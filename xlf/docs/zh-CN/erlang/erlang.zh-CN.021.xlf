<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">在这里，我们检查来自postgres的结果。如果是数据，我们将其编码为带有列数据的列表列表。postgres中的所有内容都是C字符串，因此我们使用 &lt;code&gt;ei_x_encode_string&lt;/code&gt; 将结果作为字符串发送到Erlang。（列表的开头包含列名。）</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">在这里,我们创建了一个包含Erlang代码和Beam代码的归档脚本,然后我们对归档中的所有文件进行迭代,并收集它们的内容和一些相关信息。</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">在这里，我们创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件，并将其放置在目录 &lt;code&gt;../projectdir&lt;/code&gt; 中。该文件包含有关这三个文件的功能，记录和宏定义的信息。</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">在这里，我们或多或少地仅实现了 &lt;code&gt;get_until&lt;/code&gt; 并使用内部助手来实现 &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_line&lt;/code&gt; 。在生产代码中，这可能效率低下，但这取决于不同请求的频率。在开始实现功能 &lt;code&gt;put_chars/2&lt;/code&gt; 和 &lt;code&gt;get_until/5&lt;/code&gt; 之前，我们检查了一些剩余的请求：</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">在这里我们看到,没有一个函数有很大的区别,这是很正常的。</target>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">在这里，您可以看到 &lt;code&gt;|&lt;/code&gt; 的使用。从列表中获取前两个元素。如果尝试从列表中获取的元素多于列表中的元素，则会返回错误。还要注意没有元素[]的列表的特殊情况：</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">这里还有一个例子。</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">在此， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是任何表达式， &lt;code&gt;M0&lt;/code&gt; 至 &lt;code&gt;M4&lt;/code&gt; 是结果映射项。</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">在这里，&amp;ldquo; &lt;code&gt;Arguments&lt;/code&gt; 是零个或多个参数的列表。该 &lt;code&gt;-callback&lt;/code&gt; 属性是首选，因为额外的类型信息，可以通过工具来产生的文档或找到差异。</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">在这里， &lt;code&gt;Bin&lt;/code&gt; 是绑定的，元素是绑定或未绑定的，就像在任何匹配中一样。</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">在这里， &lt;code&gt;Expr&lt;/code&gt; 是一个任意表达式，每个 &lt;code&gt;Qualifier&lt;/code&gt; 都是生成器或过滤器。</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">在这里， &lt;code&gt;Fd&lt;/code&gt; 是目标文件或原子 &lt;code&gt;standard_io&lt;/code&gt; 的文件描述符。 &lt;code&gt;_TraceInfo&lt;/code&gt; 包含来自跟踪信息文件的信息（请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;State&lt;/code&gt; 是格式处理程序fun的状态变量。变量 &lt;code&gt;State&lt;/code&gt; 的初始值由处理程序选项指定，例如：</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">在这里， &lt;code&gt;File&lt;/code&gt; 被用作新的变量，而不是 &lt;code&gt;X&lt;/code&gt; 。这不是那么明智，因为乐趣主体中的代码无法引用在乐趣之外定义的变量 &lt;code&gt;File&lt;/code&gt; 。编译此示例将给出以下诊断：</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">在此， &lt;code&gt;S1LogDir&lt;/code&gt; 和 &lt;code&gt;S2LogDir&lt;/code&gt; 分别是每个测试的名为 &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; 的目录。</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">在这里， &lt;code&gt;conn_types&lt;/code&gt; 指定SSH，Telnet，FTP，RPC和/或SNMP。</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;demo()&lt;/code&gt; 评估为 &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">在这里， &lt;code&gt;init&lt;/code&gt; 不需要任何输入数据，并且会忽略其参数。对于 &lt;code&gt;terminal_logger&lt;/code&gt; ，不使用内部状态。对于 &lt;code&gt;file_logger&lt;/code&gt; ，内部状态用于保存打开的文件描述符。</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">这里， &lt;code&gt;tuplep&lt;/code&gt; 指向一个 &lt;code&gt;ETERM&lt;/code&gt; 表示与两个元素的元组结构; 函数名称（atom）和参数（整数）。使用函数 &lt;code&gt;erl_element()&lt;/code&gt; 从 &lt;code&gt;erl_eterm&lt;/code&gt; ，这些元件可被提取，但它们也必须被声明为指针的 &lt;code&gt;ETERM&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">在这里，与C的通信隐藏在 &lt;code&gt;complex.erl&lt;/code&gt; 的实现中。在以下各节中，显示了如何使用不同的互操作性机制来实现此模块。</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">在这里，数据类型 &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; 表示为以下Erlang记录：</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">在这里，指令 &lt;code&gt;on_load&lt;/code&gt; 用于获取函数 &lt;code&gt;init&lt;/code&gt; ，以便在模块加载时自动调用该函数。如果 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; 以外的任何内容，例如在此示例中NIF库的加载失败时，则模块将被卸载，并且对其中的函数的调用将失败。</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">在此，处理程序还提供了动态重载配置变量的功能。如果从测试用例函数中调用了 &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; ,则使用 &lt;code&gt;config_driver:read_config/1&lt;/code&gt; 加载的所有变量都将使用其最新值进行更新，并返回变量 &lt;code&gt;localtime&lt;/code&gt; 的新值。</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">在此，执行（和可能重复）与前面示例相同的测试运行。但是，如果发生超时，则在1小时后，&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; &amp;rdquo;会在停止之前完成整个测试运行（即 &lt;code&gt;to1&lt;/code&gt; 和 &lt;code&gt;to2&lt;/code&gt; 始终在同一测试运行中执行）。</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">在这里，运行与示例1相同的测试，但是将标志 &lt;code&gt;force_stop&lt;/code&gt; 设置为 &lt;code&gt;skip_rest&lt;/code&gt; 。如果在目录 &lt;code&gt;to1&lt;/code&gt; 中执行测试时发生超时，则会跳过 &lt;code&gt;to1&lt;/code&gt; 中其余的测试用例，并且中止测试，而无需再次运行 &lt;code&gt;to2&lt;/code&gt; 中的测试。如果在目录 &lt;code&gt;to2&lt;/code&gt; 中执行测试时发生超时，则跳过 &lt;code&gt;to2&lt;/code&gt; 中其余的测试用例，并终止测试。</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">在这里，与 &lt;code&gt;Opts&lt;/code&gt; 变量相对应的段具有&lt;strong&gt;类型修饰符&lt;/strong&gt;，指定 &lt;code&gt;Opts&lt;/code&gt; 将绑定到二进制文件。所有其他变量的默认类型等于无符号整数。</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">在此，在一次测试运行中执行测试目录 &lt;code&gt;to1&lt;/code&gt; 中的套件，然后是 &lt;code&gt;to2&lt;/code&gt; 中的套件。10分钟后发生超时事件。只要还有时间， &lt;code&gt;Common Test&lt;/code&gt; 就会重复测试运行（即从test &lt;code&gt;to1&lt;/code&gt; 重新开始）。超时后，当完成当前作业时， &lt;code&gt;Common Test&lt;/code&gt; 停止（由于标志 &lt;code&gt;force_stop&lt;/code&gt; ）。结果，可以在测试 &lt;code&gt;to1&lt;/code&gt; 之后和测试 &lt;code&gt;to2&lt;/code&gt; 之前中止指定的测试运行。</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">在此，将包括 &lt;code&gt;to1&lt;/code&gt; 和 &lt;code&gt;to2&lt;/code&gt; 测试在内的测试运行重复五次。</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">在这里,先运行 &quot;ts1 &quot;指定的测试,然后运行 &quot;ts2 &quot;指定的测试,最后运行 &quot;ts3 &quot;和 &quot;ts4 &quot;指定的测试。</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">在这里，在乐趣开头定义的变量 &lt;code&gt;X&lt;/code&gt; 是一个新变量。乐趣中使用的变量 &lt;code&gt;Stream&lt;/code&gt; 从 &lt;code&gt;file:open&lt;/code&gt; 行获取其值。</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">此处， &lt;code&gt;div.error&lt;/code&gt; 打印输出使用白色文本代替默认黑色（并且不影响 &lt;code&gt;pre&lt;/code&gt; 的其他属性设置）。</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">在这里， &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 具有以下参数：</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">十六进制数字</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">以下系统会自动启用HiPE。</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">HiPE支持以下系统配置。</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">隐藏菜单。</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">高容错率</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">高层指示</target>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前操作系统单调时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; ，以每秒为单位。如果无法从OS检索到分辨率信息，则 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 与分辨率一致。但是，您确实知道精度并不比 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前OS系统时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; （以每秒为单位）。如果无法从OS检索到分辨率信息，则 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 做到对齐决议。但是，您确实知道精度并不比 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Hmac功能- &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">挂钩选项 &lt;code&gt;log_type&lt;/code&gt; 可用于更改 &lt;code&gt;cth_conn_log&lt;/code&gt; 行为。此选项的默认值为 &lt;code&gt;raw&lt;/code&gt; ，这将导致上述行为。如果该值设置为 &lt;code&gt;html&lt;/code&gt; ，则所有Telnet通信都将打印到测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">钩子选项 &lt;code&gt;log_type&lt;/code&gt; 指定日志记录的类型：</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">在配置文件中指定的钩子选项覆盖了测试套件中任何硬编码的钩子选项。</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">配置文件中指定的钩子选项覆盖了测试套件中的硬编码钩子选项。</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">在发送出站请求时,按直径设置逐跳和端到端标识符。</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">水平片 (HT)</target>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">主机= &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">找不到主机,找不到FTP服务器,或者连接被FTP服务器拒绝。</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">主机密钥算法。</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">主机钥匙</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">主机公钥</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">主机-IP-地址AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">主机名提取</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">Hostname是在调用这个funcion的Erlang节点中调用net_adm:localhost()的结果。</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">节点的 &lt;code&gt;host&lt;/code&gt; 名，主机</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">主机名和主机地址</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">&amp;ldquo;如何将类别映射到CSS标记&amp;rdquo; 在&amp;ldquo;运行测试和分析结果&amp;rdquo; 部分的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">代码如何编译和加载不是语言问题,而是取决于系统。本节介绍了Erlang/OTP中的编译和代码加载,并引用了文档中的相关部分。</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">在输出带有时间戳之前，Erlang需要停用多长时间。默认为 &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; ，最小值为1。</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">在将 &quot;ALIVE &quot;消息写入日志之前等待输出的时间(分钟)。默认值为15,最小值为1。</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">从套接字读取（接收到）多少个字节，以与 &lt;code&gt;sent&lt;/code&gt; 相似的方式使用。</target>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">通过套接字发送了多少字节。这可以进行包装，但这对于发行版来说不是问题，因为Erlang发行版仅在此值已更改时才感兴趣。（Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 通过调用驱动程序来获取它来使用此值，这是通过 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 例程完成的。）</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">如何绑定调度器很重要。例如,在运行进程少于在线调度器的情况下,运行时系统会尝试将进程迁移到调度器标识较低的调度器上。在这种情况下,调度器在硬件上的分布越多,运行时系统的资源就越多。</target>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">如何构建一个启用调试的Erlang RunTime系统?</target>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">如何与外界和其他语言（端口）编写的软件进行通信； &lt;code&gt;Interoperability Tutorial&lt;/code&gt; 对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何处理传入消息中&amp;ldquo;直径标题&amp;rdquo;的&amp;ldquo;消息长度&amp;rdquo;字段中的错误。在这种情况下的错误是，该长度不是至少20个字节（标头的长度），不是4的倍数（有效长度），或者不是通过传输接收到的相关消息的长度接口记录在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">如何在目标环境中安装发行版,在第2节系统原理中关于目标系统的部分有介绍。</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何应用程序中描述 &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何计划版本中描述 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">本节介绍如何通过从主代理发送 &lt;code&gt;fTrap&lt;/code&gt; 来发送陷阱。主代理已加载MIB &lt;code&gt;EX1-MIB&lt;/code&gt; ，并在其中定义了陷阱。该陷阱指定应与陷阱一起发送两个变量 &lt;code&gt;myName&lt;/code&gt; 和 &lt;code&gt;fIndex&lt;/code&gt; 。 &lt;code&gt;fIndex&lt;/code&gt; 是一个表列，因此我们必须在调用 &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; 时提供其值和该行的索引。在下面的示例中，我们假设所讨论的行的索引为2（ &lt;code&gt;fIndex&lt;/code&gt; 为 2 的行）。</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">如何启动和停止应用程序的代码,也就是监督树,由两个回调函数描述。</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">可以从书籍和Internet上的许多页面中学习如何编写 &lt;code&gt;d&lt;/code&gt; 程序或 &lt;code&gt;systemtap&lt;/code&gt; 脚本。本手册页不包含有关使用相应平台的动态跟踪工具的任何文档。但是， &lt;code&gt;runtime_tools&lt;/code&gt; 应用程序的 &lt;code&gt;examples&lt;/code&gt; 目录包含 &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;systemtap&lt;/code&gt; 程序的综合示例，可帮助您入门。另一个信息来源是《运行时工具用户指南》中的 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; 章节。</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">但是，NTP不是故障安全的。 NTP服务器可能不可用， &lt;code&gt;ntp.conf&lt;/code&gt; 可能配置错误，或者您的计算机有时可能与Internet断开连接。此外，您可能有一个用户（甚至系统管理员）认为处理夏时制的正确方法是一年两次调整时钟一次（这是不正确的方法）。更复杂的是，该用户从Internet上获取了您的软件，但并未考虑计算机认为正确的时间。用户并不关心使挂钟与正确的时间保持同步。用户希望您的程序对时间有无限的了解。</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">然而,以这种方式启动的节点拒绝与其他节点对话,因为没有提供TLS参数(见下一节)。</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">但是,不允许使用非完整字节的位串,所以UTF字符必须沿8位边界分割才能被解码。</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">但是，还可以使用 &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; 解码证书，该证书可以自定义和递归解码证书的标准部分：</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">但是,转义其他非字母数字字符并无大碍。</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">但是，对于 &lt;code&gt;SET OF&lt;/code&gt; 类型的值，DER编码格式要求元素以其编码的升序发送，这意味着运行时的排序过程很昂贵。因此 &lt;code&gt;SET OF&lt;/code&gt; 如果可能 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 建议使用SEQUENCE OF代替SET OF。</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">然而,在这里你可以找到一些如何使用xmerl的例子,以及使用xmerl的目的。用户界面的详细描述可以在参考手册中找到。</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">然而，如果 &lt;code&gt;cp1&lt;/code&gt; 也重新启动，则该函数 &lt;code&gt;application:takeover/2&lt;/code&gt; 移动 &lt;code&gt;myapp&lt;/code&gt; 到 &lt;code&gt;cp1&lt;/code&gt; ，如 &lt;code&gt;cp1&lt;/code&gt; 具有比较高的优先级 &lt;code&gt;cp3&lt;/code&gt; 这种应用。在这种情况下， &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; 在被执行 &lt;code&gt;cp1&lt;/code&gt; 以启动应用程序。</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">但是,如果一个量化符后面加一个问号,它就不再贪婪,而是尽可能地减少匹配次数,所以下面的模式用C注释做了正确的事情。</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">但是，如果另一个进程已加载驱动程序，调用 &lt;code&gt;reload_driver&lt;/code&gt; 返回错误代码 &lt;code&gt;pending_process&lt;/code&gt; 。如前所述，建议的设计是不允许&amp;ldquo;驱动程序重新加载器&amp;rdquo;以外的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 要求加载相关驱动程序。</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">但是，如果反斜杠后面的十进制数字&amp;lt;10，则始终将其用作反向参考，并且仅在整个模式中没有太多捕获左括号的情况下才会引起错误。也就是说，对于数字&amp;lt;10，引用的括号不必位于引用的左侧。当涉及重复并且右侧的子模式已参与到重复操作中时，这种类型的&amp;ldquo;正向引用&amp;rdquo;可能很有意义。较早的迭代。</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">但是,如果第一个模式不匹配,则测试第二个模式。如果匹配,则从队列中删除消息,并执行与第二个模式对应的操作。如果第二个模式不匹配,则尝试第三个模式,以此类推,直到没有更多的模式可供测试。如果没有更多的模式可供测试,第一条消息将被保留在队列中,并尝试第二条消息。如果这与任何模式相匹配,则执行适当的操作,并将第二条消息从队列中移除(保留队列中的第一条消息和任何其他消息)。如果第二条消息不匹配,则尝试第三条消息,以此类推,直到到达队列的末端。如果到达队列的末端,进程就会阻塞(停止执行)并等待,直到收到新的消息,然后重复这个过程。</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">但是，如果输入 &lt;code&gt;Data&lt;/code&gt; 是纯二进制，则错误元组的第三部分也保证是二进制。</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">然而,如果创建表时使用显式记录名作为参数,如下面的示例所示,则无论表名如何,订阅者记录都可以存储在两个表中。</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">但是，如果这样做并生成了 &lt;code&gt;relup&lt;/code&gt; 文件，则它不仅将包含用于重启（即删除和添加） &lt;code&gt;prim_app&lt;/code&gt; 的指令，还将包含用于启动 &lt;code&gt;ch_app&lt;/code&gt; （并在降级的情况下将其停止）的指令。。这是因为 &lt;code&gt;ch_app&lt;/code&gt; 包含在新的 &lt;code&gt;.rel&lt;/code&gt; 文件中，而不包含在旧的.rel文件中。</target>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">但是，如果按以下方式调用 &lt;code&gt;escript&lt;/code&gt; ，则第一行的内容无关紧要，但是它不能包含Erlang代码，因为它将被忽略：</target>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">但是，在解 &lt;code&gt;sys.config&lt;/code&gt; 之后但在运行发行版之前，在目标上的sys.config中替换变量也很方便。如果您有 &lt;code&gt;sys.config.src&lt;/code&gt; ，它将包含在内，并且不需要像 &lt;code&gt;sys.config&lt;/code&gt; 这样的有效Erlang术语文件。在运行发行版之前，您必须在同一目录中具有有效的 &lt;code&gt;sys.config&lt;/code&gt; ，因此，使用 &lt;code&gt;sys.config.src&lt;/code&gt; 需要具有一些工具来填充所需内容，并在启动发行版之前将 &lt;code&gt;sys.config&lt;/code&gt; 写入磁盘。</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">但是,如果改写成使用两个顶级分支,PCRE是可以接受的。</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">不过,是否考虑这些额外的信息,要由处理规格的工具来选择。</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">但是，可能存在更多的点分隔部分。点分隔的部分由非负整数组成。如果所有小于 &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 的不重要部分都等于 &lt;code&gt;0&lt;/code&gt; ，则将其省略。三个 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 部分&amp;lt;Major&amp;gt;。&amp;lt;Minor&amp;gt;。&amp;lt;Patch&amp;gt;更改如下：</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">但是，由于 &lt;code&gt;{foo, false}&lt;/code&gt; 遮盖了 &lt;code&gt;foo&lt;/code&gt; ，因此在下面的调用中未进行任何扩展：</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">但是,请注意,如果使用脏操作来更新数据库,就有可能使数据库处于不一致的状态。只有在绝对必要的情况下,出于性能考虑才会使用脏操作。</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">然而,这种简单的行为可以通过多种方式进行修改。例如,Net if进程可以对字节应用某种加密/解密方案,或者充当代理过滤器,将一些数据包发送到代理代理代理,将一些数据包发送到主代理。</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">然而,这种简单的行为可以通过多种方式进行修改。例如,Net if进程可以对字节应用某种加密/解密方案。</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">但是,在某些情况下,不能使用这种优化。当.*位于捕获括号内,而括号又是模式中其他地方的反向引用的主题时,开始时的匹配可能会失败,而后来的匹配则会成功。例如,可以考虑</target>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">但是，此过程可能很耗时，快捷功能 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 以更快的速度从磁盘加载所有表。无论网络情况如何，该功能都会强制从光盘加载表。</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">然而,为了避免旧的(R14之前的)代码在用OTP版本R14A或更高版本编译时改变其行为,以下限制适用。如果你覆盖了一个在R14A之前的OTP版本(ERTS 5.8版本)中自动导入的BIF的名称,并且在你的代码中对该函数有一个隐式限定的调用,你需要使用编译器指令显式地删除自动导入,或者用一个完全限定的函数调用替换该调用。否则你会得到一个编译错误。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">但是，例如在使用IA5String（与ASCII非常相似）时，字节65（以十进制表示）&lt;strong&gt;表示&lt;/strong&gt;字符'A'。</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">Http客户端服务启动/停止</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Http数据类型</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">连字符(只有在它可以被解释为指定范围的情况下)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">SMIv2中允许使用连字符(一种务实的方法)。原因是根据SMIv2,从SMIv1转换而来的对象允许使用连字符,但其他对象不允许。这对于编译器来说是无法检查的。</target>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">I/O错误。</target>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">I/O是目前Unicode最棘手的领域。文件是一个存储字节的实体,而编程的传说是把字符和字节当作可以互换的。对于Unicode字符,当你想在文件中存储数据时,你必须决定一个编码。在Erlang中,你可以打开一个带有编码选项的文本文件,这样你就可以从文件中读取字符而不是字节,但你也可以打开一个文件进行字节式I/O。</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">I/O库功能。</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">I / O服务器的行为略有不同。无论使用哪种编码选项，连接到终端（或 &lt;code&gt;stdout&lt;/code&gt; ）的I / O服务器通常都可以处理Unicode数据。当人们期望使用现代环境，而又不想在写入古老的终端或管道时崩溃时，这很方便。</target>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">整个系统中的I / O服务器可以处理Unicode数据，并具有用于在设备输出或输入时转换数据的选项。如前所述， &lt;code&gt;shell&lt;/code&gt; 模块支持Unicode终端， &lt;code&gt;file&lt;/code&gt; 模块允许与磁盘上的各种Unicode格式进行相互转换。</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">IANA的考虑因素</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC(Erlang IDL Compiler)是一个接口生成器,给定一个IDL接口规范,它可以自动生成Erlang、C或Java的存根代码。请参阅《IC用户指南》和《IC参考手册》。</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">IC文件。它运行IDL编译器。</target>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF--该协议称为Megaco。</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG(Interface Generator)自动生成Erlang程序和C程序之间的端口或套接字通信代码,给定一个带有某些关键字的C头文件。</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-从Erlang/OTP R6B中删除。</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP(CORBA)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">INTEGER,INT,SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">IP地址， &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">将主机地址指定为 &lt;code&gt;any&lt;/code&gt; IP地址时使用的IP版本。</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">IPsec对直径是透明的。</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1（0-255，每个字节一个字符）。在此，将案例参数 &lt;code&gt;InEncoding&lt;/code&gt; 指定为 &lt;code&gt;latin1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">国际电联--该组织将该协议称为H.248。</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;ssh&lt;/code&gt; 通道的ID 。</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">理想情况下,你的代码只包含第一种类型的高效代码。如果发现太慢,可以对应用程序进行剖析,找出性能瓶颈所在,只优化瓶颈。让其他代码尽可能的保持干净。</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">所标识的处理器状态在不同的操作系统上可能有所不同，并且可能在同一操作系统的不同版本的 &lt;code&gt;cpu_sup&lt;/code&gt; 之间更改。但是，在所有繁忙和所有非繁忙处理器状态下所花费的CPU周期百分比份额的总和将始终总计为100％。</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">标识并返回在缓冲区中编码的Erlang术语的类型。它跳过尾随的&lt;strong&gt;魔术&lt;/strong&gt;标识符。</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">标明文件所在的文件系统。在Windows中,数字表示一个驱动器,如下所示。0表示A:,1表示B:,以此类推。</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">标识要使用的密钥。格式取决于加载的引擎。它被传递到libcrypto中的 &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">确定要按什么信息排序。</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">通过数字来识别捕捉小括号是很简单的,但在复杂的正则表达式中很难跟踪数字。另外,如果修改了表达式,数字也会发生变化。为了帮助解决这个困难,PCRE支持子模式的命名。这个功能直到5.10版本才被添加到Perl中。Python更早有这个功能,PCRE在4.0版本时就引入了这个功能,使用的是Python语法。现在PCRE同时支持Perl和Python语法。Perl允许相同编号的子模式有不同的名字,但PCRE不允许。</target>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">意识形态空间</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">如果(*ACCEPT)在捕获括号内,则捕获到目前为止的数据。例如,下面匹配 &quot;AB&quot;、&quot;AAD &quot;或 &quot;ACD&quot;。当符合 &quot;AB &quot;时,&quot;B &quot;被外括号捕获。</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">如果（* COMMIT）是唯一遇到的回溯动词，则在传递完后， &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 会在当前起始点或根本不寻找匹配项，例如：</target>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Kernel&lt;/code&gt; 中的 &lt;code&gt;global&lt;/code&gt; 模块已知 &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; ，则将返回一个Erlang pid，可用于将消息发送到计划服务。同样，将 &lt;code&gt;node&lt;/code&gt; 初始化为包含注册服务的节点的名称，以便您可以通过简单地将变量传递给 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 来与其建立连接。</target>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">如果使用了 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; ，则所有事件都在 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 中处理，我们可以（但不必）使用以事件为中心的方法，在该方法中，我们首先根据事件进行分支，然后根据状态进行分支：</target>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 没有返回这样的列表，则没有状态回叫完成。</target>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 返回包含 &lt;code&gt;state_enter&lt;/code&gt; 的列表，则 &lt;code&gt;gen_statem&lt;/code&gt; 引擎将在每次状态更改时使用参数 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。这可能看起来像一个事件，但实际上是在先前的状态回调返回之后，任何事件传递到新的状态回调之前执行的调用。参见 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 。可以通过从状态回调返回 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 元组来重复此调用。</target>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 应该转换状态，则将其视为状态重命名而不是状态更改，这不会引起状态回车。</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则当前事件被推迟。</target>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，并且是：状态更改，它是初始状态，或者使用回调结果 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 中的一个；在 &lt;code&gt;gen_statem&lt;/code&gt; 调用带有参数的新状态回调 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; ，则只使用一个系统配置文件，而该文件称为 &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">如果 &lt;code&gt;Abs&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则启动一个绝对计时器，如果为 &lt;code&gt;false&lt;/code&gt; ，则为一个相对值，这是默认值。有关详细信息，请参见 &lt;code&gt;erlang:start_timer/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">如果 &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; ，则 &lt;code&gt;Suspendee&lt;/code&gt; 者当前处于挂起状态。</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Alg&lt;/code&gt; 是 &lt;code&gt;crypto&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; 则此函数的行为与rand_seed_s / 0完全相同。</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">如果 &lt;code&gt;Alg&lt;/code&gt; 是 &lt;code&gt;crypto_cache&lt;/code&gt; ,则此函数使用OpenSSL的 &lt;code&gt;RAND_bytes&lt;/code&gt; 获取随机数据，并使用56位内部字长将其高速缓存，这使得在64位计算机上的计算速度更快。</target>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">如果 &lt;code&gt;Asn1module&lt;/code&gt; 是不带扩展名的文件名，则首先假定为 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; ，然后为 &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; ，最后为 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; （与旧的ASN.1编译器兼容）。 &lt;code&gt;Asn1module&lt;/code&gt; 可以是完整路径名（相对或绝对），包括带（或不带）扩展名的文件名。</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">如果 &lt;code&gt;Bin&lt;/code&gt; 不包含整个数据包，则返回 &lt;code&gt;{more,Length}&lt;/code&gt; 。 &lt;code&gt;Length&lt;/code&gt; 是预期的数据包&lt;strong&gt;总大小&lt;/strong&gt;，如果预期的数据包大小未知，则为 &lt;code&gt;undefined&lt;/code&gt; 。然后可以在添加更多数据的情况下再次调用 &lt;code&gt;decode_packet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">如果省略 &lt;code&gt;BinRel1&lt;/code&gt; ,则改为使用 R [i]范围（范围R [1]&amp;times;...&amp;times;范围R [n]）的 &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; 元素之间的相等关系（直觉上，什么都不是&amp;ldquo;丢失&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;Binaries&lt;/code&gt; 不是二进制的固定列表，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">如果 &lt;code&gt;Binary&lt;/code&gt; 包含模块 &lt;code&gt;Module&lt;/code&gt; 的目标代码，则此BIF加载该目标代码。如果模块 &lt;code&gt;Module&lt;/code&gt; 的代码已经存在，则将替换所有导出引用，以便它们指向新加载的代码。先前加载的代码将作为旧代码保留在系统中，因为仍然会有执行该代码的进程。</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">如果 &lt;code&gt;BlockState =:= block&lt;/code&gt; ，则会阻止多调度。也就是说，将执行一个并且只有一个调度程序线程。如果 &lt;code&gt;BlockState =:= unblock&lt;/code&gt; 并且没有其他人阻止多重调度，并且此过程仅被阻止一次，则多重调度将被解除阻止。</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">如果 &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; ，则会阻止常规多调度。也就是说，将仅执行一个正常的调度程序线程，但可以执行多个脏调度程序。如果 &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; 并且没有其他人阻止正常的多调度，并且此过程仅阻塞了一次，则正常的多调度将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">如果返回 &lt;code&gt;Body&lt;/code&gt; 并等于 &lt;code&gt;{Fun,Arg}&lt;/code&gt; ，则Web服务器将以 &lt;code&gt;Arg&lt;/code&gt; 作为参数尝试对 &lt;code&gt;Fun&lt;/code&gt; &lt;code&gt;apply/2&lt;/code&gt; 。 web服务器期望的乐趣或者返回一个列表 &lt;code&gt;(Body)&lt;/code&gt; ，其为HTTP repsonse，或原子 &lt;code&gt;sent&lt;/code&gt; 如果HTTP响应被发送回客户端。如果从乐趣中返回了 &lt;code&gt;close&lt;/code&gt; ，则出了点问题，服务器通过关闭连接向客户端发出信号。</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">如果 &lt;code&gt;Bool&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则 &lt;code&gt;rb&lt;/code&gt; 对于遇到的每个错误报告，都会向 &lt;code&gt;stdout&lt;/code&gt; 打印一条错误消息，但是日志记录过程永远不会结束。所有可打印的报告均已写入。如果启用了记录到文件的功能，则 &lt;code&gt;rb&lt;/code&gt; 在日志文件中不可打印报告的位置打印 &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">如果 &lt;code&gt;Bool&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，如果遇到格式错误的报告，则 &lt;code&gt;rb&lt;/code&gt; 停止日志记录（并向 &lt;code&gt;stdout&lt;/code&gt; 输出错误消息）。如果启用了记录到文件的功能，则错误消息也会附加到日志文件中。</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">如果 &lt;code&gt;Boolean == true&lt;/code&gt; ，则为套接字打开选项 &lt;code&gt;TCP_NODELAY&lt;/code&gt; ，这意味着也会立即发送少量数据。</target>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Button&lt;/code&gt; 是顶级类型，并且需要从解码中排除组件 &lt;code&gt;number&lt;/code&gt; ，则配置文件中指令中的 &lt;code&gt;Type_List&lt;/code&gt; 为 &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; 。如果您调用解码函数 &lt;code&gt;decode_Button_exclusive&lt;/code&gt; ，则 &lt;code&gt;Decode_Instruction&lt;/code&gt; 为 &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; }。</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">如果 &lt;code&gt;Common Test&lt;/code&gt; Master最初未能连接到测试规范或 &lt;code&gt;InclNodes&lt;/code&gt; 列表中指定的任何测试节点，则会提示操作员选择重新开始（手动检查相关节点的状态之后）的选项，在没有丢失节点的情况下运行，或者中止该操作。</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">如果 &lt;code&gt;CurrentIndentation&lt;/code&gt; 为负，则不存在换行符，仅将空格用作分隔符。</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">如果 &lt;code&gt;Data&lt;/code&gt; 是无效的I / O列表。</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; 的格式为 &lt;code&gt;{DateTo, to}&lt;/code&gt; ，则显示在 &lt;code&gt;DateTo&lt;/code&gt; 之前发生的报告。</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; ，则它必须是在当前运行时系统实例上创建的进程的 &lt;code&gt;pid()&lt;/code&gt; 。此过程已终止或未终止。如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;atom()&lt;/code&gt; ，则将其解释为本地注册进程的名称。在计时器到期时会查询名称所指的过程。如果名称不引用进程，则不会返回任何错误。</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; ，则如果 &lt;code&gt;pid()&lt;/code&gt; 所引用的进程未激活或退出，计时器将自动取消。ERTS 5.4.11中引入了此功能。请注意，当 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;atom()&lt;/code&gt; 时，计时器不会自动取消。</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Destination&lt;/code&gt; 引用文件名，则在复制之前将其以 &lt;code&gt;write&lt;/code&gt; 模式添加到模式列表之前打开，并在完成后关闭。</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">如果 &lt;code&gt;Dir&lt;/code&gt; 不存在</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;Distributed == default&lt;/code&gt; ，则使用内核配置参数 &lt;code&gt;distributed&lt;/code&gt; 中的应用程序值。</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">如果 &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; ，则该应用程序变为分布式。该参数会覆盖&amp;ldquo; &lt;code&gt;distributed&lt;/code&gt; &amp;rdquo;内核配置参数中应用程序的值。 &lt;code&gt;Application&lt;/code&gt; 必须是应用程序名称（与第一个参数相同）。如果节点崩溃并指定了 &lt;code&gt;Time&lt;/code&gt; ，则应用程序控制器将等待 &lt;code&gt;Time&lt;/code&gt; 毫秒，然后再尝试在另一个节点上重新启动应用程序。如果未指定 &lt;code&gt;Time&lt;/code&gt; ，则默认为 &lt;code&gt;0&lt;/code&gt; ，应用程序将立即重新启动。</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Encoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则在可能时将整数列表 &lt;code&gt;0..255&lt;/code&gt; 或包含纯字节的二进制文件发送回客户端。如果 &lt;code&gt;Encoding&lt;/code&gt; 是 &lt;code&gt;unicode&lt;/code&gt; ，则将具有整个Unicode范围内的整数的列表或以UTF-8编码的二进制文件发送到客户端。用户提供的函数始终会看到整数列表，而不会看到二进制列表，但是如果 &lt;code&gt;Encoding&lt;/code&gt; 为 &lt;code&gt;unicode&lt;/code&gt; ，则该列表可以包含大于255的数字。</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">如果 &lt;code&gt;End == close&lt;/code&gt; ，则当服务器关闭通道时，数据将返回给调用方。如果在此之前发生 &lt;code&gt;{timeout,Data}&lt;/code&gt; ，该函数将返回{timeout，Data}（其中， &lt;code&gt;Data&lt;/code&gt; 是到目前为止接收到的数据）。</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">如果 &lt;code&gt;End == timeout&lt;/code&gt; ，则期望超时，并且在超时的情况下和通道关闭时都返回 &lt;code&gt;{ok,Data}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">如果 &lt;code&gt;End&lt;/code&gt; 是一个有趣的事情，则使用一个参数调用此有趣的事情，即接收到的 &lt;code&gt;ssh_cm&lt;/code&gt; 消息中的数据值（请参阅 &lt;code&gt;ssh_connection(3)&lt;/code&gt; 。有趣的是返回 &lt;code&gt;true&lt;/code&gt; 结束接收操作（并返回到目前为止收集的数据） ）或 &lt;code&gt;false&lt;/code&gt; 以等待来自服务器的更多数据。即使提供了乐趣，如果服务器关闭通道，该函数也会立即返回。</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">如果ASN.1规范中不存在 &lt;code&gt;EnumTypeName&lt;/code&gt; ，则编译将以错误代码停止。</target>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将事件管理器全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则未注册事件管理器。</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将事件管理器注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; ，则事件管理器将使用 &lt;code&gt;Module&lt;/code&gt; 表示的注册表进行注册。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出的功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现为在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;EventType&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; ，则呼叫者等待答复。通过在 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 中使用 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 返回，在 &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 中或通过调用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; ，可以从此 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 或任何其他状态回调中发送答复。</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果 &lt;code&gt;Expr1&lt;/code&gt; 计算为一个名称，但未注册该名称，则会发生 &lt;code&gt;badarg&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">如果 &lt;code&gt;ExprF&lt;/code&gt; 是一个原子，则称该函数是通过使用&lt;strong&gt;隐式限定函数名称&lt;/strong&gt;调用的。如果函数 &lt;code&gt;ExprF&lt;/code&gt; 是本地定义的，则将调用它。或者，如果从 &lt;code&gt;M&lt;/code&gt; 模块显式导入 &lt;code&gt;ExprF&lt;/code&gt; ，则调用 &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; 。如果 &lt;code&gt;ExprF&lt;/code&gt; 既未在本地声明，也未明确导入，则 &lt;code&gt;ExprF&lt;/code&gt; 必须是自动导入的BIF的名称。</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;log&lt;/code&gt; ，则允许匹配事件。如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;stop&lt;/code&gt; ，则匹配事件将停止。</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;log&lt;/code&gt; ，则允许进度报告。如果 &lt;code&gt;Extra&lt;/code&gt; 的 &lt;code&gt;stop&lt;/code&gt; ，进度报告被停止。</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">如果 &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;P&lt;/code&gt; 或 &lt;code&gt;Pad&lt;/code&gt; 是 &lt;code&gt;*&lt;/code&gt; 字符，则 &lt;code&gt;Data&lt;/code&gt; 中的下一个参数用作值。例如：</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">如果 &lt;code&gt;FIPS_mode_set&lt;/code&gt; 返回 &lt;code&gt;no&lt;/code&gt; OpenSSL库不是FIPS启用，密码将不支持FIPS模式两种。</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family3&lt;/code&gt; 是家庭，使得索引集合等于索引集合的 &lt;code&gt;Family1&lt;/code&gt; ，和 &lt;code&gt;Family3&lt;/code&gt; [i]是之间的差 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; 如果[I] &lt;code&gt;Family2&lt;/code&gt; 映射I，否则 &lt;code&gt;Family1[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family3&lt;/code&gt; 是家庭，使得索引集合是的交集 &lt;code&gt;Family1&lt;/code&gt; ：S和 &lt;code&gt;Family2&lt;/code&gt; ：S指数集，和 &lt;code&gt;Family3&lt;/code&gt; [i]是的交点 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; [i]中。</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，那么 &lt;code&gt;Family3&lt;/code&gt; 是家庭使得指标集为联盟 &lt;code&gt;Family1&lt;/code&gt; ：S和 &lt;code&gt;Family2&lt;/code&gt; ：■索引集，以及 &lt;code&gt;Family3&lt;/code&gt; [i]是联盟 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; [I]如果两者都映射i，否则映射 &lt;code&gt;Family1&lt;/code&gt; [i]或 &lt;code&gt;Family2&lt;/code&gt; [i]。</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I] 。</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I] 。</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对于每个i在索引集合的集合的集合 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]是所述 &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I ]。</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集合的集合的集合 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I ]。</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;Family1&lt;/code&gt; 对索引集i上那些元素的 &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; ，这些元素对 &lt;code&gt;Fun&lt;/code&gt; 应用于 &lt;code&gt;Family1&lt;/code&gt; [i]返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;Fun&lt;/code&gt; 是一个元组 &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; ，然后 &lt;code&gt;Fun2&lt;/code&gt; 被施加到 &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I]，否则 &lt;code&gt;Fun&lt;/code&gt; 被施加到 &lt;code&gt;Family1&lt;/code&gt; [i]中。</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]是调用的结果而 &lt;code&gt;SetFun&lt;/code&gt; 与 &lt;code&gt;Family1&lt;/code&gt; [I]作为参数。</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; [i]是某个i的空集，则该过程将退出并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;BinRel&lt;/code&gt; 是包含所有对（i，x）的二进制关系，使得i属于 &lt;code&gt;Family&lt;/code&gt; 的索引集，而x属于 &lt;code&gt;Family&lt;/code&gt; [i]。</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">如果 &lt;code&gt;File&lt;/code&gt; 没有指定，打开一个文件对话框，在故障转储可以选择。</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">如果无法运行 &lt;code&gt;FileName&lt;/code&gt; ，则会引发错误异常，并以POSIX错误代码为原因。操作系统之间的错误原因可能有所不同。通常，尝试运行未找到的程序时会引发错误 &lt;code&gt;enoent&lt;/code&gt; ，而当指定的文件不可执行时会引发 &lt;code&gt;eacces&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;FileName&lt;/code&gt; 的后缀表示目标文件（ &lt;code&gt;.beam&lt;/code&gt; ），则EUnit将尝试从指定的文件重新加载模块并进行测试。否则，假定该文件是包含测试规范的文本文件，将使用标准库函数 &lt;code&gt;file:path_consult/2&lt;/code&gt; 读取该文件。</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">如果 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 是 &lt;code&gt;string()&lt;/code&gt; ， &lt;code&gt;make_config/1&lt;/code&gt; 将使用 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 作为文件名。创建一个名为 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 的文件，并将配置写入该文件。如果 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 是 &lt;code&gt;io_device()&lt;/code&gt; （请参阅模块 &lt;code&gt;io&lt;/code&gt; 的文档），则配置将被写入io设备。</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Filename&lt;/code&gt; 不是符号链接，则此函数返回与 &lt;code&gt;read_file_info/1&lt;/code&gt; 完全相同的结果。在不支持符号链接的平台上，此功能始终等效于 &lt;code&gt;read_file_info/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">如果 &lt;code&gt;Fix&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则调用过程将表 &lt;code&gt;Name&lt;/code&gt; 固定（一次以上），否则表将被释放。当固定过程终止时，该表也会被释放。</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;get&lt;/code&gt; ，则返回所有已记录事件的列表。</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 是 &lt;code&gt;print&lt;/code&gt; ，记录的事件被打印到 &lt;code&gt;standard_io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则开始新的订阅。如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则将停止所有使用相同 &lt;code&gt;Options&lt;/code&gt; 启动的先前订阅。如果两个选项列表包含相同的选项集，则认为它们是相同的。</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">如果 &lt;code&gt;Flags = all&lt;/code&gt; ，则设置所有可能的标志。</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;finish&lt;/code&gt; ，则处理暂挂输入，刷新暂挂输出，然后 &lt;code&gt;deflate/3&lt;/code&gt; 返回。之后，流上唯一可能的操作是 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">如果 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;full&lt;/code&gt; ，则与 &lt;code&gt;sync&lt;/code&gt; 一样刷新所有输出，并且重置压缩状态，以便如果先前的压缩数据已损坏或需要随机访问，则可以从此处重新开始解压缩。太频繁使用 &lt;code&gt;full&lt;/code&gt; 会严重降低压缩率。</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">如果将 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;sync&lt;/code&gt; ，则所有未决的输出都将刷新到输出缓冲区，并且输出在字节边界上对齐，以便解压缩器可以获取到目前为止可用的所有输入数据。刷新会降低某些压缩算法的压缩率。因此，仅在必要时使用它。</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">如果 &lt;code&gt;Force = true&lt;/code&gt; 那么即使无法加载先前的mib，代理也会继续尝试加载每个mib。小心使用。</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">如果 &lt;code&gt;Force = true&lt;/code&gt; 那么即使无法卸载先前的mib，代理也会继续尝试卸载每个mib。小心使用。</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; ， &lt;code&gt;et_viewer&lt;/code&gt; 应用程序ET中的et_viewer用于以图形方式显示跟踪日志。 &lt;code&gt;ttb&lt;/code&gt; 提供了一些不同的过滤器，可以从 &lt;code&gt;et_viewer&lt;/code&gt; 中的&lt;strong&gt;过滤器和缩放&lt;/strong&gt;菜单中选择。</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">如果 &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; ，则为每个跟踪消息调用 &lt;code&gt;Function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">如果未指定 &lt;code&gt;FormatHandler&lt;/code&gt; ，则使用默认处理程序将每个跟踪消息显示为文本行。</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">如果 &lt;code&gt;Forms&lt;/code&gt; 是 &lt;code&gt;form_list&lt;/code&gt; 以外的其他类型的语法树，则将使用 &lt;code&gt;recomment_tree/2&lt;/code&gt; 直接插入注释，并将该过程中剩下的任何注释作为后注释添加到结果中。</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">如果 &lt;code&gt;Fun(Item)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则将 &lt;code&gt;Item&lt;/code&gt; 复制到结果队列。如果返回 &lt;code&gt;false&lt;/code&gt; ，则不会复制 &lt;code&gt;Item&lt;/code&gt; 。如果返回列表，则在结果队列中插入列表元素而不是 &lt;code&gt;Item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是当地的乐趣， &lt;code&gt;Module&lt;/code&gt; 是其中的乐趣定义模块。</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是本地乐趣，则 &lt;code&gt;Name&lt;/code&gt; 是实现该乐趣的本地函数的名称。（此名称是由编译器生成的，仅供参考。由于它是本地函数，因此不能直接调用。）如果当前没有为乐趣而加载代码，则返回 &lt;code&gt;[]&lt;/code&gt; 而不是原子。</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是外部的乐趣， &lt;code&gt;Module&lt;/code&gt; 是乐趣指模块。</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是外部乐趣，则 &lt;code&gt;Name&lt;/code&gt; 是该乐趣所引用的导出函数的名称。</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">如果 &lt;code&gt;Function&lt;/code&gt; 将对象插入表中，或者另一个进程将对象插入表中，则这些对象&lt;strong&gt;可以&lt;/strong&gt;（取决于键顺序）包括在遍历中。</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">如果 &lt;code&gt;HandlerId&lt;/code&gt; 为 &lt;code&gt;default&lt;/code&gt; ，则此条目将修改默认处理程序，等效于调用</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;How == read&lt;/code&gt; 或 &lt;code&gt;Socket&lt;/code&gt; 端口没有缓冲传出数据，则套接字将立即关闭，并且 &lt;code&gt;Reason&lt;/code&gt; 中将返回遇到的任何错误。</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">如果不是 &lt;code&gt;How&lt;/code&gt; ,则没有记载的替代方法之一。</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;I&lt;/code&gt; 不是一个非负整数，或者如果数组具有固定的大小并且 &lt;code&gt;I&lt;/code&gt; 大于最大索引，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; ；比较 &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">如果 &lt;code&gt;IgnoreCase&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则该函数会在相等性测试之前即时进行 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则只要在列表中找到大于255的整数，就会发生错误。</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则二进制文件只要包含整个字节，就始终有效，因为每个字节都属于有效的ISO Latin-1范围。</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则参数 &lt;code&gt;Data&lt;/code&gt; 对应于 &lt;code&gt;iodata()&lt;/code&gt; 类型，但对于 &lt;code&gt;unicode&lt;/code&gt; ，参数 &lt;code&gt;Data&lt;/code&gt; 可以包含大于255的整数（超出ISO Latin-1范围的Unicode字符），使其作为 &lt;code&gt;iodata()&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 是Unicode类型，则无论何时发现以下任一情况，都会发生错误：</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 是UTF类型之一，则任何二进制文件中的字节必须在该编码中有效。</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Incr =:= 0&lt;/code&gt; 并且 &lt;code&gt;From =/= To&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">如果省略 &lt;code&gt;IpPort&lt;/code&gt; ,则使用 &lt;code&gt;162&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;IsDst == true&lt;/code&gt; ，则 &lt;code&gt;Localtime&lt;/code&gt; 时间位于夏令时，如果 &lt;code&gt;IsDst == false&lt;/code&gt; ，则不是。如果 &lt;code&gt;IsDst == undefined&lt;/code&gt; ，则底层操作系统可以猜测，这与调用 &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">如果 &lt;code&gt;Item&lt;/code&gt; 是无效的项目。</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;ItemList&lt;/code&gt; ，则结果为 &lt;code&gt;InfoTupleList&lt;/code&gt; 。所述 &lt;code&gt;InfoTuple&lt;/code&gt; S IN &lt;code&gt;InfoTupleList&lt;/code&gt; 包含与对应的 &lt;code&gt;Item&lt;/code&gt; 以相同的顺序作为S &lt;code&gt;Item&lt;/code&gt; 小号被列入 &lt;code&gt;ItemList&lt;/code&gt; 。有效 &lt;code&gt;Item&lt;/code&gt; 可以多次包含在 &lt;code&gt;ItemList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">如果 &lt;code&gt;Key&lt;/code&gt; 不存在，则创建一个新记录，如果该记录大于0，则该值 &lt;code&gt;Incr&lt;/code&gt; ，否则将其设置为0。</target>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">如果 &lt;code&gt;Map1&lt;/code&gt; 中存在 &lt;code&gt;Key&lt;/code&gt; ，则将旧的关联值替换为 &lt;code&gt;Value&lt;/code&gt; 。该函数返回包含新的关联值的新地图 &lt;code&gt;Map2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">如果 &lt;code&gt;KeyOrName&lt;/code&gt; 是与此ID关联的已配置 &lt;code&gt;server_id()&lt;/code&gt; 或 &lt;code&gt;target_name()&lt;/code&gt; ，则将从配置文件中获取此服务器的选项。</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">如果 &lt;code&gt;LinkTo&lt;/code&gt; 是一个pid，它将成为日志的所有者。如果 &lt;code&gt;LinkTo&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; ，则日志将通过增加 &lt;code&gt;users&lt;/code&gt; 计数器来记录该进程已匿名使用它。默认情况下，调用 &lt;code&gt;open/1&lt;/code&gt; 的进程拥有该日志。</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ListOfBinRels&lt;/code&gt; 是一个非空列表[R [1]，...，R [n]的]二元关系和 &lt;code&gt;BinRel1&lt;/code&gt; 是一个二元关系，然后 &lt;code&gt;BinRel2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; 的有序集合（R [I]的。 ..，R [n]）和 &lt;code&gt;BinRel1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">如果还有其他 &lt;code&gt;Loader&lt;/code&gt; ，则将启动用户提供的 &lt;code&gt;Loader&lt;/code&gt; 端口程序。</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是二进制文件， &lt;code&gt;tftp_binary&lt;/code&gt; 用作回调模块。将二进制文件逐块传输，并在 &lt;code&gt;LastCallbackState&lt;/code&gt; 中返回传输的字节数。</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且没有注册的回调模块， &lt;code&gt;tftp_file&lt;/code&gt; 用作回调模块。它逐块读取名为 &lt;code&gt;LocalFilename&lt;/code&gt; 的文件，并返回 &lt;code&gt;LastCallbackState&lt;/code&gt; 中传输的字节数。</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且没有注册的回调模块， &lt;code&gt;tftp_file&lt;/code&gt; 用作回调模块。它将每个传输的块写入名为 &lt;code&gt;LocalFilename&lt;/code&gt; 的文件，并返回 &lt;code&gt;LastCallbackState&lt;/code&gt; 中传输的字节数。</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且有已注册的回调模块，则针对这些模块的正则表达式测试 &lt;code&gt;LocalFilename&lt;/code&gt; ，并使用与第一个匹配项对应的回调模块，如果找不到匹配的regexp，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是 &lt;code&gt;tftp_binary&lt;/code&gt; &lt;code&gt;binary&lt;/code&gt; ，则将tftp_binary用作回调模块。它连接所有传输的块，并在 &lt;code&gt;LastCallbackState&lt;/code&gt; 中将它们作为一个二进制文件返回。</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;M&lt;/code&gt; 不是map类型，则抛出 &lt;code&gt;badmap&lt;/code&gt; 类型的异常。</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">如果在密钥交换中 &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; ，它将失败并断开连接。</target>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">如果将 &lt;code&gt;Minutes&lt;/code&gt; 设置为 &lt;code&gt;infinity&lt;/code&gt; ，则由于经过了最大时间，因此不会发生重新键入密钥。将 &lt;code&gt;Bytes&lt;/code&gt; 设置为 &lt;code&gt;infinity&lt;/code&gt; 大将禁止在传输一定数量的数据后重新键入密钥。如果选项值设置为 &lt;code&gt;{infinity, infinity}&lt;/code&gt; ，则不会启动密钥更新。请注意，仍将执行由对等方发起的重新生成密钥。</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 检测到不一致的交易决策，则会生成 &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; 系统事件，以使应用程序有机会安装后备或其他适当的措施来解决不一致问题。 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序的默认行为与数据库由于分区网络而变得不一致时的行为相同（如前所述）。</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 在启动时检测到本地节点和另一个节点都相互接收 &lt;code&gt;mnesia_down&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 会生成 &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; 系统事件，并按照上一项所述操作。</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 可能由于电源故障而检测到文件未正确关闭，它将尝试以类似方式修复损坏的文件。数据可能会丢失，但是即使数据不一致， &lt;code&gt;Mnesia&lt;/code&gt; 也可以重新启动。配置参数 &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; 可用于控制启动时 &lt;code&gt;Mnesia&lt;/code&gt; 的行为。如果 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 尝试修复该文件。如果 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 的值为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 如果检测到可疑文件，则不会重新启动。此配置参数影响日志文件 &lt;code&gt;DAT&lt;/code&gt; 的修复行为 文件和默认备份媒体。</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 尚未在事务中涉及的某些节点上启动，&lt;strong&gt;并且&lt;/strong&gt;本地节点或任何已经运行的节点都不知道事务的结果，则 &lt;code&gt;Mnesia&lt;/code&gt; 默认情况下等待一个。在最坏的情况下，所有其他涉及的节点必须先启动，然后 &lt;code&gt;Mnesia&lt;/code&gt; 才能对事务做出正确的决定并完成其启动。</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 发生故障，系统信息将转储到文件 &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; 。此文件中包含的系统信息的类型也可以使用函数 &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; 生成。如果 &lt;code&gt;Mnesia&lt;/code&gt; 系统的行为异常，建议在错误报告中包含 &lt;code&gt;Mnesia&lt;/code&gt; 核心转储文件。</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module2:init/1&lt;/code&gt; 返回正确的值，则此函数返回 &lt;code&gt;ok&lt;/code&gt; 。如果 &lt;code&gt;Module2:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回意外值 &lt;code&gt;Term&lt;/code&gt; ，则此函数分别返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 或 &lt;code&gt;{error,Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 失败或返回错误的元组或错误的值，则此函数返回 &lt;code&gt;{error,Errorr}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是带有有关错误的信息的术语，主管网桥以 &lt;code&gt;Error&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 失败或返回错误值，则此函数返回 &lt;code&gt;{error,Term}&lt;/code&gt; ，其中 &lt;code&gt;Term&lt;/code&gt; 是包含有关错误信息的术语，而主管则以 &lt;code&gt;Term&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 由于 &lt;code&gt;Reason&lt;/code&gt; 失败，则该函数返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;{stop,Reason}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; ，则进程终止，函数分别返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败，则此函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; ，则进程终止，此函数分别返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;ignore&lt;/code&gt; ，则此函数也返回 &lt;code&gt;ignore&lt;/code&gt; ，并且supervisor网桥终止，原因为 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;ignore&lt;/code&gt; ，此函数返回 &lt;code&gt;ignore&lt;/code&gt; 为好，并用原因主管终止 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回指示成功完成的正确值，则事件管理器添加事件处理程序，并且此函数返回 &lt;code&gt;ok&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ，则事件处理程序将被忽略，并且此函数分别返回 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; ，则common_test将尝试调用 &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; ，则common_test将尝试调用 &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 是原子，而不是源文件的路径，则将搜索代码路径以找到该模块的目标文件，并提取其原始编译器选项和源路径。如果在原始位置找不到源文件，则使用 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 相对于目标文件的目录进行搜索。</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">如果解释了 &lt;code&gt;Module&lt;/code&gt; ，则调用解释器，并返回解释后的 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 调用的返回值。</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 已加载并且目标文件存在并且包含相同的代码。</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 已加载但没有本机代码</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">如果已加载 &lt;code&gt;Module&lt;/code&gt; ，但是在代码路径中找不到相应的目标文件。</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">如果已加载 &lt;code&gt;Module&lt;/code&gt; ，但是目标文件包含具有不同MD5校验和的代码。</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">如果未对 &lt;code&gt;Module&lt;/code&gt; 进行Cover Cover编译，则该函数返回 &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 不是原子。</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">如果当前未加载 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">如果未提供 &lt;code&gt;Module&lt;/code&gt; ，则将导出所有Cover编译或较早导入的模块的数据。</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">如果未加载 &lt;code&gt;Module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 是已加载本机代码的已加载模块的名称</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 是原子（一个模块），则返回为 &lt;code&gt;Answer&lt;/code&gt; ，否则返回为列表 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 是原子（一个模块），则返回将为 &lt;code&gt;OneResult&lt;/code&gt; ，否则返回为 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 没有给定，即在覆盖数据表中的数据的所有模块，进行了分析。请注意，这包括封面编译模块和导入模块。</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">如果 &lt;code&gt;Modules=dynamic&lt;/code&gt; ，这是事件管理器的情况，则事件管理器进程将当前已安装的事件处理程序列表（ &lt;code&gt;gen_event&lt;/code&gt; ）通知发布处理程序，并检查模块名称是否在此列表中。</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">如果 &lt;code&gt;MonitorPid&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;MonitorPid&lt;/code&gt; 不是本地进程。</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">如果 &lt;code&gt;MonitorRef&lt;/code&gt; 是通过调用 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 获得的调用过程的引用，则将关闭此监视。如果监视已关闭，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; ，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; = 0，则该过程的呼叫保存功能被禁用，这是默认设置。只要设置了呼叫保存列表的大小，便会重置其内容。</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">如果使用 &lt;code&gt;Name&lt;/code&gt; （ &lt;code&gt;Key&lt;/code&gt; 的别名）来标识连接，则该名称可用作后续调用的连接参考。与 &lt;code&gt;Name&lt;/code&gt; 关联的一次只能建立一个打开的连接。如果使用 &lt;code&gt;Key&lt;/code&gt; ，则返回的句柄必须用于后续调用（可以使用 &lt;code&gt;Key&lt;/code&gt; 指定的配置数据打开多个连接）。</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 也是输入模块之一的名称，则来自该模块的代码将出现在结果代码的顶部，并且不会添加任何额外的&amp;ldquo;标题&amp;rdquo;注释。换句话说，将保留该模块的外观。</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 是 &lt;code&gt;ip_address()&lt;/code&gt; ，则将要查询的域名生成为标准反向 &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; IPv4地址的名称，或 &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; IPv6地址的名称。在这种情况下，您很可能希望使用 &lt;code&gt;Class = in&lt;/code&gt; 和 &lt;code&gt;Type = ptr&lt;/code&gt; ，但这不是自动完成的。</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;Name&lt;/code&gt; ，则将消息 &lt;code&gt;Msg&lt;/code&gt; 发送到相应的pid。pid也是函数的返回值。如果未找到名称，则该函数返回 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;Name&lt;/code&gt; ，则返回相应的pid。如果未找到名称，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 不是全局注册的名称，则调用函数将退出，原因为 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 不是符号链接，则此函数返回与 &lt;code&gt;read_file_info/1&lt;/code&gt; 相同的结果。在不支持符号链接的平台上，此功能始终等效于 &lt;code&gt;read_file_info/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">如果找不到 &lt;code&gt;Name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 或 &lt;code&gt;Dir&lt;/code&gt; 无效</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">如果 &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; ，则 &lt;code&gt;net_ticktime&lt;/code&gt; 更改在过渡期结束时完成；否则在开始时。在过渡期间， &lt;code&gt;net_kernel&lt;/code&gt; 确保至少每 &lt;code&gt;MTTI&lt;/code&gt; 毫秒在所有连接上都有传出流量。</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;{update_paths,true}&lt;/code&gt; 安装了 &lt;code&gt;NewVsn&lt;/code&gt; ，则 &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; 返回 &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">如果 &lt;code&gt;NextState =/= State&lt;/code&gt; 则状态机将更改为新状态。一个 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; 如果允许执行，所有 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; 的重试。</target>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 发生故障或不存在，则消息 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 将传递到该进程。如果某个进程对 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 进行了两次调用并且 &lt;code&gt;Node&lt;/code&gt; 终止， &lt;code&gt;nodedown&lt;/code&gt; 两个nodedown消息传递给该进程。如果没有与 &lt;code&gt;Node&lt;/code&gt; 的连接，则尝试创建一个。如果失败，则传递 &lt;code&gt;nodedown&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 是 &lt;code&gt;new&lt;/code&gt; 则 &lt;code&gt;Options&lt;/code&gt; 也将添加到内核配置参数 &lt;code&gt;inet_dist_listen_options&lt;/code&gt; 和 &lt;code&gt;inet_dist_connect_options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 是连接的节点，则返回值与 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; 中的返回值相同，其中 &lt;code&gt;Sock&lt;/code&gt; 是 &lt;code&gt;Node&lt;/code&gt; 的分发套接字。</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">如果 &lt;code&gt;NodeRefs&lt;/code&gt; 的值为 &lt;code&gt;all_nodes&lt;/code&gt; ，则在所有指定的测试节点上执行操作或测试。（声明不带 &lt;code&gt;NodeRefs&lt;/code&gt; 元素的术语具有相同的效果）。如果 &lt;code&gt;NodeRefs&lt;/code&gt; 的值为 &lt;code&gt;master&lt;/code&gt; ，则该操作仅在 &lt;code&gt;Common Test&lt;/code&gt; Master节点上执行（即设置日志目录或安装事件处理程序）。</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;Nodename&lt;/code&gt; 是本地节点，则返回错误原因 &lt;code&gt;cant_add_local_node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Norm&lt;/code&gt; 不 &lt;code&gt;none&lt;/code&gt; 功能应用上的平等测试前飞正常化。有四种可用的规范化形式： &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 是一个列表，则该函数会在插入任何内容之前检查&lt;strong&gt;每个&lt;/strong&gt;键。除非表中没有列表中的&lt;strong&gt;所有&lt;/strong&gt;键，否则不会插入任何内容。像 &lt;code&gt;insert/2&lt;/code&gt; 一样，保证整个操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">如果 &lt;code&gt;Operation&lt;/code&gt; 不适合32位整数。</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">如果 &lt;code&gt;Operation&lt;/code&gt; 不适合32位整数。</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Opt&lt;/code&gt; 是任何原子，则除非原子字符串以 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 开头，否则它将解释为 &lt;code&gt;{Opt,true}&lt;/code&gt; ，使解释为 &lt;code&gt;{Opt,false}&lt;/code&gt; 。例如， &lt;code&gt;usevc&lt;/code&gt; 是 &lt;code&gt;{usevc,true}&lt;/code&gt; 的别名， &lt;code&gt;nousevc&lt;/code&gt; 是 &lt;code&gt;{usevc,false}&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">如果 &lt;code&gt;OptList&lt;/code&gt; 不是有效 &lt;code&gt;Opt&lt;/code&gt; 的正确列表。</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">如果未提供 &lt;code&gt;OptParams&lt;/code&gt; ，则使用默认值 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">如果 &lt;code&gt;Option&lt;/code&gt; 是无效的选项。</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 是无效的选项列表。</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 是无效的选项列表。</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 不是列表。</target>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Options&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，则该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Options&lt;/code&gt; 是列表，则等效于 &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; ；否则，它等效于 &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; 。但是，直接使用此功能效率更高。</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">如果 &lt;code&gt;Options&lt;/code&gt; 不是 &lt;code&gt;[]&lt;/code&gt; ，则格式如下：</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">如果未指定 &lt;code&gt;Opts&lt;/code&gt; 或为 &lt;code&gt;[]&lt;/code&gt; ，则将删除 &lt;code&gt;ConfigFile&lt;/code&gt; 并创建一个新文件。如果 &lt;code&gt;Opts = [append]&lt;/code&gt; ，则不会删除 &lt;code&gt;ConfigFile&lt;/code&gt; 。新信息将附加在文件末尾。</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">如果指定了 &lt;code&gt;Out&lt;/code&gt; ，则 &lt;code&gt;FormatHandler&lt;/code&gt; 将文件描述符获取为 &lt;code&gt;Out&lt;/code&gt; 作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; ，则已使用 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的选项 &lt;code&gt;asynchronous&lt;/code&gt; ，并且 &lt;code&gt;Pid&lt;/code&gt; 尚未暂停被暂停的对象。</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Path&lt;/code&gt; 是目录 &lt;code&gt;default_index/2&lt;/code&gt; ，则它将开始搜索配置指令 &lt;code&gt;DirectoryIndex&lt;/code&gt; 中指定的资源或文件。如果找到合适的资源或文件，则将其附加到 &lt;code&gt;Path&lt;/code&gt; 的末尾，然后返回。 &lt;code&gt;Path&lt;/code&gt; 如果没有找到正确的档案返回不变，否则，如果 &lt;code&gt;Path&lt;/code&gt; 是不是一个目录。 &lt;code&gt;config_db()&lt;/code&gt; 是ETS表格式的服务器配置文件，如 &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">如果 &lt;code&gt;Pattern1&lt;/code&gt; 和 &lt;code&gt;Pattern2&lt;/code&gt; 是有效模式，则以下也是有效模式：</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;Pattern&lt;/code&gt; 不是二进制文件， &lt;code&gt;badarg&lt;/code&gt; 是长度大于0的二进制适当的平面列表，则会引发badarg异常。</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid2&lt;/code&gt; 不存在，则会立即发送'DOWN'消息，并将 &lt;code&gt;Reason&lt;/code&gt; 设置为 &lt;code&gt;noproc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;Pid2&lt;/code&gt; 因退出原因 &lt;code&gt;Reason&lt;/code&gt; 终止，则会向 &lt;code&gt;Pid1&lt;/code&gt; 发送&amp;ldquo; DOWN&amp;rdquo;消息：</target>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 等于 &lt;code&gt;self()&lt;/code&gt; ，并且未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则立即执行垃圾回收，即与调用 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 相同。否则，将垃圾收集请求发送到 &lt;code&gt;Pid&lt;/code&gt; 标识的进程，并将在适当的时候进行处理。如果未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则调用程序将阻塞，直到 &lt;code&gt;GCResult&lt;/code&gt; 可用并可以返回为止。</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 等于 &lt;code&gt;self()&lt;/code&gt; ，并且未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则立即执行该操作。否则，将操作请求发送到 &lt;code&gt;Pid&lt;/code&gt; 标识的进程，并在适当时进行处理。如果未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则调用方将阻塞，直到 &lt;code&gt;CheckResult&lt;/code&gt; 可用并可以返回为止。</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 是I / O设备，即从 &lt;code&gt;open/2&lt;/code&gt; 返回的pid ，则此函数返回文件名，或者更确切地说：</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 不是本地进程。</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 不是节点本地进程标识符。</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 没有捕获退出，则 &lt;code&gt;Pid&lt;/code&gt; 本身会退出，原因是退出 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 并传递到 &lt;code&gt;Pid&lt;/code&gt; 的消息队列。</target>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">如果 &lt;code&gt;PidOrPort&lt;/code&gt; 不存在，则BIF的行为取决于调用进程是否正在捕获退出（请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">如果 &lt;code&gt;PidOrPort&lt;/code&gt; 不是现有的本地进程或端口。</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">如果 &lt;code&gt;Port == 0&lt;/code&gt; ，则底层操作系统分配一个空闲的UDP端口，请使用 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">如果 &lt;code&gt;Port == 0&lt;/code&gt; ，则底层OS分配可用的端口号，请使用 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">如果 &lt;code&gt;Port&lt;/code&gt; 不是开放端口的标识符，也不是开放端口的注册名称。如果调用进程先前已链接到由 &lt;code&gt;Port&lt;/code&gt; 标识的已关闭端口，则可以保证在此 &lt;code&gt;badarg&lt;/code&gt; 异常发生之前，已发出来自该端口的退出信号。</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">如果 &lt;code&gt;Port&lt;/code&gt; 不是开放端口或开放端口的注册名称。</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;PosLen&lt;/code&gt; 以任何方式引用了二进制文件之外的内容，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Prefix&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; 的前缀，则将其删除并返回 &lt;code&gt;String&lt;/code&gt; 的其余部分，否则返回 &lt;code&gt;nomatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">如果 &lt;code&gt;QH2&lt;/code&gt; 是对 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 函数的调用（如 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 节中所定义），则 &lt;code&gt;gb_table:table/1&lt;/code&gt; 会为每个 &lt;code&gt;QH1&lt;/code&gt; 答案启动gb-tree的迭代器。然后，一一返回gb-tree的对象。在这种情况下，这可能是遍历表的最有效方法，因为它花费了最小的计算能力才能获得以下对象。但是，如果 &lt;code&gt;QH2&lt;/code&gt; 不是一个表，而是一个更复杂的QLC，则使用一些RAM内存来收集高速缓存中的答案会更加有效，特别是在答案很少的情况下。然后必须假设评估 &lt;code&gt;QH2&lt;/code&gt; 没有副作用，因此，如果仅对 &lt;code&gt;QH2&lt;/code&gt; 进行一次评估，查询的含义就不会改变。缓存答案的一种方法是首先评估 &lt;code&gt;QH2&lt;/code&gt; ，然后在查询中用答案列表替换 &lt;code&gt;QH2&lt;/code&gt; 。另一种方法是使用选项 &lt;code&gt;cache&lt;/code&gt; 。它表示为：</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Reason&lt;/code&gt; 是原子 &lt;code&gt;kill&lt;/code&gt; ，即，如果 &lt;code&gt;exit(Pid, kill)&lt;/code&gt; 被调用时，一个untrappable出口信号被发送到 &lt;code&gt;Pid&lt;/code&gt; ，其与退出原因无条件退出 &lt;code&gt;killed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">如果 &lt;code&gt;Reason&lt;/code&gt; 是原子 &lt;code&gt;normal&lt;/code&gt; ，则 &lt;code&gt;Pid&lt;/code&gt; 不会退出。如果正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; 并传递到其消息队列。</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;Receiver&lt;/code&gt; 的值为 &lt;code&gt;{Tag, Recv}&lt;/code&gt; ，则根据 &lt;code&gt;Recv&lt;/code&gt; 完成传递：</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">如果 &lt;code&gt;Receiver&lt;/code&gt; 是 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 记录，则将根据 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 记录的内容，通过 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 行为定义的回调函数将有关通知传递的信息传递给 &lt;code&gt;receiver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">如果 &lt;code&gt;RegName&lt;/code&gt; 已经被使用。</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;RegName&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 的原子。</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">如果 &lt;code&gt;Repair&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则根据需要修复当前日志文件。启动恢复时，错误日志上将输出一条消息。如果指定为 &lt;code&gt;false&lt;/code&gt; ，则不尝试自动修复。相反，如果尝试打开损坏的日志文件，则返回元组 &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; 。如果指定了 &lt;code&gt;truncate&lt;/code&gt; ，则日志文件将被截断，从而创建一个空日志。默认为 &lt;code&gt;true&lt;/code&gt; ，对以只读模式打开的日志没有影响。</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">如果 &lt;code&gt;Report&lt;/code&gt; 是地图，则在格式化之前将其转换为键值列表。</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">如果 &lt;code&gt;ReqId&lt;/code&gt; 小于0，则表示该信息对管理者不可用（该信息在丢弃消息之前从未检索过）。</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0，则数据包仅由 &lt;code&gt;[119, Result]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则找不到与 &lt;code&gt;TimerRef&lt;/code&gt; 对应的计时器。这是因为计时器已到期或被取消，或者因为 &lt;code&gt;TimerRef&lt;/code&gt; 从未对应于计时器。即使计时器已过期，它也不会告诉您超时消息是否已到达其目的地。</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则找不到与 &lt;code&gt;TimerRef&lt;/code&gt; 对应的计时器。这可能是因为计时器已到期，已被取消，或者是因为 &lt;code&gt;TimerRef&lt;/code&gt; 从未对应于计时器。即使计时器已过期，它也不会告诉您超时消息是否已到达其目的地。</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 是一个整数，则它表示直到取消的计时器到期之前还剩下的毫秒数。</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 是一个整数，则它表示直到计时器到期为止的剩余时间（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Rules&lt;/code&gt; 被忽略或为空列表，则使用默认系统规则。另请参阅内核应用程序参数 &lt;code&gt;source_search_rules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">如果将 &lt;code&gt;Schedulers&lt;/code&gt; 或 &lt;code&gt;SchedulersOnline&lt;/code&gt; 指定为负数，则分别从已配置的逻辑处理器或可用逻辑处理器的默认数量中减去该值。</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">如果操作 &lt;code&gt;Scope&lt;/code&gt; 是 &lt;code&gt;local&lt;/code&gt; ，则后备仅安装在本地节点上。</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;self()&lt;/code&gt; ，则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; 一样创建一个匿名服务器。如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; ,则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; 一样创建一个命名服务器。但是，在调用此函数&lt;strong&gt;之前，&lt;/strong&gt;必须已相应注册了 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 名称。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将 &lt;code&gt;gen_server&lt;/code&gt; 进程ID全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则不注册 &lt;code&gt;gen_server&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将 &lt;code&gt;gen_server&lt;/code&gt; 进程注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程向 &lt;code&gt;Module&lt;/code&gt; 表示的注册表注册。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出的功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">如果 &lt;code&gt;Server_or_Actions&lt;/code&gt; 是 &lt;code&gt;list()&lt;/code&gt; ，则与 &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 相同，除了不必注册任何 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 且 &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; 。这将创建一个匿名服务器。</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">如果 &lt;code&gt;SetFun&lt;/code&gt; 是编号i&amp;gt; = 1，并且 &lt;code&gt;Set1&lt;/code&gt; 是一个关系，则返回的集合是 &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Set1&lt;/code&gt; 到坐标我。</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是普通的 &lt;code&gt;socket()&lt;/code&gt; ：将 &lt;code&gt;gen_tcp&lt;/code&gt; 或等效套接字升级到SSL套接字，即执行SSL / TLS服务器端握手并返回TLS套接字。</target>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是 &lt;code&gt;sslsocket()&lt;/code&gt; ：为 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 中指定的选项提供额外的SSL / TLS / DTLS选项，然后执行SSL / TLS / DTLS握手。如果握手成功，则返回新的TLS / DTLS套接字。</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">如果 &lt;code&gt;Source&lt;/code&gt; 引用文件名，则它将以复制之前的模式列表之前的 &lt;code&gt;read&lt;/code&gt; 模式打开，并在完成时关闭。</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">如果 &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; ，则将为每个规范创建单独的测试。如果 &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; ，则所有规格将合并为一个测试。</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Streams&lt;/code&gt; 为空列表，则通过发送以下过滤器来请求&lt;strong&gt;所有&lt;/strong&gt;流：</target>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将主管桥全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将主管网桥注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; ，则使用由Module表示的注册表将主管网桥注册为 &lt;code&gt;Name&lt;/code&gt; 。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将主管全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupName={local,Name}&lt;/code&gt; ，则主管使用 &lt;code&gt;register/2&lt;/code&gt; 在本地注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; ，则使用 &lt;code&gt;Module&lt;/code&gt; 表示的注册表将主管注册为 &lt;code&gt;Name&lt;/code&gt; 。所述 &lt;code&gt;Module&lt;/code&gt; 的回调必须导出功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，它必须表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,Name}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">如果 &lt;code&gt;Suspendee&lt;/code&gt; 不是进程标识符。</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">如果 &lt;code&gt;Term&lt;/code&gt; 和 &lt;code&gt;Pattern&lt;/code&gt; 可以匹配，则该函数返回一个非零值，并绑定 &lt;code&gt;Pattern&lt;/code&gt; 中所有未绑定的变量。如果 &lt;code&gt;Term&lt;/code&gt; 和 &lt;code&gt;Pattern&lt;/code&gt; 不匹配，则返回 &lt;code&gt;0&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 为 &lt;code&gt;infinity&lt;/code&gt; ，则不会启动任何计时器，因为它永远不会过期。</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 是相对的且 &lt;code&gt;0&lt;/code&gt; ,则实际上不启动任何计时器，而是将timeout事件排队，以确保在尚未接收到任何外部事件之前但在已排队的事件之后对其进行处理。</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 是相对的且 &lt;code&gt;0&lt;/code&gt; ,则实际上没有启动任何计时器，而是将timeout事件排队，以确保在尚未收到任何外部事件之前对其进行处理。</target>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">如果将 &lt;code&gt;Time&lt;/code&gt; 指定为整数，则此函数将等待 &lt;code&gt;Time&lt;/code&gt; 毫秒以等待新进程调用 &lt;code&gt;init_ack&lt;/code&gt; ，否则将返回 &lt;code&gt;{error, timeout}&lt;/code&gt; ，并且该进程将被终止。</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">如果将 &lt;code&gt;Timeout&lt;/code&gt; 设置为以毫秒为单位的整数值，则Mnesia会强制完成&amp;ldquo;重量级交易&amp;rdquo;，即使目前尚不清楚交易的结果。后 &lt;code&gt;Timeout&lt;/code&gt; 毫秒，Mnesia的提交或终止交易，并启动继续。这可能导致事务在某些节点上提交而在其他节点上终止的情况。如果事务是架构事务，则不一致可能是致命的。</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; 并且 &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; 和 &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;TupleOfBinRels&lt;/code&gt; 为{R，... - [R [n]的[1]，}二元关系的一个非空的元组和 &lt;code&gt;BinRel1&lt;/code&gt; 是一个二元关系，然后 &lt;code&gt;BinRel2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; 的有序集合的（R [I]， ...，R [n]）和 &lt;code&gt;BinRel1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">如果 &lt;code&gt;Type = load&lt;/code&gt; ，则仅加载应用程序。</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">如果 &lt;code&gt;Type = none&lt;/code&gt; ，则尽管已加载其模块的代码，但该应用程序不会加载也不会启动。</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; ，以相应的方式加载和启动 &lt;code&gt;application(3)&lt;/code&gt; ，请参见application（3）。</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;file&lt;/code&gt; ，则客户端读取存储在名为 &lt;code&gt;Filename&lt;/code&gt; 的文件中或由 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 指定的所有跟踪消息（必须与创建跟踪时使用的跟踪消息相同，请参阅trace_port / 2），让我们使用默认处理程序函数在控制台上格式化消息。这是文件跟踪端口驱动程序解释存储在文件中的数据的一种方法。</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;follow_file&lt;/code&gt; ，则客户端的行为与 &lt;code&gt;file&lt;/code&gt; 情况相同，但会继续尝试从文件读取（并处理）更多数据，直到被 &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; 停止为止。 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 不允许用作此 &lt;code&gt;Type&lt;/code&gt; 的第二个参数。</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;ip&lt;/code&gt; ，则客户端连接到主机 &lt;code&gt;Hostname&lt;/code&gt; 上的TCP / IP端口 &lt;code&gt;PortNumber&lt;/code&gt; ，从该主机读取跟踪消息，直到TCP / IP连接关闭。如果未指定 &lt;code&gt;Hostname&lt;/code&gt; ，则使用本地主机。</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;port&lt;/code&gt; ，则第二个参数应该是一个&lt;strong&gt;有趣的&lt;/strong&gt;函数，它不带任何参数，并且在调用时返回一个新打开的跟踪端口。最好通过调用 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 来产生这种&lt;strong&gt;乐趣&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;process&lt;/code&gt; ，则可以指定消息处理程序函数（ &lt;code&gt;HandlerSpec&lt;/code&gt; ）。对于每个跟踪消息，将调用处理程序函数，该函数应带有两个参数，这将是一个 &lt;code&gt;fun&lt;/code&gt; ，其中第一个参数按原样包含消息，第二个参数包含上次调用该乐趣时的返回值。第二个参数的初始值在 &lt;code&gt;HandlerSpec&lt;/code&gt; 的 &lt;code&gt;InitialData&lt;/code&gt; 部分中指定。该 &lt;code&gt;HandlerFun&lt;/code&gt; 可以选择任何适当的行动调用时采取，并且可以通过返回其保存为下次调用的状态。</target>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;table&lt;/code&gt; ，则要匹配的对象将是一个元组。然后 &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; 该函数返回{ok，Result，[]，Warnings}，其中 &lt;code&gt;Result&lt;/code&gt; 是真正的 &lt;code&gt;ets:select/2&lt;/code&gt; 调用中的结果，如果匹配说明与对象元组不匹配，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;trace&lt;/code&gt; ，则要匹配的对象将是一个列表。该函数返回 &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; ，其中 &lt;code&gt;Result&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; 的描述中列出的内存类型之一。</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">如果返回 &lt;code&gt;[]&lt;/code&gt; ，则没有OS单调时间可用。该列表包含两个元组，其中 &lt;code&gt;Key&lt;/code&gt; 为第一个元素， &lt;code&gt;Value&lt;/code&gt; 为第二个元素。这些元组的顺序是不确定的。以下元组可以是列表的一部分，但将来可以引入更多的元组：</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">如果 &lt;code&gt;[node()]&lt;/code&gt; ,则如果在任何指定节点上已经存在另一个连接，则拒绝连接。类型 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;node&lt;/code&gt; ， &lt;code&gt;nodes&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 分别等效于 &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;[node()]&lt;/code&gt; ， &lt;code&gt;[node()|nodes()]&lt;/code&gt; 和求值，每当要建立新连接时，都会对每个表达式进行求值成立。请注意， &lt;code&gt;false&lt;/code&gt; 允许与同一对等方建立无限数量的连接。</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">如果将 &lt;code&gt;active&lt;/code&gt; 指定为-32768到32767（包括）之间的整数 &lt;code&gt;N&lt;/code&gt; ，则将该数字添加到套接字的要传递给控制过程的数据消息的计数中。如果相加结果为负，则将计数设置为 &lt;code&gt;0&lt;/code&gt; 。一旦计数达到 &lt;code&gt;0&lt;/code&gt; （通过传递消息或通过使用 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 显式设置），套接字模式将自动重置为被动（ &lt;code&gt;{active, false}&lt;/code&gt; ）。当处于此主动模式的套接字转换为被动模式时，将消息 &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; 发送到控制进程，以通知它如果要从套接字接收更多数据消息，则必须调用 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 将套接字重新设置为活动模式。</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">如果 &lt;code&gt;alloc&lt;/code&gt; 成功，则也会执行 &lt;code&gt;dealloc&lt;/code&gt; 。但是，如果 &lt;code&gt;alloc&lt;/code&gt; 失败，则不会执行 &lt;code&gt;dealloc&lt;/code&gt; ,而是在HTML日志中将其标记为 &lt;code&gt;SKIPPED&lt;/code&gt; 。无论 &lt;code&gt;alloc_and_dealloc&lt;/code&gt; 情况如何， &lt;code&gt;get_resource_status&lt;/code&gt; 都会运行。</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">如果为 &lt;code&gt;answer_3xxx&lt;/code&gt; ,则无需处理 &lt;code&gt;handle_request/3&lt;/code&gt; 回调即可应答请求。如果 &lt;code&gt;answer&lt;/code&gt; 则即使没有应答也可以回答5xxx错误，除非所讨论的连接配置了RFC 3588通用字典，如下所述。如果是 &lt;code&gt;callback&lt;/code&gt; 则始终执行 &lt;code&gt;handle_request/3&lt;/code&gt; 回调，并且其返回值确定发送给对等方的答案（如果有）。</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">如果 &lt;code&gt;audit_trail_log&lt;/code&gt; 指定应进行日志记录，则&lt;strong&gt;必须&lt;/strong&gt;定义此参数。</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;auto_ack&lt;/code&gt; 为true，则如果 &lt;code&gt;trans_ack&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则会立即发送ack。如果 &lt;code&gt;trans_ack&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则将ack发送到事务发送方进程进行累积并随后发送（请参见 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxsize&lt;/code&gt; ， &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 和 &lt;code&gt;trans_timer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">如果是 &lt;code&gt;callback&lt;/code&gt; 则错误 &lt;code&gt;handle_answer/4&lt;/code&gt; 与 &lt;code&gt;handle_request/3&lt;/code&gt; 相同的方式导致handle_answer / 4回调，并在传递给回调的 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 的 &lt;code&gt;errors&lt;/code&gt; 字段中传达错误。如果 &lt;code&gt;report&lt;/code&gt; 则包含错误的答案将被丢弃，而不会进行回调，并且将警告报告写入日志。如果 &lt;code&gt;discard&lt;/code&gt; 则包含错误的答案将被静默丢弃，而不会进行回调。在 &lt;code&gt;report&lt;/code&gt; 和 &lt;code&gt;discard&lt;/code&gt; 情况下，所涉及的 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 调用的返回值都好像发生了回调并返回了 &lt;code&gt;{error, failure}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">如果 &lt;code&gt;ch4&lt;/code&gt; 是应用程序 &lt;code&gt;sp_app&lt;/code&gt; 的一部分，并且从该应用程序的版本&amp;ldquo; 1&amp;rdquo;升级到&amp;ldquo; 2&amp;rdquo;时要加载模块的新版本，则 &lt;code&gt;sp_app.appup&lt;/code&gt; 可以如下所示：</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;cp1&lt;/code&gt; 发生故障，系统将检查其他节点 &lt;code&gt;cp2&lt;/code&gt; 或 &lt;code&gt;cp3&lt;/code&gt; 中哪个节点具有最少数量的正在运行的应用程序，但要等待5秒钟才能重新启动 &lt;code&gt;cp1&lt;/code&gt; 。如果 &lt;code&gt;cp1&lt;/code&gt; 不重新启动和 &lt;code&gt;cp2&lt;/code&gt; 的运行速度比更少的应用程序 &lt;code&gt;cp3&lt;/code&gt; ， &lt;code&gt;myapp&lt;/code&gt; 被重启 &lt;code&gt;cp2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;-help&lt;/code&gt; 调用 &lt;code&gt;ct_run&lt;/code&gt; ，它将所有有效的开始标志 &lt;code&gt;stdout&lt;/code&gt; 到stdout。</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">如果 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 设置为与 &lt;code&gt;flush_qlen&lt;/code&gt; 相同的值，则丢弃模式将被禁用，并且永远不会发生。</target>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_call/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_ports/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_procs/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_receive/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_running_ports/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_running_procs/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_send/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">如果将 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 之外的其他值，则如果数据包含的字符大于255 ，则 &lt;code&gt;read_line/1&lt;/code&gt; 调用将失败，为什么在读取此类文件时首选模块 &lt;code&gt;io(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">如果将 &lt;code&gt;epmd&lt;/code&gt; 用于节点发现，通常需要使用（不幸的是，未记录） &lt;code&gt;erl_epmd&lt;/code&gt; 模块（ &lt;code&gt;kernel&lt;/code&gt; 应用程序的一部分），以便向 &lt;code&gt;epmd&lt;/code&gt; 注册侦听端口并检索要使用的 &lt;code&gt;Creation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;erl_script_nocache&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则服务器将添加HTTP标头字段，以防止代理缓存页面。对于动态内容，这通常是一个好主意，因为内容在每个请求之间经常有所不同。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">如果 &lt;code&gt;erl_script_timeout&lt;/code&gt; 设置了以秒为单位的时间，则服务器在要通过 &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; 传递的每个数据块之间等待。默认值为 &lt;code&gt;15&lt;/code&gt; 。这仅与使用erl方案的脚本有关。</target>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;error_logger&lt;/code&gt; ，则使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。可以通过选项 &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">如果 &lt;code&gt;ev&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，则返回所有类型为 &lt;code&gt;-1&lt;/code&gt; &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 为ErlDrvSizeT的值。</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">如果 &lt;code&gt;exit&lt;/code&gt; 则所讨论的运输过程退出。如果为 &lt;code&gt;handle&lt;/code&gt; ,则照常处理该消息，生成的 &lt;code&gt;handle_request/3&lt;/code&gt; 或 &lt;code&gt;handle_answer/4&lt;/code&gt; 回调（如果发生）表示 &lt;code&gt;5015&lt;/code&gt; 错误（DIAMETER_INVALID_MESSAGE_LENGTH）。如果 &lt;code&gt;discard&lt;/code&gt; 则该消息将被静默丢弃。</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;Options&lt;/code&gt; 中指定了 &lt;code&gt;extra&lt;/code&gt; ，则返回值为 &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; 而不是 &lt;code&gt;{ok, Epp}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;Options&lt;/code&gt; 中指定了 &lt;code&gt;extra&lt;/code&gt; ，则返回值为 &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; 而不是 &lt;code&gt;{ok, [Form]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; （被动模式，默认设置），则调用者必须执行显式 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 调用以从套接字检索可用数据。</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不共享对等体。如果 &lt;code&gt;[node()]&lt;/code&gt; ,则与指定的节点列表共享对等体。如果使用 &lt;code&gt;eval()&lt;/code&gt; ,则与指定函数返回的节点共享对等点，并在对等连接可用或远程服务请求有关本地连接的信息时进行评估。值 &lt;code&gt;true&lt;/code&gt; 等效于 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 。列表中的值 &lt;code&gt;node()&lt;/code&gt; 会被忽略，因此可以将服务集合全部配置为与同一节点列表共享。</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不使用远程对等体。如果 &lt;code&gt;[node()]&lt;/code&gt; ,则仅使用指定节点列表中的对等体。如果使用 &lt;code&gt;eval()&lt;/code&gt; ,则仅使用由指定函数返回的对等体，只要远程服务传达有关可用对等体连接的信息，就进行评估。值 &lt;code&gt;true&lt;/code&gt; 等效于 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 。列表中的值 &lt;code&gt;node()&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则在需要任何用户交互时（例如接受要添加到 &lt;code&gt;known_hosts&lt;/code&gt; 文件中的服务器或提供密码），禁止客户端连接到服务器。</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不会保存密钥，并且在同一主机的下一次访问中，密钥仍然是未知的。</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">如果 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;latin1&lt;/code&gt; ，则不翻译路径名。</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">如果 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;utf8&lt;/code&gt; ，则在创建tar文件时将路径名编码为UTF-8，而在提取tar文件时将假定路径名以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果返回 &lt;code&gt;final&lt;/code&gt; ，则时间偏移已处于final状态。这是因为另一个 &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; 调用，或者因为 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则备份仅包括自上次备份或还原以来创建，修改或删除的那些对象（即增量备份）。备份后，所有标记为脏的对象现在都是干净的，并且所有标记为删除的对象都将被删除。</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 是 &lt;code&gt;EI_BIN&lt;/code&gt; ，则需要第五个参数 &lt;code&gt;int *size&lt;/code&gt; ，以便可以返回对象的大小。</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;EI_BIN&lt;/code&gt; ，则需要第五个参数 &lt;code&gt;size&lt;/code&gt; ，以指示 &lt;code&gt;v&lt;/code&gt; 指向的对象的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;hibernate&lt;/code&gt; 模式而不是超时值，则在等待下一条消息到达时（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），进程将进入休眠模式。</target>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果跳过 &lt;code&gt;init_per_group&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">如果存在 &lt;code&gt;init_per_suite&lt;/code&gt; ，则在执行测试用例之前首先调用它。它通常包含该套件中所有测试用例通用的初始化，只能执行一次。建议使用 &lt;code&gt;init_per_suite&lt;/code&gt; 在被测系统（SUT）或&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 主机节点或两者上设置和验证状态和环境，以便套件中的测试用例能够正确执行。以下是初始配置操作的示例：</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;init_per_suite&lt;/code&gt; 失败，则会自动跳过测试套件中的所有测试用例（所谓的&lt;strong&gt;auto skipped&lt;/strong&gt;），包括 &lt;code&gt;end_per_suite&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;init_per_suite&lt;/code&gt; 失败，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 崩溃（称为&lt;strong&gt;自动跳过&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 崩溃，或者返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 或 &lt;code&gt;{fail,Reason}&lt;/code&gt; ，则不调用函数 &lt;code&gt;end_per_testcase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">如果存在 &lt;code&gt;init_per_testcase&lt;/code&gt; ，则会在套件中的每个测试用例之前调用它。它通常包含必须针对每个测试用例进行的初始化（该套件的 &lt;code&gt;init_per_suite&lt;/code&gt; 模拟）。</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 返回一个元组 &lt;code&gt;{skip,Reason}&lt;/code&gt; （称为&lt;strong&gt;用户skipped&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;ip_access&lt;/code&gt; 和 &lt;code&gt;name_access&lt;/code&gt; 的实现类似，我们可以使用 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; 编写 &lt;code&gt;generic_access&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">如果 &lt;code&gt;keysearch&lt;/code&gt; 返回原子 &lt;code&gt;false&lt;/code&gt; ，则发生了一些错误，服务器发回了消息：</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">如果 &lt;code&gt;keysearch&lt;/code&gt; 返回：</target>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;kill&lt;/code&gt; ，则将使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。它可以通过选项改变 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">如果将 &lt;code&gt;local&lt;/code&gt; 指定为参数，则Debugger仅在当前节点解释代码。如果将 &lt;code&gt;global&lt;/code&gt; 指定为参数，则Debugger会在所有已知节点上解释代码，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">如果使用负数作为参数调用 &lt;code&gt;m:fact/1&lt;/code&gt; ，则没有子句头匹配。一个 &lt;code&gt;function_clause&lt;/code&gt; 出现运行错误。</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">如果为 &lt;code&gt;master&lt;/code&gt; ，则启动一个主代理。否则，不会启动任何代理。</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">如果 &lt;code&gt;maximum&lt;/code&gt; 的为通过 &lt;code&gt;Type&lt;/code&gt; 和仿真器是不是在仪表模式下运行。</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">如果 &lt;code&gt;mon&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则成功调用将监视器的身份存储在 &lt;code&gt;mon&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 结构中。此标识符用于引用监视器，以供以后通过 &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; 除去或与 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 比较。触发监视器或释放资源时，监视器会自动删除。</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">如果 &lt;code&gt;msg_env&lt;/code&gt; 设置为 &lt;code&gt;NULL&lt;/code&gt; ，则将复制 &lt;code&gt;msg&lt;/code&gt; 术语，并且在调用后原始术语及其环境仍然有效。</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">如果 &lt;code&gt;myapp&lt;/code&gt; 在 &lt;code&gt;cp3&lt;/code&gt; 上运行，并且现在 &lt;code&gt;cp2&lt;/code&gt; 重新启动，则它不会重新启动 &lt;code&gt;myapp&lt;/code&gt; ，因为 &lt;code&gt;cp2&lt;/code&gt; 和 &lt;code&gt;cp3&lt;/code&gt; 节点之间的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">如果 &lt;code&gt;nc&lt;/code&gt; 是由分配器管理多嵌段载波（排除主多嵌段载波）的当前数量，下一个的大小 &lt;code&gt;mseg_alloc&lt;/code&gt; 由该分配器分配多嵌段载体是大致 &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; 当 &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; 和 &lt;code&gt;lmbcs&lt;/code&gt; 当 &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; 。如果参数的值 &lt;code&gt;sbct&lt;/code&gt; 比参数的值越大 &lt;code&gt;lmbcs&lt;/code&gt; ，分配器可能必须创建多块载体是比参数的值越大 &lt;code&gt;lmbcs&lt;/code&gt; ，虽然。通过 &lt;code&gt;mseg_alloc&lt;/code&gt; 分配的单块载波大小调整为整个页面。</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">如果将 &lt;code&gt;no_repeat&lt;/code&gt; 设置为值，则重复文件同步操作将被禁用，并且操作系统设置决定了将数据写入磁盘的速度。用户还可以调用 &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 函数来执行文件同步。</target>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">如果将 &lt;code&gt;no_repeat&lt;/code&gt; 设置为值，则禁用重复同步操作。用户还可以调用filesync &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 函数来执行disk_log同步。</target>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;node&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则它是指向缓冲区的指针，该函数可以在其中填充找到名称的节点的 &lt;code&gt;name&lt;/code&gt; 。如有必要，可以将 &lt;code&gt;node&lt;/code&gt; 直接传递到 &lt;code&gt;erl_connect()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">如果为 &lt;code&gt;once&lt;/code&gt; ，则仅自动将一条消息放入消息队列，然后此模式自动重置为被动模式。这提供了流控制，并为接收器提供了侦听与其他进程间消息交织的传入SCTP数据的可能性。</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则必须在停止OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; &lt;strong&gt;之后&lt;/strong&gt;调用此函数。 &lt;code&gt;Dir&lt;/code&gt; 定义了目录，该目录包含备份副本和 &lt;code&gt;syslogd&lt;/code&gt; 的Erlang特定配置文件，以及一个命名管道，用于接收来自 &lt;code&gt;syslogd&lt;/code&gt; 的消息。默认为 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 。 &lt;code&gt;Conf&lt;/code&gt; 定义 &lt;code&gt;syslogd&lt;/code&gt; 的配置文件的全名。默认值为 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则必须在启动OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;调用此函数。 &lt;code&gt;Dir&lt;/code&gt; 定义了目录，该目录包含备份副本和 &lt;code&gt;syslogd&lt;/code&gt; 的Erlang特定配置文件，以及一个命名管道，用于接收来自 &lt;code&gt;syslogd&lt;/code&gt; 的消息。默认为 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 。 &lt;code&gt;Conf&lt;/code&gt; 定义 &lt;code&gt;syslogd&lt;/code&gt; 的配置文件的全名。默认值为 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">如果 &lt;code&gt;preliminary&lt;/code&gt; 返回，进行定稿和时间偏移现在是最后的。</target>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">如果 &lt;code&gt;read/2&lt;/code&gt; 调用的大小不明显小于或什至大于 &lt;code&gt;Size&lt;/code&gt; 字节，则无法期望获得性能提升。</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">如果指定 &lt;code&gt;read&lt;/code&gt; ，则仅记录获取请求。</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">如果指定为 &lt;code&gt;read&lt;/code&gt; ，则仅记录收到的消息。</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">如果为表启用了 &lt;code&gt;read_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">如果为 &lt;code&gt;read_write&lt;/code&gt; ，则记录所有请求。</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">如果为 &lt;code&gt;read_write&lt;/code&gt; ，则记录传出消息和传入消息。</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;registered_name&lt;/code&gt; 是 &lt;code&gt;ItemList&lt;/code&gt; 的一部分，并且进程未注册任何名称，则 &lt;code&gt;{registered_name, []}&lt;/code&gt; &lt;code&gt;InfoTuple&lt;/code&gt; ，[]}，InfoTuple &lt;strong&gt;将&lt;/strong&gt;包含在结果 &lt;code&gt;InfoTupleList&lt;/code&gt; 中。当指定单个 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 时，以及使用 &lt;code&gt;process_info/1&lt;/code&gt; 时，此行为是不同的。</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;remove_handler&lt;/code&gt; ，则通过调用 &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; 删除事件处理程序。</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;script_nocache&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则默认情况下，HTTP服务器会添加必要的头字段，以防止代理缓存页面。通常，这是优选的。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">如果在加载应用程序之前调用 &lt;code&gt;set_env/4&lt;/code&gt; ，则文件 &lt;code&gt;Application.app&lt;/code&gt; 中指定的应用程序环境值将覆盖先前设置的值。对于应用程序重新加载也是如此。</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则将头部的大小放置在此处。</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">如果返回 &lt;code&gt;stop&lt;/code&gt; ，则立即丢弃日志事件。如果过滤器是主过滤器，则不会调用任何处理程序过滤器或回调。如果它是处理程序过滤器，则不会调用相应的处理程序回调，但是会将日志事件转发到附加到下一个处理程序的过滤器（如果有）。</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">如果 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; ，则将同步处理所有日志事件。即，禁用了异步日志记录。</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">如果将 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 设置为与 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 相同的值，那么将禁用同步模式。也就是说，处理程序始终以异步模式运行，除非调用删除或刷新。</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 标识节点本地端口，则此函数从中初始化端口变量 &lt;code&gt;*port_id&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。不检查端口是否还活着。</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是一个元组，则此函数将 &lt;code&gt;*array&lt;/code&gt; 设置为指向包含该元组元素的数组，并将 &lt;code&gt;*arity&lt;/code&gt; 设置为元素数。注意，数组是只读的， &lt;code&gt;(*array)[N-1]&lt;/code&gt; 是元组的第N个元素。如果元组的Arity为零，则未定义 &lt;code&gt;*array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是节点本地进程的pid，则此函数从中初始化pid变量 &lt;code&gt;*pid&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。不检查该进程是否仍在运行。</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果未在catch中评估 &lt;code&gt;throw/1&lt;/code&gt; ，则将发生 &lt;code&gt;nocatch&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">如果未设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; ，则使用由 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; ）指定的默认值。</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">如果未针对特定测试用例专门设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 或两者，则使用由功能 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 指定的默认值。</target>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_call/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_ports/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_procs/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_receive/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_running_ports/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_running_procs/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_send/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">如果 &lt;code&gt;trans_req&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则将立即发送请求（在其自身的消息中）。</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将请求发送到事务发送方进程进行累积，然后再发送（请参见 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxsize&lt;/code&gt; ， &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 和 &lt;code&gt;trans_timer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; （完全活动模式），则未决数据或事件将发送到拥有进程。</target>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在启动期间重新读取配置文件，并且忽略配置数据库的内容。因此，如果为 &lt;code&gt;true&lt;/code&gt; ，则在代理重新启动后，对配置数据库的更改将丢失。</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">如果 &lt;code&gt;true&lt;/code&gt; ，休眠的 &lt;code&gt;gen_statem&lt;/code&gt; 通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 才能进入 &lt;code&gt;receive&lt;/code&gt; 等待新的外部事件。</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在尝试发送大于当前PMTU大小的消息时会引发错误（这将需要分段/重新组装）。注意，消息碎片不会影响其传递的逻辑原子性。仅出于性能原因提供此选项。</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则net_if绑定到IP地址。如果为 &lt;code&gt;false&lt;/code&gt; ，则net_if侦听运行它的主机上的任何IP地址。</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则net_if不指定IP和端口地址应可重用。如果为 &lt;code&gt;false&lt;/code&gt; ，则地址设置为可重用。</target>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则推迟当前事件并在状态更改时重试（ &lt;code&gt;NextState =/= State&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则代理是多线程的，每个get请求都有一个线程。</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则客户端不会在授权时打印任何内容。</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则客户端将保存一个接受的主机密钥，以避免下次连接同一主机时出现接受问题。如果不存在选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; ，则该密钥将保存在文件&amp;ldquo; known_hosts&amp;rdquo;中。请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 以获取该文件的位置。</target>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则将累积执行时间和缩减量。</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在发生某些日志事件时会通知日志所有者。默认为 &lt;code&gt;false&lt;/code&gt; 。事件发生时，将向所有者发送以下消息之一：</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，这将使 &lt;code&gt;epp_dodger&lt;/code&gt; 替换任何无法用 &lt;code&gt;text&lt;/code&gt; 类型的节点解析的程序形式（请参阅 &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; ），表示该形式的原始令牌序列，而不是报告解析错误。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">如果将 &lt;code&gt;u&lt;/code&gt; 用作子系统标识符（即 &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ），则所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 的分配器都会生效。如果将 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 用作子系统标识符，则仅实现特定的分配器标识符。</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果返回了 &lt;code&gt;volatile&lt;/code&gt; ，则由于使用了 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 因此无法最终确定时间偏移。</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">如果指定了 &lt;code&gt;write&lt;/code&gt; ，则仅记录已发送的消息。</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">如果指定了 &lt;code&gt;write&lt;/code&gt; ，则仅记录设置请求。</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">如果为表启用了 &lt;code&gt;write_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">如果返回 &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; ，则在执行升级指令之前重新启动模拟器。如果仿真器或任何应用程序内核，STDLIB或SASL被更新，则会发生这种情况。新的仿真器版本和这些核心应用程序在重启后执行。对于所有其他应用程序，将启动旧版本，并通过执行升级说明按常规执行升级。</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;{eof, Endline}&lt;/code&gt; 立即返回，则对 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 的调用返回 &lt;code&gt;{ok, eof}&lt;/code&gt; 。如果在解析器期望输入结束之前返回 &lt;code&gt;{eof, Endline}&lt;/code&gt; ，则 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 当然会返回错误消息（请参见上文）。否则 &lt;code&gt;{ok, Result}&lt;/code&gt; 返回{ok，Result}。</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">如果在源规范中设置了 &lt;code&gt;{merge_tests,true}&lt;/code&gt; （这是默认设置），则合并规范中的术语将与源规范中的术语合并（根据之前的 &lt;code&gt;merge_tests&lt;/code&gt; 的描述）。</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;{noreply,NewState}&lt;/code&gt; ， &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; 或 &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程将继续使用 &lt;code&gt;NewState&lt;/code&gt; 执行。必须使用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 明确指定对 &lt;code&gt;From&lt;/code&gt; 的任何答复。</target>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; ，则事件管理器也会进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），等待下一个事件发生。事件处理程序之一返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 就足以使整个事件管理器进程休眠。</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,NewState}&lt;/code&gt; 或 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; ，则事件处理程序将保留在事件管理器中，并带有可能更新的内部状态 &lt;code&gt;NewState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，则事件管理器进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），等待下一个事件发生。</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; 返回， &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; 或 &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; ， &lt;code&gt;Reply&lt;/code&gt; 返还给 &lt;code&gt;From&lt;/code&gt; 为的返回值 &lt;code&gt;call/2,3&lt;/code&gt; 或纳入 &lt;code&gt;multi_call/2,3,4&lt;/code&gt; 的返回值。然后 &lt;code&gt;gen_server&lt;/code&gt; 进程以可能更新的内部状态 &lt;code&gt;NewState&lt;/code&gt; 继续执行。</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">如果为该过程设置了 &lt;code&gt;{save_calls,N}&lt;/code&gt; ,则不会将任何函数调用保存到调用保存列表中。（不会清除呼叫保存列表。此外，发送，接收和超时事件仍会添加到列表中。）</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 在选项中指定，使得 &lt;code&gt;Start&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ， &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0或 &lt;code&gt;Start + Length&lt;/code&gt; 是&amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ，一个 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 在选项中指定，使得 &lt;code&gt;Start&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ， &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt;0或 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ，一个 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过该组中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在该组的概述日志中。</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过模块中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在HTML结果页上。</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过套件中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则跳过该测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在该套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">如果返回 &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; ,则必须使用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 显式指定对 &lt;code&gt;From&lt;/code&gt; 的任何答复。然后 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; 并终止。</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; 返回， &lt;code&gt;Reply&lt;/code&gt; 返还给 &lt;code&gt;From&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果返回了 &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; ，则首先通过 &lt;code&gt;Handler2&lt;/code&gt; 调用 &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; 和 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 来将事件处理程序替换为Handler2，其中 &lt;code&gt;Term&lt;/code&gt; 是返回值 &lt;code&gt;Module:terminate/2&lt;/code&gt; 。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">如果&lt;strong&gt;任何&lt;/strong&gt;的&lt;strong&gt;其他的&lt;/strong&gt;回调函数崩溃（退出，或者抛出一个普通的崩溃）或返回无效的结果（如果已指定一个有效的回报），这个函数被调用。目的是允许用户处理此错误（例如发出错误报告）。</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;false&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; 函数发送megaco消息。</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;false&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 函数发送megaco消息。</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;true&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; 函数&lt;strong&gt;重新发送&lt;/strong&gt;megaco消息。仍然使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 函数完成初始消息发送。</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">如果A和B进行了匹配,但在C中出现了失败,则匹配不会回溯到A中,而是移动到下一个备选方案,也就是D中。然而,如果给含有(*THEN)的子模式提供了一个备选方案,它的表现就不同了。</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">如果A是X的子集，则A在R下的&lt;strong id=&quot;image&quot;&gt;图像&lt;/strong&gt;是集合{y：x R y对于A中的某些x}。如果B是Y的子集，则B 的&lt;strong id=&quot;inverse_image&quot;&gt;逆像是&lt;/strong&gt;集合{x：x R y对于B中的某些y}。</target>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K := V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K := V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">如果A匹配但B失败,回溯到(*COMMIT)会导致整个匹配失败。然而,如果 A 和 B 匹配,但 C 失败,则回溯到 (*THEN)会导致下一个选择 (ABD)被尝试。这种行为是一致的,但并不总是与Perl中的行为相同。它的意思是,如果连续出现两个或更多的回溯动词,其中最后一个动词没有效果。考虑下面的例子。</target>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是case子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的案例子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; ，即，带有显式异常类 &lt;code&gt;throw&lt;/code&gt; 且带有或不带有显式stacktrace变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与没有显式异常类且没有显式stacktrace变量的catch子句区分开。</target>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即具有显式异常类 &lt;code&gt;throw&lt;/code&gt; 且带有或不具有显式堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与没有显式异常类的catch子句区别开来，并且没有显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式，而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; ，即具有显式异常类和显式堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与具有显式异常类且没有显式异常类的catch子句区分开一个显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;S&lt;/code&gt; 是变量，并且 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P：S，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;S&lt;/code&gt; 是变量， &lt;code&gt;B&lt;/code&gt; 是主体，然后Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列，并且 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即，带有明确的异常类和明确的堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与一个带有显式异常类且没有显式stacktrace变量的catch子句。</target>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">如果C是约束 &lt;code&gt;V :: T&lt;/code&gt; ，其中 &lt;code&gt;V&lt;/code&gt; 是类型变量， &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（C）= &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是函数子句 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; C是函数子句（Ps），其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是if子句 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">如果CPU拓扑信息不可用。</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">如果D是一个由形式 &lt;code&gt;F_1&lt;/code&gt; ，...， &lt;code&gt;F_k&lt;/code&gt; 组成的模块声明，则Rep（D）= &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是位串理解 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果E是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个类型特定的列表，则Rep（E）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个块表达式，则 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;begin B end&lt;/code&gt; ，其中B是主体，则Rep（E）= &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; 的case表达式case E_0；...; Cc_k end，其中 &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，然后Rep（E）= &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是catch表达式 &lt;code&gt;catch E_0&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个缺点骨架 &lt;code&gt;[E_h | E_t]&lt;/code&gt; ，然后Rep（E）= &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式，则 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是一个功能子句，则Rep（E）= &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 。（在Erlang / OTP R15之前：Rep（E）= &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式， &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; ，其中 &lt;code&gt;Name&lt;/code&gt; 是变量，每个 &lt;code&gt;Fc_i&lt;/code&gt; 是函数子句，然后Rep（E）= &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是列表 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图更新 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 或 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是匹配运算符表达式 &lt;code&gt;P = E_0&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式，则Rep（E）= &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">如果E是带括号的表达式 &lt;code&gt;( E_0 )&lt;/code&gt; ，则Rep（E）= &lt;code&gt;Rep(E_0)&lt;/code&gt; ，即，不能将带括号的表达式与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句， &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，而 &lt;code&gt;B_t&lt;/code&gt; 是一个主体，则Rep（E）= &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，则Rep（E）= &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录创建 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; （其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; )，则Rep（E）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录字段访问 &lt;code&gt;E_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（E）= &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（E）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录更新 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; （其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子），则Rep（E）= &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;try B after A end&lt;/code&gt; 的try表达式，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，然后Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是一个主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是一个catch子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是catch子句，然后Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个元组骨架 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果E是变量 &lt;code&gt;V&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">如果E是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（E）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是if表达式， &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Ic_i&lt;/code&gt; 是一个if子句，则Rep（E）= &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;E_1 Op E_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（E）= &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;Op E_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符，则Rep（E）= &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果E为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">如果以长名称分布式模式启动Erlang，则需要从某个位置获取域名并读取系统 &lt;code&gt;inet&lt;/code&gt; 配置文件以获取此信息。找到的所有主机和解析器信息也会被记录，但只要为本地查询配置了Erlang，就不会使用它们。如果将查找方法更改为 &lt;code&gt;'file'&lt;/code&gt; 或 &lt;code&gt;'dns'&lt;/code&gt; ，则该信息将很有用，请参见下文。</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">例如，如果Erlang将列表 &lt;code&gt;[$a,$b,$c]&lt;/code&gt; 发送到端口，则 &lt;code&gt;bufflen&lt;/code&gt; 变量为 &lt;code&gt;3&lt;/code&gt; ， &lt;code&gt;buff&lt;/code&gt; 变量包含 &lt;code&gt;{'a','b','c'}&lt;/code&gt; （无 &lt;code&gt;NULL&lt;/code&gt; 终止） ）。通常，第一个字节用作操作码，在该驱动程序中也是如此（至少在端口处于 &lt;code&gt;command&lt;/code&gt; 模式时）。操作码定义如下：</target>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数声明 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是具有相同长度 &lt;code&gt;Arity&lt;/code&gt; 的模式序列的函数子句，然后Rep（F）= &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中 &lt;code&gt;Spec&lt;/code&gt; 是原子 &lt;code&gt;spec&lt;/code&gt; 或原子 &lt;code&gt;callback&lt;/code&gt; ，并且每个 &lt;code&gt;Ft_i&lt;/code&gt; 是一个受约束的函数类型，其参数序列的长度为 &lt;code&gt;Arity&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中每个 &lt;code&gt;Ft_i&lt;/code&gt; 是一个可能受约束的函数类型，其参数序列具有相同的长度 &lt;code&gt;Arity&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">如果F是记录声明 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; ，其中每个 &lt;code&gt;V_i&lt;/code&gt; 是一个记录字段，则Rep（F）= &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。对于Rep（V），请参见下文。</target>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是记录字段类型 &lt;code&gt;Name :: Type&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是类型，则Rep（F）= &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是类型声明 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是原子 &lt;code&gt;type&lt;/code&gt; 或原子 &lt;code&gt;opaque&lt;/code&gt; ，则每个 &lt;code&gt;V_i&lt;/code&gt; 是变量，而 &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（F ）= &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">如果F是通配属性 &lt;code&gt;-A(T)&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; 则Rep（F）= {attribute，LINE，export，[{Fun_1，A_1}，...，{Fun_k， A_k}]}。</target>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-file(File,Line)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 则Rep（F）= {attribute，LINE，import，{Mod，[{Fun_1，A_1}，.. 。，{Fun_k，A_k}]}}。</target>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-module(Mod)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">如果 &lt;code&gt;Ft_1 when Fc&lt;/code&gt; Ft是约束函数类型Ft_1，其中 &lt;code&gt;Ft_1&lt;/code&gt; 是函数类型，而 &lt;code&gt;Fc&lt;/code&gt; 是函数约束，则Rep（T）= &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 。对于Rep（Fc），请参见下文。</target>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果Ft是函数类型 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; ，其中每个 &lt;code&gt;T_i&lt;/code&gt; 是一种类型，则Rep（Ft）= &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">如果G是有向图，则认为G的顶点和边缘与 &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; 的顶点和边缘相同。</target>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果Gt是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个保护测试，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个类型特定列表，则Rep（Gt）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见上文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个缺点骨架 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; ，然后Rep（Gt）= &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个函数调用 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，则Rep（Gt）= &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个函数调用 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; ，其中 &lt;code&gt;A_m&lt;/code&gt; 是原子 &lt;code&gt;erlang&lt;/code&gt; ,而 &lt;code&gt;A&lt;/code&gt; 是原子或运算符，则Rep（Gt）= &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图更新 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 或 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">如果Gt是带括号的防护测试 &lt;code&gt;( Gt_0 )&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;Rep(Gt_0)&lt;/code&gt; ，即，不能将带括号的防护测试与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录创建 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段，则访问 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是元组骨架 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果Gt是可变模式 &lt;code&gt;V&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中A是一个原子，其打印名称与 &lt;code&gt;V&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">如果Gt是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（Gt）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是运算符防护测试 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（Gt）= &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是操作员防护测试 &lt;code&gt;Op Gt_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元操作符，则Rep（Gt）= &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果Gt为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是字符文字，则Rep（L）= &lt;code&gt;{char,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是浮点文字，则Rep（L）= &lt;code&gt;{float,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">如果L是由字符 &lt;code&gt;C_1&lt;/code&gt; ，...， &lt;code&gt;C_k&lt;/code&gt; 组成的字符串文字，则Rep（L）= &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是原子文字，则Rep（L）= &lt;code&gt;{atom,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是整数文字，则Rep（L）= &lt;code&gt;{integer,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">如果Mnesia在本地节点上处于关闭状态，则该函数返回当前可运行的其他 &lt;code&gt;db_nodes&lt;/code&gt; 和 &lt;code&gt;extra_db_nodes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">如果启动了Mnesia，则该函数返回本地节点上的Mnesia完全连接到的那些节点。只有Mnesia与之交换了架构信息的那些节点 &lt;code&gt;running_db_nodes&lt;/code&gt; 包含为running_db_nodes。合并架构后，本地Mnesia系统将完全可操作，并且应用程序可以执行对远程副本的访问。在架构合并之前，Mnesia仅在本地运行。有时， &lt;code&gt;running_db_nodes&lt;/code&gt; 列表中包含的节点比所有 &lt;code&gt;db_nodes&lt;/code&gt; 和 &lt;code&gt;extra_db_nodes&lt;/code&gt; 都多。</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">如果将Mnesia用作存储方法，则必须在HTTP服务器之前启动Mnesia。首次启动Mnesia时，必须在启动Mnesia之前创建架构和表。这里提供了一个简单的示例，其中包含创建和启动Mnesia的两个功能的模块。首次使用功能 &lt;code&gt;first_start/0&lt;/code&gt; 。它创建架构和表。 &lt;code&gt;start/0&lt;/code&gt; 将在连续的启动中使用。 &lt;code&gt;start/0&lt;/code&gt; 启动Mnesia，并等待表初始化。仅在已创建模式和表时才可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果P是位串模式 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是可以计算为整数的表达式，并且每个 &lt;code&gt;TSL_i&lt;/code&gt; 是类型特定的列表，则Rep（P）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是复合模式 &lt;code&gt;P_1 = P_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">如果P是一个缺点模式 &lt;code&gt;[P_h | P_t]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果P是地图模式 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果P是nil模式 &lt;code&gt;[]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">如果P是带括号的模式 &lt;code&gt;( P_0 )&lt;/code&gt; ，则Rep（P）= &lt;code&gt;Rep(P_0)&lt;/code&gt; ，即，不能将带括号的模式与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录字段索引模式 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（P）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录模式 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果P是元组模式 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">如果P是通用模式 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果P是可变图案 &lt;code&gt;V&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中A是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">如果P是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（P）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;Op P_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符（这是一个表达式的出现，可以在编译时将其评估为数字），则Rep（P）= &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;P_1 Op P_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是二进制运算符（这是应用于文字字符串或字符列表的 &lt;code&gt;++&lt;/code&gt; 的出现，或者是在编译时可以求值为数字的表达式的出现），然后Rep（P）= &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">如果想要PER编码。</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">如果Ps是模式 &lt;code&gt;P_1, ..., P_k&lt;/code&gt; 的序列，则Rep（Ps）= &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; 。这样的序列作为函数或fun的参数列表出现。</target>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是位串生成器 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">如果Q是过滤器 &lt;code&gt;E&lt;/code&gt; （其中 &lt;code&gt;E&lt;/code&gt; 是表达式），则Rep（Q）= &lt;code&gt;Rep(E)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是生成器 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">如果R是从X到Y的关系，而S是从Y到Z的关系，则R和S 的&lt;strong id=&quot;relative_product&quot;&gt;相对乘积&lt;/strong&gt;是从X到Z的关系T定义为x T z当且仅当存在元素y时在Y中使得x R y和y S z为。</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">如果R是X中的一个关系，并且如果S被定义为x S y如果x R y而不是x = y，则S是对应于R 的&lt;strong id=&quot;strict_relation&quot;&gt;严格&lt;/strong&gt;关系。反之，如果S是X中的关系，并且定义R使得如果x S y或x = y时x R y，则R是对应于S 的&lt;strong id=&quot;weak_relation&quot;&gt;弱&lt;/strong&gt;关系。</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">如果R是X中的等价关系，并且x是X的元素，则相对于R的x 的&lt;strong id=&quot;equivalence_class&quot;&gt;等价类&lt;/strong&gt;是X的所有元素y的集合。等价类构成X的一个分区。相反，如果C是X的一个分区，则如果X的任何两个元素属于相同的等价类，则对X的任意两个元素成立的关系是由分区C引起的等价关系。</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">如果R是X中的等价关系，则&lt;strong id=&quot;canonical_map&quot;&gt;规范映射&lt;/strong&gt;是将X的每个元素映射到其等价类的函数。</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">如果S是R对A的限制，则R是S对X 的&lt;strong id=&quot;extension&quot;&gt;扩展&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">如果S是Set的元素（T，X），则T是X 的&lt;strong id=&quot;valid_type&quot;&gt;有效类型&lt;/strong&gt;，T是S的类型，并且X是S的外部集合 &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; 从类型和Erlang创建一个集合术语变成了外部集合。</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;.rel&lt;/code&gt; 文件中未将SASL作为应用程序包括在内，则会发出警告，因为这样的发行版不能在升级中使用。要关闭此警告，请添加选项 &lt;code&gt;no_warn_sasl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">如果使用SNMPv3,则默认加载这些MIB。</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">如果将SetFun指定为fun,则将fun应用于给定集合的每个元素,并假定返回值是一个集合。</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">如果将SetFun指定为元组 &lt;code&gt;{external, Fun}&lt;/code&gt; ，则将Fun应用于给定集合的每个元素的外部集合，并假定返回值为外部集合。在本实施方式中，选择无序集合的元素作为外部集合并从外部集合的列表中组装新的无序集合比将每个元素修改为集合更有效。但是，仅当无序集的元素是原子集或有序集时才可以使用此优化。还必须是元素的类型与Fun的某个子句匹配的情况（创建的集合的类型是将Fun应用于给定集合的类型的结果），并且Fun除了选择​​，复制或重新排列元素的一部分。</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">如果T为 &lt;code&gt;( T_0 )&lt;/code&gt; ，则Rep（T）= &lt;code&gt;Rep(T_0)&lt;/code&gt; ，即，不能将括号类型与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是位串类型 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 是单例整数类型，则Rep（T）= &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun(Ft)&lt;/code&gt; ，其中 &lt;code&gt;Ft&lt;/code&gt; 是一个函数类型，则Rep（T）= &lt;code&gt;Rep(Ft)&lt;/code&gt; 。对于Rep（Ft），请参见下文。</target>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果T是地图类型 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联类型），则Rep（T）= &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">如果T是地图类型 &lt;code&gt;map()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是预定义（或内置）类型 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">如果T是记录类型 &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; ，其中每个 &lt;code&gt;F_i&lt;/code&gt; 是记录字段类型，则Rep（T）= &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; 。对于Rep（F），请参见下文。</target>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">如果T是远程类型 &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个元组类型 &lt;code&gt;tuple()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个元组类型 &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是类型并集 &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; ，然后Rep（T）= &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">如果T是类型变量 &lt;code&gt;V&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。类型变量是除下划线（ &lt;code&gt;_&lt;/code&gt; ）之外的任何变量。</target>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是用户定义的类型 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是带注释的类型 &lt;code&gt;A :: T_0&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是变量，则Rep（T）= &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">如果T是一个原子或整数文字L,那么Rep(T)=Rep(L)。</target>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是整数范围类型 &lt;code&gt;L .. H&lt;/code&gt; ，其中 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;H&lt;/code&gt; 是单例整数类型，则Rep（T）= &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">如果T是运算符类型 &lt;code&gt;Op T_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符（这是一个表达式的出现，可以在编译时将其评估为整数），则Rep（T）= &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个运算符类型 &lt;code&gt;T_1 Op T_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一个二进制运算符（这是一个表达式的出现，可以在编译时将其评估为整数），则Rep（T）= &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">如果T是空列表类型 &lt;code&gt;[]&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">如果请求TLS（ &lt;code&gt;Bool=true&lt;/code&gt; ），则连接过程应与对等方发起TLS握手，并且接受过程应准备接受握手。成功握手后，应向父进程发送一条 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 消息。握手失败应导致进程退出。</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">如果TS是类型说明符 &lt;code&gt;A:Value&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是原子，而 &lt;code&gt;Value&lt;/code&gt; 是整数，则Rep（TS）= &lt;code&gt;{A,Value}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果TS是一个类型说明符 &lt;code&gt;A&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，然后代表（TS）= &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">如果要对远程节点使用跟踪工具生成器，强烈建议将跟踪控制节点启动为&lt;strong&gt;hidden&lt;/strong&gt;。这样，它可以连接到被跟踪的节点而不会被它&amp;ldquo;看到&amp;rdquo;，也就是说，如果在被跟踪的节点上调用 &lt;code&gt;nodes()&lt;/code&gt; BIF，则不会显示跟踪控制节点。要启动隐藏节点，请在 &lt;code&gt;erl&lt;/code&gt; 命令中添加 &lt;code&gt;-hidden&lt;/code&gt; 选项，例如：</target>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参见 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串 &lt;code&gt;VarName&lt;/code&gt; 可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参见 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串 &lt;code&gt;VarName&lt;/code&gt; 和 &lt;code&gt;Value&lt;/code&gt; 可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参阅 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">如果Unicode文件名转换有效并且文件系统是透明的，则可能会遇到无法解释为Unicode的文件名，在这种情况下，必须准备好 &lt;code&gt;fun()&lt;/code&gt; 来处理原始文件名（即二进制文件）。如果正则表达式包含&amp;gt; 255的代码点，则它与不符合预期字符编码的文件名不匹配（即，未以有效的UTF-8编码）。</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">如果启用了Unicode文件名，则对 &lt;code&gt;os:getenv/0,1&lt;/code&gt; ， &lt;code&gt;os:putenv/2&lt;/code&gt; 和 &lt;code&gt;os:unsetenv/1&lt;/code&gt; 的调用将处理Unicode字符串。在类似Unix的平台上，内置函数可能会将UTF-8中的环境变量转换为Unicode字符串或从Unicode字符串转换为环境变量，而代码点可能大于255。在Windows上，使用了环境系统API的Unicode版本，并且代码点大于255被允许。</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">如果Unicode翻译有效（ &lt;code&gt;~ts&lt;/code&gt; ），则接受大于255的字符，否则不接受。使用translation修饰符，返回的列表因此也可以包含大于255的整数：</target>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A :: T&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（V）= &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A = E :: T&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 是一个表达式， &lt;code&gt;T&lt;/code&gt; 是一个类型，则Rep（V）= &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A = E&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 是一个表达式，则Rep（V）= &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果V为 &lt;code&gt;A&lt;/code&gt; ，则Rep（V）= &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">如果VM处于Unicode文件名模式，则 &lt;code&gt;string()&lt;/code&gt; 和 &lt;code&gt;char()&lt;/code&gt; 的值应大于255。另请参见 &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; 类型的文档。</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">如果VM处于Unicode文件名模式，则允许的字符&amp;gt; &lt;code&gt;RawFilename&lt;/code&gt; 是不受Unicode转换限制的文件名，这意味着它可以包含不符合文件系统预期的Unicode编码的字符（即非UTF） -8个字符（尽管VM以Unicode文件名模式启动）。空字符（整数值为零）的&lt;strong&gt;未&lt;/strong&gt;在文件名中不允许（未甚至在结束时）。</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">如果X = Y，则R被称为关系&lt;strong&gt;在&lt;/strong&gt; X.</target>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果通过顶点 &lt;code&gt;V&lt;/code&gt; 存在长度为2或更大的 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; ，则该循环将作为顶点列表 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 返回。如果一个 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 通过 &lt;code&gt;V&lt;/code&gt; 存在，则循环返回为一个列表 &lt;code&gt;[V]&lt;/code&gt; 。如果不存在通过 &lt;code&gt;V&lt;/code&gt; 的循环，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">如果代码路径中已存在 &lt;code&gt;Dir&lt;/code&gt; ，则将其从旧位置删除。</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">如果 &lt;code&gt;StateFun&lt;/code&gt; 函数崩溃或引发异常，则 &lt;code&gt;gen_server&lt;/code&gt; 和 &lt;code&gt;gen_statem&lt;/code&gt; 进程的原始状态不变。对于 &lt;code&gt;gen_event&lt;/code&gt; 进程，崩溃或失败的 &lt;code&gt;StateFun&lt;/code&gt; 函数意味着只有失败或崩溃时正在处理的特定事件处理程序的状态不变；它仍然可以成功更改在同一 &lt;code&gt;gen_event&lt;/code&gt; 进程中注册的其他事件处理程序的状态。</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">如果 &lt;code&gt;StateFun&lt;/code&gt; 函数决定不对进程状态进行任何更改，则无论进程类型如何，它都可以返回其 &lt;code&gt;State&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定了 &lt;code&gt;Tag&lt;/code&gt; ，则返回的 &lt;code&gt;Match&lt;/code&gt; 还包括匹配的 &lt;code&gt;Tag&lt;/code&gt; 。否则，仅返回 &lt;code&gt;RxMatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">如果指定了 &lt;code&gt;Threshold&lt;/code&gt; ，则在发生以下情况时，计数器将重置为值 &lt;code&gt;SetValue&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;pid()&lt;/code&gt; ，则存在元组 &lt;code&gt;{timeout, Millis}&lt;/code&gt; ， &lt;code&gt;{in, Location}&lt;/code&gt; 和 &lt;code&gt;{out, Location}&lt;/code&gt; ，其中 &lt;code&gt;Location&lt;/code&gt; 是描述该函数的MFA（ &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; ）被安排进/出，或原子 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">如果 &lt;code&gt;port()&lt;/code&gt; ，则存在元组 &lt;code&gt;{timeout, Millis}&lt;/code&gt; 和 &lt;code&gt;{port_op,Op}&lt;/code&gt; 。 &lt;code&gt;Op&lt;/code&gt; 是 &lt;code&gt;proc_sig&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; ， &lt;code&gt;input&lt;/code&gt; ， &lt;code&gt;output&lt;/code&gt; ， &lt;code&gt;event&lt;/code&gt; 或 &lt;code&gt;dist_cmd&lt;/code&gt; 之一，具体取决于正在执行的驱动程序回调。</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">如果发现 &lt;code&gt;property_parm()&lt;/code&gt; 作为输入（ &lt;code&gt;SDP&lt;/code&gt; ）的一部分，则将其保持不变。</target>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;relup&lt;/code&gt; 文件和/或名为 &lt;code&gt;sys.config&lt;/code&gt; 的系统配置文件或 &lt;code&gt;sys.config.src&lt;/code&gt; ，则这些文件也将包含在发行包中。请参阅 &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">如果出现&lt;strong&gt;滴答声&lt;/strong&gt;，即连接另一端的Erlang节点已轮询该节点以查看其是否仍然存在，则该函数返回 &lt;code&gt;ERL_TICK&lt;/code&gt; 且缓冲区中未放置任何消息。同样， &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EAGAIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">如果出现&lt;strong&gt;滴答声&lt;/strong&gt;，即连接另一端的Erlang节点已轮询该节点以查看其是否仍在运行，则该函数返回 &lt;code&gt;ERL_TICK&lt;/code&gt; ,指示已接收并响应了滴答声，但未放置任何消息在缓冲区中。在这种情况下，您将再次调用 &lt;code&gt;erl_receive_msg()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">如果将二进制文件作为消息发送到进程或端口，则该二进制文件将缩小，并且任何进一步的追加操作会将二进制数据复制到新的二进制文件中。例如，在下面的代码片段中， &lt;code&gt;Bin1&lt;/code&gt; 将被复制到第三行：</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">如果二进制文件引用了较大的二进制文件（通常描述为子二进制文件），则获取所引用二进制文件的大小可能很有用。可以在程序中使用此功能来触发 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; 的使用。通过复制二进制文件，可以取消引用原始的（可能是较大的）二进制文件，而较小的二进制文件将对其进行引用。</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">如果将调用添加到此函数（例如在模块 &lt;code&gt;m1&lt;/code&gt; 中)，则如果首先加载新版本的 &lt;code&gt;m1&lt;/code&gt; 并在加载新版本的 &lt;code&gt;ch3&lt;/code&gt; 之前调用 &lt;code&gt;ch3:available/0&lt;/code&gt; ，则在发行升级期间可能会发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">如果回调(在TFTP服务器中执行文件访问)需要的时间太长(超过TFTP的双倍超时),服务器就会中止连接,并向客户端发送一个错误回复。这意味着服务器比以前更快地释放连接上的资源。服务器只是认为客户端已经放弃了。</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">如果回调函数失败或返回错误值，则 &lt;code&gt;gen_server&lt;/code&gt; 进程终止。</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">如果回调函数失败或返回错误值，除非另有说明，否则 &lt;code&gt;gen_statem&lt;/code&gt; 终止。但是，类 &lt;code&gt;throw&lt;/code&gt; 的异常不被视为错误，而是所有回调函数的有效返回。</target>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">如果一个子进程终止,其他所有的子进程都会被终止,然后包括被终止的子进程在内的所有子进程都会被重新启动。</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">如果一个子进程终止,只有该进程被重新启动。</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">如果一个子进程终止,其余的子进程(也就是按启动顺序排在终止进程之后的子进程)就会被终止。然后,终止的子进程和其余的子进程被重新启动。</target>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">如果客户端和服务器想要使用升级机制,比如RFC 2817定义的升级机制,将普通的TCP/IP连接升级为TLS连接,那么Erlang SSL应用API就支持这个机制。这对于在同一端口上支持HTTP和HTTPS以及实现虚拟主机等都很有用。注意这只是TLS功能。</target>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">如果客户端发送了多个限制服务器响应权限的头字段，则标准未指定如何处理。 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 按以下顺序控制每个字段，如果其中一个字段与当前状态不匹配，则请求将被拒绝并给出适当的响应：</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">如果外壳无法识别命令（本地函数调用），则首先尝试在 &lt;code&gt;user_default&lt;/code&gt; 模块中找到可以放置自定义本地命令的函数。如果找到，则对函数进行评估，否则尝试在模块 &lt;code&gt;shell_default&lt;/code&gt; 中评估该函数。必须明确加载模块 &lt;code&gt;user_default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">如果存在选择 &lt;code&gt;encoding&lt;/code&gt; 的注释，则该注释可以位于第二行。</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">如果完整的系统由无磁盘和/或只读客户机节点组成，则将 &lt;code&gt;clients&lt;/code&gt; 目录添加到 &lt;code&gt;$ROOT&lt;/code&gt; 目录中。只读节点是具有只读文件系统的节点。</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">如果将具有较大窗口大小的压缩流指定为输入，则 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 会引发 &lt;code&gt;data_error&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">如果一个已经匹配的子模式的条件测试指的是一个非唯一的数字,那么如果该数字的任何一个子模式已经匹配,则测试为真。</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">如果在多个文件中定义了配置变量，并且您想访问所有可能的值，请使用函数 &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; 并在选项列表中指定 &lt;code&gt;all&lt;/code&gt; 变量。然后，这些值将以列表形式返回，并且元素的顺序与启动时指定配置文件的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">如果在多个文件中定义了配置变量，请使用选项 &lt;code&gt;all&lt;/code&gt; 访问所有可能的值。这些值将在列表中返回。元素的顺序与启动时指定配置文件的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">如果配置变量键已与名称关联（通过 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 语句），则可以使用名称代替键来读取值：</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">如果连接尝试失败,可以检查以下内容。</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">如果在执行此指令后发生崩溃，则系统将无法恢复并从旧发行版重新启动。该指令只能在脚本中出现一次。它应放置在所有 &lt;code&gt;load_object_code&lt;/code&gt; 指令之后。</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">如果发生碰撞，一个 &lt;code&gt;erl_crash.dump&lt;/code&gt; 是&lt;strong&gt;不&lt;/strong&gt;写，除非环境变量 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 是集：</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">如果安装了定制CLI（请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; ），则上述规则将替换为定制CLI所暗示的思想。</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">如果指定了默认对象 &lt;code&gt;Default&lt;/code&gt; ，则在表中缺少键时，它将用作要更新的对象。代替键的值将被忽略，并由正确的键值代替。返回值就像未使用默认对象一样，即单个更新的元素或它们的列表。</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">如果目录同时受HTTP服务器配置文件中的身份验证指令和 &lt;code&gt;htaccess&lt;/code&gt; 文件的限制，则两种方法都必须允许用户访问该文件，请求才能成功。</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">如果发生灾难并且 &lt;code&gt;Mnesia&lt;/code&gt; 数据库已损坏，则可以从备份中重建它。将此作为万不得已的方法，因为备份中包含旧数据。希望数据是一致的，但是当使用旧备份还原数据库时，数据肯定会丢失。</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">如果无盘和/或只读客户端节点将要启动，则文件 &lt;code&gt;start_erl.data&lt;/code&gt; 位于主节点的客户端目录中。因此， &lt;code&gt;START_ERL_DATA&lt;/code&gt; 行如下所示：</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">如果无盘和/或只读客户端节点与SASL配置参数 &lt;code&gt;static_emulator&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 即将启动，将 &lt;code&gt;-boot&lt;/code&gt; 和 &lt;code&gt;-config&lt;/code&gt; 标志必须改变。</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">如果使用的是功能型驱动(就是不持有任何状态,只是做一些繁重的计算和返回结果),可以事先打开几个注册名称的端口,根据调度器ID选择要使用的端口,如下图。</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">如果在R13A或以后的版本中增加了某个功能,则会在文中提及。</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">如果指定一个文件名作为参数,Debugger会尝试从这个文件中加载其设置。有关设置的详细信息,请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">如果某个过滤器或处理程序仍然崩溃,Logger 将从配置中删除相关的过滤器或处理程序,并向终端打印一条简短的错误信息。还会发出一个包含崩溃原因和其他细节的调试事件。</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">如果在尝试注册乐趣时已经注册了乐趣，则返回 &lt;code&gt;{error, exists}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">如果将一个函数指定为输入，并且最后一个输入函数返回 &lt;code&gt;{end_of_input, Value}&lt;/code&gt; ，则指定为输出的函数将使用参数 &lt;code&gt;{value, Value}&lt;/code&gt; 调用。这样就很容易用输入函数计算出的值来初始化输出函数的序列。</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">如果系统中的垃圾回收导致分配的堆大小至少为 &lt;code&gt;Size&lt;/code&gt; 字 &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; 将消息{monitor，GcPid，large_heap，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;GcPid&lt;/code&gt; 和 &lt;code&gt;Info&lt;/code&gt; 与先前的 &lt;code&gt;long_gc&lt;/code&gt; 相同，除了不存在带有 &lt;code&gt;timeout&lt;/code&gt; 标记的元组。</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">如果系统中的垃圾回收至少花费了 &lt;code&gt;Time&lt;/code&gt; 墙上时钟毫秒 &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; 一条消息{monitor，GcPid，long_gc，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;GcPid&lt;/code&gt; 是被垃圾回收的pid。 &lt;code&gt;Info&lt;/code&gt; 是一个由两个元素组成的元组的列表，描述了垃圾回收的结果。</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">如果给定的模块不是Cover编译的，则由错误原因 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">如果组包含子组，则还可以在组元组中指定这些组的执行属性： &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; 其中， &lt;code&gt;SubGroups&lt;/code&gt; 是元组列表， &lt;code&gt;{GroupName,Properties}&lt;/code&gt; 或 &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; 代表子组。在&amp;ldquo; &lt;code&gt;group/0&lt;/code&gt; 为组定义的，未在&amp;ldquo; &lt;code&gt;SubGroups&lt;/code&gt; 列表中指定的任何子组都将使用其预定义的属性执行。</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">如果组具有并行属性，则同时生成其测试用例并并行执行。但是，不允许一个测试用例与 &lt;code&gt;end_per_group/2&lt;/code&gt; 并行执行，这意味着执行并行组的时间等于该组中最慢的测试用例的执行时间。并行运行测试用例的负面影响是，直到该组的功能 &lt;code&gt;end_per_group/2&lt;/code&gt; 完成，HTML摘要页面才会使用指向各个测试用例日志的链接进行更新。</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">如果与当前配置相比删除了一个键,并且记录仪知道该键,则使用默认值。如果是自定义键,那么是删除该值还是插入默认值,则由处理程序实现。</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">如果与当前配置相比,删除一个键,则使用默认值。</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">如果给出 &lt;code&gt;ModFiles&lt;/code&gt; 列表作为输入，则将返回 &lt;code&gt;Result&lt;/code&gt; 列表。返回列表的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如果在 &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; 中使用了标识符列表：</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">如果本地函数与自动导入的BIF具有相同的名称，则语义是隐式限定的函数调用将定向到本地定义的函数，而不是BIF。为避免混淆，有一个可用的编译器指令 &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; ，该指令不会自动导入BIF。在某些情况下，这样的编译指令是强制性的。</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">如果日志事件通过特定处理程序的所有主过滤器和所有处理程序过滤器，则Logger会将事件转发到&lt;strong&gt;处理程序回调&lt;/strong&gt;。处理程序将事件格式化并打印到其目的地。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">如果将日志配置为分发，则可能未在所有节点上记录所有项目。 &lt;code&gt;wrap_log_reader&lt;/code&gt; 只读取被调用节点上的日志。用户应确保已阅读所有项目。</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">如果具有指定名称的日志在某个节点上是本地的，并且试图打开分布在同一节点上的日志，则返回元组 &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; 。如果日志分布在某个节点上，则返回相同的元组，并且尝试在同一节点上本地打开日志。首次打开单个分布式磁盘日志时，会将这些日志添加到（可能为空）分布式磁盘日志中。所提供的选项值可用于option &lt;code&gt;distributed&lt;/code&gt; 提到的所有节点上。单个分布式日志对彼此的选项值一无所知，因此可以通过创建一个分布式日志来给每个节点唯一的选项值，该分布式日志包含对 &lt;code&gt;open/1&lt;/code&gt; 的多次调用。</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">如果一个宏在多个模块中使用,建议将宏定义放在一个include文件中。</target>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">如果匹配失败，则在某些情况下仍应接受证书。例如，以您选择接受过期证书的Web浏览器为例。此选项可启用此功能。这个 &lt;code&gt;fun/1&lt;/code&gt; 被调用时没有 &lt;code&gt;ReferenceID&lt;/code&gt; 匹配。fun的返回值（ &lt;code&gt;boolean()&lt;/code&gt; ）决定结果。如果为 &lt;code&gt;true&lt;/code&gt; ，则证书被接受，否则被拒绝。请参阅 &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; 用户指南》中的&amp;ldquo;固定&amp;rdquo;证书。</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">如果成员终止,则会自动从组中删除。</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">如果在 &quot;虚拟 &quot;连接建立之前收到消息,连接将自动建立。MGC可以真正的开放,根据传输层接触的方式,动态决定使用哪种编码和传输服务。对于IP传输来说,有两个端口是标准化的,一个用于文本编码,一个用于二进制编码。例如在文本端口上收到一个UDP数据包,就可以在飞行中决定编码和传输。</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">如果模块不是Cover编译的，则由错误原因 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">如果模块是从 &lt;code&gt;.beam&lt;/code&gt; 文件编译而来的，即使用 &lt;code&gt;compile_beam/1&lt;/code&gt; 或 &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; ，则假定可以在与 &lt;code&gt;.beam&lt;/code&gt; 文件相同的目录中找到源代码，相对于 &lt;code&gt;../src&lt;/code&gt; 到该目录，或使用 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 中的源路径。使用后者时，将检查两条路径：首先是通过连接 &lt;code&gt;../src&lt;/code&gt; 和在尾随 &lt;code&gt;src&lt;/code&gt; 组件下方的已编译路径的尾部构造的路径，然后是已编译路径本身。如果未找到源代码，则由错误原因 &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">如果一个监控进程变得如此之大,以至于自己在垃圾收集时开始引起系统监控消息,这些消息扩大了进程消息队列,很可能使问题变得更糟。</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">如果进行了更复杂的更改（例如，更改 &lt;code&gt;gen_server&lt;/code&gt; 内部状态的格式），则简单的代码替换是不够的。相反，必须：</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">如果发生名称冲突，则编译器将报告 &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; 消息，该消息表明是否重命名了定义以及必须用于编码/解码数据的新名称。</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Files&lt;/code&gt; 中的名称不是现有文件的名称，则Igor会假定它代表模块名称，并尝试查找和读取相应的源文件。解析的文件被附加到 &lt;code&gt;Sources&lt;/code&gt; 并传递到 &lt;code&gt;merge_sources/3&lt;/code&gt; ，即 &lt;code&gt;Sources&lt;/code&gt; 中的条目在从文件读取条目之前被列出。</target>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">如果使用与现有记录相同的键插入新项，则旧记录将被覆盖。但是，如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ，则每个键都可以映射到多个记录。类型 &lt;code&gt;bag&lt;/code&gt; 表中的所有记录都是唯一的，只有密钥可以重复。</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">如果引入新模块,则使用以下指令。</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">如果一个节点在脏操作过程中宕机,表加载机制会确保更新在所有副本上执行,或者不执行。异步脏更新和同步脏更新都使用与轻量级事务相同的恢复原理。</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">如果某个节点发生故障，则将删除与该节点的所有连接。调用 &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; 强制断开节点连接。</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">如果启动了一个节点，该节点根据 &lt;code&gt;distributed&lt;/code&gt; 优先级高于运行分布式应用程序的节点，则该应用程序将在新节点处重新启动，并在旧节点处停止。这称为&lt;strong&gt;收购&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">如果使用选项 &lt;code&gt;extended&lt;/code&gt; 编译模式，则模式中的空格（字符类中的字符除外）以及字符类外部的＃与下一个换行符之间的字符将被忽略。转义的反斜杠可用于在模式中包含空格或＃字符。</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">如果模式以。*或。{0，}开头，并且设置了 &lt;code&gt;dotall&lt;/code&gt; 选项（等效于Perl选项 &lt;code&gt;/s&lt;/code&gt; ），从而允许该点与换行符匹配，则该模式将隐式锚定，因为以下内容将针对每个字符位置进行尝试在主题字符串中。因此，在第一个位置之后的任何位置重试整个比赛都没有意义。PCRE通常将模式视为\ A开头。</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">如果模式以 &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; 开头，则其作用与在编译时设置选项 &lt;code&gt;no_start_optimize&lt;/code&gt; 的作用相同。</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">如果一个永久的应用程序终止,所有其他应用程序和整个Erlang节点也会被终止。</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">如果一个永久应用程序终止,所有其他应用程序和运行时系统也会被终止。</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">如果将端口放入运行队列或从运行队列中删除 &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; ，则会向 &lt;code&gt;ProfilerPid&lt;/code&gt; 发送一条消息{profile，Port，State，0，Ts}。</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">如果一个包含一个或多个捕获子模式的正断言成功了,但在模式的后面未能匹配导致在这个断言上回溯,那么只有在没有更高编号的捕获已经被设置的情况下,断言内的捕获才会被重置。不幸的是,这是当前实现的一个基本限制,而且由于PCRE1现在只处于维护状态,所以不太可能改变。</target>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">如果需要预设字典来进一步解压缩，则此函数返回 &lt;code&gt;need_dictionary&lt;/code&gt; 元组。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">如果某个进程在未先设置种子的情况下调用了 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; ,则将自动调用 &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">如果某个进程在没有先设置种子的情况下调用了 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; ，则使用默认算法自动调用 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; ，并创建一个非恒定种子。</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">如果加载了驱动程序的进程死亡,则与卸载时的效果相同。</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">如果在系统中的处理被暂停，因为它发送到一个繁忙的港口，消息 &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; 被发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;SusPid&lt;/code&gt; 是发送到 &lt;code&gt;Port&lt;/code&gt; 时挂起的pid 。</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">如果系统中的某个进程由于发送到远程节点上的某个进程而挂起，则该节点的节点间通信已由繁忙端口处理，则消息 &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; 发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;SusPid&lt;/code&gt; 是通过节点间通信端口 &lt;code&gt;Port&lt;/code&gt; 发送时挂起的pid 。</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">如果将某个进程放入或从运行队列中删除，则将 &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; 发送到 &lt;code&gt;ProfilerPid&lt;/code&gt; 。被抢占后重新插入到运行队列中的正在运行的进程不会触发此消息。</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">如果系统中的进程或端口至少在 &lt;code&gt;Time&lt;/code&gt; 墙上时钟毫秒内未中断运行 &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; 消息{monitor，PidOrPort，long_schedule，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;PidOrPort&lt;/code&gt; 是正在运行的进程或端口。 &lt;code&gt;Info&lt;/code&gt; 是描述事件的包含两个元素的元组的列表。</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">如果一个进程只是简单地保留二进制文件(无论是在 &quot;循环数据 &quot;中还是在进程字典中),垃圾收集器最终可以收缩这些二进制文件。如果只保留一个这样的二进制,它将不会被收缩。如果进程后来追加到一个被收缩的二进制,二进制对象将被重新分配,以给要追加的数据腾出位置。</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">如果持有锁的进程死亡,或者节点宕机,该进程持有的锁就会被删除。</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">如果一个注册了名字的进程死亡,或者节点宕机,该名字在所有节点上都会被取消注册。</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">如果在执行 &lt;code&gt;init_per_suite/1&lt;/code&gt; 的过程中产生了进程 &lt;code&gt;P&lt;/code&gt; ，则它会继承 &lt;code&gt;init_per_suite&lt;/code&gt; 进程的组长。该组负责人是前面提到的中央I / O服务器进程。如果稍后&lt;strong&gt;在并行测试用例执行期间&lt;/strong&gt;，某个事件触发进程 &lt;code&gt;P&lt;/code&gt; 调用 &lt;code&gt;io:format/1/2&lt;/code&gt; ，则该调用永不返回（因为组长处于非响应状态）并导致 &lt;code&gt;P&lt;/code&gt; 挂起。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">设置无大小写匹配时，如果使用包含字母的范围，则在两种情况下都将匹配字母。例如，[Wc]等效于[] [\\ ^ _`wxyzabc]，不区分大小写。在非UTF模式下，如果使用的是法语语言环境的字符表，则在两种情况下[\ xc8- \ xcb]都匹配带重音符号的E字符。在UTF模式下，PCRE仅在使用Unicode属性支持进行编译时才支持大小写大于255的字符的大小写概念。</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">如果收到的消息包含多个事务请求，则此选项指示是应在同一进程中按顺序处理请求（ &lt;code&gt;false&lt;/code&gt; ），还是应由自己的进程处理每个请求（为 &lt;code&gt;true&lt;/code&gt; ,即为每个请求派生一个单独的进程） 。</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">如果一条记录卡在节点 &lt;code&gt;N1&lt;/code&gt; 上,并且您尝试为该节点 &lt;code&gt;N2&lt;/code&gt; 上的记录设置粘滞锁，则该记录必须是未粘住的。此操作很昂贵，并且会降低性能。如果在 &lt;code&gt;N2&lt;/code&gt; 发出 &lt;code&gt;s_write/1&lt;/code&gt; 请求，则自动执行取消粘帖操作。</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">如果一个记录在多个模块中使用,建议将记录定义放在一个include文件中。</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">如果发生可恢复的错误，该函数将返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ,并且将恢复原始应用程序规范。如果发生不可恢复的错误，则系统将重新启动。</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">如果经常性核心转储想，让 &lt;code&gt;heart&lt;/code&gt; 通过kill信号设置为中止使用环境变量知道 &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; 。如果未设置或未设置为 &lt;code&gt;SIGABRT&lt;/code&gt; ，则默认行为是使用 &lt;code&gt;SIGKILL&lt;/code&gt; 的终止信号：</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">如果在带有 &lt;code&gt;ebin&lt;/code&gt; 子目录的代码路径中存在一个名为 &lt;code&gt;Name&lt;/code&gt; 或 &lt;code&gt;Name-Vsn&lt;/code&gt; 的常规目录，则返回此目录的路径（不是 &lt;code&gt;ebin&lt;/code&gt; 目录）。</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">如果没有及时收到请求的回复,megaco栈会从它的表中删除所有关于请求的信息。如果在这之后才收到回复,那么应用程序就无法知道该把这个消息发送到哪里。通过在本地节点(拥有链接的节点)上调用这个函数,消息就会被传递给 &quot;用户&quot;。</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">如果创建了一行，我们总是将内部列设置为 &lt;code&gt;&quot;internal&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调度程序无法绑定，则通常会默默地忽略它，因为并非总是可能验证有效的逻辑处理器标识符。如果报告错误，则会记录一个错误事件。要验证调度程序是否已按要求绑定，请调用 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调度程序无法绑定，则通常会默默地忽略它，因为并非总是可能验证有效的逻辑处理器标识符。如果报告了错误，则将其报告给 &lt;code&gt;error_logger&lt;/code&gt; 。如果要验证调度程序是否已按要求绑定，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">如果调度程序进入睡眠或唤醒 &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; 向 &lt;code&gt;ProfilerPid&lt;/code&gt; 发送一条消息{profile，scheduler，Id，State，NoScheds，Ts}。</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">如果一个调度器线程每纳秒创建一个新的引用,引用最早将在超过584年后被重复使用。也就是说,在可预见的未来,它们是足够唯一的。</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">如果找到脚本，则第一件事就是根据属于发行版本 &lt;code&gt;Vsn&lt;/code&gt; 的 &lt;code&gt;.app&lt;/code&gt; 文件和 &lt;code&gt;sys.config&lt;/code&gt; 更新应用程序规范。</target>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">如果重复洗牌的测试用例组,轮次之间不重置种子。</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">如果对功能模块进行了简单扩展，则足以将模块的新版本加载到系统中，并删除旧版本。这称为&lt;strong&gt;简单代码替换&lt;/strong&gt;，为此使用以下指令：</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">如果以某种方式连接了套接字而不使用 &lt;code&gt;gen_tcp&lt;/code&gt; ，请使用此选项传递文件描述符。</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">如果以某种方式连接了套接字而不使用 &lt;code&gt;gen_tcp&lt;/code&gt; ，请使用此选项传递文件描述符。如果将 &lt;code&gt;{ip, Address}&lt;/code&gt; 和/或 &lt;code&gt;{port, port_number()}&lt;/code&gt; 与该选项结合使用，则在连接前将 &lt;code&gt;fd&lt;/code&gt; 绑定到指定的接口和端口。如果未指定这些选项，则假定 &lt;code&gt;fd&lt;/code&gt; 已被适当绑定。</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">如果不使用 &lt;code&gt;gen_udp&lt;/code&gt; 就以某种方式打开了套接字，请使用此选项传递文件描述符。如果 &lt;code&gt;Port&lt;/code&gt; 未设置为 &lt;code&gt;0&lt;/code&gt; 和/或 &lt;code&gt;{ip, ip_address()}&lt;/code&gt; 与该选项结合使用，则 &lt;code&gt;fd&lt;/code&gt; 在打开后将绑定到指定的接口和端口。如果未指定这些选项，则假定 &lt;code&gt;fd&lt;/code&gt; 已被适当绑定。</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">如果已经连接了套接字，则可以使用选项 &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; 将打开的文件描述符传递给 &lt;code&gt;gen_udp&lt;/code&gt; 。这可以通过使用命令行参数自动说明预绑定文件描述符号来实现。例如，如果端口为69，并且文件描述符22由 &lt;code&gt;setuid_socket_wrap&lt;/code&gt; 打开，则命令行参数&amp;ldquo; -tftpd_69 22&amp;rdquo;将触发使用预绑定文件描述符22而不是打开端口69。UDP选项 &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; 自动添加。有关命令行参数，请参见 &lt;code&gt;init:get_argument/&lt;/code&gt; 有关UDP选项，请参见 &lt;code&gt;gen_udp:open/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">如果在具有 &lt;code&gt;shuffle&lt;/code&gt; 属性的组中指定了一个子组，则该子组相对于该组中的测试用例（和其他子组）的执行顺序是随机的。但是，子组中测试用例的顺序不是随机的（除非子组具有 &lt;code&gt;shuffle&lt;/code&gt; 属性）。</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">如果完成了从进程到端口的同步调用，则在对端口的调用运行时期间，该调用进程被视为不可运行。调用进程被通知为 &lt;code&gt;inactive&lt;/code&gt; ，后来 &lt;code&gt;active&lt;/code&gt; 当端口回调的回报。</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ，则有时可能需要删除具有特定键的某些记录。这可以通过 &lt;code&gt;delete_object/3&lt;/code&gt; 函数来完成。必须为此功能提供完整的记录。</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">如果表的类型为 &lt;code&gt;set&lt;/code&gt; ，则每个键都将导致一个或零个记录。</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">如果一个临时申请终止,会被报告,但没有其他申请被终止。</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">如果终端符号是类别的唯一成员，并且符号名称与类别名称相同，则标记格式可以为 &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">如果属于一个组的测试用例(根据组定义)在没有组规范的情况下被执行,也就是说,只是通过(使用命令行)。</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果测试用例失败，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果跳过测试用例，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">如果测试用例需要暂停自己的时间，并且该时间也 &lt;code&gt;multiply_timetraps&lt;/code&gt; multiple_timetraps （并且如果启用了 &lt;code&gt;scale_timetraps&lt;/code&gt; ,则可能还会放大），则可以使用功能 &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; （而不是例如 &lt;code&gt;timer:sleep/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">如果该模块的第三个实例被加载,代码服务器会删除(清除)旧的代码,并终止任何滞留在其中的进程。然后第三个实例变成 &quot;当前&quot;,之前的当前代码变成 &quot;旧&quot;。</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">如果模块的第三个实例被加载,代码服务器会删除(清除)旧的代码,并终止任何滞留在其中的进程。然后第三个实例变成 &quot;当前&quot;,之前的当前代码变成 &quot;旧&quot;。</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">如果一个线程已经在工作,则调用会排队并按顺序执行。对每个驱动实例使用相同的线程可以确保调用按顺序进行。</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">如果线程池可用，则使用线程。如果参数 &lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，则以循环方式使用池中的线程，每次对 &lt;code&gt;driver_async&lt;/code&gt; 的调用都使用池中的下一个线程。设置参数 &lt;code&gt;key&lt;/code&gt; ，此行为将更改。 &lt;code&gt;*key&lt;/code&gt; 的两个相同值始终获得相同的线程。</target>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果在本地节点上运行跟踪端口（请参见 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ），则无法使用跟踪器进程跟踪远程节点。返回错误原因 &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; 。但是，可以使用 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 功能在远程节点上启动跟踪端口。</target>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">如果在两个列表中都指定了跟踪器,则优先使用启用列表中的跟踪器。如果没有指定tracer,则使用与执行匹配规范的进程相同的tracer(不是元tracer)。如果该进程也没有 tracer,则忽略跟踪标志。</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">如果一个事务涉及到不对称复制的表的更新或模式表的更新,就会使用重磅提交协议。无论表是如何复制的,这个协议都可以完成事务。重磅事务的典型用途是当一个副本要从一个节点移动到另一个节点时。然后确保复制本要么完全被移动,要么保持原样。千万不要最后出现两个节点上都有副本,或者根本没有节点的情况。即使一个节点在提交协议中间崩溃,也必须保证事务是原子的。与轻量级协议相比,重量级提交协议涉及到事务协调器和参与者之间更多的消息,而且它在启动时执行恢复工作,以完成终止或提交工作。</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">如果交易异常终止， &lt;code&gt;Mnesia&lt;/code&gt; 会自动释放该交易持有的锁。</target>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">如果一个瞬态应用异常终止,所有其他应用和整个Erlang节点也会被终止。</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">如果瞬态应用程序因 &lt;code&gt;Reason == normal&lt;/code&gt; 终止，则会报告此情况，但不会终止其他应用程序。</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">如果瞬态应用程序以 &lt;code&gt;normal&lt;/code&gt; 理由终止，则将报告此情况，但不会终止其他应用程序。如果瞬态应用程序异常终止（除 &lt;code&gt;normal&lt;/code&gt; 原因外），则所有其他应用程序和运行时系统也会终止。</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">如果每一纳秒都会产生一个唯一的整数,那么唯一的整数最早将在584年以上后被重复使用。也就是说,在可预见的未来,它们足够独特。</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">如果用户只想运行一个测试套件的子集,那么一个测试用例就不可能成功地依赖于另一个测试用例。</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">如果未将对象的值提供给 &lt;code&gt;send_notification&lt;/code&gt; 函数，则子代理将执行获取操作以检索它。如果未在此子代理程序中实现对象，则其父代理程序将尝试执行get操作来检索它。如果该对象也未在此代理中实现，则它将对象转发给其父对象，依此类推。最终到达主代理，此时必须解析所有未知的对象值。如果某个对象甚至是主代理都不知道，则将其视为错误，并通过调用错误报告模块的 &lt;code&gt;user_err/2&lt;/code&gt; 进行报告。在这种情况下，不会发送任何通知。</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">如果通知中的变量是表元素，则该元素的 &lt;code&gt;RowIndex&lt;/code&gt; 必须在 &lt;code&gt;Varbinds&lt;/code&gt; 列表中给出。在这种情况下，通知中发送的OBJECT IDENTIFIER是标识此元素的OBJECT IDENTIFIER。此对象标识符可在以后的get操作中使用。</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">如果在一个为真的正断言中遇到一个带名字的动词,如果是最后遇到的名字,则会被记录下来并传回。这不会发生在消极断言或失败的积极断言中。</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">如果一个词是SMIv1或SMIv2中的任何一个关键字,那么它就是编译器中的关键字(只偏离SMIv1)。</target>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">如果一切顺利，则返回 &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; ，其中 &lt;code&gt;ResultOfFun&lt;/code&gt; 是 &lt;code&gt;Fun&lt;/code&gt; 中最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">如果一个模式的所有选项都以\G开头,那么这个表达式就会被锚定在起始匹配位置,并且在编译后的正则表达式中设置了 &quot;anchored &quot;标志。</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">如果找到 &lt;code&gt;.erlang&lt;/code&gt; 文件，则假定它包含有效的Erlang表达式。这些表达式的计算方式就像它们是输入到外壳程序一样。</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 分配器已禁用。</target>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">如果将I / O设备设置为二进制模式，则函数 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 可以返回二进制文件而不是列表。从Erlang / OTP R13A开始，二进制文件以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">如果I / O服务器遇到无法识别的请求（即 &lt;code&gt;io_request&lt;/code&gt; 元组具有预期的格式，但是 &lt;code&gt;Request&lt;/code&gt; 未知），则I / O服务器将发送带有错误元组的有效回复：</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">如果一个MIB对象实例正好属于一个子树,那么根据该条目的类型,该实例将被包含在相关的MIB视图中,或者被排除在该视图之外。</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">如果一个MIB对象实例属于一个以上的子树,那么就使用由最多子标识符组成的子树,并且在词法上是最大的子树。</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">如果一个MIB对象实例不属于任何相关的子树,那么该实例就不在MIB视图中。</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">如果algs_list()中缺少一个alg_entry(),则对该条目使用默认值。</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">如果一个算法名称在列表中出现一次以上,则行为未定义。属性列表中的标记也被认为最多出现一次。</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">如果在处理请求时进行的应用程序回调失败（pick_peer，prepare_request，prepare_retransmission，handle_answer或handle_error），则根据是否尝试发送请求返回 &lt;code&gt;{error,encode}&lt;/code&gt; 或 &lt;code&gt;{error,failure}&lt;/code&gt; 在运输中。</target>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">如果一个算术表达式、一个布尔表达式、一个短路表达式或对守卫BIF的调用失败(因为无效参数),则整个守卫失败。如果该守卫是守卫序列的一部分,则会评估序列中的下一个守卫(即下一个分号后面的守卫)。</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">如果首次尝试打开日志文件失败，则磁盘日志进程将以EXIT消息 &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; 终止。该函数针对所有其他错误返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">如果尝试重新打开或截断日志失败（请参阅 &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; ），则磁盘日志进程将立即终止。在该过程终止之前，将删除到所有者和阻止过程的链接（请参阅 &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; ）。结果是链接仅在一个方向上起作用。如果某个其他进程同时截断或重新打开该日志，则任何使用磁盘日志的进程都必须检查错误消息 &lt;code&gt;no_such_log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">如果边缘从v发出并入射在w上，则称w为 v &lt;strong id=&quot;out_neighbour&quot;&gt;的邻居&lt;/strong&gt;，而v为w &lt;strong id=&quot;in_neighbour&quot;&gt;的邻居&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果员工从1997年或更晚开始，但在2001年之前，返回 &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果某个员工在1997年之前开始工作，请返回元组 &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">如果必须重新启动模拟器并且不需要升级说明，也就是说，如果重新启动本身足以使升级后的应用程序开始运行新版本，则可以手动创建一个简单的 &lt;code&gt;relup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">如果在重传期间发生编码错误，则请求过程将失败并返回 &lt;code&gt;{error,failure}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Bin&lt;/code&gt; 中包含整个数据包，则将其与二进制文件的其余部分一起作为 &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">如果返回错误代码,则表示 port 没有启动。</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">如果返回错误，则可能是由于匹配规范的编译中存在错误。这些错误以元组列表 &lt;code&gt;{error, string()}&lt;/code&gt; 其中字符串是编译错误的文字说明。一个例子：</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">如果返回错误，则可能是由于跟踪程序服务器已在运行（ &lt;code&gt;{error,already_started}&lt;/code&gt; ），也可能是由于 &lt;code&gt;HandlerFun&lt;/code&gt; 引发了异常。</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">如果发生错误，则在调用 &lt;code&gt;is_set_ok&lt;/code&gt; 函数之后将调用此函数。如果为此对象调用 &lt;code&gt;set&lt;/code&gt; ，则不调用 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">如果在安装过程中发生错误,系统将使用旧版本的版本重新启动。如果安装成功,系统随后将使用新版本的版本,但如果发生任何事情并重新启动系统,系统将重新开始使用以前的版本。</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">如果套接字上发生错误，则会传递以下消息（除非在套接字的选项列表中指定了 &lt;code&gt;{active, false}&lt;/code&gt; ，在这种情况下，可通过调用 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 来检索数据包）：</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">如果使用模块 &lt;code&gt;io&lt;/code&gt; 访问打开的文件时发生错误，则退出处理该文件的过程。如果某个进程稍后尝试访问该文件，则死进程可能会挂起。这将在将来的版本中修复。</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">如果发生错误，则在 &lt;code&gt;is_set_ok&lt;/code&gt; 函数之后调用函数 &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 。如果为此对象调用 &lt;code&gt;set&lt;/code&gt; ，则不调用 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;is_set_ok&lt;/code&gt; 阶段或在 &lt;code&gt;set&lt;/code&gt; 阶段发生错误，则所有用 &lt;code&gt;is_set_ok&lt;/code&gt; 调用但未 &lt;code&gt;set&lt;/code&gt; 函数都将用 &lt;code&gt;undo&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">如果发生错误,该函数启动的应用程序将被停止,使正在运行的应用程序集恢复到初始状态。</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">如果发生错误，则退出并返回一个错误元组 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">如果发生错误，则退出并返回一个错误元组 &lt;code&gt;{error, Reason}&lt;/code&gt; 。错误元组不返回，因为它不能与键区分开。</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">如果发生错误,在这种情况下,堆栈跟踪会变成空的。</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">如果发生错误,则没有输出。例如:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;AfterBody&lt;/code&gt; 自身评估期间发生异常，则不会捕获该异常。所以，如果 &lt;code&gt;AfterBody&lt;/code&gt; 在异常后评估 &lt;code&gt;Exprs&lt;/code&gt; ， &lt;code&gt;Body&lt;/code&gt; ，或 &lt;code&gt;ExceptionBody&lt;/code&gt; ，该异常丢失，在异常掩盖 &lt;code&gt;AfterBody&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">如果在 &lt;code&gt;ExceptionBody&lt;/code&gt; 评估期间发生异常，则不会捕获该异常。</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">如果在评估 &lt;code&gt;Exprs&lt;/code&gt; 时发生异常，但没有正确的带有正确保护序列的正确 &lt;code&gt;Class&lt;/code&gt; 的 &lt;code&gt;ExceptionPattern&lt;/code&gt; 匹配，则将异常传递 &lt;code&gt;Exprs&lt;/code&gt; 就好像Exprs没有包含在 &lt;code&gt;try&lt;/code&gt; 表达式中一样。</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">如果如上所述接收到退出信号，则使用 &lt;code&gt;server_logoff&lt;/code&gt; 函数从服务器 &lt;code&gt;User_List&lt;/code&gt; 中删除元组 &lt;code&gt;{From,Name}&lt;/code&gt; 。如果运行服务器的节点发生故障，则退出信号（由系统自动生成）将发送到所有客户端进程： &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; 导致所有客户端进程终止。</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">如果在编译MIB时关联文件中变量 &lt;code&gt;myVar&lt;/code&gt; 的检测函数没有名称，则编译器将生成一个条目。</target>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">如果提供整数超时值，则除非在 &lt;code&gt;Timeout&lt;/code&gt; 毫秒内收到请求或消息，否则将发生超时。原子 &lt;code&gt;timeout&lt;/code&gt; 表示超时，该超时由 &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; 回调函数处理。原子 &lt;code&gt;infinity&lt;/code&gt; 可用于无限期等待，这是默认值。</target>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">如果所有者尝试再次以所有者身份打开日志，则会使用返回值 &lt;code&gt;{ok, Log}&lt;/code&gt; 确认它，但是磁盘日志的状态不受影响。</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果指定了无法识别的类型选项 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;Type&lt;/code&gt; 不是正确的列表，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">如果 &lt;code&gt;modify_algs_list()&lt;/code&gt; 中包含不受支持的算法，它将被静默忽略</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">如果升级包含从OTP R15之前的仿真器到OTP R15或更高版本的仿真器的更改，则会发出警告 &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; 。有关此的更多信息，请参见 &lt;code&gt;Design Principles&lt;/code&gt; &lt;strong&gt;系统文档&lt;/strong&gt;》中的&amp;ldquo; 设计原则&lt;strong&gt;&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">是否以及如何压缩消息。示例为 &lt;code&gt;none&lt;/code&gt; ，即没有压缩和 &lt;code&gt;zlib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">当且仅当在格式字符串中使用Unicode翻译修饰符（即 &lt;code&gt;~ts&lt;/code&gt; 或 &lt;code&gt;~tc&lt;/code&gt; ）时，结果列表才能包含超出ISO Latin-1字符范围的字符（即数字&amp;gt; 255）。如果是这样，结果仍然是普通的Erlang &lt;code&gt;string()&lt;/code&gt; ，并且可以在允许Unicode数据的任何上下文中很好地使用。</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">如果并且当您想启动和操作 &lt;code&gt;Mnesia&lt;/code&gt; 时，将定义和数据写入普通文本文件通常会更容易。最初，没有表，也没有数据，或者需要哪些表。在原型设计的初始阶段，谨慎的做法是将所有数据写入一个文件，对该文件进行处理，然后将文件中的数据插入数据库中。可以使用从文本文件读取的数据来初始化 &lt;code&gt;Mnesia&lt;/code&gt; 。以下两个功能可用于处理文本文件。</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">如果需要这些变量中的任何一个的另一种实现方式，例如将持久性变量存储在Mnesia数据库中，则必须对这些变量进行自己的实现。该MIB将被编译和加载，而不是默认的MIB。新的已编译MIB必须与原始MIB具有相同的名称（即STANDARD-MIB或SNMPv2-MIB），并且位于SNMP配置目录中（请参阅 &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">如果任何 &lt;code&gt;Dir&lt;/code&gt; 不是目录名</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">如果系统中的任何Erlang进程 &lt;code&gt;Pid&lt;/code&gt; 已分配了超过一定数量的系统总内存，则会设置警报 &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">如果脚本添加了任何HTTP标头字段，则它们必须在对 &lt;code&gt;deliver/2&lt;/code&gt; 的第一次调用中，并且调用中的数据必须为字符串。标头完成后的调用可以包含二进制数据，以减少复制开销。不要假定任何有关 &lt;code&gt;SessionID&lt;/code&gt; 数据类型的信息。 &lt;code&gt;SessionID&lt;/code&gt; 必须是您实现的ESI回调函数的输入值。</target>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">如果任何子进程启动函数失败或返回错误的元组或错误值，则主管首先使用原因 &lt;code&gt;shutdown&lt;/code&gt; 终止所有已经启动的子进程，然后终止自身并返回 &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从Erlang Shell调用使用&amp;ldquo;必需的配置数据&amp;rdquo;的任何功能（例如Telnet或FTP），则必须首先使用 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 来要求配置数据。</target>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从Erlang shell调用任何使用&amp;ldquo;必需的配置数据&amp;rdquo;的函数（例如，函数 &lt;code&gt;ct_telnet&lt;/code&gt; 或 &lt;code&gt;ct_ftp&lt;/code&gt; ），则首先需要使用 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 的配置数据。这等效于 &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果任何参数无效，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果任何表都不存在或 &lt;code&gt;badarg&lt;/code&gt; 表未打开，则会引发badarg异常。</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">如果在传递 &lt;code&gt;+sbt&lt;/code&gt; 时发生任何这些错误，则运行时系统将显示一条错误消息，并拒绝启动。如果在传递 &lt;code&gt;+stbt&lt;/code&gt; 时发生任何这些错误，则运行时系统将静默忽略该错误，并使用未绑定的调度程序启动。</target>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果在 &lt;code&gt;InsPos&lt;/code&gt; &amp;gt;替换二进制文件的大小中指定了任何位置，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">如果未指定参数 &lt;code&gt;-daemon&lt;/code&gt; ，则 &lt;code&gt;epmd&lt;/code&gt; 将与启动它的shell的控制终端一起作为普通程序运行。通常，它将作为守护程序运行。</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">如果将参数 &lt;code&gt;Archive&lt;/code&gt; 指定为二进制文件，则假定二进制文件的内容为zip归档文件，否则为文件名。</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">如果参数 &lt;code&gt;MFA&lt;/code&gt; 是原子 &lt;code&gt;on_load&lt;/code&gt; ，则匹配规范和标志列表将在所有新加载的模块上使用。</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">如果将参数 &lt;code&gt;Name&lt;/code&gt; 指定为 &lt;code&gt;{binary,Binary}&lt;/code&gt; ，则二进制文件的内容假定为tar存档。</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">如果参数 &lt;code&gt;Name&lt;/code&gt; 指定为 &lt;code&gt;{file,Fd}&lt;/code&gt; ，则假定 &lt;code&gt;Fd&lt;/code&gt; 是从函数 &lt;code&gt;file:open/2&lt;/code&gt; 返回的文件描述符。</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">如果指定了参数 &lt;code&gt;type&lt;/code&gt; ，则将显示此类型的所有已加载报告。如果指定了整数参数，则显示具有此参考编号的报告。如果未指定任何参数，则显示所有报告。</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">如果原子 &lt;code&gt;start&lt;/code&gt; 被指定为延续，盘记录来自被选择为读条款。当前节点上的本地或分布式磁盘日志比其他节点上的单个分布式日志更可取。</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">如果在前面的示例中使用了原子分组，则匹配器在第一次不匹配&amp;ldquo; foo&amp;rdquo;时会立即放弃。该符号是一种特殊的括号，以 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 开头，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">如果在创建表时指定了属性 &lt;code&gt;{local_content, true}&lt;/code&gt; ，则该表将位于您指定该表存在的节点上，但是对表的写操作仅在本地副本上执行。</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">如果使用身份验证或加密（仅SNMPv3），请启动 &lt;code&gt;crypto&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">如果使用认证或加密（SNMPv3的只），启动 &lt;code&gt;crypto&lt;/code&gt; 应用程序。如果忘记了此步骤，则代理将不会启动，而是报告 &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">如果自动跳过测试用例不影响退出状态。默认的行为可以使用启动标志来改变。</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">如果自动提交模式被打开,每个查询将被视为一个单独的事务,并在执行后自动提交。如果你想让多个查询成为同一个事务的一部分,那么自动提交模式应该被关闭。那么你将不得不显式调用commit/3来结束一个事务。</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">如果转储中可用,则是原子表中的原子总数。如果没有原子表的大小,则显示转储中可见的原子数。</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">如果不再使用二进制文件，则应尽快将其丢弃。（将 &lt;code&gt;Number&lt;/code&gt; 设置为零。）</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">如果不支持调度器的绑定。</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Source&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Destination&lt;/code&gt; 引用文件名，则分别在文件的模式列表前添加 &lt;code&gt;[read, binary]&lt;/code&gt; 和 &lt;code&gt;[write, binary]&lt;/code&gt; 来打开文件，以优化副本。</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">如果已在运行中开始呼叫计数跟踪，则计数将从零重新开始。要暂停运行中的计数器，请使用 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 。暂停和运行中的计数器可以使用 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 从零重新启动。</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">如果在执行 &lt;code&gt;analyse/0..2&lt;/code&gt; 的同时呼叫计数器仍在运行，则可能会得到不一致的结果。如果执行了 &lt;code&gt;analyse/0..2&lt;/code&gt; 的进程被调度了，因此其他进程可以增加正在分析的计数器，则会发生这种情况，在分析之前调用 &lt;code&gt;pause()&lt;/code&gt; 可以解决问题。</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">如果已经在运行时开始通话时间跟踪，则计数和时间将从零开始。要暂停运行中的计数器，请使用 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 。暂停和运行中的计数器可以使用 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 从零重新启动。</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">如果多次调用，则仅打印最后一条注释。测试用例的返回值 &lt;code&gt;{comment,Comment}&lt;/code&gt; 将覆盖此函数设置的字符串。</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">如果使用用户应用程序未知的扩展名进行调用，则将使用返回值 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">如果在调用 &lt;code&gt;FormatFun&lt;/code&gt; 与包括参数 &lt;code&gt;NElements&lt;/code&gt; 和 &lt;code&gt;DepthFun&lt;/code&gt; 失败， &lt;code&gt;FormatFun&lt;/code&gt; 与变量排除再次呼吁 &lt;code&gt;NElements&lt;/code&gt; 和 &lt;code&gt;DepthFun&lt;/code&gt; （ &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; 或 &lt;code&gt;all&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">如果在回参时实行的是caseful匹配,则与字母的情况有关。例如,下面匹配 &quot;rah rah &quot;和 &quot;RAH RAH&quot;,但不匹配 &quot;RAH rah&quot;,尽管原捕获子模式是无大小写匹配的。</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">如果某些特定于端口的数据必须从其他线程而不是调用驱动程序回调的线程中访问,则可以使用端口数据锁来同步数据的操作。目前,仿真器与端口数据锁相关联的唯一端口特定数据是驱动程序队列。</target>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">如果一个或多个套件的编译失败，则将编译错误打印到tty上，并向操作员询问是否要在没有缺少套件的情况下进行测试运行，或者中止测试​​。如果操作员选择继续，则会在HTML日志中记录缺少套件的测试。如果 &lt;code&gt;Common Test&lt;/code&gt; 在编译失败后无法提示用户（如果 &lt;code&gt;Common Test&lt;/code&gt; 不控制 &lt;code&gt;stdin&lt;/code&gt; ），则测试运行将自动继续，而不会缺少任何套件。但是，可以使用 &lt;code&gt;ct_run&lt;/code&gt; 标志 &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 选项 &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; 修改此行为。如果 &lt;code&gt;abort_if_missing_suites&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，如果某些套件无法编译，则测试运行会立即停止。</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">如果通过 &lt;code&gt;--enable-static-nifs&lt;/code&gt; 编译用于静态包含的NIF ，则必须在 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 声明之前定义 &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">如果通过 &lt;code&gt;--enable-static-drivers&lt;/code&gt; 编译用于静态包含的驱动程序，则必须在 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 声明之前定义 &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">如果要返回配置元素（键值元组）作为结果而不是值，请使用option &lt;code&gt;element&lt;/code&gt; 。然后，返回的元素采用 &lt;code&gt;{Required,Value}&lt;/code&gt; 的形式。</target>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">如果进行了交叉覆盖分析,并且有当前测试的累积覆盖结果,&quot;覆盖数据收集到所有测试 &quot;的链接将带您进入这些结果。</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">如果将数据以无法转换为指定编码的格式发送到 &lt;code&gt;io_device()&lt;/code&gt; ，或者如果数据返回的函数以无法处理数据字符范围的格式读取数据，则会发生错误，并且该文件已关闭。</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">如果定义，则禁用 &lt;code&gt;run_erl&lt;/code&gt; 打开的pty的输入和输出流控制。如果您想消除使用Ctrl-S（而不是Ctrl-D断开连接）意外阻塞流量控制的任何风险，这很有用，因为这可能会导致整个Beam过程的阻塞，甚至在以心脏为监督者的情况下将日志消息写入终端时，心脏进程会被阻塞，从而使心脏进程无法完成其工作。</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">如果需要区分空匹配和不存在的子模式，请使用 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 并转换为Erlang代码中的最终类型。</target>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">如果为空,说明调度器正在做一些工作。如果不为空,则表示调度器处于睡眠状态,或者暂停。这个条目只存在于启用SMP的模拟器中。</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">如果启用且可用,则显示进程SASL日志条目。</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">如果启用,则会向每个调度程序发送一个信号来检查其响应性。系统检查发生在任何发送到端口程序的心跳之前。如果任何一个调度器的响应速度不够快,心脏程序就会收不到它的心跳,从而最终终止节点。</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">如果一切成功，则回调函数可以将可能的默认值或内部状态值添加到配置中，并在 &lt;code&gt;{ok,Config2}&lt;/code&gt; 中返回调整后的映射。</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">如果一切成功，则回调函数必须在 &lt;code&gt;{ok,Config3}&lt;/code&gt; 中返回可能已调整的配置。</target>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">如果省略flag- &lt;code&gt;-loader&lt;/code&gt; ，则默认为 &lt;code&gt;efile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">如果指定了标志 &lt;code&gt;timestamp&lt;/code&gt; ， &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 或 &lt;code&gt;monotonic_timestamp&lt;/code&gt; ，则第一个元组元素为 &lt;code&gt;trace_ts&lt;/code&gt; ，并且时间戳作为消息元素中最后一个额外元素添加。如果传递了多个时间戳标志，则 &lt;code&gt;timestamp&lt;/code&gt; 优先于 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ，而后者又优先于 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 。所有时间戳标记都会被记住，因此如果传递两个时间戳标记，并且禁用优先级最高的一个标记，则另一个标记将变为活动状态。</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">如果标志 &lt;code&gt;-pa&lt;/code&gt; 或 &lt;code&gt;-pz&lt;/code&gt; 被中指定的 &lt;code&gt;Common Test&lt;/code&gt; 组选项（前述 &lt;code&gt;-erl_args&lt;/code&gt; ），相对目录被转换成绝对和重新插入到由代码路径 &lt;code&gt;Common Test&lt;/code&gt; 。这是为了避免在&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 在测试运行期间更改工作目录时加载用户模块时出现问题。然而， &lt;code&gt;Common Test&lt;/code&gt; 忽略标志 &lt;code&gt;-pa&lt;/code&gt; 和 &lt;code&gt;-pz&lt;/code&gt; 以下 &lt;code&gt;-erl_args&lt;/code&gt; 在命令行上。这些目录通常（以指定形式）添加到代码路径中。</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">如果megaco由于某种原因无法传递答复，则除非通过 &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; 调用回调函数 &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; ，否则将其原因传递给用户。</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">如果找到了,这个文件会在创建发行包时自动包含。</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">如果功能 &lt;code&gt;start_link/3,4,5&lt;/code&gt; 的使用量和处理崩溃它称为前 &lt;code&gt;init_ack/1,2&lt;/code&gt; ， &lt;code&gt;{error, Reason}&lt;/code&gt; 是如果主叫处理陷阱退出返回。</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">如果跟踪了函数调用，则必须通过单击&lt;strong&gt;添加跟踪模式&lt;/strong&gt;按钮来&lt;strong&gt;添加跟踪模式&lt;/strong&gt;。选择模块，功能和匹配规范。如果未选择任何功能，则将跟踪模块中的所有功能。</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">如果给定,设置连接的最小字节/秒值。</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">如果不包括头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，则不会翻译该趣味，这可能会导致&lt;strong&gt;运行时错误&lt;/strong&gt;（取决于该趣味在纯Erlang上下文中是否有效）。</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">如果心脏应该&lt;strong&gt;不&lt;/strong&gt;杀Erlang运行时系统，这可以通过使用环境变量来表示 &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; 。如果由心脏执行的命令对此负责（例如作为特定清除序列的一部分），这将很有用。如果未设置，或者未设置为 &lt;code&gt;TRUE&lt;/code&gt; ，则默认行为是如上所述进行杀死。</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">如果 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;ch3&lt;/code&gt; 属于同一应用程序，则 &lt;code&gt;.appup&lt;/code&gt; 文件可以如下所示：</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">如果相反， &lt;code&gt;s2&lt;/code&gt; 的封面规格如下所示：</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">如果改用以下模式,则会匹配 &quot;意识和责任 &quot;和其他两个字符串。</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">如果在执行 &lt;code&gt;end_per_testcase&lt;/code&gt; 期间确定将成功的测试用例的状态更改为失败，则 &lt;code&gt;end_per_testcase&lt;/code&gt; 可以返回元组 &lt;code&gt;{fail,Reason}&lt;/code&gt; （其中 &lt;code&gt;Reason&lt;/code&gt; 描述测试用例失败的原因）。</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">如果重要的是要获得与原始文档中相似的缩进和换行符，则必须在适当的位置添加带有空格和换行符值的#xmlText {}记录。可能还必须保留引用DTD的原始序言。如果是这样，可以将RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; 传递给 &lt;code&gt;export_simple/3&lt;/code&gt; 。以下示例代码修复了先前示例中的那些更改：</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">如果最大程度地减少更改代码时应用程序处于非活动状态的时间很重要，请使用 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;atomic_load/1&lt;/code&gt; 。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">如果必须在终止之前进行清理，则关闭策略必须是一个超时值，并且必须将 &lt;code&gt;gen_server&lt;/code&gt; 设置为在函数 &lt;code&gt;init&lt;/code&gt; 中捕获退出信号。当命令关闭时， &lt;code&gt;gen_server&lt;/code&gt; 然后调用回调函数Terminate &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">如果必须在终止前进行清理，则关闭策略必须是一个超时值，并且 &lt;code&gt;gen_statem&lt;/code&gt; 必须在 &lt;code&gt;init/1&lt;/code&gt; 函数中通过调用 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 将自身设置为捕获退出信号：</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">如果需要将一组 &lt;code&gt;ASN.1&lt;/code&gt; 模块编译为具有编码/解码功能的Erlang文件，请确保在配置文件中列出所有涉及的文件。此配置文件必须具有双扩展名 &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; （ &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 可以是 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; ）。在引号（&amp;ldquo;&amp;rdquo;）中列出输入文件名，在文件的每一行中列出一个。如果输入文件是 &lt;code&gt;File1.asn&lt;/code&gt; ， &lt;code&gt;File2.asn&lt;/code&gt; 和 &lt;code&gt;File3.asn&lt;/code&gt; ，则配置文件必须如下所示：</target>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">如果有可能的经理创建或删除表中的行，必须有一个 &lt;code&gt;RowStatus&lt;/code&gt; 列 &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;undo&lt;/code&gt; 工作正常。</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">如果可以加载 &lt;code&gt;Module&lt;/code&gt; 并且 &lt;code&gt;Function/N&lt;/code&gt; 被导出，则会调用它。</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">如果要求Mnesia必须在插入该表的所有 &lt;code&gt;person&lt;/code&gt; 记录的属性 &lt;code&gt;address&lt;/code&gt; 上建立并维护一个额外的索引表，则会发出以下代码：</target>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射中的任何现有键都不匹配，则会从键 &lt;code&gt;K&lt;/code&gt; 到值 &lt;code&gt;V&lt;/code&gt; 创建新的关联。</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射 &lt;code&gt;M&lt;/code&gt; 中的任何现有键都不匹配，则会在运行时触发类型 &lt;code&gt;badarg&lt;/code&gt; 的异常。如果在地图 &lt;code&gt;M&lt;/code&gt; 中存在匹配关键字 &lt;code&gt;K&lt;/code&gt; ，则其关联值将被新值 &lt;code&gt;V&lt;/code&gt; 替换，并且所评估的地图表达式将返回新地图。</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射 &lt;code&gt;M&lt;/code&gt; 中的现有键匹配，则其关联值将被新值 &lt;code&gt;V&lt;/code&gt; 代替。在这两种情况下，评估的地图表达式都会返回一个新地图。</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">如果以后的 &lt;code&gt;Pid&lt;/code&gt; 终止于 &lt;code&gt;Reason&lt;/code&gt; ，则主管网桥也终止于 &lt;code&gt;Reason&lt;/code&gt; 。如果稍后主管网桥由于其原因 &lt;code&gt;Reason&lt;/code&gt; 终止其主管，它将调用 &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">如果使用长节点节点名，则通过调用 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 来完成初始化：</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">如果多个进程修复了一张表,那么在所有进程释放(或终止)之前,该表一直保持固定状态。每个进程都有一个参考计数器,连续修复N次需要释放N次才能释放该表。</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">如果多个进程修复了一个表,那么在所有进程释放或终止之前,该表一直是固定的。每个进程都有一个参考计数器,连续修复N次需要释放N次才能释放该表。</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">如果地图 &lt;code&gt;map_in&lt;/code&gt; 包含 &lt;code&gt;key&lt;/code&gt; ，这个功能使得副本 &lt;code&gt;map_in&lt;/code&gt; 在 &lt;code&gt;*map_out&lt;/code&gt; 和删除 &lt;code&gt;key&lt;/code&gt; 以及相关的值。如果地图 &lt;code&gt;map_in&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则 &lt;code&gt;*map_out&lt;/code&gt; 设置为 &lt;code&gt;map_in&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">如果模式为干扰模式,服务器被强行阻塞,所有正在进行的请求终止,并立即开始重新加载。如果模式为非干扰,则不接受新的连接,但允许正在进行的请求在重载完成之前完成。</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">如果使用内联编译模块，则可能会发出虚假警告。在&amp;ldquo; &lt;strong&gt;选项&amp;rdquo;&lt;/strong&gt;菜单中，您可以选择在分析字节码时忽略内联编译模块。从源代码开始时，这不是问题，因为Dialyzer已显式关闭了内联。该选项使Dialyzer禁止来自内联编译模块的所有警告，因为Dialyzer当前无法找到通过内联产生的代码的哪些部分。</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">如果需要更复杂的过滤，请使用 &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; 并根据RFC 5277中的&amp;ldquo;事件通知的XML架构&amp;rdquo;指定确切的过滤器。</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">如果在最近的 &lt;code&gt;MaxT&lt;/code&gt; 秒内发生的重启次数超过 &lt;code&gt;MaxR&lt;/code&gt; 次，则主管将终止所有子进程，然后终止其自身。在这种情况下，主管本身的终止原因将被 &lt;code&gt;shutdown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">如基础操作系统报告的那样，如果分配的可用系统内存超过一定数量 &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; 则会设置警报{system_memory_high_watermark，[]}。</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">如果一个模式中存在不止一个回溯动词,那么后面的不同动词(*COMMIT)可以先被触发,所以在匹配过程中仅仅传递(*COMMIT)并不总是保证匹配必须在这个起点。</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">如果一个模式中出现一个以上的回溯动词,则回溯到的那个动词先作用。例如,考虑以下模式,其中A、B等是复杂模式片段。</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">如果多个进程尝试使用相同的 &lt;code&gt;Path&lt;/code&gt; 加载已经加载的驱动程序，或者同一进程尝试多次加载该驱动程序，则该函数返回 &lt;code&gt;ok&lt;/code&gt; 。仿真器跟踪 &lt;code&gt;load/2&lt;/code&gt; 调用，以便在 &lt;code&gt;unload/2&lt;/code&gt; 驱动程序之前必须从同一进程执行相应数量的unload / 2调用。因此，对于应用程序来说，在需要时加载在进程或应用程序之间共享的驱动程序是安全的。可以安全地卸载它，而不会引起系统其他部分的麻烦。</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">如果启用了多调度，则模拟器将使用多个调度程序线程。可以用两种不同的方式来阻止多调度。要么所有调度程序都被阻止，要么所有&lt;strong&gt;正常&lt;/strong&gt;调度程序都被阻止。当仅阻止常规调度程序时，肮脏的调度程序可以自由继续调度进程。</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">如果指定了多个 &lt;code&gt;-eval&lt;/code&gt; 表达式，则将按指定的顺序对它们进行求值。 &lt;code&gt;-eval&lt;/code&gt; 表达式通过 &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-run&lt;/code&gt; 函数调用顺序进行求值（这也按指定的顺序进行）。与 &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-run&lt;/code&gt; 一样，不终止的评估会阻塞系统初始化过程。</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">如果传递了多个时间戳标志，则 &lt;code&gt;timestamp&lt;/code&gt; 优先于 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ，而后者又优先于 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 。所有时间戳标记都会被记住，因此，如果传递了两个时间戳标志，并且禁用了优先级最高的那个标志，则另一个将变为活动状态。</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">如果名称注册成功，则新的 &lt;code&gt;gen_server&lt;/code&gt; 进程将调用回调函数 &lt;code&gt;ch3:init([])&lt;/code&gt; 。预期 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 的内部状态。在这种情况下，状态为可用通道。</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">如果名称注册成功，则新的 &lt;code&gt;gen_statem&lt;/code&gt; 进程将调用回调函数 &lt;code&gt;code_lock:init(Code)&lt;/code&gt; 。该功能有望恢复 &lt;code&gt;{ok, State, Data}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是初始状态 &lt;code&gt;gen_statem&lt;/code&gt; ，在这种情况下 &lt;code&gt;locked&lt;/code&gt; ;假设开始时门是锁着的。 &lt;code&gt;Data&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 的内部服务器数据。在这里，服务器数据是一个 &lt;code&gt;map&lt;/code&gt; 其中的键 &lt;code&gt;code&lt;/code&gt; 存储正确的按钮顺序，键 &lt;code&gt;length&lt;/code&gt; 存储其长度，而键 &lt;code&gt;buttons&lt;/code&gt; 存储所收集的按钮，直到相同的长度。</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">如果 &lt;code&gt;-minimal&lt;/code&gt; 和 &lt;code&gt;-sasl&lt;/code&gt; 都不作为参数传递，则将提示您。</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">如果两个端点都不需要,你可以像这样测试并重新尝试。</target>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">如果未指定 &lt;code&gt;ContextName&lt;/code&gt; ，则使用默认的 &lt;code&gt;&quot;&quot;&lt;/code&gt; 上下文。</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">如果未指定 &lt;code&gt;NotifyName&lt;/code&gt; （或者为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ），则通知将发送到所有管理目标（以下 &lt;code&gt;Addresses&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">如果未指定 &lt;code&gt;Type&lt;/code&gt; ，则列出所有报告。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
