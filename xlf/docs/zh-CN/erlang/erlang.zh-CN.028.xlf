<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">指示是否要收集过程信息。如果 &lt;code&gt;PI = true&lt;/code&gt; （默认值），则每个进程标识符 &lt;code&gt;Pid&lt;/code&gt; 将替换为元组 &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; ，其中 &lt;code&gt;ProcessInfo&lt;/code&gt; 是已注册进程名称，其全局注册名称或其初始功能。要关闭此功能，请设置 &lt;code&gt;PI = false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">表示该表是否被压缩。</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">表示该表是否被任何程序固定。</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">表示该表是否已命名。</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">从主管的角度指示孩子终止于哪个阶段。可以是 &lt;code&gt;start_error&lt;/code&gt; ， &lt;code&gt;child_terminated&lt;/code&gt; 或 &lt;code&gt;shutdown_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">表示已加载&lt;strong&gt;在&lt;/strong&gt;启动任何进程&lt;strong&gt;之前&lt;/strong&gt;&lt;strong&gt;必须&lt;/strong&gt;加载的所有模块。在交互模式下，在此命令之后解释的所有 &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; 命令都将被忽略，并且这些模块将按需加载。在嵌入式模式下， &lt;code&gt;kernel_load_completed&lt;/code&gt; 被忽略，并且所有模块在系统启动期间均已加载。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">表示发生了普通的发送操作。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 包含接收者的pid（C节点）。</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">表示不再发送数据。</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">表示为执行命令而启动的 &lt;code&gt;ssh_client_channel&lt;/code&gt; 已关闭。</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">表示客户端要尝试执行下一个协议协商。</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">表示如果Telnet客户端空闲（即，如果未接收到任何数据）超过 &lt;code&gt;IdleTimeout&lt;/code&gt; 毫秒，则该函数必须返回。默认超时为10秒。</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">表示不按时间戳合并日志,而是一个文件一个文件地处理(这样可以快一点)。</target>
        </trans-unit>
        <trans-unit id="1ab33322e5998509567ec1f06a0e97917a03dfe6" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt; ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指示另一端不再发送数据。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">指示在 &lt;code&gt;MSec&lt;/code&gt; 毫秒后将自动停止跟踪。如果已指定， &lt;code&gt;StopOpts&lt;/code&gt; 将传递给命令 &lt;code&gt;ttb:stop/2&lt;/code&gt; （默认为 &lt;code&gt;[]&lt;/code&gt; ）。请注意，该时间是近似的，因为始终存在与网络通信相关的延迟。计时器在 &lt;code&gt;ttb:p/2&lt;/code&gt; 后开始计时，因此您可以在之前设置跟踪模式。</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">表示有足够的​​输入数据可获得结果。 &lt;code&gt;Result&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">表示此调用从驱动程序中删除了最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，但仍有使用它的开放端口。当所有端口都关闭且没有新 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 到达时，将重新加载驱动程序并回收名称和内存。</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">表示在停止跟踪后不收集跟踪日志。</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">指示在跟踪过程中接收到跟踪消息时，将在控制台上打印跟踪消息。这意味着跟踪客户端 &lt;code&gt;{local, File}&lt;/code&gt; 。如果 &lt;code&gt;ShellSpec&lt;/code&gt; 是 &lt;code&gt;only&lt;/code&gt; （而不是 &lt;code&gt;true&lt;/code&gt; ），没有跟踪日志被存储。</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">表示文件所有者。对于非Unix文件系统,忽略。</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">表示inets版本。</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">表示文件的所有者。在非Unix文件系统中,该字段为零。</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">指示返回值将是 &lt;code&gt;{stopped, Dir}&lt;/code&gt; ，而不仅仅是 &lt;code&gt;stopped&lt;/code&gt; 。这意味着 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">表示服务器将尝试执行应用层协议协商(ALPN)。</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">表示跟踪停止后要格式化的跟踪日志。fetch目录下的所有日志都会被合并。</target>
        </trans-unit>
        <trans-unit id="c9caeef1a9bf6a4c1f663bd7540e3e604062a5c1" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;decentralized_counters&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">指示表是否使用 &lt;code&gt;read_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">指示表是否使用 &lt;code&gt;write_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e0e5bf9d20bf47d959fe201139325627c2f3941" translate="yes" xml:space="preserve">
          <source>Indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d333b1897ab1d5bb5a70973c07335347937ec466" translate="yes" xml:space="preserve">
          <source>Indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">指示功能交换是否已使用TLS选择带内安全性。 &lt;code&gt;Ref&lt;/code&gt; 是必须在 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 到传输的父进程的回复消息中包含的reference（）（请参阅下文）。 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;connect&lt;/code&gt; 还是 &lt;code&gt;accept&lt;/code&gt; ,分别取决于是否已针对连接传输或侦听传输启动了进程。 &lt;code&gt;Bool&lt;/code&gt; 是一个boolean（），指示是否应将传输连接升级到TLS。</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">各个模式的代表如下:</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">从起源-状态-ID推断会话终止。</target>
        </trans-unit>
        <trans-unit id="312cf7f9e08930449da2f3a70ec59de01578d97a" translate="yes" xml:space="preserve">
          <source>Infinite Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">无限循环可以通过遵循一个子模式来构造,例如,可以用一个没有上限的量化符来匹配没有字符。</target>
        </trans-unit>
        <trans-unit id="e575fea98a15d988a12ed46eab26f00dd0e764af" translate="yes" xml:space="preserve">
          <source>InfoTupleList | InfoTuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e649f7899e661682dcf40da83dd77a934e9978" translate="yes" xml:space="preserve">
          <source>InfoTupleList | InfoTuple | {error, bad_daemon_ref}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">告知交付结果。</target>
        </trans-unit>
        <trans-unit id="bfcd17ecc49f5239dbbb19b14b0dc7ca6b6bf5ec" translate="yes" xml:space="preserve">
          <source>Inform about file descriptor used by the socket which is identified by &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f033a38b61d37b7919f393716c730267413513" translate="yes" xml:space="preserve">
          <source>Inform about handshake packet header size to use during the Erlang distribution handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">告知目标地址。</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">通知父级 &lt;code&gt;Type=accept&lt;/code&gt; 的传输过程已与对等方建立连接。如果传输过程具有 &lt;code&gt;Type=connect&lt;/code&gt; ,则不发送。</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通知父级 &lt;code&gt;Type=connect&lt;/code&gt; 的传输过程已与对等方建立连接。如果传输过程具有 &lt;code&gt;Type=accept&lt;/code&gt; ,则不发送。 &lt;code&gt;Remote&lt;/code&gt; 是一个任意术语，用于唯一标识传输已连接到的远程端点。一个 &lt;code&gt;LocalAddr&lt;/code&gt; 列表具有相同的语义，一个从返回 &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">非正式地讲,I/O列表是一个可以发送到Erlang端口的字符和二进制文件的深度列表。在 BNF 中,I/O 列表的正式定义如下。</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">信息对象类、信息对象和信息对象集(以下分别称为类、对象和对象集)在标准定义X.681中进行了定义。这里只做简单的解释。</target>
        </trans-unit>
        <trans-unit id="2d484a6c4fd2a8198b820555e505d0e990310c8a" translate="yes" xml:space="preserve">
          <source>Information about a message received via &lt;code&gt;&lt;a href=&quot;#ei_receive_msg&quot;&gt;ei_receive_msg()&lt;/a&gt;&lt;/code&gt; or friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">关于所有被调试的进程的信息,即所有在解释模块中已经或正在执行代码的进程。</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">当进行升级或降级时,会从脚本中获取应用程序的信息。</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">例如,关于Erlang的实现信息可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">与崩溃进程相关联的进程的信息,并且不捕捉退出。这些进程就是因为这个进程崩溃而终止的邻居。收集到的信息与上一项中介绍的Crasher的信息相同。</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">关于崩溃过程的信息,如初始函数调用、退出原因、消息队列等。</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">可以使用选项 &lt;code&gt;--add_to_plt&lt;/code&gt; 将信息添加到现有的PLT中。如果您还希望将Erlang编译器包含在PLT中并将其放置在新的PLT中，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="3521f2cf94de7eff4c9ac49833f3792cb383574d" translate="yes" xml:space="preserve">
          <source>Information flows between processes in a lot of different ways. Not all flows of information will be covered by sequential tracing. One example is information passed via ETS tables. Below is a list of information paths that are covered by sequential tracing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d714fa02dd99c17cb145c5818ce9c2c7a15188e" translate="yes" xml:space="preserve">
          <source>Information for ssl applications use of &lt;code&gt; Logger(3)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">返回测试用例属性列表的信息函数。(可选)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">信息函数,用于返回测试用例组的属性。(可选)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">用于返回该套房属性的信息函数。(可选)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">信息功能也可以用于函数 &lt;code&gt;init_per_suite&lt;/code&gt; ， &lt;code&gt;end_per_suite&lt;/code&gt; ， &lt;code&gt;init_per_group&lt;/code&gt; 和 &lt;code&gt;end_per_group&lt;/code&gt; ，它们的作用方式与 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 。例如，这对于设置时间陷阱并要求仅与所讨论的配置功能相关的外部配置数据有用（不影响为套件中的组和测试用例设置的属性）。</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">信息通过对回调函数 &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; 调用传递给接收器。</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">通过调用提供的fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; 将信息传递给接收器。</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">有关当前主要对等地址的信息（有关 &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; 的格式，请参见下文）</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">信息以 &lt;code&gt;Allowed&lt;/code&gt; 通过 &lt;code&gt;accept_connection/5&lt;/code&gt; 传递。仅当远程节点启动连接时，此字段才是必填字段。也就是说，当通过 &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 建立连接时。</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 将信息添加到跟踪信息文件中。请注意， &lt;code&gt;ValueList&lt;/code&gt; 始终是一个列表，并且如果您使用相同的 &lt;code&gt;Key&lt;/code&gt; 多次调用 &lt;code&gt;write_trace_info/2&lt;/code&gt; ，则 &lt;code&gt;ValueList&lt;/code&gt; 都会用新值扩展ValueList。</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">参考资料</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">测试用例的初始化/结束配置功能</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">测试用例组的启动/结束配置功能。</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">测试套件的启动/结束配置功能</target>
        </trans-unit>
        <trans-unit id="569763f9af2cd4ec4e87af5548f03474b19269ff" translate="yes" xml:space="preserve">
          <source>Initial Database Content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2b1ad6dd5b0e863107461f8ceb27d60b1c0cb1" translate="yes" xml:space="preserve">
          <source>Initial Heap Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">可以使用测试规范术语 &lt;code&gt;init&lt;/code&gt; 在测试目标节点上自动启动并执行初始操作。</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">初始回调状态。占主导地位的状态被传递给一些 &lt;code&gt;diameter_app(3)&lt;/code&gt; 回调，然后这些回调可以返回新状态。默认为 &lt;code&gt;alias&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">用户的初始配置</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">基准的初始配置已经完成。现在是时候对实际的基准和Mnesia进行配置了。</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">最初的标点符号</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="720af05a9330814d44ade6dcc2331d10aefceb80" translate="yes" xml:space="preserve">
          <source>Initialization Vector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a42b2def50c7a5490ba305f82951039087900a5" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt; enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; 读取的初始化结构。</target>
        </trans-unit>
        <trans-unit id="b321f9a1e8a675ea2509ce2b0539809a756cd038" translate="yes" xml:space="preserve">
          <source>Initialize a Schema and Start Mnesia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27938fcde1cf5af3f8db5ecbf20a6ad88b05809" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;code&gt;ei&lt;/code&gt; library. This function should be called once (and only once) before calling any other functionality in the &lt;code&gt;ei&lt;/code&gt; library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f6886984c95422bac94f177607f7282849e50" translate="yes" xml:space="preserve">
          <source>Initialize the dynamically realizable buffer referred to by &lt;code&gt;x&lt;/code&gt;. The fields of the structure pointed to by parameter &lt;code&gt;x&lt;/code&gt; is filled in, and a default buffer is allocated. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; also puts an initial version byte, which is used in the binary format (so that &lt;code&gt;ei_x_encode_version()&lt;/code&gt; will not be needed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">初始化 &lt;code&gt;Config&lt;/code&gt; 以进行属性测试。</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">初始化zlib流的解压会话。</target>
        </trans-unit>
        <trans-unit id="41ffca7e6986ca11ec650f170b95e3cc75bf8fd1" translate="yes" xml:space="preserve">
          <source>Initializes a series of encryptions or decryptions where the IV is provided later. The actual encryption or decryption is done by &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">初始化一个zlib流进行压缩。</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">初始化zlib流进行解压。</target>
        </trans-unit>
        <trans-unit id="336b3d7ce13f5601ff72f5897cdf09da9f9fe9ae" translate="yes" xml:space="preserve">
          <source>Initializes and extends &lt;code&gt;Config&lt;/code&gt; for property based testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">在 &lt;code&gt;*pid&lt;/code&gt; 处初始化 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 变量以表示调用过程。</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">初始化 &lt;code&gt;ec&lt;/code&gt; 结构，以标识服务器的节点名称和cookie。必须先调用其中一个，然后才能使用适用于 &lt;code&gt;ei_cnode&lt;/code&gt; 类型的其他函数或使用与到另一个节点的连接关联的文件描述符。</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">初始化 &lt;code&gt;erl_connect&lt;/code&gt; 模块。特别是，这些函数用于标识从中调用它们的C节点的名称。在使用 &lt;code&gt;erl_connect&lt;/code&gt; 模块中的任何其他功能之前，必须先调用这些功能之一。</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">从指定的字节序列初始化压缩字典,但不产生任何压缩输出。</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">初始化流HMAC操作的上下文。 &lt;code&gt;Type&lt;/code&gt; 确定在HMAC操作中使用哪个哈希函数。 &lt;code&gt;Key&lt;/code&gt; 是认证密钥。密钥可以是任何长度。</target>
        </trans-unit>
        <trans-unit id="cc5e35ae1f6e4c8a9f317a985307e702ec5fe8b6" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming MAC operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">初始化流哈希操作的上下文。 &lt;code&gt;Type&lt;/code&gt; 确定要使用的摘要。返回的上下文应用作 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">从指定的未压缩字节序列初始化解压缩字典。必须将此函数作为对返回 &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; 的膨胀操作（例如 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; ）的响应，或者在不推荐使用的函数的情况下，抛出 &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; 例外。</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">初始化要在RC4流加密中使用的状态 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用计数器模式（CTR）初始化用于流AES加密的状态。 &lt;code&gt;Key&lt;/code&gt; 是AES密钥，并且必须为128、192或256位长。 &lt;code&gt;IVec&lt;/code&gt; 是128位（16字节）的任意初始化向量。此状态用于 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">使用连续的缓冲区初始化 &lt;code&gt;bin&lt;/code&gt; 指向的结构，该缓冲区的字节内容与 &lt;code&gt;iolist&lt;/code&gt; 相同。与 &lt;code&gt;inspect_binary&lt;/code&gt; 一样， &lt;code&gt;bin&lt;/code&gt; 指向的数据是瞬态的，不需要释放。</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">使用有关二进制项 &lt;code&gt;bin_term&lt;/code&gt; 的信息初始化 &lt;code&gt;bin&lt;/code&gt; 指向的结构。</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">初始化 &lt;code&gt;Erl_Interface&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">初始化数据库</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">初始化一个新的数据库模式,该模式有一个属性,该属性指定了该数据库要在哪个节点或哪些节点上运行。</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">初始768字+每个元素的大小(6字+Erlang数据的大小)。必要时表格会增长。</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">最初，代码路径包括当前工作目录和库目录 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 下的所有Erlang对象代码目录，其中 &lt;code&gt;$OTPROOT&lt;/code&gt; 是Erlang / OTP的安装目录， &lt;code&gt;code:root_dir()&lt;/code&gt; 。目录可以命名为 &lt;code&gt;Name[-Vsn]&lt;/code&gt; ，默认情况下，代码服务器从具有相同 &lt;code&gt;Name&lt;/code&gt; 的目录中选择版本号最高的目录。后缀 &lt;code&gt;-Vsn&lt;/code&gt; 是可选的。如果 &lt;code&gt;ebin&lt;/code&gt; 目录位于 &lt;code&gt;Name[-Vsn]&lt;/code&gt; ，则此目录将添加到代码路径。</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">最初，代码路径由当前工作目录和 &lt;code&gt;ROOT/lib&lt;/code&gt; 下的所有目标代码目录组成，其中 &lt;code&gt;ROOT&lt;/code&gt; 是Erlang / OTP的安装目录。目录可以命名为 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 。默认情况下，代码服务器从具有相同 &lt;code&gt;Name&lt;/code&gt; 的目录中选择版本号最高的目录。该 &lt;code&gt;-Vsn&lt;/code&gt; 后缀是可选的。如果 &lt;code&gt;ebin&lt;/code&gt; 目录存在于 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 目录下，则将该目录添加到代码路径中。</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">使用通知 &lt;code&gt;Notification&lt;/code&gt; 由 &lt;code&gt;TargetName&lt;/code&gt; 标识的管理器启动发现过程。</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">启动传输服务,并为其提供一个从megaco:user_info/2获得的接收句柄。</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Addr&lt;/code&gt; 和 &lt;code&gt;Port&lt;/code&gt; 指定的对等方（SCTP服务器套接字）启动套接字 &lt;code&gt;Socket&lt;/code&gt; 的新关联。</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">启动新的握手。一个显着的返回值是 &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; 指示对等方拒绝进行重新协商，但是使用先前协商的会话，连接仍然处于活动状态。</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">启动zlib流进行压缩。</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">立即启动心脏跳动</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">启动事件处理程序。返回 &lt;code&gt;Args&lt;/code&gt; ，该参数将在对 &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; 的调用中使用。</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 功能来完成对管理者的发现。 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; 文件中目标（管理器）条目的 &lt;code&gt;EngineId&lt;/code&gt; 字段必须具有 &lt;code&gt;discovery&lt;/code&gt; 值。请注意，如果管理器不响应，则 &lt;code&gt;Timeout&lt;/code&gt; 和 &lt;code&gt;RetryCount&lt;/code&gt; 字段将决定函数在返回之前将挂起多长时间。</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统跟踪程序的启动。当使用 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 启动跟踪端口时，将自动完成此操作。</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">内联不一定能改善运行时间。例如,内联会增加Beam栈的使用量,这可能会对递归函数的性能造成损害。</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">内联从来都不是默认值。必须在源模块中使用编译器选项或 &lt;code&gt;-compile()&lt;/code&gt; 属性显式启用它。</target>
        </trans-unit>
        <trans-unit id="d1f86e94d7e79143e2b6de623fe87b30507e4ce9" translate="yes" xml:space="preserve">
          <source>Inlining of List Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77e8eee07a3df5a34aa397c94c2739ac57d8e58" translate="yes" xml:space="preserve">
          <source>Input File Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输入的是 &lt;code&gt;modify_algs_list()&lt;/code&gt; 和一组算法 &lt;code&gt;A&lt;/code&gt; (如果存在），它们是从 &lt;code&gt;preferred_algorithms&lt;/code&gt; 选项获得的，或者是从 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 获得的。</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">在ssl应用程序本地缓存中插入CRL。</target>
        </trans-unit>
        <trans-unit id="c64d6655689268dfa5695acb8ab21be53b2e0542" translate="yes" xml:space="preserve">
          <source>Insert CRLs, available to fetch on DER format from &lt;code&gt;URI&lt;/code&gt;, into the ssl applications local cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">插入一个字典条目,并向所有注册用户发送一个{et,{dict_insert,Key,Val}}元组。</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">不管表的大小如何，在 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; 和 &lt;code&gt;duplicate_bag&lt;/code&gt; 类型的表中的插入和查找时间都是恒定的。对于 &lt;code&gt;ordered_set&lt;/code&gt; 数据类型，时间与对象数的（二进制）对数成正比。</target>
        </trans-unit>
        <trans-unit id="ddc91d12a204c2897db05b9911e78202bfd7630f" translate="yes" xml:space="preserve">
          <source>Insert matching closing bracket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">插入以前杀死的文本</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">插入一些数据</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">插入事件取代了调用自己的状态处理函数的技巧，而在 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 中，您通常必须诉诸这种状态处理函数，以便在其他事件之前强制处理插入的事件。</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">在抽象的 Erlang 语法树中插入注释。</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">在抽象的 Erlang 语法树中插入注释。</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">对于大表来说,插入和删除的效率很低。</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">插入 &lt;code&gt;Item&lt;/code&gt; 作为队列 &lt;code&gt;Q1&lt;/code&gt; 的尾项。返回新队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的前面。返回结果队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的开头。返回新队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的后面。返回结果队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">将具有值 &lt;code&gt;Value&lt;/code&gt; 的 &lt;code&gt;Key&lt;/code&gt; 插入 &lt;code&gt;Tree1&lt;/code&gt; 并返回新树。假定树中不存在密钥，否则崩溃。</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">插入 &lt;code&gt;Key&lt;/code&gt; 与价值 &lt;code&gt;Value&lt;/code&gt; 到 &lt;code&gt;Tree1&lt;/code&gt; ，如果关键是不存在的树状结构，否则更新 &lt;code&gt;Key&lt;/code&gt; 价值 &lt;code&gt;Value&lt;/code&gt; 在 &lt;code&gt;Tree1&lt;/code&gt; 。返回新树。</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">插入 &lt;code&gt;Sep&lt;/code&gt; 在各元件之间 &lt;code&gt;List1&lt;/code&gt; 。对空列表和单例列表没有影响。例如：</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">将新的键值元组插入索引结构。如果已经存在具有相同键的项，则新 &lt;code&gt;Value&lt;/code&gt; 覆盖旧值。</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">将配置文件中的所有数据插入数据库，并销毁所有旧数据，包括具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 的行。从配置文件创建的行将具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">将配置文件中的所有数据插入到数据库中,并销毁所有旧数据。</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">将配置文件中的所有数据插入数据库，并使用StorageType &lt;code&gt;volatile&lt;/code&gt; 销毁所有旧行。从配置文件创建的行将具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">将一个或多个对象插入表 &lt;code&gt;Name&lt;/code&gt; 。如果已经存在某个键与任何指定对象的键匹配的对象，则不更新表，并返回 &lt;code&gt;false&lt;/code&gt; 。否则，将插入对象并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">将一个或多个对象插入表 &lt;code&gt;Name&lt;/code&gt; 中。如果已经存在一个对象且其键与某些给定对象的键匹配，并且表类型已 &lt;code&gt;set&lt;/code&gt; ，则旧对象将被替换。</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">将列表 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 中的对象或所有对象插入表 &lt;code&gt;Tab&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">将 &lt;code&gt;EtsTab&lt;/code&gt; 表 &lt;code&gt;Name&lt;/code&gt; 的对象插入ETS表EtsTab中。没有插入对象的顺序。除非覆盖，否则将保留ETS表的现有对象。</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">在一个字符类中,/b有不同的含义;它匹配的是退格字符。如果这些断言中的任何其他断言出现在一个字符类中,默认情况下,它与相应的文字字符相匹配(例如,/B与字母B相匹配)。</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">在字符类内部，或者\后面的十进制数字&amp;gt; 7并且没有太多捕获子模式，PCRE将\ 8和\ 9当作文字字符&amp;ldquo; 8&amp;rdquo;和&amp;ldquo; 9&amp;rdquo;处理，否则重新读取到反斜杠后的三个八进制数字，并使用它们生成数据字符。随后的任何数字都代表自己。例如：</target>
        </trans-unit>
        <trans-unit id="238b16c4bad02ed3ad5ceb23a1d53060e3529beb" translate="yes" xml:space="preserve">
          <source>Inspecting the Inferred Types of the Analyzed Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">检查选项和收集表格的信息。因此,在优化阶段要修改限定词。</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">检查流程的消息队列。该队列显示在Evaluator区域。</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">检查堆栈上的下一个函数调用,显示位置和变量绑定。</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">检查堆栈上的前一个函数调用,显示位置和变量绑定。</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">安装 &lt;code&gt;Common Test Hooks&lt;/code&gt; （类似于 &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">安装 &lt;code&gt;event_handler&lt;/code&gt; 插件（类似于 &lt;code&gt;ct_run -event_handler&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">安装Microsofts Windows SDK 8.1。</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">安装Visual Studio 12.0 (2013)</target>
        </trans-unit>
        <trans-unit id="7c3074dad8c89939fd6bc2238ba9706f6b6fa012" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 2019</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">安装已创建的目标系统</target>
        </trans-unit>
        <trans-unit id="15bd18613a0aabd193b9d2c514329890ddf37e12" translate="yes" xml:space="preserve">
          <source>Install an alternative evaluator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670c52cab50cfe68e434bacfaa8fb6e66c45fef4" translate="yes" xml:space="preserve">
          <source>Install into &lt;code&gt;C:/OpenSSL-Win64&lt;/code&gt; (or &lt;code&gt;C:/OpenSSL-Win32&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92439a10a8cbf48c10c3c7a94cc9989ba236ab4b" translate="yes" xml:space="preserve">
          <source>Install mingw-gcc, make and autoconf: &lt;code&gt;sudo apt install gcc-mingw-w64 make autoconf&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">将其安装或解压缩到pgm文件夹中：Cygwin： &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS： &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2： &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">一定需要安装很多东西，尤其是现代的用户界面组件。在我的情况下，将 &lt;code&gt;makensis&lt;/code&gt; 放在您的路径中：</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;release&lt;/code&gt; 目标进行安装。您可以使用 &lt;code&gt;release&lt;/code&gt; 目标在所需的任何目录中创建安装，然后自己运行 &lt;code&gt;Install&lt;/code&gt; 脚本，而不用进行 &lt;code&gt;make install&lt;/code&gt; 。 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 用于指定应在其中创建安装的目录。如果使用 &lt;code&gt;make install&lt;/code&gt; 进行安装，则默认情况下这就是 &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; 下的内容。 &lt;code&gt;configure&lt;/code&gt; 阶段中提供的所有安装路径以及 &lt;code&gt;DESTDIR&lt;/code&gt; 和 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 都将被忽略。如果您想要来自特定 &lt;code&gt;bin&lt;/code&gt; 链接目录到安装目录，您必须自己进行设置。一个示例，其中Erlang / OTP应该位于 &lt;code&gt;/home/me/OTP&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="1061e24b97b7e7926c0e75ef8fe1d7b8635a2b45" translate="yes" xml:space="preserve">
          <source>Installation Problems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">手动安装</target>
        </trans-unit>
        <trans-unit id="9a154fadab6abdb56f07ab11ddc3af5ae97be03c" translate="yes" xml:space="preserve">
          <source>Installing Module os_sup in Application os_mon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">使用配置确定的路径进行安装。</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">安装后备是分布式操作，&lt;strong&gt;仅对&lt;/strong&gt;所有 &lt;code&gt;db_nodes&lt;/code&gt; 执行。回退将在下次启动系统时还原数据库。如果安装了回退的 &lt;code&gt;Mnesia&lt;/code&gt; 节点检测到另一个节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 已死，则它会无条件终止。</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">如果系统中有许多进程,安装一个新版本可能会很耗时。原因是在清除模块之前,必须检查每个进程对旧代码的引用。这种检查可能会导致垃圾收集和复制数据。</target>
        </trans-unit>
        <trans-unit id="f49d0664d6c577222fc6b488f95606771d152054" translate="yes" xml:space="preserve">
          <source>Installing an Embedded System</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">安装嵌入式系统</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">在应用程序os_mon中安装模块os_sup。</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">安装备份作为后备。在下次启动的时候,用这个备份来恢复数据库。安装后备需要在所有涉及的节点上运行Erlang,但Mnesia是否运行并不重要。如果本地节点不是备份中的磁盘驻留节点之一,那么回退的安装就会失败。</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">在发行结构中安装与发行相关的文件。安装新发行版时，与发行版相关的文件必须位于发行结构中： &lt;code&gt;start.boot&lt;/code&gt; ， &lt;code&gt;relup&lt;/code&gt; 和 &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">安装配置文件和事件处理程序。</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">安装发行版的指定版本 &lt;code&gt;Vsn&lt;/code&gt; 。首先查找 &lt;code&gt;Vsn&lt;/code&gt; 的 &lt;code&gt;relup&lt;/code&gt; 文件和此文件中的脚本 &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; ，以从当前版本升级。如果未找到，该函数将查找当前版本的 &lt;code&gt;relup&lt;/code&gt; 文件，并在该文件中查找脚本 &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; 以降级为 &lt;code&gt;Vsn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">建议使用 &lt;code&gt;information object class&lt;/code&gt; ， &lt;code&gt;table constraints&lt;/code&gt; 和 &lt;code&gt;parameterization&lt;/code&gt; 来代替 &lt;code&gt;ANY&lt;/code&gt; 和 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 。特别是，构造 &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; 与已弃用的 &lt;code&gt;ANY&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1a112f4ca91bf66f308e6108843c00878e4e2493" translate="yes" xml:space="preserve">
          <source>Instead of a syntax tree, the atom &lt;code&gt;any&lt;/code&gt; can be passed for &lt;code&gt;Expr&lt;/code&gt; (or, more generally, be used for any subtree of &lt;code&gt;Expr&lt;/code&gt;, in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to &lt;code&gt;any&lt;/code&gt;. The typical use is for producing bindings for &lt;code&gt;receive&lt;/code&gt; clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcac9a2c6f438e0b892acc88067b58945c6aafe1" translate="yes" xml:space="preserve">
          <source>Instead of allocating and deallocating memory blocks for the different versions of the balancing information we keep old memory blocks and reuse them when it is safe to do so. In order to be able to determine when it is safe to reuse a block we use the thread progress functionality, ensuring that no threads have any references to the memory block when we reuse it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">与其纠结于何时取消超时,不如在已知超时的状态下,对迟到的超时事件进行忽略处理。</target>
        </trans-unit>
        <trans-unit id="5df25e84cfbffa2ce05cceb65eb4a19410b1a990" translate="yes" xml:space="preserve">
          <source>Instead of confirming at a global location each thread confirms that it accepts in increment of the global counter in its own cache line. These confirmation cache lines are located in sequence in an array, and each confirmation cache line will only be written by one and only one thread. One of the managed threads always have the leader responsibility. This responsibility may jump between threads, but as long as there are some activity in the system always one of them will have the leader responsibility. The thread with the leader responsibility will call &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt; which will check that all other threads have confirmed an increment of the global counter before doing the increment of the global counter. The leader thread is the only thread reading the confirmation cache lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213371ce84506976ac4492056a774bb42087e25f" translate="yes" xml:space="preserve">
          <source>Instead of decoding a term you can also skipped past it if you are not interested in the data by usage of &lt;code&gt;&lt;a href=&quot;#ei_skip_term&quot;&gt;ei_skip_term()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">该选项不是提取到目录，而是将结果显示为元组列表 &lt;code&gt;{Filename, Binary}&lt;/code&gt; ，其中 &lt;code&gt;Binary&lt;/code&gt; 是二进制 &lt;code&gt;Filename&lt;/code&gt; ，包含tar文件中名为Filename的文件的提取数据。</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">结果不是提取到当前目录，而是给出一个元组列表 &lt;code&gt;{Filename, Binary}&lt;/code&gt; ，其中 &lt;code&gt;Binary&lt;/code&gt; 是一个二进制文件，其中包含zip存档中 &lt;code&gt;Filename&lt;/code&gt; 文件的提取数据。</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">代替发明编码/解码方案，将使用 &lt;code&gt;term_to_binary/1&lt;/code&gt; 和 &lt;code&gt;binary_to_term/1&lt;/code&gt; BIF。</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">将事件写入文件后不保留,而是可以在事件成功写入文件后删除所有存储的事件(清除)。</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">无需进行两次&lt;strong&gt;完整的解码&lt;/strong&gt;（正常情况下的解码），一次在服务器中，一次在收件人中，而只需要进行一次&lt;strong&gt;专门的解码&lt;/strong&gt;（在服务器中）而另一次进行完整的解码（在收件人中）。本节描述了以下两种专用解码，它们支持解决此问题和类似问题：</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">建议测试用例不要在测试用例之间传递数据,而是从SUT中读取状态,并执行断言(即如果状态符合预期,就让测试用例运行,否则复位或失败)。同时建议使用状态来设置测试用例正常执行所需的变量。常见的动作通常可以实现为测试用例调用的库函数,以将SUT设置为所需的状态。如果有必要的话,也可以对这种常用动作进行单独测试,以确保它们按照预期工作)。有时也可以(但并不总是可取的)在一个测试用例中把测试分组,即让一个测试用例执行一个 &quot;场景 &quot;测试(由子测试组成的测试)。</target>
        </trans-unit>
        <trans-unit id="5e843f77e91e88619108e5e1053242424ec8027e" translate="yes" xml:space="preserve">
          <source>Instead of printing the logs to stdout we print them to a rotating file log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">与其说是收发信息,还不如说是使用一些BIF。</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">代替使用 &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; 来检索调用堆栈回溯，而使用以下语法：</target>
        </trans-unit>
        <trans-unit id="de3457c1d8ba8869d9e05a5cf426f25a98eeb702" translate="yes" xml:space="preserve">
          <source>Instead of using a global lock protecting modifications of this information, we write a completely new version of it at each load balancing. The new version is written in another memory block than the previous one, and published by issuing a write memory barrier and then storing a pointer to the new memory block in a global variable using an atomic write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">F中不写(x,y),也不写x F y,而是写F(x)=y,当F是一个函数时,我们说F把x映射到y上,或者说F在x处的值是y。</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">而是使用STDLIB中的 &lt;code&gt;ordsets&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="bbec30d1239740312abe0f5b282771460878faea" translate="yes" xml:space="preserve">
          <source>Instead we store the meta information about all the free segments in a dedicated area apart from the &lt;code&gt;sa&lt;/code&gt; and &lt;code&gt;sua&lt;/code&gt; areas. Every free segment is represented by a descriptor struct (&lt;code&gt;ErtsFreeSegDesc&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">而是可以从头开始或通过编辑生成的版本来手动创建正确的 &lt;code&gt;relup&lt;/code&gt; 文件。启动/停止 &lt;code&gt;ch_app&lt;/code&gt; 的说明已替换为加载/卸载应用程序的说明：</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">反之,则写成:</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">指示网络接口进程向信息请求发送响应(确认)。</target>
        </trans-unit>
        <trans-unit id="d2bbe05f8fa95e1efc3d5bece8070fe298a07cc9" translate="yes" xml:space="preserve">
          <source>Instruction</source>
          <target state="translated">Instruction</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">有关说明已按上述顺序添加到 &lt;code&gt;relup&lt;/code&gt; 文件中。可从相关的应用程序升级文件 &lt;code&gt;App.appup&lt;/code&gt; 获取有关在应用程序版本之间进行升级或降级的说明，这些文件的排序与生成引导脚本时的排序顺序相同，请参见 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; 。将高级指令转换为低级指令，并将结果打印到 &lt;code&gt;relup&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">指示编译器在 &lt;code&gt;Directory&lt;/code&gt; 中搜索包含文件。当遇到 &lt;code&gt;-include&lt;/code&gt; 或 &lt;code&gt;-include_lib&lt;/code&gt; 指令时，编译器会在以下目录中搜索头文件：</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">指示服务器在客户端声称符合HTTP / 1.1时是否使用持久连接。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">仪表标志</target>
        </trans-unit>
        <trans-unit id="d576ad12ae7ca73aaebcc2a1bd690b16fd09352f" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">SNMP-COMMUNITY-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">SNMP-FRAMEWORK-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">SNMP-NOTIFICATION-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">SNMP-TARGET-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">STANDARD-MIB和SNMPv2-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">Instrumentation可以使用分布式Erlang与应用程序进行通信。</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">必须为标量变量和表的 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 以及为表的 &lt;code&gt;get-next&lt;/code&gt; 编写检测函数。该 &lt;code&gt;get-bulk&lt;/code&gt; 操作被翻译成一系列调用的 &lt;code&gt;get-next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">系统存储空间不足[452]。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">整数(24位无符号)。用于限制有效的TLS握手数据包的大小,以避免DoS攻击。默认值为256*1024。</target>
        </trans-unit>
        <trans-unit id="4054de071d83c0118f2e7e0bb466ffc5a48431e8" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received information that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">整数 &lt;code&gt;PreviousSerial&lt;/code&gt; 表示在最后一个接收到的带有跟踪令牌的消息中传递的串行计数器。如果该过程是新顺序跟踪中的第一个，则将 &lt;code&gt;PreviousSerial&lt;/code&gt; 设置为过程内部&amp;ldquo;跟踪时钟&amp;rdquo;的值。</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">整数 &lt;code&gt;ThisSerial&lt;/code&gt; 是进程在传出消息上设置的串行计数器。它基于进程内部的&amp;ldquo;跟踪时钟&amp;rdquo;，在将其附加到消息中的跟踪令牌之前，将其递增1。</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">整数除法</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">X/Y的整数剩余部分</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">整数表示有效的单码点。</target>
        </trans-unit>
        <trans-unit id="181a76a5f255c27b6eead001f5b06ef26f0b2d1e" translate="yes" xml:space="preserve">
          <source>Integer values are either integer or character literals or expressions consisting of possibily nested unary or binary operations that evaluate to an integer. Such expressions can also be used in bit strings and ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">例如，在 &lt;code&gt;SIZE&lt;/code&gt; 表达式中的整数值必须以十进制语法而不是十六进制或位语法输入。</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">与base &lt;strong&gt; &lt;code&gt;base&lt;/code&gt; &lt;/strong&gt;的整数，必须为2..36范围内的整数。</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">整数必须以微秒为单位，这意味着偏移量 &lt;code&gt;7200000000&lt;/code&gt; 等效于 &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">整数超出范围。</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">以909开头的整数，例如 &lt;code&gt;9091&lt;/code&gt; 或 &lt;code&gt;909123&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">目的是为了方便测试。</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当升级ERTS，内核，STDLIB或SASL时使用。当 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成 &lt;code&gt;relup&lt;/code&gt; 文件时，它将自动添加。它在所有其他升级指令之前执行。有关此指令的更多信息，请参见《 &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_new_emulator（低级）。</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">故意不出示证件。</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">呼叫间图形边缘(*)。</target>
        </trans-unit>
        <trans-unit id="c0647e7fac7fdd2a3b341864d842dcd6753383c9" translate="yes" xml:space="preserve">
          <source>Interaction With Other SNMP Agent Toolkits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">交互数据强制执行模块依赖性,并且要尽可能避免。这意味着模块属性中的模块顺序很重要。</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">安全套接层的接口功能</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">SNMP工具箱MIB编译器的接口函数</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">与SNMP工具箱代理的接口功能</target>
        </trans-unit>
        <trans-unit id="47f2cdd50d9092fae631a48bdc454c378a0342df" translate="yes" xml:space="preserve">
          <source>Interface address description list returned from &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0,1&lt;/a&gt;&lt;/code&gt; for a named interface, translated from the returned data of the POSIX API function &lt;code&gt;getaddrinfo()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">客户端和信使之间的接口定义。</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">SNMP工具箱的接口功能</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">与SNMP工具箱管理器的接口功能</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">XML Schema验证的接口模块。</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">XML模式验证的接口模块。它处理2004年10月28日发布的XML Schema第二版的W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; 。有关XML Schema研究的 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; 的介绍。XML结构通过xmerl_xsd：validate / [2,3]进行验证。</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 应用程序的接口模块。</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">事件追踪(ET)应用的接口模块</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Megaco应用的接口模块</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248的TPKT传输协议接口模块。</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248的UDP传输协议接口模块。</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">驱动程序中链接到柔性扫描仪的接口模块。</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">与操作系统系统信息的接口</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">连接TCP/IP套接字的接口。</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">连接UDP套接字的接口。</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">与Windows事件日志的接口</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">动态跟踪的接口</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">标准Erlang I/O服务器的接口</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Erlang内置术语存储BIF的接口</target>
        </trans-unit>
        <trans-unit id="e271a1417ebd38c2097dcca069254ee88820347c" translate="yes" xml:space="preserve">
          <source>Interfaces with &lt;strong&gt;only&lt;/strong&gt; the specified address family</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f70720ae9d9a9229ade1c047b73ae221942913d" translate="yes" xml:space="preserve">
          <source>Interfaces with address family &lt;code&gt;inet&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;inet6&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">内部的Erlang定义。</target>
        </trans-unit>
        <trans-unit id="1d7b78aa00f45d0dd9ee4563372276be519f843b" translate="yes" xml:space="preserve">
          <source>Internal Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76a3a1f266ee2d2c19bd1cf93ee7be9edde487b" translate="yes" xml:space="preserve">
          <source>Internal data types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c321c0008c19ab39f772c58457023179c5cabf57" translate="yes" xml:space="preserve">
          <source>Internal generic instructions are known only to the runtime system and can be changed at any time without compatibility issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57478123672682d59f79168c35495125ed986756" translate="yes" xml:space="preserve">
          <source>Internal generic instructions. They are known only to the runtime system and can be changed at any time without compatibility issues. They are created by transformation rules (described next).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">锁的内部id,并不总是唯一的。这可以是ets表的表名(db_tab),端口的端口ID,分配器的整数标识符等。</target>
        </trans-unit>
        <trans-unit id="0b4e732bf321d59bf0542504f5ae72694c688f58" translate="yes" xml:space="preserve">
          <source>Internal runtime lock counter controllers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">服务器内部的错误记录在错误日志文件中。该文件的格式比使用通用日志文件格式的日志更无计划,但符合以下语法。</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">通道的内部状态。</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 内部使用几种提交协议。所选协议取决于事务中已更新的表。如果对称地复制了所有涉及的表（也就是说，它们都具有当前可从协调器节点访问的相同的 &lt;code&gt;ram_nodes&lt;/code&gt; ， &lt;code&gt;disc_nodes&lt;/code&gt; 和 &lt;code&gt;disc_only_nodes&lt;/code&gt; ），那么将使用轻量级事务提交协议。</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">在内部，称为 &lt;code&gt;alloc_util&lt;/code&gt; 的框架用于实现分配器。 &lt;code&gt;sys_alloc&lt;/code&gt; 和 &lt;code&gt;mseg_alloc&lt;/code&gt; 不使用此框架，所以下面也&lt;strong&gt;不能&lt;/strong&gt;适用于他们。</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">在每个优先级的内部,进程以循环的方式进行调度。</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">在Erlang运行时系统内部,锁是用来保护资源不被多个线程以致命的方式更新。锁是保证运行时系统正常工作的必要条件,但它也引入了一些限制。锁的争用和锁的开销。</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">在运行时系统内部，Erlang单调时间是&amp;ldquo;时间引擎&amp;rdquo;，用于或多或少地与时间有关的所有事情。所有计时器，无论它是 &lt;code&gt;receive ... after&lt;/code&gt; 计时器，BIF计时器还是在 &lt;code&gt;timer(3)&lt;/code&gt; 模块中的计时器之后的接收...，都被触发相对的Erlang单调时间。甚至 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 也基于Erlang单调时间。通过将当前的Erlang单调时间与当前时间偏移量相加，可以获得当前的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">在内部，二进制文件和位串以相同的方式实现。在本节中，它们被称为&lt;strong&gt;二进制文件，&lt;/strong&gt;因为这就是它们在模拟器源代码中的名称。</target>
        </trans-unit>
        <trans-unit id="65b23551ca2d93024f6a6d3767a19538365fa833" translate="yes" xml:space="preserve">
          <source>Internally, for example in the generated code and in the output from the BEAM disassembler, the instruction &lt;code&gt;move x y&lt;/code&gt; will be called &lt;code&gt;move_xy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">在内部,记录使用标记的元组来表示。</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">在内部，主管还跟踪PID的 &lt;code&gt;Child&lt;/code&gt; 的孩子的过程中，或者 &lt;code&gt;undefined&lt;/code&gt; 如果没有PID存在。</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">不支持国际化域名。</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">可解释的模块是其中模块 &lt;code&gt;.beam&lt;/code&gt; 文件，用选项编译 &lt;code&gt;debug_info&lt;/code&gt; 组，位于相同的目录中的源代码，或在 &lt;code&gt;ebin&lt;/code&gt; 旁边目录。</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">解释器接口。</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">将其解释为普遍时间。</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">无论模式属性的值是多少,都会对escript进行解释。</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">解释指定的模块。 &lt;code&gt;i/1&lt;/code&gt; 仅在当前节点上解释模块。 &lt;code&gt;ni/1&lt;/code&gt; 解释所有已知节点上的模块。</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释指定的模块。 &lt;code&gt;ii/1&lt;/code&gt; 仅在当前节点上解释模块，请参见 &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ini/1&lt;/code&gt; 解释所有已知节点上的模块，请参阅 &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">将设定的时间解释为本地时间。</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">与空家族相交会退出，并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">与一组空集相交会退出，并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">在ERTS 8.1.2(Erlang/OTP 19.2)中引入。</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">在ERTS 8.3中引入(Erlang/OTP 19.3)。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">无效的主题备选名称扩展。</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">无效的Unicode码点是指0xd800到0xdfff(所谓的 &quot;代用 &quot;码点)的范围,以及0xffef。</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">无效的参数： &lt;code&gt;to&lt;/code&gt; 不是有效的Erlang pid。</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">无效的用户名或密码。</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">使mib服务器缓存无效。</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">反转量词的&amp;ldquo;贪婪度&amp;rdquo;，以便默认情况下它们不是贪婪的，但是如果后面跟有&amp;ldquo;？&amp;rdquo;，则变成贪婪的。它与Perl不兼容。也可以通过图案中的 &lt;code&gt;(?U)&lt;/code&gt; 选项设置进行设置。</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">为每个交易请求调用</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">当连接被关闭时调用。</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">建立新连接时调用</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">当收到的消息有语法错误时调用。</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">当收到的消息只包含一个错误而不是交易列表时调用。</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">当交易请求被中止时调用。</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">收到意外信息时调用</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">当文件传输中止时调用。</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;et:trace_me/5&lt;/code&gt; 并将 &lt;code&gt;From&lt;/code&gt; 和 &lt;code&gt;To&lt;/code&gt; 都设置为 &lt;code&gt;FromTo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">调用内存检查，并将生成的，与系统相关的数据作为带标签的元组的列表返回，其中， &lt;code&gt;Tag&lt;/code&gt; 可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">调用 Erlang/OTP 3.3 中的旧版 Erlang shell。旧的shell仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">调用 &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; 可能会失败，静默生成次优代码或静默生成错误代码。</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">是 &lt;code&gt;0&lt;/code&gt; 用于常规NIF（并且因此可以用于静态初始化被省略其值 &lt;code&gt;ErlNifFunc&lt;/code&gt; 实例）。</target>
        </trans-unit>
        <trans-unit id="7bfc1a78cb2bcc7b84b4d8522e849e276e3b2586" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if encryption is performed. It is &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">对于 &lt;code&gt;get&lt;/code&gt; 操作，是列号的列表，对于 &lt;code&gt;set&lt;/code&gt; 操作，是列号和值的列表。</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">最好是通过修改工具提供的 meas.sh.skel skeleton 脚本来运行。</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">最好是通过修改工具提供的mstone1.sh.skel skeleton脚本来运行。</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;height&lt;/code&gt; 则忽略。</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;width&lt;/code&gt; 则忽略。</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">是否可以减少函数的调用次数?</target>
        </trans-unit>
        <trans-unit id="460929b5d588ad61c8de03280e78c7d56b2a232e" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_event&lt;/code&gt; when the message &lt;code&gt;Msg&lt;/code&gt; arrives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc97fc3f4fc4dc1bf68aae6f4b7ffaa2bb517cc" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when a &lt;code&gt;{continue,Continuation}&lt;/code&gt; tuple is returned from the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e898ead58a9e871bab718f1e84f37b0b14af8665" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when a &lt;code&gt;{noreply,...}&lt;/code&gt; tuple is returned from the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228974dc1e2ee8c166ab5346a104e82ff7c3810f" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when the reply &lt;code&gt;Msg&lt;/code&gt; is sent back to &lt;code&gt;To&lt;/code&gt; by returning a &lt;code&gt;{reply,...}&lt;/code&gt; tuple from the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74227d0a2fe296366515d24df1da708c9888f70" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when a timeout zero action inserts event &lt;code&gt;Event&lt;/code&gt; in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff83bfe286bb6329b89d051e527a883c039d588" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when it terminates with reason &lt;code&gt;Reason&lt;/code&gt; in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294a5b48153239c37765e39a931950c322e99aa9" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the action &lt;code&gt;Action&lt;/code&gt; starts a timer in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071d8e95d779e01785b0a3c05e94ce0fe7b67644" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the first state &lt;code&gt;State&lt;/code&gt; is entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f49c2b43436a344fa100ba7cd9b9f4394a258d" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; arrives in state &lt;code&gt;State&lt;/code&gt; as the first event after a code change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be78ba4038f711f408995f0478a8c603d217458b" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; is consumed in state &lt;code&gt;State&lt;/code&gt;. &lt;code&gt;NextState&lt;/code&gt; is the new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7103dc771c5867d2888c1c26ca98a43ac20ce8" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; is postponed in state &lt;code&gt;State&lt;/code&gt;. &lt;code&gt;NextState&lt;/code&gt; is the new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb861ed4a841ceaed35aa2f090480bc6b20d264" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Msg&lt;/code&gt; arrives in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e32c5ff6e17908a1ac3d4af8b673dfb7f78b40" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the reply &lt;code&gt;Msg&lt;/code&gt; is sent back to &lt;code&gt;To&lt;/code&gt; by returning a &lt;code&gt;{reply,To,Msg}&lt;/code&gt; action from the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">是实际的协议版本。在大多数情况下,协议版本是从处理过的消息中获取的,但也有例外。</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">挠性扫描仪到底是不是再进入。</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; 相同（表格，[详细，report_errors，report_warnings]）。</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">是被客户端通道进程调用,要求在服务器端执行用户默认shell(通常在Unix系统的/etc/passwd中定义)。</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">是由客户端-通道进程调用,用于请求在服务器上执行预定义的子系统。</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">由客户端通道进程调用，以请求服务器开始执行给定命令。结果是根据以下模式的几条消息。最后一条消息是通道关闭消息，因为 &lt;code&gt;exec&lt;/code&gt; 请求是一次性执行，执行完成后将关闭通道。</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">是由服务器通道进程调用,向客户端发送命令的退出状态。</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">是由客户端和服务器通道进程相互调用来发送数据。</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将用作 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 参数 将是 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="82fbc73aac01b54be4b187e714699ce8bf8833b0" translate="yes" xml:space="preserve">
          <source>Is-set-ok Operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;get next&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;get&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;set&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;tracer/2&lt;/code&gt; 指定了选项 &lt;code&gt;timer&lt;/code&gt; 则发出此命令将启动此跟踪的计时器。</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">如果F是一个家庭，则认为F是 &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; 的子集。如果 &lt;code&gt;union_of_family(F)&lt;/code&gt; 是 &lt;code&gt;domain(F)&lt;/code&gt; 的子集，则相等成立。</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">它允许其他表复制到这个节点。</target>
        </trans-unit>
        <trans-unit id="db00fe5a5a8e9c911935cedb14376bb72459b7b7" translate="yes" xml:space="preserve">
          <source>It allows the handler to remove internal data fields from its configuration data before it is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">它还初始化了一些SNMP计数器。</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">它调用 &lt;code&gt;run_erl&lt;/code&gt; ，它进行设置，以便操作员可以连接到系统。</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">它调用 &lt;code&gt;start_erl&lt;/code&gt; ，它使用正确的 &lt;code&gt;boot&lt;/code&gt; 和 &lt;code&gt;config&lt;/code&gt; 文件调用正确版本的 &lt;code&gt;erlexec&lt;/code&gt; （位于 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">也可以从Erlang程序内部使用它。如果在ASN.1模块 &lt;code&gt;Values&lt;/code&gt; 中定义了该ASN.1代码，则可以通过对 &lt;code&gt;'Values':tt()&lt;/code&gt; 的函数调用从Erlang 获取ASN.1值 &lt;code&gt;tt&lt;/code&gt; ，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">它可以通过以下方式进入:</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">对于一个经常读取数据,但很少写入数据的分布式应用来说,创建表复制是很有优势的,可以实现本地节点的快速读取操作。复制的主要缺点是增加了写数据的时间。如果一个表有两个副本,那么每个写操作都必须访问两个表的副本。由于这些写操作中必须有一个是网络操作,所以对复制表进行写操作的成本要比对非复制表进行写操作的成本高得多。</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">在调用 &lt;code&gt;sign&lt;/code&gt; 或 &lt;code&gt;verify&lt;/code&gt; 之前计算消息摘要，然后将 &lt;code&gt;none&lt;/code&gt; 用作第二个参数可能是合适的：</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">可能要求您的代码必须在不同OTP版本的各种OTP安装上运行。如果是这样，你不能使用新的API开箱即用，因为它不会是可利用的版本OTP 18之前的解决方案是&lt;strong&gt;不&lt;/strong&gt;以避免使用新的API，为您的代码会那么不从可扩展性和准确性的改善中受益制作。相反，请使用新的API（如果可用），并在新的API不可用时使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">可以看出,DBMS是由一个普通的文本文件启动的。</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">在这样的列表中查找最高和最低温度是很有用的。在扩展程序来做这件事之前,我们先来看看用于查找列表中元素最大值的函数。</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">可以验证,如果将数据插入到Ets表中,共享将丢失。</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">它可以是。</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">它还可以选择导出以下部分或全部内容:</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">有时能够对您自己的状态机生成事件可能会有所帮助。这可以通过 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="955cb8381bd4c10a03ed96cbdf6e946485df3b5c" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">在指定的时间段内启用跟踪有时会很有用（例如，监视系统24小时或半秒）。这可以通过选项 &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; 。如果 &lt;code&gt;TimerSpec&lt;/code&gt; 的格式为 &lt;code&gt;MSec&lt;/code&gt; ，则使用 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;MSec&lt;/code&gt; 毫秒后停止跟踪。如果提供了更多的选择（ &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ）， &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 改为调用 &lt;code&gt;Opts&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">选择性/完全解码或独占性/部分解码的组合是最快的,这可以根据具体情况而定。</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">它不能通过URL引用检索互联网上的外部实体,只能检索本地文件系统中的资源。</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">这会导致 &lt;code&gt;Mnesia&lt;/code&gt; 在光盘满节点启动时尝试联系该节点。</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">也可能是对同步请求的延迟回复。</target>
        </trans-unit>
        <trans-unit id="15d82ac91e7712df5bdf96a55a2294646a1789f2" translate="yes" xml:space="preserve">
          <source>It defines the version of the instruction set (which will be included in the code header in the BEAM code). Theoretically, the version could be bumped, and all instructions changed. In practice, we would have two support two instruction sets in the runtime system for at least two releases, so it will probably never happen in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">它本身并没有真正实现任何管理功能。这取决于&lt;strong&gt;用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1c0facb3f9f742f5d022d43754416108d7a651fc" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它不设置任何 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，而是回复调用方，以等待 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 中的回复。 &lt;code&gt;From&lt;/code&gt; 必须是来自对 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 的调用中参数 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 的术语。</target>
        </trans-unit>
        <trans-unit id="f569904cdf74c64d61502b40cdf52a64e986cfae" translate="yes" xml:space="preserve">
          <source>It evaluates to &lt;code&gt;true&lt;/code&gt; if submitted to the Erlang daemon started in &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9d83d94c6d539b05132d871e1c9c5c83c742ef" translate="yes" xml:space="preserve">
          <source>It follows all the pointers from the root-set to the heap and copies each term word by word to the &lt;strong&gt;to space&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">它是在用户数据报协议(UDP)的基础上实现的,因此它可以用来在实施UDP的不同网络上的机器之间移动文件。它的设计是小型和易于实现的。因此,它缺乏常规FTP的大部分功能。它唯一能做的就是从远程服务器读写文件(或邮件)。它不能列出目录,目前也没有用户认证的规定。</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">先前已经证明，每个表都具有许多系统属性，例如 &lt;code&gt;index&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;true&lt;/code&gt; ，如果在列表应用于所有元素的谓词是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">它是一个通道回调模块，用于实现外壳程序和命令执行。可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 定制shell的read-eval-print循环。与实现自己的CLI通道相比，这意味着更少的工作。如果 &lt;code&gt;ssh_cli&lt;/code&gt; 设置为 &lt;code&gt;no_cli&lt;/code&gt; ，则禁用诸如 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 之类的CLI通道，并且仅允许子系统通道。</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">这是一个旧版OTP的转储,其中没有写这个项目。</target>
        </trans-unit>
        <trans-unit id="e5182044a6ea3fa91dca2975296e4a746a6452be" translate="yes" xml:space="preserve">
          <source>It is a major source of confusion exactly which characters will be percent-encoded. In order to make it easier to answer this question the library provides a utility function, &lt;code id=&quot;percent_encoding&quot;&gt;&lt;a href=&quot;uri_string#allowed_characters-0&quot;&gt;uri_string:allowed_characters/0 &lt;/a&gt;&lt;/code&gt;, that lists the allowed set of characters in each major URI component, and also in the most important standard character sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">如果 &lt;code&gt;deterministic&lt;/code&gt; 选项受用户支持并且由用户提供，建议编译器删除所有非确定性信息。</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">允许省略 &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Stacktrace&lt;/code&gt; 。省略的 &lt;code&gt;Class&lt;/code&gt; 是 &lt;code&gt;throw&lt;/code&gt; 的简写：</target>
        </trans-unit>
        <trans-unit id="48abed156caaf8fbad6e753b59c7f4527e776ac9" translate="yes" xml:space="preserve">
          <source>It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">还假定在 &lt;code&gt;otpuser&lt;/code&gt; 的主目录中有一个名为 &lt;code&gt;otp&lt;/code&gt; 的目录，其完整路径为：</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">还必须注意 &lt;code&gt;ERL_ERROR&lt;/code&gt; （发生错误）和 &lt;code&gt;ERL_TICK&lt;/code&gt; （来自其他节点的有效检查，将被忽略）类型。其他可能的类型指示过程事件，例如链接，取消链接和退出：</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">还有趣的是，知道在完整解码，排他解码之后是排除部分中的 &lt;code&gt;decode_part&lt;/code&gt; 和选择性解码之后是完整解码之间的关系。可以将某些情况与此模拟进行比较，例如，检查子值，然后再检查整个值。下表显示了该测试的数据。循环数和时间单位与之前的测试相同。</target>
        </trans-unit>
        <trans-unit id="47109d04235cc55b443f9196149aab3ccf242450" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &lt;code&gt;%else&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">也可以直接从普通的Erlang Shell提示符下调用 &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">也有可能进行更深入的挖掘，例如，根据各种原因跳过或失败进行模式匹配。请注意， &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 元组已转换为 &lt;code&gt;{error,Reason}&lt;/code&gt; 。还请注意，如果收到 &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; 结果，则说明该测试用例成功，但该案例的 &lt;code&gt;end_per_testcase&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">也可以用xmerl对解析后的XML做进一步的处理。如果你想改变XML文档的格式,例如HTML,文本或其他XML格式,你可以转换它。xmerl支持这种转换。</target>
        </trans-unit>
        <trans-unit id="1fb169d7a25eee8232f1cc295837278dd944901e" translate="yes" xml:space="preserve">
          <source>It is also possible to do the same changes in an already running system using the &lt;code&gt;logger&lt;/code&gt; module. Then you do like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166a98df287ec46c15162d974f22e50c42ef71ea" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch the configuration using &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">也可以使用带有 &lt;code&gt;il&lt;/code&gt; 选项的方式以 &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; 形式从OTP应用程序导入MIB 。例：</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">如果使用下面的调用格式,也可以让解析器在需要时要求更多的输入标记。</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">通过使用Erlang仿真器中的内置跟踪支持，还可以对正在运行的系统进行实时跟踪。这些Erlang跟踪可以定向到文件或端口。有关更多信息，请参见 &lt;code&gt;erlang:trace/4&lt;/code&gt; ， &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; ， &lt;code&gt;dbg&lt;/code&gt; 和 &lt;code&gt;ttb&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">也可以用以下的回车方式将字符推回到输入字符中。</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">也可以引用一个在不同模块中定义的函数,其语法如下。</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">也可以通过写引用,如(?+2)来引用后面打开的小括号。然而,这些不能是递归的,因为引用不在被引用的小括号内。它们总是非递归的子程序调用,如下一节所述。</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">也可以指定应该在通知中发送的额外变量的名称和值,但在通知规范中没有定义。</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">也可以立即跟踪到创建原始剖析数据的剖析进程中,也就是将跟踪和剖析步骤短路,使文件系统不被使用。</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">也可以编写自己的Net if进程,本节介绍如何编写。</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">也可以编写自己的Net if过程。默认的Net if进程在模块 &lt;code&gt;snmpa_net_if&lt;/code&gt; 中实现，它使用UDP作为传输协议，即传输域 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 和/或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">在 &lt;code&gt;end_per_group/2&lt;/code&gt; 中，还可以检查子组的状态（也许确定当前组要返回什么状态）。这就像前面的示例中所示的那样简单，只有组名存储在元组 &lt;code&gt;{group_result,GroupName}&lt;/code&gt; 中，可以在状态列表中进行搜索。</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">还建议所有测试套件模块中都包含 &lt;code&gt;ct.hrl&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">如果多个进程同时更新同一记录，则更新事务内的数据库也很有用。例如，功能 &lt;code&gt;raise(Name, Amount)&lt;/code&gt; ，这增加 &lt;code&gt;Amount&lt;/code&gt; 到的人的工资字段，就是被如下实现：</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">同样值得注意的是,带有定时器的程序在调试时可能会有不同的表现。尤其是当停止执行一个进程时(例如,在断点处)。然后,超时可能发生在其他继续正常执行的进程中。</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">如果不是所有的 &lt;code&gt;String&lt;/code&gt; 字符都被消耗掉，那将是一个错误。</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">它在Erlang中的赋值如下。</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">假设驱动程序不访问其他驱动程序。如果驱动程序之间相互访问,它们必须提供自己的线程安全同步机制。这种 &quot;驱动程序之间的通信 &quot;是非常不鼓励的。</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">假设读者已经做过一些编程,对数据类型和编程语言语法等概念比较熟悉。</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">假设读者熟悉Erlang编程语言,对使用公钥和数字证书的概念有基本了解。</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">假定读者熟悉Erlang编程语言，&lt;strong&gt;OTP的&lt;/strong&gt;概念，并对&lt;strong&gt;公共密钥&lt;/strong&gt;有基本的了解。</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并具备SNMP的基本知识。</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对关系型数据库和SQL有基本了解。</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对和HTTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对FTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对TFTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并熟悉ASN.1符号。ASN.1符号被记录在标准定义X.680中,这是主要文本。阅读标准定义X.681、X.682、X.683、X.690和X.691也会有帮助,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、系统开发原理和数据库管理系统。</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对SSL/TLS/DTLS有基本了解。</target>
        </trans-unit>
        <trans-unit id="537e5cc7cbceb70acccab6e7e1e372b187bbe2dc" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of TLS/DTLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">假设读者熟悉Erlang编程语言。</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">假定已启用跟踪（请参见上面的 &lt;code&gt;enable_trace&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">假设你是一个熟练的Erlang程序员,熟悉Erlang数据类型、进程、消息和错误处理等概念。</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">假设你已经熟悉了Erlang编程语言和OTP概念。</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">假设你对司机有一定的了解。</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">假设你有一个工作的Erlang/OTP系统,按照OTP的设计原则进行架构。</target>
        </trans-unit>
        <trans-unit id="da7170d41c4bbfe66ba486c027eb9dc9f166d049" translate="yes" xml:space="preserve">
          <source>It is assumed to be called inside the property called by &lt;code&gt;&lt;a href=&quot;#quickcheck-2&quot;&gt;quickcheck/2&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">它在方案字符串转换为方案原子之前被调用,因此可以防止可能的原子泄漏。</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">ASN.1模块从另一个ASN.1模块导入定义的类型、值和其他实体是很常见的。</target>
        </trans-unit>
        <trans-unit id="f3c0695294a6b1c0df2bd4d07de88a1e3a54c6dd" translate="yes" xml:space="preserve">
          <source>It is composed of lines as for &lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#AUTHORIZED_KEYS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366ff05e8481f1b50ee5d8b0ae1d4dea2764c12b" translate="yes" xml:space="preserve">
          <source>It is composed of lines as for &lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#SSH_KNOWN_HOSTS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e9e1b630f3f988db69ac953192881fde572b35" translate="yes" xml:space="preserve">
          <source>It is crucial to clarify that a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">设计使用SNMP来操纵和控制系统的应用程序很容易。 &lt;code&gt;Mnesia&lt;/code&gt; 提供了组成SNMP控制应用程序的逻辑表和组成 &lt;code&gt;Mnesia&lt;/code&gt; 表的物理数据之间的直接映射。默认值为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">在注册子代理时很容易出错,这项活动应谨慎进行。例如,以下配置会导致一种奇怪的行为:</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">如果使用非规范化数据模型而不是规范化模型，则很容易显示出执行速度更快的代码示例。主要原因是需要较少的表。因此，来自不同表的数据可以更轻松地合并到联接操作中。在前面的示例中，功能 &lt;code&gt;get_emps/2&lt;/code&gt; 从联接操作转换为简单查询，该查询由一个选择和一个表上的投影组成。</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">鼓励省略空目录。</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">为每个驱动程序实例初始化一次 &lt;code&gt;myKey&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">可以预期的是，本节中描述的类型语言将取代并替换 &lt;code&gt;@spec&lt;/code&gt; 使用的纯基于注释的 &lt;code&gt;@type&lt;/code&gt; 和@spec声明。</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">写一个生成器是相当容易的,每次调用它时,如果完成了,就生成一个空列表,否则就生成一个包含一个测试用例的列表,再加上一个新的生成器,生成其余的测试。这演示了基本的模式。</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">确保宏定义是有效的Erlang语法形式是良好的编程实践,但不是强制性的。</target>
        </trans-unit>
        <trans-unit id="20fc259cbb6b4c9e5e515f22c485c458685813f7" translate="yes" xml:space="preserve">
          <source>It is implemented like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">重要的是，表必须有足够数量的对象插槽。如果不是这样，则当 &lt;code&gt;init_table/2&lt;/code&gt; 返回时，哈希列表开始增长，这会在一段时间内显着减慢对表的访问。最小插槽数由 &lt;code&gt;open_file/2&lt;/code&gt; 选项 &lt;code&gt;min_no_slots&lt;/code&gt; 设置，并由 &lt;code&gt;info/2&lt;/code&gt; 项 &lt;code&gt;no_slots&lt;/code&gt; 返回。另请参见下面的选项 &lt;code&gt;min_no_slots&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfd76fb18738a1a7309ffa02f852c57726d1bccb" translate="yes" xml:space="preserve">
          <source>It is important that you do not raise the primary log level before adjusting the default handler's level as otherwise your standard out may be flooded by debug log messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">重要的是，返回的数据取决于选项集的正确类型。因此，在返回之前，&lt;strong&gt;如果可能&lt;/strong&gt;，我们将列表转换为采用正确编码的二进制文件。 &lt;code&gt;get_until&lt;/code&gt; 请求元组中提供的函数可以返回任何最终结果，因此只有返回列表的函数才能将它们转换为二进制。如果请求包含编码标签 &lt;code&gt;unicode&lt;/code&gt; ，则列表可以包含所有Unicode代码点，并且二进制文件应使用UTF-8。如果编码标签是 &lt;code&gt;latin1&lt;/code&gt; ，则客户端只能获取 &lt;code&gt;0..255&lt;/code&gt; 范围内的字符。功能 &lt;code&gt;check/2&lt;/code&gt; 如果将编码指定为 &lt;code&gt;latin1&lt;/code&gt; ,则注意不要在列表中返回任意Unicode代码点。如果该功能未返回列表，则无法执行检查，结果是未更改所提供功能的结果。</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">对脏作业进行正确分类很重要。I/O绑定作业应该这样分类,CPU绑定作业也应该这样分类。如果你应该把CPU绑定的作业分类为I/O绑定的作业,那么脏I/O调度器可能会饿坏普通调度器。I/O绑定作业预计要么阻塞等待I/O,和/或花费有限的时间移动数据。</target>
        </trans-unit>
        <trans-unit id="9a4196885ce002104d00e42ea02d9f5307edd242" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that it is not safe to apply &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; directly on an input URI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">需要理解的是,限制匹配时所说的 &quot;递归 &quot;并不是在Erlang机器的C栈或Erlang进程栈上的递归。编译到Erlang虚拟机中的PCRE版本使用机器 &quot;堆 &quot;内存来存储正则表达式匹配中必须保持递归的值。</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">使用没有分支的 &lt;code&gt;receive..after&lt;/code&gt; 表达式是合法的：</target>
        </trans-unit>
        <trans-unit id="8591893750dc5759c22c24a40b729a09191cadb5" translate="yes" xml:space="preserve">
          <source>It is like the older type an exception of the &lt;code&gt;error&lt;/code&gt; class. In addition they contain a descriptive text in English. That text is targeted to a developer. Examples are &quot;Bad key size&quot; or &quot;Cipher id is not an atom&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">在归一化数据库中进行归一化搜索的效率更高。在归一化的数据模型上,有些操作也更容易执行。例如,可以很容易地删除一个项目,如下例所示:</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">设置一个本地锁比设置一个网络锁更有效率。因此,粘性锁可以使一个使用复制表的应用程序受益,并且只在其中一个节点上执行大部分工作。</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">它的效率更高。</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">能够在示例中进行格式化输出真是太好了，因此下一个示例展示了一种使用 &lt;code&gt;io:format&lt;/code&gt; 函数的简单方法。像所有其他导出的函数一样，您可以在shell中测试 &lt;code&gt;io:format&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">使用全局变量不是一个好主意,因为 port 驱动程序可以由多个 Erlang 进程生成。这个驱动结构要被多次实例化。</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">不允许从 &lt;code&gt;stop_select&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; 中的任何函数。此严格限制是因为可以调用 &lt;code&gt;stop_select&lt;/code&gt; 的易失上下文。</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">一旦在一个被跟踪的节点之一中激活了过载保护，就不允许更改跟踪详细信息（使用 &lt;code&gt;ttb:p&lt;/code&gt; 和 &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ）。这是为了避免节点之间的跟踪设置不一致。</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">不允许加载具有相同名称但具有不同 &lt;code&gt;Path&lt;/code&gt; 参数的多个驱动程序。</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">不允许引用未声明为导出的类型。</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">不允许将原子 &lt;code&gt;asn1_VALUE&lt;/code&gt; 和 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 与地图一起使用。</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">普通括号实现两个功能并不总是有用的。通常情况下,需要一个没有捕获要求的分组子模式。如果开头的小括号后面是一个问号和一个冒号,那么这个子模式就不做任何捕获,在计算任何后续捕获子模式的数量时也不会被计算在内。例如,如果将字符串 &quot;the white queen &quot;与下面的模式进行匹配,捕获的子串是 &quot;white queen &quot;和 &quot;queen&quot;,编号为1和2。</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">将传输添加到尚未配置的服务中并不是一个错误:服务可以在配置其传输后启动。</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">从尚不存在的服务中订阅事件不会出错。在添加传输之前,需要这样做,以保证接收所有传输相关的事件。</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">不检查表单是否符合 &lt;code&gt;AbstVersion&lt;/code&gt; 指示的抽象格式。 &lt;code&gt;no_abstract_code&lt;/code&gt; 表示存在块 &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; ，但为空。</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">它的设计不是为了被应用程序直接调用,而是通过i/o系统使用,在应用程序中通常可以通过以下方式调用它。</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">不能保证分布式磁盘日志的所有日志文件都包含相同的日志项。没有尝试同步文件的内容。但是，只要每次至少有一个涉及的节点处于活动状态，就会记录所有项目。在将项目记录到分布式日志中或尝试更改日志时，将忽略来自单个日志的答复。如果所有节点都已关闭，则磁盘日志功能 &lt;code&gt;nonode&lt;/code&gt; 错误答复。</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">即使表是固定的，也不能保证对 &lt;code&gt;first/1&lt;/code&gt; ， &lt;code&gt;next/2&lt;/code&gt; 或select and match函数的调用按预期工作。Dets尚未提供 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 模块提供的对并发的有限支持。当前修复表仅会禁用表的哈希列表的大小调整。</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">不难猜测该程序将数字的值加倍。该代码的前两行将在后面介绍。让我们编译程序。可以在Erlang shell中按如下方式完成此操作，其中 &lt;code&gt;c&lt;/code&gt; 表示编译：</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">并非必须实现 &lt;code&gt;Module:format_status/2&lt;/code&gt; 函数。如果不这样做，则使用默认实现，该实现与本示例函数相同，但不过滤 &lt;code&gt;Data&lt;/code&gt; 术语，即 &lt;code&gt;StateData = {State,Data}&lt;/code&gt; ，在此示例中包含敏感信息。</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">没有必要导出该函数。它在一个新生成的进程中被调用(该进程在函数返回后立即终止)。</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">不需要在发送的消息中明确地设置报头字段,因为 diameter 本身会设置适当的值。设置不合适的值对于测试来说是很有用的。</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">不需要将启动脚本链接到标准目录，例如 &lt;code&gt;/usr/local/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">使用此语法不可能对数字为10或更大的子模式使用数字&amp;ldquo;前向引用&amp;rdquo;，因为诸如\ 50之类的序列被解释为以八进制定义的字符。有关反斜杠后的数字处理的更多详细信息，请参阅前面的 &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; 一节。使用命名括号时没有这种问题。可以使用命名括号对任何子模式进行向后引用（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">除了表达式,其他地方不可能有未知形式的钩子函数。</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">通过测试无法证明程序是正确的。相反，已经正式证明不可能通过测试来证明程序。对于那些希望证明程序正确的人，理论上的程序证明或对代码的简单检查可能是可行的选择。基于测试的测试服务器不能用于认证。它的预期用途是（经济有效地）&lt;strong&gt;查找错误&lt;/strong&gt;。成功的测试套件可以揭示一个错误。如果测试套件的结果为&amp;ldquo; OK&amp;rdquo;，则说明我们之前所不知道的很少。</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">状态图没有规定如何处理图中某一特定状态中没有说明的事件是很常见的。希望在相关的文本中或从上下文中对此进行描述。</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">指定的开始时间晚于当前时间是无效的。如果指定 &lt;code&gt;StartTime&lt;/code&gt; 的时间早于日志可以支持的时间，则重播将从最早的可用通知开始。</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">现在可以很容易地检查释放对未定义函数的调用。</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">除非将 &lt;code&gt;long_request_timer&lt;/code&gt; （请参见上文）也设置为增量计时器（ &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ），否则将此值设置为&lt;strong&gt;true&lt;/strong&gt;当然是没有意义的。</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">当然,也可以更改多个列表。</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">当然,为什么有人愿意同时使用这两种方案是值得商榷的,但如果有意外的需要,也是可以的。</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">这个操作至关重要,不能长时间阻挡呼叫者。这是因为它是由连接主管调用的。</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">在这样的圆圈中标记查询变量通常是很清楚的。下图显示了一些预定义的分析。注意，仅由本地函数使用的本地函数未在 &lt;code&gt;locals_not_used&lt;/code&gt; 圆圈中标记。</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">在修改表格时,往往需要采取一些特定的行动。这可以通过一个工具函数来实现。当表被设置时,它会执行一些特定的代码,并将所有其他请求传递给预先定义的函数。</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">按原样使用Erlang/OTP系统往往是不可取的。开发者可以为某个特定的目的创建新的符合Erlang/OTP的应用,而原有的几个Erlang/OTP应用可能与相关目的无关。因此,需要能够在给定的Erlang/OTP系统的基础上创建一个新的系统,在这个系统中删除可有可无的应用程序,并包含新的应用程序。文档和源代码是不相关的,因此不包含在新系统中。</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">通常情况下,在escript中加入一个头是非常方便的,尤其是在Unix平台上。但是,头是可选的,所以你可以直接 &quot;执行 &quot;一个Erlang模块,Beam文件,或者存档文件,而不需要添加任何头。但是你必须调用脚本,如下所示。</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">在FIPS模式下， &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; 分别使用 &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; 和usmAesCfb128Protocol进行身份验证和隐私。但是，snmp应用程序不会以任何方式限制选择禁用的协议，使用它们会导致运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="9fa7b580bee0cd82b79a574d9169e03e86d95bf2" translate="yes" xml:space="preserve">
          <source>It is ordered by the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">它由状态转换动作 &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 或只是一个整数 &lt;code&gt;Time&lt;/code&gt; 排序，即使没有封闭动作列表（后者是从 &lt;code&gt;gen_fsm&lt;/code&gt; 继承的形式）。</target>
        </trans-unit>
        <trans-unit id="c2055694d674903a04f32f46b3d110e4fe1e7d79" translate="yes" xml:space="preserve">
          <source>It is outside the scope for this document to describe in detail how such guard functions are written, but for the curious here is the implementation of &lt;code&gt;literal_is_map()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb514030de07cc7f47659f8e694150bb1b3605c4" translate="yes" xml:space="preserve">
          <source>It is outside the scope of this document to describe in detail how generator functions are written, but for the curious, here is the implementation of &lt;code&gt;gen_element()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">通过这个选项,可以为状态提供早期验证的过程信息。</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">Emacs可以在显示缓冲区时使用颜色。我们所说的 &quot;语法高亮 &quot;是指语法成分,例如关键字和函数名,将被着色。</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">一个处理程序即使能够成功地处理高负载的峰值而不崩溃,也有可能建立一个大的消息队列,或者使用大量的内存。过载保护机制包括一个自动终止和重新启动的功能,目的是为了保证处理程序不会增长到超出边界的程度。该功能的配置参数如下。</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">可以将&lt;strong&gt;通知过滤器&lt;/strong&gt;添加到代理。发送通知时将调用这些过滤器。它们的目的是允许修改，抑制或其他类型的动作。</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">可以仅通过给出相应的进程标识来附加到被解释的进程。默认情况下,会显示一个附加窗口。其他 Erlang 节点的进程可以手动或自动附加。</target>
        </trans-unit>
        <trans-unit id="2e8dd8df3b8da8be36f66edb5a2d3e1745bac94b" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the script's original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">可以将 &lt;code&gt;escript&lt;/code&gt; 与Erlang运行时系统捆绑在一起，以使其自给自足且可重定位。在这样的独立系统中， &lt;code&gt;escript&lt;/code&gt; 应位于独立系统的顶层 &lt;code&gt;bin&lt;/code&gt; 目录中，并以 &lt;code&gt;.escript&lt;/code&gt; 作为文件扩展名。此外，应将（内置） &lt;code&gt;escript&lt;/code&gt; 程序复制到同一目录，并赋予脚本原始名称（不带 &lt;code&gt;.escript&lt;/code&gt; 扩展名）。这将允许使用捆绑的Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">可以使匹配过程有条件地服从一个子模式,或者根据一个断言的结果,或者是否已经匹配了一个特定的捕获子模式,在两个备选子模式中进行选择。以下是条件子模式的两种可能形式。</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">可以配置一个3588字典,以获得3588语义,其中与6733不同。</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">可以调试应用程序的每个（非主管）进程（代理和管理器），可能是net_if模块的例外，这可以由应用程序的用户提供。这可以通过调用 &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; 和 &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; 函数和/或使用 &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。详细程度本身有几个&lt;strong&gt;层次&lt;/strong&gt;： &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; 。对于最低的详细度 &lt;code&gt;silence&lt;/code&gt; ，不会打印任何内容。详细程度越高，打印的越多。默认值为始终 &lt;code&gt;silence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">可以生成一个 &lt;code&gt;.hrl&lt;/code&gt; 文件，其中包含来自已编译的MIB文件的Erlang常量的定义。然后可以将该文件包含在Erlang源代码中。该文件将包含以下常量：</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">可能在一个节点上具有 &lt;code&gt;disc_copies&lt;/code&gt; 类型的复制表，而在另一节点上具有另一种类型的复制表。默认值为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">可能在一个节点上具有 &lt;code&gt;disc_copies&lt;/code&gt; 类型的复制表，而在另一节点上将同一表存储为不同类型的表。默认值为 &lt;code&gt;[]&lt;/code&gt; 。如果需要以下操作特性，则此布置是理想的：</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">可以有以下ASN.1类型定义:</target>
        </trans-unit>
        <trans-unit id="548cba172b1fcb6f71c35f5e74ff7ab8d68b17fd" translate="yes" xml:space="preserve">
          <source>It is possible to limit which types of documentation is build by passing the &lt;code&gt;DOC_TARGETS&lt;/code&gt; environment variable to &lt;code&gt;make docs&lt;/code&gt;. The currently available types are: &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;pdf&lt;/code&gt;, &lt;code&gt;man&lt;/code&gt; and &lt;code&gt;chunks&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65479625a383af2cdbc9583d3c3a03b0cb2fe00" translate="yes" xml:space="preserve">
          <source>It is possible to limit which types of documentation is released using the same &lt;code&gt;DOC_TARGETS&lt;/code&gt; environment variable as when building documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">可以将mib加载到管理器中,但这不是正常运行所必需的,也不推荐。</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">可以修改进程的默认行为，以使其在收到异常退出信号时不会被杀死。而是将所有信号转换为格式为 &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; 普通消息，并将其添加到接收过程的消息队列的末尾。通过以下方式设置此行为：</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">除了预定义的宏,可以重载宏。一个重载宏有一个以上的定义,每个定义有不同的参数数。</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">通过使用选项 &lt;code&gt;{compress, What}&lt;/code&gt; 和 &lt;code&gt;{uncompress, What}&lt;/code&gt; 可以覆盖默认行为并控制要压缩的文件类型。也可以使用许多 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">可以对图形进行一些有限的操作。节点可以被移动、选择、锁定或删除。在按下鼠标左键的同时移动鼠标,可以移动单个节点或整个图形。松开鼠标左键时,按住shift键可以锁定一个节点的固定位置。在按下控制键和鼠标左键的同时移动鼠标,可选择多个节点。点击合适的按钮,可以锁定、解锁或删除所选节点。</target>
        </trans-unit>
        <trans-unit id="14dd64fc26d9237b80497c4bfb62db94add92668" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt; Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;catch&lt;/code&gt; 或 &lt;code&gt;try&lt;/code&gt; 可以防止运行时错误和其他异常导致进程终止，请参阅有关 &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">通过首先使用 &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 操作 &lt;code&gt;DataOrStats&lt;/code&gt; ,可以打印更多特定类型的统计信息。例如，如果要打印每个线程的运行时百分比，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b575de532305d96f140137cd1f86dd41dc4043ea" translate="yes" xml:space="preserve">
          <source>It is possible to replace the string with one randomly generated for each connection attempt. See the reference manual for &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356a713c1c6a5a552cd4fb5692b12412de6a432d" translate="yes" xml:space="preserve">
          <source>It is possible to return logger info that will be used by the TLS connection to produce log events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63341d5389e1053c03c8898576d1f494be0100d" translate="yes" xml:space="preserve">
          <source>It is possible to specify more than one type letter for each operand. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">可以指定该模块是&lt;strong&gt;行为&lt;/strong&gt;的回调模块：</target>
        </trans-unit>
        <trans-unit id="81cfbe4935d3cb8cd743dc8d0f5da3c1eaae533d" translate="yes" xml:space="preserve">
          <source>It is possible to use Pre-Shared Key (PSK) and Secure Remote Password (SRP) cipher suites, but they are not enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">可以在IPv6而非IPv4上使用SSL / TLS分发。为此，请在命令行或 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 环境变量中启动Erlang时传递 &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; 选项而不是 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff4792545154511875db9acebbc89980b3695713" translate="yes" xml:space="preserve">
          <source>It is possible to use TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">可以根据某些原理用C编写驱动程序，并将其动态链接到Erlang运行时系统。从Erlang程序员的角度来看，链接的驱动程序看起来像是端口，被称为&lt;strong&gt;端口驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">可以在网络中的多个节点上以全局模式启动Debugger,但绝对不推荐,因为节点之间会相互干扰,导致行为不一致。</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">它主要用于 &lt;code&gt;ets:match/2&lt;/code&gt; 和 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 中，以将记录字段设置为原子 &lt;code&gt;'_'&lt;/code&gt; 。（这是 &lt;code&gt;ets:match/2&lt;/code&gt; 中的通配符。）</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">同时进行壁时钟测量和CPU时间测量可能是一个好主意。</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">休眠过程是相当昂贵的；参见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 。在每个事件之后，您都不希望这样做。</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">SSH连接协议建议发送此消息,但并非总是如此。</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">除非绝对必要，否则建议不要指定 &lt;code&gt;LogFileOpts&lt;/code&gt; 。处理程序用来打开文件进行日志记录的默认选项是 &lt;code&gt;raw&lt;/code&gt; ， &lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;delayed_write&lt;/code&gt; 。请注意，标准处理程序不支持循环日志记录。为此，请使用disk_log处理程序 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 采用与 &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 遵循与 &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 遵循与 &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">建议将应用程序目录命名为应用程序，可能后跟短划线和版本号。例如 &lt;code&gt;myapp&lt;/code&gt; 或 &lt;code&gt;myapp-1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">建议在 &lt;code&gt;Mnesia&lt;/code&gt; 运行时不要篡改数据文件。虽然未被禁止，但 &lt;code&gt;Mnesia&lt;/code&gt; 的行为是无法预测的。</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">建议嵌入式环境由普通用户,也就是没有超级用户权限的用户来运行。</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">建议添加这几行以避免冲突。冲突会使系统无法启动。</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">建议只在需要与外部实体通信时使用外部编码。当在Erlang/OTP环境中工作时,当表示Unicode字符时,建议将二进制文件保持在UTF-8中。ISO Latin-1编码既支持向后兼容性,也支持与不支持Unicode字符集的外部实体进行通信。</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">建议在具有多个并发进程的系统上将此参数设置为 &lt;code&gt;false&lt;/code&gt; ，因为每次进程内存检查都会遍历整个进程列表。</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">为了便于阅读，建议尽可能使用 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 。然而，该功能将在兼容性的界面被保留，并且将&lt;strong&gt;不会&lt;/strong&gt;在以后的版本不事先通知被移除。</target>
        </trans-unit>
        <trans-unit id="f07eb0965b87ff02eea12ef51a97da8280fa42de" translate="yes" xml:space="preserve">
          <source>It is recommended to use keys like &lt;code&gt;?MODULE&lt;/code&gt; or &lt;code&gt;{?MODULE,SubKey}&lt;/code&gt; to avoid name collisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">建议使用由Erlang / OTP MIB编译器创建的 &lt;code&gt;.hrl&lt;/code&gt; 文件来定义对象标识符（OID）。例如，要从OTP-MIB中的 &lt;code&gt;erlNodeTable&lt;/code&gt; 获取Erlang节点名称：</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">建议使用 &lt;code&gt;record_info/2&lt;/code&gt; 表示法，因为它可以更轻松地维护程序，并且程序在将来的记录更改方面也变得更强大。</target>
        </trans-unit>
        <trans-unit id="b98f8e2acaa67a7dbb0c785ee6e89218b85a8106" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt; Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时创建用户定义的启动脚本很有用或必要。尤其是在嵌入式模式下运行Erlang时，这是正确的，请参阅 &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">强烈建议使用此功能,避免以非标准方式缩进行。一些动机是:</target>
        </trans-unit>
        <trans-unit id="b50f3227925167fcdec205161b96c5f8d34fa936" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">之后，调用者有责任释放数组。该函数已经通过对 &lt;code&gt;malloc()&lt;/code&gt; 的一次调用分配了，因此仅需一个 &lt;code&gt;free()&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="8a182802d5aa3c75c9fd2f1613ab45ae44c8ce7f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;ei_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">释放数组是调用者的责任。 &lt;code&gt;erl_global_names&lt;/code&gt; 使用对 &lt;code&gt;malloc()&lt;/code&gt; 的一次调用分配数组和所有字符串，因此 &lt;code&gt;free(names)&lt;/code&gt; 就是必需的。</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">释放返回的 &lt;code&gt;ETERM&lt;/code&gt; 结构和 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 指向的内存是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">释放 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; ， &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 指向的内存是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">然后可以分配如下数值:</target>
        </trans-unit>
        <trans-unit id="24b56a6b7a78f70503c6ff661055208a04c51535" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">因此，重要的是，赋予 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; 的Fun中的代码是纯净的。例如，如果消息是通过事务Fun发送的，则可能会产生一些奇怪的结果。以下示例说明了这种情况：</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">因此,建议尽可能小步骤地修改代码,并始终保持向后兼容。</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">它将是(或导致)对下列任何一项的调用:</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">通常，使用匹配而不是调用 &lt;code&gt;split_binary/2&lt;/code&gt; 函数来拆分二进制文件更为有效。此外，混合使用位语法匹配和 &lt;code&gt;split_binary/2&lt;/code&gt; 可以阻止对位语法匹配的某些优化。</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">从源代码构建有效的OpenSSL FIPS对象模块和库非常容易。但是，如果未正确遵循安全策略中的众多限制，则它&lt;strong&gt;不&lt;/strong&gt;符合FIPS 140-2验证的条件。</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">了解编码和Unicode字符之间的区别是至关重要的。根据Unicode标准,Unicode字符是代码点,而编码是表示这些代码点的方法。编码只是一种表示标准。例如,UTF-8可以用来表示Unicode字符集中非常有限的一部分(例如ISO-Latin-1)或整个Unicode范围。它只是一种编码格式。</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">它将一组备选方案本地化。例如,以下模式匹配 &quot;cataract&quot;、&quot;caterpillar &quot;或 &quot;cat&quot;。</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">它使调试变得困难(因为故障可能是由不同的测试用例中的问题造成的,而不是失败的测试用例)。</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">这使得测试用例无法以不同的顺序运行。</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">这使得它无法单独运行测试用例。</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">它与主语 &quot;ab &quot;中的 &quot;ab &quot;相匹配。使用回溯控制动词(*PRUNE)和(*SKIP)也会使这种优化失效。</target>
        </trans-unit>
        <trans-unit id="ae6efd6ccdd0c384b5a13c5546c09169a3449d84" translate="yes" xml:space="preserve">
          <source>It may also raise the exception &lt;code&gt;error:notsup&lt;/code&gt; in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">如果底层OpenSSL实现中没有引擎支持,它也可能抛出异常notsup。</target>
        </trans-unit>
        <trans-unit id="5c74c37a77d9015d8cc2cde873f1e045e8626043" translate="yes" xml:space="preserve">
          <source>It may be impossible to know what (buffer) size is appropriate &quot;in advance&quot;, and in those cases it may be convenient to use the (recv) 'peek' flag. When this flag is provided, the message is *not* &quot;consumed&quot; from the underlying buffers, so another recvfrom call is needed, possibly with a then adjusted buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e63fe0213f34cbbed25cc7230c36479fd2b05a" translate="yes" xml:space="preserve">
          <source>It may be impossible to know what (buffer) size is appropriate &quot;in advance&quot;, and in those cases it may be convenient to use the (recv) 'peek' flag. When this flag is provided, the message is *not* &quot;consumed&quot; from the underlying buffers, so another recvmsg call is needed, possibly with a then adjusted buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338543b46e123502d18dfc5bfc5fdece95d218e9" translate="yes" xml:space="preserve">
          <source>It may not be possible to specify the default protocol (except when &lt;code&gt;Domain = local&lt;/code&gt;). We need to be able to retreive the resulting protocol, which is &lt;strong&gt;not&lt;/strong&gt; possble on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">似乎在没有事先知道元素数量的情况下无法创建列表。但是确实有办法。请注意，列表 &lt;code&gt;[a, b, c]&lt;/code&gt; 可以写为 &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; b | c] 。[b | [c]]。使用此功能，可以将清单写为简略。</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">为了解决安全问题,可能需要引入不兼容的变更。这种不兼容的情况可能发生在补丁中。</target>
        </trans-unit>
        <trans-unit id="af545030bc117fe554dbe2f7c3a3a6a615e4f7eb" translate="yes" xml:space="preserve">
          <source>It might point to the &lt;code&gt;init&lt;/code&gt; process if the &lt;code&gt;Fun&lt;/code&gt; was statically allocated when module was loaded (this optimisation is performed for local functions that do not capture the environment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">进行两步升级而不是仅使用所有应用程序的新版本重新启动模拟器似乎很奇怪。做出此设计决定的原因是允许 &lt;code&gt;code_change&lt;/code&gt; 函数具有副作用，例如，更改磁盘上的数据。它还可以确保非核心应用程序的升级机制不会因核心应用程序是否同时更改而有所不同。</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">你写不写已经不重要了(从性能的角度看)。</target>
        </trans-unit>
        <trans-unit id="c324ea70f963f73142902d03499b65a1148202cb" translate="yes" xml:space="preserve">
          <source>It only makes sense to define external generic instructions in the file &lt;code&gt;genop.tab&lt;/code&gt; in &lt;code&gt;lib/compiler/src&lt;/code&gt;, because the compiler must know about them in order to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">它的作用如下:</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">它需要在配置文件中加入以下内容。</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">它返回通过对列表中的每个参数应用函数得到的列表。</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">除非评估期间发生异常 &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; 否则它将返回 &lt;code&gt;Exprs&lt;/code&gt; 的值（表达式序列Expr1，...，ExprN）。在这种情况下，将捕获 &lt;code&gt;ExceptionPattern&lt;/code&gt; ，并且将具有正确异常类 &lt;code&gt;Class&lt;/code&gt; 的ExceptionPattern模式与捕获的异常顺序匹配。如果匹配成功，并且可选的保护序列 &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; 为true，则将评估对应的 &lt;code&gt;ExceptionBody&lt;/code&gt; 以使其成为返回值。</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">它将 &lt;code&gt;io_reply&lt;/code&gt; 元组发送回客户端，提供请求中接收到的元素 &lt;code&gt;ReplyAs&lt;/code&gt; 以及请求的结果，如前所述。</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它将子模式设置为捕获子模式。也就是说，当完整模式匹配时，与子模式匹配的主题字符串部分将通过 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的返回值传递回调用方。</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">它启动跟踪服务器，然后设置适当的匹配规范（根据 &lt;code&gt;Level&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31112f0381a91b222a2817dba84ed1d667b040d2" translate="yes" xml:space="preserve">
          <source>It still works, but lacks for example I/O possibility. It is because of that compatibility we need the &lt;code&gt;{direct,...}&lt;/code&gt; construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">它采用32位salt值，并在 &lt;code&gt;0..2^32-1&lt;/code&gt; 内生成哈希值。</target>
        </trans-unit>
        <trans-unit id="c42cf0c4b44711bb956523450bfed3115cf1f7e2" translate="yes" xml:space="preserve">
          <source>It turned out that using the old api in the new way (more about that later), and still keep it backwards compatible, was not possible. Specially as more precision in the error messages is desired it could not be combined with the old standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">它只使用数字或位运算符。</target>
        </trans-unit>
        <trans-unit id="b267b9915cac30453e44b602e4b325db52e2a448" translate="yes" xml:space="preserve">
          <source>It would also be nice to get rid of the rwlock all together. The use of a reader optimized rwlock makes sure we do not any contention on the lock, but unnecessary memory barriers will be issued due to the lock. The main issue here is to modify iterating BIFs so that they do not require exclusive access to the table while reading a sequence of slots. In principle this should be rather easy, the code can handle sequences of variable sizes, so shrinking the sequence size of slots to one would solv the problem. This will, however, need some tweeks and modifications of not trival code, but is something that should be looked at in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2540fbabc3c9158380baa45f0c22de898b8d1e1" translate="yes" xml:space="preserve">
          <source>It would also be possible to define it like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">当此回复到达时，它会写上&amp;ldquo; Ping收到的Pong&amp;rdquo;，然后&amp;ldquo; ping&amp;rdquo; 再次调用 &lt;code&gt;ping&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">假定读者熟悉 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; 。为了能够修补应用程序，必须存在以下内容：</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">不过,它使用的是原生实现,不在堆上建立垃圾,性能稍好。</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">Item (?p{...})在运行时对Perl代码进行插值,在这种情况下,递归地引用它出现的模式。</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">可以使用功能 &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; &lt;strong&gt;同步&lt;/strong&gt;记录项目。对于这些功能中的每一个，调用者都将保持等待状态，直到记录项目为止（但不一定要写入，请使用 &lt;code&gt;sync/1&lt;/code&gt; 来确保）。通过为每个提及的函数名称添加 &lt;code&gt;a&lt;/code&gt; ，我们获得了&lt;strong&gt;异步&lt;/strong&gt;记录项目的函数。异步函数不等待磁盘日志过程将项目写入文件，而是将控件立即或多或少地返回给调用者。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">对当前存储的事件进行迭代。</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">对备份进行迭代,将其转换为新的备份,或读取它。这里简要解释了参数。详情请参见用户指南。</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">对当前存储的事件进行迭代,并对每个事件应用一个函数。迭代可以向前或向后进行,并且可以限制事件的最大数量(abs(Limit))。</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">遍历表 &lt;code&gt;Table&lt;/code&gt; 并为表中的每个 &lt;code&gt;Record&lt;/code&gt; 调用 &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; 。从 &lt;code&gt;Function&lt;/code&gt; 返回的术语在下一次调用 &lt;code&gt;Function&lt;/code&gt; 时用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">其语法如下:</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">它的值在遵守时可以评价为一个常数。</target>
        </trans-unit>
        <trans-unit id="1b9c42b14f3b80c83ccc522cfa693b39fd93fed6" translate="yes" xml:space="preserve">
          <source>JCL Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c706c391ec82badc3ec2e08de4f3bc19799ea82" translate="yes" xml:space="preserve">
          <source>JER encoding instructions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7e6a489b783443722628f1a5e368b35cd12558" translate="yes" xml:space="preserve">
          <source>JUMP(Fail)</source>
          <target state="translated">JUMP(Fail)</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">詹姆斯登录c2@kosken。</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">詹姆斯现在试图给弗雷德发信息。</target>
        </trans-unit>
        <trans-unit id="5e448215b22256e2517ad0fd1cc0140dc720a94f" translate="yes" xml:space="preserve">
          <source>Java JDK 8 or later (optional) If you don't care about Java, you can skip this step. The result will be that jinterface is not built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="9cdd767569c10e504770fd67a278cd9f65dc364a" translate="yes" xml:space="preserve">
          <source>Jinterface</source>
          <target state="translated">Jinterface</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-从Erlang/OTP R7B中移除。</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jive在Erlang程序和Java程序之间提供了一个简单的接口。</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">作业控制模式 &lt;code&gt;JCL&lt;/code&gt; ，可以在其中启动，终止，分离和连接作业</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">加入的规范共享通用的配置设置，例如 &lt;code&gt;config&lt;/code&gt; 文件列表或 &lt;code&gt;include&lt;/code&gt; 目录。对于无法组合的配置，例如 &lt;code&gt;logdir&lt;/code&gt; 或 &lt;code&gt;verbosity&lt;/code&gt; 的设置，由用户确保加入测试规范时不会发生冲突。 &lt;code&gt;separate&lt;/code&gt; 选项中包含的规范不与源规范共享配置设置。例如，这在包含的规范中配置配置冲突时很有用，使其无法加入。</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">将多个规格加入,或者分别运行,也可以通过(可以结合)测试规格文件的收录来实现。</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">用目录分隔符连接文件名 &lt;code&gt;Components&lt;/code&gt; 列表。如果 &lt;code&gt;Components&lt;/code&gt; 的元素之一包括绝对路径，例如 &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; ，则从结果中删除前面的元素（如果有）。</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">加入一个多播组。</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">加入具有相对文件名的绝对目录。与 &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; 相似，但在对原始文件名长度有严格限制且不支持符号链接的平台上（阅读：VxWorks）， &lt;code&gt;Filename&lt;/code&gt; 中的主要父目录组件与 &lt;code&gt;Dir&lt;/code&gt; 中的尾随目录组件匹配，因此可以从结果中删除它们。 -最小化其长度。</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">将单个注释行合并为多行注释。输入是代表条目的列表，&lt;strong&gt;以行号递减的顺序&lt;/strong&gt;表示各个注释行；有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; 。结果是代表&lt;strong&gt;多行&lt;/strong&gt;注释的条目列表，&lt;strong&gt;仍按行号递减的顺序列出&lt;/strong&gt;，但是对于每个条目， &lt;code&gt;Text&lt;/code&gt; 是按行号&lt;strong&gt;递增的&lt;/strong&gt;顺序排列的连续注释行的列表（即，自上而下）。</target>
        </trans-unit>
        <trans-unit id="3dc90045824109fca3c74e3c2dd79f512aa8ec0c" translate="yes" xml:space="preserve">
          <source>Joins single process or multiple processes to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">将调用线程与另一个线程连接起来，也就是说，调用线程被阻塞，直到由 &lt;code&gt;tid&lt;/code&gt; 标识的线程终止。</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">将进程 &lt;code&gt;Pid&lt;/code&gt; 加入到组 &lt;code&gt;Name&lt;/code&gt; 中。一个进程可以多次加入一个组，然后必须离开该组相同的次数。</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">用目录分隔符连接两个文件名组件。等效于 &lt;code&gt;join([Name1, Name2])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">跳转函数:相当于2^512次调用</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">跳转函数:相当于2^64次调用</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">运行 &lt;code&gt;configure&lt;/code&gt; 脚本时，只需在命令中添加 &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; 选项即可。如果使用的是systemtap，则configure选项为 &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b611320826148a6230c5ef2adb69785b7a7a9d7" translate="yes" xml:space="preserve">
          <source>Just as a demonstration, we can add a &lt;code&gt;-no_prefetch&lt;/code&gt; directive to the &lt;code&gt;move/2&lt;/code&gt; instruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">只需打印一个显示当前文件和行号的标记。请注意，这是一个无参数的宏。结果总是 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">保持活动状态（如果连接空闲，则每8秒向服务器发送一次NOP）= &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">请记住，外部命令高度依赖于操作系统。您可以在测试生成器函数中使用标准库函数 &lt;code&gt;os:type()&lt;/code&gt; ，以根据当前操作系统生成不同的测试集。</target>
        </trans-unit>
        <trans-unit id="45ee9466d0be93f29125686a1cbd9782282e5eb8" translate="yes" xml:space="preserve">
          <source>Keep in mind that if the underlying OS &lt;code&gt;connect()&lt;/code&gt; call returns a timeout, &lt;code&gt;gen_tcp:connect&lt;/code&gt; will also return a timeout (i.e. &lt;code&gt;{error, etimedout}&lt;/code&gt;), even if a larger &lt;code&gt;Timeout&lt;/code&gt; was specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">监测过程中要保持整洁,不要把系统监测限值设置得太紧。</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">保留一个索引表,在表中插入记录时,会引入一些开销。因此,必须将从表中获得的操作数与在表中插入对象的操作数进行比较。然而,注意到当键可以用来查找元素时,收益是显著的。</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">Kernel-运行Erlang所需的功能。</target>
        </trans-unit>
        <trans-unit id="9b311a97505939c000087e862d0f4deafba1fdc1" translate="yes" xml:space="preserve">
          <source>Key :: &lt;code&gt;&lt;a href=&quot;#type-key&quot;&gt;key()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7e1a7afd70468b58a6a45217a2e808010638f9" translate="yes" xml:space="preserve">
          <source>Key :: filter_default,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26dc0e44f1ced76088c1d761ea664fe885bc865e" translate="yes" xml:space="preserve">
          <source>Key :: term(),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">密钥 &lt;code&gt;mod&lt;/code&gt; 对于实现为监督树的应用程序是必需的，否则应用程序控制器不知道如何启动它。对于没有进程的应用程序，通常是代码库，例如STDLIB，可以省略 &lt;code&gt;mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6397ca66ce3b58cd7edcfd81299d71d5e083ac73" translate="yes" xml:space="preserve">
          <source>Key Equality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84946a9c6eeb1481d5b22997b26c2e0ed2cc12a" translate="yes" xml:space="preserve">
          <source>Key Exchange: ECDHE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6d5b439deefaa65c2dd5b4f472a6f796fb2c48" translate="yes" xml:space="preserve">
          <source>Key Share</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f470ba2d89f460de62ae07afdf74476dc26b66" translate="yes" xml:space="preserve">
          <source>Key and Initialization Vector Update is supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">交换钥匙;</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">密钥长度为128、192或256位</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">密钥长度为64位(在CBC模式下只使用8位)</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">线程特定数据可以关联的键。</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">键值字典为有序列表。</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">键值词典;</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="f317a3c39acb1917a8e35e2c694160ac8d4dee6b" translate="yes" xml:space="preserve">
          <source>Keys and files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">键和值之间用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 箭头分隔，关联之间用逗号 &lt;code&gt;,&lt;/code&gt; 。）分隔。</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">键是字符串，即以 &lt;code&gt;NULL&lt;/code&gt; 终止的字符数组，而值是任意对象。尽管注册表特别对待整数和浮点数，但是您可以将字符串或任何类型的二进制对象存储为指针。</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="f0368fc58ffcbb13dbf52da89366d4bc1cb1f40e" translate="yes" xml:space="preserve">
          <source>Kill EPMD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">切割线</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">杀死或暂停当前的外壳</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">杀死接收过程。</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">杀死运行 &lt;code&gt;epmd&lt;/code&gt; 如果只允许 &lt;code&gt;epmd -names&lt;/code&gt; 显示一个空数据库，或者 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 时的运行实例指定 &lt;code&gt;epmd&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">终止作业号 &lt;code&gt;nn&lt;/code&gt; 或当前作业。只要尚未评估 &lt;code&gt;group_leader/1&lt;/code&gt; BIF且位于本地计算机上，该作业中所有产生的进程都将被杀死。远程节点上产生的进程不会被杀死。</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">杀死当前正在运行的 &lt;code&gt;epmd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d077f8d3e486ad628e73d06261b975a13986914e" translate="yes" xml:space="preserve">
          <source>Knowing that an operand is not always used can improve how packing is done for some instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b4bd81f6a1807f205eb7b39db738fc67e5d76b" translate="yes" xml:space="preserve">
          <source>Known Hosts - OpenSSH Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0240977ffaeac0a7cbbd595196b651a1f287d553" translate="yes" xml:space="preserve">
          <source>Known Limitation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616ae0e516f073c066a59a8a38d5b52110f5407c" translate="yes" xml:space="preserve">
          <source>Known Limitations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">已知主机-OpenSSH格式如下:</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">已知问题。当一个节点以相同节点名多次重启时,在较新节点上创建的引用可能会被误认为是在较旧节点上创建的相同节点名的引用。</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">已知节点</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">LALR-1解析器生成器</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAP客户端</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST:用户空间追踪库。</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-tools:一个控制跟踪会话的命令行接口。</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">事件的标签(类型)。</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">标签旨在提供一个简短的事件摘要。</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">标记测试运行（类似于 &lt;code&gt;ct_run -label&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="043cffbb1435e33554384174474c4348b7979705" translate="yes" xml:space="preserve">
          <source>Labels each expression in the tree. A term &lt;code&gt;{label, L}&lt;/code&gt; is prefixed to the annotation list of each expression node, where L is a unique number for every node, except for variables (and function name variables) which get the same label if they represent the same variable. Constant literal nodes are not labeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">在OTP 21之前,标签被限制为小的有符号整数(28位)。如果跟踪令牌越过一个不支持标签的节点,它将被沉默地丢弃。</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">缺乏支持。如为HiPE编译模块加载NIF库。</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">不允许在匹配规范中使用诸如 &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 之类的语言构造。</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">在任何函数中都不考虑对输入的语言或语言环境的特定处理。</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">没有大写(或小写)概念的语言。</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">大文件支持</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">大型地图（&amp;gt; 32键）</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">大批量的日志事件--处理者在短时间内收到的许多事件--可能会造成潜在的问题,比如:。</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">大整数</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">大规模的自动化测试需要并行运行多个独立的测试会话。这可以通过在一个或多个主机上运行一些 &lt;code&gt;Common Test&lt;/code&gt; 节点，测试不同的目标系统来实现。独立配置，启动和控制测试节点可能是一项繁琐的操作。为了帮助进行这种自动化的大规模测试， &lt;code&gt;Common Test&lt;/code&gt; 提供了一个主测试节点组件 &lt;code&gt;Common Test&lt;/code&gt; Master，该组件在分布式 &lt;code&gt;Common Test&lt;/code&gt; 节点的系统中处理中央配置和控制。</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">较大的程序通常被写成一个文件的集合,各部分之间有一个明确的接口。</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">较大的测试用例在失败的情况下更难判断出了什么问题。另外,当错误发生时,大段的测试代码有可能被跳过。</target>
        </trans-unit>
        <trans-unit id="1b435236d148d33634d75be98a7f8ff0238652ce" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt; The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 64 MB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">最大（ &lt;code&gt;mseg_alloc&lt;/code&gt; ）多块载波大小（以千字节为单位）。请参阅 &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 部分中有关如何确定 &lt;code&gt;mseg_alloc&lt;/code&gt; 多块载波的大小的描述。在32位Unix风格的操作系统上，此限制不能设置为&amp;gt; 128 MB。</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start_link/4&lt;/code&gt; 的最后一个参数。</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">最后的交易ID:</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">最后,应用程序主程序终止。请注意,所有以应用主程序为组长的进程,即从属于应用的进程中产生的进程,也被终止。</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">后来,当你修复了应用程序my_app中的一个bug,你想更新PLT,使它在下次运行Dialyzer时变得新鲜。在这种情况下,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">在写文件之前,焦油成员名中的前导斜线将被删除。也就是说,绝对路径将变成相对路径。当以这种方式改变路径时,会有一条信息写入错误记录器。</target>
        </trans-unit>
        <trans-unit id="47b8a505fbd2560ad30175ab17add0932e2fcd2a" translate="yes" xml:space="preserve">
          <source>Leading zeroes are ignored. Single underscore &lt;code&gt;_&lt;/code&gt; can be inserted between digits as a visual separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e94aa1c6222c80f386ab41d6d2143723fd28ef" translate="yes" xml:space="preserve">
          <source>Leap Years</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">离开多播组。</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">留给用户阅读和解释记录的数据。该 &lt;code&gt;disk_log&lt;/code&gt; 模块不能修复外部格式化日志。</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leex将添加扩展 &lt;code&gt;.hrl&lt;/code&gt; 到 &lt;code&gt;Includefile&lt;/code&gt; 名和扩展名 &lt;code&gt;.erl&lt;/code&gt; 到 &lt;code&gt;Scannerfile&lt;/code&gt; 名称，除非扩展已经存在。</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">左联想</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容的原因，具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的旧版API函数 &lt;code&gt;process_msg/7&lt;/code&gt; 仍像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容的原因，具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的旧版API函数 &lt;code&gt;send_pdu/7&lt;/code&gt; 仍像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">旧版API函数 &lt;code&gt;add_addr/10&lt;/code&gt; (未指定传输域）以及具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的 &lt;code&gt;add_addr/11&lt;/code&gt; 仍然可以像往常一样工作，原因是向后兼容。</target>
        </trans-unit>
        <trans-unit id="2c597c4b003d18d8f6683d7d10d1da508314f6e0" translate="yes" xml:space="preserve">
          <source>Legacy Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">使用不带 &lt;code&gt;Domain&lt;/code&gt; 元素的元组以及所有 &lt;code&gt;TDomain&lt;/code&gt; ， &lt;code&gt;Ip&lt;/code&gt; 和 &lt;code&gt;Port&lt;/code&gt; 元素的旧配置仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">旧版网络接口筛选器模块使用 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 形式的参数代替 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ，如果运行SNMP代理而不更改配置以使用传输域，则使用网络接口筛选器仍然会得到旧的论点并像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">传统网络接口筛选器模块使用 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 形式的参数，而不是 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ，并且如果运行SNMP管理器而不更改配置以使用传输域，则网络接口筛选器仍然会得到旧的论点并像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">旧版通知传递信息接收器模块使用 &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; 而不是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 形式的目标参数，并且如果运行SNMP代理而不更改配置以使用传输域，则通知传递信息接收器仍将获得旧的论点，照旧工作。</target>
        </trans-unit>
        <trans-unit id="1e08ec2ca11598f98010b341769a06c738201d73" translate="yes" xml:space="preserve">
          <source>Legacy parts of erl_interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">遗留的解决方案最终可能需要取消。在这种情况下,它们将在足够长的时间内被逐步淘汰,以使用户有时间适应。在移除功能之前,至少会在一个版本中明确宣布即将移除的功能。新的弃用至少会在发行说明和文档中宣布。</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">CGI中使用的遗留字符串,忽略即可。</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">节点名称的长度</target>
        </trans-unit>
        <trans-unit id="d326c8e60791bd80c030a051ea704db236992dae" translate="yes" xml:space="preserve">
          <source>Length of command sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">低于</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">小于或等于</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">令 &lt;code&gt;SetOfSets&lt;/code&gt; 为一组集合，让 &lt;code&gt;BinRel&lt;/code&gt; 为二进制关系。每个元素映射函数 &lt;code&gt;Set&lt;/code&gt; 的 &lt;code&gt;SetOfSets&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 下 &lt;code&gt;BinRel&lt;/code&gt; 由以下函数返回：</target>
        </trans-unit>
        <trans-unit id="9f91f5a1240b87dec80e3e2107742012305cec9c" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created outside of a trace sequence. The counters are updated at the following occasions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">让每个进程都有两个计数器 &lt;code&gt;prev_cnt&lt;/code&gt; 和 &lt;code&gt;curr_cnt&lt;/code&gt; ，在创建进程时都将它们设置为 &lt;code&gt;0&lt;/code&gt; 。计数器在以下情况下更新：</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">让Megaco堆栈启动柔性扫描仪(加载驱动程序)。</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">让跟踪令牌的序列为 &lt;code&gt;tprev&lt;/code&gt; 和 &lt;code&gt;tcurr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">让此过程通过调用 &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; 函数启动Flex扫描器。</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">让我们(再次)打印城市列表中的温度。</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">我们假设有两台计算机,分别叫gollum和kosken。首先在kosken上启动一个节点,称为ping,然后在gollum上启动一个节点,称为pong。</target>
        </trans-unit>
        <trans-unit id="c3a7214e52200df1fa690005e2d061b16388a1ae" translate="yes" xml:space="preserve">
          <source>Let us break that apart into its components. First we have the distribution header tags together with the sequence id and a fragment id of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">让我们继续往下打印寻找。</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">让我们找到 &lt;code&gt;suspend&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">我们先来看看如何不做。</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">我们来看看运行后的打印结果。</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">让我们利用一些有趣的功能直接跳入深渊的例子。</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">让我们现在打电话。</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">现在让我们定义一个乐趣,可以用来通过一个城市和温度的列表,并将它们全部转化为摄氏度。</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">现在让我们回到测试代码。</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">现在，让我们使用这个重写乒乓球例子，有的名称 &lt;code&gt;pong&lt;/code&gt; 到&amp;ldquo;傍&amp;rdquo;的过程：</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">让我们回到信使程序,并添加修改,使其更加强大。</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">让我们再来看看上一节开头的例子。</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">让我们在不同的计算机上用&amp;ldquo; ping&amp;rdquo;和&amp;ldquo; pong&amp;rdquo;重写乒乓程序。首先，需要进行一些设置才能使其正常运行。分布式Erlang实现提供了非常基本的身份验证机制，以防止意外访问另一台计算机上的Erlang系统。互相交谈的Erlang系统必须具有相同的&lt;strong&gt;魔术cookie&lt;/strong&gt;。实现此目的最简单的方法是在要运行彼此通信的Erlang系统的所有计算机上的主目录中都有一个名为 &lt;code&gt;.erlang.cookie&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">让我们看看在 &lt;code&gt;convert&lt;/code&gt; 函数中输入 &lt;code&gt;centimeter&lt;/code&gt; 或 &lt;code&gt;inch&lt;/code&gt; 以外的值会发生什么：</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">让我们使用 &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 示例中描述的示例数据库 &lt;code&gt;Company&lt;/code&gt; 来说明如何在两个单独的节点 &lt;code&gt;a@gin&lt;/code&gt; 和 &lt;code&gt;b@skeppet&lt;/code&gt; 上运行数据库。在启动 &lt;code&gt;Mnesia&lt;/code&gt; 之前，这些节点中的每个节点都必须具有 &lt;code&gt;Mnesia&lt;/code&gt; 目录和已初始化的架构。有两种方法可以指定要使用的 &lt;code&gt;Mnesia&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">让关于未知函数和类型的警告影响命令行版本的退出状态。在设置退出状态时,默认是忽略关于未知函数和类型的警告。当使用来自Erlang的Dialyzer时,会返回关于未知函数和类型的警告,默认情况下是不返回这些警告。</target>
        </trans-unit>
        <trans-unit id="dd1ced138efad4a76a4f08aefdf9554dec9dccb1" translate="yes" xml:space="preserve">
          <source>Let's have a look at &lt;code&gt;ops.tab&lt;/code&gt; in &lt;code&gt;erts/emulator/beam&lt;/code&gt;, where the specific &lt;code&gt;move&lt;/code&gt; instructions are defined. Here are a few of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdf49f0f1855811dcea84430d7a6c47956fe46f" translate="yes" xml:space="preserve">
          <source>Let's look at an example that returns a tuple with the newly created data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def4ebac3d33eb1fabe588b9b1bb2ae738aa87c5" translate="yes" xml:space="preserve">
          <source>Let's say that we would like to create the following URI and send it over the network: &lt;code&gt;http://cities/&amp;ouml;rebro?foo bar&lt;/code&gt;. This is not a valid URI as it contains characters that are not allowed in a URI such as &quot;&amp;ouml;&quot; and the space. We can verify this by parsing the URI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240d62239f989fbc36c65942d5c7b38032446bb1" translate="yes" xml:space="preserve">
          <source>Let's start with what it is not. It is not the text that you type in the address bar in your Web browser. Web browsers do all possible heuristics to convert the input into a valid URI that could be sent over the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">让所有被跟踪的进程创建的进程继承跟踪进程的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">每当被跟踪的进程链接到 &lt;code&gt;P2&lt;/code&gt; 时，让另一个进程 &lt;code&gt;P2&lt;/code&gt; 继承被跟踪的进程的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">让我们来详细了解一下。</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">那我们走吧！我们将从安装程序的简短版本开始，然后是一些常见问题解答，然后我们将详细介绍安装程序。</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;epmd&lt;/code&gt; 的此实例仅侦听以逗号分隔的IP地址列表和回送地址（如果未指定，则隐式添加到列表中）。也可以使用环境变量 &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; 进行设置；请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;epmd&lt;/code&gt; 的该实例侦听默认值4369以外的另一个TCP端口。也可以使用环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 进行设置。请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">字号</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">字母和数字</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">模式中的字母与大写字母和小写字母都匹配。它等效于Perl选项 &lt;code&gt;/i&lt;/code&gt; ,并且可以通过 &lt;code&gt;(?i)&lt;/code&gt; 选项设置在模式内进行更改。大写和小写字母的定义与ISO 8859-1字符集相同。</target>
        </trans-unit>
        <trans-unit id="3e2aaf0fe96e43e92a68ce3b067fcb5b706d11e5" translate="yes" xml:space="preserve">
          <source>Level 0: Hard-coded default values in the source code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d72e5305a2d6c95e1ce5a0fdd176d060f6349de" translate="yes" xml:space="preserve">
          <source>Level 1: &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">第1级:函数头、保留字、注释、字符串、引用的原子和字符常量将被着色。</target>
        </trans-unit>
        <trans-unit id="06b1ca10283f0cd789d2a4ec53089eb86fe07e67" translate="yes" xml:space="preserve">
          <source>Level 2: Options in the &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;&lt;code&gt;server_options&lt;/code&gt; or &lt;code&gt;client_options&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">第2级:以上,属性、Erlang bif:s、guards以及注释中用单引号括起来的词都会被着色。</target>
        </trans-unit>
        <trans-unit id="005a74e908fba8ac913dab104358fa319caa3bd4" translate="yes" xml:space="preserve">
          <source>Level 3: Options in argument list to a function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">第3层:上面的,变量,记录,宏都会有颜色。这个级别也被称为圣诞树级别)。</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Erlang的词汇分析生成器</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="cf656455a0c076b572da9d3e79ba5760d2879b7c" translate="yes" xml:space="preserve">
          <source>Library Summary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">可以添加，编辑或删除库目录。这是通过选择显示库目录路径的行并单击鼠标右键来完成的。在弹出的菜单中选择添加，编辑或删除。通过选择&amp;ldquo; &lt;code&gt;Library directories&lt;/code&gt; &amp;rdquo;行并单击鼠标右键，也可以添加新的库目录。在弹出的菜单中选择添加。</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">处理二进制数据的库</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">用于处理二进制数据的库。</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">库模块--没有实现流程的模块的骨架。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">像 &lt;code&gt;#&lt;/code&gt; 一样，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 一样，但是列表从右到左遍历。</target>
        </trans-unit>
        <trans-unit id="32d5f6e565cfc3565274db933e070bbf6e2d1067" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2 &lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; ，但是解压缩没有更多的数据比将适合在通过被配置在缓冲 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; 。在对具有高压缩率的流进行解压缩时非常有用，这样少量的压缩输入可以扩展到1000倍。</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 一样，但是一旦它扩展到实现定义的较小阈值，它就会返回。当解压缩不受信任的输入时很有用，该输入可能被恶意制作以扩展直到系统用尽内存。</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; ，但仅插入顶级注释。函数定义或声明（&amp;ldquo;表单&amp;rdquo;）中的注释将被忽略。</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;@custom_types&lt;/code&gt; 类似,但要求指定的模块导出 &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; 而不是 &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">类似于 &lt;code&gt;B&lt;/code&gt; ，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">与 &lt;code&gt;B&lt;/code&gt; 相似，但使用以Erlang样式 &lt;code&gt;#&lt;/code&gt; 分隔的基本前缀打印数字。例：</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">类似于 &lt;code&gt;B&lt;/code&gt; ，但是使用一个额外的参数，该参数是要在数字之前但在前导破折号（如果有）之后插入的前缀。</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">类似于 &lt;code&gt;X&lt;/code&gt; ，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">像 &lt;code&gt;any&lt;/code&gt; 一样，但在有匹配项的第一个过滤器处停止，如果有多个对等项，效率会高得多。例如，以下过滤器将仅导致与主机过滤器和领域过滤器最匹配的对等设备。</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">类似于 &lt;code&gt;debugVal(Expr)&lt;/code&gt; ，但打印截断到给定深度的术语。</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">类似于 &lt;code&gt;lists:foldl/3&lt;/code&gt; ，但位于列表列表上方。</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">类似于 &lt;code&gt;lists:mapfoldl/3&lt;/code&gt; ，但位于列表列表上方。结果中的列表列表与给定的列表列表具有相同的结构。</target>
        </trans-unit>
        <trans-unit id="20cd10d2eeffd99802581dc74afe8402156d942f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;make_data/2&lt;/code&gt;, but analogous to &lt;code&gt;c_tuple_skel/1&lt;/code&gt; and &lt;code&gt;c_cons_skel/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa498794c1c7f5c1165baaba1370336976238c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;match/2&lt;/code&gt;, but matching a sequence of patterns against a sequence of expressions. Passing an empty list for &lt;code&gt;Exprs&lt;/code&gt; is equivalent to passing a list of &lt;code&gt;any&lt;/code&gt; atoms of the same length as &lt;code&gt;Patterns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">类似于 &lt;code&gt;new_variable_name/1&lt;/code&gt; ，但生成 &lt;code&gt;N&lt;/code&gt; 个新名称的列表。</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">类似于 &lt;code&gt;new_variable_name/2&lt;/code&gt; ，但生成 &lt;code&gt;N&lt;/code&gt; 个新名称的列表。</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">与 &lt;code&gt;notempty&lt;/code&gt; 相似，除了允许在主题的开头以外的空字符串匹配之外。如果模式已锚定，则只有模式包含\ K时，才可以进行这种匹配。</target>
        </trans-unit>
        <trans-unit id="34e86a0413da3932950dc47086d60ef92f88635d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;update_c_fname/3&lt;/code&gt;, but takes the arity from &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e166321bf0d2863d025505b2e22d21ed9895ce6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;variables/1&lt;/code&gt;, but only includes variables that are free in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">类似于 &lt;code&gt;{inparallel, Tests}&lt;/code&gt; ，但同时运行不超过 &lt;code&gt;N&lt;/code&gt; 个子测试。</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">类似于 &lt;code&gt;{spawn, Tests}&lt;/code&gt; ，但是在给定的Erlang节点上运行指定的测试。</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">就像端口程序一样，端口与Erlang进程通信。所有通信都通过一个Erlang进程进行，该&lt;strong&gt;进程&lt;/strong&gt;是端口驱动程序的&lt;strong&gt;连接进程&lt;/strong&gt;。终止此过程将关闭端口驱动程序。</target>
        </trans-unit>
        <trans-unit id="0f0b5ac5e9d7250099d7a631f9477dabbc5350f7" translate="yes" xml:space="preserve">
          <source>Like before, in the &lt;code&gt;Options&lt;/code&gt; parameter in the Erlang code in a call to for example &lt;code&gt;&lt;a href=&quot;ssh#daemon-3&quot;&gt;ssh:daemon/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; or any of their variants. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">像大多数 &lt;code&gt;gen_&lt;/code&gt; 行为一样， &lt;code&gt;gen_statem&lt;/code&gt; 除了状态外还保留服务器 &lt;code&gt;Data&lt;/code&gt; 。因此，由于对状态数量（假设有足够的虚拟机内存）或不同输入事件的数量没有限制，因此具有此行为的状态机实际上是图灵完成的。但是，感觉就像是事件驱动的Mealy机器。</target>
        </trans-unit>
        <trans-unit id="667e40cbed5b7781de3cc699e0b1ac1e4df6269e" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviours, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behaviour is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">和sub/2一样,但不会将模板的结果转换为树。如果你想进行多个独立的替换,这很有用。</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; 的宏，但除非返回的状态值是生成异常 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">和上面一样,如果您必须保持与UTAR兼容,您还必须确保符号/硬链接的路径不超过100字节,否则将使用PAX头。</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">同样，可以从 &lt;code&gt;Mnesia&lt;/code&gt; 表中还原注册表：</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">限制：命令字符串 &lt;code&gt;Cmd&lt;/code&gt; 以ISO Latin-1或UTF-8编码的二进制格式发送到 &lt;code&gt;heart&lt;/code&gt; 程序，具体取决于模拟器的文件名编码模式（请参阅 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; ）。编码二进制文件的大小必须小于2047字节。</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">将 &lt;code&gt;run/3&lt;/code&gt; 限制为在第一个匹配位置进行匹配。如果模式编译时 &lt;code&gt;anchored&lt;/code&gt; ，或变成了凭借其内容被锚定，因此不能进行未锚定在匹配时，因此不存在 &lt;code&gt;unanchored&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">将语法树限制为指定的深度。用 &lt;code&gt;Node&lt;/code&gt; 替换给定 &lt;code&gt;Depth&lt;/code&gt; 处 &lt;code&gt;Tree&lt;/code&gt; 中的所有非叶子子树。如果 &lt;code&gt;Depth&lt;/code&gt; 为负，则即使 &lt;code&gt;Tree&lt;/code&gt; 没有子树，结果也始终是 &lt;code&gt;Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">以特定于实现的方式限制匹配的执行时间和内存消耗，与 &lt;code&gt;match_limit&lt;/code&gt; 非常相似。PCRE文档对此进行了如下描述：</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">以特定的实现方式限制匹配的执行时间。PCRE文件对其描述如下:</target>
        </trans-unit>
        <trans-unit id="a4883e35292d9be4c86365cc67be55d00ec1e1e6" translate="yes" xml:space="preserve">
          <source>Limits the number of decentralized counter groups used by decentralized counters optimized for update operations in the Erlang runtime system. By default, the limit is 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">限制在Erlang运行时系统中为读操作优化的读/写锁所使用的读者组的数量。默认情况下,读取器组的限制是64个。</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">限制可以支持的同时请求数。默认值为 &lt;code&gt;150&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">限制HTTP请求URI的大小。默认值是没有限制。</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">限制HTTP请求的消息体的大小。默认值是没有限制。</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">限制HTTP请求的消息标头的大小。默认值是 &lt;code&gt;10240&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">限制客户在diffie-hellman-group-exchange中的要求。限制为 &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; ，其中 &lt;code&gt;MaxClient&lt;/code&gt; 和 &lt;code&gt;MinClient&lt;/code&gt; 是连接客户端建议的值。</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">第1行（用 &lt;code&gt;%% 1&lt;/code&gt; 注释标记）将 &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; 分配给 &lt;code&gt;Bin0&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">第2行是追加操作。由于 &lt;code&gt;Bin0&lt;/code&gt; 尚未参与追加操作，新的 &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; 被创建和内容 &lt;code&gt;Bin0&lt;/code&gt; 被复制到它。refc二进制文件的&lt;strong&gt;ProcBin&lt;/strong&gt;部分的大小设置为存储在二进制文件中的数据的大小，而二进制对象分配了额外的空间。二进制对象的大小是 &lt;code&gt;Bin1&lt;/code&gt; 或256 的大小的两倍，以较大者为准。在这种情况下为256。</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">第3行更有趣。 &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;已经&lt;/strong&gt;在附加操作中使用，并且它具有252个字节在末端未使用的存储空间，所以3个新字节被存储在那里。</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">第4行。这里也是如此。还剩249个字节,所以再存储3个字节没有问题。</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">第5行。在这里，发生了一些&lt;strong&gt;有趣的&lt;/strong&gt;事情。请注意，结果不追加到以前的结果 &lt;code&gt;Bin3&lt;/code&gt; ，但 &lt;code&gt;Bin1&lt;/code&gt; 。预期 &lt;code&gt;Bin4&lt;/code&gt; 赋值 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; 。还可以预期 &lt;code&gt;Bin3&lt;/code&gt; 将保留其值（ &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; ）。显然，运行时系统无法将字节 &lt;code&gt;17&lt;/code&gt; 写入二进制文件，因为这会将 &lt;code&gt;Bin3&lt;/code&gt; 的值更改为 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d96d415e109919c75164ce4c11337300d5c505" translate="yes" xml:space="preserve">
          <source>Line Breakpoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">线路供给</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">线路馈电(LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">线路输入(十六进制0A)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">分线器</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">包含注释的行根据使用的%字符数不同而缩进。</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">带有一个％字符的行在代码的右侧缩进。该列由变量 &lt;code&gt;comment-column&lt;/code&gt; 指定，默认情况下使用列48。</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">有三个以上%字符的行会缩进到左边的空白处。</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">有两个%字符的行将被缩进到与代码在相同情况下的深度。</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">Linked-in驱动涉及到用C语言编写一定的回调函数,这需要很好的技术,因为代码是和Erlang运行时系统链接的。</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">链接代码。</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">链接是双向的，两个进程之间只能有一个链接。重复调用 &lt;code&gt;link(Pid)&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">链接用于监视其他进程的行为，请参阅 &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">支持Linux(Aurora)。</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">支持Linux(黄狗)和OS X 10.4。</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (需要2.6.15-2054或更新的内核)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">支持UTRACE的Linux内核</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">支持Linux。</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">通过SystemTap兼容Linux。请参阅 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; 了解更多详细信息。</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">支持Linux。支持Fedora Core。支持32位和64位模式。</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="cd35517590c8ba62aaafca822f31e45849fd7931" translate="yes" xml:space="preserve">
          <source>List Reports in Server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84478621597e3250b6410dcf31b2c7f5cfa01376" translate="yes" xml:space="preserve">
          <source>List all engines currently loaded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e20fcd0dc8894a575034d1d37150331fce67f9a" translate="yes" xml:space="preserve">
          <source>List all notification filters in an agent.</source>
          <target state="translated">列出代理中的所有通知过滤器。</target>
        </trans-unit>
        <trans-unit id="433e9558c472f250dda9655b9de01d8c5b1cbc95" translate="yes" xml:space="preserve">
          <source>List comprehensions are analogous to set comprehensions in Zermelo-Frankel set theory and are called ZF expressions in Miranda. They are analogous to the &lt;code&gt;setof&lt;/code&gt; and &lt;code&gt;findall&lt;/code&gt; predicates in Prolog.</source>
          <target state="translated">列表推导类似于Zermelo-Frankel集合论中的集合推导，在Miranda中称为ZF表达式。它们类似于Prolog中的 &lt;code&gt;setof&lt;/code&gt; 和 &lt;code&gt;findall&lt;/code&gt; 谓词。</target>
        </trans-unit>
        <trans-unit id="493415e452a1ca58d7ab0e55c11450201b1caf07" translate="yes" xml:space="preserve">
          <source>List comprehensions are written with the following syntax:</source>
          <target state="translated">列表理解的写法如下语法。</target>
        </trans-unit>
        <trans-unit id="f643c07aa2da6eaa1122e1bfdb07a56a6d60470e" translate="yes" xml:space="preserve">
          <source>List comprehensions is a feature of many modern functional programming languages. Subject to certain rules, they provide a succinct notation for generating elements in a list.</source>
          <target state="translated">列表理解是许多现代函数式编程语言的一个特点。根据一定的规则,它们为生成列表中的元素提供了一个简洁的符号。</target>
        </trans-unit>
        <trans-unit id="c0adcf806e6c6cb4dd52f21d37c6386d7fc26ec4" translate="yes" xml:space="preserve">
          <source>List comprehensions used to be implemented using funs, and in the old days funs were indeed slow.</source>
          <target state="translated">列表理解以前是用funs实现的,以前的funs确实很慢。</target>
        </trans-unit>
        <trans-unit id="6a97adf09881d30899eb88074972670e34c92836" translate="yes" xml:space="preserve">
          <source>List comprehensions with low-level &lt;code&gt;Mnesia&lt;/code&gt; functions can be combined in the same transaction. To raise the salary of all female employees, execute the following:</source>
          <target state="translated">具有低级 &lt;code&gt;Mnesia&lt;/code&gt; 功能的列表理解可以合并到同一事务中。要提高所有女性雇员的工资，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="49eee1559f1ee0d2b82c81d4f588a2ed770857f0" translate="yes" xml:space="preserve">
          <source>List comprehensions.</source>
          <target state="translated">列举理解。</target>
        </trans-unit>
        <trans-unit id="05e97a2b6e38fea3735726e5819ee8ba95e83bc5" translate="yes" xml:space="preserve">
          <source>List elements are the UTF-8 encodings of the individual characters in the string. Invalid codepoints will result in encode/decode failure. On encode, a UTF8String() can be specified as a binary, or as a nested list of binaries and codepoints.</source>
          <target state="translated">列表元素是字符串中单个字符的UTF-8编码。无效的编码点将导致编码/解码失败。在编码时,一个UTF8String()可以被指定为一个二进制,或者是一个二进制和编码点的嵌套列表。</target>
        </trans-unit>
        <trans-unit id="278d3b4f4ee0740a1de4cdf1bd2bf93be61d3954" translate="yes" xml:space="preserve">
          <source>List of algorithms to use in the algorithm negotiation. The default &lt;code&gt;algs_list()&lt;/code&gt; can be obtained from &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在算法协商中使用的算法列表。可以从 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt; 获得默认的 &lt;code&gt;algs_list()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9db4243408e7145f00857f4260325dcb24458c15" translate="yes" xml:space="preserve">
          <source>List of extra arguments to the user callback functions. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">用户回调函数的额外参数列表。更多信息请参见megaco_user的参考手册。</target>
        </trans-unit>
        <trans-unit id="46ea5ca4efb80ab899337d420e90c90285a406b1" translate="yes" xml:space="preserve">
          <source>List of protocols to send to the client if the client indicates that it supports the Next Protocol extension. The client can select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol, it can be accessed using the &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; method.</source>
          <target state="translated">如果客户端指示它支持下一协议扩展，则发送给客户端的协议列表。客户端可以选择不在此列表上的协议。协议列表不得包含空二进制文件。如果服务器协商下一个协议，则可以使用 &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; 方法对其进行访问。</target>
        </trans-unit>
        <trans-unit id="98e5b6b3bdd287b5c011c0b0403e09b9164fe07d" translate="yes" xml:space="preserve">
          <source>List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant URI (&lt;strong&gt;percent-encoded form&lt;/strong&gt;). A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters.</source>
          <target state="translated">Unicode编码点列表，UTF-8编码的二进制或两者的混合，代表 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 兼容URI（&lt;strong&gt;百分比编码形式&lt;/strong&gt;）。URI是一组非常有限的字符序列：基本拉丁字母的字母，数字和一些特殊字符。</target>
        </trans-unit>
        <trans-unit id="d93d5d53babf56ebe1e390ba9a950fbf91d0cb2b" translate="yes" xml:space="preserve">
          <source>List of user (client) public key algorithms to try to use.</source>
          <target state="translated">要尝试使用的用户(客户端)公钥算法列表。</target>
        </trans-unit>
        <trans-unit id="cc9f7cb6591bec743e823fe706dead283d4905b5" translate="yes" xml:space="preserve">
          <source>List of variable bindings in the shell environment.</source>
          <target state="translated">shell环境中的变量绑定列表。</target>
        </trans-unit>
        <trans-unit id="f80b12db0f84fe26ec9bd3ed10dcbee12e085184" translate="yes" xml:space="preserve">
          <source>List processing</source>
          <target state="translated">名单处理</target>
        </trans-unit>
        <trans-unit id="8b3923bc8621a43a87bb226f3d90850a4f20ee30" translate="yes" xml:space="preserve">
          <source>List processing functions.</source>
          <target state="translated">列表处理功能。</target>
        </trans-unit>
        <trans-unit id="6345849796c275ff0cae0a5e12aa669943d6685e" translate="yes" xml:space="preserve">
          <source>List subtraction used to have a run-time complexity proportional to the product of the length of its operands, so it was extremely slow when both lists were long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53479af7c4b258e47635cf3f831bd457573f3848" translate="yes" xml:space="preserve">
          <source>List the id's of all engines in OpenSSL's internal list.</source>
          <target state="translated">列出OpenSSL内部列表中所有引擎的id。</target>
        </trans-unit>
        <trans-unit id="360c1be474e03a75dfed0b0aac585b7b6b77ea1d" translate="yes" xml:space="preserve">
          <source>Listen for connections on a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cf5c534cf79a3ef7abbfc9f78dcce0140e6482" translate="yes" xml:space="preserve">
          <source>Listing without class combiner.</source>
          <target state="translated">没有类组合器的列表。</target>
        </trans-unit>
        <trans-unit id="9d1f72a30a3a6c56319d5de301e7dcd8d4ea9184" translate="yes" xml:space="preserve">
          <source>Lists all TCP, UDP and SCTP sockets, including those that the Erlang runtime system uses as well as those created by the application.</source>
          <target state="translated">列出所有TCP、UDP和SCTP套接字,包括Erlang运行时系统使用的套接字和应用程序创建的套接字。</target>
        </trans-unit>
        <trans-unit id="4337868b9d860ba3caf101beb26d92ab8c3abdd4" translate="yes" xml:space="preserve">
          <source>Lists all active connections for this user. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">列出该用户的所有活动连接。返回megaco_conn_handle记录的列表。</target>
        </trans-unit>
        <trans-unit id="2714b113edcc2a65636a1ec94ae0d858a92ee520" translate="yes" xml:space="preserve">
          <source>Lists all active connections. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">列出所有活动的连接。返回megaco_conn_handle记录的列表。</target>
        </trans-unit>
        <trans-unit id="c14044ad12ace6bccaea0455b877c42c13dc64aa" translate="yes" xml:space="preserve">
          <source>Lists all active users. Returns a list of megaco_mid()'s.</source>
          <target state="translated">列出所有活跃用户。返回megaco_mid()的列表。</target>
        </trans-unit>
        <trans-unit id="09883357a748a23703460bb6b31f36dc6eb24786" translate="yes" xml:space="preserve">
          <source>Lists all available start flags.</source>
          <target state="translated">列出所有可用的起始标志。</target>
        </trans-unit>
        <trans-unit id="4edfc25b8c7646b4111ec287d11e328fd05b2ca3" translate="yes" xml:space="preserve">
          <source>Lists all entries in the specified configuration file.</source>
          <target state="translated">列出指定配置文件中的所有条目。</target>
        </trans-unit>
        <trans-unit id="2c53d0f7e8e7f87d95870b0e5dd392fdbd1aed3a" translate="yes" xml:space="preserve">
          <source>Lists all files in a directory, &lt;strong&gt;except&lt;/strong&gt; files with raw filenames. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件，带有原始文件名的文件&lt;strong&gt;除外&lt;/strong&gt;。如果成功，则返回 &lt;code&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="e14a213355b4d17f65990a6133f694eb009717fd" translate="yes" xml:space="preserve">
          <source>Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.</source>
          <target state="translated">列出所有工作。打印所有已知作业的列表。当前的作业名称前有'*'。</target>
        </trans-unit>
        <trans-unit id="d449a2e13ab08f8d884a484f2a845df785c5c0f1" translate="yes" xml:space="preserve">
          <source>Lists all modified modules. Shorthand for &lt;code&gt;code:modified_modules/0&lt;/code&gt;.</source>
          <target state="translated">列出所有修改的模块。 &lt;code&gt;code:modified_modules/0&lt;/code&gt; 简写：modified_modules / 0。</target>
        </trans-unit>
        <trans-unit id="8a4773cfa062c5fb572736024d216eb9e4b59ec0" translate="yes" xml:space="preserve">
          <source>Lists all possible cipher suites corresponding to &lt;code&gt;Description&lt;/code&gt; that are available. The &lt;code&gt;exclusive&lt;/code&gt; option will exclusively list cipher suites introduced in &lt;code&gt;Version&lt;/code&gt; whereas the the other options are inclusive from the lowest possible version to &lt;code&gt;Version&lt;/code&gt;. The &lt;code&gt;all&lt;/code&gt; options includes all suites except the anonymous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e08270ad4d1c057bd6013ee9f18877c27d91e14" translate="yes" xml:space="preserve">
          <source>Lists all reports loaded in &lt;code&gt;rb_server&lt;/code&gt;. Each report is given a unique number that can be used as a reference to the report in function &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出加载在 &lt;code&gt;rb_server&lt;/code&gt; 中的所有报告。每个报告都有一个唯一的编号，可以在 &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt; 函数中用作对该报告的引用。</target>
        </trans-unit>
        <trans-unit id="3d585b5f080c2320d84337d311297ce3312051fb" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory, including files with raw filenames. Returns &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件，包括带有原始文件名的文件。如果成功，则返回 &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="02f72b758a50a88ea9e456ce7bb76a0ffe8cb08d" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件。如果成功，则返回 &lt;code&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;error&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="4410d2b8ea4abd8b562807aff638f01d51fdbe5b" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element. Tuples are ordered by size, two tuples with the same size are compared element by element.</source>
          <target state="translated">列表是按元素进行比较的。图元组按大小排序,两个大小相同的图元组按元素进行比较。</target>
        </trans-unit>
        <trans-unit id="aaaad5080a7d5e7990259ba71c1c2a741010f595" translate="yes" xml:space="preserve">
          <source>Lists can only be built starting from the end and attaching list elements at the beginning. If you use the &quot;&lt;code&gt;++&lt;/code&gt;&quot; operator as follows, a new list is created that is a copy of the elements in &lt;code&gt;List1&lt;/code&gt;, followed by &lt;code&gt;List2&lt;/code&gt;:</source>
          <target state="translated">只能从末尾开始构建列表，并在开头附加列表元素。如果按如下方式使用&amp;ldquo; &lt;code&gt;++&lt;/code&gt; &amp;rdquo;运算符，则会创建一个新列表，该列表是 &lt;code&gt;List1&lt;/code&gt; 中元素的副本，后跟 &lt;code&gt;List2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4926eced8ea62bd521cb340059a74702d8b7f96d" translate="yes" xml:space="preserve">
          <source>Lists comprehensions still have a reputation for being slow. They used to be implemented using funs, which used to be slow.</source>
          <target state="translated">Lists comprehensions仍然以慢著称。它们过去是用funs实现的,而funs过去是很慢的。</target>
        </trans-unit>
        <trans-unit id="813529648a19db76d9b2436854b7d6cbfd832327" translate="yes" xml:space="preserve">
          <source>Lists directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">列出目录 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7ad6d844316d235b7276ea8fedc7b6ce5feb6d2" translate="yes" xml:space="preserve">
          <source>Lists files in directory &lt;code&gt;Dir&lt;/code&gt; or, if &lt;code&gt;Dir&lt;/code&gt; is a file, only lists it.</source>
          <target state="translated">列出目录 &lt;code&gt;Dir&lt;/code&gt; 中的文件，或者如果 &lt;code&gt;Dir&lt;/code&gt; 是文件，则仅列出它。</target>
        </trans-unit>
        <trans-unit id="89af84891678e7a6adbb862fe15a05f7928921ee" translate="yes" xml:space="preserve">
          <source>Lists files in the current directory.</source>
          <target state="translated">列出当前目录下的文件。</target>
        </trans-unit>
        <trans-unit id="a526e66bff6fcc167e33e50709753226df32d0ad" translate="yes" xml:space="preserve">
          <source>Lists information, mainly concerning TLS/DTLS versions, in runtime for debugging and testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58c2a350f07347551b9f3634b864bd30234359c" translate="yes" xml:space="preserve">
          <source>Lists names registered with the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">列出在当前运行的 &lt;code&gt;epmd&lt;/code&gt; 中注册的名称。</target>
        </trans-unit>
        <trans-unit id="db086781259aaadaaf44b182603d38e68f16fda8" translate="yes" xml:space="preserve">
          <source>Lists of UTF-8 Bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d04787e574b0b36059101cd1aba185b5fe294f5" translate="yes" xml:space="preserve">
          <source>Lists the given directory on the server, returning the filenames as a list of strings.</source>
          <target state="translated">列出服务器上给定的目录,以字符串列表的形式返回文件名。</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="4dca4b373f502fbb16dccc9e0b7237d86410b372" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;Mibs&lt;/code&gt; into an agent. If the agent cannot load all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where loading was aborted. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">将 &lt;code&gt;Mibs&lt;/code&gt; 装入代理。如果代理无法加载所有MIB（ &lt;code&gt;Force&lt;/code&gt; 参数的默认值为 &lt;code&gt;false&lt;/code&gt; ），它将指示加载在何处中止。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如，</target>
        </trans-unit>
        <trans-unit id="9eb24b588b22c0b9641d19a0eb23be1ce0fbc392" translate="yes" xml:space="preserve">
          <source>Load Balancing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d7f412fb063f70b02868e384179ef9d1b1a087" translate="yes" xml:space="preserve">
          <source>Load a &lt;code&gt;Mib&lt;/code&gt; into the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">将 &lt;code&gt;Mib&lt;/code&gt; 加载到管理器中。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如，</target>
        </trans-unit>
        <trans-unit id="b3e3360ea19707f02f4a020e3f19c3e4bc8449f2" translate="yes" xml:space="preserve">
          <source>Load a crypto engine, should be done once per engine used. For example dynamically load the engine called &lt;code&gt;MyEngine&lt;/code&gt;:</source>
          <target state="translated">加载加密引擎，每个引擎应执行一次。例如，动态加载名为 &lt;code&gt;MyEngine&lt;/code&gt; 的引擎：</target>
        </trans-unit>
        <trans-unit id="8a579cb5ea4d299e98f6e3305e729a2e2691eb3c" translate="yes" xml:space="preserve">
          <source>Load a single &lt;code&gt;Mib&lt;/code&gt; into an agent. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example:</source>
          <target state="translated">将单个 &lt;code&gt;Mib&lt;/code&gt; 加载到代理中。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如：</target>
        </trans-unit>
        <trans-unit id="977a17eb3484eaefc96c3c23206f0b5245055b6b" translate="yes" xml:space="preserve">
          <source>Load an engine and replace some methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715502f398ccdfa0aa43a432af1ca13d1b7adbea" translate="yes" xml:space="preserve">
          <source>Load an engine with the dynamic engine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51c159c86fd747d2e5230014dcc8e2ec41e6224" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine and just replace some engine methods.</source>
          <target state="translated">在动态引擎的帮助下加载一个引擎,只需替换一些引擎方法即可。</target>
        </trans-unit>
        <trans-unit id="4c42d226cb6d70b946e6d5b82bc4c3543f9c44ef" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine by giving the path to the library.</source>
          <target state="translated">在动态引擎的帮助下,通过给出库的路径来加载一个引擎。</target>
        </trans-unit>
        <trans-unit id="32bc843d0b756c56e85673fa55374b9397575f9a" translate="yes" xml:space="preserve">
          <source>Load distribution facility.</source>
          <target state="translated">负荷分配设施。</target>
        </trans-unit>
        <trans-unit id="76bad6da55b53cc690e8073bcd70b2d51d7df367" translate="yes" xml:space="preserve">
          <source>Load mode. Loads all recompiled modules.</source>
          <target state="translated">加载模式。加载所有重新编译的模块。</target>
        </trans-unit>
        <trans-unit id="2cccf6ad0728e7b357295554e6d28b49c3a4a67a" translate="yes" xml:space="preserve">
          <source>Load raw Erlang trace from a file, port or process.</source>
          <target state="translated">从文件、端口或进程加载原始 Erlang 跟踪。</target>
        </trans-unit>
        <trans-unit id="9270554fc2af7c0fd3400f7998148c1961fce683" translate="yes" xml:space="preserve">
          <source>Load the &lt;code&gt;dyntrace&lt;/code&gt; module.</source>
          <target state="translated">加载 &lt;code&gt;dyntrace&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="c237f6e4c5365a30ac145a8b509d8e8b9dd96a4d" translate="yes" xml:space="preserve">
          <source>Load the compiled MIB into the agent.</source>
          <target state="translated">将编译后的MIB加载到代理中。</target>
        </trans-unit>
        <trans-unit id="20c1d6dc95e25c92e1610b1211f7233c890d0b64" translate="yes" xml:space="preserve">
          <source>Load the event table from a file.</source>
          <target state="translated">从文件中加载事件表。</target>
        </trans-unit>
        <trans-unit id="a92787cc36930707fbb75a6d9a3de46ba71425a8" translate="yes" xml:space="preserve">
          <source>Load the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument into the mib-server. The &lt;code&gt;MeOverride&lt;/code&gt; and &lt;code&gt;TeOverride&lt;/code&gt; arguments specifies how the mib-server shall handle duplicate mib- and trap- entries.</source>
          <target state="translated">将 &lt;code&gt;Filename&lt;/code&gt; 参数指定的mib加载到mib服务器中。该 &lt;code&gt;MeOverride&lt;/code&gt; 和 &lt;code&gt;TeOverride&lt;/code&gt; 参数指定MIB-服务器应如何处理重复的MIB-和TRAP-条目。</target>
        </trans-unit>
        <trans-unit id="b2d3b1b2db0276aeeaa93c9149c9814e0ffe32aa" translate="yes" xml:space="preserve">
          <source>Load with the ensure loaded function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffabdc1b0aada0df09c6b33e94264210e3036668" translate="yes" xml:space="preserve">
          <source>Loading and Unloading of OTP-OS-MON-MIB</source>
          <target state="translated">OTP-OS-MON-MIB的加载和卸载。</target>
        </trans-unit>
        <trans-unit id="59f753c4a89d6cb4b2fbf224764ebcc567bab7f3" translate="yes" xml:space="preserve">
          <source>Loading and unloading of MIBs are quite cheap operations. However, if the application does this very often, perhaps several times per minute, it should load the MIBs once and for all in a sub-agent. This sub-agent only registers and unregisters itself under another agent instead of loading the MIBs each time. This is cheaper than loading an MIB.</source>
          <target state="translated">MIB的加载和卸载是相当便宜的操作。然而,如果应用程序经常这样做,也许每分钟要做几次,它应该在一个子代理中一次性加载MIB。这个子代理只在另一个代理下注册和解注册自己,而不是每次都加载MIBs。这比加载一个MIB要便宜。</target>
        </trans-unit>
        <trans-unit id="4bbdf176626164bdc51fe89c8ab7ac24003faec2" translate="yes" xml:space="preserve">
          <source>Loading can fail for one the following reasons:</source>
          <target state="translated">加载失败的原因有以下几种:</target>
        </trans-unit>
        <trans-unit id="4410a62a4b26f67ed425ab03e6b26d834ab6061b" translate="yes" xml:space="preserve">
          <source>Loading of Code From Archive Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b4c7383cbd28718a91c4b0a187d7de34640193" translate="yes" xml:space="preserve">
          <source>Loading on previous releases is &lt;strong&gt;not&lt;/strong&gt; supported.</source>
          <target state="translated">&lt;strong&gt;不&lt;/strong&gt;支持在以前的版本中加载。</target>
        </trans-unit>
        <trans-unit id="b3ddb8527fe2c15b0846a1df5469d7936b6ac994" translate="yes" xml:space="preserve">
          <source>Loading tables at startup</source>
          <target state="translated">启动时加载表格</target>
        </trans-unit>
        <trans-unit id="262bab97e2113ec92485a2a01d5cabfcd110e445" translate="yes" xml:space="preserve">
          <source>Loading the NIF library overrides the stub implementations and cause calls to &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; to be dispatched to the NIF implementations instead.</source>
          <target state="translated">加载NIF库会覆盖存根实现，并导致对 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 的调用被分派到NIF实现。</target>
        </trans-unit>
        <trans-unit id="766009fe24c4fa886de18bd755755efdbd37a7b5" translate="yes" xml:space="preserve">
          <source>Loading/unloading an application does not load/unload the code used by the application. Code loading is done the usual way.</source>
          <target state="translated">加载/卸载应用程序不会加载/卸载应用程序使用的代码。代码加载是以通常的方式进行的。</target>
        </trans-unit>
        <trans-unit id="595a176aa31ecdb076d6a4fbcfdce5bb9c525cbc" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;Module&lt;/code&gt; on all nodes.</source>
          <target state="translated">在所有节点上加载 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ffc53d4569575bdb25ef1541658266ca11f4420" translate="yes" xml:space="preserve">
          <source>Loads a new module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">加载新模块 &lt;code&gt;Mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="663b889f55fd7cc7ec3d743d418d4fed670a69b0" translate="yes" xml:space="preserve">
          <source>Loads a series of definitions and data found in the text file (generated with &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt;) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</source>
          <target state="translated">将在文本文件（使用 &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt; 生成）中找到的一系列定义和数据加载到Mnesia中。此功能还会启动Mnesia，并可能创建一个新的架构。此功能仅用于教育目的。建议使用其他功能来处理实际备份。</target>
        </trans-unit>
        <trans-unit id="5b69f0a046ca1124c0aebf63391cf8345c5a3dd5" translate="yes" xml:space="preserve">
          <source>Loads and links a dynamic library containing native implemented functions (NIFs) for a module. &lt;code&gt;Path&lt;/code&gt; is a file path to the shareable object/dynamic library file minus the OS-dependent file extension (&lt;code&gt;.so&lt;/code&gt; for Unix and &lt;code&gt;.dll&lt;/code&gt; for Windows). Notice that on most OSs the library has to have a different name on disc when an upgrade of the nif is done. If the name is the same, but the contents differ, the old library may be loaded instead. For information on how to implement a NIF library, see &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">加载并链接包含一个模块的本机实现功能（NIF）的动态库。 &lt;code&gt;Path&lt;/code&gt; 是可共享对象/动态库文件的文件路径，减去操作系统相关的文件扩展名（对于Unix是 &lt;code&gt;.so&lt;/code&gt; ，对于Windows是 &lt;code&gt;.dll&lt;/code&gt; ）。请注意，在大多数操作系统上，完成nif升级后，该库在磁盘上的名称必须不同。如果名称相同，但内容不同，则可以加载旧库。有关如何实现NIF库的信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82f1623ae8a87546c7dd248aabd05fecaf6a3b4a" translate="yes" xml:space="preserve">
          <source>Loads and links the dynamic driver &lt;code&gt;Name&lt;/code&gt;. &lt;code&gt;Path&lt;/code&gt; is a file path to the directory containing the driver. &lt;code&gt;Name&lt;/code&gt; must be a sharable object/dynamic library. Two drivers with different &lt;code&gt;Path&lt;/code&gt; parameters cannot be loaded under the same name. &lt;code&gt;Name&lt;/code&gt; is a string or atom containing at least one character.</source>
          <target state="translated">加载并链接动态驱动程序 &lt;code&gt;Name&lt;/code&gt; 。 &lt;code&gt;Path&lt;/code&gt; 是包含驱动程序的目录的文件路径。 &lt;code&gt;Name&lt;/code&gt; 必须是可共享的对象/动态库。无法使用相同的名称加载具有不同 &lt;code&gt;Path&lt;/code&gt; 参数的两个驱动程序。 &lt;code&gt;Name&lt;/code&gt; 是包含至少一个字符的字符串或原子。</target>
        </trans-unit>
        <trans-unit id="a9103067a9d66d079fdfa3978fe03390b072c888" translate="yes" xml:space="preserve">
          <source>Loads configuration variables using the specified callback module and configuration string. The callback module is to be either loaded or present in the code part. Loaded configuration variables can later be removed using function &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用指定的回调模块和配置字符串加载配置变量。回调模块将被加载或存在于代码部分中。稍后可以使用功能 &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt; 删除已加载的配置变量。</target>
        </trans-unit>
        <trans-unit id="92030378678e8bb7a8c82cb9b51ba59dd5bd9509" translate="yes" xml:space="preserve">
          <source>Loads the MIBs into agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">将MIB加载到代理 &lt;code&gt;snmp_master_agent&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4dbafa4e360e2579c05082b7f407c76430fb3b56" translate="yes" xml:space="preserve">
          <source>Loads the OTP-MIB.</source>
          <target state="translated">加载OTP-MIB。</target>
        </trans-unit>
        <trans-unit id="309db15774fbe5a771972504b9f3ef690359b4c3" translate="yes" xml:space="preserve">
          <source>Loads the OTP-OS-MON-MIB.</source>
          <target state="translated">加载OTP-OS-MON-MIB。</target>
        </trans-unit>
        <trans-unit id="f34f8f079029d395543bcd8071ed78fa06f88866" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; and the path to the dynamic library implementing the engine. This function differs from the normal engine_load in that sense it also add the engine id to the internal list in OpenSSL. Then in the following calls to the function it just fetch the reference to the engine instead of loading it again. An error tuple is returned if the engine can't be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790d91314c3d136e8ec61f0c269f44b4dbdfc75f" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; and the path to the dynamic library implementing the engine. This function is the same as calling &lt;code&gt;ensure_engine_loaded/3&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294bfed427ce1e4aaf41a120556a07d884c20438" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">加载由 &lt;code&gt;EngineId&lt;/code&gt; 提供的OpenSSL引擎（如果可用），然后返回ok和引擎句柄。如果无法加载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="19c49f3d4456a895329c5795a2a2e050a1652c20" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. This function is the same as calling &lt;code&gt;engine_load/4&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">加载由 &lt;code&gt;EngineId&lt;/code&gt; 提供的OpenSSL引擎（如果可用），然后返回ok和引擎句柄。此功能与调用 &lt;code&gt;engine_load/4&lt;/code&gt; 与 &lt;code&gt;EngineMethods&lt;/code&gt; 设置为所有可能的方法的列表。如果无法加载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="40397b451950fbe4fa114fa0103e62e80e7fa347" translate="yes" xml:space="preserve">
          <source>Loads the application specification for an application into the application controller. It also loads the application specifications for any included applications. Notice that the function does not load the Erlang object code.</source>
          <target state="translated">将应用程序的应用程序规范加载到应用程序控制器中。它也加载任何包含的应用程序的应用程序规范。请注意,该函数不加载Erlang对象代码。</target>
        </trans-unit>
        <trans-unit id="ec340a7ef82adaf495980f8394af2d18c4828368" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt; erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0882de707c0d281667a21347a4ebcd6453edd4" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="translated">从 &lt;code&gt;Path&lt;/code&gt; 中指定的目录中加载模块 &lt;code&gt;[Mod]&lt;/code&gt; 。脚本解释器通过调用 &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt; 来获取适当的模块。如果找不到模块，则会发生致命错误并终止系统。</target>
        </trans-unit>
        <trans-unit id="b222c6a3c319314c492cf0438513476921b1937e" translate="yes" xml:space="preserve">
          <source>Local Calls (*).</source>
          <target state="translated">本地电话(*)。</target>
        </trans-unit>
        <trans-unit id="22b269c280a4483582888bf05922c7b7ce1c87e3" translate="yes" xml:space="preserve">
          <source>Local Function Names Clashing With Auto-Imported BIFs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d28f25e340f821fe07d1de47fc1a75ea76b56" translate="yes" xml:space="preserve">
          <source>Local Functions (*). All local functions of analyzed modules.</source>
          <target state="translated">本地函数(*)。分析模块的所有本地函数。</target>
        </trans-unit>
        <trans-unit id="fc554992a28c61639d93b552c374a6c7640f6fd7" translate="yes" xml:space="preserve">
          <source>Local and universal time, day of the week, date and time conversions.</source>
          <target state="translated">本地和通用时间、星期、日期和时间转换。</target>
        </trans-unit>
        <trans-unit id="3a24185719639d033f0e83cfef0d2ecbbd64ed33" translate="yes" xml:space="preserve">
          <source>Local content tables</source>
          <target state="translated">本地内容表</target>
        </trans-unit>
        <trans-unit id="eec0b138b64b9281f5ecd12aa0d772831301eadf" translate="yes" xml:space="preserve">
          <source>Local error handling (catch/throw).</source>
          <target state="translated">本地错误处理(抓/扔)。</target>
        </trans-unit>
        <trans-unit id="fec84131be53b732f54c4a71b1a7666df7c2da3e" translate="yes" xml:space="preserve">
          <source>Local membership is not preserved if scope process exits and restarts. This behaviour is different from &lt;code&gt;&lt;a href=&quot;pg2&quot;&gt;pg2&lt;/a&gt;&lt;/code&gt;, that recovers local membership from remote nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de80d54249d1e2b8e04f06115d77bf6522dcbe" translate="yes" xml:space="preserve">
          <source>Local or remote process is monitored by name.</source>
          <target state="translated">本地或远程进程按名称进行监控。</target>
        </trans-unit>
        <trans-unit id="9c7734a4ec06d4dd200eb7b25986d4166f45276c" translate="yes" xml:space="preserve">
          <source>Local port is monitored by name. Please note, that remote port monitors are not supported, so &lt;code&gt;Node&lt;/code&gt; will always be the local node name.</source>
          <target state="translated">本地端口按名称监视。请注意，不支持远程端口监视器，因此 &lt;code&gt;Node&lt;/code&gt; 将始终是本地节点名称。</target>
        </trans-unit>
        <trans-unit id="e7d3e02be42f1c184b6a3c3c525e75c5179c0a77" translate="yes" xml:space="preserve">
          <source>Local port is monitored by port id.</source>
          <target state="translated">本地端口通过端口ID进行监控。</target>
        </trans-unit>
        <trans-unit id="5a6dd59b11d0e4520b4498e658eed0dbf5af795c" translate="yes" xml:space="preserve">
          <source>Local time is obtained from the Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt;. Universal time is computed from the BIF &lt;code&gt;universaltime/0&lt;/code&gt;.</source>
          <target state="translated">本地时间是从Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt; 获得的。通用时间是根据BIF &lt;code&gt;universaltime/0&lt;/code&gt; 计算的。</target>
        </trans-unit>
        <trans-unit id="4bbadc0e66c71769347f5cbcfb7c145c283ad8fd" translate="yes" xml:space="preserve">
          <source>LocalFunctionHandler,</source>
          <target state="translated">LocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="fa3ca264b4b0fef6182372f6a2a3773355ef8380" translate="yes" xml:space="preserve">
          <source>Locally Used Functions (*). Functions of all modules that have been used in some local call.</source>
          <target state="translated">本地使用的函数(*)。在本地调用中使用过的所有模块的函数。</target>
        </trans-unit>
        <trans-unit id="5b09785286488bac8a487ce328cb324b03ce2288" translate="yes" xml:space="preserve">
          <source>Location data produced by the log macros, and/or metadata given as argument to the log call (API function or macro), are merged with the process metadata. If the same keys occur, values from the metadata argument to the log call overwrite values from the process metadata, which in turn overwrite values from the location data.</source>
          <target state="translated">由日志宏产生的位置数据和/或作为日志调用(API函数或宏)参数给出的元数据会与过程元数据合并。如果出现相同的键,则日志调用的元数据参数的值会覆盖过程元数据的值,而过程元数据的值又会覆盖位置数据的值。</target>
        </trans-unit>
        <trans-unit id="98d3b1967c02fdc780f97715c22bad74f36e5d2c" translate="yes" xml:space="preserve">
          <source>Location transparency. Programs can be written without knowledge of the actual data location.</source>
          <target state="translated">位置透明。可以在不知道实际数据位置的情况下编写程序。</target>
        </trans-unit>
        <trans-unit id="7786377791ba3a21918764c28fc12553cbbcfa4e" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS中BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; 的位置透明版本。</target>
        </trans-unit>
        <trans-unit id="ee8a078095b685bbe1aa5a8273ed6ba602b4e833" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS中BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; 的位置透明版本。</target>
        </trans-unit>
        <trans-unit id="7890346208b55e9f0de8ac7ad2436d80c5f1ce98" translate="yes" xml:space="preserve">
          <source>Lock &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; for ports and processes are interchangeable with the use of &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; and is the reason why &lt;code&gt;pid()&lt;/code&gt; and &lt;code&gt;port()&lt;/code&gt; options can be used in both &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space. Both pids and ports are special identifiers with stripped creation and can be recreated with &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">端口和进程的锁 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Id&lt;/code&gt; 可与 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 互换使用，这就是在 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Id&lt;/code&gt; 空间中都可以使用 &lt;code&gt;pid()&lt;/code&gt; 和 &lt;code&gt;port()&lt;/code&gt; 选项的原因。pid和port都是带剥离创建的特殊标识符，可以使用 &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt; 重新创建。</target>
        </trans-unit>
        <trans-unit id="8a1f5f8eab7c8604bc5fd5406eb1dc291955e813" translate="yes" xml:space="preserve">
          <source>Lock physical memory. Defaults to &lt;code&gt;no&lt;/code&gt;, that is, no physical memory is locked. If set to &lt;code&gt;all&lt;/code&gt;, all memory mappings made by the runtime system are locked into physical memory. If set to &lt;code&gt;all&lt;/code&gt;, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</source>
          <target state="translated">锁定物理内存。默认为 &lt;code&gt;no&lt;/code&gt; ，即没有物理内存被锁定。如果设置为 &lt;code&gt;all&lt;/code&gt; ，则运行时系统进行的所有内存映射都将锁定到物理内存中。如果设置为 &lt;code&gt;all&lt;/code&gt; ，则在不支持此功能，用户没有足够的特权或者不允许用户锁定足够的物理内存时，运行时系统将无法启动。如果达到了用户对锁定内存量的限制，则运行时系统也会因内存不足而失败。</target>
        </trans-unit>
        <trans-unit id="9644e8510fee7197b968870e4b28fa5886afdcd9" translate="yes" xml:space="preserve">
          <source>LockKind :: &lt;code&gt;&lt;a href=&quot;#type-write_locks&quot;&gt;write_locks()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="45057a24787103ff08cc02cd027e2fddb757a403" translate="yes" xml:space="preserve">
          <source>Locks a mutex. The calling thread is blocked until the mutex has been locked. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; lock the same mutex again.</source>
          <target state="translated">锁定互斥锁。调用线程被阻塞，直到互斥锁已被锁定。当前已锁定互斥锁的线程&lt;strong&gt;无法&lt;/strong&gt;再次锁定同一互斥锁。</target>
        </trans-unit>
        <trans-unit id="07893be798653c5847566c8be8dbfc1f8e339a9a" translate="yes" xml:space="preserve">
          <source>Locks are released when the outermost transaction ends.</source>
          <target state="translated">当最外层的交易结束时,锁被释放。</target>
        </trans-unit>
        <trans-unit id="94c151cf6fbb179cda9bff3f3d73d852d7a92582" translate="yes" xml:space="preserve">
          <source>Locks have an inherent cost in execution time and memory space. It takes time initialize, destroy, aquiring or releasing locks. To decrease lock contention it some times necessary to use finer grained locking strategies. This will usually also increase the locking overhead and hence there is a tradeoff between lock contention and overhead. In general, lock contention increases with the number of threads running concurrently. The &lt;code&gt;lcnt&lt;/code&gt; tool does not measure locking overhead.</source>
          <target state="translated">锁在执行时间和存储空间上具有固有的成本。初始化，销毁，获取或释放锁需要时间。为了减少锁争用，有时必须使用更细粒度的锁策略。这通常也将增加锁定开销，因此在锁定争用和开销之间需要权衡。通常，锁争用随着并发运行的线程数而增加。该 &lt;code&gt;lcnt&lt;/code&gt; 工具不测量锁定开销。</target>
        </trans-unit>
        <trans-unit id="97e3b2745352de6be776b6b063835147719fb8df" translate="yes" xml:space="preserve">
          <source>Locks in the emulator are named after what type of resource they protect and where in the emulator they are initialized, those are lock 'classes'. Most of those locks are also instantiated several times, and given unique identifiers, to increase locking granularity. Typically an instantiated lock protects a disjunct set of the resource, for example ets tables, processes or ports. In other cases it protects a specific range of a resource, for example &lt;code&gt;pix_lock&lt;/code&gt; which protects index to process mappings, and is given a unique number within the class. A unique lock in &lt;code&gt;lcnt&lt;/code&gt; is referenced by a name (class) and an identifier: &lt;code&gt;{Name, Id}&lt;/code&gt;.</source>
          <target state="translated">仿真器中的锁以它们保护的资源类型以及在仿真器中的初始化位置（即锁&amp;ldquo;类&amp;rdquo;）命名。这些锁中的大多数还被实例化了几次，并赋予了唯一的标识符，以增加锁的粒度。通常，实例化的锁可保护资源的分离集，例如ets表，进程或端口。在其他情况下，它保护资源的特定范围，例如 &lt;code&gt;pix_lock&lt;/code&gt; ，它保护索引到进程的映射，并在类中被赋予唯一编号。 &lt;code&gt;lcnt&lt;/code&gt; 中的唯一锁由名称（类）和标识符 &lt;code&gt;{Name, Id}&lt;/code&gt; 引用。</target>
        </trans-unit>
        <trans-unit id="e8dbe53a83645d1cc991331113f81f0a7faf9914" translate="yes" xml:space="preserve">
          <source>Locks the configuration target.</source>
          <target state="translated">锁定配置目标。</target>
        </trans-unit>
        <trans-unit id="278c995aa0e75b2b9c086639c4daf158ccfe0917" translate="yes" xml:space="preserve">
          <source>Locks the driver used by the port &lt;code&gt;port&lt;/code&gt; in memory for the rest of the emulator process' lifetime. After this call, the driver behaves as one of Erlang's statically linked-in drivers.</source>
          <target state="translated">在仿真器进程的剩余寿命中，锁定端口 &lt;code&gt;port&lt;/code&gt; 在内存中使用的驱动程序。调用之后，该驱动程序将充当Erlang的静态链接驱动程序之一。</target>
        </trans-unit>
        <trans-unit id="877522e39f7783d66d9b87789ee2ec4ff4bf44e6" translate="yes" xml:space="preserve">
          <source>Locks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">锁定作为参数（ &lt;code&gt;pdl&lt;/code&gt; ）传递的端口数据锁。</target>
        </trans-unit>
        <trans-unit id="c61a839f83e5687db76049539133035688e5e448" translate="yes" xml:space="preserve">
          <source>Log File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f84854507a1065ca8c9cdcabd8f6b4e1e78700" translate="yes" xml:space="preserve">
          <source>Log a standard error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准的错误事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="d0480874641874b7e8e0be1a60fc5834def2580a" translate="yes" xml:space="preserve">
          <source>Log a standard error event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准错误事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="ad4ad09e24cbfd4d5d21372873fb510f9def4cc0" translate="yes" xml:space="preserve">
          <source>Log a standard information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准信息事件。错误记录器将事件转发到记录器,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="b41037da94e8aee3e126b299e92f7fe2e27f3503" translate="yes" xml:space="preserve">
          <source>Log a standard information event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准信息事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="3fa6e0baa5d187967c02dcd11af5efcea6dd94e2" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准的警告事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="0d4fed3a8c3034253fd45573f68ab458ca57cd12" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准警告事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="1844b1c7ae49d978743ba14c4e6a6dc7c218a27d" translate="yes" xml:space="preserve">
          <source>Log a user-defined error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的错误事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="887d25b1b376c5062e3b1b29ffe4bc683a9b4867" translate="yes" xml:space="preserve">
          <source>Log a user-defined information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的信息事件。错误记录器将事件转发到记录器,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="6d52584bb8ee44c32d0e928afa86be59daa75386" translate="yes" xml:space="preserve">
          <source>Log a user-defined warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的警告事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="068d9dbd5d7dcab97d0cf593a32eb92cca768c9e" translate="yes" xml:space="preserve">
          <source>Log events that do not contain any domain field, match only when &lt;code&gt;Compare&lt;/code&gt; is equal to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;not_equal&lt;/code&gt;.</source>
          <target state="translated">日志事件不包含任何域字段，仅当 &lt;code&gt;Compare&lt;/code&gt; 等于 &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;not_equal&lt;/code&gt; 时才匹配。</target>
        </trans-unit>
        <trans-unit id="dab7fd93efd795148bbe27e97e70b16665121c7b" translate="yes" xml:space="preserve">
          <source>Log files are always UTF-8 encoded. The encoding cannot be changed by setting the mode &lt;code&gt;{encoding,Encoding}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420705b9279101c5f7f8c29e1095fd25e0bd28a6" translate="yes" xml:space="preserve">
          <source>Log files are written in &lt;code&gt;log_dir&lt;/code&gt;. Each log file has a name of the form &lt;code&gt;erlang.log.N&lt;/code&gt;, where N is a generation number, ranging from 1 to 5. Each log file holds up to 100 kB text. As time goes by, the following log files are found in the log file directory:</source>
          <target state="translated">日志文件写入 &lt;code&gt;log_dir&lt;/code&gt; 。每个日志文件的名称格式为 &lt;code&gt;erlang.log.N&lt;/code&gt; ，其中N是世代号，范围为1到5。每个日志文件最多可容纳100 kB文本。随着时间的流逝，在日志文件目录中找到以下日志文​​件：</target>
        </trans-unit>
        <trans-unit id="a923af4f09938b28def56fc57c9c20863233189b" translate="yes" xml:space="preserve">
          <source>Log files from every repeated test run is saved in normal &lt;code&gt;Common Test&lt;/code&gt; fashion (described earlier).</source>
          <target state="translated">每次重复的测试运行中的日志文件都以普通的&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 方式保存（如前所述）。</target>
        </trans-unit>
        <trans-unit id="2578374749dfd011e3a5cbfbf27037022ad25cd6" translate="yes" xml:space="preserve">
          <source>Log files grow very large, very quickly.</source>
          <target state="translated">日志文件长得非常大,非常快。</target>
        </trans-unit>
        <trans-unit id="e92387004c6d91ee27198a23307e44f60b2be4d5" translate="yes" xml:space="preserve">
          <source>Log levels are expressed as atoms. Internally in Logger, the atoms are mapped to integer values, and a log event passes the log level check if the integer value of its log level is less than or equal to the currently configured log level. That is, the check passes if the event is equally or more severe than the configured level. See section &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; for a listing and description of all log levels.</source>
          <target state="translated">对数水平表示为原子。在Logger内部，原子被映射为整数值，并且日志事件的日志级别的整数值小于或等于当前配置的日志级别，则日志事件通过日志级别检查。也就是说，如果事件的严重性等于或大于配置的级别，则检查通过。有关所有日志级别的列表和说明，请参阅 &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e3d6b530f7c8342006e1b77a12ea94bab500b544" translate="yes" xml:space="preserve">
          <source>Log size.</source>
          <target state="translated">对数大小。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
