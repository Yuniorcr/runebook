<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="0f9944b699387d7c11ea7cd1be3bab23ba4afdef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</source>
          <target state="translated">所述 &lt;code&gt;.appup&lt;/code&gt; 文件包含一个单一的Erlang术语，它定义了用于升级或降级的应用的指令。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="0a4e2f387f9c84aa65d3380a5a44029b602ea3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.erlang.cookie&lt;/code&gt; file is to contain a line with the same atom. For example, on Linux or UNIX, in the OS shell:</source>
          <target state="translated">该 &lt;code&gt;.erlang.cookie&lt;/code&gt; 文件是包含具有相同原子的线。例如，在Linux或UNIX上，在OS Shell中：</target>
        </trans-unit>
        <trans-unit id="0032fcf48e0da685e59294f0a4f697a2db8dcacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcs&lt;/code&gt; file would look like:</source>
          <target state="translated">该 &lt;code&gt;.funcs&lt;/code&gt; 文件将如下所示：</target>
        </trans-unit>
        <trans-unit id="14e7547174b37977afa693aeffb001d289cd5a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hrl&lt;/code&gt; files are generated with &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt;. Include these files in your code as in the following example:</source>
          <target state="translated">的 &lt;code&gt;.hrl&lt;/code&gt; 文件与生成 &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt; 。如下例所示，将这些文件包括在您的代码中：</target>
        </trans-unit>
        <trans-unit id="3f3c52adfe9451ed557d5cb72636a16ce9b8cff5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="f61412bcc5809a8e7db35485d4bc2ee4c582bd3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains information about the release: its name, version, and which ERTS and application versions it uses.</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件包含有关发布的信息：它的名称，版本，以及ERTS和应用程序版本，它使用。</target>
        </trans-unit>
        <trans-unit id="fba0dc5cd4e50a75950facea5ebefcde4b2c40d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains one single Erlang term, which is called a &lt;strong&gt;release specification&lt;/strong&gt;. The file has the following syntax:</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件包含一个单一的Erlang项，其中被称为&lt;strong&gt;放行标准&lt;/strong&gt;。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="9be75095f9fcc28e6742d9c5c6b665ebdc21fd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file must also contain &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt;, as these applications are required by &lt;code&gt;ch_app&lt;/code&gt;. The file is called &lt;code&gt;ch_rel-1.rel&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件还必须包含 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 和 &lt;code&gt;sasl&lt;/code&gt; ，因为这些应用程序是由需要 &lt;code&gt;ch_app&lt;/code&gt; 。该文件称为 &lt;code&gt;ch_rel-1.rel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="13be72d295c9d3a74b0ba266a8b6d753044e4f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.script&lt;/code&gt; file is generated by &lt;code&gt;systools&lt;/code&gt; from a &lt;code&gt;.rel&lt;/code&gt; file and from &lt;code&gt;.app&lt;/code&gt; files.</source>
          <target state="translated">该 &lt;code&gt;.script&lt;/code&gt; 文件由产生 &lt;code&gt;systools&lt;/code&gt; 从 &lt;code&gt;.rel&lt;/code&gt; 文件，并从 &lt;code&gt;.app&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="8952d3b159688281512664b4559315ca46a6b2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; in which the resolved process id is stored.</source>
          <target state="translated">存储了解析的进程ID 的 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f0ba8ce42f3241f6f1e8ce8e3ec88bd285be952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; in which the resolved port id is stored.</source>
          <target state="translated">存储解析的端口ID 的 &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9be61e44d94622615ce4101938ee713afd7cdab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; has the same behavior as before, and the old API still works. Thus, you are not required to change anything unless you want to. However, &lt;strong&gt;you are strongly encouraged to use the new API&lt;/strong&gt; instead of the old API based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; is deprecated, as it is and will be a scalability bottleneck.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; 具有相同的行为和以前一样，和旧的API仍然有效。因此，除非您愿意，否则无需更改任何内容。但是，&lt;strong&gt;强烈建议您使用新的API&lt;/strong&gt;而不是基于 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 的旧API 。 &lt;code&gt;erlang:now/0&lt;/code&gt; 仍被弃用，它将成为可伸缩性瓶颈。</target>
        </trans-unit>
        <trans-unit id="18bf0f08971899dc4f16a1b00f5aad47c098d502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt; state transition action explicitly postpones one received event.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 的设计模型选择性接收。选择性接收会隐式延迟任何未接收的事件，但是 &lt;code&gt;postpone&lt;/code&gt; 状态转换操作会显式延迟一个已接收的事件。</target>
        </trans-unit>
        <trans-unit id="2e521122544eb6fa9ab0cd68ed9751d9d365e33f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of Erlang monotonic time heavily depends on the following:</source>
          <target state="translated">Erlang单调时间的 &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 在很大程度上取决于以下各项：</target>
        </trans-unit>
        <trans-unit id="da959f4f913bd754095c0cffc4af1e4cec02fe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt;&lt;strong&gt;transition action&lt;/strong&gt; explicitly postpones one received event.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 的设计模型选择性接收。选择性接收会隐式延迟任何未接收的事件，但是 &lt;code&gt;postpone&lt;/code&gt; &lt;strong&gt;转换操作会&lt;/strong&gt;显式延迟一个已接收的事件。 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee853e7e00e08008dc7e059fac73729f774dbe00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt; enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt; enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 函数可以被用来通知运行时系统对NIF呼叫的长度。除非NIF执行得非常快，否则通常总是使用它。</target>
        </trans-unit>
        <trans-unit id="6f631a391a9754e49e6ee1bde4ff6f90ac52a87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 函数可以被用来通知运行时系统对NIF呼叫的长度。除非NIF执行得非常快，否则通常总是使用它。</target>
        </trans-unit>
        <trans-unit id="42203200dce5d30a841bfbad273ab03cca628668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; records below are defined in diameter.hrl, which can be included as follows.</source>
          <target state="translated">下面的 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 记录在直径.hrl中定义，可以包括以下内容。</target>
        </trans-unit>
        <trans-unit id="5443a5673cfdeb62b70cfaa66a1a4d05ea2c10ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; is displayed.</source>
          <target state="translated">显示&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64917e182873d825bb4118b082544cb5020d55ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; test is not completely foolproof. For a few special node types (e.g. &lt;code&gt;arity_qualifier&lt;/code&gt;), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if &lt;code&gt;Tree&lt;/code&gt; does not actually represent legal Erlang code.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 测试是不完全万无一失。对于一些特殊的节点类型（例如 &lt;code&gt;arity_qualifier&lt;/code&gt; ），如果这样的节点出现在不期望出现的上下文中，则将其保留为结果的未还原子树。仅当 &lt;code&gt;Tree&lt;/code&gt; 实际上不表示合法的Erlang代码时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="8bdddf2d9e89b5afec27570549313f0a00dfb66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; is displayed with information about all debugged processes, interpreted modules, and selected options. Initially there are normally no debugged processes. First, it must be specified which modules that are to be &lt;strong&gt;debugged&lt;/strong&gt; (also called &lt;strong&gt;interpreted&lt;/strong&gt;). Proceed as follows:</source>
          <target state="translated">将显示&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; ，其中包含有关所有调试的进程，解释的模块和所选选项的信息。最初通常没有调试过的进程。首先，必须指定要&lt;strong&gt;调试的&lt;/strong&gt;模块（也称为&lt;strong&gt;解释的&lt;/strong&gt;）。进行如下：</target>
        </trans-unit>
        <trans-unit id="d1371003c4109f45bb7c590d9e6bfcf741d3783e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; at the time when current Erlang runtime system instance started.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 的时候，目前的Erlang运行时系统实例启动。</target>
        </trans-unit>
        <trans-unit id="c54a199fd4640b0c1f2d1a7d7f234a5d11ebf160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; syntax and semantics resemble that of Perl.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; 的语法和语义相似是Perl的。</target>
        </trans-unit>
        <trans-unit id="86910d8a99b113804f6c41ebe30ba830eeca44e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted in the event queue as the next to call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 可以插入使用事件 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 和插入事件队列作为下调用此类事件 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 用。也就是说，好像它是最早的传入事件。可以将专用的 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 事件用于此类事件，从而使它们不会被误认为是外部事件。</target>
        </trans-unit>
        <trans-unit id="ddaf5a8cfd6684f5a32a7cfde1c55113cf46f155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;gen_statem&lt;/code&gt; to execute during the &lt;strong&gt;state transition&lt;/strong&gt;, for example to reply to a &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;gen_statem:call/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 可能返回 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;&lt;strong&gt;transition actions&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;gen_statem&lt;/code&gt; 在执行过程中&lt;strong&gt;的状态转换&lt;/strong&gt;，例如回复 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;gen_statem:call/2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7246167f3c09c6525874f60b11ba89db7e2744c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted as the next to present to the state callback. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 可以插入使用的事件 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 和这样的事件被插入作为下一存在到状态回调。也就是说，好像它是最早的传入事件。可以将专用的 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 事件用于此类事件，从而使它们无法误认为外部事件。</target>
        </trans-unit>
        <trans-unit id="8dc397f4aad495e70f783e4e9f18314a11b4699a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 进入第一次当执行 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 只是作为一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，只不过操作 &lt;code&gt;postpone&lt;/code&gt; 被迫 &lt;code&gt;false&lt;/code&gt; ，因为没有活动推迟。</target>
        </trans-unit>
        <trans-unit id="d79b4de0faec73ea8a56c3d33b4728d0d0f13117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 进入第一次当执行 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 只是作为一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，只不过操作 &lt;code&gt;postpone&lt;/code&gt; 被迫 &lt;code&gt;false&lt;/code&gt; ，因为没有活动推迟。</target>
        </trans-unit>
        <trans-unit id="4b95289b0c26b39ec2e6bba34c2ea61ee391b999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec-option&lt;/a&gt;&lt;/code&gt; has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-6 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec-option&lt;/a&gt;&lt;/code&gt; 已经存在了很长时间，但以前没有被记录在案。保留了旧的定义和行为，但如果有冲突，请遵守上述规则1-6。旧的和未记录的样式不应在新程序中使用。</target>
        </trans-unit>
        <trans-unit id="99afc1abdda369a0914949188ce7fb06901f6f8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec_spec&lt;/a&gt;&lt;/code&gt;&lt;code&gt;fun()&lt;/code&gt; is called with the same number of parameters as the arity of the fun, and the result is returned to the client. Shell-requests are not affected, they follow the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;'s value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec_spec&lt;/a&gt;&lt;/code&gt; &lt;code&gt;fun()&lt;/code&gt; 被调用相同数量的参数作为乐趣的元数，并将结果返回给客户端。Shell请求不受影响，它们遵循 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="04249803fd25f8d18a129af7ec7559589758bac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; are associated with this list of keys.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; 与键此列表关联。</target>
        </trans-unit>
        <trans-unit id="c47299082b86fea81f7b73b85c3b481aabd9d033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; can then be passed to the aforementioned functions to use the referenced configuration.</source>
          <target state="translated">然后可以将 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 或关联的 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 传递给上述函数，以使用引用的配置。</target>
        </trans-unit>
        <trans-unit id="0e395a27eee95c6082f8cf61222aaf962540cea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; must then be used in calls to &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 或相关联的 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 必须随后在调用用于 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3dc033ce6bd037856bac83ebd4f39855340ec51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; type also consist of the following &lt;strong&gt;deprecated&lt;/strong&gt; symbolic time units:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; 类型还包括以下的&lt;strong&gt;弃用&lt;/strong&gt;符号时间单元：</target>
        </trans-unit>
        <trans-unit id="88d76a69dffe86852b03f6f2771d64a235602ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is expected to know if reloading is demanded before creating a monitor for loading.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 预计将知道，如果重新装入加载创建显示器前要求。</target>
        </trans-unit>
        <trans-unit id="6529c6f67bbc8e3a2934d327ad30e40ae74a06cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;crypto#next_iv-2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;crypto#next_iv-3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/code&gt; is not needed since the &lt;code&gt;crypto_init&lt;/code&gt; and &lt;code&gt;crypto_update&lt;/code&gt; includes this functionality.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;crypto#next_iv-2&quot;&gt;next_iv/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;crypto#next_iv-3&quot;&gt;next_iv/3&lt;/a&gt;&lt;/code&gt; 不需要因为 &lt;code&gt;crypto_init&lt;/code&gt; 和 &lt;code&gt;crypto_update&lt;/code&gt; 包括此功能。</target>
        </trans-unit>
        <trans-unit id="4ef4e16c6d6043c0d934f6a3edee0c7cc5aa2fe6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; module provides the main interface for writing test cases. This includes for example, the following:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 模块提供了编写测试用例的主界面。例如，这包括以下内容：</target>
        </trans-unit>
        <trans-unit id="24d2428c5253a289420ac3c56a797aad5738f051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; function prints a string to the test case log file. The &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the string to screen. The &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the same string both to file and screen. The functions are described in module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 函数打印字符串测试用例的日志文件。在 &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; 函数打印字符串到屏幕。在 &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; 函数打印相同的字符串既文件和屏幕。功能在模块 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 中描述。</target>
        </trans-unit>
        <trans-unit id="f487c24dcce56661b796ae49d9fa184c1120f87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test&quot;&gt;ct_property_test&lt;/a&gt;&lt;/code&gt; module does the following:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct_property_test&quot;&gt;ct_property_test&lt;/a&gt;&lt;/code&gt; 模块执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7520b5a1282410b50e8ce82d773253694bcb5f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_property_test#present_result-4&quot;&gt;ct_property_test:present_result/4&lt;/a&gt;&lt;/code&gt; is a help function for printing some statistics in the CommonTest log file.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct_property_test#present_result-4&quot;&gt;ct_property_test:present_result/4&lt;/a&gt;&lt;/code&gt; 是打印在CommonTest日志文件中的一些统计数据的帮助功能。</target>
        </trans-unit>
        <trans-unit id="2225a95d59e4a2a00a916261ffc2ac6e972545a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program can be used for running tests from the OS command line, for example, as follows:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 程序可用于从OS命令行运行试验，例如，如下所示：</target>
        </trans-unit>
        <trans-unit id="45351661ad4006c4669c2ebdd26490749b02b241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable &lt;code&gt;Age&lt;/code&gt;, which is included at two positions in the tuple. The pattern match is performed as follows:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; 功能执行模式匹配。它需要一个模式和一个术语，并试图匹配它们。副作用是，模式中任何未绑定的变量都将被绑定。在以下示例中，使用变量 &lt;code&gt;Age&lt;/code&gt; 创建一个模式，该模式包含在元组的两个位置。模式匹配执行如下：</target>
        </trans-unit>
        <trans-unit id="f58e8b7ebcca47b5fa5b9e432d29b5c35a2acf4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 回调，这是在这个实现中使用了很多。</target>
        </trans-unit>
        <trans-unit id="5d913aee0ec20f5c99548c0d67120c8b7390405c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 回调，这是在这个实现中使用了很多。</target>
        </trans-unit>
        <trans-unit id="5df35aa6c58680e6606845e3cb0a4b184a4d606d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel handling the remote channel. The Erlang format of thoose messages is (see also &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; 由客户机和服务器，即，SSH通道使用的，超过所述SSH连接进行通信。此模块中的API函数发送SSH连接协议事件，这些消息由处理远程通道的远程通道作为消息接收。thoose消息的Erlang格式为（另请参见 &lt;code&gt;&lt;a href=&quot;#type-event&quot;&gt;below&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e04d20c0a21a342accdbeea00bdc89554c9bbc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel. If the receiving channel is an Erlang process, the messages have the format &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; 由客户机和服务器，即，SSH通道使用的，超过所述SSH连接进行通信。此模块中的API函数发送SSH连接协议事件，该事件作为消息由远程通道接收。如果接收通道是Erlang进程，则消息的格式为 &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt; 。如果使用 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为来实现通道过程，则由 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 处理这些消息。</target>
        </trans-unit>
        <trans-unit id="bb9446bc2906454d7543c5cf2f665a89704ad38a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021&quot;&gt;high-watermark&lt;/a&gt;&lt;/code&gt; is placed where the previous garbage collection (described in &lt;code&gt;&lt;a href=&quot;#Overview&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;) ended and we have introduced a new area called the old heap. When doing the normal garbage collection pass, any term that is located below the high-watermark is copied to the old &lt;strong&gt;to space&lt;/strong&gt; instead of the young.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021&quot;&gt;high-watermark&lt;/a&gt;&lt;/code&gt; 被放置在前面的垃圾收集（描述 &lt;code&gt;&lt;a href=&quot;#Overview&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; ）结束，我们引入了一个叫老堆新的领域。在进行正常的垃圾收集过程时，位于高水位线以下的任何术语都将复制到旧&lt;strong&gt;的空间&lt;/strong&gt;而不是年轻的&lt;strong&gt;空间&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd1b00c890947931beb8fe9dcb1f1a330520a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465&quot;&gt;`erts_is_literal`&lt;/a&gt;&lt;/code&gt; check works differently on different architectures and operating systems.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465&quot;&gt;`erts_is_literal`&lt;/a&gt;&lt;/code&gt; 检查工作不同在不同的体系结构和操作系统。</target>
        </trans-unit>
        <trans-unit id="29f892246d7df69546254cbfcc798654f3646997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; defines</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; 定义</target>
        </trans-unit>
        <trans-unit id="7dcb6a1e5d8b3f03deff03d3241d42eac28f4c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module makes it possible to map different parts of the host file system into the document tree, that is, creates aliases and redirections.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 模块，可以将主机文件系统的不同部分映射到文档树中，即创建别名和重定向。</target>
        </trans-unit>
        <trans-unit id="fcc4b78316a4143698c35ef4043e086c3252f889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; module provides for basic user authentication using textual files, Dets databases as well as Mnesia databases.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 模块使用的文本文件，dets的数据库以及数据库的Mnesia提供了基本的用户认证。</target>
        </trans-unit>
        <trans-unit id="461a1eaddbc542451f83c2ca184fe0b61bd2923e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; module implements the Erlang Server Interface (ESI) providing a tight and efficient interface to the execution of Erlang functions.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 模块实现Erlang的服务器接口（ESI）提供紧密和有效的接口的二郎功能的执行。</target>
        </trans-unit>
        <trans-unit id="451822a0390939c5b7aa871766fbf59707a840eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; module serves as a filter for authenticated requests handled in &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt;. It provides a possibility to restrict users from access for a specified amount of time if they fail to authenticate several times. It logs failed authentication as well as blocking of users, and it calls a configurable callback module when the events occur.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; 模块用作认证请求的过滤器中处理 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 。如果用户多次验证失败，则可以在指定的时间内限制用户访问。它记录失败的身份验证以及对用户的阻止，并在事件发生时调用可配置的回调模块。</target>
        </trans-unit>
        <trans-unit id="cca463bd9735d9ae37813de52272ea12a3c25d3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run program&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run program&lt;/a&gt;&lt;/code&gt; 为可用的开始标志的概述（大多数标志具有相应配置的术语）</target>
        </trans-unit>
        <trans-unit id="41608b3a764923c262561e0c2d97e667f71e82d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; 可用开始标志的概述（大多数标志具有相应配置的术语）</target>
        </trans-unit>
        <trans-unit id="3f97cdf73ff78f958f92c1082d9981899a202f74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 选项必须是包含一个主机密钥文件的目录，并将其默认 &lt;code&gt;/etc/ssh&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 中的配置文件部分。</target>
        </trans-unit>
        <trans-unit id="8c2bdaafc19f8eda6fa7e095397c6b638b7731c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; module can be used for debugging a supervisor bridge.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 模块，可用于调试主管桥。</target>
        </trans-unit>
        <trans-unit id="1915b4761876d96adb7cfdaf20279417ba58c6b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 功能启动一个守护进程监听端口的UDP数据包。收到读取或写入请求后，它将生成一个临时服务器进程来处理传输。</target>
        </trans-unit>
        <trans-unit id="34bf65dbe208c89793330cc690692124bc99f1eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e817126baaf83dd2177ff4d3961b1bf92117ec3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d9a2bc15a65c27354714aedd36bc465c988bc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac6d07dd79fabf515998a51c2c8ccd52cb9e6e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6a0707134722e646e7cc1eaf4404ec443d34378" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11b934f9948e4845a2b33851b5932f94d59f1d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40c216921e0f08c2b36308cbbb132054a41492aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;CRYPTO User's Guide&lt;/a&gt;&lt;/code&gt; has more information on FIPS, Engines and Algorithm Details like key lengths.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;CRYPTO User's Guide&lt;/a&gt;&lt;/code&gt; 对FIPS，发动机和算法的细节，如密钥长度的详细信息。</target>
        </trans-unit>
        <trans-unit id="842d1fd61ccfd8c7f0a3b2ea51238f75d1a39f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; has examples and a &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">《 &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 包含示例和&amp;ldquo; &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="7213ba1d558f14b69b4e8a3edef214d04ef9e98a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?Q&lt;/code&gt; macros turn the quoted code fragments into ASTs, and lifts metavariables such as &lt;code&gt;_@Tuple&lt;/code&gt; and &lt;code&gt;_@Number&lt;/code&gt; to the level of your Erlang code, so you can use the corresponding Erlang variables &lt;code&gt;Tuple&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</source>
          <target state="translated">该 &lt;code&gt;?Q&lt;/code&gt; 宏打开引用的代码片段到AST的，和升降机元变量诸如 &lt;code&gt;_@Tuple&lt;/code&gt; 和 &lt;code&gt;_@Number&lt;/code&gt; 到您的二郎山代码的水平，这样你就可以使用相应的二郎神变量 &lt;code&gt;Tuple&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 直接。这是使用Merl的最直接的方法，在很多情况下，这就是您所需要的。</target>
        </trans-unit>
        <trans-unit id="15c579f9adfb6704c3bcff309334cae348b5e5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?assert(Expression)&lt;/code&gt; macro will evaluate &lt;code&gt;Expression&lt;/code&gt;, and if that does not evaluate to &lt;code&gt;true&lt;/code&gt;, it will throw an exception; otherwise it just returns &lt;code&gt;ok&lt;/code&gt;. In the above example, the test will thus fail if the call to &lt;code&gt;length&lt;/code&gt; does not return 3.</source>
          <target state="translated">本 &lt;code&gt;?assert(Expression)&lt;/code&gt; 宏将评估 &lt;code&gt;Expression&lt;/code&gt; ，如果不计算结果为 &lt;code&gt;true&lt;/code&gt; ，就会抛出一个异常; 否则，它将返回 &lt;code&gt;ok&lt;/code&gt; 。在上面的示例中，如果调用 &lt;code&gt;length&lt;/code&gt; 不返回3 ，则测试将因此失败。</target>
        </trans-unit>
        <trans-unit id="824fe9ddd06f6c4a1a05c0b0fcb9265f7a7b2017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASN.1&lt;/code&gt; application provides the following two separate user interfaces:</source>
          <target state="translated">在 &lt;code&gt;ASN.1&lt;/code&gt; 申请提供了以下两个独立的用户界面：</target>
        </trans-unit>
        <trans-unit id="ad1896e2fd3770f39ede02112fb63bbac81b7df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Address&lt;/code&gt; field is the second element.</source>
          <target state="translated">的 &lt;code&gt;Address&lt;/code&gt; 字段是第二元件。</target>
        </trans-unit>
        <trans-unit id="90bfd70e3f20f8f506d98edda14b178d797720e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AlgorithmId&lt;/code&gt; is the signature OID from a certificate or a certificate revocation list.</source>
          <target state="translated">该 &lt;code&gt;AlgorithmId&lt;/code&gt; 是从证书或证书吊销列表签名OID。</target>
        </trans-unit>
        <trans-unit id="e284c989131372b49e03051b62849870dd521425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to &quot;compact notation&quot;. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;BIT STRING&lt;/code&gt; 类型被解码为&amp;ldquo;紧凑符号&amp;rdquo;。&lt;strong&gt;不建议在新代码中使用此选项。&lt;/strong&gt;此选项不能与选项 &lt;code&gt;maps&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="d727373c971108a708085cfa309ebdb4fa5bc28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to the legacy format, that is, a list of zeroes and ones. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;BIT STRING&lt;/code&gt; 类型被解码到传统格式，也就是0和1的列表。&lt;strong&gt;不建议在新代码中使用此选项。&lt;/strong&gt;此选项不能与选项 &lt;code&gt;maps&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="3c84e077a6dbf3c771cfd255a8a9895e6702d3a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bitstring&lt;/code&gt; variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default &lt;code&gt;unit&lt;/code&gt; for bitstrings is 1.</source>
          <target state="translated">的 &lt;code&gt;Bitstring&lt;/code&gt; 变量可以由任意数目的位，例如，0，1，8，11，17，42，等等。这是因为位串的默认 &lt;code&gt;unit&lt;/code&gt; 是1。</target>
        </trans-unit>
        <trans-unit id="94a1488efe62c17d8ba98c01afd1b232f7321a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; argument indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Block&lt;/code&gt; 参数指示如果日志应转换期间不被阻止。这在转换大型日志时可能很有用（否则，在转换过程中日志可能会换行）。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ab5f211e8f18fd1c4ca859d11a5d3fcd218d631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Block&lt;/code&gt; 选项指示在转换过程中是否应阻止日志。这在转换大型日志时可能很有用（否则，在转换过程中日志可能会自动换行）。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2a775047eba8dcca0470291f62d589146470f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufSz&lt;/code&gt; argument basically defines the size of the receive buffer. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; and &lt;code&gt;Key&lt;/code&gt; = &lt;code&gt;rcvbuf&lt;/code&gt;) is used.</source>
          <target state="translated">所述 &lt;code&gt;BufSz&lt;/code&gt; 参数基本上定义的接收缓冲区的大小。通过将该值设置为零（0），将使用配置的大小（setopt，其中 &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; 和 &lt;code&gt;Key&lt;/code&gt; = &lt;code&gt;rcvbuf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2acfbefe2ee37310ba387213e5e15aa6901a988c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Callback&lt;/code&gt; module should contain hook functions for all tags present in the data structure. A hook function must have the following format:</source>
          <target state="translated">所述 &lt;code&gt;Callback&lt;/code&gt; 模块应包含钩子函数所有标签存在于所述数据结构中。挂钩函数必须具有以下格式：</target>
        </trans-unit>
        <trans-unit id="883390db9451e13b3d5a5f85d744ec9ca06a2b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallbackMode&lt;/code&gt; is either just &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; or a list containing &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; and possibly the atom &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;CallbackMode&lt;/code&gt; 是要么只是 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 或含列表 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 以及可能的原子 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a580d51d45e0183e4b31ffec1224002d11cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CharSpec&lt;/code&gt;&lt;code&gt;eof&lt;/code&gt; signals end of file. &lt;code&gt;LeftOverChars&lt;/code&gt; then takes the value &lt;code&gt;eof&lt;/code&gt; as well.</source>
          <target state="translated">所述 &lt;code&gt;CharSpec&lt;/code&gt; &lt;code&gt;eof&lt;/code&gt; 信号结束的文件。然后， &lt;code&gt;LeftOverChars&lt;/code&gt; 也将取值 &lt;code&gt;eof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64d980b4c7c9584d2e8b4e055ab6694f99c89599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChildSpecs&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; is a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; 返回值中的 &lt;code&gt;ChildSpecs&lt;/code&gt; 变量是 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="e5232c85e790e4f73652dc642ce50e6888594555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChunkSize&lt;/code&gt; defines the size of the &lt;code&gt;PlainBin&lt;/code&gt;s that &lt;code&gt;EncodeFun&lt;/code&gt; is applied to. If the &lt;code&gt;ChunkSize&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;ChunkSize&lt;/code&gt; is intended for block crypto. &lt;code&gt;ChunkSize&lt;/code&gt;s can be changed in the return from the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;ChunkSize&lt;/code&gt; 定义了的尺寸 &lt;code&gt;PlainBin&lt;/code&gt; s表示 &lt;code&gt;EncodeFun&lt;/code&gt; 施加到。如果 &lt;code&gt;ChunkSize&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; ，所述的尺寸 &lt;code&gt;PlainBin&lt;/code&gt; 小号而变化，因为这是用于流密码，而一个固定的 &lt;code&gt;ChunkSize&lt;/code&gt; 是用于块密码。 &lt;code&gt;ChunkSize&lt;/code&gt; S能够从返回改变 &lt;code&gt;EncryptFun&lt;/code&gt; 或 &lt;code&gt;DecryptFun&lt;/code&gt; 。可以在 &lt;code&gt;pos_integer()&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 之间更改该值。</target>
        </trans-unit>
        <trans-unit id="e8a7a9966f0b85d64cc4feece108959a21b830fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; API does also allow you to save the collected &lt;code&gt;Events&lt;/code&gt; to file and later load them in a later session.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; API确实也让您保存收集 &lt;code&gt;Events&lt;/code&gt; ，以文件，后来在以后的会议上加载它们。</target>
        </trans-unit>
        <trans-unit id="fceb8c2c1f65a97284385a3f23405d68267725fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; automatically registers itself to listen for trace &lt;code&gt;Events&lt;/code&gt;, so all you have to do is enable them.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; 会自动将自身注册为监听跟踪 &lt;code&gt;Events&lt;/code&gt; ，因此，所有你需要做的就是让他们。</target>
        </trans-unit>
        <trans-unit id="ec20677889045987c82a0d9f6c4d053fcf85822c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; manages a key/value based dictionary, where the filters are stored. Updates of the dictionary is propagated to all subscribing processes. When a &lt;code&gt;Viewer&lt;/code&gt; is started it is registered as a subscriber of dictionary updates.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; 管理基于键/值字典，当过滤器存储。字典的更新将传播到所有订阅过程。当 &lt;code&gt;Viewer&lt;/code&gt; 启动已被注册为词典更新的订户。</target>
        </trans-unit>
        <trans-unit id="e368c10bff22300d3fab811f6f50a4674a69667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Framework Log page includes links to the Pre- and Post Test I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; and &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt;, as well as captured system error- and progress reports, which take place before, and after, the test run. Examples of this are printouts from a CT hook init- or terminate function, or progress reports generated when an OTP application is started from a CT hook init function. Another example is an error report generated because of a failure when an external application is stopped from a CT hook terminate function. All information in these examples ends up in the Pre- and Post Test I/O Log. For more information on how to synchronize test runs with external user applications, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 框架日志&amp;rdquo;页面包含指向&amp;ldquo;测试前和测试后I / O日志&amp;rdquo;的链接。在此日志中， &lt;code&gt;Common Test&lt;/code&gt; 保存使用 &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 和 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 进行的打印输出，以及捕获的系统错误和进度报告，这些报告分别在测试运行之前和之后进行。例如，CT挂钩初始化或终止功能的打印输出，或从CT挂钩初始化功能启动OTP应用程序时生成的进度报告。另一个示例是由于从CT挂钩终止功能停止外部应用程序时失败导致的错误报告。这些示例中的所有信息最终显示在&amp;ldquo;测试前/测试后I / O日志&amp;rdquo;中。有关如何将测试运行与外部用户应用程序同步的更多信息，请参见&amp;ldquo; 通用测试挂钩&amp;rdquo; 部分中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="2b15f94344ef9977a91750baa9dddf1dbad0746d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master API is exported by module &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 大师API由模块输出 &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1eb6fe3660c4d65491500f6426215f629639619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server runs on one dedicated Erlang node and uses distributed Erlang to communicate with any number of &lt;code&gt;Common Test&lt;/code&gt; test nodes, each hosting a regular &lt;code&gt;Common Test&lt;/code&gt; server. Test specifications are used as input to specify what to test on which test nodes, using what configuration.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 一个专门的Erlang节点上的主服务器运行，并使用分布式二郎神与任意数量的沟通 &lt;code&gt;Common Test&lt;/code&gt; 测试节点，每个节点托管一个普通 &lt;code&gt;Common Test&lt;/code&gt; 服务器。测试规范用作输入，以指定使用什么配置在哪些测试节点上进行测试。</target>
        </trans-unit>
        <trans-unit id="d910e14beb83938480f0c5db0900211c5bc5ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server writes progress information to HTML log files similarly to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The logs contain test statistics and links to the log files written by each independent &lt;code&gt;Common Test&lt;/code&gt; server.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 主服务器到HTML日志文件类似于定期将进展信息 &lt;code&gt;Common Test&lt;/code&gt; 服务器。日志包含测试统计信息，并链接到每个独立的 &lt;code&gt;Common Test&lt;/code&gt; 服务器编写的日志文件。</target>
        </trans-unit>
        <trans-unit id="4e124139583e4b5d8918f07bb2c0c03bd8d6c703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application also includes other modules named &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt;, which provide various support, mainly simplified use of communication protocols such as RPC, SNMP, FTP, Telnet, and others.</source>
          <target state="translated">的 &lt;code&gt;Common Test&lt;/code&gt; 程序还包括其他名为模块 &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt; ，它们提供各种支持，主要简化使用的通信协议，例如RPC，SNMP，FTP，Telnet和其他。</target>
        </trans-unit>
        <trans-unit id="03a84fce685f88578ce41de6a729049cb8fac0fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application is installed with the Erlang/OTP system. No extra installation step is required to start using &lt;code&gt;Common Test&lt;/code&gt; through the &lt;code&gt;ct_run&lt;/code&gt; executable program, and/or the interface functions in the &lt;code&gt;ct&lt;/code&gt; module.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 应用程序安装与二郎/ OTP系统。通过 &lt;code&gt;ct_run&lt;/code&gt; 可执行程序和/或 &lt;code&gt;ct&lt;/code&gt; 模块中的接口功能开始使用 &lt;code&gt;Common Test&lt;/code&gt; ,不需要任何额外的安装步骤。</target>
        </trans-unit>
        <trans-unit id="78a22725d0c7f0f676d4ba2a90661e795ebb56c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is a tool that supports implementation and automated execution of test cases to any types of target systems. &lt;code&gt;Common Test&lt;/code&gt; is the main tool being used in all testing- and verification activities that are part of Erlang/OTP system development and maintenance.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 框架是支持实施和测试用例自动执行任何类型的目标系统的工具。 &lt;code&gt;Common Test&lt;/code&gt; 是Erlang / OTP系统开发和维护中所有测试和验证活动中使用的主要工具。</target>
        </trans-unit>
        <trans-unit id="18e9917f7eb0c975fe2d0bf461322b555cc56962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is an environment for implementing and performing automatic and semi-automatic execution of test cases.</source>
          <target state="translated">的 &lt;code&gt;Common Test&lt;/code&gt; 框架是用于实现和执行的测试用例自动和半自动执行的环境。</target>
        </trans-unit>
        <trans-unit id="c32a30ee7b6005326d0a472ffa1a54f5ce95df96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework provides a high-level operator interface for testing, providing the following features:</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 框架提供了测试，并提供以下功能的高级操作界面：</target>
        </trans-unit>
        <trans-unit id="ad9b65cad13beffef2e82d575de6699dcf88a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; test server requires that the test suite defines and exports the following mandatory or optional callback functions:</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 测试服务器要求的测试套件定义和导出以下强制或可选的回调函数：</target>
        </trans-unit>
        <trans-unit id="b3f5974325a1f6adb2e7a53fd6b80b396429c849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database is now initialized and contains data.</source>
          <target state="translated">该 &lt;code&gt;Company&lt;/code&gt; 数据库现在已经初始化并包含数据。</target>
        </trans-unit>
        <trans-unit id="84399fbfc3c32ddc0958865c1bc7e66e07f291b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database, introduced in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, has three tables that store records (&lt;code&gt;employee&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, &lt;code&gt;project&lt;/code&gt;), and three tables that store relationships (&lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, &lt;code&gt;in_proj&lt;/code&gt;). This is a normalized data model, which has some advantages over a non-normalized data model.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 引入的 &lt;code&gt;Company&lt;/code&gt; 数据库具有三个存储记录的表（ &lt;code&gt;employee&lt;/code&gt; ， &lt;code&gt;dept&lt;/code&gt; ， &lt;code&gt;project&lt;/code&gt; ）和三个存储关系的表（ &lt;code&gt;manager&lt;/code&gt; ， &lt;code&gt;at_dep&lt;/code&gt; ， &lt;code&gt;in_proj&lt;/code&gt; ）。这是规范化的数据模型，与非规范化的数据模型相比，它具有一些优点。</target>
        </trans-unit>
        <trans-unit id="5b4167561d4c9786e75acf722fa5255d76e1f375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ControlMessage&lt;/code&gt; is a tuple, where the first element indicates which distributed operation it encodes:</source>
          <target state="translated">所述 &lt;code&gt;ControlMessage&lt;/code&gt; 是一个元组，其中第一元素指示它编码一种分布式操作：</target>
        </trans-unit>
        <trans-unit id="a9bce474e15518f3622f365b9755866898515b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CtrlSz&lt;/code&gt; argument basically defines the size of the receive buffer for the control messages. By setting the value to zero (0), the configured size (setopt with &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt;) is used.</source>
          <target state="translated">所述 &lt;code&gt;CtrlSz&lt;/code&gt; 参数基本上定义的接收缓冲区的大小为控制消息。通过将该值设置为零（0），将使用配置的大小（使用 &lt;code&gt;Level&lt;/code&gt; = &lt;code&gt;otp&lt;/code&gt; 的setopt ）。</target>
        </trans-unit>
        <trans-unit id="b53e02a747463b517e8ec15e14ceddfb049c6d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DAT&lt;/code&gt; files must always be opened with option &lt;code&gt;{repair, false}&lt;/code&gt;. This ensures that these files are not automatically repaired. Without this option, the database can become inconsistent, because &lt;code&gt;Mnesia&lt;/code&gt; can believe that the files were properly closed. For information about configuration parameter &lt;code&gt;auto_repair&lt;/code&gt;, see the Reference Manual.</source>
          <target state="translated">的 &lt;code&gt;DAT&lt;/code&gt; 文件必须始终选项打开 &lt;code&gt;{repair, false}&lt;/code&gt; 。这样可以确保不会自动修复这些文件。没有此选项，数据库可能会变得不一致，因为 &lt;code&gt;Mnesia&lt;/code&gt; 可以认为文件已正确关闭。有关配置参数 &lt;code&gt;auto_repair&lt;/code&gt; 的信息，请参见《参考手册》。</target>
        </trans-unit>
        <trans-unit id="5873af1928aed9c59ec2db4bf69bcbdd1c33d63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Data&lt;/code&gt; received can be a &lt;code&gt;binary()&lt;/code&gt; or a &lt;code&gt;list()&lt;/code&gt; of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP event.</source>
          <target state="translated">根据套接字模式或SCTP事件，接收到的 &lt;code&gt;Data&lt;/code&gt; 可以是 &lt;code&gt;binary()&lt;/code&gt; 或字节的 &lt;code&gt;list()&lt;/code&gt; （0到255之间的整数）。</target>
        </trans-unit>
        <trans-unit id="69f5b6911daa714868434e1a90189319187674c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DbgExtra&lt;/code&gt; options are described in section &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;DbgExtra&lt;/code&gt; 选项在节中描述 &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16f5677b6ef24617d1e07a7aa94edc055731eaee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DiscoHandler&lt;/code&gt; module is used during the discovery process. See &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">所述 &lt;code&gt;DiscoHandler&lt;/code&gt; 模块在发现过程中使用。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="510046e751218ed5f95a1059673c4d8fbf2a7fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dst&lt;/code&gt; map is updated with new channel values. The syntax for updating an existing key with a new value is with the &lt;code&gt;:=&lt;/code&gt; operator.</source>
          <target state="translated">所述 &lt;code&gt;Dst&lt;/code&gt; 的图与新的信道值来更新。用新值更新现有键的语法是使用 &lt;code&gt;:=&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="30f4f4e3c2c9185266f65e6f7d9040faa980d49a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt; erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">所述 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 术语类型用于通过与所述编码的术语 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; ，即，已经由编码的术语 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt; erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; ，等等。例如，如果 &lt;code&gt;binp&lt;/code&gt; 是指向ErlDrvBinary的指针，而该 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 包含以 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 编码的术语 &lt;code&gt;{17, 4711}&lt;/code&gt; 17，4711 }，并且您想将其包装为带有标签 &lt;code&gt;my_tag&lt;/code&gt; 的两个元组，即 &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; ，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="d0e5af70acd62ed71f0140803a094eed25236db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">所述 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 术语类型用于通过与所述编码的术语 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; ，即，已经由编码的术语 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; ，等等。例如，如果 &lt;code&gt;binp&lt;/code&gt; 是指向ErlDrvBinary的指针，该指针包含用 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 编码的术语 &lt;code&gt;{17, 4711}&lt;/code&gt; &lt;code&gt;ErlDrvBinary&lt;/code&gt; }，并且您想将其包装成带有标签 &lt;code&gt;my_tag&lt;/code&gt; 的两个元组，即 &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; ，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="8c0ac01302ce56a5538e783afbe86c0e3ca92aac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; term is a way to construct strings. It works differently from how &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; works. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; builds a string list in reverse order (as opposed to how &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; works), concatenating the strings added to a list. The tail must be specified before &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 项是构建字符串的方法。它的工作方式与 &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; 的工作方式不同。 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 以相反的顺序构建字符串列表（与 &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 的工作方式相反），将添加到列表中的字符串连接起来。必须在 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 之前指定尾部。</target>
        </trans-unit>
        <trans-unit id="7fe5603a0b688982ee095c5b6eb8b3abf301f57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_UINT&lt;/code&gt;, &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt;, and &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term types were introduced in ERTS 5.6.</source>
          <target state="translated">该 &lt;code&gt;ERL_DRV_UINT&lt;/code&gt; ， &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 和 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 项类型ERTS 5.6进行了介绍。</target>
        </trans-unit>
        <trans-unit id="78c7a39595ca5fe9252d32999a603c6e910dd570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable can be used to store the complicated parameters in:</source>
          <target state="translated">所述 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 环境变量可以用于存储复杂参数中：</target>
        </trans-unit>
        <trans-unit id="0a3584a359b0427b176ceaff9674304e574ffce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Emakefile&lt;/code&gt; (if it exists) in the current directory is searched for compiler options for each module. If a given module does not exist in &lt;code&gt;Emakefile&lt;/code&gt; or if &lt;code&gt;Emakefile&lt;/code&gt; does not exist, the module is still compiled.</source>
          <target state="translated">在当前目录中的 &lt;code&gt;Emakefile&lt;/code&gt; （如果存在）中搜索每个模块的编译器选项。如果给定的模块不存在中 &lt;code&gt;Emakefile&lt;/code&gt; 或者 &lt;code&gt;Emakefile&lt;/code&gt; 不存在，该模块还在编制。</target>
        </trans-unit>
        <trans-unit id="da28c7ffe618c58fd36df47a840c22abe8ebdbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encoding&lt;/code&gt; says how the characters in the request are represented. We want to store the characters as lists in the ETS table, so we convert them to lists using function &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt;. The conversion function conveniently accepts the encoding types &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;latin1&lt;/code&gt;, so we can use &lt;code&gt;Encoding&lt;/code&gt; directly.</source>
          <target state="translated">该 &lt;code&gt;Encoding&lt;/code&gt; 表示，如何在请求中的字符表示。我们要将字符存储为ETS表中的列表，因此我们使用 &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt; 函数将它们转换为列表。转换函数方便地接受 &lt;code&gt;unicode&lt;/code&gt; 和 &lt;code&gt;latin1&lt;/code&gt; 编码类型，因此我们可以直接使用 &lt;code&gt;Encoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3c694d3baa325d31ca5ef434295459f7fd84d35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvBinary&lt;/code&gt; structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when &lt;code&gt;driver_binary_free&lt;/code&gt; is called, the reference count is decremented, when it reaches zero, the binary is deallocated. &lt;code&gt;orig_size&lt;/code&gt; is the binary size and &lt;code&gt;orig_bytes&lt;/code&gt; is the buffer. &lt;code&gt;ErlDrvBinary&lt;/code&gt; has not a fixed size, its size is &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 结构是二进制，因为仿真器和驱动器之间发送。所有二进制文件都以引用计数；调用 &lt;code&gt;driver_binary_free&lt;/code&gt; 时，引用计数递减，当引用计数达到零时，将释放二进制文件。 &lt;code&gt;orig_size&lt;/code&gt; 是二进制大小，而 &lt;code&gt;orig_bytes&lt;/code&gt; 是缓冲区。 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 没有固定大小，其大小为 &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c86b87f3b0b95eba095182c55f0fcc45cc6647fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvNowData&lt;/code&gt; structure holds a time stamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</source>
          <target state="translated">该 &lt;code&gt;ErlDrvNowData&lt;/code&gt; 结构包含由选自在过去的某个任意点处测量的三个值的时间戳。这三个结构成员是：</target>
        </trans-unit>
        <trans-unit id="4c525691955a7766948a2ab00688137550480556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">该 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构用于关于Erlang运行时系统信息的存储。当传递对 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构的引用时， &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 会写入系统信息。结构中的字段如下：</target>
        </trans-unit>
        <trans-unit id="89f846aa2a9d3bbb835eaa5c58e3ac257c0f2247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">该 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构用于关于Erlang运行时系统信息的存储。当传递对 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构的引用时， &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 会写入系统信息。结构中的字段如下：</target>
        </trans-unit>
        <trans-unit id="a097b8521d625c64b18dfa0ef6d0bb28ad84fb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library contains functions that help you integrate programs written in C and Erlang. The functions in &lt;code&gt;Erl_Interface&lt;/code&gt; support the following:</source>
          <target state="translated">该 &lt;code&gt;Erl_Interface&lt;/code&gt; 库包含了帮助您将C语言编写，Erlang程序的功能。 &lt;code&gt;Erl_Interface&lt;/code&gt; 中的函数支持以下功能：</target>
        </trans-unit>
        <trans-unit id="6e029ea371407136acd36ef3f94ae9b566be79a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;Erl_Interface&lt;/code&gt; 库支持这项活动。它具有创建和操作Erlang数据结构的几个C函数。下面的示例演示如何创建和编码Erlang元组 &lt;code&gt;{tobbe,3928}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c0bb8f936d4589865a80fe604ad9b594bedb70df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;Erl_Interface&lt;/code&gt; 库支持这项活动。它具有创建和操作Erlang数据结构的多个C函数。该库还包含编码和解码功能。下面的示例演示如何创建和编码Erlang元组 &lt;code&gt;{tobbe,3928}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57a4e297c09c6f1e5049ba6a6a04c4f9715c1746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorDesc&lt;/code&gt; returned is an opaque value to be passed further on to function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. For more control over the operation, use the &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">返回的 &lt;code&gt;ErrorDesc&lt;/code&gt; 是一个不透明的值，将进一步传递给函数 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。要对操作进行更多控制，请使用 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="0a7a560a95e6aefba3bb607f84b70fa45da9fcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned earlier is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure, which is returned from all I/O modules. It has the following format:</source>
          <target state="translated">前面提到的 &lt;code&gt;ErrorInfo&lt;/code&gt; 是标准的 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构，该结构从所有I / O模块返回。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="46cd6a74f6ad42247387aa8b77c1e43606850bb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned in this module is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure that is returned from all I/O modules. It has the following format:</source>
          <target state="translated">所述 &lt;code&gt;ErrorInfo&lt;/code&gt; 该模块中提到的是标准 &lt;code&gt;ErrorInfo&lt;/code&gt; 即从所有的I / O模块返回的结构。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="93b9c6c6a8848b5cb82997ba3624a2f0fabf1b76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Records&lt;/code&gt; in the Ets table are ordered by their timestamp. Which timestamp that should be used is controlled via the &lt;code&gt;event_order&lt;/code&gt; parameter. Default is &lt;code&gt;trace_ts&lt;/code&gt; which means the time when the trace data was generated. &lt;code&gt;event_ts&lt;/code&gt; means the time when the trace data was parsed (transformed into an &lt;code&gt;Event Record&lt;/code&gt;).</source>
          <target state="translated">Ets表中的 &lt;code&gt;Event Records&lt;/code&gt; 按其时间戳排序。通过 &lt;code&gt;event_order&lt;/code&gt; 参数控制应使用的时间戳。默认值为 &lt;code&gt;trace_ts&lt;/code&gt; ，这表示生成跟踪数据的时间。 &lt;code&gt;event_ts&lt;/code&gt; 表示解析跟踪数据（转换为 &lt;code&gt;Event Record&lt;/code&gt; ）的时间。</target>
        </trans-unit>
        <trans-unit id="78b79ae16c44e1321dea0365d3ec779b8f949891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses named filters in various contexts. An Event Trace filter is an &lt;code&gt;Erlang fun&lt;/code&gt; that takes some trace data as input and returns a possibly modified version of it:</source>
          <target state="translated">该 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 使用命名在各种情况下的过滤器。事件跟踪过滤器是 &lt;code&gt;Erlang fun&lt;/code&gt; 一个有趣功能，它将一些跟踪数据作为输入并返回其可能的修改版本：</target>
        </trans-unit>
        <trans-unit id="272a43aecd37d28c1a13622b7271bed26dc65387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</source>
          <target state="translated">该 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 用来收集和跟踪数据的图形查看内置在二郎山跟踪机制，并提供工具。</target>
        </trans-unit>
        <trans-unit id="7b3f5424185756e71f4988bcc6cd871d1c3dd01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expire&lt;/code&gt; time indicates for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">该 &lt;code&gt;Expire&lt;/code&gt; 时间表示请求的有效时间（在此之后，管理者可以自由地将其删除）。</target>
        </trans-unit>
        <trans-unit id="39bea9e5ae5bbc7a2dffd8b8ca100b554fe6e7ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 通过添加过滤器时参数被指定 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e6c34cadce8690c6e2555787337ac8b727e225e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 通过添加过滤器时参数被指定 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="727df65f2f4d2a5696a95b4aebc0f85f3f6e4431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 的参数 &lt;code&gt;domain/2&lt;/code&gt; 通过添加过滤器时指定的函数 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="229acf43839cafb043149ab1533fb570fa7aafb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 的参数 &lt;code&gt;domain/2&lt;/code&gt; 通过添加过滤器时指定的函数 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52e94c11f02389a5bccbbedf86c2e899b3c665d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraArgument&lt;/code&gt; parameter is the empty list. For example, when the agent receives a get-request for the &lt;code&gt;ipAdr&lt;/code&gt; variable, a call will be made to &lt;code&gt;ip_access(get)&lt;/code&gt;. The value returned by this function is the answer to the get-request.</source>
          <target state="translated">该 &lt;code&gt;ExtraArgument&lt;/code&gt; 参数为空表。例如，当代理收到对 &lt;code&gt;ipAdr&lt;/code&gt; 变量的get-request时，将调用 &lt;code&gt;ip_access(get)&lt;/code&gt; 。此函数返回的值是get-request的答案。</target>
        </trans-unit>
        <trans-unit id="fb7a37656b5be6c6e17b2389894ea550dae8ed86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on from the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;ExtraInfo&lt;/code&gt; 参数从传递 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="f30e53e02c0d2cd4e451fab992fbc868cf17c42e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on to the callback functions of the &lt;code&gt;DiscoHandler&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ExtraInfo&lt;/code&gt; 参数传递到的回调函数 &lt;code&gt;DiscoHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="289abc6fff4535554475e47566270dcbf6237037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Freeze&lt;/code&gt; button starts/stops the redrawing of the graph. &lt;code&gt;Reset&lt;/code&gt; moves the graph to the middle of the window and resets all graph settings to default, with the exception of deleted nodes.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Freeze&lt;/code&gt; 按钮开始/停止图形的重绘。 &lt;code&gt;Reset&lt;/code&gt; 将图形移至窗口的中间，并将所有图形设置重置为默认值，但删除的节点除外。</target>
        </trans-unit>
        <trans-unit id="0da0ebb6c63a989a7a4138310af5788ea3268e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserData,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserData&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">该 &lt;code&gt;Fun&lt;/code&gt; 被称为当焦油功能想要做一个低级别的操作，就像写一个块到一个文件中。的 &lt;code&gt;Fun&lt;/code&gt; 称为 &lt;code&gt;Fun(Op, {UserData,Parameters...})&lt;/code&gt; ，其中， &lt;code&gt;Op&lt;/code&gt; 是操作名称， &lt;code&gt;UserData&lt;/code&gt; 是作为第一个参数，以传递的术语 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;Parameters...&lt;/code&gt; 在数据通过所添加的tar函数将传递给存储处理函数。</target>
        </trans-unit>
        <trans-unit id="bb27036c1560c4a25ff7bd106092a75ea724c349" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserPrivate&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">该 &lt;code&gt;Fun&lt;/code&gt; 被称为当焦油功能想要做一个低级别的操作，就像写一个块到一个文件中。的 &lt;code&gt;Fun&lt;/code&gt; 称为 &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt; ，其中， &lt;code&gt;Op&lt;/code&gt; 是操作名称， &lt;code&gt;UserPrivate&lt;/code&gt; 是作为第一个参数，以传递的术语 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;Parameters...&lt;/code&gt; 在数据通过所添加的tar函数将传递给存储处理函数。</target>
        </trans-unit>
        <trans-unit id="5d186993003ed1ccd81976e2681cc3264ce79a2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as &lt;code&gt;add/3&lt;/code&gt;, &lt;code&gt;add/4&lt;/code&gt;, and &lt;code&gt;close/1&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;Fun&lt;/code&gt; 是当不同的存储操作功能是从更高的焦油处理函数调用做什么的定义（如 &lt;code&gt;add/3&lt;/code&gt; ， &lt;code&gt;add/4&lt;/code&gt; ，和 &lt;code&gt;close/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ca0ec970a34ee33c7f128926a1e15f48a39b7957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;foldl/3&lt;/code&gt; returns the final accumulator value. &lt;code&gt;Acc0&lt;/code&gt; is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception.</source>
          <target state="translated">该 &lt;code&gt;Fun&lt;/code&gt; 必须返回一个新的累加器，这是传递给下一个电话。 &lt;code&gt;foldl/3&lt;/code&gt; 返回最终的累加器值。如果存档为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。不必遍历存档中的所有文件。可以通过引发异常以受控的方式提前结束迭代。</target>
        </trans-unit>
        <trans-unit id="387a945d1ef3c3c3d8058c83966af63af2d4d8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt; section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang:</source>
          <target state="translated">该 &lt;code&gt;Guard&lt;/code&gt; 部还可以包含逻辑和算术运算，其被写入与相同的语法作为保护测试（前缀符号），所以下面的后卫测试Erlang编写：</target>
        </trans-unit>
        <trans-unit id="0ed2562e6fd2d312da06422aef22e77ebef5ba9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt;s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &lt;code&gt;'$1'&lt;/code&gt;, one would write the test as &lt;code&gt;{is_list, '$1'}&lt;/code&gt;. If the test fails, the object in the table does not match and the next &lt;code&gt;MatchFunction&lt;/code&gt; (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed &lt;code&gt;is_&lt;/code&gt; are allowed (&lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_atom&lt;/code&gt;, and so on).</source>
          <target state="translated">的 &lt;code&gt;Guard&lt;/code&gt; s的构造为元组，其中所述第一元件是所述测试名称和其余元件的测试参数。要检查绑定到匹配变量 &lt;code&gt;'$1'&lt;/code&gt; 的元素的特定类型（例如列表），可以将测试写为 &lt;code&gt;{is_list, '$1'}&lt;/code&gt; 。如果测试失败，则表中的对象不匹配，并尝试下一个 &lt;code&gt;MatchFunction&lt;/code&gt; （如果有）。目前在二郎大多数后卫的测试可以使用，但只有新版本的前缀 &lt;code&gt;is_&lt;/code&gt; 允许（ &lt;code&gt;is_float&lt;/code&gt; ， &lt;code&gt;is_atom&lt;/code&gt; ，等等）。</target>
        </trans-unit>
        <trans-unit id="3de2a50d3651924af28c65d29b6c75e407eb8165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HTTP&lt;/code&gt; version of the request, that is, &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;.</source>
          <target state="translated">请求的 &lt;code&gt;HTTP&lt;/code&gt; 版本，即&amp;ldquo; HTTP / 0.9&amp;rdquo;，&amp;ldquo; HTTP / 1.0&amp;rdquo;或&amp;ldquo; HTTP / 1.1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="462a5eb6a4e1b7237b73c6e94eed8c647d921612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostName&lt;/code&gt; will also be used in the hostname verification of the peer certificate using &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;HostName&lt;/code&gt; 也将在对等证书的主机名验证使用与用于 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fe5414d8d8a859939f8d4935fe18c2a11ba8b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Id&lt;/code&gt; identifies a CTH instance uniquely. If two CTHs return the same &lt;code&gt;Id&lt;/code&gt;, the second CTH is ignored and subsequent calls to the CTH are only made to the first instance. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">该 &lt;code&gt;Id&lt;/code&gt; 唯一标识一个CTH实例。如果两个CTH返回相同的 &lt;code&gt;Id&lt;/code&gt; ，则将忽略第二个CTH，并且仅对第一个实例进行对CTH的后续调用。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c260809e9afd9c349ba39adc0e706099bd4227f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InclNodes&lt;/code&gt; argument to &lt;code&gt;run/3&lt;/code&gt; is a list of node names. Function &lt;code&gt;run/3&lt;/code&gt; runs the tests in &lt;code&gt;TestSpecs&lt;/code&gt; just like &lt;code&gt;run/1&lt;/code&gt;, but also takes any test in &lt;code&gt;TestSpecs&lt;/code&gt;, which is not explicitly tagged with a particular node name, and execute it on the nodes listed in &lt;code&gt;InclNodes&lt;/code&gt;. By using &lt;code&gt;run/3&lt;/code&gt; this way, any test specification can be used, with or without node information, in a large-scale test environment.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 的 &lt;code&gt;InclNodes&lt;/code&gt; 参数是节点名称的列表。函数 &lt;code&gt;run/3&lt;/code&gt; 与 &lt;code&gt;run/1&lt;/code&gt; 一样在 &lt;code&gt;TestSpecs&lt;/code&gt; 中运行测试，但也可以在 &lt;code&gt;TestSpecs&lt;/code&gt; 中进行任何未显式标记有特定节点名称的测试，并在 &lt;code&gt;InclNodes&lt;/code&gt; 中列出的节点上执行该测试。通过以这种方式使用 &lt;code&gt;run/3&lt;/code&gt; ，可以在大规模测试环境中使用任何测试规范，无论有无节点信息。</target>
        </trans-unit>
        <trans-unit id="728f2fde5e1be51dec6dbadf7fd8bb23ae8a8436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InfoTuple&lt;/code&gt;s with the following items are part of the result:</source>
          <target state="translated">具有以下各项的 &lt;code&gt;InfoTuple&lt;/code&gt; 属于结果的一部分：</target>
        </trans-unit>
        <trans-unit id="18a616360c14e89869b3ee8a191e8982efcb7c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InitFun&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The returned &lt;code&gt;CryptoState&lt;/code&gt; is then folded into repeated applications of the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the &lt;code&gt;CloseFun&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;CloseFun&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">所述 &lt;code&gt;InitFun&lt;/code&gt; 被任何其他施加一次现有 &lt;code&gt;crypto&lt;/code&gt; 操作。然后将返回的 &lt;code&gt;CryptoState&lt;/code&gt; 折叠到 &lt;code&gt;EncryptFun&lt;/code&gt; 或 &lt;code&gt;DecryptFun&lt;/code&gt; 的重复应用程序中。这些功能返回的二进制文件将进一步发送到远程SFTP服务器。最后，如果进行加密，则将 &lt;code&gt;CloseFun&lt;/code&gt; 应用于最后一块数据。所述 &lt;code&gt;CloseFun&lt;/code&gt; 负责填充（如果需要）并加密该最后一块。</target>
        </trans-unit>
        <trans-unit id="f831068a66059cf58bd10807a62c5026adc8c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">该 &lt;code&gt;Install&lt;/code&gt; 脚本应该当前被调用为它驻留（顶层目录）的目录如下：</target>
        </trans-unit>
        <trans-unit id="151c25d0c87229840b1a357c4265bc6b194406ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script used when installing Erlang/OTP requires common Unix tools such as &lt;code&gt;sed&lt;/code&gt; to be present in your &lt;code&gt;$PATH&lt;/code&gt;. If your target system does not have such tools, you need to run the &lt;code&gt;Install&lt;/code&gt; script on your build machine before packaging Erlang/OTP. The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">安装Erlang / OTP时使用的 &lt;code&gt;Install&lt;/code&gt; 脚本需要 &lt;code&gt;$PATH&lt;/code&gt; Unix 中存在的通用Unix工具，例如 &lt;code&gt;sed&lt;/code&gt; 。如果目标系统没有这样的工具，则在打包Erlang / OTP之前，需要在构建计算机上运行 &lt;code&gt;Install&lt;/code&gt; 脚本。该 &lt;code&gt;Install&lt;/code&gt; 脚本应该当前被调用为它驻留（顶层目录）的目录如下：</target>
        </trans-unit>
        <trans-unit id="63ceadf10aefd8db61da0846c16f50dd4c57bf68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Issuer&lt;/code&gt; argument contains the issuer name of the certificate to be checked. Normally the returned CRL should be issued by this issuer, except if the &lt;code&gt;cRLIssuer&lt;/code&gt; field of &lt;code&gt;DistributionPoint&lt;/code&gt; has a value, in which case that value should be used instead.</source>
          <target state="translated">该 &lt;code&gt;Issuer&lt;/code&gt; 参数包含要检查的证书的颁发者的名字。通常，返回的CRL应该由此发行者发行，除非 &lt;code&gt;DistributionPoint&lt;/code&gt; 的 &lt;code&gt;cRLIssuer&lt;/code&gt; 字段具有值，在这种情况下，应使用该值代替。</target>
        </trans-unit>
        <trans-unit id="1df86fa6a13d4782f56f4b70368193619f74ccce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JCL&lt;/code&gt; commands have the following meaning:</source>
          <target state="translated">该 &lt;code&gt;JCL&lt;/code&gt; 命令的含义如下：</target>
        </trans-unit>
        <trans-unit id="eb0d6b265bbd8a2ede63c784c4e76e0b9b25a09c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; setting are to be consistent with what the terminal is capable of. There is no portable way for Erlang to ask the terminal about its UTF-8 capacity, we have to rely on the language and character type settings.</source>
          <target state="translated">该 &lt;code&gt;LANG&lt;/code&gt; 或 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置要与什么终端能够保持一致。Erlang没有可移植的方式向终端询问其UTF-8容量，我们必须依靠语言和字符类型设置。</target>
        </trans-unit>
        <trans-unit id="6dcd5eb8b8d30040b44118c19bb40f40ac2fd675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lin&lt;/code&gt; (&lt;code&gt;LLin&lt;/code&gt;, &lt;code&gt;XLin&lt;/code&gt;) operator assigns the lines where calls (local calls, external calls) are made. The &lt;code&gt;ELin&lt;/code&gt; operator assigns to each call (From, To), for which it is defined, every line L such that there is a chain of calls from From to To beginning with a call on line L.</source>
          <target state="translated">该 &lt;code&gt;Lin&lt;/code&gt; （ &lt;code&gt;LLin&lt;/code&gt; ， &lt;code&gt;XLin&lt;/code&gt; ）运算符受让人，其中电话（拨打本地电话，外线电话）制成的线。所述 &lt;code&gt;ELin&lt;/code&gt; 操作者分配给每个呼叫（从，到），它被定义为其中，每个线L，使得在调用链从从到要与线L的呼叫开始</target>
        </trans-unit>
        <trans-unit id="ddd6ecd801eba0297210dd779a386d2f9b34f307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListOfExtraArguments&lt;/code&gt; can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, &lt;code&gt;ipAdr&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt;, which will be in the MIB. The functions could be specified in a text file as follows:</source>
          <target state="translated">该 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; 可用于编写通用的功能。该列表被附加到每个函数的标准参数中。考虑设备的两个只读变量 &lt;code&gt;ipAdr&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; ，分别具有对象标识符1.1.23.4和1.1.7。要访问这些变量，可以实现两个Erlang函数 &lt;code&gt;ip_access&lt;/code&gt; 和 &lt;code&gt;name_access&lt;/code&gt; ，它们将在MIB中。可以在文本文件中指定功能，如下所示：</target>
        </trans-unit>
        <trans-unit id="e1503197789ab51916ae2782b9a6115c1230e790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; argument will be the same as the &lt;code&gt;Listen&lt;/code&gt; handle part of the return value of the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback above. &lt;code&gt;accept/1&lt;/code&gt; is called only once when the distribution protocol is started.</source>
          <target state="translated">在 &lt;code&gt;Listen&lt;/code&gt; 的说法将是一样的 &lt;code&gt;Listen&lt;/code&gt; 的返回值的手柄部分 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 回调以上。启动分发协议时， &lt;code&gt;accept/1&lt;/code&gt; 仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="431a15a498450f82a9cfae588ffa70427314b380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoadOrder&lt;/code&gt; priority is by default &lt;code&gt;0&lt;/code&gt; (zero) but can be set to any integer. The tables with the highest &lt;code&gt;LoadOrder&lt;/code&gt; priority are loaded first at startup.</source>
          <target state="translated">默认情况下， &lt;code&gt;LoadOrder&lt;/code&gt; 优先级为 &lt;code&gt;0&lt;/code&gt; （零），但可以设置为任何整数。具有最高 &lt;code&gt;LoadOrder&lt;/code&gt; 优先级的表将在启动时首先加载。</target>
        </trans-unit>
        <trans-unit id="c0d1ccb772696ffcb0ff02e3e38d3edd067a8070" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port message queue will never enter the busy state.</source>
          <target state="translated">该 &lt;code&gt;Low&lt;/code&gt; 限将自动调整到一样 &lt;code&gt;High&lt;/code&gt; ，如果它被设置更大然后 &lt;code&gt;High&lt;/code&gt; 。 &lt;code&gt;Low&lt;/code&gt; 和 &lt;code&gt;High&lt;/code&gt; 的值的有效范围是 &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt; 。如果通过了原子 &lt;code&gt;disabled&lt;/code&gt; ，则端口消息队列将永远不会进入繁忙状态。</target>
        </trans-unit>
        <trans-unit id="6ca11762016f06296699f63500e41a8f8017d459" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Low&lt;/code&gt; limit is automatically adjusted to the same as &lt;code&gt;High&lt;/code&gt; if it is set larger then &lt;code&gt;High&lt;/code&gt;. Valid range of values for &lt;code&gt;Low&lt;/code&gt; and &lt;code&gt;High&lt;/code&gt; is &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt;. If the atom &lt;code&gt;disabled&lt;/code&gt; is passed, the port will never enter the busy state.</source>
          <target state="translated">该 &lt;code&gt;Low&lt;/code&gt; 限将自动调整到一样 &lt;code&gt;High&lt;/code&gt; ，如果它被设置更大然后 &lt;code&gt;High&lt;/code&gt; 。 &lt;code&gt;Low&lt;/code&gt; 和 &lt;code&gt;High&lt;/code&gt; 的值的有效范围是 &lt;code&gt;[1, (1 bsl (8*erlang:system_info(wordsize)))-2]&lt;/code&gt; 。如果 &lt;code&gt;disabled&lt;/code&gt; atomic，则端口将永远不会进入繁忙状态。</target>
        </trans-unit>
        <trans-unit id="6ca1036527f7b7c9ab7ab8a36cae20db5fe67ec0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; configuration was as follows:</source>
          <target state="translated">的 &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 配置如下：</target>
        </trans-unit>
        <trans-unit id="d517f2a191b0a2929a426e74c5d9977a2a92791e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MIB.Object&lt;/code&gt; syntax is not implemented (since all objects must be unique anyway).</source>
          <target state="translated">该 &lt;code&gt;MIB.Object&lt;/code&gt; 语法未实现（因为所有的对象都必须是唯一反正）。</target>
        </trans-unit>
        <trans-unit id="431d9a802a4fe9bcef002e403293ba1753c616e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mac&lt;/code&gt; result will have a default length depending on the &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SubType&lt;/code&gt;. To set a shorter length, use &lt;code&gt;&lt;a href=&quot;#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; instead. The default length is documented in &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">在 &lt;code&gt;Mac&lt;/code&gt; 的结果将取决于有一个默认的长度 &lt;code&gt;Type&lt;/code&gt; 和 &lt;code&gt;SubType&lt;/code&gt; 。要设置较短的长度，请改用 &lt;code&gt;&lt;a href=&quot;#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; 。默认长度记录在《用户指南》的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; &amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="9b5dc880ea5414559476926c86f0abfef7e6942b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; for building the emulator currently defines the following symbols by using the &lt;code&gt;-D&lt;/code&gt; option on the command line for &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="translated">当前，用于构建仿真器的 &lt;code&gt;Makefile&lt;/code&gt; 通过在&lt;strong&gt;beam_makeops&lt;/strong&gt;的命令行上使用 &lt;code&gt;-D&lt;/code&gt; 选项来定义以下符号。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="636dca28dbd87863b36f206b257464a2e654c483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Max Carrier size&lt;/code&gt; column shows the maximum value seen by observer since the last node change or since the start of the application, i.e. switching nodes will reset the max column. Values are sampled so higher values may have existed than what is shown.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Max Carrier size&lt;/code&gt; 列显示观察者自上次节点更改或自应用程序启动以来看到的最大值，即交换节点将重置最大列。对值进行了采样，因此可能存在比所示更高的值。</target>
        </trans-unit>
        <trans-unit id="cc6e05d560929a4a9cfa001cecdf62f1726f815c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the &lt;code&gt;Mnesia&lt;/code&gt; DBMS transaction system is not suitable for hard real-time applications. However, &lt;code&gt;Mnesia&lt;/code&gt; contains other features that have real-time properties.</source>
          <target state="translated">该 &lt;code&gt;Mnesia&lt;/code&gt; 的程序员不能优先考虑一个特定的交易之前等待执行的其他交易中执行。结果， &lt;code&gt;Mnesia&lt;/code&gt; DBMS事务系统不适用于硬实时应用程序。但是， &lt;code&gt;Mnesia&lt;/code&gt; 包含其他具有实时属性的功能。</target>
        </trans-unit>
        <trans-unit id="2398df613eed0972c6702e33c30169f57db4a6c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; record identifiers (&lt;code&gt;{Tab, Key}&lt;/code&gt;) can also be used as references. In this case, attribute &lt;code&gt;dept&lt;/code&gt; would be set to value &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; instead of &lt;code&gt;'B/SFR'&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 的记录标识符（ &lt;code&gt;{Tab, Key}&lt;/code&gt; ）也可以用作参考。在这种情况下，属性 &lt;code&gt;dept&lt;/code&gt; 将设置为 &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; 而不是 &lt;code&gt;'B/SFR'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90246ca10a3686ec4547ee9155bf07c76827f547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</source>
          <target state="translated">该 &lt;code&gt;Mnesia&lt;/code&gt; 的交易系统提供以下重要特性来方便可靠，分布式系统的建设：</target>
        </trans-unit>
        <trans-unit id="05c05e9d6716d8728951521a8360d9cad3bf485c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transactions have four important properties, called &lt;strong&gt;A&lt;/strong&gt;tomicity, &lt;strong&gt;C&lt;/strong&gt;onsistency, &lt;strong&gt;I&lt;/strong&gt;solation, and &lt;strong&gt;D&lt;/strong&gt;urability (ACID). These properties are described in the following sections.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 的事务有四大特性，被称为&lt;strong&gt;一个&lt;/strong&gt; tomicity，&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt; onsistency，&lt;strong&gt;我&lt;/strong&gt;染料溶液，和&lt;strong&gt;d&lt;/strong&gt; urability（ACID）。这些属性在以下各节中描述。</target>
        </trans-unit>
        <trans-unit id="34969f65d94bd140bef4861a2be0633f1edd4059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Module:callback_mode()&lt;/code&gt; function may also return a list containing the callback mode and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; are activated for the callback mode.</source>
          <target state="translated">的 &lt;code&gt;Module:callback_mode()&lt;/code&gt; 函数也可以返回包含该回调模式和原子的列表 &lt;code&gt;state_enter&lt;/code&gt; 在这种情况下， &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; 被回调模式激活。</target>
        </trans-unit>
        <trans-unit id="40a0e269f3ccc50144dceff290b7ec1e5d3d30c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">该 &lt;code&gt;Msg&lt;/code&gt; 或者是二进制的&amp;ldquo;明文&amp;rdquo;的数据，或者它是&amp;ldquo;纯文本&amp;rdquo;，的散列值即，消化。</target>
        </trans-unit>
        <trans-unit id="aa7575828f011f723e11b39b2169db4b9db4b1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">该 &lt;code&gt;Msg&lt;/code&gt; 或者是二进制的&amp;ldquo;明文&amp;rdquo;的数据进行签名，或者它是&amp;ldquo;纯文本&amp;rdquo;，的散列值即，消化。</target>
        </trans-unit>
        <trans-unit id="caed8c29d6ad9904a92815ee1e45441de9aec981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; parameters have exactly the same meaning as when calling the plain function &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 参数具有完全相同的含义调用纯函数时，作为同一 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27916491cb8658a94525ccdce76cf8ccb4103b9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; field is the first element of the tuple.</source>
          <target state="translated">该 &lt;code&gt;Name&lt;/code&gt; 字段是元组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="771b9f2fcc80d7e7468afb27c626f330320484ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; is &lt;code&gt;&quot;sftp&quot;&lt;/code&gt; and &lt;code&gt;CbMod&lt;/code&gt; is the name of the Erlang module implementing the subsystem using the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour.</source>
          <target state="translated">该 &lt;code&gt;Name&lt;/code&gt; 是 &lt;code&gt;&quot;sftp&quot;&lt;/code&gt; 和 &lt;code&gt;CbMod&lt;/code&gt; 是实现使用子系统二郎神模块的名称 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; （取代ssh_daemon_channel）行为。</target>
        </trans-unit>
        <trans-unit id="3ca819160319b409a2f4c421438e5784e6c81c13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; specified is to correspond to the filename of the dynamically loadable object file residing in the directory specified as &lt;code&gt;Path&lt;/code&gt;, but &lt;strong&gt;without&lt;/strong&gt; the extension (that is, &lt;code&gt;.so&lt;/code&gt;). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as Erlang module names correspond to the names of the &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">指定的 &lt;code&gt;Name&lt;/code&gt; 对应于驻留在指定为 &lt;code&gt;Path&lt;/code&gt; 的目录中的动态可加载目标文件的文件名，但&lt;strong&gt;没有&lt;/strong&gt;扩展名（即 &lt;code&gt;.so&lt;/code&gt; ）。驱动程序初始化例程中提供的驱动程序名称必须与文件名相对应，与Erlang模块名称与 &lt;code&gt;.beam&lt;/code&gt; 文件的名称相对应的方式几乎相同。</target>
        </trans-unit>
        <trans-unit id="a8577668ea7b4d3a7d25c6ddf13c9da38e01e030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegotiationTimeout&lt;/code&gt; is in milli-seconds. The default value is &lt;code&gt;infinity&lt;/code&gt;. For connection timeout, use the option &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;NegotiationTimeout&lt;/code&gt; 是毫秒。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。对于连接超时，请使用选项 &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25cf803e685b877b848b6e92d88b9c3e6c3210a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is an important type and it is widely used within different standards to identify various objects uniquely. Dubuisson: ASN.1 - Communication Between Heterogeneous Systems includes an easy-to-understand description of the use of &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 是一个重要的类型和它被广泛不同的标准中用于唯一地标识各个对象。Dubuisson：ASN.1-异构系统之间的通信包括对目标 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 的使用的易于理解的描述。</target>
        </trans-unit>
        <trans-unit id="d89a49f90db529d1a87ec8ebe643fd609dd3d3b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; value is simply a tuple with the consecutive values, which must be integers.</source>
          <target state="translated">的 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 值是简单地与连续值，它必须是整数的元组。</target>
        </trans-unit>
        <trans-unit id="a30b8da746d4069e2cdb144e9b76560cd1897c56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; is now deprecated and has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Old API&lt;/code&gt; 现在已经过时并且也已 &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b07c15aa636f0544d2756cdbf51bdac039857354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Old API&lt;/code&gt; will be removed as of OTP 24. The support was formally deprecated as of OTP 23.</source>
          <target state="translated">自OTP 24起， &lt;code&gt;Old API&lt;/code&gt; 将被删除。自OTP 23起，该支持已被正式弃用。</target>
        </trans-unit>
        <trans-unit id="291813bf4581fd45b017cff8a605850835e5740d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Operation&lt;/code&gt; 可以是 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0de93bd973f344208a44803393d2336ed72a592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Operation&lt;/code&gt; 可以是 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dd3e602f768fecc29440b2334d159be22f01871" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for &quot;other&quot; options. The supported option(s) are described below:</source>
          <target state="translated">在 &lt;code&gt;Opts&lt;/code&gt; 论点适用于&amp;ldquo;其他&amp;rdquo;选项。支持的选项如下所述：</target>
        </trans-unit>
        <trans-unit id="98288c1e55f84bdd812985a5fd086264e78ad4f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; argument is intended for providing extra information for the open call:</source>
          <target state="translated">该 &lt;code&gt;Opts&lt;/code&gt; 参数用于提供公开征集额外的信息：</target>
        </trans-unit>
        <trans-unit id="1c435f50eeeff168b9ba4f24d7c44a547a62546d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; when only the &lt;code&gt;Module&lt;/code&gt; is specified.</source>
          <target state="translated">所述 &lt;code&gt;Opts&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 当只有 &lt;code&gt;Module&lt;/code&gt; 中指定。</target>
        </trans-unit>
        <trans-unit id="fb29cec4d8746b25b30ed76f21784b67fd7d4bbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Phone&lt;/code&gt; field is the third element.</source>
          <target state="translated">在 &lt;code&gt;Phone&lt;/code&gt; 领域是第三个元素。</target>
        </trans-unit>
        <trans-unit id="9a36c74c23cadea74c3943787187639b86600b99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pid&lt;/code&gt; is the process handling the supervision of the SNMP manager start. When the manager has started a completion message will be sent to the client from this process: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt;. If the SNMP manager was not started in time, a timeout message will be sent to the client: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Pid&lt;/code&gt; 是搬运过程SNMP管理器启动的监督。经理启动后，将通过以下过程将完成消息发送给客户端： &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt; 。如果SNMP管理器未及时启动，则会向客户端发送超时消息： &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b30293a63b2a3b26c593085f1e5a77514ed0092c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PingTO&lt;/code&gt; time specifies the between a successful ping (or start) and the time when a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; message is to be sent to the net-if process (basically the time between ping:s).</source>
          <target state="translated">所述 &lt;code&gt;PingTO&lt;/code&gt; 时间指定一个成功的ping之间（或开始），并且当所述时间 &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; 消息将被发送到网如果处理（基本上平之间的时间：秒）。</target>
        </trans-unit>
        <trans-unit id="523184d1586b2a64475008cf790d421779a2a4e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PongTO&lt;/code&gt; time specifies how long time the net-if process has to respond to a ping message, with a &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message. It starts counting when the ping message has been sent.</source>
          <target state="translated">该 &lt;code&gt;PongTO&lt;/code&gt; 时间指定的时间有多长净进程是否具有响应ping消息，有 &lt;code&gt;&lt;a href=&quot;snmp_manager_netif#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 消息。发送ping消息后，它开始计数。</target>
        </trans-unit>
        <trans-unit id="5ad1ec7b826ce17efed8a480d14fb2c2d7c83c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ProtocolVersion&lt;/code&gt; version is the version actually encoded in the reply message.</source>
          <target state="translated">该 &lt;code&gt;ProtocolVersion&lt;/code&gt; 版本是在回复消息实际编码的版本。</target>
        </trans-unit>
        <trans-unit id="cc15bf57b674de665a3aa4e09be58f12e93f6528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RELATIVE-OID&lt;/code&gt; type for relative object identifiers is fully supported.</source>
          <target state="translated">完全支持相对对象标识符的 &lt;code&gt;RELATIVE-OID&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="500392beab058916677f3be61233265c489d27bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; parameter in the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; user callback function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; 用户回调函数中的 &lt;code&gt;Reason&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="6b9fce90dd7e0310098f64ad13d29f2262c2551d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; returned value if any of the sync/async get/get-next/set/get-bulk functions returns &lt;code&gt;{error, Reason}&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;Reason&lt;/code&gt; 返回的值是否有任何同步/异步获取/ GET-下一个/组/取块函数返回 &lt;code&gt;{error, Reason}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adaa6337c0136bccefb9d645f47ac7a3dea29f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReplyData&lt;/code&gt; defaults to &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt;, but may be explicitly overridden by a &lt;code&gt;megaco:cast/3&lt;/code&gt; option in order to forward info about the calling context of the originating process.</source>
          <target state="translated">该 &lt;code&gt;ReplyData&lt;/code&gt; 默认为 &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt; ，但可以通过显式覆盖 &lt;code&gt;megaco:cast/3&lt;/code&gt; 选项以约始发过程的调用上下文向前信息。</target>
        </trans-unit>
        <trans-unit id="5dcd8c369c6500e932ff1e1629f6fafbdc39108e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;Request-Line&lt;/code&gt; ，例如 &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="560f996f8e0b32b35d673e574bfba7c7f5732599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;Request-URI&lt;/code&gt; ，例如 &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cc862e08384f6496c068b1ef00d8543bcd2fea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request&lt;/code&gt; element can in itself contain many &lt;code&gt;Request&lt;/code&gt;s by using the following format:</source>
          <target state="translated">通过使用以下格式， &lt;code&gt;Request&lt;/code&gt; 元素本身可以包含许多 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df3736ae6d527f6dc758c7bc44a6f372a5715a61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Root directory&lt;/code&gt; can be edited by selecting the line where the path of the root directory is displayed and clicking the right mouse button. Choose edit in the menu that pops up.</source>
          <target state="translated">的 &lt;code&gt;Root directory&lt;/code&gt; 可以通过选择在显示的根目录的路径的线并点击鼠标右键进行编辑。在弹出的菜单中选择&amp;ldquo;编辑&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="84770d839ef4e410e85af06b8af1e00bd08e41e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RowIndex&lt;/code&gt; argument may refer to an existing row or a non-existing row, or it may be unspecified. The &lt;code&gt;Cols&lt;/code&gt; list may refer to inaccessible columns or non-existing columns. For each column in the &lt;code&gt;Cols&lt;/code&gt; list, the corresponding next instance is determined, and the last part of its OBJECT IDENTIFIER and its value is returned.</source>
          <target state="translated">所述 &lt;code&gt;RowIndex&lt;/code&gt; 参数可以是指现有的行或不存在的行，或它可以是未指定的。该 &lt;code&gt;Cols&lt;/code&gt; 列表可参考不可访问的列或不存在的柱。对于 &lt;code&gt;Cols&lt;/code&gt; 列表中的每一列，都会确定相应的下一个实例，并返回其对象标识符的最后一部分及其值。</target>
        </trans-unit>
        <trans-unit id="b8d86bbb9ebe74c2dccf692588c950366f9986be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SecurityCallbackModule&lt;/code&gt; is a user-written module that can receive events from the &lt;code&gt;mod_security&lt;/code&gt; Erlang web server API module. This module only exports the functions event/[4,5] which are described here.</source>
          <target state="translated">该 &lt;code&gt;SecurityCallbackModule&lt;/code&gt; 是可以接收来自事件的用户编写的模块 &lt;code&gt;mod_security&lt;/code&gt; 的二郎山Web服务器API模块。该模块仅导出此处描述的功能event / [4,5]。</target>
        </trans-unit>
        <trans-unit id="6af65a9600faa054b3af4ac9bf04b32c2eda0702" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SeqCnt&lt;/code&gt; values in the filenames are all in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;WrapCnt&lt;/code&gt; with a gap in the circular sequence. The gap is needed to find the end of the trace.</source>
          <target state="translated">文件名中的 &lt;code&gt;SeqCnt&lt;/code&gt; 值都在 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;WrapCnt&lt;/code&gt; 的范围内，循环序列中有一个间隔。需要间隙来找到轨迹的末端。</target>
        </trans-unit>
        <trans-unit id="c2214d4ed634c1087714e34b7518b2efdc6127b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; or the &lt;code&gt;TypeSpecifier&lt;/code&gt;, or both, can be omitted. Thus, the following variants are allowed:</source>
          <target state="translated">在 &lt;code&gt;Size&lt;/code&gt; 或 &lt;code&gt;TypeSpecifier&lt;/code&gt; ，或两者，可以省略。因此，允许以下变体：</target>
        </trans-unit>
        <trans-unit id="4401af203194a6b8a2b7ece91e21c535b2bfb4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; part of the segment multiplied by the unit in &lt;code&gt;TypeSpecifierList&lt;/code&gt; (described later) gives the number of bits for the segment. In construction, &lt;code&gt;Size&lt;/code&gt; is any expression that evaluates to an integer. In matching, &lt;code&gt;Size&lt;/code&gt; must be a constant expression or a variable.</source>
          <target state="translated">段的 &lt;code&gt;Size&lt;/code&gt; 部分乘以 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 中的单位（稍后描述）可得出该段的位数。在构造中， &lt;code&gt;Size&lt;/code&gt; 是任何计算结果为整数的表达式。在匹配中， &lt;code&gt;Size&lt;/code&gt; 必须是常量表达式或变量。</target>
        </trans-unit>
        <trans-unit id="fa124ccd13ea8b5e4811fb40dda4e89bf8e0ab6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Socket&lt;/code&gt; shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined.</source>
          <target state="translated">该 &lt;code&gt;Socket&lt;/code&gt; 应在调用这个函数，否则这个函数的行为是未定义之前处于被动模式（{活跃，假}）。</target>
        </trans-unit>
        <trans-unit id="71d2c0146fa0a8ad0d23a9f16dafb29d093033b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State0&lt;/code&gt; is the State value originally from a MAC init function, that is &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac_init/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; or a previous call of &lt;code&gt;mac_update/2&lt;/code&gt;. The value &lt;code&gt;State0&lt;/code&gt; is returned unchanged by the function as &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;State0&lt;/code&gt; 最初是从一个MAC init函数国家值，即 &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac_init/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; 或先前呼叫 &lt;code&gt;mac_update/2&lt;/code&gt; 。 &lt;code&gt;State0&lt;/code&gt; 函数通过 &lt;code&gt;State&lt;/code&gt; 不变地返回值State0。</target>
        </trans-unit>
        <trans-unit id="9a112d3244fe07cff9e8f015a14975b38bd7df44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StatisticsSpec&lt;/code&gt; is a list of the tuples:</source>
          <target state="translated">该 &lt;code&gt;StatisticsSpec&lt;/code&gt; 是元组的列表：</target>
        </trans-unit>
        <trans-unit id="7eae7e5127eb1df08b89e0018b0917cb18f30c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SupFlags&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; represents the &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; 返回值中的 &lt;code&gt;SupFlags&lt;/code&gt; 变量表示 &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b2315a984f49c0998e8d5af6001ef3acd45c41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TEST&lt;/code&gt; macro can also be used to override the &lt;code&gt;NOTEST&lt;/code&gt; macro. If &lt;code&gt;TEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included (even if &lt;code&gt;NOTEST&lt;/code&gt; is also defined), then the code will be compiled with EUnit enabled.</source>
          <target state="translated">该 &lt;code&gt;TEST&lt;/code&gt; 宏还可以用来覆盖 &lt;code&gt;NOTEST&lt;/code&gt; 宏。如果&lt;strong&gt;在&lt;/strong&gt;包含EUnit头文件&lt;strong&gt;之前&lt;/strong&gt;定义了 &lt;code&gt;TEST&lt;/code&gt; （即使还定义了 &lt;code&gt;NOTEST&lt;/code&gt; ），则将在启用EUnit的情况下编译代码。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="838665ed4c5367a2b5c2a4be4ad60949587a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.</source>
          <target state="translated">该 &lt;code&gt;TarDescriptor&lt;/code&gt; 项不是文件描述符。建议您不要依赖此术语的具体内容，因为当向该模块添加更多功能时，它可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="465bc37c25caf4b34efb2c4086ab264294ebb922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module..</source>
          <target state="translated">该 &lt;code&gt;TarDescriptor&lt;/code&gt; 项不是文件描述符。建议您不要依赖此术语的具体内容，因为当向该模块添加更多功能时，它可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="0454f0125983aa193be8922f905a4526ad0af9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; is the time the request is valid. The value has to be greater then zero.</source>
          <target state="translated">该 &lt;code&gt;Timeout&lt;/code&gt; 是请求有效的时间。该值必须大于零。</target>
        </trans-unit>
        <trans-unit id="7d17ac7ee8e9756a5bbf3de834214c031df9a61a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; parameter is for the actual tls upgrade (phase 2) while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for the initial negotiation about upgrade (phase 1).</source>
          <target state="translated">的 &lt;code&gt;Timeout&lt;/code&gt; 参数是实际的TLS升级而在超时（阶段2） &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 被用于有关升级（阶段1）在初始协商。</target>
        </trans-unit>
        <trans-unit id="2880ac4f009b868dac04469b39959fc855b2bc2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; value in milliseconds sets an upper time limit for all &lt;code&gt;call&lt;/code&gt; operations to complete.</source>
          <target state="translated">在 &lt;code&gt;Timeout&lt;/code&gt; 毫秒值设置为所有的时间上限 &lt;code&gt;call&lt;/code&gt; 操作完成。</target>
        </trans-unit>
        <trans-unit id="7e76487200ab118ffd183bce3e76d073d0b42eca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Trace Pattern&lt;/code&gt; is basically a tuple of a &lt;code&gt;module&lt;/code&gt; and a &lt;code&gt;detail level&lt;/code&gt; (either an integer or the atom max for full detail). In most cases the &lt;code&gt;Trace Pattern&lt;/code&gt;&lt;code&gt;{et,max}&lt;/code&gt; does suffice. But if you do not want any runtime dependency of &lt;code&gt;et&lt;/code&gt; you can implement your own &lt;code&gt;trace_me/5&lt;/code&gt; function in some module and refer to that module in the &lt;code&gt;Trace Pattern&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Trace Pattern&lt;/code&gt; 基本上是一个元组 &lt;code&gt;module&lt;/code&gt; 和 &lt;code&gt;detail level&lt;/code&gt; （整数或原子最大为全部细节）。在大多数情况下， &lt;code&gt;Trace Pattern&lt;/code&gt; &lt;code&gt;{et,max}&lt;/code&gt; 就足够了。但是，如果您不希望 &lt;code&gt;et&lt;/code&gt; 的任何运行时依赖性，则可以在某个模块中实现自己的 &lt;code&gt;trace_me/5&lt;/code&gt; 函数，并在&amp;ldquo; &lt;code&gt;Trace Pattern&lt;/code&gt; 引用该模块。</target>
        </trans-unit>
        <trans-unit id="c7f49e5bd7c0b07a911f5147dffd68a5a99e4dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceStartOption&lt;/code&gt; is any option allowed for &lt;code&gt;trace/1&lt;/code&gt;. The options &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; are given to &lt;code&gt;trace/1&lt;/code&gt;, where &lt;code&gt;OptList&lt;/code&gt; is &lt;code&gt;OptionList&lt;/code&gt; with &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;{procs, _}&lt;/code&gt; options removed.</source>
          <target state="translated">该 &lt;code&gt;TraceStartOption&lt;/code&gt; 是允许任何选项 &lt;code&gt;trace/1&lt;/code&gt; 。选项 &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; 分配给 &lt;code&gt;trace/1&lt;/code&gt; ，其中 &lt;code&gt;OptList&lt;/code&gt; 是 &lt;code&gt;OptionList&lt;/code&gt; ，其中删除了 &lt;code&gt;continue&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;{procs, _}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d2aed641ea18d80129eeabfddfeb6dc4dea97713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceTag&lt;/code&gt;&lt;code&gt;seq_trace&lt;/code&gt; is handled slightly differently. There is no &lt;code&gt;Tracee&lt;/code&gt; for &lt;code&gt;seq_trace&lt;/code&gt;, instead the &lt;code&gt;Label&lt;/code&gt; associated with the &lt;code&gt;seq_trace&lt;/code&gt; event is specified.</source>
          <target state="translated">该 &lt;code&gt;TraceTag&lt;/code&gt; &lt;code&gt;seq_trace&lt;/code&gt; 略有不同的处理。没有 &lt;code&gt;Tracee&lt;/code&gt; 对 &lt;code&gt;seq_trace&lt;/code&gt; ，而不是 &lt;code&gt;Label&lt;/code&gt; 与相关 &lt;code&gt;seq_trace&lt;/code&gt; 指定事件。</target>
        </trans-unit>
        <trans-unit id="0e7aee8b9587689f8640e087123cb9269b76c67d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeSpecifierList&lt;/code&gt; is a list of type specifiers separated by hyphens.</source>
          <target state="translated">该 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 是用连字符隔开类型说明符的列表。</target>
        </trans-unit>
        <trans-unit id="cf30b67e2b9d6eefe96e2a44b56b701c3a71843b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Value&lt;/code&gt; part is any expression, when used in binary construction. Used in binary matching, the &lt;code&gt;Value&lt;/code&gt; part must be a literal or a variable. For more information about the &lt;code&gt;Value&lt;/code&gt; part, see &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当用于二进制构造时， &lt;code&gt;Value&lt;/code&gt; 部分是任何表达式。在二进制匹配中使用，&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 部分必须是文字或变量。有关&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 部分的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db41e1083994609150ba03a58467ce1564f93559" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will automatically pull events from the &lt;code&gt;Collector&lt;/code&gt; and display them on the screen.</source>
          <target state="translated">该 &lt;code&gt;Viewer&lt;/code&gt; 将自动从拉事件 &lt;code&gt;Collector&lt;/code&gt; ，并在屏幕上显示出来。</target>
        </trans-unit>
        <trans-unit id="8afb3e18be8e7e2fb56c7adc4a8999ad88a05635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will by default create a &lt;code&gt;Collector&lt;/code&gt; for you. With a few options and some configuration settings you can start collecting &lt;code&gt;Events&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;Viewer&lt;/code&gt; 将为您创建一个 &lt;code&gt;Collector&lt;/code&gt; 。使用一些选项和一些配置设置，您可以开始收集 &lt;code&gt;Events&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12a1a53435b86d328cae136152477d1bdb078001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XXL&lt;/code&gt; operator is defined for the interpretation of any of the LineOp operators applied to a set of function calls. The result is that of replacing the function call with a line numbered function call, that is, each of the two functions of the call is replaced by a pair of the function and the line where the function is defined. The effect of the &lt;code&gt;XXL&lt;/code&gt; operator can be undone by the LineOp operators. For instance, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; is equivalent to &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;XXL&lt;/code&gt; 操作者对任何应用到一组函数调用LineOp运营商的解释定义。结果是用行编号的函数调用替换了函数调用，也就是说，该调用的两个函数中的每一个都被一对函数和定义函数的那一行替换。该效果 &lt;code&gt;XXL&lt;/code&gt; 运营商可以通过LineOp运营商百废待兴。例如， &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; 等效于 &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="773f8eacbf90d517d7610d94842c0bab01a3934c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ZipHandle&lt;/code&gt; is closed if the process that originally opened the archive dies.</source>
          <target state="translated">该 &lt;code&gt;ZipHandle&lt;/code&gt; 如果过程最初打开存档模具被关闭。</target>
        </trans-unit>
        <trans-unit id="557e22236c78cd7d079417146126bba5baaa6036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[&amp;lt;&amp;lt;&quot;First bytes&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;Second bytes&quot;&amp;gt;&amp;gt;]&lt;/code&gt; could of course have been one single binary: &lt;code&gt;&amp;lt;&amp;lt;&quot;First bytesSecond bytes&quot;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;[&amp;lt;&amp;lt;&quot;First bytes&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;Second bytes&quot;&amp;gt;&amp;gt;]&lt;/code&gt; 当然可以过一个单一的二进制： &lt;code&gt;&amp;lt;&amp;lt;&quot;First bytesSecond bytes&quot;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a10f4396b335e787b9182ce75a8ccae749ae857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_test&lt;/code&gt; macro takes any expression (the &quot;body&quot;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</source>
          <target state="translated">该 &lt;code&gt;_test&lt;/code&gt; 宏接受任何表情（以下简称&amp;ldquo;机构&amp;rdquo;）作为参数，和一个有趣的表达式中放置它（有一些额外的信息一起）。主体可以是任何类型的测试表达式，就像简单的测试函数的主体一样。</target>
        </trans-unit>
        <trans-unit id="21e2f2fedc48b32638d6fb2b72fe74559f091a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call does &lt;strong&gt;not&lt;/strong&gt; have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</source>
          <target state="translated">在 &lt;code&gt;accept&lt;/code&gt; 电话并&lt;strong&gt;没有&lt;/strong&gt;必须从插座所有者进程发出。使用5.5.3版和更高版本的仿真器，可以从不同的进程发出多个同时的接受调用，从而允许一组处理传入连接的接受器进程。</target>
        </trans-unit>
        <trans-unit id="118d34eb87604b965b95931c52d7927f1d1dca61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; arguments are both input and output arguments. When called &lt;code&gt;addr&lt;/code&gt; points to an address structure of lenght &lt;code&gt;*len&lt;/code&gt; containing information on how to bind the socket. Uppon return this callback should have updated the structure referred by &lt;code&gt;addr&lt;/code&gt; with information on how the socket actually was bound. &lt;code&gt;*len&lt;/code&gt; should be updated to reflect the size of &lt;code&gt;*addr&lt;/code&gt; updated. &lt;code&gt;backlog&lt;/code&gt; identifies the size of the backlog for the listen socket.</source>
          <target state="translated">该 &lt;code&gt;addr&lt;/code&gt; 和 &lt;code&gt;len&lt;/code&gt; 个参数是输入和输出参数。当被调用时， &lt;code&gt;addr&lt;/code&gt; 指向长度为 &lt;code&gt;*len&lt;/code&gt; 的地址结构，其中包含有关如何绑定套接字的信息。 Uppon返回此回调应已使用有关套接字实际绑定方式的信息更新了 &lt;code&gt;addr&lt;/code&gt; 引用的结构。 &lt;code&gt;*len&lt;/code&gt; 应该更新，以反映 &lt;code&gt;*addr&lt;/code&gt; 更新的大小。 &lt;code&gt;backlog&lt;/code&gt; 标识用于侦听套接字的待办事项的大小。</target>
        </trans-unit>
        <trans-unit id="d5a0f81704a04cf2f958a3cb5b26d7a07f57fb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; argument of the &lt;code&gt;listen&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, and &lt;code&gt;connect&lt;/code&gt; callbacks refer to appropriate address structure for currently used protocol. Currently &lt;code&gt;ei&lt;/code&gt; only supports IPv4. That is, at this time &lt;code&gt;addr&lt;/code&gt; always points to a &lt;code&gt;struct sockaddr_in&lt;/code&gt; structure.</source>
          <target state="translated">&lt;code&gt;listen&lt;/code&gt; ， &lt;code&gt;accept&lt;/code&gt; 和 &lt;code&gt;connect&lt;/code&gt; 回调的 &lt;code&gt;addr&lt;/code&gt; 参数引用当前使用协议的适当地址结构。目前， &lt;code&gt;ei&lt;/code&gt; 仅支持IPv4。也就是说，此时 &lt;code&gt;addr&lt;/code&gt; 始终指向 &lt;code&gt;struct sockaddr_in&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="b97c48085c09e86337df00a4b0a18e9e9f983484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apread/4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;apread/4&lt;/code&gt; 功能从指定的位置读出，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="6e1ba830557bf0975fcfe18ee483f0f3bec5d278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apwrite/4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;apwrite/4&lt;/code&gt; 函数写入到指定的位置，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="00d3c3634428cbc77b5aceea9f983ec649758967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert&lt;/code&gt; macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example:</source>
          <target state="translated">该 &lt;code&gt;assert&lt;/code&gt; 宏可以在程序中使用的任何地方，不只是在单元测试，以检查前/后置条件和不变量。例如：</target>
        </trans-unit>
        <trans-unit id="108ceadd98496de12d8902f0058bac96f4aa9204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is passed to the &lt;code&gt;do_perm&lt;/code&gt; function. We do not use a &lt;code&gt;async_free&lt;/code&gt; function (the last argument to &lt;code&gt;driver_async&lt;/code&gt;), it is only used if the task is cancelled programmatically.</source>
          <target state="translated">该 &lt;code&gt;async_data&lt;/code&gt; 传递给 &lt;code&gt;do_perm&lt;/code&gt; 功能。我们不使用 &lt;code&gt;async_free&lt;/code&gt; 功能（最后一个参数 &lt;code&gt;driver_async&lt;/code&gt; ），它只是用来当任务以编程方式取消。</target>
        </trans-unit>
        <trans-unit id="4cd04a38dd6fcdc2cd251ae665b899f10977e42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is the argument to the functions &lt;code&gt;async_invoke&lt;/code&gt; and &lt;code&gt;async_free&lt;/code&gt;. It is typically a pointer to a structure containing a pipe or event that can be used to signal that the async operation completed. The data is to be freed in &lt;code&gt;async_free&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;async_data&lt;/code&gt; 是参数的功能 &lt;code&gt;async_invoke&lt;/code&gt; 和 &lt;code&gt;async_free&lt;/code&gt; 。它通常是指向包含管道或事件的结构的指针，该管道或事件可用于指示异步操作已完成。数据将在 &lt;code&gt;async_free&lt;/code&gt; 中释放。</target>
        </trans-unit>
        <trans-unit id="10c62ebaa7dc721acc77acfe725a467db8e1f296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atom()&lt;/code&gt; value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#page-49&quot;&gt;draft-ietf-secsh-filexfer-13&lt;/a&gt;&lt;/code&gt; section 9.1. The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">如 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#page-49&quot;&gt;draft-ietf-secsh-filexfer-13&lt;/a&gt;&lt;/code&gt; 第9.1节所定义， &lt;code&gt;atom()&lt;/code&gt; 值由协议级别响应中的sftp错误代码形成。这些代码被命名为 &lt;code&gt;SSH_FX_*&lt;/code&gt; ，它们被转换为星号的小写字母。例如，错误代码 &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; 将导致 &lt;code&gt;reason()&lt;/code&gt; 为 &lt;code&gt;no_such_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61c5f2724e8a89f933cb80bf3b2eb6cc8b3b6977" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;avg1/0&lt;/code&gt;, &lt;code&gt;avg5/0&lt;/code&gt;, and &lt;code&gt;avg15/0&lt;/code&gt; functions can be used for retrieving system load values, and the &lt;code&gt;util/0&lt;/code&gt; and &lt;code&gt;util/1&lt;/code&gt; functions can be used for retrieving CPU utilization values.</source>
          <target state="translated">所述 &lt;code&gt;avg1/0&lt;/code&gt; ， &lt;code&gt;avg5/0&lt;/code&gt; ，和 &lt;code&gt;avg15/0&lt;/code&gt; 函数可以用于检索系统的负载值，并且 &lt;code&gt;util/0&lt;/code&gt; 和 &lt;code&gt;util/1&lt;/code&gt; 可用于检索CPU利用率值的函数。</target>
        </trans-unit>
        <trans-unit id="a43d2dcf5e0e967eda5efa53bd70665dc5d59efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blog()&lt;/code&gt; functions can also be used for internally formatted logs, but in this case they must be called with binaries constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; and automatic repair functions fail. The corresponding terms (not the binaries) are returned when &lt;code&gt;chunk/2,3&lt;/code&gt; is called.</source>
          <target state="translated">该 &lt;code&gt;blog()&lt;/code&gt; 函数也可以用于内部格式的日志，但在这种情况下，他们必须与调用构造二进制文件被称为 &lt;code&gt;term_to_binary/1&lt;/code&gt; 。没有检查可以确保这一点，这完全是呼叫者的责任。如果使用与Erlang项不对应的二进制文件来调用这些函数，则 &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; 和自动修复函数将失败。当调用 &lt;code&gt;chunk/2,3&lt;/code&gt; 时，将返回相应的项（不是二进制文件）。</target>
        </trans-unit>
        <trans-unit id="c6a9390501bbca6818af22e2d682ca803f60bdab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; operand can encode any literal value, including NIL. The &lt;code&gt;n&lt;/code&gt; operand only works for NIL. If we have the generic instruction &lt;code&gt;{move,nil,{x,1}}&lt;/code&gt;, the loader will translate it to &lt;code&gt;move_nx 1&lt;/code&gt; because &lt;code&gt;move n x&lt;/code&gt; is more specific. &lt;code&gt;move_nx&lt;/code&gt; could be slightly faster or smaller (depending on the architecture), because the &lt;code&gt;[]&lt;/code&gt; is not stored explicitly as an operand.</source>
          <target state="translated">该 &lt;code&gt;c&lt;/code&gt; 操作数可以编码任何文字值，包括NIL。该 &lt;code&gt;n&lt;/code&gt; 操作仅适用于无。如果我们有通用指令 &lt;code&gt;{move,nil,{x,1}}&lt;/code&gt; ，则加载器会将其转换为 &lt;code&gt;move_nx 1&lt;/code&gt; ,因为 &lt;code&gt;move n x&lt;/code&gt; 更具体。 &lt;code&gt;move_nx&lt;/code&gt; 可能更快或更小（取决于体系结构），因为 &lt;code&gt;[]&lt;/code&gt; 没有显式存储为操作数。</target>
        </trans-unit>
        <trans-unit id="9287c794d6838f0d9c560c6cf16a390d870948c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call()&lt;/code&gt; function only returns if the applied function successfully returned without raising any uncaught exceptions, the operation did not time out, and no failures occurred. In all other cases an exception is raised. The following exceptions, listed by exception class, can currently be raised by &lt;code&gt;erpc:call()&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;call()&lt;/code&gt; 函数只有在应用的功能，而不引起任何未捕获的异常成功返回返回，该操作未超时，无故障发生。在所有其他情况下，都会引发异常。 &lt;code&gt;erpc:call()&lt;/code&gt; 当前可以引发由异常类列出的以下异常：</target>
        </trans-unit>
        <trans-unit id="725661331a506e2dce5360076476c39f4c67eeff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node raised an exception of class &lt;code&gt;Class&lt;/code&gt; with exception reason &lt;code&gt;ExceptionReason&lt;/code&gt;. These corresponds the the exceptions that &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call/5&lt;/a&gt;&lt;/code&gt; can raise.</source>
          <target state="translated">此特定节点的 &lt;code&gt;call&lt;/code&gt; 操作引发了类 &lt;code&gt;Class&lt;/code&gt; 的异常，异常原因为 &lt;code&gt;ExceptionReason&lt;/code&gt; 。这些对应于 &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call/5&lt;/a&gt;&lt;/code&gt; 可能引发的异常。</target>
        </trans-unit>
        <trans-unit id="3190218027bddfcb10c66d83569c4e030fe8e281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; operation for this specific node returned &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">此特定节点的 &lt;code&gt;call&lt;/code&gt; 操作返回 &lt;code&gt;Result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20c4b6b511dd79e662208e902c57d062a8c73aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call_ext&lt;/code&gt; instruction can be used to call functions written in Erlang as well as BIFs (or more properly called SNIFs). The &lt;code&gt;u$is_bif&lt;/code&gt; constraint will match if the operand refers to a BIF (that is, if it is listed in the file &lt;code&gt;bif.tab&lt;/code&gt;). Note that &lt;code&gt;u$is_bif&lt;/code&gt; should only be applied to operands that are known to contain an index to the import table chunk in the BEAM file (such operands have the type &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt; in the corresponding specific instruction). If applied to other &lt;code&gt;u&lt;/code&gt; operands, it will at best return a nonsense result.</source>
          <target state="translated">所述 &lt;code&gt;call_ext&lt;/code&gt; 指令可用于写入二郎以及内建函数（或更恰当地称为SNIFs）呼叫功能。该 &lt;code&gt;u$is_bif&lt;/code&gt; 如果操作数是指BIF（即，如果它在文件中列出的约束将匹配 &lt;code&gt;bif.tab&lt;/code&gt; ）。请注意， &lt;code&gt;u$is_bif&lt;/code&gt; 仅应应用于已知包含BEAM文件中的导入表块索引的操作数（此类操作数在相应的特定指令中具有 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;e&lt;/code&gt; 类型）。如果应用于其他 &lt;code&gt;u&lt;/code&gt; 操作数，则最多将返回无意义的结果。</target>
        </trans-unit>
        <trans-unit id="37d74f76daa8e51f123951ddaf373680517fc012" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel_callback&lt;/code&gt; is the module that implements the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour in the daemon. See the section &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information and an example.</source>
          <target state="translated">该 &lt;code&gt;channel_callback&lt;/code&gt; 是模块实现了 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 的守护进程（取代ssh_daemon_channel）行为。有关更多信息和示例，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b8493f2b264f76e709a289fe048f59895e05cdc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; above makes the &lt;code&gt;.erlang.cookie&lt;/code&gt; file accessible only by the owner of the file. This is a requirement.</source>
          <target state="translated">上面的 &lt;code&gt;chmod&lt;/code&gt; 使得 &lt;code&gt;.erlang.cookie&lt;/code&gt; 文件只能由文件所有者访问。这是一个要求。</target>
        </trans-unit>
        <trans-unit id="067ed8257f3ed48d1dd77d1c82e5f73c03791be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;client_directory&lt;/code&gt; in the directory structure of the master nodes must be specified.</source>
          <target state="translated">该 &lt;code&gt;client_directory&lt;/code&gt; 在主节点的目录结构必须被指定。</target>
        </trans-unit>
        <trans-unit id="97ad2677bec8a2ec1b2eaf275491aa26823e6cdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clients&lt;/code&gt; directory is to have one subdirectory per supported client node. The name of each client directory is to be the name of the corresponding client node. As a minimum, each client directory is to contain the &lt;code&gt;bin&lt;/code&gt; and &lt;code&gt;releases&lt;/code&gt; subdirectories. These directories are used to store information about installed releases and to appoint the current release to the client. The &lt;code&gt;$ROOT&lt;/code&gt; directory thus contains the following:</source>
          <target state="translated">该 &lt;code&gt;clients&lt;/code&gt; 目录是让每个支持的客户端节点的一个子目录。每个客户端目录的名称将是相应客户端节点的名称。至少，每个客户端目录 &lt;code&gt;bin&lt;/code&gt; 包含bin并 &lt;code&gt;releases&lt;/code&gt; 子目录。这些目录用于存储有关已安装发行版的信息，并将当前发行版指定给客户端。在 &lt;code&gt;$ROOT&lt;/code&gt; 因此目录包含以下内容：</target>
        </trans-unit>
        <trans-unit id="fef0ac1b98cce64ffd1d82b4509565a3e18b84ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code_change&lt;/code&gt; method must also be implemented.</source>
          <target state="translated">该 &lt;code&gt;code_change&lt;/code&gt; 方法也必须执行。</target>
        </trans-unit>
        <trans-unit id="dfba9577e3cba70bb212c1548338d8d33c8f09a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combined&lt;/code&gt; format is one line looking like this: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;combined&lt;/code&gt; 格式被一条线看起来像这样： &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="630925a2786b7b59d8f4c833942afd22d020f670" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compatibility_only_hash()&lt;/code&gt; algorithms are recommended only for compatibility with existing applications.</source>
          <target state="translated">仅建议与现有应用程序兼容时才使用 &lt;code&gt;compatibility_only_hash()&lt;/code&gt; 算法。</target>
        </trans-unit>
        <trans-unit id="1b60f349fe6a82d8f3ab2d525a727ef964290939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process does the following:</source>
          <target state="translated">在 &lt;code&gt;complex&lt;/code&gt; 过程执行以下操作：</target>
        </trans-unit>
        <trans-unit id="ceca332ed5fece3a22bbc2b65250bbdfb9575097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process performs the following:</source>
          <target state="translated">的 &lt;code&gt;complex&lt;/code&gt; 过程执行以下：</target>
        </trans-unit>
        <trans-unit id="0e88a24bce8d7b2a409cde6bc42dab540256c0b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file is assumed to have been opened with the appropriate flags.</source>
          <target state="translated">当使用 &lt;code&gt;{file,Fd}&lt;/code&gt; 传递文件描述符时， &lt;code&gt;compressed&lt;/code&gt; 和 &lt;code&gt;cooked&lt;/code&gt; 标志无效。假定已使用适当的标志打开了该文件。</target>
        </trans-unit>
        <trans-unit id="45da19705e860c5554e30ca96214a35258f720dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compressed&lt;/code&gt; and &lt;code&gt;cooked&lt;/code&gt; flags are invalid when passing a file descriptor with &lt;code&gt;{file,Fd}&lt;/code&gt;. The file must already be opened with the appropriate flags.</source>
          <target state="translated">当使用 &lt;code&gt;{file,Fd}&lt;/code&gt; 传递文件描述符时， &lt;code&gt;compressed&lt;/code&gt; 和 &lt;code&gt;cooked&lt;/code&gt; 标志无效。该文件必须已经使用适当的标志打开。</target>
        </trans-unit>
        <trans-unit id="3748b6dda37726d1886cb8a28dacde2fa7798fe9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; macro is defined in &lt;code&gt;ct.hrl&lt;/code&gt;. This macro is to be used to retrieve information from the &lt;code&gt;Config&lt;/code&gt; variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the &lt;code&gt;Config&lt;/code&gt; variable supplied to the test case.</source>
          <target state="translated">的 &lt;code&gt;config&lt;/code&gt; 宏在定义 &lt;code&gt;ct.hrl&lt;/code&gt; 。该宏用于从发送给所有测试用例的 &lt;code&gt;Config&lt;/code&gt; 变量中检索信息。它与两个参数一起使用；第一个是要检索的配置变量的名称，第二个是提供给测试用例的 &lt;code&gt;Config&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3402fd646c2b066512d58aeec8dd8cb2dfa256aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">使用默认值时， &lt;code&gt;configure&lt;/code&gt; 脚本将发出警告。设置变量后，将不会发出警告。</target>
        </trans-unit>
        <trans-unit id="6288c90b6c5e2f3d2b468cb02b51d6affc24bf92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; scripts are generated by invoking &lt;code&gt;./otp_build autoconf&lt;/code&gt; in the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. The &lt;code&gt;configure&lt;/code&gt; scripts also have to be regenerated when a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file has been modified. Note that when checking out a branch a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file may change content, and you may therefore have to regenerate the &lt;code&gt;configure&lt;/code&gt; scripts when checking out a branch. Regenerated &lt;code&gt;configure&lt;/code&gt; scripts imply that you have to run &lt;code&gt;configure&lt;/code&gt; and build again.</source>
          <target state="translated">该 &lt;code&gt;configure&lt;/code&gt; 脚本调用产生 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 在 &lt;code&gt;$ERL_TOP&lt;/code&gt; 目录。该 &lt;code&gt;configure&lt;/code&gt; 脚本还具有当要再生 &lt;code&gt;configure.in&lt;/code&gt; 或 &lt;code&gt;aclocal.m4&lt;/code&gt; 文件已被修改。请注意，签出分支时， &lt;code&gt;configure.in&lt;/code&gt; 或 &lt;code&gt;aclocal.m4&lt;/code&gt; 文件可能会更改内容，因此签出分支时可能必须重新生成 &lt;code&gt;configure&lt;/code&gt; 脚本。重新生成的 &lt;code&gt;configure&lt;/code&gt; 脚本意味着您必须再次运行 &lt;code&gt;configure&lt;/code&gt; 和build。</target>
        </trans-unit>
        <trans-unit id="208c163b5d9b18adfd658c53d3afa3ceb105c168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; function looks a bit different too. We connect using the asynchronous &lt;code&gt;PQconnectStart&lt;/code&gt; function. After the connection is started, we retrieve the socket for the connection with &lt;code&gt;PQsocket&lt;/code&gt;. This socket is used with the &lt;code&gt;driver_select&lt;/code&gt; function to wait for connection. When the socket is ready for input or for output, the &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">在 &lt;code&gt;connect&lt;/code&gt; 功能看起来有点不同了。我们使用异步 &lt;code&gt;PQconnectStart&lt;/code&gt; 函数进行连接。连接开始后，我们使用 &lt;code&gt;PQsocket&lt;/code&gt; 检索用于连接的套接字。该套接字与 &lt;code&gt;driver_select&lt;/code&gt; 函数一起使用，以等待连接。当套接字准备好用于输入或输出时，将 &lt;code&gt;ready_io&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="72241940e6969f3882cb2063d805e933d9f13162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; option is &lt;strong&gt;not&lt;/strong&gt; intended for production. It is &lt;strong&gt;only&lt;/strong&gt; a convenient way to debug Erlang services during development.</source>
          <target state="translated">该 &lt;code&gt;console&lt;/code&gt; 选项&lt;strong&gt;不&lt;/strong&gt;用于生产。这&lt;strong&gt;只是&lt;/strong&gt;在开发过程中调试Erlang服务的便捷方法。</target>
        </trans-unit>
        <trans-unit id="09d03cd7b2afda946d29b4dfa4871ca45c957a3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content&lt;/code&gt; field of the top element is a list of records that shows the structure and data of the document. If it is a simple document like:</source>
          <target state="translated">顶部元素的 &lt;code&gt;content&lt;/code&gt; 字段是记录列表，显示文档的结构和数据。如果它是一个简单的文档，例如：</target>
        </trans-unit>
        <trans-unit id="838c0fd05d2d1deb4094b06de0e616a5af7c6e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; option inhibits the call to &lt;code&gt;trace(stop)&lt;/code&gt; and leaves it up to the caller to stop tracing at a suitable time.</source>
          <target state="translated">该 &lt;code&gt;continue&lt;/code&gt; 选项禁止调用 &lt;code&gt;trace(stop)&lt;/code&gt; 和叶它给调用者停止在一个合适的时间跟踪。</target>
        </trans-unit>
        <trans-unit id="5e5e4cf83680d9fc0726d1fa4e444a1ac9be072e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;control&lt;/code&gt; entry is called from the emulator when the Erlang code calls &lt;code&gt;port_control/3&lt;/code&gt;, to do the actual work. We have defined a simple set of commands: &lt;code&gt;connect&lt;/code&gt; to log in to the database, &lt;code&gt;disconnect&lt;/code&gt; to log out, and &lt;code&gt;select&lt;/code&gt; to send a SQL-query and get the result. All results are returned through &lt;code&gt;rbuf&lt;/code&gt;. The library &lt;code&gt;ei&lt;/code&gt; in &lt;code&gt;erl_interface&lt;/code&gt; is used to encode data in binary term format. The result is returned to the emulator as binary terms, so &lt;code&gt;binary_to_term&lt;/code&gt; is called in Erlang to convert the result to term form.</source>
          <target state="translated">该 &lt;code&gt;control&lt;/code&gt; 在二郎山代码调用条目从模拟器称为 &lt;code&gt;port_control/3&lt;/code&gt; ，做实际工作。我们定义了一组简单的命令： &lt;code&gt;connect&lt;/code&gt; 以登录数据库， &lt;code&gt;disconnect&lt;/code&gt; 以注销，并 &lt;code&gt;select&lt;/code&gt; 发送SQL查询并获取结果。所有结果都通过 &lt;code&gt;rbuf&lt;/code&gt; 返回。该库 &lt;code&gt;ei&lt;/code&gt; 在 &lt;code&gt;erl_interface&lt;/code&gt; 用于以二进制格式术语编码数据。结果以二进制术语的形式返回给仿真器，因此在Erlang中调用 &lt;code&gt;binary_to_term&lt;/code&gt; 将结果转换为术语形式。</target>
        </trans-unit>
        <trans-unit id="26bab11093554a028ef86c3afb6f974cfc496b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert_to_c&lt;/code&gt; function is the same as before, but here it is used as a fun:</source>
          <target state="translated">该 &lt;code&gt;convert_to_c&lt;/code&gt; 功能是和以前一样，但在这里它作为一个有趣的：</target>
        </trans-unit>
        <trans-unit id="77c0725ecb5968616addeb9bf220dfefe059032f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cprof&lt;/code&gt; module is used to profile a program to find out how many times different functions are called. Breakpoints similar to local call trace, but containing a counter, are used to minimise runtime performance impact.</source>
          <target state="translated">该 &lt;code&gt;cprof&lt;/code&gt; 模块用于简报的程序，找出不同的功能调用多少次。类似于本地呼叫跟踪的断点，但包含一个计数器，用于最大程度地减少对运行时性能的影响。</target>
        </trans-unit>
        <trans-unit id="9716455d32bb78ba694b642a2f677996c5c94a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes.</source>
          <target state="translated">将 &lt;code&gt;crypto&lt;/code&gt; 模式选项应用于已生成的字节流，然后再将其发送到SFTP服务器。这旨在用于加密，但可以用于其他目的。</target>
        </trans-unit>
        <trans-unit id="fae5817bafe1b274a413d2d8be87f3d34ec23f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is explained in the data types section above, see &lt;code&gt;&lt;a href=&quot;#Crypto%20operations%20for%20open_tar&quot;&gt;Crypto operations for open_tar&lt;/a&gt;&lt;/code&gt;. Encryption is assumed if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;write&lt;/code&gt;, and decryption if the &lt;code&gt;Mode&lt;/code&gt; contains &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;crypto&lt;/code&gt; 模式选项在数据类型部分上面所解释的，请参阅 &lt;code&gt;&lt;a href=&quot;#Crypto%20operations%20for%20open_tar&quot;&gt;Crypto operations for open_tar&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;Mode&lt;/code&gt; 包含 &lt;code&gt;write&lt;/code&gt; ，则假定加密；如果 &lt;code&gt;Mode&lt;/code&gt; 包含 &lt;code&gt;read&lt;/code&gt; ，则假定解密。</target>
        </trans-unit>
        <trans-unit id="e5cee4c61a0a375534a2fba35a2573413a78af60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_init&lt;/code&gt; initialies an internal cipher state, and one or more calls of &lt;code&gt;crypto_update&lt;/code&gt; does the acual encryption or decryption. Note that AEAD ciphers can't be handled this way due to their nature.</source>
          <target state="translated">所述 &lt;code&gt;crypto_init&lt;/code&gt; initialies内部加密状态，并且其中一个或多个呼叫 &lt;code&gt;crypto_update&lt;/code&gt; 确实的acual加密或解密。请注意，由于其性质，无法以这种方式处理AEAD密码。</target>
        </trans-unit>
        <trans-unit id="7b046fe6dab519074b82c93250ff16e0a704aba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto_one_time_aead&lt;/code&gt; functions are for the ciphers of mode &lt;code&gt;ccm&lt;/code&gt; or &lt;code&gt;gcm&lt;/code&gt;, and for the cipher &lt;code&gt;chacha20-poly1305&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;crypto_one_time_aead&lt;/code&gt; 功能是模式的密码 &lt;code&gt;ccm&lt;/code&gt; 或 &lt;code&gt;gcm&lt;/code&gt; ，以及用于加密 &lt;code&gt;chacha20-poly1305&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1ea90a542fdde5c9bfa793410f97e64b38fc90e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cryptolib_padding&lt;/code&gt; are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app.</source>
          <target state="translated">的 &lt;code&gt;cryptolib_padding&lt;/code&gt; 是填补处理可能存在的在链接到二郎/ OTP加密的应用程序的底层cryptolib。</target>
        </trans-unit>
        <trans-unit id="f05085fc1befe3aa6ba53fe6204755e8c7f0ad8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_hooks&lt;/code&gt; statement must look as follows:</source>
          <target state="translated">该 &lt;code&gt;ct_hooks&lt;/code&gt; 声明必须如下所示：</target>
        </trans-unit>
        <trans-unit id="195e3e1b4f16da2ed99752167d29e762d1e2035f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program is automatically installed with Erlang/OTP and the &lt;code&gt;Common Test&lt;/code&gt; application (for more information, see section &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; in the User's Guide). The program accepts different start flags. Some flags trigger &lt;code&gt;ct_run&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt; and pass on data to it. Some flags start an Erlang node prepared for running &lt;code&gt;Common Test&lt;/code&gt; in a particular mode.</source>
          <target state="translated">该 &lt;code&gt;ct_run&lt;/code&gt; 程序使用Erlang / OTP和自动安装 &lt;code&gt;Common Test&lt;/code&gt; 应用程序（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; 的用户指南）。该程序接受不同的开始标志。一些标志触发 &lt;code&gt;ct_run&lt;/code&gt; 以启动 &lt;code&gt;Common Test&lt;/code&gt; 并将数据传递给它。一些标志会启动一个Erlang节点，准备在特定模式下运行 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bead0eeaff46c7e466e0712fc0054654e293c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program sets the exit status before shutting down. The following values are defined:</source>
          <target state="translated">该 &lt;code&gt;ct_run&lt;/code&gt; 程序关闭之前设置退出状态。定义了以下值：</target>
        </trans-unit>
        <trans-unit id="5e688bf44ef358ec92d20ce42ff6bf380d1fb9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cth_conn_log&lt;/code&gt; hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log.</source>
          <target state="translated">所述 &lt;code&gt;cth_conn_log&lt;/code&gt; 钩进行远程登录数据的无格式记录到一个单独的文本文件。捕获并打印所有Telnet通信，包括从服务器发送的所有数据。指向此文本文件的链接位于测试用例HTML日志的顶部。</target>
        </trans-unit>
        <trans-unit id="a68179b6708f261780e3204a93ccf67ebff3b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; module is primarily targeted towards tracing through the &lt;code&gt;erlang:trace/3&lt;/code&gt; function. It is sometimes desired to trace messages in a more delicate way, which can be done with the help of the &lt;code&gt;seq_trace&lt;/code&gt; module.</source>
          <target state="translated">所述 &lt;code&gt;dbg&lt;/code&gt; 模块主要是针对向通过跟踪 &lt;code&gt;erlang:trace/3&lt;/code&gt; 的功能。有时希望以一种更精致的方式跟踪消息，这可以在 &lt;code&gt;seq_trace&lt;/code&gt; 模块的帮助下完成。</target>
        </trans-unit>
        <trans-unit id="4ec06ab24b2bef8a81af6b12d4353768a1844399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; server keeps a list of nodes where tracing should be performed. Whenever a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; call or a &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; call is made, it is executed for all nodes in this list including the local node (except for &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; with a specific &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; as first argument, in which case the command is executed only on the node where the designated process or port resides).</source>
          <target state="translated">该 &lt;code&gt;dbg&lt;/code&gt; 服务器保留在那里跟踪应执行的节点列表。每当进行 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 调用或 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 调用时，都会对列表中的所有节点（包括本地节点）执行该操作（除了以特殊 &lt;code&gt;pid()&lt;/code&gt; 或 &lt;code&gt;port()&lt;/code&gt; 作为第一个参数的 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 之外），其中如果命令仅在指定进程或端口所在的节点上执行）。</target>
        </trans-unit>
        <trans-unit id="c217008a9ef77e9f7c9c82997e3edae1e2b0a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for &lt;code&gt;ets:fun2ms/1&lt;/code&gt; returns the result without side effects. As matching (&lt;code&gt;=&lt;/code&gt;) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction.</source>
          <target state="translated">匹配规范的 &lt;code&gt;dbg&lt;/code&gt; 变体对匹配规范主体具有强制性的方法，而ETS方言则没有。 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 的fun主体返回的结果没有副作用。由于不允许匹配规范中的匹配（ &lt;code&gt;=&lt;/code&gt; ）（出于性能原因），剩下的或多或少是术语构造。</target>
        </trans-unit>
        <trans-unit id="8b1d45e514e2b4bb0f72c0e576b456b901110516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; option ensures that the BEAM file contains debug information, which makes it possible to find unused local functions.</source>
          <target state="translated">该 &lt;code&gt;debug_info&lt;/code&gt; 选项确保梁文件包含调试信息，这使得它可以找到未使用的本地功能。</target>
        </trans-unit>
        <trans-unit id="f272f87848e9520c4164ada69cea273706e63692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; parameter controls whether the debug information in the beam file should be kept (&lt;code&gt;keep&lt;/code&gt;) or stripped &lt;code&gt;strip&lt;/code&gt; when the file is copied to the target system.</source>
          <target state="translated">所述 &lt;code&gt;debug_info&lt;/code&gt; 参数控制在梁文件中的调试信息是否应保持（ &lt;code&gt;keep&lt;/code&gt; ）或剥离 &lt;code&gt;strip&lt;/code&gt; 时，文件被复制到目标系统。</target>
        </trans-unit>
        <trans-unit id="6fb823bf619fb63ef67310a79ad7a561ee4d0a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 功能不会从数据库中，因为卸载的MIB并不一定意味着该表应销毁删除表。</target>
        </trans-unit>
        <trans-unit id="9bb6d436299249f5caa30b07b29030812a609536" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the variable from the database.</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 功能不会从数据库中删除该变量。</target>
        </trans-unit>
        <trans-unit id="7056e5309dbe8cb35a67254e724ea1561fd3590e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; operation is considered successful if the element was not present in the table. Hence all attempts to check that the element is present in the Ets/Mnesia table before deletion are unnecessary. Here follows an example for Ets tables:</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 操作被认为是成功的，如果该元素是不存在的表。因此，无需在删除之前进行所有检查以检查该元素是否在Ets / Mnesia表中的尝试。以下是Ets表的示例：</target>
        </trans-unit>
        <trans-unit id="9843826cc8a81d332dd5ca58dc2e4d273cfa0a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_der&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="translated">该 &lt;code&gt;dh_der&lt;/code&gt; 选项没有被TLS 1.3的支持。请改使用 &lt;code&gt;supported_groups&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="2d506578ec68dd2a9fa7f8cceed364aba6b39394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dh_file&lt;/code&gt; option is not supported by TLS 1.3. Use the &lt;code&gt;supported_groups&lt;/code&gt; option instead.</source>
          <target state="translated">该 &lt;code&gt;dh_file&lt;/code&gt; 选项没有被TLS 1.3的支持。请改使用 &lt;code&gt;supported_groups&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="3ec29833516e95ca8c52bcd06ca0329b6a9912b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disc_copies&lt;/code&gt; tables are stored on disk with &lt;code&gt;.DCL&lt;/code&gt; and &lt;code&gt;.DCD&lt;/code&gt; files, which are standard &lt;code&gt;disk_log&lt;/code&gt; files.</source>
          <target state="translated">该 &lt;code&gt;disc_copies&lt;/code&gt; 表存储在磁盘 &lt;code&gt;.DCL&lt;/code&gt; 和 &lt;code&gt;.DCD&lt;/code&gt; 文件，这是标准的 &lt;code&gt;disk_log&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0566aa9127b7a16298ed02e87fbca3df443437c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disk_log&lt;/code&gt; module does not report errors to the &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; module. It is up to the caller to decide whether to employ the error logger. Function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; can be used to produce readable messages from error replies. However, information events are sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks.</source>
          <target state="translated">该 &lt;code&gt;disk_log&lt;/code&gt; 模块不向报告错误 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 模块。由调用者决定是否使用错误记录器。函数 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 可用于从错误回复中产生可读的消息。但是，在两种情况下，信息事件会发送到错误记录器，即修复日志时或读取块时缺少文件时。</target>
        </trans-unit>
        <trans-unit id="cfcfef3897d14b434ad165428853c39b5f2890f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; and &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; functions takes a &lt;code&gt;#hs_data{}&lt;/code&gt; record as argument. There are quite a lot of fields in this record that you need to set. The record is defined in &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt;. Not documented fields should not be set, i.e., should be left as &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; 和 &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; 功能需要 &lt;code&gt;#hs_data{}&lt;/code&gt; 记录作为参数。您需要在此记录中设置很多字段。该记录在 &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt; 中定义。未记录的字段不应设置，即应保留为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83c7e0ed34c372831d8c8f2866d0a4d8b8af47d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_select&lt;/code&gt; function initiates a select, and returns if there is no immediate error. The result is returned when &lt;code&gt;ready_io&lt;/code&gt; is called.</source>
          <target state="translated">该 &lt;code&gt;do_select&lt;/code&gt; 功能启动选择和回报，如果没有直接的错误。调用 &lt;code&gt;ready_io&lt;/code&gt; 时将返回结果。</target>
        </trans-unit>
        <trans-unit id="9e898d68f399dcaad71bedb473b4e1db27a86822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver_entry&lt;/code&gt; structure is a C struct that all Erlang drivers define. It contains entry points for the Erlang driver, which are called by the Erlang emulator when Erlang code accesses the driver.</source>
          <target state="translated">该 &lt;code&gt;driver_entry&lt;/code&gt; 结构是一个C结构，所有二郎司机定义。它包含Erlang驱动程序的入口点，当Erlang代码访问驱动程序时，Erlang仿真器将调用这些入口点。</target>
        </trans-unit>
        <trans-unit id="e2f343471e0cd9e732eb94fa594ad01445d525d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;entity-Body&lt;/code&gt; ，例如，使用POST方法从CGI脚本发送的数据。</target>
        </trans-unit>
        <trans-unit id="8485e195c6ca973415a83d30d66c767c905bacbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epmd&lt;/code&gt; daemon accepts messages from both the local host and remote hosts. However, only the query commands are answered (and acted upon) if the query comes from a remote host. It is always an error to try to register a node name if the client is not a process on the same host as the &lt;code&gt;epmd&lt;/code&gt; instance is running on. Such requests are considered hostile and the connection is closed immediately.</source>
          <target state="translated">该 &lt;code&gt;epmd&lt;/code&gt; 守护进程接受来自本地主机和远程主机的消息。但是，如果查询来自远程主机，则仅查询（和执行）查询命令。如果客户端不是与 &lt;code&gt;epmd&lt;/code&gt; 实例运行在同一主机上的进程，则尝试注册节点名称始终是错误的。此类请求被视为具有敌意，并且连接将立即关闭。</target>
        </trans-unit>
        <trans-unit id="1a8cdcc41303bad80d1836231fd657575e8b7da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl&lt;/code&gt; program starts an Erlang runtime system. The exact details (for example, whether &lt;code&gt;erl&lt;/code&gt; is a script or a program and which other programs it calls) are system-dependent.</source>
          <target state="translated">该 &lt;code&gt;erl&lt;/code&gt; 程序启动一个Erlang运行时系统。确切的详细信息（例如， &lt;code&gt;erl&lt;/code&gt; 是脚本还是程序，以及它调用的其他程序）取决于系统。</target>
        </trans-unit>
        <trans-unit id="23033c746a70348dcd7ee413398f764a041fafc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_boot_server&lt;/code&gt; can read regular files and files in archives. See &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; in ERTS.</source>
          <target state="translated">该 &lt;code&gt;erl_boot_server&lt;/code&gt; 可以在档案读取普通文件和文件。请参阅ERTS中的 &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc1db4ac366acb55e5dbd23b870fee87dcf6984d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_prim_loader&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">所述 &lt;code&gt;erl_prim_loader&lt;/code&gt; 模块解释下面的命令行标志：</target>
        </trans-unit>
        <trans-unit id="a9f75e2ebb8bacf1be148858ac754ee91aff0b2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:processes/1&lt;/code&gt; and &lt;code&gt;erlang:port/1&lt;/code&gt; BIFs iterate over the tables and return corresponding identifiers. These BIF should return a consistent snapshot of the table content during some time when the BIF is executing. In order to implement this we use locking in a strange way. We use an &quot;inverted rwlock&quot;.</source>
          <target state="translated">所述 &lt;code&gt;erlang:processes/1&lt;/code&gt; 和 &lt;code&gt;erlang:port/1&lt;/code&gt; 的BIF遍历表，并返回对应的标识符。在执行BIF的某个时间段内，这些BIF应该返回表内容的一致快照。为了实现这一点，我们以一种奇怪的方式使用锁定。我们使用&amp;ldquo;反向rwlock&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9c8443a325361f346c54c5b5b79ecfd176dc3cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF is equivalent to:</source>
          <target state="translated">的 &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF等效于：</target>
        </trans-unit>
        <trans-unit id="674c071fef1bb6c50be069bf2fac5cfa5b02ddff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; commands can be used to compile SNMP MIBs. Example:</source>
          <target state="translated">所述 &lt;code&gt;erlc&lt;/code&gt; 命令可用于编译的SNMP MIB。例：</target>
        </trans-unit>
        <trans-unit id="62bad1fda35fe8631456e7f852e564c8e9c8e268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides a common way to run all compilers in the Erlang system. Depending on the extension of each input file, &lt;code&gt;erlc&lt;/code&gt; invokes the appropriate compiler. Regardless of which compiler is used, the same flags are used to provide parameters, such as include paths and output directory.</source>
          <target state="translated">该 &lt;code&gt;erlc&lt;/code&gt; 程序提供运行在Erlang的系统中所有的编译器的常用方法。根据每个输入文件的扩展名， &lt;code&gt;erlc&lt;/code&gt; 调用适当的编译器。无论使用哪种编译器，都使用相同的标志来提供参数，例如包含路径和输出目录。</target>
        </trans-unit>
        <trans-unit id="04a181b53380c41c65d2013dd7fbc831073b3697" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides an even better way to compile modules from the shell, see the &lt;code&gt;erlc(1)&lt;/code&gt; manual page in ERTS. It understands a number of flags that can be used to define macros, add search paths for include files, and more.</source>
          <target state="translated">该 &lt;code&gt;erlc&lt;/code&gt; 方案提供了一个更好的方法，以从所述外壳编译模块，请参见 &lt;code&gt;erlc(1)&lt;/code&gt; 在ERTS手册页。它了解许多标志，这些标志可用于定义宏，添加包含文件的搜索路径等等。</target>
        </trans-unit>
        <trans-unit id="8ef81ea9999fef9d6386667fd464ac528873e195" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed due to some system limit being reached. This typically due to failure to create a process on the remote node &lt;code&gt;Node&lt;/code&gt;, but can be other things as well.</source>
          <target state="translated">该 &lt;code&gt;erpc&lt;/code&gt; 被达到，由于一些系统限制操作失败。这通常是由于无法在远程节点 &lt;code&gt;Node&lt;/code&gt; 上创建进程而引起的，但也可能是其他原因。</target>
        </trans-unit>
        <trans-unit id="ef05a4f26d361fa5f7db9630f59b90887dc5e15f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation failed. The following &lt;code&gt;ERpcErrorReason&lt;/code&gt;s are the most common ones:</source>
          <target state="translated">该 &lt;code&gt;erpc&lt;/code&gt; 操作失败。以下是最常见的 &lt;code&gt;ERpcErrorReason&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ecee252d04d93f7d74c1c1a56f12a612505d489e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erpc&lt;/code&gt; operation timed out. The function may or may not be applied.</source>
          <target state="translated">该 &lt;code&gt;erpc&lt;/code&gt; 操作超时。该功能可能适用也可能不适用。</target>
        </trans-unit>
        <trans-unit id="cd3c7d4f5dac617c7aad52a992257a0165d9e724" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger&lt;/code&gt; API still exists, but should only be used by legacy code. It will be removed in a later release.</source>
          <target state="translated">该 &lt;code&gt;error_logger&lt;/code&gt; API仍然存在，但只能由传统的代码中使用。它将在以后的版本中删除。</target>
        </trans-unit>
        <trans-unit id="cecfe06c35cc22d6fbeab34699c031b77ba0b013" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt; deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">所述 &lt;code&gt;error_logger_format_depth&lt;/code&gt; 变量 &lt;code&gt; deprecated&lt;/code&gt; 由于 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 在二郎/ OTP 21.0引入。保留变量和此函数是为了向后兼容，因为旧式报表处理程序仍可能使用它们。</target>
        </trans-unit>
        <trans-unit id="d68556b2eb1fae2f09bd4af885781dca52da64d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt;deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">所述 &lt;code&gt;error_logger_format_depth&lt;/code&gt; 变量 &lt;code&gt;deprecated&lt;/code&gt; 由于 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 在二郎/ OTP 21.0引入。保留变量和此函数是为了向后兼容，因为旧式报表处理程序仍可能使用它们。</target>
        </trans-unit>
        <trans-unit id="7c78dbc6e06eb7032ca1037abf4bb7cf984ec4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="translated">所述 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 工具，可以用来帮助一个的创建 &lt;code&gt;erts_alloc&lt;/code&gt; 配置适合于运行时的场景的数量有限。</target>
        </trans-unit>
        <trans-unit id="6d445f376d6f420d187f6eefce3f926292a91d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;et&lt;/code&gt; module is not like other modules. It contains a function called &lt;code&gt;et:trace_me/5&lt;/code&gt;. Which is a function that does not do any useful stuff at all. Its sole purpose is to be a function that is easy to trace. A call to it may be something like:</source>
          <target state="translated">所述 &lt;code&gt;et&lt;/code&gt; 模块不是像其它模块。它包含一个名为 &lt;code&gt;et:trace_me/5&lt;/code&gt; 的函数。该函数根本不做任何有用的事情。其唯一目的是成为易于跟踪的功能。对其进行的调用可能类似于：</target>
        </trans-unit>
        <trans-unit id="bed59c1de102975ce15ed3e675ac3119209f047d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; program of fairly modern versions of Emacs and XEmacs has native support for Erlang. To check if your version does include this support, issue the command &lt;code&gt;etags --help&lt;/code&gt; at a the command line prompt. At the end of the help text there is a list of supported languages. Unless Erlang is a member of this list I suggest that you should upgrade to a newer version of Emacs.</source>
          <target state="translated">相当现代的Emacs和XEmacs版本的 &lt;code&gt;etags&lt;/code&gt; 程序具有对Erlang的本地支持。要检查您的版本是否确实包含此支持，请在命令行提示符下发出命令 &lt;code&gt;etags --help&lt;/code&gt; 。帮助文本的末尾有支持的语言列表。除非Erlang是此列表的成员，否则我建议您升级到Emacs的较新版本。</target>
        </trans-unit>
        <trans-unit id="47e6f553b59c8cd440ae6bcf427e51798ed42721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; utility can also read a list of files from its standard input by supplying a single dash in place of the file names. This feature is useful when a project consists of a large number of files. The standard UNIX command &lt;code&gt;find&lt;/code&gt; can be used to generate the list of files, e.g:</source>
          <target state="translated">该 &lt;code&gt;etags&lt;/code&gt; 实用程序还可以通过替代文件名提供一个单一的破折号读取从标准输入文件的列表。当项目包含大量文件时，此功能很有用。标准UNIX命令 &lt;code&gt;find&lt;/code&gt; 可用于生成文件列表，例如：</target>
        </trans-unit>
        <trans-unit id="e41a30417c9eb9b7fd9125a0948a761a185309da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ets:select/2&lt;/code&gt; call conceptually looks like this in the resulting code:</source>
          <target state="translated">在结果代码中， &lt;code&gt;ets:select/2&lt;/code&gt; 调用在概念上看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c0a28f71fbf02463cf528426b0591cc67a7a02b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;example_drv_start&lt;/code&gt;, is the only function that is called with a handle to the port instance, so this must be saved. It is customary to use an allocated driver-defined structure for this one, and to pass a pointer back as a reference.</source>
          <target state="translated">该 &lt;code&gt;example_drv_start&lt;/code&gt; ，是调用句柄到端口实例的唯一功能，因此必须被保存。通常为此使用分配的驱动程序定义的结构，并将指针传回作为引用。</target>
        </trans-unit>
        <trans-unit id="d0356d1c5d4e8ef894f1ca0204010b1f0f916038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extended_errors&lt;/code&gt; option enables extended ODBC error information when an operation fails. Rather than returning &lt;code&gt;{error, Reason}&lt;/code&gt;, the failing function will reutrn &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt;. Note that this information is probably of little use when writing database-independent code, but can be of assistance in providing more sophisticated error handling when dealing with a known underlying database.</source>
          <target state="translated">当操作失败时， &lt;code&gt;extended_errors&lt;/code&gt; 选项启用扩展的ODBC错误信息。失败的函数将返回 &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt; 而不是返回 &lt;code&gt;{error, Reason}&lt;/code&gt; }。请注意，在编写与数据库无关的代码时，此信息可能用处不大，但是在处理已知的基础数据库时，可以帮助提供更复杂的错误处理。</target>
        </trans-unit>
        <trans-unit id="c59051a0d238b0abf7c9e7050c91b5361d579937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra&lt;/code&gt; info is not normally interpreted by the agent, instead it is passed through to the &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; process. It is up to the implementor of that process to make use of this data.</source>
          <target state="translated">该 &lt;code&gt;extra&lt;/code&gt; 信息通常不被代理人的解释，而不是将其传递通过对 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; 过程。使用该数据取决于该过程的实现者。</target>
        </trans-unit>
        <trans-unit id="57ed5e1b23df723cf600bd41057a5b61adc0bf3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; field can only have the (above) specified values (and not all the values of socket:domain()).</source>
          <target state="translated">该 &lt;code&gt;family&lt;/code&gt; 场只能有（以上）指定的值（而不是插座中的所有值：域（））。</target>
        </trans-unit>
        <trans-unit id="9363097de66681822e14d18a16cae53b07a71b33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module accepts raw filenames as input. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; also accepts them. As mentioned earlier, the arguments specified in the option list to &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; undergo the same conversion as the filenames, meaning that the executable is provided with arguments in UTF-8 as well. This translation is avoided consistently with how the filenames are treated, by giving the argument as a binary.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; 模块接受原始文件名作为输入。 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 也接受它们。如前所述，在选项列表中为 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 指定的参数与文件名的转换相同，这意味着可执行文件在UTF-8中也提供了参数。通过将参数指定为二进制，可以避免与文件名的处理方式保持一致的转换。</target>
        </trans-unit>
        <trans-unit id="56811d8968fc7cff92a38ee6c1b86759f5455dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module already spread's tags, so there is noo need to manually call these function to get user tags spread to the efile driver through that module.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; 模块已经蔓延的标签，所以野应需要手动调用这些函数来获取用户标签蔓延到通过该模块的电子文件的驱动程序。</target>
        </trans-unit>
        <trans-unit id="d1888f67852ce013eb515b48a1f7e3f5fb2b5677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foo&lt;/code&gt; table is replicated on the two nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;foo&lt;/code&gt; 表被复制的两个节点 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58cb0b27674de03ef7e6aa8a782a3f05022f6202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fprof&lt;/code&gt; module uses tracing to collect profiling data, hence there is no need for special compilation of any module to be profiled. When it starts tracing, &lt;code&gt;fprof&lt;/code&gt; will erase all previous tracing in the node and set the necessary trace flags on the profiling target processes as well as local call trace on all functions in all loaded modules and all modules to be loaded. &lt;code&gt;fprof&lt;/code&gt; erases all tracing in the node when it stops tracing.</source>
          <target state="translated">该 &lt;code&gt;fprof&lt;/code&gt; 模块使用跟踪，收集分析数据，因此没有必要对任何模块的特殊编制进行概要分析。当开始跟踪时， &lt;code&gt;fprof&lt;/code&gt; 将擦除节点中的所有先前跟踪，并在概要分析目标进程上设置必要的跟踪标志，以及在所有已加载模块和要加载的所有模块中的所有函数上设置本地调用跟踪。 &lt;code&gt;fprof&lt;/code&gt; 停止跟踪时，它将删除该节点中的所有跟踪。</target>
        </trans-unit>
        <trans-unit id="2499ac11d982c28fc125b257bd3bdd2fea444c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fqdn_fun&lt;/code&gt; extracts hostnames (Fully Qualified Domain Names) from uri_id or other ReferenceIDs that are not pre-defined in the public_key function. Suppose you have some URI with a very special protocol-part: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt;. Since this a non-standard URI there will be no hostname extracted for matching CN-names in the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;fqdn_fun&lt;/code&gt; 从uri_id或其他ReferenceIDs提取的主机名（完全限定域名），其未在PUBLIC_KEY函数预先定义。假设您有一些带有非常特殊协议部分的URI： &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt; 。由于这是一个非标准URI，因此不会提取任何主机名来匹配 &lt;code&gt;Subject&lt;/code&gt; 中的CN名称。</target>
        </trans-unit>
        <trans-unit id="122806faca6d67fa7fa167376a0e47c2c49bcb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;message&lt;/code&gt; parameters are exactly what they sound like. &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are visualized in the &lt;code&gt;Viewer&lt;/code&gt; as &quot;lifelines&quot;, with the message passing from one to the other. If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same value, then it is displayed next to the lifeline as an &quot;action&quot;. The &lt;code&gt;extra_stuff&lt;/code&gt;value is simply data that you can attach that will be displayed when someone actually clicks on the action or message in the &lt;code&gt;Viewer&lt;/code&gt; window.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 参数是它们的声音究竟是什么样子。 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 在可视化 &lt;code&gt;Viewer&lt;/code&gt; 为&amp;ldquo;生命线&amp;rdquo;，用从一个到另一个的消息传递。如果 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 是相同的值，那么它将在生命线旁边显示为&amp;ldquo;操作&amp;rdquo;。该 &lt;code&gt;extra_stuff&lt;/code&gt; 值只是数据可以附加，当有人在操作或消息实际点击会显示 &lt;code&gt;Viewer&lt;/code&gt; 窗口。</target>
        </trans-unit>
        <trans-unit id="87548be67a9ff93c1ef1ff4d3cbb19180b6403f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ftp&lt;/code&gt; module normally accesses the tar file on disk using the &lt;code&gt;file&lt;/code&gt; module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ftp&lt;/code&gt; 模块访问正常使用的磁盘tar文件 &lt;code&gt;file&lt;/code&gt; 模块。当有其他需求时，您可以定义自己的低级Erlang函数，以在存储介质上执行写入和读取操作。使用函数 &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97a262c9e6ae8c813f3758420838640077d62040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; in the exec option could take up to three arguments (&lt;code&gt;Cmd&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;ClientAddress&lt;/code&gt;). See the &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; for the details.</source>
          <target state="translated">exec选项中的 &lt;code&gt;fun()&lt;/code&gt; 最多可以包含三个参数（ &lt;code&gt;Cmd&lt;/code&gt; ， &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;ClientAddress&lt;/code&gt; ）。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="601051b0fdf8cf4c5f5015c05c1f7676f5366f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; is very restricted, it can take only a single parameter (the parameter list to match), a sole variable or a list. It needs to use the &lt;code&gt;is_&lt;/code&gt;XXX guard tests and one cannot use language constructs that have no representation in a match_spec (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; etc). The return value from the fun will be the return value of the resulting match_spec.</source>
          <target state="translated">的 &lt;code&gt;fun()&lt;/code&gt; 是非常有限的，它可以采取只有一个参数（参数列表匹配），唯一的变量或列表。它需要使用 &lt;code&gt;is_&lt;/code&gt; XXX保护测试，并且不能使用在match_spec中没有表示形式的语言构造（例如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;receive&lt;/code&gt; 等）。Fun的返回值将是结果match_spec的返回值。</target>
        </trans-unit>
        <trans-unit id="000806ecedbeddab2e6bf12ee5fe07ca1e33c2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun/2&lt;/code&gt; in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom &lt;code&gt;default&lt;/code&gt;, if the default matching rules shall apply. This makes it possible to augment the tests with a special case:</source>
          <target state="translated">此选项中的 &lt;code&gt;fun/2&lt;/code&gt; 替换默认的主机名匹配规则。乐趣应该返回一个布尔值，以告诉参考ID和呈现ID是否匹配。如果默认匹配规则适用，该fun还可以返回第三个值，原子 &lt;code&gt;default&lt;/code&gt; 。这样就可以通过特殊情况扩展测试：</target>
        </trans-unit>
        <trans-unit id="f52884fca2fcf6439eaac6506d404d211516c579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functions&lt;/code&gt; filter shows each function as a vertical line in the sequence diagram. A function calling itself is shown as an activity within a function, and all other function calls are shown as interactions between functions.</source>
          <target state="translated">所述 &lt;code&gt;functions&lt;/code&gt; 过滤器示出了每个功能如在序列图的垂直线。调用自身的函数显示为函数内的活动，所有其他函数调用均显示为函数之间的交互。</target>
        </trans-unit>
        <trans-unit id="3f981dcbf4ac48552e64e421603989d6797ca936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;garbage_collect&lt;/code&gt; pseudo function has not got an OWN time of zero like &lt;code&gt;suspend&lt;/code&gt;, instead it is equal to the ACC time.</source>
          <target state="translated">该 &lt;code&gt;garbage_collect&lt;/code&gt; 伪功能还没有得到零像自己的时间 &lt;code&gt;suspend&lt;/code&gt; ，相反，它是等于ACC时间。</target>
        </trans-unit>
        <trans-unit id="65be8dbec39cb8799bd4b2ae3b3d10e864f2a323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">该 &lt;code&gt;gen_event&lt;/code&gt; 过程可以进入休眠状态（见 &lt;code&gt; erlang:hibernate/3&lt;/code&gt; ）如果在一个处理器模块指定回调函数 &lt;code&gt;hibernate&lt;/code&gt; 在其返回值。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾回收（休眠时和唤醒后不久），而不是您想要在繁忙的事件管理器处理的每个事件之间执行的操作。</target>
        </trans-unit>
        <trans-unit id="044322659b6e8af2be19d4c036e45080be4df433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">该 &lt;code&gt;gen_event&lt;/code&gt; 过程可以进入休眠状态（见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ）如果在一个处理器模块指定回调函数 &lt;code&gt;hibernate&lt;/code&gt; 在其返回值。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾回收（休眠时和唤醒后不久），而不是您要在繁忙的事件管理器处理的每个事件之间执行的操作。</target>
        </trans-unit>
        <trans-unit id="f841b959e8263c246a84615eb245e9aa9e79a66a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 来处理该请求。</target>
        </trans-unit>
        <trans-unit id="26a989bcc28ed3e808b806405714b19049fd235b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned.</source>
          <target state="translated">的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 进行初始化。为了确保同步启动过程，在返回 &lt;code&gt;Module:init/1&lt;/code&gt; 之前，不会返回 &lt;code&gt;start_link/3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7490f34408e79e925356758b66c95f52679a6c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt; erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">如果回调函数指定 &lt;code&gt;'hibernate'&lt;/code&gt; 而不是超时值，则 &lt;code&gt;gen_server&lt;/code&gt; 进程可以进入休眠状态（请参阅 &lt;code&gt; erlang:hibernate/3&lt;/code&gt; ）。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾收集（休眠时和唤醒后不久），并且您不想在每次对繁忙服务器的调用之间进行此操作。</target>
        </trans-unit>
        <trans-unit id="fa0125aacc8a9ef2d0db488477563acd091e114f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">如果回调函数指定 &lt;code&gt;'hibernate'&lt;/code&gt; 而不是超时值，则 &lt;code&gt;gen_server&lt;/code&gt; 进程可以进入休眠状态（请参阅 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ）。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾回收（休眠时和唤醒后不久），并且您不想在每次调用繁忙的服务器之间执行此操作。</target>
        </trans-unit>
        <trans-unit id="93b11bb8bc3cc58fae8df0b4cde4e2b1b7508719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process has been set to trap exit signals.</source>
          <target state="translated">该 &lt;code&gt;gen_server&lt;/code&gt; 过程已被设置为捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="1a0a8f650014835d8fac6303db526f6a6997059c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;gen_server&lt;/code&gt; 进程异常终止和记录一个错误。 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a177f7b03da7ce677026ac74a7f1eaf2f38ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior can if this is enabled, regardless of callback mode, automatically &lt;code&gt;call the state callback&lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the state transition rules. It typically looks like this:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为如果被启用，不管回调模式，自动 &lt;code&gt;call the state callback&lt;/code&gt; 有每当状态变化，所以你可以写状态进入附近的状态转换规则，其余的操作特殊的参数。通常看起来像这样：</target>
        </trans-unit>
        <trans-unit id="bed0fd34af6e417a5ed2971b378b4cefa2ed46b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior supports two callback modes:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为支持两种回调模式：</target>
        </trans-unit>
        <trans-unit id="0853cf94b65372cd43a3f0b5a15fa90c0eef1c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour can if this is enabled, regardless of &lt;strong&gt;callback mode&lt;/strong&gt;, automatically &lt;code&gt; call the state callback &lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the &lt;strong&gt;state transition&lt;/strong&gt; rules. It typically looks like this:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为如果被启用，不管&lt;strong&gt;回调模式&lt;/strong&gt;，自动 &lt;code&gt; call the state callback &lt;/code&gt; 有每当状态变化，所以你可以写状态进入附近的其余动作特殊的参数&lt;strong&gt;状态转换&lt;/strong&gt;规则。通常看起来像这样：</target>
        </trans-unit>
        <trans-unit id="9bfee8de64aaf220d4aeed1c41aab972dbfcbf33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behaviour supports two &lt;strong&gt;callback modes&lt;/strong&gt;:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为支持两种&lt;strong&gt;回调模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="202063559580002e499e6f482887a341d2fb543d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 有 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 和事件内容的 &lt;code&gt;Request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6f22901bf82daa00ca3a8e82f1d85e746f57f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a &lt;strong&gt;state transition&lt;/strong&gt; to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If &lt;code&gt;NextState =/= CurrentState&lt;/code&gt; the &lt;strong&gt;state transition&lt;/strong&gt; is a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 做一个&lt;strong&gt;状态转变&lt;/strong&gt;到 &lt;code&gt;NextState&lt;/code&gt; （其可以是相同的当前状态），设置 &lt;code&gt;NewData&lt;/code&gt; ，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。如果 &lt;code&gt;NextState =/= CurrentState&lt;/code&gt; 则&lt;strong&gt;状态转换&lt;/strong&gt;是&lt;strong&gt;状态更改&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="17680806ff10db88faa8089ccb57cda1bbf46d1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 确实的状态转变到 &lt;code&gt;NextState&lt;/code&gt; （其可以是相同的当前状态），设置 &lt;code&gt;NewData&lt;/code&gt; ，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b1ba800b2bd8eddab3c29205a82310973e51fec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;State&lt;/code&gt;, which has to be the current state, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 做了状态过渡到 &lt;code&gt;State&lt;/code&gt; ，它必须是当前的状态，将 &lt;code&gt;NewData&lt;/code&gt; ，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3869ef62f08e2a10aa5bf3ec284cea8fd875bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the &lt;strong&gt;state transition&lt;/strong&gt;, and/or to use a dedicated &lt;strong&gt;state transition&lt;/strong&gt; function, but that is something you will have to remember at every &lt;strong&gt;state transition&lt;/strong&gt; to the state(s) that need it.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 引擎可以自动进行专门调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 每当进入一个新的状态; 参见 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 。这是用于编写所有状态条目通用的代码。做到这一点的另一种方法是在&lt;strong&gt;状态转换&lt;/strong&gt;处显式插入事件，和/或使用专用的&lt;strong&gt;状态转换&lt;/strong&gt;函数，但这是您在每次&lt;strong&gt;状态转换&lt;/strong&gt;到需要它的状态时都必须记住的事情。</target>
        </trans-unit>
        <trans-unit id="1ff91dbdb67dc0752a1cb136935a70afdac9c712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it.</source>
          <target state="translated">每当输入新状态时， &lt;code&gt;gen_statem&lt;/code&gt; 引擎就可以自动对 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 进行专门的调用。参见 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 。这是用于编写所有状态条目通用的代码。做到这一点的另一种方法是在状态转换处插入事件，和/或使用专用的状态转换函数，但这是您在每次状态转换到需要状态的状态时都必须记住的事情。</target>
        </trans-unit>
        <trans-unit id="298787bc0880c606f6d382d6ec4eea28eb66cd16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine will find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; of &lt;code&gt;NewModule&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; NewModule:callback_mode/0 &lt;/a&gt;&lt;/code&gt; before the next &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 引擎会找出 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;NewModule&lt;/code&gt; 通过调用 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; NewModule:callback_mode/0 &lt;/a&gt;&lt;/code&gt; 下一个前 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。 &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="609a55f5722ed6b61803cc1734f944814dbce653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; enqueues incoming events in order of arrival and presents these to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in that order. The state callback can postpone an event so it is not retried in the current state. After a state change the queue restarts with the postponed events.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 按到达顺序使进入的事件排队，并按该顺序将它们呈现给 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。状态回调可以推迟事件，因此不会在当前状态下重试该事件。状态更改后，队列将重新启动并推迟事件。</target>
        </trans-unit>
        <trans-unit id="63345530db17175adac9ec3a019543d210266d03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 事件队列模型是足够选择性接收以模拟正常过程消息队列。推迟事件对应于在接收语句中不匹配事件，而更改状态对应于输入新的接收语句。</target>
        </trans-unit>
        <trans-unit id="641237d979ff0a2d03c26c3ad66f07cb507fd0a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; has been set to trap exit signals.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 已被设置为捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="154bbf6641ffd5663c5aefea121dd325520717a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is globally registered in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 在全球范围内注册的 &lt;code&gt;global&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67b6a4a7c1fd3b7590f8afba5f3bf9c9be4abb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered on another node.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 是本地注册的另一个节点上。</target>
        </trans-unit>
        <trans-unit id="85f1bfb26c1bebdbfe3ea8eee17c7ba7fcaa85f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 是本地注册。</target>
        </trans-unit>
        <trans-unit id="dff17e2a1fe994c2de42244386fbbe29172ce5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is registered in an alternative process registry. The registry callback module &lt;code&gt;RegMod&lt;/code&gt; is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is the same as &lt;code&gt;{global,GlobalName}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 注册在替代进程注册表。注册表回调模块 &lt;code&gt;RegMod&lt;/code&gt; 将导出函数 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; 和 &lt;code&gt;send/2&lt;/code&gt; ，它们的行为类似于 &lt;code&gt;global&lt;/code&gt; 中的相应函数。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 与 &lt;code&gt;{global,GlobalName}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f744ffe4f5b7b57ef92ebf70203f5d38f475257a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state and data, or does a state transition to the current state if you like, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state_and_data&lt;/code&gt; is the same as &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 保持当前的状态和数据，或者做一个状态过渡到当前状态，如果你喜欢，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt; 相同。如果 &lt;code&gt;gen_statem&lt;/code&gt; 运行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，则状态输入调用将重复，请参见type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，否则 &lt;code&gt;repeat_state_and_data&lt;/code&gt; 与 &lt;code&gt;keep_state_and_data&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d475ad84f6e39a68e71be16a98a5f4760d76809d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state or does a state transition to the current state if you like, keeps the current server data, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，保留当前服务器数据，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6668d570fa47d65dc6496ac8a7e26666fa0a0e00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，设置 &lt;code&gt;NewData&lt;/code&gt; 并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。如果 &lt;code&gt;gen_statem&lt;/code&gt; 运行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，则将重复状态输入调用，请参见type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，否则 &lt;code&gt;repeat_state&lt;/code&gt; 与 &lt;code&gt;keep_state&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d700edd0442a4b2cb750903fd91d19af04ce58f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，设置 &lt;code&gt;NewData&lt;/code&gt; 并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8501d306024ff238059935aefd0de35838afe886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize the server. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; has returned.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 初始化服务器。为了确保同步启动过程，在返回 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 之前，不会返回 &lt;code&gt;start_link/3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="238d457fbc3808fc222aef2d6327199e92b50362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 过程可以进入休眠状态; 参见 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 在返回的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 列表中指定 &lt;code&gt;hibernate&lt;/code&gt; ，便完成了此操作。该功能在预期服务器长时间处于空闲状态时回收进程堆内存很有用。但是，请谨慎使用此功能，因为在每次事件后使用休眠方式的成本都很高。参见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3de78075e1ead85abb08c9961b0132a2121787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 过程可以进入休眠状态; 参见 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 在返回的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 列表中指定 &lt;code&gt;hibernate&lt;/code&gt; ，便完成了此操作。在预期服务器长时间处于空闲状态时，此功能对于回收进程堆内存很有用。但是，请谨慎使用此功能，因为在每次事件后使用休眠方式的成本都很高。参见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="881ead844dbebfad51980a814a9a4905aa6bf4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 异常终止，记录一个错误。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98d014159aa311c58e42eb49a30b95ce56872c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get-bulk&lt;/code&gt; operation for transferring large amounts of data.</source>
          <target state="translated">用于传输大量数据的 &lt;code&gt;get-bulk&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="ca7aa99a53f77bb03e023a14cb8a5dfa322719fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;realm&lt;/code&gt; filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, and assuming at most one of each AVP. If this is not the case then the &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; filters must be used to achieve the desired result. An empty &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (which should not be typical) matches all hosts/realms for the purposes of filtering.</source>
          <target state="translated">在 &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;realm&lt;/code&gt; 滤波器原因目的主机和目标的境界的AVP从呼出请求被提取，假设它是一个record-或列表值 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; ，并且假定每个AVP的至多一个。如果不是这种情况，则必须使用 &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; 过滤器才能获得所需的结果。空 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; （不应该是典型值）与所有主机/领域匹配，以进行过滤。</target>
        </trans-unit>
        <trans-unit id="1384604d97fc2fad058cb0b49328402f702a9c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; was successfully decoded but the path contains at least one character with non-UTF-8 encoding. In order to be able to decode this, you have to make assumptions about the encoding used in these triplets. The most obvious choice is</source>
          <target state="translated">所述 &lt;code&gt;host&lt;/code&gt; 被成功解码，但该路径包含与非UTF-8编码的至少一个字符。为了能够对此进行解码，您必须对这些三胞胎中使用的编码进行假设。最明显的选择是</target>
        </trans-unit>
        <trans-unit id="6d366d9713f6b9c72596126187499371839fd52b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, the Erlang interpreter.</source>
          <target state="translated">在 &lt;code&gt;i&lt;/code&gt; 模块提供了一些由图形调试器使用的功能和一些在模块的功能的简短形式 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ，Erlang的解释器。</target>
        </trans-unit>
        <trans-unit id="d1d8b2c5a7a92df360a05d4f0b328a8a9dec2469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_fast_element/2&lt;/code&gt; instruction is faster because the tuple is already an untagged integer. It also knows that the index is at least 1, so it does not have to test for that. The &lt;code&gt;i_element/4&lt;/code&gt; instruction will have to fetch the index from a register, test that it is an integer, and untag the integer.</source>
          <target state="translated">所述 &lt;code&gt;i_fast_element/2&lt;/code&gt; 指令是更快，因为元组是已经未加标签的整数。它还知道索引至少为1，因此不必对此进行测试。所述 &lt;code&gt;i_element/4&lt;/code&gt; 指令将不得不从寄存器取指数，测试它是否是一个整数，并取消标记的整数。</target>
        </trans-unit>
        <trans-unit id="ffe8d3c73461c97195740001f84500385e3636a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i_increment&lt;/code&gt; instruction is implemented like this:</source>
          <target state="translated">该 &lt;code&gt;i_increment&lt;/code&gt; 指令实现这样的：</target>
        </trans-unit>
        <trans-unit id="56dd7d3b9f60436a9a9021776dba220b9a35a843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; header represents the number of unique identifiers under a class when the option &lt;code&gt;{combine, true}&lt;/code&gt; is used (which is on by default). It will otherwise show the specific identifier. The &lt;code&gt;db_tab&lt;/code&gt; listing shows 722287 unique locks, it is one for each ets-table created and Mnesia creates one for each transaction.</source>
          <target state="translated">的 &lt;code&gt;id&lt;/code&gt; 标头表示的唯一标识符的一类下的数量，当选项 &lt;code&gt;{combine, true}&lt;/code&gt; 被使用（这是在默认情况下）。否则，它将显示特定的标识符。该 &lt;code&gt;db_tab&lt;/code&gt; 清单所示722287个独特的锁，它是一个用于创建的每个ETS-表的Mnesia创建一个为每个事务。</target>
        </trans-unit>
        <trans-unit id="0fc657f0d7c1adea0e37abaf50e5955d09748ddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; key is mandatory.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 关键是强制性的。</target>
        </trans-unit>
        <trans-unit id="543a86a9dbb014f2154dac485e637aa4987d5f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; type denotes an snmp index structure.</source>
          <target state="translated">的 &lt;code&gt;index()&lt;/code&gt; 类型表示一个SNMP索引结构。</target>
        </trans-unit>
        <trans-unit id="9e43b2120ef1641713607a20d5663b50e4bfd154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; field of a &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; record. Can have one of the following types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; 记录的 &lt;code&gt;info&lt;/code&gt; 字段。可以具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="1a3e0c6a3b85d7da20be620618cd94e4069d8c32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; functions return information as a list of pairs {Tag, term()} in some order about the state and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;info&lt;/code&gt; 函数返回的信息，对{标签，期限（1）}在有关国家的一些订单和列表 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 的的 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe1b7238dd78cc738fd7a6138cfed66a0946104d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init:get_arguments()&lt;/code&gt; call verifies that the correct arguments are supplied to the emulator.</source>
          <target state="translated">该 &lt;code&gt;init:get_arguments()&lt;/code&gt; 调用验证正确的参数被给仿真器。</target>
        </trans-unit>
        <trans-unit id="de26f216cc9cb8c745717da43fc15ae4239618cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">所述 &lt;code&gt;init&lt;/code&gt; 模块解释下面的命令行标志：</target>
        </trans-unit>
        <trans-unit id="9159e5b3d2da59b16c5905eba93189ce3aa15286" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; process itself interprets some of these flags, the &lt;strong&gt;init flags&lt;/strong&gt;. It also stores any remaining flags, the &lt;strong&gt;user flags&lt;/strong&gt;. The latter can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;init&lt;/code&gt; 过程本身的一些解释这些标志时，&lt;strong&gt;初始化标志&lt;/strong&gt;。它还存储所有剩余的标志，即&lt;strong&gt;用户标志&lt;/strong&gt;。可以通过调用 &lt;code&gt;init:get_argument/1&lt;/code&gt; 来检索后者。</target>
        </trans-unit>
        <trans-unit id="808f537737de60102eb2d48a20a77f05a231d51c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The intention is that this function initiates the encryption or decryption for example by calling &lt;code&gt;crypto:crypto_init/4&lt;/code&gt; or similar. The &lt;code&gt;crypto_state()&lt;/code&gt; is the state such a function may return.</source>
          <target state="translated">所述 &lt;code&gt;init_fun()&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; 被以任何其他施加一次现有 &lt;code&gt;crypto&lt;/code&gt; 操作。目的是该功能例如通过调用 &lt;code&gt;crypto:crypto_init/4&lt;/code&gt; 或类似方法来启动加密或解密。所述 &lt;code&gt;crypto_state()&lt;/code&gt; 是这样一个函数可能返回的状态。</target>
        </trans-unit>
        <trans-unit id="a00463fc2a7f182be0da0183c5213eee9fd19f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert_emp/3&lt;/code&gt; arguments are as follows:</source>
          <target state="translated">所述 &lt;code&gt;insert_emp/3&lt;/code&gt; 参数如下：</target>
        </trans-unit>
        <trans-unit id="35e63d83642fa80f496dd6056b90a430ea6b3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; module has been extended along with the actual I/O protocol to handle Unicode data. This means that many functions require binaries to be in UTF-8, and there are modifiers to format control sequences to allow for output of Unicode strings.</source>
          <target state="translated">在 &lt;code&gt;io&lt;/code&gt; 模块已经与所述实际I / O协议来处理Unicode数据扩展沿。这意味着许多函数要求二进制文件使用UTF-8，并且有一些修饰符可以格式化控制序列以允许输出Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="abc6624cbf5af8be037d2670ec76b72f4b7f1113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip&lt;/code&gt; Reference ID takes an &lt;code&gt;inet:ip_address()&lt;/code&gt; or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element.</source>
          <target state="translated">的 &lt;code&gt;ip&lt;/code&gt; 参考ID接受一个 &lt;code&gt;inet:ip_address()&lt;/code&gt; 或字符串格式（例如，&amp;ldquo;10.0.1.1&amp;rdquo;或&amp;ldquo;1234 :: 5678：9012&amp;rdquo;）的IP地址作为第二元件。</target>
        </trans-unit>
        <trans-unit id="a7ee8c582d46917ec81790ab0ac53e2589a28393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is_set_ok&lt;/code&gt; function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</source>
          <target state="translated">所述 &lt;code&gt;is_set_ok&lt;/code&gt; 函数检查该行要被修改或删除是否存在，以及一个行要被创建的不存在。</target>
        </trans-unit>
        <trans-unit id="3f824fe79494e6524fbde8189315044778985916" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jer&lt;/code&gt; encoding rules (ITU-T X.697) are experimental in OTP 22. There is support for a subset of the X.697 standard, for example there is no support for:</source>
          <target state="translated">在 &lt;code&gt;jer&lt;/code&gt; 编码规则（ITU-T X.697）是实验在OTP 22.是用于X.697标准的一个子集支持，例如不存在用于支持：</target>
        </trans-unit>
        <trans-unit id="ff7f1bbdc59c16a06c62efdccc8b7854b7407424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key()&lt;/code&gt; type correlates to the &lt;code&gt;key_types()&lt;/code&gt; type. If the &lt;code&gt;key_types()&lt;/code&gt; is a single atom, the corresponding &lt;code&gt;key()&lt;/code&gt; is a single type as well, but if the &lt;code&gt;key_types()&lt;/code&gt; is a tuple, &lt;code&gt;key&lt;/code&gt; must be a tuple of the same size.</source>
          <target state="translated">的 &lt;code&gt;key()&lt;/code&gt; 类型相关于 &lt;code&gt;key_types()&lt;/code&gt; 的类型。如果 &lt;code&gt;key_types()&lt;/code&gt; 是单个原子，则相应的 &lt;code&gt;key()&lt;/code&gt; 也是单个类型，但是如果 &lt;code&gt;key_types()&lt;/code&gt; 是一个元组，则 &lt;code&gt;key&lt;/code&gt; 必须是相同大小的元组。</target>
        </trans-unit>
        <trans-unit id="5cac72dd809c7185a7dcb83183f4f89c08277c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type defines the types of the SNMP INDEX columns for the table. If the table has one single INDEX column, this type should be a single atom, but if the table has multiple INDEX columns, it should be a tuple with atoms.</source>
          <target state="translated">所述 &lt;code&gt;key_types()&lt;/code&gt; 类型定义了类型SNMP INDEX列表中的。如果表具有单个INDEX列，则此类型应为单个原子，但如果表具有多个INDEX列，则应为具有原子的元组。</target>
        </trans-unit>
        <trans-unit id="a81df154de4b4c4f859872829034600f9ab7e463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type is used when creating the index structure, and the &lt;code&gt;key()&lt;/code&gt; type is used when inserting and deleting items from the structure.</source>
          <target state="translated">所述 &lt;code&gt;key_types()&lt;/code&gt; 创建索引结构时类型被使用，并且 &lt;code&gt;key()&lt;/code&gt; 插入和删除从该结构项目时类型被使用。</target>
        </trans-unit>
        <trans-unit id="555d2dccfadbf0b7e5219e84813fd3bd45eaaf5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypos&lt;/code&gt; of the table dumped to file, which is used when loading the table again.</source>
          <target state="translated">表的 &lt;code&gt;keypos&lt;/code&gt; 转储到文件中，在再次加载表时使用。</target>
        </trans-unit>
        <trans-unit id="f7afe180cd162bc0e597b4a20726157b5ac4e0bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;killproc&lt;/code&gt; procedure is not to be removed. The purpose is here to move from run level 3 (multi-user mode with networking resources) to run level 2 (multi-user mode without such resources), in which Erlang is not to run.</source>
          <target state="translated">该 &lt;code&gt;killproc&lt;/code&gt; 程序不被删除。目的是从运行级别3（具有网络资源的多用户模式）移至运行级别2（没有此类资源的多用户模式），在该级别中，将不运行Erlang。</target>
        </trans-unit>
        <trans-unit id="03c484e3840400c5a5e9dd6a195fc19b5d1faa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, &lt;code&gt;label&lt;/code&gt; is used to identify the separate traces. Default is 0.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 组件是标识属于同一顺序跟踪的所有事件的术语。如果几个连续的迹线可以同时处于活动状态，则使用 &lt;code&gt;label&lt;/code&gt; 标识单独的迹线。默认值为0。</target>
        </trans-unit>
        <trans-unit id="8ada4b47638c77da9291a9bd47140e9b15fe504a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_free&lt;/code&gt; and &lt;code&gt;number_of_free&lt;/code&gt; tags are currently only returned on a VxWorks system.</source>
          <target state="translated">该 &lt;code&gt;largest_free&lt;/code&gt; 和 &lt;code&gt;number_of_free&lt;/code&gt; 标签目前只能返回VxWorks系统上。</target>
        </trans-unit>
        <trans-unit id="47c985889700e94be33eba8b924bf9a3dfed0540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lcnt&lt;/code&gt; module is used to profile the internal ethread locks in the Erlang Runtime System. With &lt;code&gt;lcnt&lt;/code&gt; enabled, internal counters in the runtime system are updated each time a lock is taken. The counters stores information about the number of acquisition tries and the number of collisions that has occurred during the acquisition tries. The counters also record the waiting time a lock has caused for a blocked thread when a collision has occurred.</source>
          <target state="translated">在 &lt;code&gt;lcnt&lt;/code&gt; 模块用于轮廓在Erlang运行时系统中的内部ETHREAD锁。与 &lt;code&gt;lcnt&lt;/code&gt; 启用，在运行时系统的内部计数器的每一个的锁被取时进行更新。计数器存储有关获取尝试次数和获取尝试期间发生的冲突次数的信息。计数器还记录发生冲突时锁导致线程阻塞的等待时间。</target>
        </trans-unit>
        <trans-unit id="b187fc5e5c5e9c948af3fd95dc59f5d10e6fe566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;list_in&lt;/code&gt; 项必须属于环境 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2831975c1bbe04314d3d0e20134569769f4c8e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_mf_h&lt;/code&gt; handler writes all reports to a report logging directory, which is specified when configuring the SASL application.</source>
          <target state="translated">该 &lt;code&gt;log_mf_h&lt;/code&gt; 处理程序会将所有报告的报告日志目录，这是配置SASL应用程序时指定。</target>
        </trans-unit>
        <trans-unit id="c42c9a83ba0cfd927135745afcf8a51d16e0e657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;map_in&lt;/code&gt; 项必须属于环境 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4596e3e12adaafb27a37675223c89e5e8290b48e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match_fun&lt;/code&gt; takes two arguments and returns either &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;. The value &lt;code&gt;default&lt;/code&gt; will invoke the default match function.</source>
          <target state="translated">该 &lt;code&gt;match_fun&lt;/code&gt; 有两个参数，并返回要么 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 。该值 &lt;code&gt;default&lt;/code&gt; 将调用默认的匹配功能。</target>
        </trans-unit>
        <trans-unit id="8b940d5eaace9d3d7a8384b7f450246290a324ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_path_length&lt;/code&gt; is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if &lt;code&gt;max_path_length&lt;/code&gt; is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.</source>
          <target state="translated">该 &lt;code&gt;max_path_length&lt;/code&gt; 是可以遵循的有效证书路径对证书的非自发放的中间证书的最大数量。因此，如果 &lt;code&gt;max_path_length&lt;/code&gt; 为0，则PEER必须直接由受信任的ROOT-CA签名，如果为1，则路径可以为PEER，CA，ROOT-CA，如果为2，则路径可以为PEER，CA， CA，ROOT-CA等。</target>
        </trans-unit>
        <trans-unit id="38b7f85ec648548ce222a27921a129e6b78760bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mib_to_hrl&lt;/code&gt; generator can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.bin&lt;/code&gt;, and invokes this function for files with that extension.</source>
          <target state="translated">所述 &lt;code&gt;mib_to_hrl&lt;/code&gt; 发生器可以从OS的命令行通过使用命令调用 &lt;code&gt;erlc&lt;/code&gt; 。 &lt;code&gt;erlc&lt;/code&gt; 识别扩展名 &lt;code&gt;.bin&lt;/code&gt; ，并对具有该扩展名的文件调用此函数。</target>
        </trans-unit>
        <trans-unit id="8c1d578ccfe04ced0a4858e6e98da0fd19d29b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mods_and_procs&lt;/code&gt; and &lt;code&gt;funcs_and_procs&lt;/code&gt; filters are equivalent to the &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;functions&lt;/code&gt; filters respectively, except that each module or function can have many vertical lines, one for each process it resides on.</source>
          <target state="translated">的 &lt;code&gt;mods_and_procs&lt;/code&gt; 和 &lt;code&gt;funcs_and_procs&lt;/code&gt; 滤波器等同于 &lt;code&gt;modules&lt;/code&gt; 和 &lt;code&gt;functions&lt;/code&gt; 分别过滤器，不同之处在于每个模块或功能可以有许多垂直的线，一个用于每个它驻留在进程。</target>
        </trans-unit>
        <trans-unit id="629670db402f7cde732ec01282578c7159f3daad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; functions of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">该 &lt;code&gt;module&lt;/code&gt; 选件能够为用户提供他们自己的回调模块。当接收到新消息时，将调用此模块的 &lt;code&gt;receive_message/4&lt;/code&gt; 或 &lt;code&gt;process_received_message/4&lt;/code&gt; 函数（取决于消息的大小；小-receive_message，大-process_received_message）。默认值为&lt;strong&gt;megaco&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4039dc8c38a872b706a72298a0693bdeed53b2b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The functions &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">该 &lt;code&gt;module&lt;/code&gt; 选件能够为用户提供他们自己的回调模块。当接收到新消息时，将调用此模块的函数 &lt;code&gt;receive_message/4&lt;/code&gt; 或 &lt;code&gt;process_received_message/4&lt;/code&gt; （取决于消息的大小；其中小-receive_message，大-process_received_message）。默认值为&lt;strong&gt;megaco&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1fa747bd68db4bc817397fca349049b0c0c2bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_info/0&lt;/code&gt; function in each module, returns a list of &lt;code&gt;{Key,Value}&lt;/code&gt; tuples with information about the module. Currently, the list contain tuples with the following &lt;code&gt;Key&lt;/code&gt;s: &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt;, &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;. The order and number of tuples may change without prior notice.</source>
          <target state="translated">每个模块中的 &lt;code&gt;module_info/0&lt;/code&gt; 函数返回 &lt;code&gt;{Key,Value}&lt;/code&gt; 元组的列表，其中包含有关该模块的信息。当前，列表包含具有以下 &lt;code&gt;Key&lt;/code&gt; 的元组： &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;attributes&lt;/code&gt; ， &lt;code&gt;compile&lt;/code&gt; ， &lt;code&gt;exports&lt;/code&gt; ， &lt;code&gt;md5&lt;/code&gt; 和 &lt;code&gt;native&lt;/code&gt; 。元组的顺序和数量如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="13c3af4d94c692779fc270d51ec8836243a76c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; filter shows each module as a vertical line in the sequence diagram. External function calls/returns are shown as interactions between modules, and internal function calls/returns are shown as activities within a module.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 过滤器示出了每个模块作为序列图的垂直线。外部函数调用/返回显示为模块之间的交互，内部函数调用/返回显示为模块内的活动。</target>
        </trans-unit>
        <trans-unit id="220a661131b4c202e09615fa7794089d54019aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not given, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 关键是可选的。如果未给出，则默认为 &lt;code&gt;[M]&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 来自孩子的开头 &lt;code&gt;{M,F,A}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3890e0d50c45d6e12a18dbc1aec19b335349f526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 关键是可选的。如果未指定，则默认为 &lt;code&gt;[M]&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 来自孩子的开头 &lt;code&gt;{M,F,A}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b73b08f6879f5bf7ade5d9880f8cf1f512709fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native&lt;/code&gt; time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the &lt;code&gt;native&lt;/code&gt; time unit of the new runtime system instance can differ from the &lt;code&gt;native&lt;/code&gt; time unit of the old runtime system instance.</source>
          <target state="translated">所述 &lt;code&gt;native&lt;/code&gt; 时间单元在运行时系统开始确定，并且保持相同，直到运行时系统终止。如果运行时系统会停止，然后再次启动（即使是在同一台机器上），在 &lt;code&gt;native&lt;/code&gt; 的新的运行时系统实例的时间单位可以从不同的 &lt;code&gt;native&lt;/code&gt; 老运行系统实例的时间单位。</target>
        </trans-unit>
        <trans-unit id="e77d232e74f552cf373975f9713b96716de00e8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_kernel&lt;/code&gt; process terminated.</source>
          <target state="translated">所述 &lt;code&gt;net_kernel&lt;/code&gt; 过程终止。</target>
        </trans-unit>
        <trans-unit id="33c94a1185ccb7943d79b55ac568ef3bf3963cc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_ticktime&lt;/code&gt; changes must be initiated on all nodes in the network (with the same &lt;code&gt;NetTicktime&lt;/code&gt;) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</source>
          <target state="translated">所述 &lt;code&gt;net_ticktime&lt;/code&gt; 变化必须在网络中的所有节点（具有相同的上启动 &lt;code&gt;NetTicktime&lt;/code&gt; 任何节点上的任何过渡期结束前）; 否则可能会错误地断开连接。</target>
        </trans-unit>
        <trans-unit id="88d35276b805d419b7b2b451eec9f43dfbe3fb9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;reuse&lt;/code&gt; options might seem convenient in a production system, but consider that the logs grow indefinitely during the system lifetime and cannot be truncated, except if the service is restarted.</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;reuse&lt;/code&gt; 的选项似乎在生产系统中方便，但考虑到该日志的系统生命周期内无限增长，不能被截断，除非重新启动该服务。</target>
        </trans-unit>
        <trans-unit id="ffcaa93ee15ba09c39cb246f4b83efb0388fde54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates a new variable in the database with a default value as defined in the MIB, or a zero value (depending on the type).</source>
          <target state="translated">的 &lt;code&gt;new&lt;/code&gt; 函数创建与在MIB中定义的默认值，或零值（取决于类型）数据库中的一个新的变量。</target>
        </trans-unit>
        <trans-unit id="2000d16d511f7d3865cad4dec402c68d50d75e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates the table if it does not exist, but only if the database is the SNMP internal db.</source>
          <target state="translated">该 &lt;code&gt;new&lt;/code&gt; 功能创建表，如果它不存在，但只有当数据库是SNMP内部分贝。</target>
        </trans-unit>
        <trans-unit id="2d170f32fbd322133bb3d50a0e41f54d86fe7d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, as in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">该 &lt;code&gt;nteventlog&lt;/code&gt; 模块用于实现 &lt;code&gt;os_sup&lt;/code&gt; 。参见 &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 。请注意，不需要使用 &lt;code&gt;nteventlog&lt;/code&gt; 的启动功能，因为在这种情况下，该过程作为OS_Mon监视树的一部分自动启动。</target>
        </trans-unit>
        <trans-unit id="fe241cbaac0cb96b60c93ae96dc9889cf2b5f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">该 &lt;code&gt;nteventlog&lt;/code&gt; 模块用于实现 &lt;code&gt;os_sup&lt;/code&gt; 。参见 &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 。请注意，不需要使用 &lt;code&gt;nteventlog&lt;/code&gt; 的启动功能，在这种情况下，该过程将作为OS_Mon监视树的一部分自动启动。</target>
        </trans-unit>
        <trans-unit id="e2bfdbeebfa5a9fe7cf75fe729c76e05070db8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</source>
          <target state="translated">该 &lt;code&gt;obj&lt;/code&gt; 参数是指向该资源。析构函数中对资源的唯一允许使用是最后一次访问其用户数据。保证析构函数是释放资源之前的最后一个回调。</target>
        </trans-unit>
        <trans-unit id="7ceb6922f1bc2b55a11a196aefd83fd27d2d6cd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; if no chain of calls between the given constants can be found.</source>
          <target state="translated">的 &lt;code&gt;of&lt;/code&gt; 操作符返回 &lt;code&gt;false&lt;/code&gt; ，如果没有给定的常数之间的调用链都可以找到。</target>
        </trans-unit>
        <trans-unit id="edc8f1a9759344cda2be6a01281eb7cf8541e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;after&lt;/code&gt; sections are all optional, as long as there is at least a &lt;code&gt;catch&lt;/code&gt; or an &lt;code&gt;after&lt;/code&gt; section. So the following are valid &lt;code&gt;try&lt;/code&gt; expressions:</source>
          <target state="translated">所述 &lt;code&gt;of&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ，和 &lt;code&gt;after&lt;/code&gt; 段都是可选的，只要有至少一个 &lt;code&gt;catch&lt;/code&gt; 或 &lt;code&gt;after&lt;/code&gt; 部。因此，以下是有效的 &lt;code&gt;try&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="ebc057ad457a36d0493c7c4827deec0d89f9db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid()&lt;/code&gt; type is used to represent an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">的 &lt;code&gt;oid()&lt;/code&gt; 类型用于代表一个ASN.1对象标识符。</target>
        </trans-unit>
        <trans-unit id="c317ddfbc946c81f789ac77305cd9d495bd67257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordered_set&lt;/code&gt; works on the &lt;strong&gt;Erlang term order&lt;/strong&gt; and no defined order exists between an &lt;code&gt;integer()&lt;/code&gt; and a &lt;code&gt;float()&lt;/code&gt; that extends to the same value. Hence the key &lt;code&gt;1&lt;/code&gt; and the key &lt;code&gt;1.0&lt;/code&gt; are regarded as equal in an &lt;code&gt;ordered_set&lt;/code&gt; table.</source>
          <target state="translated">的 &lt;code&gt;ordered_set&lt;/code&gt; 的运作上&lt;strong&gt;Erlang项顺序&lt;/strong&gt;和一个之间不存在定义的顺序 &lt;code&gt;integer()&lt;/code&gt; 和 &lt;code&gt;float()&lt;/code&gt; 延伸到相同的值。因此，键 &lt;code&gt;1&lt;/code&gt; 和键 &lt;code&gt;1.0&lt;/code&gt; 在 &lt;code&gt;ordered_set&lt;/code&gt; 表中被视为相等。</target>
        </trans-unit>
        <trans-unit id="23f84a949184c1de5bc030233161e9c4c0b92121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;originating&lt;/code&gt; options effects discovery initiated by this agent.</source>
          <target state="translated">在 &lt;code&gt;originating&lt;/code&gt; 此代理启动选项效应的发现。</target>
        </trans-unit>
        <trans-unit id="ccd973135b90cc097810c0c2b724141ea8487e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; syntax:</source>
          <target state="translated">该 &lt;code&gt;otp_patch_apply&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="8bdd7004ea407fa82763663af39ba15a0e1f25f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; tool utilizes the &lt;code&gt;runtime_dependencies&lt;/code&gt; tag in the &lt;code&gt;application resource file&lt;/code&gt;. This information is used to determine if the patch can be installed in the given Erlang/OTP installation directory.</source>
          <target state="translated">该 &lt;code&gt;otp_patch_apply&lt;/code&gt; 工具利用 &lt;code&gt;runtime_dependencies&lt;/code&gt; 在标签 &lt;code&gt;application resource file&lt;/code&gt; 。此信息用于确定是否可以在给定的Erlang / OTP安装目录中安装补丁。</target>
        </trans-unit>
        <trans-unit id="8315d03358900e027c0447a981ac995840fffee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; function allocates the work area of the asynchronous function. As we use C++, we use a struct, and stuff the data in it. We must copy the original data, it is not valid after we have returned from the &lt;code&gt;output&lt;/code&gt; function, and the &lt;code&gt;do_perm&lt;/code&gt; function is called later, and from another thread. We return no data here, instead it is sent later from the &lt;code&gt;ready_async&lt;/code&gt; callback.</source>
          <target state="translated">该 &lt;code&gt;output&lt;/code&gt; 功能分配异步函数的工作区。在使用C ++时，我们使用一个结构，并将数据填充到其中。我们必须复制原始数据，从 &lt;code&gt;output&lt;/code&gt; 函数返回后，它无效，然后稍后再从另一个线程调用 &lt;code&gt;do_perm&lt;/code&gt; 函数。我们在这里不返回任何数据，而是稍后从 &lt;code&gt;ready_async&lt;/code&gt; 回调发送该数据。</target>
        </trans-unit>
        <trans-unit id="71aa4ffe227f9aa33da51854c389c54a822efeef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; format is an internal representation that can be passed to &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;forms&lt;/code&gt; format can be passed to &lt;code&gt;compile:forms/2&lt;/code&gt;. The &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;hrl&lt;/code&gt; formats are returned as iolists.</source>
          <target state="translated">的 &lt;code&gt;parse&lt;/code&gt; 格式是可以传递到内部表示 &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;forms&lt;/code&gt; 格式可以传递给 &lt;code&gt;compile:forms/2&lt;/code&gt; 。该 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;hrl&lt;/code&gt; 格式返回iolists。</target>
        </trans-unit>
        <trans-unit id="9ac6e1b83188e6ba00253b80c4e4e283b31e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option is used for pointing out the old version of all applications. (The new versions are already in the code path - assuming of course that the Erlang node on which this is executed is running the correct version of Erlang/OTP.)</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 选项用于指明了旧版本的所有应用程序。（新版本已在代码路径中-当然，要假定执行此操作的Erlang节点正在运行正确版本的Erlang / OTP。）</target>
        </trans-unit>
        <trans-unit id="24e00a9507fa707a286aad7abe3e3cd07325080a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pending_driver&lt;/code&gt;&lt;code&gt;MonitorOption&lt;/code&gt; is by far the most useful. It must be used to ensure that the driver really is unloaded and the ports closed whenever option &lt;code&gt;kill_ports&lt;/code&gt; is used, or the driver can have been loaded with driver option &lt;code&gt;kill_ports&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;pending_driver&lt;/code&gt; &lt;code&gt;MonitorOption&lt;/code&gt; 是迄今为止最有用的。每当使用选项 &lt;code&gt;kill_ports&lt;/code&gt; 或可以使用驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 加载驱动程序时，必须使用它来确保确实卸载了驱动程序并关闭了端口。</target>
        </trans-unit>
        <trans-unit id="7752015e6089336570fa00078221b8ccabc19aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt; os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;perf_counter&lt;/code&gt; 时间单位的行为多以同样的方式为 &lt;code&gt;native&lt;/code&gt; 时间单位。也就是说，运行时重新启动之间可能有所不同。要获取此类型的值，请调用 &lt;code&gt; os:perf_counter/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f36e06928220660615452de6fef2258f5362fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt;os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;perf_counter&lt;/code&gt; 时间单位的行为多以同样的方式为 &lt;code&gt;native&lt;/code&gt; 时间单位。也就是说，运行时重新启动之间可能有所不同。要获取此类型的值，请调用 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b9f8d1ef7145eb704be87bd7e74e2fde38ff315" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg2&lt;/code&gt; module is deprecated as of OTP 23 and scheduled for removal in OTP 24. You are advised to replace the usage of &lt;code&gt;pg2&lt;/code&gt; with &lt;code&gt;pg&lt;/code&gt;. &lt;code&gt;pg&lt;/code&gt; has a similar API, but with an implementation that is more scalable. See the documentation of &lt;code&gt;pg&lt;/code&gt; for more information about differences.</source>
          <target state="translated">该 &lt;code&gt;pg2&lt;/code&gt; 模块不赞成OTP 23中，预计去除OTP 24.建议您在更换的使用 &lt;code&gt;pg2&lt;/code&gt; 与 &lt;code&gt;pg&lt;/code&gt; 。 &lt;code&gt;pg&lt;/code&gt; 具有类似的API，但具有可扩展性更高的实现。有关差异的更多信息，请参见 &lt;code&gt;pg&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="d3ddb3f0153c3890640ae834ac81e6898f916068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; parameter is a pointer to a &lt;code&gt;erlang_pid&lt;/code&gt; that the function will update with the pid associated with the global name, if successful.</source>
          <target state="translated">该 &lt;code&gt;pid&lt;/code&gt; 参数是一个指向 &lt;code&gt;erlang_pid&lt;/code&gt; 该函数将与全局名称相关联的PID如果成功更新。</target>
        </trans-unit>
        <trans-unit id="8ff6f3b7d18bc68a03a8f098e3306bea8afa3388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pread/3,4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;pread/3,4&lt;/code&gt; 函数从指定的位置读出，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="1d5e46480f01a8aa86737f226ba56bdcb171312f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; fields in the elements of the list contain the value of the pointer, a modification marker, and a deleted marker. Memory operations on these fields are done using atomic memory operations. When a thread has set the modification marker in a field, no-one except the thread that set the marker is allowed to modify the field. If multiple modification markers need to be set, we always begin with &lt;code&gt;next&lt;/code&gt; fields followed by &lt;code&gt;prev&lt;/code&gt; fields in the order following the actual pointers. This guarantees that no deadlocks will occur.</source>
          <target state="translated">的 &lt;code&gt;prev&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 在列表中的元素的字段包含的指针，修改标记，和一个删除的标记的值。这些字段上的存储操作是使用原子存储操作完成的。当线程在字段中设置了修改标记时，除设置标记的线程外，不允许其他人修改字段。如果多重修改标记需要进行设置，我们总是首先 &lt;code&gt;next&lt;/code&gt; 领域，然后 &lt;code&gt;prev&lt;/code&gt; 如下实际指针的顺序领域。这样可以保证不会发生死锁。</target>
        </trans-unit>
        <trans-unit id="8ade504b785b0942df35eaf3b82afa6476a54cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended it does so in a structured manner.</source>
          <target state="translated">在 &lt;code&gt;priv&lt;/code&gt; 目录保存资产，应用程序运行时的需要。可执行文件应驻留在 &lt;code&gt;priv/bin&lt;/code&gt; 中,而动态链接的库应驻留在 &lt;code&gt;priv/lib&lt;/code&gt; 中。其他资产可以自由地驻留在 &lt;code&gt;priv&lt;/code&gt; 目录中，但是建议以结构化的方式这样做。</target>
        </trans-unit>
        <trans-unit id="6b2507225c4f70efae176a5a0a6b4b0633e1f261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended they do so in a structured manner.</source>
          <target state="translated">在 &lt;code&gt;priv&lt;/code&gt; 目录保存资产，应用程序运行时的需要。可执行文件应驻留在 &lt;code&gt;priv/bin&lt;/code&gt; 中,而动态链接的库应驻留在 &lt;code&gt;priv/lib&lt;/code&gt; 中。其他资产可以自由地驻留在 &lt;code&gt;priv&lt;/code&gt; 目录中，但是建议以结构化的方式驻留它们。</target>
        </trans-unit>
        <trans-unit id="a744587962b51e3c606263db57ff07f274e44a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processes&lt;/code&gt; filter is the only filter showing all trace messages from a trace log. Each vertical line in the sequence diagram represents a process. Erlang messages, spawn, and link/unlink are typical interactions between processes. Function calls, scheduling, and garbage collection, are typical activities within a process. &lt;code&gt;processes&lt;/code&gt; is the default filter.</source>
          <target state="translated">该 &lt;code&gt;processes&lt;/code&gt; 滤波器是表示从跟踪日志中的所有跟踪消息的唯一的过滤器。顺序图中的每条垂直线代表一个过程。Erlang消息，生成和链接/取消链接是进程之间的典型交互。函数调用，调度和垃圾回收是流程中的典型活动。 &lt;code&gt;processes&lt;/code&gt; 是默认过滤器。</target>
        </trans-unit>
        <trans-unit id="3861f99e16c84fe5707ca3129e815480d2eca579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwrite/3,4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;pwrite/3,4&lt;/code&gt; 函数写入到一个指定的位置，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="a4939b64de1d53ed04f7d5997288438bc45d2be8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module evaluates this differently depending on the query handles &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;. If, for example, &lt;code&gt;X2&lt;/code&gt; is matched against the key of a QLC table, the lookup join method traverses the objects of &lt;code&gt;QH2&lt;/code&gt; while looking up key values in the table. However, if not &lt;code&gt;X2&lt;/code&gt; or &lt;code&gt;Y2&lt;/code&gt; is matched against the key or an indexed position of a QLC table, the merge join method ensures that &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; are both sorted on position 2 and next do the join by traversing the objects one by one.</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块评估此不同，这取决于查询处理 &lt;code&gt;QH1&lt;/code&gt; 和 &lt;code&gt;QH2&lt;/code&gt; 。例如，如果 &lt;code&gt;X2&lt;/code&gt; 与QLC表的键匹配，则查找联接方法将在查找表中的键值时遍历 &lt;code&gt;QH2&lt;/code&gt; 的对象。但是，如果 &lt;code&gt;X2&lt;/code&gt; 或 &lt;code&gt;Y2&lt;/code&gt; 没有与QLC表的键或索引位置匹配，则合并 &lt;code&gt;QH1&lt;/code&gt; 方法可确保QH1和 &lt;code&gt;QH2&lt;/code&gt; 都在位置2上排序，然后通过逐个遍历对象来进行联接。</target>
        </trans-unit>
        <trans-unit id="7bdc283a4e0d387d9b4fe3c9cce9b3813bddfd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module supports fast join of two query handles. Fast join is possible if some position &lt;code&gt;P1&lt;/code&gt; of one query handler and some position &lt;code&gt;P2&lt;/code&gt; of another query handler are tested for equality. Two fast join methods are provided:</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块支持快速连接两个查询句柄。快速连接是可能的，如果某些位置 &lt;code&gt;P1&lt;/code&gt; 一个查询处理程序和一些位置 &lt;code&gt;P2&lt;/code&gt; 另一个查询处理的都是平等的测试。提供了两种快速连接方法：</target>
        </trans-unit>
        <trans-unit id="4dc69ce9649099f1a16568929e4dca5a9ec4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块警告在编译时如果QLC联合查询以这样的方式来处理多个连接是可能的。也就是说，没有提供可以在可能的联接操作之间选择良好顺序的查询计划器。用户可以通过引入查询句柄来对联接进行排序。</target>
        </trans-unit>
        <trans-unit id="1ac4329d09995d8cc50dafbae48fcd60ee3ef172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re&lt;/code&gt; module allows for matching Unicode strings as a special option. As the library is centered on matching in binaries, the Unicode support is UTF-8-centered.</source>
          <target state="translated">在 &lt;code&gt;re&lt;/code&gt; 模块允许符合Unicode字符串作为一个特殊的选项。由于库的重点是二进制匹配，因此Unicode支持以UTF-8为中心。</target>
        </trans-unit>
        <trans-unit id="412cfcfb79171f8451db72dbfc6769aeeae48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_ahead&lt;/code&gt; buffer is also highly used by function &lt;code&gt;read_line/1&lt;/code&gt; in &lt;code&gt;raw&lt;/code&gt; mode, therefore this option is recommended (for performance reasons) when accessing raw files using that function.</source>
          <target state="translated">所述 &lt;code&gt;read_ahead&lt;/code&gt; 缓冲器也被高度使用功能 &lt;code&gt;read_line/1&lt;/code&gt; 中 &lt;code&gt;raw&lt;/code&gt; 使用该函数访问原始文件时模式，因此建议该选项（出于性能原因）。</target>
        </trans-unit>
        <trans-unit id="1d7e68fecfc79e8020cc09ac14cad9865216cb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_io&lt;/code&gt; function is called when the socket we got from postgres is ready for input or output. Here we first check if we are connecting to the database. In that case, we check connection status and return OK if the connection is successful, or error if it is not. If the connection is not yet established, we simply return; &lt;code&gt;ready_io&lt;/code&gt; is called again.</source>
          <target state="translated">该 &lt;code&gt;ready_io&lt;/code&gt; 当我们从Postgres的拿到插槽中可以输入或输出函数被调用。在这里，我们首先检查是否要连接到数据库。在这种情况下，我们将检查连接状态，如果连接成功则返回OK，否则返回错误。如果尚未建立连接，我们只返回即可； &lt;code&gt;ready_io&lt;/code&gt; 再次被调用。</target>
        </trans-unit>
        <trans-unit id="c5f336c46236fef6d33a9737fecfbc45848cc85a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; construct is used to allow processes to wait for messages from other processes. It has the following format:</source>
          <target state="translated">所述 &lt;code&gt;receive&lt;/code&gt; 结构用于允许进程等待来自其它进程的消息。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="37481113af1fc6bf67ec51a1b4573b5766d4940d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; expression can be augmented with a timeout:</source>
          <target state="translated">所述 &lt;code&gt;receive&lt;/code&gt; 表达可以与一个超时来增强：</target>
        </trans-unit>
        <trans-unit id="42725fa1b02c7390bf310c7b5f650def33047bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receiver&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">首先将向 &lt;code&gt;receiver&lt;/code&gt; 发送 &lt;code&gt;snmp_targets&lt;/code&gt; 消息，然后为&amp;ldquo; &lt;code&gt;Addresses&lt;/code&gt; 列表中的每个地址发送两个 &lt;code&gt;snmp_notification&lt;/code&gt; 消息之一。</target>
        </trans-unit>
        <trans-unit id="d783190c30a4c184095fc9fe7326cabca7bed37e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt; driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt; driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt; driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;refc&lt;/code&gt; 场已被删除。 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 的引用计数现在存储在其他位置。一个的引用计数 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 可以通过被访问 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt; driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt; driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt; driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e35f7f5fad0e5d56316957219823696de6e6786c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;refc&lt;/code&gt; 场已被删除。 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 的引用计数现在存储在其他位置。一个的引用计数 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 可以通过被访问 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82f0b91245f77a3b886c273dd05b9767b42d775d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="translated">该 &lt;code&gt;registry&lt;/code&gt; 的功能性的一部分 &lt;code&gt;erl_interface&lt;/code&gt; 是作为 &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; ，将在OTP 24被移除。</target>
        </trans-unit>
        <trans-unit id="660ed54d5ac1fcd2169600b38b40bd925d66cf86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_handler&lt;/code&gt; copies these files to the &lt;code&gt;bin&lt;/code&gt; directory in the client directory at the master nodes whenever a new release is made permanent.</source>
          <target state="translated">每当使新发行版成为永久发行版时， &lt;code&gt;release_handler&lt;/code&gt; 会将这些文件复制到主节点上客户端目录中的 &lt;code&gt;bin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="56830d582041a2d058cd8b9ca80ec725e5c3e287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reload&lt;/code&gt; option can be either of the following:</source>
          <target state="translated">该 &lt;code&gt;reload&lt;/code&gt; 选项可以是以下几点：</target>
        </trans-unit>
        <trans-unit id="207c0a4a6dd7d54555e6c470a0c170ec46378f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains instructions for how to upgrade to, or downgrade from, this version of the release.</source>
          <target state="translated">该 &lt;code&gt;relup&lt;/code&gt; 文件包含如何升级到，或从该版本的发布的降级说明。</target>
        </trans-unit>
        <trans-unit id="eb051013f36a233ac41b404b8075c071558087a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade the release. The file has the following syntax:</source>
          <target state="translated">该 &lt;code&gt;relup&lt;/code&gt; 文件包含一个单一的Erlang项，它定义了用于升级版本的说明。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="d56076bd8991e00d489d3da464bc1ef66915e244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply_timer&lt;/code&gt; eventually times out.</source>
          <target state="translated">最后， &lt;code&gt;reply_timer&lt;/code&gt; 超时。</target>
        </trans-unit>
        <trans-unit id="3918ee266b06587588695e693fc72ac650418ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;permanent&lt;/code&gt; will be used.</source>
          <target state="translated">该 &lt;code&gt;restart&lt;/code&gt; 键是可选的。如果未给出，将使用默认值 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa12db49496616557ec440b620daa191bf27cdc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;restart&lt;/code&gt; 键是可选的。如果未指定，则默认为 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6a92effc8d3efc4277861eec34f0f1caed07816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction must always be the first instruction in a relup. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">该 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令必须始终在relup的第一条指令。如果relup由 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成，则会自动确保。</target>
        </trans-unit>
        <trans-unit id="11d3f640ffec2cfdf0c8a6e928ab7cecff319eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_erl&lt;/code&gt; program is specific to Unix systems. This program redirects the standard input and standard output streams so that all output can be logged. It also lets the program &lt;code&gt;to_erl&lt;/code&gt; connect to the Erlang console, making it possible to monitor and debug an embedded system remotely.</source>
          <target state="translated">该 &lt;code&gt;run_erl&lt;/code&gt; 方案是专门针对Unix系统。该程序重定向标准输入和标准输出流，以便可以记录所有输出。它还使程序 &lt;code&gt;to_erl&lt;/code&gt; 连接到Erlang控制台，从而可以远程监视和调试嵌入式系统。</target>
        </trans-unit>
        <trans-unit id="750c30ae5ba824b2f2aab4a171c99b419364a053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime_dependencies&lt;/code&gt; key was introduced in OTP 17.0. The type of its value might be subject to changes during the OTP 17 release.</source>
          <target state="translated">该 &lt;code&gt;runtime_dependencies&lt;/code&gt; 关键是在OTP 17.0介绍。在OTP 17发行期间，其值的类型可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="c0fc6c1e3ca6659e674892c5855367c57b82e3b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt; Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;sasl&lt;/code&gt; 应用程序包括例如二郎模块 &lt;code&gt;target_system.erl&lt;/code&gt; ，其中包含用于创建和安装目标系统的功能。在以下示例中使用此模块。该模块的源代码在 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt; Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 列出。</target>
        </trans-unit>
        <trans-unit id="49d8491d2a1375817a9cf2b814c2646acf960284" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;sasl&lt;/code&gt; 应用程序包括例如二郎模块 &lt;code&gt;target_system.erl&lt;/code&gt; ，其中包含用于创建和安装目标系统的功能。在以下示例中使用此模块。该模块的源代码在 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 列出。</target>
        </trans-unit>
        <trans-unit id="3906ed9fb14f8072e02da2d35e2b47f21b0a6292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; expression matches all entries in table employee with the field &lt;code&gt;sex&lt;/code&gt; set to &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;select&lt;/code&gt; 表达式匹配与田间表员工所有条目 &lt;code&gt;sex&lt;/code&gt; 设定为 &lt;code&gt;female&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d221358022dcaa2231dd0fa112459ee9f7e4a5b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_ref()&lt;/code&gt; is the same as was received in the &lt;code&gt;&lt;a href=&quot;socket#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;select_ref()&lt;/code&gt; 是相同的在被接收 &lt;code&gt;&lt;a href=&quot;socket#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5c2c9e1f5cbdb80c6a7e6b52821b6b12fa676f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; flags enable tracing of all messages sent and received by the process/port. Trace patterns set with &lt;code&gt;tpe&lt;/code&gt; may limit traced messages based on the message content, the sender, and/or the receiver.</source>
          <target state="translated">的 &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 标志使所有消息的跟踪发送并且由处理/端口接收。使用 &lt;code&gt;tpe&lt;/code&gt; 设置的跟踪模式可能会根据消息内容，发送者和/或接收者来限制跟踪的消息。</target>
        </trans-unit>
        <trans-unit id="0233a943ab6f52106ec90bb0ab714ed2cd9deb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; call does not accept a time-out option because time-outs on send is handled through socket option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with no receiver is mainly defined by the underlying TCP stack and the network infrastructure. To write code that handles a hanging receiver that can eventually cause the sender to hang on a &lt;code&gt;send&lt;/code&gt; do like the following.</source>
          <target state="translated">在 &lt;code&gt;send&lt;/code&gt; 因为发送超时通过套接字选项处理的呼叫不接受超时选项 &lt;code&gt;send_timeout&lt;/code&gt; 。没有接收者的发送操作的行为主要由基础TCP堆栈和网络基础结构定义。要编写处理挂起的接收方的代码，最终可能导致发送方挂起 &lt;code&gt;send&lt;/code&gt; 请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="bdcf831f5f9a895f78c5ead8d39eb67c53d11a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_notification/6&lt;/code&gt; function is the most general version of the function. A &lt;code&gt;ContextName&lt;/code&gt; must be specified, from which the notification will be sent. If this parameter is not specified, the default context (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">该 &lt;code&gt;send_notification/6&lt;/code&gt; 功能是函数的最普遍的版本。必须指定一个 &lt;code&gt;ContextName&lt;/code&gt; ，从中将发送通知。如果未指定此参数，则使用默认上下文（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e10004941e2f7c2be1fb735798912ba806d773f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_out_queue&lt;/code&gt; routine is as follows:</source>
          <target state="translated">该 &lt;code&gt;send_out_queue&lt;/code&gt; 程序如下：</target>
        </trans-unit>
        <trans-unit id="843b939f65952e899d6ea657ca1ebe102c72dbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; module corresponds, greatly simplified, to the Erlang/OTP behaviour &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;server&lt;/code&gt; 模块对应，极大地简化，所述的Erlang / OTP行为 &lt;code&gt;gen_server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eede287bf30328bbe010a8372b63b7607963a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; commands modifies or adds an Erlang service, respectively. The simplest form of an &lt;code&gt;add&lt;/code&gt; command is without any options in which case all default values (described above) apply. The service name is mandatory.</source>
          <target state="translated">的 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;add&lt;/code&gt; 分别命令修改或添加一个Erlang服务。 &lt;code&gt;add&lt;/code&gt; 命令的最简单形式是不带任何选项，在这种情况下，所有默认值（如上所述）都适用。服务名称是必填项。</target>
        </trans-unit>
        <trans-unit id="7d5aec8c53556f4c4632141415f220fd68b8daa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function checks if it has enough information to make the row change its status from &lt;code&gt;notReady&lt;/code&gt; to &lt;code&gt;notInService&lt;/code&gt; (when a row has been been set to &lt;code&gt;createAndWait&lt;/code&gt;). If a row is set to &lt;code&gt;createAndWait&lt;/code&gt;, columns without a value are set to &lt;code&gt;noinit&lt;/code&gt;. If Mnesia is used, the set functionality is handled within a transaction.</source>
          <target state="translated">该 &lt;code&gt;set&lt;/code&gt; 功能检查是否有足够的信息，使该行改变其状态 &lt;code&gt;notReady&lt;/code&gt; ，以 &lt;code&gt;notInService&lt;/code&gt; （当行已被设置为 &lt;code&gt;createAndWait&lt;/code&gt; ）。如果将一行设置为 &lt;code&gt;createAndWait&lt;/code&gt; ，则将没有值的列设置为 &lt;code&gt;noinit&lt;/code&gt; 。如果使用Mnesia，则在交易中处理设置的功能。</target>
        </trans-unit>
        <trans-unit id="dffce6a86883fb98a441ee618f3e33a10bd8dd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_on_spawn&lt;/code&gt; option will active call time tracing for all processes spawned by processes in the rootset. This is the default behaviour.</source>
          <target state="translated">该 &lt;code&gt;set_on_spawn&lt;/code&gt; 选项将通过在rootset过程中产生的所有进程当前通话时间跟踪。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="d7ea8237fdbb6c1e6e9cad779100829368078340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not given, and the child is of type &lt;code&gt;worker&lt;/code&gt;, the default value &lt;code&gt;5000&lt;/code&gt; will be used; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;, the default value &lt;code&gt;infinity&lt;/code&gt; will be used.</source>
          <target state="translated">在 &lt;code&gt;shutdown&lt;/code&gt; 键是可选的。如果未给出，并且子 &lt;code&gt;worker&lt;/code&gt; 类型，则将使用默认值 &lt;code&gt;5000&lt;/code&gt; ；否则，将使用默认值。如果子项是 &lt;code&gt;supervisor&lt;/code&gt; 类型，则将使用默认值 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb49de51c4b23fb4081f3a3f48b32fd97395704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;5000&lt;/code&gt; if the child is of type &lt;code&gt;worker&lt;/code&gt; and it defaults to &lt;code&gt;infinity&lt;/code&gt; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;shutdown&lt;/code&gt; 键是可选的。如果未指定，则在子类型为 &lt;code&gt;worker&lt;/code&gt; 的情况下默认为 &lt;code&gt;5000&lt;/code&gt; ，在子类型为 &lt;code&gt;supervisor&lt;/code&gt; 的情况下默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38a6562eb72c50374e4148dda56f4f2798a51836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silent&lt;/code&gt; trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function &lt;code&gt;{silent,Bool}&lt;/code&gt;, giving a high degree of control of which functions with which arguments that trigger the trace.</source>
          <target state="translated">在 &lt;code&gt;silent&lt;/code&gt; 跟踪标志有利于建立许多甚至在系统中的所有进程痕迹。然后可以使用匹配规范函数 &lt;code&gt;{silent,Bool}&lt;/code&gt; 激活和停用跟踪，从而高度控制哪些函数使用哪些参数来触发跟踪。</target>
        </trans-unit>
        <trans-unit id="57bdb45fe915c31143be502180221ee741783591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field changed from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">在 &lt;code&gt;size&lt;/code&gt; 从变化领域签署无符号。如果仅在各处更改类型，则可能会导致例如循环终止条件或错误条件的问题。</target>
        </trans-unit>
        <trans-unit id="240a989a5bf707c990bcb78e115aed91f3f04714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field in &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; has been changed to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from &lt;code&gt;int&lt;/code&gt;. Check all code that use that field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;size&lt;/code&gt; 字段已从 &lt;code&gt;int&lt;/code&gt; 更改为 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 。检查使用该字段的所有代码。</target>
        </trans-unit>
        <trans-unit id="a337f162f4c8e035168099f55089fef2894d81f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; directory could be useful to release for debugging purposes but is not required. The &lt;code&gt;include&lt;/code&gt; directory should only be released if the applications has public include files.</source>
          <target state="translated">在 &lt;code&gt;src&lt;/code&gt; 目录可能会释放用于调试的目的，但不是必需的有用。在 &lt;code&gt;include&lt;/code&gt; 如果应用程序具有公共包含文件的目录应该只被释放。</target>
        </trans-unit>
        <trans-unit id="fc13993adad718eae8701221afde4693b532449e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; application is an implementation of the SSH Transport, Connection and Authentication Layer Protocols in Erlang. It provides the following:</source>
          <target state="translated">在 &lt;code&gt;ssh&lt;/code&gt; 应用程序是SSH运输，在二郎山连接和认证层协议的实现。它提供以下内容：</target>
        </trans-unit>
        <trans-unit id="1b351d65a63d0aa90f08b7937079a25c6920290a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssl_passive&lt;/code&gt; message is sent only when the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode and the counter dropped to 0. It indicates that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode.</source>
          <target state="translated">所述 &lt;code&gt;ssl_passive&lt;/code&gt; 只有当插座是在被发送消息 &lt;code&gt;{active, N}&lt;/code&gt; 模式和计数器下降到0。它表示插座已经转换到无源（ &lt;code&gt;{active, false}&lt;/code&gt; ）模式。</target>
        </trans-unit>
        <trans-unit id="8f65d2a2ea4f4fd44a5c098586ac285ac95cdefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; commands communicates with the service manager for starting and stopping a service. The commands wait until the service is started or stopped. When disabling a service, it is not stopped, the disabled state does not take effect until the service is stopped. Enabling a service sets it in automatic mode, which is started at boot. This command cannot set the service to manual.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 的服务管理器的命令通信来启动和停止服务。命令等待，直到服务启动或停止。禁用服务时，它不会停止，禁用状态直到服务停止后才生效。启用服务会将其设置为自动模式，该模式在启动时启动。此命令无法将服务设置为手动。</target>
        </trans-unit>
        <trans-unit id="d1f3d732c30aec74a57c16dda04003bb1543c716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; entry is called when the driver is opened as a port with &lt;code&gt;open_port/2&lt;/code&gt;. Here we allocate memory for a user data structure. This user data is passed every time the emulator calls us. First we store the driver handle, as it is needed in later calls. We allocate memory for the connection handle that is used by LibPQ. We also set the port to return allocated driver binaries, by setting flag &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, calling &lt;code&gt;set_port_control_flags&lt;/code&gt;. (This is because we do not know if our data will fit in the result buffer of &lt;code&gt;control&lt;/code&gt;, which has a default size, 64 bytes, set up by the emulator.)</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 时，驾驶员被打开了端口条目被称为 &lt;code&gt;open_port/2&lt;/code&gt; 。在这里，我们为用户数据结构分配内存。每次模拟器调用我们时，都会传递此用户数据。首先，我们存储驱动程序句柄，这在以后的调用中是必需的。我们为LibPQ使用的连接句柄分配内存。我们还通过设置标志 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 并调用 &lt;code&gt;set_port_control_flags&lt;/code&gt; 来设置端口以返回分配的驱动程序二进制文件。（这是因为我们不知道数据是否适合 &lt;code&gt;control&lt;/code&gt; 的结果缓冲区，该缓冲区的默认大小为64字节，由模拟器设置。）</target>
        </trans-unit>
        <trans-unit id="f756fe51eb87c21305c2536fa74b5434575da4c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; key is mandatory.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 关键是强制性的。</target>
        </trans-unit>
        <trans-unit id="7a89df12694a55231dbe9df289731067f34bf0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; program is called when the machine is started.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 时，机器启动程序被调用。</target>
        </trans-unit>
        <trans-unit id="34d8bb2f8c095328e05b319382abf621840539e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is an example script on how to start up the Erlang system in embedded mode on Unix.</source>
          <target state="translated">该 &lt;code&gt;start&lt;/code&gt; 脚本是如何在Unix上嵌入模式下启动Erlang的系统的示例脚本。</target>
        </trans-unit>
        <trans-unit id="c9b5982012fe67cdfffd9b71b0eeb41c6d062f31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is to be edited accordingly.</source>
          <target state="translated">该 &lt;code&gt;start&lt;/code&gt; 脚本进行相应的修改。</target>
        </trans-unit>
        <trans-unit id="31e73008fe878f9797af9d091c4fba4b24889e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_disabled&lt;/code&gt; command operates on a service regardless of if it is enabled/disabled or started/stopped. It does this by first enabling it (regardless of if it is enabled or not), then starting it (if not already started), and then disabling it. The result is a disabled but started service, regardless of its earlier state. This is useful for starting services temporarily during a release upgrade. The difference between using &lt;code&gt;start_disabled&lt;/code&gt; and the sequence &lt;code&gt;enable&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;disable&lt;/code&gt; is that all other &lt;code&gt;erlsrv&lt;/code&gt; commands are locked out during the sequence of operations in &lt;code&gt;start_disable&lt;/code&gt;, making the operation atomic from an &lt;code&gt;erlsrv&lt;/code&gt; user's point of view.</source>
          <target state="translated">该 &lt;code&gt;start_disabled&lt;/code&gt; 不管是启用/禁用或启动的一个服务命令操作/停止。为此，它首先启用它（无论是否启用），然后启动它（如果尚未启动），然后禁用它。结果是禁用的但已启动的服务，而不管其之前的状态如何。这对于在版本升级期间临时启动服务很有用。使用 &lt;code&gt;start_disabled&lt;/code&gt; 和序列 &lt;code&gt;enable&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;disable&lt;/code&gt; 之间的区别是，在 &lt;code&gt;start_disable&lt;/code&gt; 中的操作序列期间，所有其他 &lt;code&gt;erlsrv&lt;/code&gt; 命令均被锁定，从而使操作从 &lt;code&gt;erlsrv&lt;/code&gt; 变为原子 用户的观点。</target>
        </trans-unit>
        <trans-unit id="fc0272cbbd8f9392623927de4cb2fc5730b48880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program in its original form recognizes the following options:</source>
          <target state="translated">原始形式的 &lt;code&gt;start_erl&lt;/code&gt; 程序可识别以下选项：</target>
        </trans-unit>
        <trans-unit id="a046e5227b7bb73b869f5bee562322400ca78ede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program is specific to Windows NT/2000/XP (and later versions of Windows). Although there are programs with the same name on other platforms, their functionality is different.</source>
          <target state="translated">该 &lt;code&gt;start_erl&lt;/code&gt; 程序是特定于Windows NT / 2000 / XP（以及更高版本的Windows）。尽管在其他平台上存在具有相同名称的程序，但是它们的功能不同。</target>
        </trans-unit>
        <trans-unit id="dbb5a322b443d443c9f79ed8f50a8ce9c3dd4066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; shell script is normally not to be altered by the user.</source>
          <target state="translated">该 &lt;code&gt;start_erl&lt;/code&gt; shell脚本通常不是由用户来改变。</target>
        </trans-unit>
        <trans-unit id="f114d80543f043efa956ef10b8b8d871f223052b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stop&lt;/code&gt; entry is called when the port is closed.</source>
          <target state="translated">该 &lt;code&gt;stop&lt;/code&gt; 当端口关闭入口被调用。</target>
        </trans-unit>
        <trans-unit id="d04747a932902a65b42336d22f13d3d5bc78329f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strategy&lt;/code&gt; key is optional in this map. If it is not given, it defaults to &lt;code&gt;one_for_one&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;strategy&lt;/code&gt; 关键是在这个地图可选。如果未给出，则默认为 &lt;code&gt;one_for_one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="677a0d7125364697331cecce3cb1b444380c3397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; reason is the error information from the server in case of an exit-signal. If that information is empty, the reason is the exit signal name.</source>
          <target state="translated">的 &lt;code&gt;string()&lt;/code&gt; 的原因是从服务器中出射信号的情况下的误差的信息。如果该信息为空，则原因是退出信号名称。</target>
        </trans-unit>
        <trans-unit id="ac46c7648d961485339da72bde9519efe243649a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string&lt;/code&gt; module works perfectly for Unicode strings and ISO Latin-1 strings, except the language-dependent functions &lt;code&gt;string:uppercase/1&lt;/code&gt; and &lt;code&gt;string:lowercase/1&lt;/code&gt;. These two functions can never function correctly for Unicode characters in their current form, as there are language and locale issues to consider when converting text between cases. Converting case in an international environment is a large subject not yet addressed in OTP.</source>
          <target state="translated">该 &lt;code&gt;string&lt;/code&gt; 模块完全适用于Unicode字符串和ISO Latin-1的字符串，除了依赖于语言的函数 &lt;code&gt;string:uppercase/1&lt;/code&gt; 和 &lt;code&gt;string:lowercase/1&lt;/code&gt; 。这两种功能永远无法正确使用当前格式的Unicode字符，因为在大小写之间转换文本时要考虑语言和语言环境问题。在国际环境中进行案件转换是OTP中尚未解决的一个大问题。</target>
        </trans-unit>
        <trans-unit id="bbf0fa4cdfc9cb3b3a98e97fea86cc7766872258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subsystem_name&lt;/code&gt; is the name that a client requests to start with for example &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;subsystem_name&lt;/code&gt; 是名，一个客户端请求开始，例如 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09767c0926afa55480ccd26075dea864841952af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suspend&lt;/code&gt; pseudo function has got an OWN time of zero. This is to prevent the process total OWN time from including time in suspension. Whether suspend time is really ACC or OWN time is more of a philosophical question.</source>
          <target state="translated">在 &lt;code&gt;suspend&lt;/code&gt; 伪功能已经得到了零的自己的时间。这是为了防止进程总OWN时间包括暂停时间。暂停时间是真正的ACC时间还是OWN时间更是一个哲学问题。</target>
        </trans-unit>
        <trans-unit id="56fd6933946b063ca50f26b9fde4abf8abbc8167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. It also has functions that, together with functions in the &lt;code&gt;proc_lib&lt;/code&gt; module, can be used to implement a &lt;strong&gt;special process&lt;/strong&gt; that complies to the OTP design principles without using a standard behaviour. These functions can also be used to implement user-defined (non-standard) behaviours.</source>
          <target state="translated">该 &lt;code&gt;sys&lt;/code&gt; 模块具有的使用行为实施的过程简单的调试。它还具有与 &lt;code&gt;proc_lib&lt;/code&gt; 模块中的函数一起使用的函数，可用于实现符合OTP设计原则的&lt;strong&gt;特殊过程&lt;/strong&gt;，而无需使用标准行为。这些功能还可用于实现用户定义的（非标准）行为。</target>
        </trans-unit>
        <trans-unit id="a5f881a797bfc4fbe38f558b9ae2256b6de4f52c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. The &lt;code&gt;code_lock&lt;/code&gt; example from &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; is used to illustrate this:</source>
          <target state="translated">该 &lt;code&gt;sys&lt;/code&gt; 模块具有的使用行为实施的过程简单的调试。 &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;code_lock&lt;/code&gt; 示例用于说明这一点：</target>
        </trans-unit>
        <trans-unit id="d8d80e46d29a3b09620c79d01dfafc6546d08b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; value is not complete. Some allocated memory that is to be part of this value is not.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 价值是不完整的。某些分配的内存不是该值的一部分。</target>
        </trans-unit>
        <trans-unit id="26e392c3cf2f0ef617cba237c6220075b3ea4b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system_dir&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;system_dir&lt;/code&gt; 选项必须是包含一个主机密钥文件的目录，并将其默认 &lt;code&gt;/etc/ssh&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 中的配置文件部分。</target>
        </trans-unit>
        <trans-unit id="8dc4b52b4a1a8766ffe6fbf819d4319fd568e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; function takes a &lt;code&gt;.rel&lt;/code&gt; file as input and creates a zipped tar file with the code for the specified applications, a &lt;strong&gt;release package&lt;/strong&gt;:</source>
          <target state="translated">的 &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; 函数需要一个 &lt;code&gt;.rel&lt;/code&gt; 文件作为输入，并创建与所指定的应用程序，一个代码中的压缩的tar文件&lt;strong&gt;发布包&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="301c4b01094f4be3c122bd03d67de7a461179ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_info/2&lt;/code&gt; function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</source>
          <target state="translated">该 &lt;code&gt;table_info/2&lt;/code&gt; 函数有两个参数。第一个是Mnesia表的名称。第二个是以下键之一：</target>
        </trans-unit>
        <trans-unit id="cc6490531af30f5ced0c442f4ca5f18223c8f2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag_receiver()&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">所述 &lt;code&gt;tag_receiver()&lt;/code&gt; 将首先发送的 &lt;code&gt;snmp_targets&lt;/code&gt; 消息，然后在每个地址 &lt;code&gt;Addresses&lt;/code&gt; 列表中，这两个中的一个 &lt;code&gt;snmp_notification&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="05b2bd26a182333de1bd8075c792a7cf0885382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term&lt;/code&gt; structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</source>
          <target state="translated">该 &lt;code&gt;term&lt;/code&gt; 结构包含用于为二进制，字符串或原子的元组或列表，大小的元数。它包含以下各项之一：整数，浮点数，原子，pid，端口或引用。</target>
        </trans-unit>
        <trans-unit id="414ded4046829ee348e2029f26b1f968edf7170d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminating&lt;/code&gt; options effects discovery initiated by a manager.</source>
          <target state="translated">该 &lt;code&gt;terminating&lt;/code&gt; 由经理启动选项的效果发现。</target>
        </trans-unit>
        <trans-unit id="7e88c128d4034b8d31e143d58083f1b627d669f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; functions use the &lt;code&gt;*.asn1db&lt;/code&gt; files for all included modules. If they are located in a different directory than the current working directory, use the &lt;code&gt;include&lt;/code&gt; option to add paths. This is only needed when automatically generating values. For static values using &lt;code&gt;Value&lt;/code&gt; no options are needed.</source>
          <target state="translated">该 &lt;code&gt;test&lt;/code&gt; 功能使用 &lt;code&gt;*.asn1db&lt;/code&gt; 文件所包含的全部模块。如果它们位于与当前工作目录不同的目录中，请使用 &lt;code&gt;include&lt;/code&gt; 选项添加路径。仅在自动生成值时才需要。对于使用&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 静态值，不需要任何选项。</target>
        </trans-unit>
        <trans-unit id="83b7e0837f597d64ddcc824925c5e1f6e2d7ce99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tftp&lt;/code&gt; application implements the following IETF standards:</source>
          <target state="translated">在 &lt;code&gt;tftp&lt;/code&gt; 应用程序实现以下IETF标准：</target>
        </trans-unit>
        <trans-unit id="6783b7d09b3f65f7bff4fe67aceb9dac10494244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;time_unit/0&lt;/code&gt; 类型可以延长。要在时间单位之间转换时间值，请使用 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bd16215e29bac88188ec05db9e000d6b25c2a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;time_unit/0&lt;/code&gt; 类型可以延长。要在时间单位之间转换时间值，请使用 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d6b5da79accb971f070469104b62f5de13468c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; option in the &lt;code&gt;SearchOptions&lt;/code&gt; is for the ldap server, while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for each individual request in the search operation.</source>
          <target state="translated">&lt;code&gt;SearchOptions&lt;/code&gt; 中的 &lt;code&gt;timeout&lt;/code&gt; 选项用于ldap服务器，而 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 中的超时用于搜索操作中的每个单独请求。</target>
        </trans-unit>
        <trans-unit id="3469f460bad51d15abfb716bef8439dd19f5713d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the &lt;code&gt;total&lt;/code&gt; value is &lt;strong&gt;not&lt;/strong&gt; supposed to be equal to the total size of all pages mapped to the emulator.</source>
          <target state="translated">该 &lt;code&gt;total&lt;/code&gt; 应该是仿真器动态分配的内存总量。不应包含共享库，仿真器本身的代码以及仿真器堆栈。也就是说， &lt;code&gt;total&lt;/code&gt; 价值&lt;strong&gt;不&lt;/strong&gt;应该等于映射到仿真器的所有页面的总大小。</target>
        </trans-unit>
        <trans-unit id="855a90cd384864cf599ca9011960a53bac88f853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trim&lt;/code&gt; behavior corresponds exactly to the Perl default. &lt;code&gt;{parts,N}&lt;/code&gt;, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of &lt;code&gt;split/3&lt;/code&gt; corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</source>
          <target state="translated">该 &lt;code&gt;trim&lt;/code&gt; 行为完全对应于Perl中的默认值。 &lt;code&gt;{parts,N}&lt;/code&gt; （其中N是一个正整数）与具有正数字第三参数的Perl行为完全对应。当将负整数指定为Perl例程的第三个参数时， &lt;code&gt;split/3&lt;/code&gt; 的默认行为与Perl行为相对应。</target>
        </trans-unit>
        <trans-unit id="503ae720e5d8f3760c374c5a7724a46be581ffb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can also be augmented with an &lt;code&gt;after&lt;/code&gt; section, intended to be used for cleanup with side effects:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 表达也可以与增强 &lt;code&gt;after&lt;/code&gt; 部分，意在被用于与副作用清理：</target>
        </trans-unit>
        <trans-unit id="9aa8fddb846b9b7abd8af53c04dc022f8bbdb56d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can have an &lt;code&gt;of&lt;/code&gt; section:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 的表达可以有一个 &lt;code&gt;of&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="1247ef97bc2a099c330eff988713e9a5888387df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tuple()&lt;/code&gt; reason are other errors like for example &lt;code&gt;{exit_status,1}&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;tuple()&lt;/code&gt; 的原因是其他错误像例如 &lt;code&gt;{exit_status,1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="874e9960e26401a3b617a3b1e2c19da394373ec5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;worker&lt;/code&gt; will be used.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 关键是可选的。如果未提供，将使用默认值 &lt;code&gt;worker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce30d2f89579b051b36741023e812a759179d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;worker&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 关键是可选的。如果未指定，则默认为 &lt;code&gt;worker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ab52ef65eee07504a8c99112afca9e52efb72ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$bif:Module:Name/Arity&lt;/code&gt; constraint tests whether the given operand refers to a specific BIF. Note that &lt;code&gt;Module:Name/Arity&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be an existing BIF defined in &lt;code&gt;bif.tab&lt;/code&gt;, or there will be a compilation error. It is useful when a call to a specific BIF should be replaced with an instruction as in this example:</source>
          <target state="translated">该 &lt;code&gt;u$bif:Module:Name/Arity&lt;/code&gt; 约束测试是否给定的操作数是指一个特定的BIF。需要注意的是 &lt;code&gt;Module:Name/Arity&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt;是现有的BIF定义 &lt;code&gt;bif.tab&lt;/code&gt; ，否则会有编译错误。如以下示例所示，当将对特定BIF的调用替换为指令时，这很有用：</target>
        </trans-unit>
        <trans-unit id="d8f2c733d5f2c3ff7dc2fecb9f7616099b07cea0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$func:Module:Name/Arity&lt;/code&gt; will test whether the given operand is a a specific function. Here is an example:</source>
          <target state="translated">该 &lt;code&gt;u$func:Module:Name/Arity&lt;/code&gt; 将测试给定的操作数是否是AA特定的功能。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="58e0ceadd09742f3e89a0e0c489abdb4b9f52d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u$is_not_bif&lt;/code&gt; constraint matches if the operand does not refer to a BIF (not listed in &lt;code&gt;bif.tab&lt;/code&gt;). For example:</source>
          <target state="translated">如果操作数未引用BIF（未在 &lt;code&gt;bif.tab&lt;/code&gt; 中列出），则 &lt;code&gt;u$is_not_bif&lt;/code&gt; 约束匹配。例如：</target>
        </trans-unit>
        <trans-unit id="c8f1c69ed96b83a679b6a1461cadd4cb592d2117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_command&lt;/code&gt; routine is the routine called when an Erlang process sends data to the port. This routine handles all asynchronous commands when the port is in &lt;code&gt;command&lt;/code&gt; mode and the sending of all data when the port is in &lt;code&gt;data&lt;/code&gt; mode:</source>
          <target state="translated">所述 &lt;code&gt;uds_command&lt;/code&gt; 例程是当一个Erlang过程将数据发送到的端口称为例程。当端口处于 &lt;code&gt;command&lt;/code&gt; 模式时，此例程处理所有异步命令；当端口处于 &lt;code&gt;data&lt;/code&gt; 模式时，此例程将发送所有数据：</target>
        </trans-unit>
        <trans-unit id="12d38078aadeb17f73f6143b46507ced220c8b0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine handles other input events (like non-blocking &lt;code&gt;accept&lt;/code&gt;), but most importantly handle data arriving at the socket by calling &lt;code&gt;do_recv&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;uds_input&lt;/code&gt; 程序处理其他输入事件（如无阻塞 &lt;code&gt;accept&lt;/code&gt; ），但通过调用最重要的处理到达套接字数据 &lt;code&gt;do_recv&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="202a772c2bbbb0c73373b15e1d87ffd28aa29133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine is called when data is available on a file descriptor previously passed to the &lt;code&gt;driver_select&lt;/code&gt; routine. This occurs typically when a read command is issued and no data is available. The &lt;code&gt;do_recv&lt;/code&gt; routine is as follows:</source>
          <target state="translated">该 &lt;code&gt;uds_input&lt;/code&gt; 数据可用时先前传递给一个文件描述符程序被称为 &lt;code&gt;driver_select&lt;/code&gt; 程序。通常在发出读取命令并且没有可用数据时发生。该 &lt;code&gt;do_recv&lt;/code&gt; 程序如下：</target>
        </trans-unit>
        <trans-unit id="afe5ea4f80f83ad57ad0aad31e10486a4f2bf930" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_start&lt;/code&gt; routine is called when a port is opened from Erlang. In this case, we only allocate a structure and initialize it. Creating the actual socket is left to the &lt;code&gt;uds_command&lt;/code&gt; routine.</source>
          <target state="translated">该 &lt;code&gt;uds_start&lt;/code&gt; 当口，从二郎打开程序被调用。在这种情况下，我们仅分配一个结构并对其进行初始化。创建实际的套接字由 &lt;code&gt;uds_command&lt;/code&gt; 例程完成。</target>
        </trans-unit>
        <trans-unit id="8bfbb24810f0c5b15e0b6448d90f972fe31a6386" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undo&lt;/code&gt; function does nothing.</source>
          <target state="translated">该 &lt;code&gt;undo&lt;/code&gt; 函数什么都不做。</target>
        </trans-unit>
        <trans-unit id="7969bdd4f7e8e8283016abfb83b747e28e6525e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unicode&lt;/code&gt; module is clearly Unicode-aware. It contains functions for conversion between different Unicode formats and some utilities for identifying byte order marks. Few programs handling Unicode data survive without this module.</source>
          <target state="translated">在 &lt;code&gt;unicode&lt;/code&gt; 模块显然是支持Unicode的。它包含用于在不同Unicode格式之间进行转换的功能，以及一些用于标识字节顺序标记的实用程序。没有这个模块，很少有处理Unicode数据的程序可以生存。</target>
        </trans-unit>
        <trans-unit id="45fc4ab31edeed78de6dcc133ce43fa458252958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; function is an alternative for updating module data of recompiled modules.</source>
          <target state="translated">的 &lt;code&gt;update&lt;/code&gt; 功能是用于更新重新编译模块的模块数据的替代方案。</target>
        </trans-unit>
        <trans-unit id="e7a993cc2041a3a5e4126cbf7ea824172decdb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; instruction must contain the tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;. The instruction makes the special process call the callback function &lt;code&gt;system_code_change/4&lt;/code&gt;, a function the user must implement. The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to &lt;code&gt;system_code_change/4&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;update&lt;/code&gt; 指令必须包含元组 &lt;code&gt;{advanced,Extra}&lt;/code&gt; 。该指令使特殊过程调用回调函数 &lt;code&gt;system_code_change/4&lt;/code&gt; ，这是用户必须实现的功能。术语 &lt;code&gt;Extra&lt;/code&gt; （在这种情况下为 &lt;code&gt;[]&lt;/code&gt; ）按原样传递给 &lt;code&gt;system_code_change/4&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55a52d1bdeacd91af756556ef9395d795b7ce705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user_args&lt;/code&gt; configuration parameter which may be used to extend the argument list of the callback functions. For example, the handle_connect function takes by default two arguments:</source>
          <target state="translated">所述 &lt;code&gt;user_args&lt;/code&gt; 配置参数，其可以被用于扩展的回调函数的参数列表。例如，handle_connect函数默认采用两个参数：</target>
        </trans-unit>
        <trans-unit id="c15ed8631e7be541ad2f112cab6d63b078785dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmAccessTable&lt;/code&gt; maps the &lt;code&gt;groupName&lt;/code&gt; (found in &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;), &lt;code&gt;contextName&lt;/code&gt;, &lt;code&gt;securityModel&lt;/code&gt;, and &lt;code&gt;securityLevel&lt;/code&gt; to an MIB view for each type of operation (read, write, or notify). The MIB view is represented as a &lt;code&gt;viewName&lt;/code&gt;. The definition of the MIB view represented by the &lt;code&gt;viewName&lt;/code&gt; is found in the &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;vacmAccessTable&lt;/code&gt; 的映射 &lt;code&gt;groupName&lt;/code&gt; （在发现 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ）， &lt;code&gt;contextName&lt;/code&gt; ， &lt;code&gt;securityModel&lt;/code&gt; 和 &lt;code&gt;securityLevel&lt;/code&gt; 进行为每个类型的操作（读，写，或通知）的MIB图。MIB视图表示为 &lt;code&gt;viewName&lt;/code&gt; 。在 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 中找到由 &lt;code&gt;viewName&lt;/code&gt; 表示的MIB视图的定义</target>
        </trans-unit>
        <trans-unit id="a70d16c49aee0ecab7697bd61b2b47a75fed9fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmContextTable&lt;/code&gt; is a read-only table that lists all available contexts.</source>
          <target state="translated">该 &lt;code&gt;vacmContextTable&lt;/code&gt; 是一个只读表，其中列出了可用的上下文。</target>
        </trans-unit>
        <trans-unit id="ef9aac3e2a8987ec6dd80992e0534a1b71403af1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; maps a &lt;code&gt;securityModel&lt;/code&gt; and a &lt;code&gt;securityName&lt;/code&gt; to a &lt;code&gt;groupName&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; 映射一个 &lt;code&gt;securityModel&lt;/code&gt; 和 &lt;code&gt;securityName&lt;/code&gt; 的 &lt;code&gt;groupName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28801f1623b234b9de96cc740a98bd5f85c06c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; is indexed by the &lt;code&gt;viewName&lt;/code&gt;, and defines which objects are included in the MIB view.</source>
          <target state="translated">该 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 由索引 &lt;code&gt;viewName&lt;/code&gt; ，并且该对象包括在MIB视图定义。</target>
        </trans-unit>
        <trans-unit id="1870424a39adeddc9df6d1301607365bb578c850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vfs&lt;/code&gt; layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older versions did this by refusing to create non-UTF-8 conforming filenames, while newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the original character in hexadecimal notation. As Unicode translation is enabled by default on MacOS X, the only way to come up against this is to either start the VM with flag &lt;code&gt;+fnl&lt;/code&gt; or to use a raw filename in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. If using a raw filename, with a bytewise encoding containing characters from 127 through 255, to create a file, the file cannot be opened using the same name as the one used to create it. There is no remedy for this behavior, except keeping the filenames in the correct encoding.</source>
          <target state="translated">MacOS X 的 &lt;code&gt;vfs&lt;/code&gt; 层以积极的方式强制执行UTF-8文件名。较旧的版本通过拒绝创建不符合UTF-8的文件名来做到这一点，而较新的版本则用序列&amp;ldquo;％HH&amp;rdquo;替换有问题的字节，其中HH是十六进制表示法中的原始字符。由于MacOS X上默认启用了Unicode转换，因此唯一的解决方法是使用标志 &lt;code&gt;+fnl&lt;/code&gt; 启动VM 或使用按字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码的原始文件名。如果使用原始文件名（按字节编码包含从127到255的字符）来创建文件，则无法使用与用于创建文件的文件名相同的名称来打开文件。除了将文件名保留为正确的编码外，没有针对此行为的补救措施。</target>
        </trans-unit>
        <trans-unit id="831df5545d1b1c7760cea7009d162230198cc0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;werl&lt;/code&gt; window is in many ways modeled after the &lt;code&gt;xterm&lt;/code&gt; window present on other platforms, as the &lt;code&gt;xterm&lt;/code&gt; model fits well with line-oriented command-based interaction. This means that selecting text is line-oriented rather than rectangle-oriented.</source>
          <target state="translated">由于 &lt;code&gt;xterm&lt;/code&gt; 模型非常适合基于行的基于命令的交互，因此在很多方面都以其他平台上存在的 &lt;code&gt;xterm&lt;/code&gt; 窗口为模型来模拟 &lt;code&gt;werl&lt;/code&gt; 窗口。这意味着选择文本是面向行的，而不是面向矩形的。</target>
        </trans-unit>
        <trans-unit id="cb0a24e0ba3c71a8aad37252c9a038696dacac35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;whereis&lt;/code&gt; function-call verifies that the SSL application is started.</source>
          <target state="translated">该 &lt;code&gt;whereis&lt;/code&gt; 函数调用验证的SSL应用程序已启动。</target>
        </trans-unit>
        <trans-unit id="e2ea2763aab3c4567e48b6fa3d1366d90dff0b7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_concurrency&lt;/code&gt; option can be combined with the options &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt;. You typically want to combine &lt;code&gt;write_concurrency&lt;/code&gt; with &lt;code&gt;read_concurrency&lt;/code&gt; when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned on by default for tables of type &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;write_concurrency&lt;/code&gt; option enabled, and the &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned off by default for all other table types. For more information, see the documentation for the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">该 &lt;code&gt;write_concurrency&lt;/code&gt; 选项可以与选项组合 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 。当大型并发读取突发和大型并发写入突发很常见时，您通常希望将 &lt;code&gt;write_concurrency&lt;/code&gt; 与 &lt;code&gt;read_concurrency&lt;/code&gt; 结合使用。有关更多信息，请参见选项 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt; read_concurrency&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项类型的表默认开启 &lt;code&gt;ordered_set&lt;/code&gt; 与 &lt;code&gt;write_concurrency&lt;/code&gt; 选项启用，并且 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项默认是关闭了所有其它类型的表。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="a6d05af96ec0e7231d4e09ddd7a1fc622f5621cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; is defined by the user and is passed to the &lt;code&gt;match_fun&lt;/code&gt;, if defined. If the term in &lt;code&gt;OtherRefId&lt;/code&gt; is a binary, it will be converted to a string.</source>
          <target state="translated">的 &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; 由用户定义，并且被传递到 &lt;code&gt;match_fun&lt;/code&gt; ，如果定义的话。如果 &lt;code&gt;OtherRefId&lt;/code&gt; 中的术语是二进制的，则它将转换为字符串。</target>
        </trans-unit>
        <trans-unit id="19e1b6293cd5c62e374c8457e4fbd9d95a253158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; option must be included. This option is used to find the callback module &lt;code&gt;Module&lt;/code&gt; of the application. &lt;code&gt;StartArgs&lt;/code&gt; is ignored, as &lt;code&gt;Module:start/2&lt;/code&gt; is called only for the primary application.</source>
          <target state="translated">的 &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; 选项必须被包括在内。此选项用于查找应用程序的回调模块 &lt;code&gt;Module&lt;/code&gt; 。 &lt;code&gt;StartArgs&lt;/code&gt; 被忽略，因为 &lt;code&gt;Module:start/2&lt;/code&gt; 仅针对主应用程序被调用。</target>
        </trans-unit>
        <trans-unit id="4668f1fd645c2ffa2dba60de3db8016985e65bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ok,tut}&lt;/code&gt; means that the compilation is OK. If it says &quot;error&quot; it means that there is some mistake in the text that you entered. Additional error messages gives an idea to what is wrong so you can modify the text and then try to compile the program again.</source>
          <target state="translated">该 &lt;code&gt;{ok,tut}&lt;/code&gt; 意味着编译正常。如果显示&amp;ldquo;错误&amp;rdquo;，则表示您输入的文本中存在错误。其他错误消息会提示您错误所在，因此您可以修改文本，然后尝试再次编译程序。</target>
        </trans-unit>
        <trans-unit id="37c82dec6529acb72fb125b0bac4fda347c61081" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{packet, N}&lt;/code&gt; and &lt;code&gt;{line, L}&lt;/code&gt; settings are mutually exclusive.</source>
          <target state="translated">的 &lt;code&gt;{packet, N}&lt;/code&gt; 和 &lt;code&gt;{line, L}&lt;/code&gt; 的设置是互相排斥的。</target>
        </trans-unit>
        <trans-unit id="971d55e17028d3606b6c283922622f2c0932a483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{port,PortNum}&lt;/code&gt; tuple is optional and if omitted, default Telnet port 23 is used. Also the &lt;code&gt;keep_alive&lt;/code&gt; tuple is optional, and the value defauls to &lt;code&gt;true&lt;/code&gt; (enabled).</source>
          <target state="translated">的 &lt;code&gt;{port,PortNum}&lt;/code&gt; 元组是可选的，并且如果省略，默认Telnet端口23被使用。另外， &lt;code&gt;keep_alive&lt;/code&gt; 元组是可选的，并且值默认为 &lt;code&gt;true&lt;/code&gt; （启用）。</target>
        </trans-unit>
        <trans-unit id="fa6ece2cc8b2e8dafa07d4e08292eb70bec23c2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</source>
          <target state="translated">的 &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; 选项必须包括在内，和该组特定阶段必须设定的用于主应用程序指定的相位的一个子集。</target>
        </trans-unit>
        <trans-unit id="ff25bb9b46c77ee1bd1587510f1046fea71955a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; &quot;such that&quot; and the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; is read as &quot;taken from&quot;.</source>
          <target state="translated">该 &lt;code&gt;||&lt;/code&gt; &amp;ldquo;诸如此类&amp;rdquo;和箭头 &lt;code&gt;&amp;lt;-&lt;/code&gt; 表示为&amp;ldquo;取自&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8950a73316b6b3766c9706406f02f3f2dda35162" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;Cartesian_product&quot;&gt;Cartesian product&lt;/strong&gt; of two sets X and Y, denoted X &amp;times; Y, is the set {a : a = (x, y) for some x in X and for some y in Y}.</source>
          <target state="translated">两个集合X和Y 的&lt;strong id=&quot;Cartesian_product&quot;&gt;笛卡尔积&lt;/strong&gt;，表示为X&amp;times;Y，是集合{a：a =（x，y），其中X中的一些x和Y中的一些y}。</target>
        </trans-unit>
        <trans-unit id="97f5043ae782de1e349c1f4e82a07bd359c0964c" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;converse&quot;&gt;converse&lt;/strong&gt; of R is the set {a : a = (y, x) for some (x, y) in R}.</source>
          <target state="translated">R 的&lt;strong id=&quot;converse&quot;&gt;逆&lt;/strong&gt;是集合{a：R中某些（x，y）的a = a（y，x）}。</target>
        </trans-unit>
        <trans-unit id="c74f91b2df651d6f1d918e8b3fa79c423cad5e1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;difference&quot;&gt;difference&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that do not belong to B.</source>
          <target state="translated">两个集合A和B 的&lt;strong id=&quot;difference&quot;&gt;区别&lt;/strong&gt;在于，该集合包含A的所有不属于B的元素。</target>
        </trans-unit>
        <trans-unit id="efd11e10dc9bffd3ce00966684d96fd8a122cb0d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;domain&quot;&gt;domain&lt;/strong&gt; of R is the set {x : x R y for some y in Y}.</source>
          <target state="translated">R 的&lt;strong id=&quot;domain&quot;&gt;域&lt;/strong&gt;是集合{x：x R y对于Y中的某些y}。</target>
        </trans-unit>
        <trans-unit id="377184fb47eff2618a884d3371438181861419a0" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;field&quot;&gt;field&lt;/strong&gt; of a relation R in X is the union of the domain of R and the range of R.</source>
          <target state="translated">X中的关系R 的&lt;strong id=&quot;field&quot;&gt;字段&lt;/strong&gt;是R的域和R的范围的并集。</target>
        </trans-unit>
        <trans-unit id="1a9617de87db1af0121da59eba19d31a6b757eff" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;in_degree&quot;&gt;in-degree&lt;/strong&gt; of a vertex is the number of edges incident on that vertex.</source>
          <target state="translated">所述&lt;strong id=&quot;in_degree&quot;&gt;入度&lt;/strong&gt;顶点的是边缘入射在该顶点的数目。</target>
        </trans-unit>
        <trans-unit id="4c0e00f79ce45926299ee2f3508020fdf2f45df9" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection&quot;&gt;intersection&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that belong to B.</source>
          <target state="translated">两个集合A和B 的&lt;strong id=&quot;intersection&quot;&gt;交集&lt;/strong&gt;是包含所有属于B的A元素的集合。</target>
        </trans-unit>
        <trans-unit id="3f1d912f47b338c33084d89f0c15a5a316197ecb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection_n&quot;&gt;intersection&lt;/strong&gt; of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</source>
          <target state="translated">该&lt;strong id=&quot;intersection_n&quot;&gt;路口&lt;/strong&gt;的集合非空集是包含属于每一套集合中的所有元素的集合。</target>
        </trans-unit>
        <trans-unit id="429f2c89c9e807577354da0b8e15a8e248018d77" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;length&quot;&gt;length&lt;/strong&gt; of path P is k-1.</source>
          <target state="translated">路径P 的&lt;strong id=&quot;length&quot;&gt;长度&lt;/strong&gt;是k-1。</target>
        </trans-unit>
        <trans-unit id="abc21b67f672b304bee1db7701b820f9b24de3c6" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;natural_join&quot;&gt;natural join&lt;/strong&gt; of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</source>
          <target state="translated">坐标i和j上的n元关系R和m元关系S 的&lt;strong id=&quot;natural_join&quot;&gt;自然连接&lt;/strong&gt;定义为集合{z：z =（x [1]，...，x [n]，y [ 1]，...，y [j-1]，y [j + 1]，...，y [m]）对于R中的某些（x [1]，...，x [n]）和对于S中的某些（y [1]，...，y [m]），使得x [i] = y [j]}。</target>
        </trans-unit>
        <trans-unit id="adf6489e3c93a13ca7fd19239f3939863c02f11d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;out_degree&quot;&gt;out-degree&lt;/strong&gt; of a vertex is the number of edges emanating from that vertex.</source>
          <target state="translated">顶点的&lt;strong id=&quot;out_degree&quot;&gt;出度&lt;/strong&gt;是从该顶点发出的边的数量。</target>
        </trans-unit>
        <trans-unit id="7c6a3c4f02bedbb63c4000218f9eaa4b3029b656" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;projection&quot;&gt;projection&lt;/strong&gt; of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &amp;lt;= j &amp;lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively.</source>
          <target state="translated">n元关系R在坐标i上的&lt;strong id=&quot;projection&quot;&gt;投影&lt;/strong&gt;是R在某些x上的集合{x [i]：（x [1]，...，x [i]，...，x [n]） X [j]中的[j]，1 &amp;lt;= j &amp;lt;= n，而不是i = j}。二进制关系R在第一和第二坐标上的投影分别是R的域和范围。</target>
        </trans-unit>
        <trans-unit id="928618861a3a7864fa16dc6571d48344039643c2" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;range&quot;&gt;range&lt;/strong&gt; of R is the set {y : x R y for some x in X}.</source>
          <target state="translated">R 的&lt;strong id=&quot;range&quot;&gt;范围&lt;/strong&gt;是集合{y：X中x的x y}。</target>
        </trans-unit>
        <trans-unit id="a0513ff69692a7179c5c24f4ad25a5aa23d84d71" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;restriction&quot;&gt;restriction&lt;/strong&gt; of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y.</source>
          <target state="translated">R对A 的&lt;strong id=&quot;restriction&quot;&gt;限制&lt;/strong&gt;是定义的集合S，因此，当且仅当A中存在元素x使得x R y时，x S y。</target>
        </trans-unit>
        <trans-unit id="53dd8e97ddf5e81c0a22de5f228a88721f6ccc8d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;symmetric_difference&quot;&gt;symmetric difference&lt;/strong&gt; of two sets is the set that contains those element that belong to either of the two sets, but not both.</source>
          <target state="translated">两组的&lt;strong id=&quot;symmetric_difference&quot;&gt;对称差异&lt;/strong&gt;是包含属于两个组中的一个但不是两个的元素的组。</target>
        </trans-unit>
        <trans-unit id="baf0cfcddb027f4d4f3dff2390047419348137ab" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union&quot;&gt;union&lt;/strong&gt; of two sets A and B is the smallest set that contains all elements of A and all elements of B.</source>
          <target state="translated">该&lt;strong id=&quot;union&quot;&gt;工会&lt;/strong&gt;两套A和B是包含和A的所有元素B的所有元素的最小集合</target>
        </trans-unit>
        <trans-unit id="81d4f87a2b598bff542bef7879776b07f0f811bb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union_n&quot;&gt;union&lt;/strong&gt; of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection.</source>
          <target state="translated">该&lt;strong id=&quot;union_n&quot;&gt;联盟&lt;/strong&gt;的集合的集合是包含所有属于至少一组的集合中的元素的最小集。</target>
        </trans-unit>
        <trans-unit id="5d51e506fb7ebd09e0439b577c3665c859bbc0bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Auto Attach&lt;/strong&gt; boxes, &lt;strong&gt;Stack Trace&lt;/strong&gt; label, &lt;strong&gt;Back Trace Size&lt;/strong&gt; label, and &lt;strong&gt;Strings&lt;/strong&gt; box display some options set. For details about these options, see section &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;自动附加&amp;rdquo;&lt;/strong&gt;框，&amp;ldquo; &lt;strong&gt;堆栈跟踪&amp;rdquo;&lt;/strong&gt;标签，&amp;ldquo; &lt;strong&gt;后跟踪大小&amp;rdquo;&lt;/strong&gt;标签和&amp;ldquo; &lt;strong&gt;字符串&amp;rdquo;&lt;/strong&gt;框显示一些选项集。有关这些选项的详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="abcaf1a971590700133b8016539b636c71ba876f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Break&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">该&lt;strong&gt;休息&lt;/strong&gt;，&lt;strong&gt;视窗&lt;/strong&gt;和&lt;strong&gt;帮助&lt;/strong&gt;菜单是一样的，在 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; ，除了&lt;strong&gt;休息&lt;/strong&gt;菜单只适用于本地断点。</target>
        </trans-unit>
        <trans-unit id="a10eb03f19350fbdf85025a9eab01c5153042f77" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Breaks&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">该&lt;strong&gt;休息&lt;/strong&gt;，&lt;strong&gt;视窗&lt;/strong&gt;和&lt;strong&gt;帮助&lt;/strong&gt;菜单是一样的，在 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; ，除了&lt;strong&gt;休息&lt;/strong&gt;菜单只适用于本地断点。</target>
        </trans-unit>
        <trans-unit id="81208a589d29fcc1ae9246757bcbbd412aee1292" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; by callbacks before and after all test suite calls. It is intended for advanced users of &lt;code&gt;Common Test&lt;/code&gt; who want to abstract out behavior that is common to multiple test suites.</source>
          <target state="translated">在&lt;strong&gt;通用测试钩（星期三）&lt;/strong&gt;框架允许的默认行为扩展 &lt;code&gt;Common Test&lt;/code&gt; 通过回调之前，所有测试套件来电之后。它适用于希望抽象出多个测试套件共有行为的 &lt;code&gt;Common Test&lt;/code&gt; 高级用户。</target>
        </trans-unit>
        <trans-unit id="e6fc5c94241e7e52f12a5fd7bd3416eff9018efa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; using hooks before and after all test suite calls. CTHs allow advanced &lt;code&gt;Common Test&lt;/code&gt; users to abstract out behavior that is common to multiple test suites without littering all test suites with library calls. This can be used for logging, starting, and monitoring external systems, building C files needed by the tests, and so on.</source>
          <target state="translated">在&lt;strong&gt;通用测试钩（星期三）&lt;/strong&gt;框架允许的默认行为扩展 &lt;code&gt;Common Test&lt;/code&gt; 使用挂钩之前，所有测试套件来电之后。CTH允许高级的 &lt;code&gt;Common Test&lt;/code&gt; 用户抽象出多个测试套件所共有的行为，而不会在所有测试套件中堆满库调用。这可用于记录，启动和监视外部系统，构建测试所需的C文件，等等。</target>
        </trans-unit>
        <trans-unit id="03e6f71f473d365a318259d6ca0121e4f4c728af" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Property Testing Support (ct_property_test)&lt;/strong&gt; is an aid to run property based testing tools in Common Test test suites.</source>
          <target state="translated">在&lt;strong&gt;通用测试性能测试支持（ct_property_test）&lt;/strong&gt;是运行属性的辅助在基于共同的测试测试套件测试工具。</target>
        </trans-unit>
        <trans-unit id="18cdc049609d4e15a26ab891a990c31ae80de460" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; and &lt;strong&gt;Edit&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;和&amp;ldquo; &lt;strong&gt;编辑&amp;rdquo;&lt;/strong&gt;菜单与&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt; 中的菜单相同。</target>
        </trans-unit>
        <trans-unit id="ff4e15bb4c0b2061b264590ff96d04af89b93805" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; menu includes options to save the contents of the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window. Simply choose the options and enter the file to save the contents in.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;菜单包含用于保存&amp;ldquo; &lt;strong&gt;日志&amp;rdquo;&lt;/strong&gt;窗口和&amp;ldquo; &lt;strong&gt;警告&amp;rdquo;&lt;/strong&gt;窗口的内容的选项。只需选择选项，然后输入文件以保存内容即可。</target>
        </trans-unit>
        <trans-unit id="370a6214852f8fdbb6373c8997912c0758173f20" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; window displays a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;窗口显示当前目录的列表。单击您要添加的目录/模块的方式，或在条目中键入正确的路径。</target>
        </trans-unit>
        <trans-unit id="8e3940de2fcf0c6b61297d85ec453fc7187e592a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;OTP design principles&lt;/strong&gt; define how to structure Erlang code in terms of processes, modules, and directories.</source>
          <target state="translated">所述&lt;strong&gt;OTP设计原则&lt;/strong&gt;定义如何构建的Erlang代码中的过程，模块，和目录条款。</target>
        </trans-unit>
        <trans-unit id="ce6dbe8f8ec89aa3b4f8a5fbd8bce3df7dce0384" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;anonymous variable&lt;/strong&gt; is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</source>
          <target state="translated">所述&lt;strong&gt;匿名变量&lt;/strong&gt;由下划线表示（_），并且可以在需要的变量，但其值可以忽略使用。</target>
        </trans-unit>
        <trans-unit id="a6798179458a851b9ebec479cdde3c475bff4cbb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application resource file&lt;/strong&gt; specifies the resources an application uses, and how the application is started. There must always be one application resource file called &lt;code&gt;Application.app&lt;/code&gt; for each application &lt;code&gt;Application&lt;/code&gt; in the system.</source>
          <target state="translated">该&lt;strong&gt;应用程序资源文件&lt;/strong&gt;指定资源的应用程序的使用，以及应用程序的启动方式。系统中的每个应用程序 &lt;code&gt;Application&lt;/code&gt; 始终必须有一个名为 &lt;code&gt;Application.app&lt;/code&gt; 的应用程序资源文件。</target>
        </trans-unit>
        <trans-unit id="f6e14a23d7c2ef8d516ebeb71a889d63ab7e5e5f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application upgrade file&lt;/strong&gt; defines how an application is upgraded or downgraded in a running system.</source>
          <target state="translated">该&lt;strong&gt;应用程序升级文件&lt;/strong&gt;定义了应用程序如何升级或正在运行的系统降级。</target>
        </trans-unit>
        <trans-unit id="6724ecd893c2f90d64929956a749eae932ffa031" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;beam_makeops&lt;/strong&gt; Perl script is used at build-time by both the compiler and runtime system. Given a number of input files (all with the extension &lt;code&gt;.tab&lt;/code&gt;), it will generate source files used by the Erlang compiler and by the runtime system to load and execute BEAM instructions.</source>
          <target state="translated">该&lt;strong&gt;beam_makeops&lt;/strong&gt; Perl脚本是在编译时由编译器和运行系统都使用。给定许多输入文件（所有扩展名为 &lt;code&gt;.tab&lt;/code&gt; ），它将生成Erlang编译器和运行时系统用来加载和执行BEAM指令的源文件。</target>
        </trans-unit>
        <trans-unit id="2db57b7456855f2efbc5591cfd1f43a7d95e2566" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;boot script&lt;/strong&gt; describes how the Erlang runtime system is started. It contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">该&lt;strong&gt;启动脚本&lt;/strong&gt;描述了Erlang运行时系统如何启动。它包含有关加载哪些代码以及启动哪些进程和应用程序的说明。</target>
        </trans-unit>
        <trans-unit id="c43e23aec0edb2b1553fbf3a42ab629ff93e0727" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is a property of the &lt;strong&gt;callback module&lt;/strong&gt; and is set at server start. It may be changed due to a code upgrade/downgrade, or when changing the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="translated">该&lt;strong&gt;回调模式&lt;/strong&gt;是的属性&lt;strong&gt;回调模块&lt;/strong&gt;，并设置在服务器启动。由于代码的升级/降级，或在更改&lt;strong&gt;回调模块&lt;/strong&gt;时，可能会更改它。</target>
        </trans-unit>
        <trans-unit id="0117a440e83974bf851c56ecb41421105f272e12" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected by implementing a mandatory callback function &lt;code&gt; Module:callback_mode() &lt;/code&gt; that returns one of the &lt;strong&gt;callback modes&lt;/strong&gt;.</source>
          <target state="translated">该&lt;strong&gt;回调模式&lt;/strong&gt;是通过实施强制回调函数选择 &lt;code&gt; Module:callback_mode() &lt;/code&gt; ，所述的返回一个&lt;strong&gt;回调模式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5741097334e8b8597284eb3550244c5de695e977" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;strong&gt;回调模式&lt;/strong&gt;开始时被选择 &lt;code&gt;gen_statem&lt;/code&gt; 并使用返回值从代码改变后 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b41a677df62f29884be14a8c6c25a7497c11480" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected with the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">使用从 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 的返回值选择&lt;strong&gt;回调模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="5bffb738c6ff50eb3adeb56460c8af109c3f28df" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt;&lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">该&lt;strong&gt;回调模式&lt;/strong&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 使得能够利用如在部分中描述的非原子状态 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; ，例如，一个复杂的状态术语等的元组。</target>
        </trans-unit>
        <trans-unit id="3427359c72c6325ce793c2593793b153f136ba5e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; can be changed for a running server using any of the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt;transition actions&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt;, &lt;code&gt;{push_callback_module, NewModule}&lt;/code&gt; or &lt;code&gt;pop_callback_module&lt;/code&gt;. Note that this is a pretty esoteric thing to do... The origin for this feature is a protocol that after version negotiation branches off into quite different state machines depending on the protocol version. There</source>
          <target state="translated">可以使用任何 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt;transition actions&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; ， &lt;code&gt;{push_callback_module, NewModule}&lt;/code&gt; 或 &lt;code&gt;pop_callback_module&lt;/code&gt; 来更改正在运行的服务器的&lt;strong&gt;回调模块&lt;/strong&gt;。请注意，这是一件很深奥的事情。此功能的起源是协议，在版本协商之后，根据协议版本，该协议会分为非常不同的状态机。那里</target>
        </trans-unit>
        <trans-unit id="61740187206076da0d0e88e42b8dcd3ef778c9b8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback module&lt;/strong&gt; contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the &lt;strong&gt;callback module&lt;/strong&gt; with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">该&lt;strong&gt;回调模块&lt;/strong&gt;包含实现状态机的功能。发生事件时， &lt;code&gt;gen_statem&lt;/code&gt; 行为引擎会使用事件，当前状态和服务器数据在&lt;strong&gt;回调模块中&lt;/strong&gt;调用一个函数。此函数执行此事件的操作，并返回新状态和服务器数据，以及行为引擎要执行的操作。</target>
        </trans-unit>
        <trans-unit id="010c2dfc5017e7774d251ec3e8505c4cdafc0e30" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;detailed table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;表&lt;/strong&gt;的&lt;strong&gt;详细事件&lt;/strong&gt;是元组，例如 &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="790690408a0b723c21e944914ee3b6f33b9bfb5b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dynamic node name&lt;/strong&gt; feature is supported from OTP 23. Both the temporary client node and the first connected peer node (supplying the dynamic node name) must be at least OTP 23 for it to work.</source>
          <target state="translated">该&lt;strong&gt;动态节点名称&lt;/strong&gt;特征是从OTP 23支撑这两个临时客户端节点和所述第一连接的对等节点（供给动态节点名称）必须至少是23 OTP为它的工作。</target>
        </trans-unit>
        <trans-unit id="60cb531fb67c541100e62d6289d443a02cba5fa3" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty set&lt;/strong&gt; contains no elements.</source>
          <target state="translated">该&lt;strong&gt;空集&lt;/strong&gt;不包含任何元素。</target>
        </trans-unit>
        <trans-unit id="529d8e8336cfdf10118ffc9b093a47018a9c6171" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;mstone2&lt;/strong&gt; is similar to the &lt;strong&gt;mstone1&lt;/strong&gt; tool, but in this case, each created process makes only &lt;strong&gt;one&lt;/strong&gt; run through the messages and then exits. A soon as a process exits, a new process (with the same config and messages) is created to takes its place. The number of messages processed in total is the mstone2(1) value.</source>
          <target state="translated">所述&lt;strong&gt;mstone2&lt;/strong&gt;类似于&lt;strong&gt;mstone1&lt;/strong&gt;工具，但在这种情况下，每个所创建的过程使得仅&lt;strong&gt;一个&lt;/strong&gt;通过消息，然后退出运行。进程退出后，将立即创建一个具有相同配置和消息的新进程来代替它。总共处理的消息数为mstone2（1）值。</target>
        </trans-unit>
        <trans-unit id="b927187f56617f5aef02c9b312ff36f409a08649" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ordered pair&lt;/strong&gt; of a and b, with first &lt;strong&gt;coordinate&lt;/strong&gt; a and second coordinate b, is denoted (a, b). An ordered pair is an &lt;strong&gt;ordered set&lt;/strong&gt; of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements.</source>
          <target state="translated">具有第一&lt;strong&gt;坐标&lt;/strong&gt; a和第二坐标b 的a和b 的&lt;strong&gt;有序对&lt;/strong&gt;表示为（a，b）。有序对是两个元素的&lt;strong&gt;有序集合&lt;/strong&gt;。在此模块中，有序集可以包含一个，两个或多个元素，并且括号用于将元素括起来。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83c801cd635dbe318e9132115de7b55b1599720" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;receiver&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which expects a response (for example Get, GetNext, Get-Bulk, Set or Inform PDU).</source>
          <target state="translated">所述&lt;strong&gt;接收器&lt;/strong&gt;是&lt;strong&gt;权威&lt;/strong&gt;对于含有有效载荷，其期望的响应消息（例如GET，的GetNext，取块，设置或通知PDU）。</target>
        </trans-unit>
        <trans-unit id="ac92db4f0e00aaa89bb19e432441af806acad352" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release handler&lt;/strong&gt; process belongs to the SASL application, which is responsible for &lt;strong&gt;release handling&lt;/strong&gt;, that is, unpacking, installation, and removal of release packages.</source>
          <target state="translated">该&lt;strong&gt;发布处理器&lt;/strong&gt;进程属于SASL应用程序，这是负责&lt;strong&gt;发布处理&lt;/strong&gt;，即，启封，安装和拆卸版本的软件包。</target>
        </trans-unit>
        <trans-unit id="91dc52a591c8ca51fdb38124dea4daf9b7e6ea32" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release resource file&lt;/strong&gt; specifies which applications are included in a release (system) based on Erlang/OTP.</source>
          <target state="translated">在&lt;strong&gt;释放资源文件&lt;/strong&gt;基于二郎/ OTP哪些应用程序被包括在释放（系统）指定。</target>
        </trans-unit>
        <trans-unit id="ad1a94e9c3dc7a7604b7beecc0ad4192b022ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release upgrade file&lt;/strong&gt; describes how a release is upgraded in a running system.</source>
          <target state="translated">该&lt;strong&gt;版本的升级文件&lt;/strong&gt;描述释放如何在正在运行的系统升级。</target>
        </trans-unit>
        <trans-unit id="df96a6a378319ab14151f9909dca99424881e367" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;sender&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which does &lt;strong&gt;not&lt;/strong&gt; expect a response (for example SNMPv2-Trap, Response or Report PDU).</source>
          <target state="translated">的&lt;strong&gt;发送者&lt;/strong&gt;是&lt;strong&gt;权威&lt;/strong&gt;对于含有有效载荷，其不消息&lt;strong&gt;不&lt;/strong&gt;期望（例如的SNMPv2-陷阱，响应或报告PDU）的响应。</target>
        </trans-unit>
        <trans-unit id="4ac925cddc8d38d70b14e09284795baa1f665f91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simple table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">在&lt;strong&gt;简单的表事件&lt;/strong&gt;都像元组 &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="c7623d1fa21054abc3e3ac53a4bbc8066dac8120" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;socket registry&lt;/strong&gt; is how we keep track of sockets. There are two functions that can be used for interaction: &lt;code&gt;&lt;a href=&quot;socket#number_of-0&quot;&gt;socket:number_of/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;socket#which_sockets-1&quot;&gt;socket:which_sockets/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;strong&gt;插座注册表&lt;/strong&gt;是我们如何跟踪插座。有两个函数可用于交互： &lt;code&gt;&lt;a href=&quot;socket#number_of-0&quot;&gt;socket:number_of/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;socket#which_sockets-1&quot;&gt;socket:which_sockets/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e42f516326a33814c075d0ef2dd476acfd28000d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;strong&gt;状态回调&lt;/strong&gt;特定 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;gen_statem&lt;/code&gt; 是呼吁在这种状态下的所有事件的回调函数。根据回调模块使用回调函数 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 选择。</target>
        </trans-unit>
        <trans-unit id="39642072ab882c38d48ac8e225ecf14ced26e9ee" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; is the callback function that handles an event in the current state, and which function that is depends on the &lt;strong&gt;callback mode&lt;/strong&gt;:</source>
          <target state="translated">的&lt;strong&gt;状态回调&lt;/strong&gt;是回调函数，处理在当前的状态的事件，并且其功能是依赖于&lt;strong&gt;回调模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="79b1ae1634c63df766310472c5f61e301e8fde51" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state callback&lt;/strong&gt; return values are defined in the description of &lt;code&gt; Module:StateName/3 &lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">的&lt;strong&gt;状态回调&lt;/strong&gt;返回值中的记载所确定 &lt;code&gt; Module:StateName/3 &lt;/code&gt; 在 &lt;code&gt;gen_statem&lt;/code&gt; 手册页，但在这里是一个更可读的列表：</target>
        </trans-unit>
        <trans-unit id="2fcc34c431d064d6d4c4085640be13ac8df36a55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;system tracer&lt;/strong&gt; for sequential tracing is automatically initiated by &lt;code&gt;ttb&lt;/code&gt; when a trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; 启动跟踪端口时，由 &lt;code&gt;ttb&lt;/code&gt; 自动启动用于顺序跟踪的&lt;strong&gt;系统&lt;/strong&gt;跟踪程序。</target>
        </trans-unit>
        <trans-unit id="c33df7c3d6f3cf265ee046f5bbcec06d7fee2046" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;unordered set&lt;/strong&gt; containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples.</source>
          <target state="translated">包含元素a，b和c 的&lt;strong&gt;无序集合&lt;/strong&gt;表示为{a，b，c}。该表示法不应与元组混淆。</target>
        </trans-unit>
        <trans-unit id="338f2ff3d932d37a0203031cf3c8ecd12e555100" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;xmerl&lt;/strong&gt; XML parser is able to parse XML documents according to the XML 1.0 standard. As default it performs well-formed parsing, (syntax checks and checks of well-formed constraints). Optionally one can also use xmerl as a validating parser, (validate according to referenced DTD and validating constraints). By means of for example the xmerl_xs module it is possible to transform the parsed result to other formats, e.g. text, HTML, XML etc.</source>
          <target state="translated">该&lt;strong&gt;xmerl&lt;/strong&gt; XML解析器能够解析XML文档根据XML 1.0标准。默认情况下，它执行格式正确的解析（语法检查和格式正确的约束检查）。也可以选择将xmerl用作验证解析器（根据引用的DTD和验证约束进行验证）。通过例如xmerl_xs模块，可以将解析的结果转换为其他格式，例如文本，HTML，XML等。</target>
        </trans-unit>
        <trans-unit id="639ddc138940995a6e19ca0db97584c255b5e3c9" translate="yes" xml:space="preserve">
          <source>The ACC time calculation is sometimes difficult to make correct, since it is difficult to define. This happens especially when a function occurs in several instances in the call stack, for example by calling itself perhaps through other functions and perhaps even non-tail recursively.</source>
          <target state="translated">ACC时间的计算有时很难做到正确,因为它很难定义。特别是当一个函数在调用堆栈中的几个实例中发生时,例如通过调用自己或许通过其他函数,甚至可能是非尾部递归地调用。</target>
        </trans-unit>
        <trans-unit id="57e2a8ffba28b7446bf70cbc1663f4839a28353c" translate="yes" xml:space="preserve">
          <source>The AND intersection of the list &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt; is also easily defined:</source>
          <target state="translated">列表 &lt;code&gt;L1&lt;/code&gt; 和 &lt;code&gt;L2&lt;/code&gt; 的AND相交也很容易定义：</target>
        </trans-unit>
        <trans-unit id="03c2705073fe9051dbc22438c110997b433d5384" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt; logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">记录的API由一组 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 表单上的一组函数组成，它们都是 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt; logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 快捷方式。</target>
        </trans-unit>
        <trans-unit id="79ddb999f667f09a910e3689c6469b160527272a" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">记录的API由一组 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 表单上的一组函数组成，它们都是 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 快捷方式。</target>
        </trans-unit>
        <trans-unit id="38e9019f75b372bc1c195496de6c985d2c8006d1" translate="yes" xml:space="preserve">
          <source>The API functions in &lt;code&gt;uri_string&lt;/code&gt; work on two basic data types &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; represents a standard URI, while &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a wider datatype, that can represent URI components using &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; is a convenient choice for enabling operations such as producing standard compliant URIs out of components that have special or &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; characters. It is easier to explain this by an example.</source>
          <target state="translated">&lt;code&gt;uri_string&lt;/code&gt; 中的API函数适用于两种基本数据类型 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 表示标准URI，而 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 是更宽的数据类型，可以使用 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 字符表示URI组件。 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 是启用操作的便捷选择，例如从具有特殊字符或 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 字符的组件中生成符合标准的URI 。通过示例更容易解释这一点。</target>
        </trans-unit>
        <trans-unit id="9d41ee39dfc3d3300eef2e7cc4120a5fd8d4f83d" translate="yes" xml:space="preserve">
          <source>The API is simple:</source>
          <target state="translated">API很简单。</target>
        </trans-unit>
        <trans-unit id="d4aca81b201537abe8dedf009dd68114d62d46d3" translate="yes" xml:space="preserve">
          <source>The API provided by Windows.</source>
          <target state="translated">Windows提供的API。</target>
        </trans-unit>
        <trans-unit id="ea6764678e9074dc87171f45bcd4511b8aa2d4d8" translate="yes" xml:space="preserve">
          <source>The ASN.1 application provides the following:</source>
          <target state="translated">ASN.1应用程序提供以下内容:</target>
        </trans-unit>
        <trans-unit id="9c1b6316b531e843db6912095bad2d7449901534" translate="yes" xml:space="preserve">
          <source>The ASN.1 code, the Erlang source code, and the generated &lt;code&gt;.hrl&lt;/code&gt; files for them are provided in the distribution and are placed in the directories &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, and &lt;code&gt;include&lt;/code&gt;, respectively, in the &lt;code&gt;snmp&lt;/code&gt; application.</source>
          <target state="translated">在发行版中提供了ASN.1代码，Erlang源代码以及为它们生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件，并将它们分别放在 &lt;code&gt;snmp&lt;/code&gt; 应用程序的目录 &lt;code&gt;mibs&lt;/code&gt; ， &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;include&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c4c076a03aaf6d1e948523fb216ccde0cc05b7f7" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler can be started directly from the command line by the &lt;code&gt;erlc&lt;/code&gt; program. This is convenient when compiling many ASN.1 files from the command line or when using Makefiles. Some examples of how the &lt;code&gt;erlc&lt;/code&gt; command can be used to start the ASN.1 compiler:</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 程序可以直接从命令行启动ASN.1编译器。从命令行编译许多ASN.1文件或使用Makefile时，这很方便。有关如何使用 &lt;code&gt;erlc&lt;/code&gt; 命令来启动ASN.1编译器的一些示例：</target>
        </trans-unit>
        <trans-unit id="fb22058cd698b91ccb24c3e367daf392b4a590e1" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can encode and decode the specified data types. Alternatively, the compiler takes a specification module specifying all input modules, and generates a module with encode/decode functions. In addition, some generic functions can be used during development of applications that handles ASN.1 data (encoded as &lt;code&gt;BER&lt;/code&gt; or &lt;code&gt;PER&lt;/code&gt;).</source>
          <target state="translated">ASN.1编译器将ASN.1模块作为输入，并生成相应的Erlang模块，该模块可以对指定的数据类型进行编码和解码。或者，编译器采用指定所有输入模块的规范模块，并生成具有编码/解码功能的模块。此外，在处理ASN.1数据（编码为 &lt;code&gt;BER&lt;/code&gt; 或 &lt;code&gt;PER&lt;/code&gt; ）的应用程序的开发过程中，可以使用一些通用功能。</target>
        </trans-unit>
        <trans-unit id="c60d4a11ddc52b500d299eda7e6852a95f2bae35" translate="yes" xml:space="preserve">
          <source>The ASN.1 specifications in the test were compiled with options &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; and &lt;code&gt;asn1config&lt;/code&gt;. Omitting option &lt;code&gt;driver&lt;/code&gt; gives higher values for &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;decode_part&lt;/code&gt;. These tests have not been rerun using NIFs, but are expected to perform about 5% better than the linked-in driver.</source>
          <target state="translated">测试中的ASN.1规范使用 &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; 和 &lt;code&gt;asn1config&lt;/code&gt; 选项进行编译。省略选项 &lt;code&gt;driver&lt;/code&gt; 可为 &lt;code&gt;decode&lt;/code&gt; 和 &lt;code&gt;decode_part&lt;/code&gt; 提供更高的值。尚未使用NIF重新运行这些测试，但预期这些测试的性能比链接驱动程序高约5％。</target>
        </trans-unit>
        <trans-unit id="2f22980605315f568d967ab23f6f0f04c10f0db4" translate="yes" xml:space="preserve">
          <source>The ASN.1 to Erlang compiler does not determine the correct interpretation of each BER string octet value with different character strings. The application is responsible for interpretation of octets. Therefore, from the BER string point of view, octets are very similar to character strings and are compiled in the same way.</source>
          <target state="translated">ASN.1到Erlang编译器并不能确定每个BER字符串八位数值与不同字符串的正确解释。应用程序负责解释八位组。因此,从BER串的角度来看,八位数与字符串非常相似,编译方式也相同。</target>
        </trans-unit>
        <trans-unit id="e882c6bd57a43305a3640939f477df3d4ead459d" translate="yes" xml:space="preserve">
          <source>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</source>
          <target state="translated">ASN.1类型可以是 &quot;证书&quot;、&quot;OTPC证书 &quot;或两者的子类型。</target>
        </trans-unit>
        <trans-unit id="a7a7f7547a93bea8b589e07f519f153c18f157b7" translate="yes" xml:space="preserve">
          <source>The AVPs of the message. Ignored for an outgoing message if the &lt;code&gt;msg&lt;/code&gt; field is set to a value other than &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">消息的AVP。如果 &lt;code&gt;msg&lt;/code&gt; 字段设置为 &lt;code&gt;undefined&lt;/code&gt; 以外的值，则忽略传出消息。</target>
        </trans-unit>
        <trans-unit id="bbe283419a75e9a012fbd1970d31d2b4f451187c" translate="yes" xml:space="preserve">
          <source>The Adler checksum of the dictionary is returned.</source>
          <target state="translated">返回字典的阿德勒校验和。</target>
        </trans-unit>
        <trans-unit id="396f5f5683edcca9c1f25e63c5cdd3210d9fa913" translate="yes" xml:space="preserve">
          <source>The Anti-Replay protection feature in stateless servers executes in the following steps when a new ClientHello is received:</source>
          <target state="translated">当接收到新的ClientHello时,无状态服务器中的防重放保护功能按以下步骤执行。</target>
        </trans-unit>
        <trans-unit id="c87eb8ebe47038b4ccdd22aaa97c4f88f2c5c087" translate="yes" xml:space="preserve">
          <source>The Application Id is set in the Diameter Header of outgoing messages of the application, and the value in the header of an incoming message is used to identify the relevant dictionary module.</source>
          <target state="translated">应用程序ID设置在应用程序的外发报文的Diameter Header中,传入报文的报头中的值用于识别相关的字典模块。</target>
        </trans-unit>
        <trans-unit id="f5de0091f6607fa5ed052b8880c8cef363f44808" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to do the actual changing of the type.</source>
          <target state="translated">审计跟踪日志是由网络接口流程管理的。所以,就是这个流程要进行实际的改型。</target>
        </trans-unit>
        <trans-unit id="4ffaae1f3e0b8fd90d36e73237642154e3434485" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to retrieve the actual log-type.</source>
          <target state="translated">审计跟踪日志是由网络接口进程管理的。所以,就是这个进程要检索实际的日志类型。</target>
        </trans-unit>
        <trans-unit id="56bc2b11b64e2a80365e104579b5470c818d8f1f" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to return the actual log-type.</source>
          <target state="translated">审计跟踪日志是由网络接口进程管理的。所以,就是这个进程要返回实际的日志类型。</target>
        </trans-unit>
        <trans-unit id="5f534cf4748ee979b48f1dda16d8700a38a8db83" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:is_process_alive/1&lt;/code&gt; is the closest you can get to a process table lookup only. The BIF looks up the process corresponding to the process identifier passed as argument, and then checks if it is alive. By running multiple processes looping over this BIF checking the same process, we get a speedup between 20000-23000%. Conceptually this operation only involve read operations. In the implementation used in R16B also only read operation are performed, while the previous implementation need to lock structures in order to read the data, suffering from both lock contention and contention due to modifications of cache lines used by lock internal data structures and the reference counter on the process being looked up.</source>
          <target state="translated">BIF &lt;code&gt;erlang:is_process_alive/1&lt;/code&gt; 是最接近过程表查找的BIF 。 BIF查找与作为参数传递的进程标识符相对应的进程，然后检查它是否有效。通过在此BIF上循环运行多个进程来检查同一进程，我们可以使速度提高20000-23000％。从概念上讲，此操作仅涉及读取操作。在R16B中使用的实现中，也仅执行读取操作，而先前的实现需要锁定结构才能读取数据，由于锁定内部数据结构和引用使用的缓存行的修改而遭受锁定争用和争用对正在查找的进程进行计数器。</target>
        </trans-unit>
        <trans-unit id="fb9967052a764c3afae20ad96d6a28a3fa28a91f" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to &lt;code&gt;true&lt;/code&gt;, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</source>
          <target state="translated">BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 也可以将匹配规范添加到函数中。匹配规范包括函数参数必须匹配的模式，必须评估为 &lt;code&gt;true&lt;/code&gt; 的保护表达式以及要执行的操作。默认操作是发送跟踪消息。如果模式不匹配或防护失败，则不执行操作。</target>
        </trans-unit>
        <trans-unit id="0e87dd32697c643963810be073120b237d9b1c65" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;open_port/2&lt;/code&gt; is documented in the &lt;code&gt;erlang&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">BIF &lt;code&gt;open_port/2&lt;/code&gt; 记录在ERTS 的 &lt;code&gt;erlang&lt;/code&gt; 手册页中。</target>
        </trans-unit>
        <trans-unit id="102d447ee7d66bcdc64a15b95caa727b7d5ec384" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system.</source>
          <target state="translated">BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; 用于估计将来的负载。它返回Erlang运行时系统中准备运行的进程的队列长度。</target>
        </trans-unit>
        <trans-unit id="a6a407c55efe87e4b70f70a1f8c95515dc9b4791" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;throw(Any)&lt;/code&gt; can be used for non-local return from a function. It must be evaluated within a &lt;code&gt;catch&lt;/code&gt;, which returns the value &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;throw(Any)&lt;/code&gt; 可用于函数的非本地返回。必须在 &lt;code&gt;catch&lt;/code&gt; 中对其求值，该catch返回值 &lt;code&gt;Any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ca995f69db34040dadf8f4fb8f2daa8f294d98" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; checks if a registered process of name &lt;code&gt;RegisteredName&lt;/code&gt; exists. If it exists, the pid of that process is returned. If it does not exist, the atom &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; 检查是否存在名称为 &lt;code&gt;RegisteredName&lt;/code&gt; 的注册进程。如果存在，则返回该进程的pid。如果它不存在，则返回 &lt;code&gt;undefined&lt;/code&gt; 的原子。</target>
        </trans-unit>
        <trans-unit id="6cbf1adc0d75868cfd46589662e75f0f79ed5cbb" translate="yes" xml:space="preserve">
          <source>The Bindings area, displaying all variables bindings. If you click a variable name, the value is displayed in the Evaluator area. Double-click a variable name to open a window where the variable value can be edited. Notice however that pid, port, reference, or fun values cannot be edited unless they can be represented in the running system.</source>
          <target state="translated">绑定区域,显示所有变量的绑定。如果点击一个变量名,其值就会显示在评价器区域。双击一个变量名,打开一个可以编辑变量值的窗口。但是请注意,pid、port、reference或fun的值不能被编辑,除非它们能在运行系统中被表示出来。</target>
        </trans-unit>
        <trans-unit id="4b6c3c38656309049129434a8a3888567bd5d33d" translate="yes" xml:space="preserve">
          <source>The Button area, with buttons for quick access to frequently used functions in the &lt;strong&gt;Process&lt;/strong&gt; menu.</source>
          <target state="translated">按钮区域，带有用于快速访问&amp;ldquo; &lt;strong&gt;过程&amp;rdquo;&lt;/strong&gt;菜单中常用功能的按钮。</target>
        </trans-unit>
        <trans-unit id="ada22f32dd020105bdc39ab625188b5d539d360a" translate="yes" xml:space="preserve">
          <source>The C driver is a module that is compiled and linked into a shared library. It uses a driver structure and includes the header file &lt;code&gt;erl_driver.h&lt;/code&gt;.</source>
          <target state="translated">C驱动程序是一个模块，已编译并链接到共享库中。它使用驱动程序结构，并包含头文件 &lt;code&gt;erl_driver.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a7c12f419c3e677f26c1d74131f78103f5ccbf9" translate="yes" xml:space="preserve">
          <source>The C node can act as a server or a client when setting up the Erlang-C communication. If it acts as a client, it connects to an Erlang node by calling &lt;code&gt;erl_connect()&lt;/code&gt;, which returns an open file descriptor at success:</source>
          <target state="translated">设置Erlang-C通信时，C节点可以充当服务器或客户端。如果它充当客户端，则通过调用 &lt;code&gt;erl_connect()&lt;/code&gt; 来连接到Erlang节点，该命令成功返回一个打开的文件描述符：</target>
        </trans-unit>
        <trans-unit id="f778bcd020988cc52d7d8911bac363507b5bc1fe" translate="yes" xml:space="preserve">
          <source>The C node can receive a message from Erlang by calling &lt;code&gt;erl_receive msg()&lt;/code&gt;. This function reads data from the open file descriptor &lt;code&gt;fd&lt;/code&gt; into a buffer and puts the result in an &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt;. &lt;code&gt;ErlMessage&lt;/code&gt; has a field &lt;code&gt;type&lt;/code&gt; defining what kind of data is received. In this case, the type of interest is &lt;code&gt;ERL_REG_SEND&lt;/code&gt; which indicates that Erlang sent a message to a registered process at the C node. The actual message, an &lt;code&gt;ETERM&lt;/code&gt;, is in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">C节点可以通过调用 &lt;code&gt;erl_receive msg()&lt;/code&gt; 从Erlang接收消息。此函数将打开的文件描述符 &lt;code&gt;fd&lt;/code&gt; 中的数据读取到缓冲区中，并将结果放入 &lt;code&gt;ErlMessage&lt;/code&gt; struct &lt;code&gt;emsg&lt;/code&gt; 中。 &lt;code&gt;ErlMessage&lt;/code&gt; 具有定义接收数据 &lt;code&gt;type&lt;/code&gt; 的字段类型。在这种情况下，感兴趣的类型是 &lt;code&gt;ERL_REG_SEND&lt;/code&gt; ，它表示Erlang向C节点的注册进程发送了一条消息。实际消息 &lt;code&gt;ETERM&lt;/code&gt; 在 &lt;code&gt;msg&lt;/code&gt; 字段中。</target>
        </trans-unit>
        <trans-unit id="ec592580544dfa8a13cf79ebfaf21d822174fe76" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_pid()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">由 &lt;code&gt;ec&lt;/code&gt; 标识的C节点必须已初始化，并且必须在调用 &lt;code&gt;ei_make_pid()&lt;/code&gt; 之前已收到名称。通过调用 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 或friends来完成C节点的初始化。如果名称是从对等节点动态分配的，则还必须连接C节点。</target>
        </trans-unit>
        <trans-unit id="e13c2586709436dfbebc6149ffb9c1b130da4a2e" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_make_ref()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">&lt;code&gt;ec&lt;/code&gt; 标识的C节点必须已初始化，并且必须在调用 &lt;code&gt;ei_make_ref()&lt;/code&gt; 之前已接收到名称。通过调用 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 或friends来完成C节点的初始化。如果名称是从对等节点动态分配的，则还必须连接C节点。</target>
        </trans-unit>
        <trans-unit id="39af024e46f5af7c40347c42343f756bdbbc0a29" translate="yes" xml:space="preserve">
          <source>The C-node identified by &lt;code&gt;ec&lt;/code&gt; must have been initialized and must have received a name prior to the call to &lt;code&gt;ei_self()&lt;/code&gt;. Initialization of the C-node is done by a call to &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends. If the name is dynamically assigned from the peer node, the C-node also has to be connected.</source>
          <target state="translated">由 &lt;code&gt;ec&lt;/code&gt; 标识的C节点必须已初始化，并且必须在调用 &lt;code&gt;ei_self()&lt;/code&gt; 之前已收到名称。通过调用 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 或friends来完成C节点的初始化。如果名称是从对等节点动态分配的，则还必须连接C节点。</target>
        </trans-unit>
        <trans-unit id="44cfee0b8169b38821cf004612b6024fa4504a22" translate="yes" xml:space="preserve">
          <source>The CA certificates specified for the connection will be used to construct the certificate chain validating the CRLs.</source>
          <target state="translated">为连接指定的CA证书将被用来构建验证CRL的证书链。</target>
        </trans-unit>
        <trans-unit id="9b711437028a29fd162a39304f7e85e3b67e2c19" translate="yes" xml:space="preserve">
          <source>The CGI script response comprises a message header and a message body, separated by a blank line. The message header contains one or more header fields. The body can be empty.</source>
          <target state="translated">CGI脚本响应包括一个消息头和一个消息体,用空行隔开。消息头包含一个或多个头字段。本体可以是空的。</target>
        </trans-unit>
        <trans-unit id="4c3c9d660d39101e158d800c72dc5b3c5f71e86f" translate="yes" xml:space="preserve">
          <source>The CNT column shows the total number of function calls that was found in the trace. In the ACC column is the total time of the trace from first timestamp to last. And in the OWN column is the sum of the execution time in functions found in the trace, not including called functions. In this case it is very close to the ACC time since the emulator had practically nothing else to do than to execute our test program.</source>
          <target state="translated">CNT列显示的是在跟踪中发现的函数调用的总次数。ACC列是跟踪中从第一个时间戳到最后一个时间戳的总时间。OWN列是跟踪中发现的函数执行时间的总和,不包括被调用的函数。在这种情况下,它非常接近ACC时间,因为仿真器除了执行我们的测试程序之外,几乎没有其他事情要做。</target>
        </trans-unit>
        <trans-unit id="0bca2724268527bcfe47363d53f453d381e52758" translate="yes" xml:space="preserve">
          <source>The CPU topology is used when binding schedulers to logical processors. If schedulers are already bound when the CPU topology is changed, the schedulers are sent a request to rebind according to the new CPU topology.</source>
          <target state="translated">在将调度器绑定到逻辑处理器时,会用到CPU拓扑结构。如果在CPU拓扑结构改变时,调度器已经被绑定,则会向调度器发送请求,要求按照新的CPU拓扑结构重新绑定。</target>
        </trans-unit>
        <trans-unit id="3e338f2c345acced3a85f3002b3cdda7b33768c1" translate="yes" xml:space="preserve">
          <source>The CPU utilization is defined as the sum of the percentage shares of the CPU cycles spent in all busy processor states (see &lt;code&gt;util/1&lt;/code&gt; below) in average on all CPUs.</source>
          <target state="translated">CPU利用率定义为在所有CPU上平均所有繁忙处理器状态（请参见下面的 &lt;code&gt;util/1&lt;/code&gt; ）所花费的CPU周期百分比份额的总和。</target>
        </trans-unit>
        <trans-unit id="aa86529ffc420dbda732a44a0aa8bd483c1ae653" translate="yes" xml:space="preserve">
          <source>The CRL entry extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL条目扩展OID名称原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="270f1611da531780d2eaa5897949ee887332e027" translate="yes" xml:space="preserve">
          <source>The CRL extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">CRL扩展OID名称原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="d9b7329cef621756a648262a641008c28933737d" translate="yes" xml:space="preserve">
          <source>The CRLs will be fetched from a local or external cache. See &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt;.</source>
          <target state="translated">CRL将从本地或外部缓存中获取。参见 &lt;code&gt;ssl_crl_cache_api(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc03e6a9344836dc83866fc80ae58c6381b38386" translate="yes" xml:space="preserve">
          <source>The CRYPTO app has evolved during its lifetime. Since also the OpenSSL cryptolib has changed the API several times, there are parts of the CRYPTO app that uses a very old one internally and other parts that uses the latest one. The internal definitions of e.g cipher names was a bit hard to maintain.</source>
          <target state="translated">CRYPTO应用程序在其生命周期中不断发展。由于OpenSSL密码库已经多次更改API,CRYPTO应用中有些部分内部使用了非常老的API,而有些部分则使用了最新的API。内部定义的例如密码名有点难以维护。</target>
        </trans-unit>
        <trans-unit id="f3d829d39e1e62045ec8647a09fccc7a51c77978" translate="yes" xml:space="preserve">
          <source>The CT hook functions can call any logging function in the &lt;code&gt;ct&lt;/code&gt; interface to print information to the log files, or to add comments in the suite overview page.</source>
          <target state="translated">CT挂钩函数可以调用 &lt;code&gt;ct&lt;/code&gt; 界面中的任何日志记录功能，以将信息打印到日志文件，或在套件概述页面中添加注释。</target>
        </trans-unit>
        <trans-unit id="3ec67be87ba83be4a6a36f46cae0a249d6c031c6" translate="yes" xml:space="preserve">
          <source>The Call Graph is  represented by Erlang terms (the sets are lists), which is suitable for many analyses. But for analyses that look at chains of calls, a list representation is much too slow. Instead the representation offered by the &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; module is used. The translation of the list representation of the Call Graph - or a subgraph thereof - to the &lt;code&gt;digraph&lt;/code&gt; representation does not come for free, so the language used for expressing queries to be described below has a special operator for this task and a possibility to save the &lt;code&gt;digraph&lt;/code&gt; representation for subsequent analyses.</source>
          <target state="translated">调用图由Erlang术语（集合为列表）表示，适用于许多分析。但是，对于要查看呼叫链的分析，列表表示太慢了。而是使用 &lt;code id=&quot;representation&quot;&gt;digraph&lt;/code&gt; 模块提供的表示形式。调用图的列表表示（或其子图）到 &lt;code&gt;digraph&lt;/code&gt; 表示的翻译不是免费的，因此下面将要描述的用于表达查询的语言对此操作具有特殊的运算符，并且有可能保存该图。 &lt;code&gt;digraph&lt;/code&gt; 表示以用于后续分析。</target>
        </trans-unit>
        <trans-unit id="bce56cac593ab0a42cef53b33869a05dc52b528e" translate="yes" xml:space="preserve">
          <source>The Code area, displaying the code being executed. The code is indented and each line is prefixed with its line number. If the process execution is stopped, the current line is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. An existing break point at a line is marked with a stop symbol. In the example shown in the illustration, the execution stopped at line 6, before the execution of &lt;code&gt;fac/1&lt;/code&gt;.</source>
          <target state="translated">代码区域，显示正在执行的代码。代码是缩进的，每行都以其行号为前缀。如果进程执行停止，则当前行用 &lt;code&gt;--&amp;gt;&lt;/code&gt; 标记。一条线上的现有断点标有停止符号。在图示的示例中，执行在 &lt;code&gt;fac/1&lt;/code&gt; 执行之前在第6行停止。</target>
        </trans-unit>
        <trans-unit id="3c4163ad4ae86ebef487e34acf3cb3b300872a11" translate="yes" xml:space="preserve">
          <source>The Common Message and Relay applications are the only applications that diameter itself has any specific knowledge of. The Common Message application is used for messages that diameter itself handles: CER/CEA, DWR/DWA and DPR/DPA. The Relay application is given special treatment with regard to encode/decode since the messages and AVPs it handles are not specifically defined.</source>
          <target state="translated">Common Message 和 Relay 应用是 diameter 本身唯一有特定知识的应用。Common Message应用是用于直径本身处理的消息。CER/CEA、DWR/DWA和DPR/DPA。中继应用程序在编码/解码方面得到了特殊的处理,因为它所处理的报文和AVP并没有被特别定义。</target>
        </trans-unit>
        <trans-unit id="314dbe1e2d1cb12d891485b91d81bb94162ddaf9" translate="yes" xml:space="preserve">
          <source>The Compliance column notes &lt;strong&gt;C&lt;/strong&gt; (Compliant) if the required functionality is implemented, &lt;strong&gt;PC&lt;/strong&gt; (Partially Compliant) if there are limitations, &lt;strong&gt;NC&lt;/strong&gt; (Not Compliant) if functionality is not implemented, or a dash if text is informational or only places requirements that must be met by the user's implementation.</source>
          <target state="translated">如果已实现所需的功能，&amp;ldquo;合规性&amp;rdquo;列会显示&lt;strong&gt;C&lt;/strong&gt;（符合），如果有限制，则为&lt;strong&gt;PC&lt;/strong&gt;（部分符合），如果未实现功能，则为&lt;strong&gt;NC&lt;/strong&gt;（不符合），如果文本是信息性的或仅提出必须满足的要求，则显示破折号由用户的实现来满足。</target>
        </trans-unit>
        <trans-unit id="cb5797134c742f2284426627bbcaee9db9ff4f9b" translate="yes" xml:space="preserve">
          <source>The ControlPid may be the identity of a process residing on another Erlang node. This is useful when you want to distribute a user over several Erlang nodes. In such a case one of the nodes has the physical connection. When a user residing on one of the other nodes needs to send a request (with megaco:call/3 or megaco:cast/3), the message will encoded on the originating Erlang node, and then be forwarded to the node with the physical connection. When the reply arrives, it will be forwarded back to the originator. The distributed connection may explicitly be deactivated by a local call to megaco:disconnect/2 or implicitly when the physical connection is deactivated (with megaco:disconnect/2, killing the controlling process, halting the other node, ...).</source>
          <target state="translated">ControlPid可以是驻留在另一个Erlang节点上的进程的标识。当你想把一个用户分布在几个Erlang节点上时,这很有用。在这种情况下,其中一个节点拥有物理连接。当驻留在其他节点上的用户需要发送请求时(使用megaco:call/3或megaco:cast/3),消息将在发起的Erlang节点上进行编码,然后转发到有物理连接的节点。当回复到达时,它将被转发回发起者。分布式连接可以通过本地调用megaco:disconnect/2显式地停用,也可以在物理连接停用时隐式地停用(使用megaco:disconnect/2,杀死控制进程,停止其他节点,...)。</target>
        </trans-unit>
        <trans-unit id="78df27997f59e3cf7a226f97555796fd4db3b167" translate="yes" xml:space="preserve">
          <source>The Crashdump Viewer is a WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">Crashdump Viewer是一个基于WxWidgets的工具,用于浏览Erlang crashdump。</target>
        </trans-unit>
        <trans-unit id="e25b4f2128c61d45f1244bb1e42a65e6c254444f" translate="yes" xml:space="preserve">
          <source>The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.</source>
          <target state="translated">Cs (Surrogate)属性只适用于U+D800到U+DFFF范围内的字符。这些字符在Unicode字符串中是无效的,因此不能被PCRE测试。Perl不支持Cs属性。</target>
        </trans-unit>
        <trans-unit id="8d8b1e5940b411ae8301615a457804bfb0094984" translate="yes" xml:space="preserve">
          <source>The DER encoder omits the encoding for the same &lt;code&gt;BIT STRING&lt;/code&gt;:</source>
          <target state="translated">DER编码器省略了相同 &lt;code&gt;BIT STRING&lt;/code&gt; 的编码：</target>
        </trans-unit>
        <trans-unit id="9e781b3302f49ad7b6f93f77b8bb63523e6ee75c" translate="yes" xml:space="preserve">
          <source>The DER-encoded Diffie-Hellman parameters. If specified, it overrides option &lt;code&gt;dhfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的Diffie-Hellman参数。如果指定，它将覆盖选项 &lt;code&gt;dhfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e05b3ca4b742f1e879494bc5c683f33ec025ce" translate="yes" xml:space="preserve">
          <source>The DER-encoded trusted certificates. If this option is supplied it overrides option &lt;code&gt;cacertfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的受信任证书。如果提供了此选项，它将覆盖选项 &lt;code&gt;cacertfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ba530c04cbce9e372b32aee5f085b4acb4f0137" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt; crypto:engine_load/4 &lt;/code&gt; and &lt;code&gt; Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的用户的私钥或引用加密引擎的映射及其密钥引用（可以选择使用密码保护），另请参阅 &lt;code&gt; crypto:engine_load/4 &lt;/code&gt; 和 &lt;code&gt; Crypto's Users Guide&lt;/code&gt; 。如果提供了此选项，它将覆盖选项 &lt;code&gt;keyfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="503452c36c49cb1fd0ea949662ea239d8f9105d2" translate="yes" xml:space="preserve">
          <source>The DER-encoded user's private key or a map refering to a crypto engine and its key reference that optionally can be password protected, seealso &lt;code&gt;crypto:engine_load/4&lt;/code&gt; and &lt;code&gt;Crypto's Users Guide&lt;/code&gt;. If this option is supplied, it overrides option &lt;code&gt;keyfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的用户的私钥或引用加密引擎的映射及其密钥引用（可以选择使用密码保护），另请参阅 &lt;code&gt;crypto:engine_load/4&lt;/code&gt; 和 &lt;code&gt;Crypto's Users Guide&lt;/code&gt; 。如果提供了此选项，它将覆盖选项 &lt;code&gt;keyfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1412b8d79c31037e94ec8ee160cfa882f7bfb3fb" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的用户证书。如果提供了此选项，它将覆盖选项 &lt;code&gt;certfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62d494bd359efefc011e29e6ca8af7b8607707f9" translate="yes" xml:space="preserve">
          <source>The DER-encoded users certificate. Note that the cert option may also be a list of DER-encoded certificates where the first one is the users certificate and the rest of the certificates constitutes the certificate chain. For maximum interoperability the certificates in the chain should be in the correct order, the chain will be sent as is to the peer. If chain certificates are not provided, certificates from &lt;code&gt;&lt;a href=&quot;#type-client_cacerts&quot;&gt;client_cacerts()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cacerts&quot;&gt;server_cacerts()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#type-client_cafile&quot;&gt;client_cafile()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-server_cafile&quot;&gt;server_cafile()&lt;/a&gt;&lt;/code&gt; are used to construct the chain. If this option is supplied, it overrides option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">DER编码的用户证书。请注意，cert选项也可以是DER编码证书的列表，其中第一个是用户证书，其余证书构成证书链。为了获得最大的互操作性，链中的证书应以正确的顺序排列，该链将按原样发送给对等方。如果未提供链证书， &lt;code&gt;&lt;a href=&quot;#type-client_cacerts&quot;&gt;client_cacerts()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-server_cacerts&quot;&gt;server_cacerts()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-client_cafile&quot;&gt;client_cafile()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-server_cafile&quot;&gt;server_cafile()&lt;/a&gt;&lt;/code&gt; 的证书来构造链。如果提供了此选项，它将覆盖选项 &lt;code&gt;certfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00e40d2bc93d885d8856a1b65b6e1164cd7cb96" translate="yes" xml:space="preserve">
          <source>The Data Structures of the Distribution Driver</source>
          <target state="translated">分销驱动的数据结构</target>
        </trans-unit>
        <trans-unit id="25f2f74a7edc47541dafb29c006cde23cd47d9fe" translate="yes" xml:space="preserve">
          <source>The Diameter header of the message. Can be (and typically should be) &lt;code&gt;undefined&lt;/code&gt; for an outgoing message in a non-relay application, in which case diameter provides appropriate values.</source>
          <target state="translated">消息的Diameter标头。对于非中继应用程序中的传出消息，可以（通常应该是 &lt;code&gt;undefined&lt;/code&gt; ），在这种情况下，直径可以提供适当的值。</target>
        </trans-unit>
        <trans-unit id="5efc1791e653c1599eb1a85a25bc63fbc5f68900" translate="yes" xml:space="preserve">
          <source>The EPMD closes the socket when it has sent the information.</source>
          <target state="translated">EPMD发送完信息后,就会关闭套接字。</target>
        </trans-unit>
        <trans-unit id="e75f4961aac2a4105e4523a54d7cf3b30606ca91" translate="yes" xml:space="preserve">
          <source>The ERTS memory allocators manage memory blocks in two types of raw memory chunks. We call these chunks of raw memory &lt;strong&gt;carriers&lt;/strong&gt;. Single-block carriers which only contain one large block, and multi-block carriers which contain multiple blocks. A carrier is typically created using &lt;code&gt;mmap()&lt;/code&gt; on unix systems. However, how a carrier is created is of minor importance. An allocator instance typically manages a mixture of single- and multi-block carriers.</source>
          <target state="translated">ERTS内存分配器以两种类型的原始内存块管理内存块。我们称这些块为原始内存&lt;strong&gt;载体&lt;/strong&gt;。仅包含一个大块的单块载波，以及包含多个块的多块载波。通常在unix系统上使用 &lt;code&gt;mmap()&lt;/code&gt; 创建载体。但是，如何创建载体并不重要。分配器实例通常管理单块和多块载波的混合。</target>
        </trans-unit>
        <trans-unit id="657accf9a74a7eb0b025905c51aa524bbb4f52c3" translate="yes" xml:space="preserve">
          <source>The ETS type of the dumped table (that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;duplicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;). This type is used when loading the table again.</source>
          <target state="translated">在ETS类型的转储的表（即， &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ， &lt;code&gt;duplicate_bag&lt;/code&gt; ，或 &lt;code&gt;ordered_set&lt;/code&gt; ）。再次加载表时使用此类型。</target>
        </trans-unit>
        <trans-unit id="37bd9159078f20014405583883e1e7838b1f320f" translate="yes" xml:space="preserve">
          <source>The EUnit framework makes it extremely easy to write unit tests in Erlang. There are a few different ways of writing them, though, so we start with the simplest:</source>
          <target state="translated">EUnit框架使得用Erlang编写单元测试变得非常容易。不过有几种不同的编写方法,所以我们从最简单的开始。</target>
        </trans-unit>
        <trans-unit id="fa53810c7a30463d78bce3f01ea7ecca8bb2337e" translate="yes" xml:space="preserve">
          <source>The Edward curves &lt;code&gt;x25519&lt;/code&gt; and &lt;code&gt;x448&lt;/code&gt; are supported with OpenSSL 1.1.1 or later if not disabled by configuration.</source>
          <target state="translated">如果未通过配置禁用，则OpenSSL 1.1.1或更高版本支持 &lt;code&gt;x448&lt;/code&gt; 曲线 &lt;code&gt;x25519&lt;/code&gt; 和x448。</target>
        </trans-unit>
        <trans-unit id="25e6615a6259b426a5c1aa433aefd48dfe9f0730" translate="yes" xml:space="preserve">
          <source>The Election Process</source>
          <target state="translated">选举过程</target>
        </trans-unit>
        <trans-unit id="d7e47fd1c3278cd7de4abd1246ff9d0b6caf0c35" translate="yes" xml:space="preserve">
          <source>The Encoding can be changed for a file &quot;on the fly&quot; by using function &lt;code&gt;io:setopts/2&lt;/code&gt;. So a file can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then be set for the right encoding before further reading. For functions identifying BOMs, see module &lt;code&gt;unicode(3)&lt;/code&gt;.</source>
          <target state="translated">可以使用函数 &lt;code&gt;io:setopts/2&lt;/code&gt; 来&amp;ldquo;动态&amp;rdquo;更改文件的编码。因此，可以使用latin1编码对文件进行分析，例如，将BOM放置在BOM之外，然后将其设置为正确的编码，然后再进行进一步读取。有关识别BOM的功能，请参见模块 &lt;code&gt;unicode(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3ce07ca3d080f90844cafbb92cdb028293480a0" translate="yes" xml:space="preserve">
          <source>The Erlang &lt;strong&gt;error logger&lt;/strong&gt; is an event manager (see &lt;code&gt;OTP Design Principles&lt;/code&gt; and &lt;code&gt;gen_event(3)&lt;/code&gt;), registered as &lt;code&gt;error_logger&lt;/code&gt;.</source>
          <target state="translated">Erlang &lt;strong&gt;错误记录器&lt;/strong&gt;是事件管理器（请参阅 &lt;code&gt;OTP Design Principles&lt;/code&gt; 和 &lt;code&gt;gen_event(3)&lt;/code&gt; ），已注册为 &lt;code&gt;error_logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6cec8bd2bf7434e290f227203641824a28b2253" translate="yes" xml:space="preserve">
          <source>The Erlang API allows using arbitrary curve parameters, but in FIPS mode only those allowed by the Security Policy shall be used.</source>
          <target state="translated">Erlang API允许使用任意的曲线参数,但在FIPS模式下,只能使用安全策略允许的参数。</target>
        </trans-unit>
        <trans-unit id="1e13d1897ff2db6a5ca229af1382794e443a1fe1" translate="yes" xml:space="preserve">
          <source>The Erlang API of the crypto application is identical regardless of building with or without FIPS support. However the nif code internally uses a different OpenSSL API.</source>
          <target state="translated">无论有无FIPS支持,加密应用的Erlang API都是相同的。然而nif代码内部使用的是不同的OpenSSL API。</target>
        </trans-unit>
        <trans-unit id="48490447d94b14d0abe2e04b21fbd8bf2b9b8cdb" translate="yes" xml:space="preserve">
          <source>The Erlang BIF &lt;code&gt;spawn&lt;/code&gt; is used to create a new process: &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt;. Consider the following module:</source>
          <target state="translated">Erlang BIF &lt;code&gt;spawn&lt;/code&gt; 器用于创建新进程： &lt;code&gt;spawn(Module, Exported_Function, List of Arguments)&lt;/code&gt; 。考虑以下模块：</target>
        </trans-unit>
        <trans-unit id="bc260aee970be8377de4dc3244ea906f03e3f766" translate="yes" xml:space="preserve">
          <source>The Erlang BIFs.</source>
          <target state="translated">埃尔兰BIFs。</target>
        </trans-unit>
        <trans-unit id="8938c14ae46ae4bc9fd254a9382eb3df9c381a7c" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang分发协议本身并不安全，也不旨在保证安全。为了获得安全的分发，应该将分布式节点配置为使用tls上的分发。有关如何设置安全分布式节点的详细信息，请参见《 &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; 用户指南》。</target>
        </trans-unit>
        <trans-unit id="99fe49d5ed45f059cc301355028f8dfef080429d" translate="yes" xml:space="preserve">
          <source>The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">Erlang Distribution协议本身并不安全，因此也并非旨在保证安全。为了获得安全的分发，应该将分布式节点配置为使用tls上的分发。有关如何设置安全分布式节点的详细信息，请参见《 &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; 用户指南》。</target>
        </trans-unit>
        <trans-unit id="a40f7e40db92a7107a9e3a5cac4b4ab65b30339c" translate="yes" xml:space="preserve">
          <source>The Erlang Emulator</source>
          <target state="translated">埃尔兰模拟器</target>
        </trans-unit>
        <trans-unit id="99377f0e14b45ce54e27b19f84ce7e618a01753c" translate="yes" xml:space="preserve">
          <source>The Erlang I/O-system has been designed (or at least used) in a way where you expect any I/O server to handle any string data. That is, however, no longer the case when working with Unicode characters. The Erlang programmer must now know the capabilities of the device where the data ends up. Also, ports in Erlang are byte-oriented, so an arbitrary string of (Unicode) characters cannot be sent to a port without first converting it to an encoding of choice.</source>
          <target state="translated">Erlang I/O系统的设计(或至少是使用)方式是希望任何I/O服务器都能处理任何字符串数据。然而,当处理Unicode字符时,情况就不一样了。现在,Erlang程序员必须知道数据最终到达的设备的能力。另外,Erlang 中的端口是面向字节的,因此,如果没有先将任意的 (Unicode)字符串转换为所选择的编码,就不能将其发送到端口。</target>
        </trans-unit>
        <trans-unit id="81cc438ebd93249f6378dd48a6614f5a8c1d4ea2" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application consists of both &lt;code&gt;Erlang&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; code. The &lt;code&gt;C&lt;/code&gt; code is delivered as a precompiled executable for windows, solaris and linux (SLES10) in the commercial build. In the open source distribution it is built the same way as all other application using configure and make. You may want to provide the the path to your ODBC libraries using --with-odbc=PATH.</source>
          <target state="translated">Erlang ODBC应用程序由 &lt;code&gt;Erlang&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 代码组成。该 &lt;code&gt;C&lt;/code&gt; 代码交付作为在商业构建Windows，Solaris和Linux（SLES10）预编译的可执行文件。在开源发行版中，它与所有其他使用configure和make的应用程序的构建方式相同。您可能想使用--with-odbc = PATH提供ODBC库的路径。</target>
        </trans-unit>
        <trans-unit id="8a4351bfa2f995c6bd330803859435f644586add" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should run on all Unix dialects including Linux, Windows 2000, Windows XP and NT. But currently it is only tested for Solaris, Windows 2000, Windows XP and NT.</source>
          <target state="translated">Erlang ODBC应用程序应该在所有Unix方言上运行,包括Linux、Windows 2000、Windows XP和NT。但目前它只在Solaris、Windows 2000、Windows XP和NT上测试。</target>
        </trans-unit>
        <trans-unit id="c54f824f83f969a528f4d85db8ff3bf2b47f63fe" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC application should work for any relational database that has an ODBC driver. But currently it is only regularly tested for &lt;code&gt;sqlserver&lt;/code&gt; and &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Erlang ODBC应用程序应可用于具有ODBC驱动程序的任何关系数据库。但目前仅定期对 &lt;code&gt;sqlserver&lt;/code&gt; 和 &lt;code&gt;postgres&lt;/code&gt; 进行测试。</target>
        </trans-unit>
        <trans-unit id="7d474f74418b8768698a57fb6613d328b379dec3" translate="yes" xml:space="preserve">
          <source>The Erlang ODBC interface is in principal database independent, e.i. an erlang program using the interface could be run without changes towards different databases. But as SQL is used it is alas possible to write database dependent programs. Even though SQL is an ANSI-standard meant to be database independent, different databases have proprietary extensions to SQL defining their own data types. If you keep to the ANSI data types you will minimize the problem. But unfortunately there is no guarantee that all databases actually treats the ANSI data types equivalently. For instance an installation of &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; will accept that you create a table column with the ANSI data type &lt;code&gt;integer&lt;/code&gt;, but when retrieving values from this column the driver reports that it is of type &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; and not &lt;code&gt;SQL_INTEGER&lt;/code&gt; as you may have expected.</source>
          <target state="translated">Erlang ODBC接口在原则上独立于数据库，即使用该接口的erlang程序可以运行，而无需更改其他数据库。但是，由于使用了SQL，因此可以编写依赖于数据库的程序。即使SQL是要独立于数据库的ANSI标准，但不同的数据库都有对SQL的专有扩展，定义了自己的数据类型。如果您保留ANSI数据类型，则可以最大程度地减少问题。但是不幸的是，不能保证所有数据库实际上都等效地对待ANSI数据类型。例如， &lt;code&gt;Oracle Enterprise release 8.0.5.0.0 for unix&lt;/code&gt; 的Oracle Enterprise版本8.0.5.0.0的安装将接受您使用ANSI数据类型 &lt;code&gt;integer&lt;/code&gt; 创建表列的情况。，但是从此列中检索值时，驱动程序报告它的类型为 &lt;code&gt;SQL_DECIMAL(0, 38)&lt;/code&gt; &lt;code&gt;SQL_INTEGER&lt;/code&gt; ），而不是您期望的SQL_INTEGER类型。</target>
        </trans-unit>
        <trans-unit id="56a64c0ae629896e0d315a11fe6e47437de08daf" translate="yes" xml:space="preserve">
          <source>The Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt; is automatically started at every host where an Erlang node is started. It is responsible for mapping the symbolic node names to machine addresses. See the &lt;code&gt;epmd(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">Erlang Port Mapper Daemon &lt;strong&gt;epmd&lt;/strong&gt;会在启动Erlang节点的每个主机上自动启动。它负责将符号节点名映射到机器地址。请参见ERTS中的 &lt;code&gt;epmd(1)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d980add9dd240554f189b1c3b37b65443fa21bb5" translate="yes" xml:space="preserve">
          <source>The Erlang Runtime System Application, ERTS, contains functionality necessary to run the Erlang system.</source>
          <target state="translated">Erlang Runtime System Application,ERTS,包含了运行Erlang系统所需的功能。</target>
        </trans-unit>
        <trans-unit id="ec553e20bbac1faf44d07e9ebb7fae6ca5046122" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the SSL/TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSL应用程序为当前支持的版本实现SSL / TLS / DTLS协议，请参见 &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="6ca09abc1780869abd79ed38a1d8065b44531491" translate="yes" xml:space="preserve">
          <source>The Erlang SSL application implements the TLS/DTLS protocol for the currently supported versions, see the &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Erlang SSL应用程序为当前支持的版本实现TLS / DTLS协议，请参见 &lt;code&gt;&lt;a href=&quot;ssl&quot;&gt;ssl(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="0c184aeafc9a6a8c3c28dfd4fc9896eddb1e7172" translate="yes" xml:space="preserve">
          <source>The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options:</source>
          <target state="translated">Erlang Token Scanner 根据选项的不同,返回带有以下注解子集的 tokens。</target>
        </trans-unit>
        <trans-unit id="f44e036ac3f33332c9617d1ca93feead49accb2d" translate="yes" xml:space="preserve">
          <source>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</source>
          <target state="translated">Erlang虚拟机使用PCRE库,当正则表达式匹配递归发生时,会使用堆内存。因此,这限制了机器堆的使用,而不是C栈。</target>
        </trans-unit>
        <trans-unit id="8d4936bbce5dce7c69c00ed9e6d923ffdcef1207" translate="yes" xml:space="preserve">
          <source>The Erlang archives are &lt;code&gt;ZIP&lt;/code&gt; files with extension &lt;code&gt;.ez&lt;/code&gt;. Erlang archives can also be enclosed in &lt;code&gt;escript&lt;/code&gt; files whose file extension is arbitrary.</source>
          <target state="translated">Erlang存档是扩展名为 &lt;code&gt;.ez&lt;/code&gt; 的 &lt;code&gt;ZIP&lt;/code&gt; 文件。Erlang归档文件也可以包含在文件扩展名是任意的 &lt;code&gt;escript&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="75458bb55fedfe4d27d190b85b2453fc10e6e94f" translate="yes" xml:space="preserve">
          <source>The Erlang code in the &quot;Erlang code.&quot; section is written into the output file directly after the module declaration and predefined exports declaration so it is possible to add extra exports, define imports and other attributes which are then visible in the whole file.</source>
          <target state="translated">&quot;Erlang code.&quot;一节中的Erlang代码是直接写在模块声明和预定义出口声明之后的输出文件中的,所以可以添加额外的出口,定义进口和其他属性,然后在整个文件中可见。</target>
        </trans-unit>
        <trans-unit id="9bada6b35e4702ac9e1f602bd85f459a9e5c8d11" translate="yes" xml:space="preserve">
          <source>The Erlang code is slightly different, as we do not return the result synchronously from &lt;code&gt;port_control&lt;/code&gt;, instead we get it from &lt;code&gt;driver_output&lt;/code&gt; as data in the message queue. The function &lt;code&gt;return_port_data&lt;/code&gt; above receives data from the port. As the data is in binary format, we use &lt;code&gt;binary_to_term/1&lt;/code&gt; to convert it to an Erlang term. Notice that the driver is opened in binary mode (&lt;code&gt;open_port/2&lt;/code&gt; is called with option &lt;code&gt;[binary]&lt;/code&gt;). This means that data sent from the driver to the emulator is sent as binaries. Without option &lt;code&gt;binary&lt;/code&gt;, they would have been lists of integers.</source>
          <target state="translated">Erlang代码略有不同，因为我们没有从 &lt;code&gt;port_control&lt;/code&gt; 同步返回结果，而是从 &lt;code&gt;driver_output&lt;/code&gt; 获得它作为消息队列中的数据。上面的函数 &lt;code&gt;return_port_data&lt;/code&gt; 从端口接收数据。由于数据为二进制格式，因此我们使用 &lt;code&gt;binary_to_term/1&lt;/code&gt; 将其转换为Erlang项。请注意，驱动程序以二进制模式打开（使用选项 &lt;code&gt;[binary]&lt;/code&gt; 调用 &lt;code&gt;open_port/2&lt;/code&gt; ）。这意味着从驱动程序发送到仿真器的数据将作为二进制文件发送。如果没有 &lt;code&gt;binary&lt;/code&gt; 选项，它们将是整数列表。</target>
        </trans-unit>
        <trans-unit id="57d172985612cd6cd41a2f597d2b75bb27821e07" translate="yes" xml:space="preserve">
          <source>The Erlang code linter.</source>
          <target state="translated">Erlang代码的linter。</target>
        </trans-unit>
        <trans-unit id="a5138a7c32b5f91b090191893db4bd11097e1026" translate="yes" xml:space="preserve">
          <source>The Erlang code preprocessor includes functions that are used by the &lt;code&gt;compile&lt;/code&gt; module to preprocess macros and include files before the parsing takes place.</source>
          <target state="translated">Erlang代码预处理器包含一些函数， &lt;code&gt;compile&lt;/code&gt; 模块使用这些函数对宏进行预处理，并在解析发生之前包含文件。</target>
        </trans-unit>
        <trans-unit id="392fc9728278e4892ea581cefb80f74c12d7912e" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt; crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlang故障转储在Erlang / OTP R9C中进行了重大改进。因此，本节中的信息不适用于较早的转储。但是，如果在较旧的转储上使用 &lt;code&gt; crashdump_viewer(3)&lt;/code&gt; ，则故障转储将转换为与此类似的格式。</target>
        </trans-unit>
        <trans-unit id="5d403e45ee407cb0dd03528fe23bfb406bd2d6ae" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump had a major facelift in Erlang/OTP R9C. The information in this section is therefore not directly applicable for older dumps. However, if you use &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; on older dumps, the crash dumps are translated into a format similar to this.</source>
          <target state="translated">Erlang故障转储在Erlang / OTP R9C中进行了重大改进。因此，本节中的信息不适用于较早的转储。但是，如果在较旧的转储上使用 &lt;code&gt;crashdump_viewer(3)&lt;/code&gt; ，则故障转储将转换为与此类似的格式。</target>
        </trans-unit>
        <trans-unit id="737305746ee3808d6e58fd2718a7d171052eb3a2" translate="yes" xml:space="preserve">
          <source>The Erlang crash dump is a readable text file, but it can be difficult to read. Using the Crashdump Viewer tool in the &lt;code&gt;Observer&lt;/code&gt; application simplifies the task. This is a wx-widget-based tool for browsing Erlang crash dumps.</source>
          <target state="translated">Erlang故障转储是可读的文本文件，但可能很难读取。使用 &lt;code&gt;Observer&lt;/code&gt; 应用程序中的Crashdump Viewer工具可以简化任务。这是一个基于wx-widget的工具，用于浏览Erlang故障转储。</target>
        </trans-unit>
        <trans-unit id="3019fbc7ca6a8b1745aa1cb4e5822a66509aa10a" translate="yes" xml:space="preserve">
          <source>The Erlang crashdump contains a listing of each living Erlang process in the system. The following fields can exist for a process:</source>
          <target state="translated">Erlang crashdump包含了系统中每个活的Erlang进程的列表。一个进程可以存在以下字段。</target>
        </trans-unit>
        <trans-unit id="db00cf758cc1a463b96d0532ae1f4b69cef5510a" translate="yes" xml:space="preserve">
          <source>The Erlang distribution can in theory use almost any connection-based protocol as bearer. However, a module that implements the protocol-specific parts of the connection setup is needed. The default distribution module is &lt;code&gt;inet_tcp_dist&lt;/code&gt; in the Kernel application. When starting an Erlang node distributed, &lt;code&gt;net_kernel&lt;/code&gt; uses this module to set up listen ports and connections.</source>
          <target state="translated">理论上，Erlang发行版可以使用几乎所有基于连接的协议作为承载。但是，需要一个用于实现连接设置的协议特定部分的模块。内核应用程序中的默认分发模块是 &lt;code&gt;inet_tcp_dist&lt;/code&gt; 。启动分布式的Erlang节点时， &lt;code&gt;net_kernel&lt;/code&gt; 使用此模块设置侦听端口和连接。</target>
        </trans-unit>
        <trans-unit id="5c65eb0e7a3b5fcbd2b82941f0e7502510e7adf8" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there can exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API.</source>
          <target state="translated">Erlang驱动线程API可以和UN-ice上的POSIX线程API以及Windows上的Windows本地线程API一起使用。Erlang驱动线程API具有可移植性的优点,但也有可能存在使用POSIX线程API或Windows本地线程API功能的情况。</target>
        </trans-unit>
        <trans-unit id="cd35f4981de74aaf8658339a6b773ed029b97baf" translate="yes" xml:space="preserve">
          <source>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it is not reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated.</source>
          <target state="translated">Erlang驱动线程API只在合理地从错误条件中恢复时返回错误代码。如果从错误条件中恢复是不合理的,整个运行时系统就会被终止。例如,如果创建mutex操作失败,就会返回一个错误代码,但如果对mutex的锁操作失败,整个运行时系统就会被终止。</target>
        </trans-unit>
        <trans-unit id="f886f4ca7d89492a5c1356ea054f392597b34344" translate="yes" xml:space="preserve">
          <source>The Erlang editing mode provides a command that knows about the Erlang comment structure and can be used to fill text paragraphs in comments. Ex:</source>
          <target state="translated">Erlang编辑模式提供了一个知道Erlang注释结构的命令,可以用来填充注释中的文本段落。例如</target>
        </trans-unit>
        <trans-unit id="6381e25503c0fb716dfd00aadaa0608beadd9a69" translate="yes" xml:space="preserve">
          <source>The Erlang emulator is found by examining the registry keys for the emulator version specified in the release data file. The new emulator must be properly installed before the upgrade for this to work.</source>
          <target state="translated">通过检查发布数据文件中指定的模拟器版本的注册表键,可以找到Erlang模拟器。新的模拟器必须在升级前正确安装,这样才能正常工作。</target>
        </trans-unit>
        <trans-unit id="6339e932f018732bcd165eb1f04f836a77855588" translate="yes" xml:space="preserve">
          <source>The Erlang emulator keeps track of a &lt;strong&gt;stack trace&lt;/strong&gt;, information about recent function calls. This information is used if an error occurs, for example:</source>
          <target state="translated">Erlang仿真器跟踪&lt;strong&gt;堆栈跟踪&lt;/strong&gt;以及有关最近函数调用的信息。如果发生错误，则使用此信息，例如：</target>
        </trans-unit>
        <trans-unit id="17cd3f882b4ce1af8737a7262e13ec5ab23b1f5e" translate="yes" xml:space="preserve">
          <source>The Erlang emulator.</source>
          <target state="translated">Erlang仿真器。</target>
        </trans-unit>
        <trans-unit id="5714cdd55594ddeb51b48625444a53558a829eec" translate="yes" xml:space="preserve">
          <source>The Erlang external term format is a representation of an Erlang term as a sequence of bytes, that is, a binary. Conversion between the two representations is done using the following BIFs:</source>
          <target state="translated">Erlang外部术语格式是将Erlang术语表示为一个字节序列,即二进制。两种表示方式之间的转换是通过以下BIF来完成的。</target>
        </trans-unit>
        <trans-unit id="152d4b6905d9f607d0072156b089899f65fd52eb" translate="yes" xml:space="preserve">
          <source>The Erlang implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">Erlang实现是&amp;ldquo;明智的&amp;rdquo;，它可以最大程度地减少针对每个 &lt;code&gt;receive&lt;/code&gt; 中的模式对每个消息进行测试的次数。</target>
        </trans-unit>
        <trans-unit id="79a0b3cf2e8db83679b557ee8aff89fcae6b1c98" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter can also be accessed through the interface module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">也可以通过接口模块 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int(3)&lt;/a&gt;&lt;/code&gt; 访问Erlang解释器。</target>
        </trans-unit>
        <trans-unit id="d3ca39c39b895d99de154868388ab2c941551645" translate="yes" xml:space="preserve">
          <source>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is primarily intended to be used by Debugger, see the User's Guide and &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang解释器提供了断点和逐步执行代码的机制。它主要供Debugger使用，请参见《用户指南》和 &lt;code&gt;&lt;a href=&quot;debugger&quot;&gt;debugger(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfe42365ca090c07c2f31a18aa82078cc7413a46" translate="yes" xml:space="preserve">
          <source>The Erlang language is described in the &lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang Reference Manual&lt;/a&gt;. An Erlang tutorial can be found in &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;doc/reference_manual/users_guide&quot;&gt;Erlang参考手册中&lt;/a&gt;描述了Erlang语言。可以&lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;在Erlang入门中&lt;/a&gt;找到Erlang教程。</target>
        </trans-unit>
        <trans-unit id="5c86834683bf25d823843edf61397923bc0c7af5" translate="yes" xml:space="preserve">
          <source>The Erlang language specification puts no limits on the number of processes, length of atoms, and so on. However, for performance and memory saving reasons, there will always be limits in a practical implementation of the Erlang language and execution environment.</source>
          <target state="translated">Erlang语言规范对进程数量、原子长度等没有限制。但是,出于性能和节省内存的考虑,在实际实现Erlang语言和执行环境的过程中,总会有一些限制。</target>
        </trans-unit>
        <trans-unit id="5868365d112b2d753afe38d0282d35341218fb05" translate="yes" xml:space="preserve">
          <source>The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;.</source>
          <target state="translated">Erlang字符串的文字语法使用&quot;//&quot;(反斜杠)字符作为转义码。无论是在你的代码中还是在shell中,你都需要用额外的反斜杠来转义字符串中的反斜杠,也就是&quot;\\&quot;。</target>
        </trans-unit>
        <trans-unit id="7436c6776e46ff0b0c98637a1562d8d93f74d6d7" translate="yes" xml:space="preserve">
          <source>The Erlang meta interpreter.</source>
          <target state="translated">Erlang元解释器。</target>
        </trans-unit>
        <trans-unit id="6dd0afebea808766c4e5ba67702ba9bcda564088" translate="yes" xml:space="preserve">
          <source>The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language.</source>
          <target state="translated">当然,Erlang模式确实提供了这个功能。使用的布局是基于语言的常用。</target>
        </trans-unit>
        <trans-unit id="e03b514fa1c315e1fd202d5ceb91d82531266ba5" translate="yes" xml:space="preserve">
          <source>The Erlang mode for the Emacs editor includes two &lt;code&gt;Common Test&lt;/code&gt; test suite templates, one with extensive information in the function headers, and one with minimal information. A test suite template provides a quick start for implementing a suite from scratch and gives a good overview of the available callback functions. The two templates follows:</source>
          <target state="translated">Emacs编辑器的Erlang模式包括两个 &lt;code&gt;Common Test&lt;/code&gt; 测试套件模板，一个在功能标头中包含大量信息，而一个在信息中包含最少的信息。测试套件模板为从头开始实施套件提供了快速入门，并对可用的回调函数进行了很好的概述。这两个模板如下：</target>
        </trans-unit>
        <trans-unit id="bd1e16dd7e3186a437be6f5c58e6b98f95a1b6f2" translate="yes" xml:space="preserve">
          <source>The Erlang module can look as follows:</source>
          <target state="translated">Erlang模块的样子可以是这样的。</target>
        </trans-unit>
        <trans-unit id="4e4823fe40646d231f25e1af4061079540646bbb" translate="yes" xml:space="preserve">
          <source>The Erlang nif library contains function for easily working with I/O vectors as used by the unix system call &lt;code&gt;writev&lt;/code&gt;. The I/O Queue is not thread safe, so some other synchronization mechanism has to be used.</source>
          <target state="translated">Erlang nif库包含用于轻松处理unix系统调用 &lt;code&gt;writev&lt;/code&gt; 所使用的I / O向量的函数。I / O队列不是线程安全的，因此必须使用其他一些同步机制。</target>
        </trans-unit>
        <trans-unit id="4fe4b7ddd1b6e3fddbfb0dc8eba68674fa92a0bc" translate="yes" xml:space="preserve">
          <source>The Erlang node is to be given the short name &lt;code&gt;e1&lt;/code&gt; and must be set to use the same magic cookie as the C node, &lt;code&gt;secretcookie&lt;/code&gt;:</source>
          <target state="translated">Erlang节点的简称为 &lt;code&gt;e1&lt;/code&gt; ，必须设置为使用与C节点相同的魔术cookie &lt;code&gt;secretcookie&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b252e3e3ea1acfeb31712ba10c8bb1164cc7e6f7" translate="yes" xml:space="preserve">
          <source>The Erlang nodes have different cookies.</source>
          <target state="translated">Erlang节点有不同的cookies。</target>
        </trans-unit>
        <trans-unit id="2dac1fcc04ff2d796878d2e221f0d3d0504eeff3" translate="yes" xml:space="preserve">
          <source>The Erlang parser.</source>
          <target state="translated">Erlang解析器。</target>
        </trans-unit>
        <trans-unit id="e3e1a66870ceefa4057accb399287057807ab241" translate="yes" xml:space="preserve">
          <source>The Erlang part of the asynchronous driver consists of the sample file &lt;code&gt;pg_async.erl&lt;/code&gt;.</source>
          <target state="translated">异步驱动程序的Erlang部分由示例文件 &lt;code&gt;pg_async.erl&lt;/code&gt; 组成。</target>
        </trans-unit>
        <trans-unit id="8a9c70ac47d5fb1df5bdc0c1579a6d354d215f36" translate="yes" xml:space="preserve">
          <source>The Erlang pretty printer.</source>
          <target state="translated">Erlang漂亮的打印机。</target>
        </trans-unit>
        <trans-unit id="8092d1a007430220494c776fea5b8d0105151629" translate="yes" xml:space="preserve">
          <source>The Erlang process creating a port is said to be the &lt;strong&gt;port owner&lt;/strong&gt;, or the &lt;strong&gt;connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the port owner. If the port owner terminates, so does the port (and the external program, if it is written correctly).</source>
          <target state="translated">创建端口的Erlang进程被称为&lt;strong&gt;端口所有者&lt;/strong&gt;，即该&lt;strong&gt;端口&lt;/strong&gt;的&lt;strong&gt;连接进程&lt;/strong&gt;。与端口之间的所有通信都必须通过端口所有者。如果端口所有者终止，则端口（以及正确编写的外部程序）也将终止。</target>
        </trans-unit>
        <trans-unit id="27d54a521c2a5287aa3d01d2b57bd9e14da9ddb9" translate="yes" xml:space="preserve">
          <source>The Erlang representation for &quot;BMPString&quot; and &quot;UniversalString&quot; is either a list of ASCII values or a list of quadruples. The quadruple representation associates to the Unicode standard representation of characters. The ASCII characters are all represented by quadruples beginning with three zeros like {0,0,0,65} for character 'A'. When decoding a value for these strings, the result is a list of quadruples, or integers when the value is an ASCII character.</source>
          <target state="translated">BMPString &quot;和 &quot;UniversalString &quot;的Erlang表示法是一个ASCII值的列表或一个四元组的列表。四元组表示法与Unicode标准的字符表示法相关联,ASCII字符都是由三个0开头的四元组表示。ASCII字符都是由三个零开始的四元组表示,比如字符'A'的{0,0,0,65}。当解码这些字符串的值时,结果是一个四元组的列表,或者当值是ASCII字符时是整数。</target>
        </trans-unit>
        <trans-unit id="fd34b0812f3e91023a25d2d60c73c4062e69913a" translate="yes" xml:space="preserve">
          <source>The Erlang representation of an ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; is an integer or an atom if a &lt;code&gt;Named Number List&lt;/code&gt; (see &lt;code&gt;T6&lt;/code&gt; in the previous list) is specified.</source>
          <target state="translated">如果指定了 &lt;code&gt;Named Number List&lt;/code&gt; （请参阅上一个列表中的 &lt;code&gt;T6&lt;/code&gt; ），则ASN.1 &lt;code&gt;INTEGER&lt;/code&gt; 的Erlang表示形式是整数或原子。</target>
        </trans-unit>
        <trans-unit id="6762086b168330d83da3710e72be56df1e3f3f82" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.</source>
          <target state="translated">Erlang运行时系统可以使用完整的32位(或64位)地址空间,但操作系统往往限制单个进程使用的地址空间少于这个数字。</target>
        </trans-unit>
        <trans-unit id="b825bf5f9dd97f4fdde610e1f993f6d1d34418b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system requires that the contents of the script used to boot the system is a binary Erlang term. This function transforms the &lt;code&gt;File.script&lt;/code&gt; boot script to a binary term, which is stored in the &lt;code&gt;File.boot&lt;/code&gt; file.</source>
          <target state="translated">Erlang运行时系统要求用于引导系统的脚本内容是二进制的Erlang术语。此函数将 &lt;code&gt;File.script&lt;/code&gt; 引导脚本转换为二进制术语，该术语存储在 &lt;code&gt;File.boot&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="a1ce0572c42ceec3f568ad1851dad4770b2b84b7" translate="yes" xml:space="preserve">
          <source>The Erlang runtime system uses a generational garbage collection scheme, using an &quot;old heap&quot; for data that has survived at least one garbage collection. When there is no more room on the old heap, a fullsweep garbage collection is done.</source>
          <target state="translated">Erlang运行时系统使用了代际垃圾收集方案,使用一个 &quot;旧堆 &quot;来收集至少经过一次垃圾收集的数据。当旧堆上没有更多空间时,就会进行一次全扫垃圾收集。</target>
        </trans-unit>
        <trans-unit id="1b5c1cc2b8bfec92e6852fd54565f25ead94806c" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt; erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 的Erlang运行时系统视图。要检索它，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt; erlang:system_time()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9d9f6b0df9097bbff53b037dc4f96145ca6dbd2" translate="yes" xml:space="preserve">
          <source>The Erlang runtime systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 的Erlang运行时系统视图。要检索它，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="175c0bd0d93fcd68af4b41f5bd3ed0c1384dfa2e" translate="yes" xml:space="preserve">
          <source>The Erlang scanner in the &lt;code&gt;io&lt;/code&gt; module can be used as a starting point when writing a new scanner. Study &lt;code&gt;yeccscan.erl&lt;/code&gt; in order to see how a filter can be added on top of &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; to provide a scanner for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more general approach to scanner implementation is to use a scanner generator. A scanner generator in Erlang called &lt;code&gt;leex&lt;/code&gt; is under development.</source>
          <target state="translated">编写新扫描仪时，可以将 &lt;code&gt;io&lt;/code&gt; 模块中的Erlang扫描仪用作起点。研究 &lt;code&gt;yeccscan.erl&lt;/code&gt; ，以了解如何在 &lt;code&gt;io:scan_erl_form/3&lt;/code&gt; 之上添加过滤器，以提供一个Yecc扫描程序，该扫描程序在使用Yecc解析器解析语法文件之前对语法文件进行标记化。扫描仪实施的一种更通用的方法是使用扫描仪生成器。正在开发Erlang中称为 &lt;code&gt;leex&lt;/code&gt; 的扫描仪生成器。</target>
        </trans-unit>
        <trans-unit id="37265f6197faced222d42e8a4148f58e5b966cea" translate="yes" xml:space="preserve">
          <source>The Erlang server interface is implemented by module &lt;code&gt;mod_esi&lt;/code&gt;.</source>
          <target state="translated">Erlang服务器接口由模块 &lt;code&gt;mod_esi&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="fa8c45ba50425e13e797fcc4854bc1fcf3424403" translate="yes" xml:space="preserve">
          <source>The Erlang shell available over SSH</source>
          <target state="translated">通过SSH提供的Erlang shell</target>
        </trans-unit>
        <trans-unit id="fa1d76065068bd2589fcd099c8a0c8156db2a1c8" translate="yes" xml:space="preserve">
          <source>The Erlang shell understands the command &lt;code&gt;c(Module)&lt;/code&gt; which both compiles and loads &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">Erlang外壳程序可以理解命令 &lt;code&gt;c(Module)&lt;/code&gt; ，该命令可以编译并加载 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5dceee96a25b9a8c7bf615c2130bf76584510ce" translate="yes" xml:space="preserve">
          <source>The Erlang shell.</source>
          <target state="translated">Erlang shell。</target>
        </trans-unit>
        <trans-unit id="a51205151ea58d8438ebe29c7d0e6218f72ff948" translate="yes" xml:space="preserve">
          <source>The Erlang source code has support for the UTF-8 encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can control the encoding by a comment like the following in the beginning of the file:</source>
          <target state="translated">Erlang源代码支持UTF-8编码和字节编码。Erlang / OTP R16B中的默认设置是按字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码。在Erlang / OTP 17.0中将其更改为UTF-8。您可以通过文件开头中的以下注释来控制编码：</target>
        </trans-unit>
        <trans-unit id="469909cd3bb80b2a08960dcf0954a2e053c206c4" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;code&gt;encoding&lt;/code&gt; is selected by a comment in one of the first two lines of the source file. The first string that matches the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is an invalid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">通过在源文件的前两行之一中的注释来选择Erlang源文件的 &lt;code&gt;encoding&lt;/code&gt; 。与正则表达式 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 匹配的第一个字符串选择编码。如果匹配的字符串是无效的编码，则将其忽略。有效的编码是 &lt;code&gt;Latin-1&lt;/code&gt; 和 &lt;code&gt;UTF-8&lt;/code&gt; ，其中字符的大小写可以自由选择。</target>
        </trans-unit>
        <trans-unit id="e7ddb53385af1f6753c8713a645cc1fc36907bac" translate="yes" xml:space="preserve">
          <source>The Erlang source file &lt;strong id=&quot;encoding&quot;&gt;encoding&lt;/strong&gt; is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are &lt;code&gt;Latin-1&lt;/code&gt; and &lt;code&gt;UTF-8&lt;/code&gt;, where the case of the characters can be chosen freely.</source>
          <target state="translated">通过在源文件的前两行之一中的注释来选择Erlang源文件的&lt;strong id=&quot;encoding&quot;&gt;编码&lt;/strong&gt;。与正则表达式 &lt;code&gt;coding\s*[:=]\s*([-a-zA-Z0-9])+&lt;/code&gt; 匹配的第一个字符串选择编码。如果匹配的字符串不是有效的编码，则将其忽略。有效的编码是 &lt;code&gt;Latin-1&lt;/code&gt; 和 &lt;code&gt;UTF-8&lt;/code&gt; ，其中字符的大小写可以自由选择。</target>
        </trans-unit>
        <trans-unit id="978c7190f27ebbf14f966c1feadf6f5410de9629" translate="yes" xml:space="preserve">
          <source>The Erlang system must be started.</source>
          <target state="translated">必须启动Erlang系统。</target>
        </trans-unit>
        <trans-unit id="c9941ae0e376a140dd219d96c5fea5aedb3770d4" translate="yes" xml:space="preserve">
          <source>The Erlang token scanner.</source>
          <target state="translated">Erlang令牌扫描器。</target>
        </trans-unit>
        <trans-unit id="a16c12a6b02ac800a11334f62d3a994378ac0165" translate="yes" xml:space="preserve">
          <source>The Erlang web server API data types are as follows:</source>
          <target state="translated">Erlang网络服务器API数据类型如下。</target>
        </trans-unit>
        <trans-unit id="682db584bdb9aa3dd1062d8f6e41de11a4e999fd" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH application is intended to be used in other applications as a library.</source>
          <target state="translated">Erlang/OTP SSH应用程序旨在作为一个库在其他应用程序中使用。</target>
        </trans-unit>
        <trans-unit id="834fb47d95be27590d99f014c1a5220c8d723132" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server after a succesful authentication</source>
          <target state="translated">认证成功后的Erlang/OTP SSH服务器。</target>
        </trans-unit>
        <trans-unit id="1ce8792731cffaac51f7760932b74501269d8966" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP SSH server checks the user name and password in the following order:</source>
          <target state="translated">Erlang/OTP SSH服务器按照以下顺序检查用户名和密码。</target>
        </trans-unit>
        <trans-unit id="65d28c591e7208c326a531484ecbb2f3de4814d0" translate="yes" xml:space="preserve">
          <source>The Evaluator area, where you can evaluate functions within the context of the debugged process, if that process execution is stopped.</source>
          <target state="translated">Evaluator区域,在这里你可以在调试进程的上下文中评估函数,如果该进程执行被停止的话。</target>
        </trans-unit>
        <trans-unit id="b8f527b2c601f16975ba4c3206247d354cc52722" translate="yes" xml:space="preserve">
          <source>The FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP客户端始终尝试使用被动FTP模式，并且只有在失败时才诉诸主动FTP模式。可以通过启动选项 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 更改此默认行为。</target>
        </trans-unit>
        <trans-unit id="46eb4343e573b38e361697e41777d053a18c2fba" translate="yes" xml:space="preserve">
          <source>The FTP client can be started and stopped dynamically in runtime by calling the &lt;code&gt;ftp&lt;/code&gt; application API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; and &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;ftp&lt;/code&gt; 应用程序API &lt;code&gt;ftp:start_service(ServiceConfig)&lt;/code&gt; 和 &lt;code&gt;ftp:stop_service(Pid)&lt;/code&gt; 可以在运行时动态启动和停止FTP客户端。</target>
        </trans-unit>
        <trans-unit id="0ff37cf016753285c00cfe38b14f6b9064cd0bb5" translate="yes" xml:space="preserve">
          <source>The Flex scanner is a Megaco scanner written as a linked in driver (in C). There are two ways to get this working:</source>
          <target state="translated">Flex扫描器是Megaco的扫描器,是以C语言编写的链接驱动。有两种方法可以让这个工作。</target>
        </trans-unit>
        <trans-unit id="8bd0f2f59d01566729720bb338392aa95bc03bec" translate="yes" xml:space="preserve">
          <source>The Fragment ID is used to number the fragments in a sequence. The id starts at the total number of fragments and then decrements to 1 (which is the final fragment). So if a sequence consists of 3 fragments the fragment id in the starting header will be 3, and then fragments 2 and 1 are sent.</source>
          <target state="translated">片段ID用于对序列中的片段进行编号,ID从片段总数开始,然后递减到1(即最后的片段)。该ID从片段总数开始,然后递减到1(这是最后的片段)。因此,如果一个序列由3个片段组成,则起始头中的片段ID将是3,然后发送片段2和1。</target>
        </trans-unit>
        <trans-unit id="b6270c4ff6807ee1959a0d7d8287c7ee55db3319" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-2&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun也可以作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#activity-2&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; ，该函数允许使用自定义的活动访问回调模块。可以通过将模块名称作为参数直接获得，也可以通过使用配置参数 &lt;code&gt;access_module&lt;/code&gt; 隐式获得。定制的回调模块可以用于多种目的，例如提供触发器，完整性约束，运行时统计信息或虚拟表。</target>
        </trans-unit>
        <trans-unit id="0817c2658a9f234929df429f0abce5aa05ce329d" translate="yes" xml:space="preserve">
          <source>The Fun can also be passed as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt;, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter &lt;code&gt;access_module&lt;/code&gt;. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</source>
          <target state="translated">Fun也可以作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/2,3,4&lt;/a&gt;&lt;/code&gt; ，该函数允许使用自定义的活动访问回调模块。可以通过将模块名称作为参数直接获得，也可以通过使用配置参数 &lt;code&gt;access_module&lt;/code&gt; 隐式获得。定制的回调模块可以用于多种目的，例如提供触发器，完整性约束，运行时统计信息或虚拟表。</target>
        </trans-unit>
        <trans-unit id="279188337fe7d9611837624292436a6f0c6df988" translate="yes" xml:space="preserve">
          <source>The GC_REGEXP definition</source>
          <target state="translated">GC_REGEXP定义</target>
        </trans-unit>
        <trans-unit id="491576369b07d94c026adb9d94add3cd468dc1c6" translate="yes" xml:space="preserve">
          <source>The GUI main window is opened when Crashdump Viewer has loaded a crashdump. It contains a title bar, a menu bar, information tabs, and a status bar.</source>
          <target state="translated">当Crashdump Viewer加载了一个crashdump后,GUI主窗口就会打开。它包含一个标题栏,一个菜单栏,信息标签和一个状态栏。</target>
        </trans-unit>
        <trans-unit id="468c9cc0468cc5c92ee919e07070c915b671da34" translate="yes" xml:space="preserve">
          <source>The GetNext Operation operation should only be defined for tables since the agent can find the next instance of plain variables in the MIB and call the instrumentation with the &lt;code&gt;get&lt;/code&gt; operation.</source>
          <target state="translated">仅应为表定义GetNext Operation操作，因为代理可以在MIB中找到下一个纯变量实例，并使用 &lt;code&gt;get&lt;/code&gt; 操作调用检测。</target>
        </trans-unit>
        <trans-unit id="ca4179f6bcde085d4b0d34f9240821a74141f758" translate="yes" xml:space="preserve">
          <source>The Gregorian calendar in this module is extended back to year 0. For a given date, the &lt;strong&gt;gregorian days&lt;/strong&gt; is the number of days up to and including the date specified. Similarly, the &lt;strong&gt;gregorian seconds&lt;/strong&gt; for a specified date and time is the number of seconds up to and including the specified date and time.</source>
          <target state="translated">该模块中的公历将追溯到&lt;strong&gt;0年。&lt;/strong&gt;对于给定的日期，公历&lt;strong&gt;天数&lt;/strong&gt;是指指定日期之前（包括该日期）的天数。同样，指定日期和时间的&lt;strong&gt;公历秒数&lt;/strong&gt;是直至并包括指定日期和时间的秒数。</target>
        </trans-unit>
        <trans-unit id="6a32364a7c7faf5d1cbacad811c6e3a642e6422e" translate="yes" xml:space="preserve">
          <source>The HTML overview log file is updated with test results.</source>
          <target state="translated">HTML概览日志文件会随着测试结果更新。</target>
        </trans-unit>
        <trans-unit id="7141eac40a2b0f12431f108b64d289e030f4933d" translate="yes" xml:space="preserve">
          <source>The HTML tags allowed in &lt;code&gt;application/erlang+html&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;application/erlang+html&lt;/code&gt; 中允许的HTML标记。</target>
        </trans-unit>
        <trans-unit id="aab4263cb8d1f32842025f35d2e34059d6bef33e" translate="yes" xml:space="preserve">
          <source>The HTML version of the test suite source code is not generated during the test run (and is consequently not available in the log file system).</source>
          <target state="translated">测试套件源代码的HTML版本在测试运行过程中不会生成(因此在日志文件系统中也不会有)。</target>
        </trans-unit>
        <trans-unit id="e41fc71ae08f56427cd0499723a4d95a81e54bc2" translate="yes" xml:space="preserve">
          <source>The HTTP client and server are HTTP 1.1 compliant as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP客户端和服务器符合 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 中定义的HTTP 1.1 。</target>
        </trans-unit>
        <trans-unit id="0a3e013cebd4679eacc44ce278db16ae997e7553" translate="yes" xml:space="preserve">
          <source>The HTTP client default profile is started when the &lt;code&gt;Inets&lt;/code&gt; application is started and is then available to all processes on that Erlang node. Other profiles can also be started at application startup, or profiles can be started and stopped dynamically in runtime. Each client profile spawns a new process to handle each request, unless a persistent connection can be used with or without pipelining. The client adds a &lt;code&gt;host&lt;/code&gt; header and an empty &lt;code&gt;te&lt;/code&gt; header if there are no such headers present in the request.</source>
          <target state="translated">HTTP客户端默认配置文件在启动 &lt;code&gt;Inets&lt;/code&gt; 应用程序时启动，然后可用于该Erlang节点上的所有进程。也可以在应用程序启动时启动其他配置文件，或者可以在运行时动态启动和停止配置文件。每个客户端配置文件都会产生一个新的过程来处理每个请求，除非可以在有或没有流水线的情况下使用持久连接。如果请求中不存在 &lt;code&gt;host&lt;/code&gt; 头，则客户端添加一个主机头和一个空的 &lt;code&gt;te&lt;/code&gt; 头。</target>
        </trans-unit>
        <trans-unit id="7c7ba7538b9c9c0121b49c6ec91168734deba0dc" translate="yes" xml:space="preserve">
          <source>The HTTP server, also referred to as httpd, handles HTTP requests as described in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; with a few exceptions, such as gateway and proxy functionality. The server supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">HTTP服务器（也称为httpd）按照 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 中的描述处理HTTP请求，但有一些例外，例如网关和代理功能。该服务器支持IPv6，只要基础机制也支持即可。</target>
        </trans-unit>
        <trans-unit id="ed5f93e75e8af313b179c6713c54eb1bf37d9eef" translate="yes" xml:space="preserve">
          <source>The HTTP standard requires them to be case insensitive. Use this feature only if there is no other way to communicate with the server or for testing purpose. When this option is used, no headers are automatically added. All necessary headers must be provided by the user.</source>
          <target state="translated">HTTP标准要求它们不区分大小写。只有在没有其他方式与服务器通信或出于测试目的时才使用此功能。当使用此选项时,不会自动添加头信息。所有必要的头信息必须由用户提供。</target>
        </trans-unit>
        <trans-unit id="f2d85de81f5fcc8588a618440bb02e8ae50bca16" translate="yes" xml:space="preserve">
          <source>The HTTP status code returned to the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">HTTP状态代码返回给客户端（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa0035abf3b99831613dc762c61fbb26c4588f4e" translate="yes" xml:space="preserve">
          <source>The Handshake in Detail</source>
          <target state="translated">握手的细节</target>
        </trans-unit>
        <trans-unit id="1b82e39a63325ee5467a0018be1f905eeb2f7c52" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described earlier. A packet is either a request, a response, a header, or an end of header mark. Invalid lines are returned as &lt;code&gt;HttpError&lt;/code&gt;.</source>
          <target state="translated">超文本传输​​协议。数据包以 &lt;code&gt;HttpPacket&lt;/code&gt; 描述的HttpPacket格式返回。数据包可以是请求，响应，标头或标头标记的结尾。无效的行作为 &lt;code&gt;HttpError&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="3946370c047884fbf4c2f18670e43abd4a1961c1" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt; erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">超文本传输​​协议。按照ERTS的 &lt;code&gt; erlang:decode_packet/3&lt;/code&gt; 中描述的 &lt;code&gt;HttpPacket&lt;/code&gt; 格式返回数据包。被动模式下的套接字从 &lt;code&gt;gen_tcp:recv&lt;/code&gt; 返回 &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; ，而主动套接字发送诸如 &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="169734960811a4c34c5ce86c1d456ff7cf230d3e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol. The packets are returned with the format according to &lt;code&gt;HttpPacket&lt;/code&gt; described in &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; in ERTS. A socket in passive mode returns &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; from &lt;code&gt;gen_tcp:recv&lt;/code&gt; while an active socket sends messages like &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt;.</source>
          <target state="translated">超文本传输​​协议。按照ERTS的 &lt;code&gt;erlang:decode_packet/3&lt;/code&gt; 中描述的 &lt;code&gt;HttpPacket&lt;/code&gt; 格式返回数据包。处于被动模式的套接字从 &lt;code&gt;gen_tcp:recv&lt;/code&gt; 返回 &lt;code&gt;{ok, HttpPacket}&lt;/code&gt; ，而处于活动状态的套接字发送诸如 &lt;code&gt;{http, Socket, HttpPacket}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fdd97c77238f0d4bc1a4b8495b731166db58155" translate="yes" xml:space="preserve">
          <source>The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to &lt;code&gt;latin1&lt;/code&gt; encoding, meaning that any characters &amp;gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system).</source>
          <target state="translated">默认情况下，以&amp;ldquo; -oldshell&amp;rdquo;或&amp;ldquo; -noshell&amp;rdquo;标志启动Erlang时使用的I / O设备设置为 &lt;code&gt;latin1&lt;/code&gt; 编码，这意味着将转义任何&amp;gt; codepoint 255的字符，并且输入应为纯8位ISO Latin-1。如果将编码更改为Unicode，则标准文件描述符的输入和输出使用UTF-8（与操作系统无关）。</target>
        </trans-unit>
        <trans-unit id="3a9ee44bfdadb9768492101f1c57f8171e2439fd" translate="yes" xml:space="preserve">
          <source>The I/O protocol in Erlang enables bi-directional communication between clients and servers.</source>
          <target state="translated">Erlang中的I/O协议可以实现客户端和服务器之间的双向通信。</target>
        </trans-unit>
        <trans-unit id="da4b71eee53848cfe7e0ded6f806a23b361aa596" translate="yes" xml:space="preserve">
          <source>The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:</source>
          <target state="translated">I/O服务器对于请求列表,可以根据列表中的请求,在回复中发送以下任何一个有效结果。</target>
        </trans-unit>
        <trans-unit id="7bf03aa38e2e7b2e9d865676ed62c6ed1b166de9" translate="yes" xml:space="preserve">
          <source>The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device.</source>
          <target state="translated">I/O服务器是一个处理请求并在I/O设备等上执行请求任务的进程。</target>
        </trans-unit>
        <trans-unit id="29324f42eeb70cb428190b9afb707250b51d08e0" translate="yes" xml:space="preserve">
          <source>The I/O server is to send one of the following as &lt;code&gt;Reply&lt;/code&gt;:</source>
          <target state="translated">I / O服务器将发送以下内容之一作为 &lt;code&gt;Reply&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cffff6188b7c071be58063158f15f52414545611" translate="yes" xml:space="preserve">
          <source>The I/O server is to send the &lt;code&gt;Reply&lt;/code&gt; as:</source>
          <target state="translated">I / O服务器将 &lt;code&gt;Reply&lt;/code&gt; 发送为：</target>
        </trans-unit>
        <trans-unit id="a68a34b093217c6e79f51f56360324a76a6607db" translate="yes" xml:space="preserve">
          <source>The I/O server replies to the client with an &lt;code&gt;io_reply&lt;/code&gt; tuple, where element &lt;code&gt;Reply&lt;/code&gt; is one of:</source>
          <target state="translated">I / O服务器使用 &lt;code&gt;io_reply&lt;/code&gt; 元组回复客户端，其中元素 &lt;code&gt;Reply&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="d6984e80e5ec40501eed04b79f0e90cd3e1a039b" translate="yes" xml:space="preserve">
          <source>The I/O server replies:</source>
          <target state="translated">I/O服务器回复。</target>
        </trans-unit>
        <trans-unit id="615c499b56501d6b2d674044444c5cd252a3aa4d" translate="yes" xml:space="preserve">
          <source>The I/O vector used by the emulator and drivers is a list of binaries, with a &lt;code&gt;SysIOVec&lt;/code&gt; pointing to the buffers of the binaries. It is used in &lt;code&gt;driver_outputv&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; driver callback. Also, the driver queue is an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">仿真器和驱动程序使用的I / O向量是二进制文件列表，其中 &lt;code&gt;SysIOVec&lt;/code&gt; 指向二进制文件的缓冲区。它在 &lt;code&gt;driver_outputv&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 驱动程序回调中使用。同样，驱动程序队列是 &lt;code&gt;ErlIOVec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11486f73702f77793d0c501dded54bd9d9a0b366" translate="yes" xml:space="preserve">
          <source>The ID of the handler (which is &lt;code&gt;false&lt;/code&gt; if it was registered without an ID).</source>
          <target state="translated">处理程序的ID（如果注册时没有ID ，则为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5910e0f627e6ac1682f658faee394e4ef0132c80" translate="yes" xml:space="preserve">
          <source>The IDs contains normal fully qualified domain names like e.g &lt;code&gt;foo.example.com&lt;/code&gt;, but IP addresses are not recommended. The rfc describes why this is not recommended as well as security considerations about how to aquire the Reference IDs.</source>
          <target state="translated">这些ID包含标准的标准域名，例如 &lt;code&gt;foo.example.com&lt;/code&gt; ，但不建议使用IP地址。RFC描述了为什么不建议这样做以及有关如何获取参考ID的安全性注意事项。</target>
        </trans-unit>
        <trans-unit id="ba43ecb0debcc2f97c4e2d5e92d1fb358277b19c" translate="yes" xml:space="preserve">
          <source>The IF() macro</source>
          <target state="translated">IF()宏</target>
        </trans-unit>
        <trans-unit id="b28f4dac9c4ee5d63c861a672e8fdeba64970c63" translate="yes" xml:space="preserve">
          <source>The IP addresses must be specified in the standard form (four decimal numbers separated by periods, for example, &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt;. Hosts names are not acceptable, but a broadcast address (preferably limited to the local network) is.</source>
          <target state="translated">IP地址必须以标准格式指定（四个小数点之间用句点分隔，例如 &lt;code&gt;&quot;150.236.20.74&quot;&lt;/code&gt; 。主机名是不可接受的，但广播地址（最好限于本地网络）是可以的。</target>
        </trans-unit>
        <trans-unit id="8e52fe37494dbcf6555873254ea719776b067efd" translate="yes" xml:space="preserve">
          <source>The IP_ADJUSTMENT pre-bound variable</source>
          <target state="translated">IP_ADJUSTMENT预绑定变量。</target>
        </trans-unit>
        <trans-unit id="74be3487335549a3ba00af3a4220139041a986e4" translate="yes" xml:space="preserve">
          <source>The Inets services API.</source>
          <target state="translated">Inets服务API。</target>
        </trans-unit>
        <trans-unit id="2bd655ea5793b54cfcef1365f007ad296dab65da" translate="yes" xml:space="preserve">
          <source>The Interpret Modules window is used for selecting which modules to interpret. Initially, the window displays the modules (&lt;code&gt;erl&lt;/code&gt; files) and subdirectories of the current working directory.</source>
          <target state="translated">&amp;ldquo;解释模块&amp;rdquo;窗口用于选择要解释的模块。最初，该窗口显示当前工作目录的模块（ &lt;code&gt;erl&lt;/code&gt; 文件）和子目录。</target>
        </trans-unit>
        <trans-unit id="46568e5f2d41b68efc3d2efed445ca9d877dd874" translate="yes" xml:space="preserve">
          <source>The Kernel application has all the code necessary to run the Erlang runtime system: file servers, code servers, and so on.</source>
          <target state="translated">Kernel应用程序拥有运行Erlang运行时系统所需的所有代码:文件服务器、代码服务器等。</target>
        </trans-unit>
        <trans-unit id="1d2901750e4e178866aa29af00b9514d934b8cb3" translate="yes" xml:space="preserve">
          <source>The Kernel application is the first application started. It is mandatory in the sense that the minimal system based on Erlang/OTP consists of Kernel and STDLIB. Kernel contains the following functional areas:</source>
          <target state="translated">Kernel应用程序是第一个被启动的应用程序。它是强制性的,因为基于Erlang/OTP的最小系统由Kernel和STDLIB组成。Kernel包含以下功能区。</target>
        </trans-unit>
        <trans-unit id="393233a88750cf4fe6f8a18919929901cb57f040" translate="yes" xml:space="preserve">
          <source>The Kernel configuration parameter &lt;code&gt;global_groups&lt;/code&gt; defines the global groups (see also &lt;code&gt;kernel(6)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">内核配置参数 &lt;code&gt;global_groups&lt;/code&gt; 定义了全局组（另请参见 &lt;code&gt;kernel(6)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="329d0e8d9e7fbac7a43bba657580181c6f878afc" translate="yes" xml:space="preserve">
          <source>The Kernel/STDLIB applications are damaged or the start script is damaged.</source>
          <target state="translated">内核/STDLIB应用程序损坏或启动脚本损坏。</target>
        </trans-unit>
        <trans-unit id="ce538f925bf84002c38fbd4dc502029a22341ac9" translate="yes" xml:space="preserve">
          <source>The Leex module should be considered experimental as it will be subject to changes in future releases.</source>
          <target state="translated">Leex模块应该被认为是实验性的,因为它在未来的版本中可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="c848076de058785ede6b2e785124e2cf00899a54" translate="yes" xml:space="preserve">
          <source>The Linux Trace Toolkit: next generation is an open source system software package for correlated tracing of the Linux kernel, user applications and libraries.</source>
          <target state="translated">Linux Trace Toolkit:next generation是一个开源系统软件包,用于Linux内核、用户应用程序和库的相关跟踪。</target>
        </trans-unit>
        <trans-unit id="9b5f802a372a8d9f81e47da8ffe942e03e117399" translate="yes" xml:space="preserve">
          <source>The Logger backend forwards log events from the API, first through a set of &lt;strong&gt;primary filters&lt;/strong&gt;, then through a set of secondary filters attached to each log handler. The secondary filters are in the following named &lt;strong&gt;handler filters&lt;/strong&gt;.</source>
          <target state="translated">Logger后端首先通过一组&lt;strong&gt;主要过滤&lt;/strong&gt;器转发API中的日志事件，然后通过附加到每个日志处理程序的一组辅助过滤器转发日志事件。辅助过滤器位于以下命名的&lt;strong&gt;处理程序过滤器中&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="30f7d257c062cf1d99aadf05acae5dcdc7db0748" translate="yes" xml:space="preserve">
          <source>The Logger proxy is an Erlang process which is part of the Kernel application's supervision tree. During startup, the proxy process registers itself as the &lt;code&gt;system_logger&lt;/code&gt;, meaning that log events produced by the emulator are sent to this process.</source>
          <target state="translated">Logger代理是一个Erlang进程，它是内核应用程序监视树的一部分。在启动期间，代理进程 &lt;code&gt;system_logger&lt;/code&gt; 其自身注册为system_logger，这意味着将由仿真器生成的日志事件发送到此进程。</target>
        </trans-unit>
        <trans-unit id="709c2b894a55cf0a9eb1d8fa9b54a57e464ba3b7" translate="yes" xml:space="preserve">
          <source>The M-bit on a component AVP of a Grouped AVP that does not set M is ignored: such AVPs are not regarded as erroneous at decode.</source>
          <target state="translated">不设置M的分组AVP的分量AVP上的M位被忽略:这样的AVP在解码时不会被认为是错误的。</target>
        </trans-unit>
        <trans-unit id="b932f03ca4571cac226370cd6a0c3fc9c9dd133c" translate="yes" xml:space="preserve">
          <source>The MBC area is called &lt;strong&gt;sa&lt;/strong&gt; as in super aligned and the SBC area is called &lt;strong&gt;sua&lt;/strong&gt; as in super un-aligned.</source>
          <target state="translated">MBC区域在超级对齐方式中称为&lt;strong&gt;sa&lt;/strong&gt;，而SBC区域在超级对齐方式中称为&lt;strong&gt;sua&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6e65c3cb49c60d682bd3249d0c0dd54ec5a5739f" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm is &lt;strong&gt;not&lt;/strong&gt; considered safe for code-signing or software-integrity purposes.</source>
          <target state="translated">出于代码签名或软件完整性目的，MD5消息摘要算法&lt;strong&gt;不&lt;/strong&gt;被认为是安全的。</target>
        </trans-unit>
        <trans-unit id="f776c349863aa954c934ed6333465e82a978b325" translate="yes" xml:space="preserve">
          <source>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see &lt;code&gt;supervisor:start_child&lt;/code&gt; for an explanation of the parameters).</source>
          <target state="translated">MFA替代方案使Megaco可以启动和监督用户编写的扫描仪（有关参数的说明，请参见 &lt;code&gt;supervisor:start_child&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1def19a97ae2b0656b00af132fb7f372cb973f9f" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 and use a provisioned MID of the MGC as the RemoteMid.</source>
          <target state="translated">MG可以显式地调用megaco:connect/4,并使用MGC的供应MID作为RemoteMid。</target>
        </trans-unit>
        <trans-unit id="d9b9106067cc9059d7c61d3ebb7b2686b953f307" translate="yes" xml:space="preserve">
          <source>The MG may explicitly invoke megaco:connect/4 with the atom 'preliminary_mid' as a temporary MID of the MGC, send an intial message, the Service Change Request, to the MGC and then wait for an initial message, the Service Change Reply. When the reply arrives, the Megaco application will pick the MID of the MGC from the message header and automatically upgrade the connection to be a &quot;normal&quot; connection. By using this method of establishing the connection, the callback function UserMod:handle_connect/2 to be invoked twice. First with a ConnHandle with the remote_mid-field set to preliminary_mid, and then when the connection upgrade is done with the remote_mid-field set to the actual MID of the MGC.</source>
          <target state="translated">MG可以显式地调用megaco:connect/4,用原子 &quot;primary_mid &quot;作为MGC的临时MID,向MGC发送一个初始消息,即服务变更请求,然后等待一个初始消息,即服务变更回复。当回复到达时,Megaco应用程序将从消息头中选择MGC的MID,并自动将连接升级为 &quot;正常 &quot;连接。通过这种建立连接的方法,回调函数UserMod:handle_connect/2要被调用两次。首先用ConnHandle将remote_mid-field设置为preliminary_mid,然后当连接升级时,将remote_mid-field设置为MGC的实际MID。</target>
        </trans-unit>
        <trans-unit id="aea17cec43c433cc7d5df78c11e5155adf50c978" translate="yes" xml:space="preserve">
          <source>The MIB compiler can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.mib&lt;/code&gt;, and invokes the SNMP MIB compiler for files with that extension. The options &lt;code&gt;db&lt;/code&gt;, &lt;code&gt;group_check&lt;/code&gt;, &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;verbosity&lt;/code&gt;, &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;module_identity&lt;/code&gt; have to be specified to &lt;code&gt;erlc&lt;/code&gt; using the syntax &lt;code&gt;+term&lt;/code&gt;. See &lt;code&gt;erlc(1)&lt;/code&gt; for details.</source>
          <target state="translated">可以使用命令 &lt;code&gt;erlc&lt;/code&gt; 从OS命令行调用MIB编译器。 &lt;code&gt;erlc&lt;/code&gt; 识别扩展名 &lt;code&gt;.mib&lt;/code&gt; ，并对具有该扩展名的文件调用SNMP MIB编译器。必须使用 &lt;code&gt;+term&lt;/code&gt; 语法为 &lt;code&gt;erlc&lt;/code&gt; 指定选项 &lt;code&gt;db&lt;/code&gt; ， &lt;code&gt;group_check&lt;/code&gt; ， &lt;code&gt;deprecated&lt;/code&gt; ， &lt;code&gt;description&lt;/code&gt; ， &lt;code&gt;verbosity&lt;/code&gt; ， &lt;code&gt;imports&lt;/code&gt; 和 &lt;code&gt;module_identity&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;erlc(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4f52d6224012981f65b2f6681c14c8ab8b0bbf8" translate="yes" xml:space="preserve">
          <source>The MIB compiler is started with a call to &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; For example:</source>
          <target state="translated">MIB编译器以对 &lt;code&gt;snmpc:compile(&amp;lt;mibname&amp;gt;).&lt;/code&gt; 的调用开始。例如：</target>
        </trans-unit>
        <trans-unit id="edd06159b7a6aba946136da4c7e4c2496fb5f976" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; statement to determine if the MIB is version 1 or 2.</source>
          <target state="translated">MIB编译器理解SMIv1和SMIv2 MIB。它使用 &lt;code&gt;MODULE-IDENTITY&lt;/code&gt; 语句确定MIB是版本1还是版本2。</target>
        </trans-unit>
        <trans-unit id="f45016e5e003d17ae323b899458860dc734f4ec3" translate="yes" xml:space="preserve">
          <source>The MIB compiler understands both SMIv1 and SMIv2 MIBs. It uses the MODULE-IDENTITY statement to determinate if the MIB is written in SMI version 1 or 2.</source>
          <target state="translated">MIB编译器可以理解SMIv1和SMIv2 MIB。它使用MODULE-IDENTITY语句来确定MIB是用SMI版本1还是2编写的。</target>
        </trans-unit>
        <trans-unit id="cd9d36a4d02e1cba5060187b622d24d58daaa77e" translate="yes" xml:space="preserve">
          <source>The MIB definition for the table looks as follows:</source>
          <target state="translated">该表的MIB定义如下。</target>
        </trans-unit>
        <trans-unit id="3670a31f68beb5c49cf1fc0895f0360e583892d6" translate="yes" xml:space="preserve">
          <source>The MIB is specified in an adapted subset of the Abstract Syntax Notation One (ASN.1) language. This adapted subset is called the Structure of Management Information (SMI).</source>
          <target state="translated">MIB用抽象语法符号一(ASN.1)语言的一个改编子集来指定。这个改编后的子集称为管理信息结构(SMI)。</target>
        </trans-unit>
        <trans-unit id="ddf38993bb21f6943082354919313abcba92be9e" translate="yes" xml:space="preserve">
          <source>The MIB must be written as a text file in SMIv1 or SMIv2 using an ASN.1 notation before it will be compiled. This text file must have the same name as the MIB, but with the suffix &lt;code&gt;.mib&lt;/code&gt;. This is necessary for handling the &lt;code&gt;IMPORT&lt;/code&gt; statement.</source>
          <target state="translated">在编译MIB之前，必须使用ASN.1表示法将其作为文本文件写入SMIv1或SMIv2中。该文本文件的名称必须与MIB相同，但后缀为 &lt;code&gt;.mib&lt;/code&gt; 。这对于处理 &lt;code&gt;IMPORT&lt;/code&gt; 语句是必需的。</target>
        </trans-unit>
        <trans-unit id="28b5820bae2b823215328a884121f24cdebd6ac9" translate="yes" xml:space="preserve">
          <source>The MIB table shown in the previous section can be compiled as follows:</source>
          <target state="translated">上一节所示的MIB表可以编译如下。</target>
        </trans-unit>
        <trans-unit id="8ec9b6855efdcd50624fb2152240f9d6cfd37b82" translate="yes" xml:space="preserve">
          <source>The MIB used in this example is called EX1-MIB. It contains two objects, a variable with a name and a table with friends.</source>
          <target state="translated">本例中使用的MIB称为EX1-MIB。它包含两个对象,一个是有名字的变量,一个是有朋友的表。</target>
        </trans-unit>
        <trans-unit id="e2036f385fe7aec6b74107075c06d9fb946e725a" translate="yes" xml:space="preserve">
          <source>The Makefile rule generated by this option looks as follows:</source>
          <target state="translated">这个选项生成的Makefile规则如下。</target>
        </trans-unit>
        <trans-unit id="b70e5f8f89b4686cb29a4a908b91ac8e282aa8a9" translate="yes" xml:space="preserve">
          <source>The Manager sends a request to the Agent.</source>
          <target state="translated">经理向代理发送请求。</target>
        </trans-unit>
        <trans-unit id="46da3a78459a2791fe81dd4c8585eaa2e4cc0ded" translate="yes" xml:space="preserve">
          <source>The Master Agent decodes the incoming UDP packet.</source>
          <target state="translated">主代理对传入的UDP数据包进行解码。</target>
        </trans-unit>
        <trans-unit id="373ff796c178ffe0a9fc192a5614c9c2aa28127a" translate="yes" xml:space="preserve">
          <source>The Master Agent determines which items in the request that should be processed here and which items should be forwarded to its subagent.</source>
          <target state="translated">主代理决定请求中哪些项目应该在这里处理,哪些项目应该转发给它的子代理。</target>
        </trans-unit>
        <trans-unit id="efae611f18882de954fb6f64727d8f6c45904beb" translate="yes" xml:space="preserve">
          <source>The Megaco client (user) starts the flex scanner (load the driver).</source>
          <target state="translated">Megaco客户端(用户)启动柔性扫描仪(加载驱动程序)。</target>
        </trans-unit>
        <trans-unit id="74b78735e0be983743300743d7f123f781d14b1d" translate="yes" xml:space="preserve">
          <source>The Megaco mib is as of yet not standardized and our implementation is based on &lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;. Almost all of the mib cannot easily be implemented by the megaco application. Instead these things should be implemented by a user (of the megaco application).</source>
          <target state="translated">Megaco mib尚未标准化，我们的实现基于&lt;strong&gt;draft-ietf-megaco-mib-04.txt&lt;/strong&gt;。megaco应用程序无法轻松实现几乎所有mib。相反，这些事情应该由megaco应用程序的用户实现。</target>
        </trans-unit>
        <trans-unit id="69ce7f3a78e528729b8eeea0590643ad39f48cc1" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 application contains implementations for the two protocols specified by the Megaco/H.248 standard; UDP, see &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;, and TCP/TPKT, see &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Megaco / H.248应用程序包含针对Megaco / H.248标准指定的两个协议的实现。UDP，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_udp&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; ，而TCP / TPKT，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_tcp&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aad987e822802dc01bf9dc22e5bb8ea6068aa667" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do in fact supply five different encoding/decoding modules.</source>
          <target state="translated">Megaco/H.248标准定义了纯文本编码和二进制编码(ASN.1 BER),我们已经实现了这两种编码和解码器。事实上,我们确实提供了五个不同的编码/解码模块。</target>
        </trans-unit>
        <trans-unit id="aa06303bf449e60941f0fbd6f5db8a0257dfe140" translate="yes" xml:space="preserve">
          <source>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</source>
          <target state="translated">Megaco/H.248标准定义了纯文本编码和二进制编码(ASN.1 BER),我们已经实现了两者的编码器和解码器。我们确实提供了一系列不同的编码/解码模块,事实上用户可以实现自己的模块(比如我们的 erl_dist 模块)。使用非标准的编码格式有其明显的缺点,但在某些配置中可能是有用的。</target>
        </trans-unit>
        <trans-unit id="4e6da9c94911e5ddf6ca86f3b535349fffeec5ca" translate="yes" xml:space="preserve">
          <source>The Metadata field exists to allow languages, tools and libraries to add custom information to each entry. This EEP documents the following metadata keys:</source>
          <target state="translated">元数据字段的存在是为了允许语言、工具和库为每个条目添加自定义信息。本EEP记录了以下元数据键。</target>
        </trans-unit>
        <trans-unit id="1180df526f481dbe5f0436fa1406c56c4711af67" translate="yes" xml:space="preserve">
          <source>The Mnesia DBMS can be used for storing data of SNMP tables. This means that an SNMP table can be implemented as a Mnesia table, and that a Mnesia table can be made visible via SNMP. This mapping is largely automated.</source>
          <target state="translated">Mnesia DBMS可用于存储SNMP表的数据。这意味着一个SNMP表可以作为一个Mnesia表来实现,而且一个Mnesia表可以通过SNMP来显示。这种映射主要是自动化的。</target>
        </trans-unit>
        <trans-unit id="a591b496e3da82473b635cc4b898494993b158a0" translate="yes" xml:space="preserve">
          <source>The Mnesia algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</source>
          <target state="translated">Mnesia的表加载算法可能导致无法加载表的情况。这种情况发生在一个节点启动后,Mnesia得出结论,或怀疑表的另一个副本在这个本地副本因系统崩溃而不活动后处于活动状态。</target>
        </trans-unit>
        <trans-unit id="5e84c0c6719410c924b39a7531b144a0635ce33f" translate="yes" xml:space="preserve">
          <source>The Mnesia application provides a heavy duty real-time distributed database.</source>
          <target state="translated">Mnesia应用程序提供了一个重型实时分布式数据库。</target>
        </trans-unit>
        <trans-unit id="4e31cb2dccdf565dc1ca8c735031043aeea8bc8e" translate="yes" xml:space="preserve">
          <source>The Mnesia directory is to be set to &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Mnesia目录被设置为 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87981337ff090edb8a09d20ade88cd56c81fc2fc" translate="yes" xml:space="preserve">
          <source>The Mnesia tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</source>
          <target state="translated">Mnesia表可以在不使用事务的情况下进行操作。这样做有一些严重的缺点,但速度要快得多,因为没有事务管理器的参与,也没有设置锁。不过,dirty操作确实可以保证一定的一致性,而且dirty操作不能返回乱码记录。所有的dirty操作都为程序员提供了位置透明性,程序不需要知道某个表的下落就可以发挥作用。</target>
        </trans-unit>
        <trans-unit id="12555ca4fb4e5c73fcfb7a6b579630e086477989" translate="yes" xml:space="preserve">
          <source>The Module, Function and/or Arity parts of the tuple may be specified as the atom &lt;code&gt;'_'&lt;/code&gt; which is a &quot;wild-card&quot; matching all modules/functions/arities. Note, if the Module is specified as &lt;code&gt;'_'&lt;/code&gt;, the Function and Arity parts have to be specified as '_' too. The same holds for the Functions relation to the Arity.</source>
          <target state="translated">元组的模块，功能和/或Arity部分可以指定为原子 &lt;code&gt;'_'&lt;/code&gt; ，这是匹配所有模块/功能/ arities的&amp;ldquo;通配符&amp;rdquo;。注意，如果模块指定为 &lt;code&gt;'_'&lt;/code&gt; ，则功能和Arity部分也必须指定为&amp;ldquo; _&amp;rdquo;。与Arity的Function关系也是如此。</target>
        </trans-unit>
        <trans-unit id="f0af3d5917bbe134a6abcdbbf9104dc4ecd4c736" translate="yes" xml:space="preserve">
          <source>The Monitor window is the main window of Debugger and displays the following:</source>
          <target state="translated">监控窗口是Debugger的主窗口,显示如下内容。</target>
        </trans-unit>
        <trans-unit id="70b4cea5e362ae717c1192bf6736623910297884" translate="yes" xml:space="preserve">
          <source>The NETCONF client is also compliant with RFC 5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the NETCONF protocol.</source>
          <target state="translated">NETCONF客户端也符合RFC 5277 NETCONF事件通知,它为NETCONF协议定义了一种异步消息通知传递服务的机制。</target>
        </trans-unit>
        <trans-unit id="99b3461576af86b2830e124486fcb6fbe5704dd5" translate="yes" xml:space="preserve">
          <source>The NETCONF client is compliant with RFC 4741 NETCONF Configuration Protocol and RFC 4742 Using the NETCONF Configuration Protocol over Secure SHell (SSH).</source>
          <target state="translated">NETCONF客户端符合RFC 4741 NETCONF配置协议和RFC 4742通过安全SHell(SSH)使用NETCONF配置协议。</target>
        </trans-unit>
        <trans-unit id="ddf8604513f6b03eececb0b12edf6062d8892eb4" translate="yes" xml:space="preserve">
          <source>The NETCONF server uses &lt;code&gt;error_logger&lt;/code&gt; for logging of NETCONF traffic. A special purpose error handler is implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;. To use this error handler, add the &lt;code&gt;cth_conn_log&lt;/code&gt; hook in the test suite, for example:</source>
          <target state="translated">NETCONF服务器使用 &lt;code&gt;error_logger&lt;/code&gt; 记录NETCONF流量。特殊目的错误处理程序在 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 中实现。要使用此错误处理程序，请在测试套件中添加 &lt;code&gt;cth_conn_log&lt;/code&gt; 挂钩，例如：</target>
        </trans-unit>
        <trans-unit id="c4e761f6142db929d9abebfe00caf12e6df69e08" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION is a pre-bound variable that is available in all instructions. It expands to the address of the next instruction.</source>
          <target state="translated">NEXT_INSTRUCTION是一个预先绑定的变量,在所有指令中都可以使用。它扩展到下一条指令的地址。</target>
        </trans-unit>
        <trans-unit id="0ee36acc539fb496464c93f96bb31d20de406968" translate="yes" xml:space="preserve">
          <source>The NEXT_INSTRUCTION pre-bound variable</source>
          <target state="translated">NEXT_INSTRUCTION预绑定变量。</target>
        </trans-unit>
        <trans-unit id="2d107278e1a70d51b4fdd7f40141f0fe34ee6756" translate="yes" xml:space="preserve">
          <source>The NIF library must be explicitly loaded by Erlang code in the same module.</source>
          <target state="translated">NIF库必须由同一模块中的Erlang代码显式加载。</target>
        </trans-unit>
        <trans-unit id="41a4ad2b0dc5ffd6f13eaa47aa861d15ed3c8d0c" translate="yes" xml:space="preserve">
          <source>The NIFs of the module are compiled and linked into a shared library. Each NIF is implemented as a normal C function. The macro &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; together with an array of structures defines the names, arity, and function pointers of all the NIFs in the module. The header file &lt;code&gt;erl_nif.h&lt;/code&gt; must be included. As the library is a shared module, not a program, no main function is to be present.</source>
          <target state="translated">模块的NIF被编译并链接到共享库中。每个NIF被实现为普通的C函数。宏 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 以及结构数组定义了模块中所有NIF的名称，含义和函数指针。必须包含头文件 &lt;code&gt;erl_nif.h&lt;/code&gt; 。由于该库是共享模块，而不是程序，因此没有主要功能。</target>
        </trans-unit>
        <trans-unit id="999daf79065332e5e6572460b7e99eb5b72cdc5f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">网络接口(Net If)进程向主代理发送SNMP PDU,并从主代理接收SNMP PDU。Net if进程最常见的行为是接收来自网络的字节,将其解码为SNMP PDU,然后发送给主代理。当主代理处理完PDU后,它向Net if进程发送一个响应PDU,Net if进程将PDU编码成字节,并将字节传送到网络上。</target>
        </trans-unit>
        <trans-unit id="36f70502604dd2333d650c0bc04a8729a4f497af" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net If) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">网络接口(Net If)进程向管理器服务器发送SNMP PDU,并从管理器服务器接收SNMP PDU。Net if进程最常见的行为是接收来自管理器服务器的请求PDU,将PDU编码成字节,并将字节传送到网络上给代理。当Net if进程收到代理的回复后,将其解码为SNMP PDU,并发送给管理器服务器。</target>
        </trans-unit>
        <trans-unit id="fd402b6f90d216badbbd85762e2a8ddff6c71c0f" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to a master agent, and receives SNMP PDUs from the master agent. The most common behaviour of a Net if process is that is receives bytes from a network, decodes them into an SNMP PDU, which it sends to a master agent. When the master agent has processed the PDU, it sends a response PDU to the Net if process, which encodes the PDU into bytes and transmits the bytes onto the network.</source>
          <target state="translated">网络接口(Net if)进程向主代理发送SNMP PDU,并从主代理接收SNMP PDU。Net if进程最常见的行为是接收来自网络的字节,将其解码为SNMP PDU,然后发送给主代理。当主代理处理完PDU后,它向Net if进程发送一个响应PDU,Net if进程将PDU编码成字节,并将字节传送到网络上。</target>
        </trans-unit>
        <trans-unit id="976e6c5625eb166a7240dd083a2239c03ac8b8ec" translate="yes" xml:space="preserve">
          <source>The Network Interface (Net if) process delivers SNMP PDUs to the manager server, and receives SNMP PDUs from the manager server. The most common behaviour of a Net if process is that is receives request PDU from the manager server, encodes the PDU into bytes and transmits the bytes onto the network to an agent. When the reply from the agent is received by the Net if process, which it decodes into an SNMP PDU, which it sends to the manager server.</source>
          <target state="translated">网络接口(Net if)进程向管理器服务器发送SNMP PDU,并从管理器服务器接收SNMP PDU。Net if 进程最常见的行为是接收来自管理器服务器的请求 PDU,将 PDU 编码成字节,并将字节传送到网络上给代理。当Net if进程收到代理的回复后,将其解码为SNMP PDU,并发送给管理器服务器。</target>
        </trans-unit>
        <trans-unit id="e3ad1933c4b353741e7d3dd411a4625d945e51b1" translate="yes" xml:space="preserve">
          <source>The OAM components, and some other OTP applications, define SNMP MIBs. These MIBs are written in SNMPv2 SMI syntax, as defined in RFC 1902. For convenience we also deliver the SNMPv1 SMI equivalent. All MIBs are designed to be v1/v2 compatible, that is, the v2 MIBs do not use any construct not available in v1.</source>
          <target state="translated">OAM组件和其他一些OTP应用定义了SNMP MIB。这些MIB是用RFC 1902中定义的SNMPv2 SMI语法编写的。为了方便起见,我们也提供了SNMPv1的SMI等价物。所有的MIB都被设计成与v1/v2兼容,也就是说,v2 MIB不使用任何v1中没有的结构。</target>
        </trans-unit>
        <trans-unit id="6a0dd4d53e9a9b356b53c2117149daa068221b0f" translate="yes" xml:space="preserve">
          <source>The OPERAND_POSITION() macro</source>
          <target state="translated">OPERAND_POSITION()宏。</target>
        </trans-unit>
        <trans-unit id="dfa71a1f0f4b6ee0f7da7bee6b28148c4530dbc7" translate="yes" xml:space="preserve">
          <source>The OS failed to load the NIF library.</source>
          <target state="translated">操作系统未能加载NIF库。</target>
        </trans-unit>
        <trans-unit id="0c8abadcc360635740ed383e0bd4f397be705277" translate="yes" xml:space="preserve">
          <source>The OTP SSH app can be configurated by a large amount of</source>
          <target state="translated">OTP SSH应用可以通过大量的配置。</target>
        </trans-unit>
        <trans-unit id="6c43c2d0328ac7bd67f0bc31e296a2b1639ba6e7" translate="yes" xml:space="preserve">
          <source>The OTP mibs are stored in the &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; directory. They are defined in SNMPv2 SMI syntax. An SNMPv1 version of the mib is delivered in the &lt;code&gt;mibs/v1&lt;/code&gt; directory. The compiled MIB is located under &lt;code&gt;priv/mibs&lt;/code&gt;, and the generated &lt;code&gt;.hrl&lt;/code&gt; file under the &lt;code&gt;include&lt;/code&gt; directory. To compile a MIB that IMPORTS a MIB in the OTP_Mibs application, give the option &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; to the MIB compiler.</source>
          <target state="translated">OTP &lt;code&gt;$OTP_ROOT/lib/otp_mibs/mibs/&lt;/code&gt; 存储在$ OTP_ROOT / lib / otp_mibs / mibs /目录中。它们以SNMPv2 SMI语法定义。mib的SNMPv1版本在 &lt;code&gt;mibs/v1&lt;/code&gt; 目录中提供。编译的MIB位于 &lt;code&gt;priv/mibs&lt;/code&gt; 下，而生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件位于 &lt;code&gt;include&lt;/code&gt; 目录下。要编译在OTP_Mibs应用程序中 &lt;code&gt;{il, [&quot;otp_mibs/priv/mibs&quot;]}&lt;/code&gt; MIB的MIB，请为MIB编译器提供选项{il，[&amp;ldquo; otp_mibs / priv / mibs&amp;rdquo;]}。</target>
        </trans-unit>
        <trans-unit id="ef0289a2a348b65c119233c8ade03f223f5c8802" translate="yes" xml:space="preserve">
          <source>The OTP release that the currently executing ERTS application is part of, as an integer. For details, see &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;. This macro was introduced in OTP release 21.</source>
          <target state="translated">当前执行的ERTS应用程序所在的OTP版本，以整数形式。有关详细信息，请参见 &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; 。此宏在OTP版本21中引入。</target>
        </trans-unit>
        <trans-unit id="16e1639b18798e91125ecf1f057060589779b23c" translate="yes" xml:space="preserve">
          <source>The OTP-MIB mib represents information about Erlang nodes such as node name, number of running processes, virtual machine version etc. If the MIB should be used in a system, it should be loaded into an SNMP agent by using the API function &lt;code&gt;otp_mib:load/1&lt;/code&gt;.</source>
          <target state="translated">OTP-MIB mib表示有关Erlang节点的信息，例如节点名称，正在运行的进程数，虚拟机版本等。如果应在系统中使用MIB，则应使用API​​函数 &lt;code&gt;otp_mib:load/1&lt;/code&gt; 将其加载到SNMP代理中：负载/ 1。</target>
        </trans-unit>
        <trans-unit id="1d079c6127c093fd0bf885dc8ec3e524eee2389b" translate="yes" xml:space="preserve">
          <source>The OTP-REG mib defines the unique OTP subtree of object identifiers under the Ericsson subtree. Under the OTP subtree several object identifiers are defined. This module is typically included by OTP applications defining their own mibs, or ASN.1 modules in general, that require unique object identifiers under the OTP subtree.</source>
          <target state="translated">OTP-REG mib定义了爱立信子树下唯一的OTP子树的对象标识符。在OTP子树下定义了多个对象标识符。这个模块通常被定义自己的mib的OTP应用所包含,或者是一般的ASN.1模块所包含,这些应用需要在OTP子树下定义唯一的对象标识符。</target>
        </trans-unit>
        <trans-unit id="7e4e2e6abc0df4b67e259520ad92410685d1db8d" translate="yes" xml:space="preserve">
          <source>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before standard MIBs existed for access control, MIB views, and trap target specification. All objects in this MIB are now obsolete.</source>
          <target state="translated">OTP-SNMPEA-MIB是在代理的早期版本中使用的,当时还没有用于访问控制、MIB视图和陷阱目标规范的标准MIB。这个MIB中的所有对象现在都已经过时了。</target>
        </trans-unit>
        <trans-unit id="dfdf456ec73d4195574c470386dbc5ef95b5e4be" translate="yes" xml:space="preserve">
          <source>The OTP-TC mib provides the textual convention datatype &lt;code&gt;OwnerString&lt;/code&gt;.</source>
          <target state="translated">OTP-TC mib提供了文本约定数据类型 &lt;code&gt;OwnerString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdfd28142322083a6af658ff0e91ac0a22fe94e4" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; for compatibilty.</source>
          <target state="translated">OTP / SSH应用程序首先在回调模块中调用此函数，然后在旧的 &lt;code&gt;Module:add_host_key/3&lt;/code&gt; 中调用以实现兼容性。</target>
        </trans-unit>
        <trans-unit id="22c83f8d2349d1be9c18b485bc1cd6600dd20f64" translate="yes" xml:space="preserve">
          <source>The OTP/SSH application first calls this function in the callback module, and then the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; for compatibilty.</source>
          <target state="translated">OTP / SSH应用程序首先在回调模块中调用此函数，然后再使用旧的 &lt;code&gt;Module:is_host_key/4&lt;/code&gt; 进行兼容性。</target>
        </trans-unit>
        <trans-unit id="370c0fa4230350b45a2bed8b159298418299327c" translate="yes" xml:space="preserve">
          <source>The Observer application is a container including the following tools for tracing and investigation of distributed systems:</source>
          <target state="translated">观察者应用是一个容器,包括以下工具,用于跟踪和调查分布式系统。</target>
        </trans-unit>
        <trans-unit id="e53532ab978b0a1e5f72db0836d60dcb2627de7d" translate="yes" xml:space="preserve">
          <source>The Observer application is available on the trace control node.</source>
          <target state="translated">观察者应用在跟踪控制节点上。</target>
        </trans-unit>
        <trans-unit id="acca74abfba6c1293f4de6924079a0d77446f3db" translate="yes" xml:space="preserve">
          <source>The Observer application might not always be available on the node to be traced (in the following called the &quot;traced node&quot;). However, Trace Tool Builder can still be run from another node (in the following called the &quot;trace control node&quot;) as long as the following is fulfilled:</source>
          <target state="translated">观察者应用程序可能并不总是在要跟踪的节点上可用(在下文中称为 &quot;跟踪节点&quot;)。但是,只要满足以下条件,Trace Tool Builder仍然可以从另一个节点上运行(以下称为 &quot;trace control node&quot;)。</target>
        </trans-unit>
        <trans-unit id="40509725b1b94ac04bace7fdcf93e38e06d1990b" translate="yes" xml:space="preserve">
          <source>The Operation and Maintenance (OAM) support in OTP consists of a generic model for management subsystems in OTP, and some components to be used in these subsystems. This section describes the model.</source>
          <target state="translated">OTP中的运维(OAM)支持包括OTP中管理子系统的通用模型,以及这些子系统中要使用的一些组件。本节介绍了该模型。</target>
        </trans-unit>
        <trans-unit id="808ca5db0eed6b5828cf7aea959f1c6d4f421b35" translate="yes" xml:space="preserve">
          <source>The P flag has been deprecated by RFC 6733.</source>
          <target state="translated">P标志已被RFC 6733废弃。</target>
        </trans-unit>
        <trans-unit id="521a731b4b96b784ec12d6942621ae176f880a6a" translate="yes" xml:space="preserve">
          <source>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If &lt;code&gt;{error, match_limit}&lt;/code&gt; is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a &lt;code&gt;nomatch&lt;/code&gt;, which is the default return value when this occurs, but by specifying &lt;code&gt;report_errors&lt;/code&gt;, you are informed when the match fails because of too many internal calls.</source>
          <target state="translated">PCRE库对内部匹配函数可以调用的次数设置了限制。在为Erlang编译的库中，默认值为10,000,000。如果返回 &lt;code&gt;{error, match_limit}&lt;/code&gt; ，则正则表达式的执行已达到此限制。通常将其视为 &lt;code&gt;nomatch&lt;/code&gt; ，它是发生这种情况时的默认返回值，但是通过指定 &lt;code&gt;report_errors&lt;/code&gt; ，将在由于内部调用过多而导致匹配失败时通知您。</target>
        </trans-unit>
        <trans-unit id="315aa4b073a3e51b4182d67ae5a99c3e8dd60122" translate="yes" xml:space="preserve">
          <source>The PCRE-specific options &lt;code&gt;dupnames&lt;/code&gt;, &lt;code&gt;ungreedy&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt; can be changed in the same way as the Perl-compatible options by using the characters J, U, and X respectively.</source>
          <target state="translated">可以分别使用字符J，U和X，以与Perl兼容的选项相同的方式来更改特定于PCRE的选项 &lt;code&gt;dupnames&lt;/code&gt; ， &lt;code&gt;ungreedy&lt;/code&gt; 和 &lt;code&gt;extra&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b60700ebcda31fdb446fa71f372ef2af6d7bcce" translate="yes" xml:space="preserve">
          <source>The PLT is built using option &lt;code&gt;--build_plt&lt;/code&gt; to Dialyzer. The following command builds the recommended minimal PLT for Erlang/OTP:</source>
          <target state="translated">PLT是使用 &lt;code&gt;--build_plt&lt;/code&gt; 选项--build_plt构建的。以下命令为Erlang / OTP构建建议的最小PLT：</target>
        </trans-unit>
        <trans-unit id="068bb5f6b3073467febaec97d8dca8e259a70b70" translate="yes" xml:space="preserve">
          <source>The PLT is extended to also include the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. Use &lt;code&gt;--plt&lt;/code&gt; to specify which PLT to start from, and &lt;code&gt;--output_plt&lt;/code&gt; to specify where to put the PLT. Notice that the analysis possibly can include files from the PLT if they depend on the new files. This option only works for BEAM files.</source>
          <target state="translated">PLT已扩展为还包括 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-r&lt;/code&gt; 指定的文件。使用 &lt;code&gt;--plt&lt;/code&gt; 指定从哪个开始PLT，并 &lt;code&gt;--output_plt&lt;/code&gt; 到指定把PLT。注意，如果分析依赖于新文件，则分析中可能包括PLT中的文件。此选项仅适用于BEAM文件。</target>
        </trans-unit>
        <trans-unit id="060b8280a8288371c7c464debf7423fb50d4cb7c" translate="yes" xml:space="preserve">
          <source>The POSIX error codes are mostly come from the OS level socket interface, but this module may generate some appropriate POSIX codes.</source>
          <target state="translated">POSIX错误代码大多来自操作系统级别的socket接口,但这个模块可能会产生一些合适的POSIX代码。</target>
        </trans-unit>
        <trans-unit id="a5ac14853a9b086e8f452912a23bfe90221af508" translate="yes" xml:space="preserve">
          <source>The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.</source>
          <target state="translated">Perl 文档指出,它可能只有在与 (?{})或 (?{})结合时才有用。这些都是PCRE中没有的Perl特性。</target>
        </trans-unit>
        <trans-unit id="7305fc245a21d67edcfb1e7040ab9604b3ab8839" translate="yes" xml:space="preserve">
          <source>The Port number of the Host.</source>
          <target state="translated">主机的端口号。</target>
        </trans-unit>
        <trans-unit id="2d7076aca020633109c1bf0af701628b144f387d" translate="yes" xml:space="preserve">
          <source>The Port number of the host.</source>
          <target state="translated">主机的端口号。</target>
        </trans-unit>
        <trans-unit id="05f38ed5f44cf6a58fcb55ac9b9ba9cb03970efa" translate="yes" xml:space="preserve">
          <source>The ProtocolVersion version is the version actually encoded in the reply message.</source>
          <target state="translated">协议版本(ProtocolVersion)是实际编码在回复消息中的版本。</target>
        </trans-unit>
        <trans-unit id="544a356532db2cd2759e24c6723c4194d33f11f5" translate="yes" xml:space="preserve">
          <source>The Public Key application deals with public-key related file formats, digital signatures, and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt;. It is a library application that provides encode/decode, sign/verify, encrypt/decrypt, and similar functionality. It does not read or write files, it expects or returns file contents or partial file contents as binaries.</source>
          <target state="translated">公钥应用程序处理与公钥相关的文件格式，数字签名和 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt; X-509 certificates&lt;/a&gt;&lt;/code&gt; 。它是一个库应用程序，提供编码/解码，签名/验证，加密/解密和类似功能。它不读写文件，它期望或返回文件内容或部分文件内容作为二进制文件。</target>
        </trans-unit>
        <trans-unit id="7ebdf434e84c8ed49f35713ff4853c27de0d8e82" translate="yes" xml:space="preserve">
          <source>The Public Key decode- and encode-functions try to use the NIFs in the ASN.1 compilers runtime modules, if they can be found. Thus, to have the ASN1 application in the path of your system gives the best performance.</source>
          <target state="translated">公钥解码和编码函数试图使用ASN.1编译器运行时模块中的NIF,如果可以找到的话。因此,在您的系统路径中使用ASN1应用程序可以获得最佳性能。</target>
        </trans-unit>
        <trans-unit id="efe14f45b872852caa29e8e8cc7c7d6e2482faaf" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog state machine has transitioned into (&lt;code&gt;up&lt;/code&gt;) or out of (&lt;code&gt;down&lt;/code&gt;) the OKAY state. If a &lt;code&gt;#diameter_packet{}&lt;/code&gt; is present in an &lt;code&gt;up&lt;/code&gt; event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</source>
          <target state="translated">RFC 3539看门狗状态机已转换为OKAY状态（ &lt;code&gt;up&lt;/code&gt; ）或从OFFAY状态（ &lt;code&gt;down&lt;/code&gt; ）转换。如果在 &lt;code&gt;up&lt;/code&gt; 事件中出现 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 则在新建立的传输连接上进行了功能交换，并且记录中包含接收到的CER或CEA。</target>
        </trans-unit>
        <trans-unit id="dc64b0c1b30970fb85a8fe63a3336e6b7a09937b" translate="yes" xml:space="preserve">
          <source>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of &amp;plusmn; 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</source>
          <target state="translated">RFC 3539看门狗计时器。整数值解释为RFC的TwInit（以毫秒为单位），每次重新设置计时器时都会添加&amp;plusmn;2秒的抖动，以计算RFC的Tw。希望MFA在应用了抖动的情况下直接返回RFC的Tw，从而允许由回调执行抖动计算。</target>
        </trans-unit>
        <trans-unit id="fcc9e80a4124e3a42a057c7e5dbba54abf671c72" translate="yes" xml:space="preserve">
          <source>The RFC states that if a certificate defines Reference IDs in a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field MUST NOT be used for host name checking, even if it contains valid CN names. Therefore only &lt;code&gt;kb.example.org&lt;/code&gt; and &lt;code&gt;https://www.example.org&lt;/code&gt; matches. The match fails both for &lt;code&gt;example.com&lt;/code&gt; and &lt;code&gt;foo.example.com&lt;/code&gt; becuase they are in the &lt;code&gt;Subject&lt;/code&gt; field which is not checked because the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field is present.</source>
          <target state="translated">该RFC规定，如果在证书中一个定义参考ID的 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 领域， &lt;code&gt;Subject&lt;/code&gt; 字段绝不能用于主机名检查，即使它包含有效的CN名称。因此，只有 &lt;code&gt;kb.example.org&lt;/code&gt; 和 &lt;code&gt;https://www.example.org&lt;/code&gt; 匹配。匹配失败，例如 &lt;code&gt;example.com&lt;/code&gt; 和 &lt;code&gt;foo.example.com&lt;/code&gt; ,因为它们位于&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 字段中，因此未选中，因为存在&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="e204403937648bc97742bc221c74abef96cbe2ca" translate="yes" xml:space="preserve">
          <source>The RSA options are experimental.</source>
          <target state="translated">RSA选项是试验性的。</target>
        </trans-unit>
        <trans-unit id="8707a6b8a6bbf5e67f47a831acd5b638d6ca82c3" translate="yes" xml:space="preserve">
          <source>The Report Browser (RB) tool is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; in STDLIB.</source>
          <target state="translated">报告浏览器（RB）工具用于浏览和格式化由STDLIB中的错误记录器处理程序 &lt;code&gt;log_mf_h&lt;/code&gt; 编写的错误报告。</target>
        </trans-unit>
        <trans-unit id="e200f59605a43a83406a6a1c3aae57938231fe10" translate="yes" xml:space="preserve">
          <source>The Report Browser Tool</source>
          <target state="translated">报告浏览器工具</target>
        </trans-unit>
        <trans-unit id="4692a2cbc9da1318b1c32468112fcf231936c7b1" translate="yes" xml:space="preserve">
          <source>The Runtime_Tools application is available on both the trace control node and the traced node.</source>
          <target state="translated">Runtime_Tools应用程序在跟踪控制节点和被跟踪节点上都可用。</target>
        </trans-unit>
        <trans-unit id="3e6f6adc881738e4e882b8995898a6ee34ae6866" translate="yes" xml:space="preserve">
          <source>The SASL application introduces three types of reports:</source>
          <target state="translated">SASL应用程序引入了三种类型的报告。</target>
        </trans-unit>
        <trans-unit id="a66565cf9194d0ac12d200f8341003bfd8ef9840" translate="yes" xml:space="preserve">
          <source>The SASL application provides support for:</source>
          <target state="translated">SASL应用提供了以下支持:</target>
        </trans-unit>
        <trans-unit id="d6eac0a2617b8363f4e9ff21a3e5cf89ae6de35c" translate="yes" xml:space="preserve">
          <source>The SASL error logging concept described in this section is deprecated since Erlang/OTP 21.0, when the new &lt;code&gt;logging API&lt;/code&gt; was introduced.</source>
          <target state="translated">自从引入新的 &lt;code&gt;logging API&lt;/code&gt; 以来，Erlang / OTP 21.0开始就不再使用本节中描述的SASL错误日志记录概念。</target>
        </trans-unit>
        <trans-unit id="06f440d4cdd560b9a71ad7c9c8906b6fd30020a0" translate="yes" xml:space="preserve">
          <source>The SAX events that are sent to the user via the callback.</source>
          <target state="translated">通过回调向用户发送的SAX事件。</target>
        </trans-unit>
        <trans-unit id="6c62591fcbde98f13b883726ae2b16d26e6fd6e4" translate="yes" xml:space="preserve">
          <source>The SMP emulator (introduced in R11B) takes advantage of a multi-core or multi-CPU computer by running several Erlang scheduler threads (typically, the same as the number of cores). Each scheduler thread schedules Erlang processes in the same way as the Erlang scheduler in the non-SMP emulator.</source>
          <target state="translated">SMP仿真器(在R11B中引入)通过运行多个Erlang调度线程(通常情况下,与核数相同)来利用多核或多CPU计算机。每个调度线程调度Erlang进程的方式与非SMP仿真器中的Erlang调度器相同。</target>
        </trans-unit>
        <trans-unit id="886a9eb3b2cede92a51b83a792de6e157b89118c" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional Sub-agents.</source>
          <target state="translated">SNMP代理系统由一个主代理和可选的子代理组成。</target>
        </trans-unit>
        <trans-unit id="7abe087b7edee22ce1a0361250a19799bdfe6153" translate="yes" xml:space="preserve">
          <source>The SNMP agent system consists of one Master Agent and optional sub-agents. The Master Agent can be seen as a special kind of sub-agent. It implements the core agent functionality, UDP packet processing, type checking, access control, trap distribution, and so on. From a user perspective, it is used as an ordinary sub-agent.</source>
          <target state="translated">SNMP代理系统由一个主代理和可选的子代理组成。主代理可以看成是一种特殊的子代理,它实现了核心代理的功能,UDP包处理、类型检查、访问控制、陷阱分发等。它实现了代理的核心功能,UDP包处理、类型检查、访问控制、陷阱分发等。从用户的角度来看,它是作为一个普通的子代理使用的。</target>
        </trans-unit>
        <trans-unit id="3265cc19f00c49d8349eff44b143ef435848cde4" translate="yes" xml:space="preserve">
          <source>The SNMP agent toolkit gets input from three different sources:</source>
          <target state="translated">SNMP代理工具箱从三个不同的来源获得输入。</target>
        </trans-unit>
        <trans-unit id="516cef785b21f525314dd4769fb5d4a3d8e52b36" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the agent is one. This function starts the agent entity of the application.</source>
          <target state="translated">SNMP应用程序由多个实体组成,代理是其中之一。该函数启动应用程序的代理实体。</target>
        </trans-unit>
        <trans-unit id="5a5e7e85ae81bf01406a4eba00ac814b17f5f063" translate="yes" xml:space="preserve">
          <source>The SNMP application consists of several entities, of which the manager is one. This function starts the manager entity of the application.</source>
          <target state="translated">SNMP应用程序由多个实体组成,管理器是其中之一。该函数启动应用程序的管理器实体。</target>
        </trans-unit>
        <trans-unit id="1c525a15cd833eca106834a5297df8dd9f3d8e99" translate="yes" xml:space="preserve">
          <source>The SNMP application should be used to start an SNMP agent. Then the API functions below can be used to load/unload the OTP-MIB into/from the agent. The instrumentation of the OTP-MIB uses Mnesia, hence Mnesia must be started prior to loading the OTP-MIB.</source>
          <target state="translated">应使用SNMP应用程序来启动SNMP代理,然后使用下面的API函数将OTP-MIB加载/卸载到/从代理中。然后可以使用下面的API函数将OTP-MIB加载/卸载到/从代理中。OTP-MIB的工具使用Mnesia,因此在加载OTP-MIB之前必须先启动Mnesia。</target>
        </trans-unit>
        <trans-unit id="efcaf71f311ac8ed0a4c853a395724aa7b68ecca" translate="yes" xml:space="preserve">
          <source>The SNMP built-in database</source>
          <target state="translated">SNMP内置数据库</target>
        </trans-unit>
        <trans-unit id="1f9b4daeb0c18439d5ab9d3febb86ba8cf3f41bc" translate="yes" xml:space="preserve">
          <source>The SNMP development tool provides an environment for rapid agent/manager prototyping and construction. With the following information provided, this tool is used to set up a running multi-lingual SNMP agent/manager:</source>
          <target state="translated">SNMP开发工具提供了一个快速的代理/管理器原型设计和构建的环境。通过提供以下信息,该工具可用于建立一个运行中的多语言SNMP代理/管理器。</target>
        </trans-unit>
        <trans-unit id="4042139e11f084c5315473eee5bae69ee58a652c" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit contains the following parts:</source>
          <target state="translated">SNMP开发工具箱包含以下部分。</target>
        </trans-unit>
        <trans-unit id="c676c0d7043a8420fb555224be79bdf5a57f0b38" translate="yes" xml:space="preserve">
          <source>The SNMP development toolkit works with all three versions of Standard Internet Management Framework; SNMPv1, SNMPv2 and SNMPv3. They all share the same basic structure and components. And they follow the same architecture.</source>
          <target state="translated">SNMP开发工具包可与标准互联网管理框架的所有三个版本配合使用:SNMPv1、SNMPv2和SNMPv3。它们都有相同的基本结构和组件。而且它们遵循相同的架构。</target>
        </trans-unit>
        <trans-unit id="4c98874c0a92d51a9659461230a55d2c1a730338" translate="yes" xml:space="preserve">
          <source>The SNMP-COMMUNITY-MIB defines managed objects that is used for coexistence between SNMPv1 and SNMPv2c with SNMPv3. Specifically, it contains objects for mapping between community strings and version-independent SNMP message parameters. In addition, this MIB provides a mechanism for performing source address validation on incoming requests, and for selecting community strings based on target addresses for outgoing notifications.</source>
          <target state="translated">SNMP-COMMUNITY-MIB定义了用于SNMPv1和SNMPv2c与SNMPv3共存的管理对象。具体来说,它包含了用于社区字符串和版本无关的SNMP消息参数之间映射的对象。此外,该MIB还提供了一种机制,用于对传入的请求进行源地址验证,以及根据目标地址为传出通知选择社区字符串。</target>
        </trans-unit>
        <trans-unit id="8668c117c3657ad50b4bac1040aadc9d90558e41" translate="yes" xml:space="preserve">
          <source>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional read-only managed objects, which is used in the generic SNMP framework defined in RFC2271 and the generic message processing and dispatching module defined in RFC2272. They are generic in the sense that they are not tied to any specific SNMP version.</source>
          <target state="translated">SNMP-FRAMEWORK-MIB和SNMP-MPD-MIB定义了额外的只读管理对象,它用于RFC2271中定义的通用SNMP框架和RFC2272中定义的通用消息处理和调度模块。它们是通用的,因为它们不与任何特定的SNMP版本相关联。</target>
        </trans-unit>
        <trans-unit id="45b5b2d3e04821e69bc6b70c4958af997f02dac7" translate="yes" xml:space="preserve">
          <source>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed objects for configuration of notification receivers. They are described in detail in RFC2273. Only a brief description is given here.</source>
          <target state="translated">SNMP-TARGET-MIB和SNMP-NOTIFICATION-MIB定义了用于配置通知接收机的管理对象。它们在RFC2273中进行了详细描述。这里只给出了简要的描述。</target>
        </trans-unit>
        <trans-unit id="9d8ba60d5c67646e6a39ec77ff47623898401ff5" translate="yes" xml:space="preserve">
          <source>The SNMP-USER-BASED-SM-MIB defines managed objects that is used for the User-Based Security Model.</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB定义了用于基于用户的安全模型的管理对象。</target>
        </trans-unit>
        <trans-unit id="06a4a7a167128e9dfbd7bbf5787fec903cb71f3c" translate="yes" xml:space="preserve">
          <source>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to control access to the the managed objects for the managers. The View Based Access Control Module (VACM) can be used with any SNMP version. However, if it is used with SNMPv1 or SNMPv2c, the SNMP-COMMUNITY-MIB defines additional objects to map community strings to VACM parameters.</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB定义了管理对象,用于控制管理人员对管理对象的访问。基于视图的访问控制模块(VACM)可以与任何SNMP版本一起使用,但如果与SNMPv1或SNMPv2c一起使用,则SNMP-VIEW-BASED-ACM-MIB定义了管理对象,用于控制管理人员对被管理对象的访问。然而,如果它与SNMPv1或SNMPv2c一起使用,SNMP-COMMUNITY-MIB定义了额外的对象来将社区字符串映射到VACM参数。</target>
        </trans-unit>
        <trans-unit id="cf1237e4f8f3b9ace0c3f4bf9ded6dcb4f4634bb" translate="yes" xml:space="preserve">
          <source>The SNMPv3 specifications take a modular approach to SNMP. All modules are separated from each other, and can be extended or replaced individually. Examples of modules are Message definition, Security and Access Control. The main features of SNMPv3 are:</source>
          <target state="translated">SNMPv3规范对SNMP采取了模块化的方法。所有模块都是相互分离的,可以单独扩展或替换。例如消息定义、安全和访问控制等模块。SNMPv3的主要特点是:1.</target>
        </trans-unit>
        <trans-unit id="49091ee8eff63f8735f82d85f410f0e974abd772" translate="yes" xml:space="preserve">
          <source>The SSH Authentication Protocol is a general-purpose user authentication protocol run over the SSH Transport Layer Protocol. The &lt;code&gt;ssh&lt;/code&gt; application supports user authentication as follows:</source>
          <target state="translated">SSH身份验证协议是在SSH传输层协议上运行的通用用户身份验证协议。所述 &lt;code&gt;ssh&lt;/code&gt; 应用程序支持的用户认证如下：</target>
        </trans-unit>
        <trans-unit id="7b0b1cec477594d6b882874c149d3fa88e25a3ad" translate="yes" xml:space="preserve">
          <source>The SSH Connection Protocol provides application-support services over the transport pipe, for example, channel multiplexing, flow control, remote program execution, signal propagation, and connection forwarding. Functions for handling the SSH Connection Protocol can be found in the module &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH连接协议通过传输管道提供应用程序支持服务，例如，通道多路复用，流控制，远程程序执行，信号传播和连接转发。可以在 &lt;code&gt;ssh&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection&lt;/a&gt;&lt;/code&gt; 模块中找到处理SSH连接协议的功能。</target>
        </trans-unit>
        <trans-unit id="509aa3afb50ca256dde1f08abd1d170febe86fc9" translate="yes" xml:space="preserve">
          <source>The SSH Transport Protocol is a secure, low-level transport. It provides strong encryption, cryptographic host authentication, and integrity protection. A minimum of Message Authentication Code (MAC) and encryption algorithms are supported. For details, see the &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; manual page in &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">SSH传输协议是一种安全的低层传输。它提供了强大的加密，加密主机身份验证和完整性保护。最少支持消息认证码（MAC）和加密算法。有关详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh(3)&lt;/a&gt;&lt;/code&gt; 在手册页 &lt;code&gt;ssh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744c82a62e8aa358bae0f2bd9bcd0a7ad67c79e1" translate="yes" xml:space="preserve">
          <source>The SSH app's mechanism</source>
          <target state="translated">SSH应用程序的机制</target>
        </trans-unit>
        <trans-unit id="6cafe9a62d6f03f5d4b28fc5be0a442441723104" translate="yes" xml:space="preserve">
          <source>The SSH protocol therefore has a special operation defined -</source>
          <target state="translated">因此,SSH协议定义了一个特殊的操作------。</target>
        </trans-unit>
        <trans-unit id="fbf96a70f08f9bc454fcd92af00d3c4835a1fd09" translate="yes" xml:space="preserve">
          <source>The SSH server on UNIX/Linux/etc after a succesful authentication</source>
          <target state="translated">UNIX/Linux/etc上的SSH服务器在认证成功后的情况下。</target>
        </trans-unit>
        <trans-unit id="24d33b22db4cc904f86f4d5db9025bf058eaf503" translate="yes" xml:space="preserve">
          <source>The SSL/TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">可以将SSL / TLS分发选项写入启动节点时要查询的文件。然后，使用命令行参数 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; 指定此文件名。</target>
        </trans-unit>
        <trans-unit id="a2ffdfd10003f355a79033be2fe1f79f1e9e6854" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">可从syslog守护程序 &lt;code&gt;syslogd&lt;/code&gt; 检索Solaris（SunOS 5.x）消息。</target>
        </trans-unit>
        <trans-unit id="555d2ccf08ac60c2e06799bc61b70df2c88b6a2f" translate="yes" xml:space="preserve">
          <source>The Solaris (SunOS 5.x) messages are retrieved from the syslog-daemon, &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">从syslog守护程序 &lt;code&gt;syslogd&lt;/code&gt; 检索Solaris（SunOS 5.x）消息。</target>
        </trans-unit>
        <trans-unit id="23097a6cf28465a184806bf15474a12dff162d12" translate="yes" xml:space="preserve">
          <source>The Standard Erlang Libraries application, &lt;strong&gt;STDLIB&lt;/strong&gt;, is mandatory in the sense that the minimal system based on Erlang/OTP consists of &lt;strong&gt;STDLIB&lt;/strong&gt; and &lt;strong&gt;Kernel&lt;/strong&gt;.</source>
          <target state="translated">从基于Erlang / OTP的最小系统由&lt;strong&gt;STDLIB&lt;/strong&gt;和&lt;strong&gt;Kernel&lt;/strong&gt;组成的意义上说，标准Erlang库应用程序&lt;strong&gt;STDLIB&lt;/strong&gt;是必需的。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2a74e481bb59b29d7198edb8d96d6f22f60622" translate="yes" xml:space="preserve">
          <source>The System Under Test (SUT) can consist of one or more target nodes. &lt;code&gt;Common Test&lt;/code&gt; contains a generic test server that, together with other test utilities, is used to perform test case execution. The tests can be started from a GUI, from the OS shell, or from an Erlang shell. &lt;strong&gt;Test suites&lt;/strong&gt; are files (Erlang modules) that contain the &lt;strong&gt;test cases&lt;/strong&gt; (Erlang functions) to be executed. &lt;strong&gt;Support modules&lt;/strong&gt; provide functions that the test cases use to do the tests.</source>
          <target state="translated">被测系统（SUT）可以包含一个或多个目标节点。 &lt;code&gt;Common Test&lt;/code&gt; 包含一个通用测试服务器，该服务器与其他测试实用程序一起用于执行测试用例。可以从GUI，OS外壳程序或Erlang外壳程序开始测试。&lt;strong&gt;测试套件&lt;/strong&gt;是包含要执行的&lt;strong&gt;测试用例&lt;/strong&gt;（Erlang函数）的文件（Erlang模块）。&lt;strong&gt;支持模块&lt;/strong&gt;提供测试用例用于进行测试的功能。</target>
        </trans-unit>
        <trans-unit id="eb87875630edf563277392030eee430765ee9a3b" translate="yes" xml:space="preserve">
          <source>The TCP/IP &lt;code&gt;epmd&lt;/code&gt; daemon only keeps track of the &lt;code&gt;Name&lt;/code&gt; (first) part of an Erlang node name. The &lt;code&gt;Host&lt;/code&gt; part (whatever is after the &lt;code&gt;@&lt;/code&gt;) is implicit in the node name where the &lt;code&gt;epmd&lt;/code&gt; daemon was contacted, as is the IP address where the Erlang node can be reached. Consistent and correct TCP naming services are therefore required for an Erlang network to function correctly.</source>
          <target state="translated">TCP / IP &lt;code&gt;epmd&lt;/code&gt; 守护程序仅跟踪Erlang节点名称的 &lt;code&gt;Name&lt;/code&gt; （第一）部分。该 &lt;code&gt;Host&lt;/code&gt; 部分（无论是后 &lt;code&gt;@&lt;/code&gt; ）是在该节点名称隐含 &lt;code&gt;epmd&lt;/code&gt; 守护进程进行了接触，因为是在二郎山节点可到达的IP地址。因此，要使Erlang网络正确运行，就需要一致且正确的TCP命名服务。</target>
        </trans-unit>
        <trans-unit id="058df102c079061352735c937be80bdb1a45818f" translate="yes" xml:space="preserve">
          <source>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</source>
          <target state="translated">TCP/IP分配使用的握手是期望基于连接的协议,也就是说,协议在握手程序之后不包括任何认证。</target>
        </trans-unit>
        <trans-unit id="6657b1618f0a92c332d5f9a74326d92f2550bf02" translate="yes" xml:space="preserve">
          <source>The TCP_NODELAY option for the telnet socket is disabled (set to &lt;code&gt;false&lt;/code&gt;) per default</source>
          <target state="translated">缺省情况下，禁用了telnet套接字的TCP_NODELAY选项（设置为 &lt;code&gt;false&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="27af0d178d9d81560da76e1bb5028c47f5e6d47a" translate="yes" xml:space="preserve">
          <source>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function &lt;code&gt;info/1&lt;/code&gt;).</source>
          <target state="translated">守护程序侦听的TFTP端口。默认值为标准化数字69。在服务器端，有时将其设置为0可能很有意义，这意味着守护程序仅选择一个空闲端口（该端口由 &lt;code&gt;info/1&lt;/code&gt; 返回）。</target>
        </trans-unit>
        <trans-unit id="1d58f1eb861475088c58d8cf25b2227f3e09eb03" translate="yes" xml:space="preserve">
          <source>The TLS 1.3 protocol does not provide inherent protection for replay of 0-RTT data but describes mechanisms that SHOULD be implemented by compliant server implementations. The implementation of TLS 1.3 in the SSL application employs all standard methods to prevent potential threats.</source>
          <target state="translated">TLS 1.3协议并没有为0-RTT数据的重放提供固有的保护,而是描述了应该由符合要求的服务器实现的机制。在SSL应用中,TLS 1.3的实施采用了所有标准方法来防止潜在的威胁。</target>
        </trans-unit>
        <trans-unit id="efab23f28e335395659c14ebcb8051f53a7632c5" translate="yes" xml:space="preserve">
          <source>The TLS distribution options can be written into a file that is consulted when the node is started. This file name is then specified with the command line argument &lt;code&gt;-ssl_dist_optfile&lt;/code&gt;.</source>
          <target state="translated">可以将TLS分发选项写入启动节点时要查询的文件。然后，使用命令行参数 &lt;code&gt;-ssl_dist_optfile&lt;/code&gt; 指定此文件名。</target>
        </trans-unit>
        <trans-unit id="75ccd2ece5259566f90ebb1a8f2c68746b4c7b93" translate="yes" xml:space="preserve">
          <source>The TLS/DTLS handshake protocol and data transfer is run on top of the TLS/DTLS Record Protocol, which uses a keyed-hash Message Authenticity Code (MAC), or a Hash-based MAC (HMAC), to protect the message data integrity. From the TLS RFC: &quot;A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.&quot;</source>
          <target state="translated">TLS/DTLS握手协议和数据传输是运行在TLS/DTLS记录协议之上的,该协议使用一个带键的散列消息认证码(Message Authenticity Code,MAC)或基于散列的MAC(HMAC)来保护消息数据的完整性。来自TLS RFC:&quot;消息认证码是由消息和一些秘密数据计算出的单向哈希值。在不知道秘密数据的情况下,它很难被伪造。其目的是检测信息是否被篡改。&quot;</target>
        </trans-unit>
        <trans-unit id="ecf685e6c13939907b870d82ee6d0c05ec6e094e" translate="yes" xml:space="preserve">
          <source>The Text Based Trace Facility</source>
          <target state="translated">基于文本的追踪机制</target>
        </trans-unit>
        <trans-unit id="e8fd67f45550805b41375cc84bc114e897e3206a" translate="yes" xml:space="preserve">
          <source>The Trace Tool Builder, &lt;code&gt;ttb&lt;/code&gt;, is a base for building trace tools for distributed systems.</source>
          <target state="translated">跟踪工具构建器 &lt;code&gt;ttb&lt;/code&gt; 是构建分布式系统跟踪工具的基础。</target>
        </trans-unit>
        <trans-unit id="64d22e790fe528bf704a212bc1e1c0da643a949f" translate="yes" xml:space="preserve">
          <source>The Trace area also displays Back Trace, a summary of the current function calls on the stack.</source>
          <target state="translated">跟踪区域还显示Back Trace,即当前堆栈上函数调用的摘要。</target>
        </trans-unit>
        <trans-unit id="b692df8320088d88e275d851ad60786d4e949a1f" translate="yes" xml:space="preserve">
          <source>The Trace area, which displays a trace output for the process.</source>
          <target state="translated">跟踪区域,显示进程的跟踪输出。</target>
        </trans-unit>
        <trans-unit id="1b50d3d2fc04c4411539dfbb6e62512f2efa0130" translate="yes" xml:space="preserve">
          <source>The Trivial File Transfer Protocol or TFTP is a very simple protocol used to transfer files.</source>
          <target state="translated">Trivial File Transfer Protocol或TFTP是一个非常简单的协议,用于传输文件。</target>
        </trans-unit>
        <trans-unit id="bf89156ef59750c4bb77ca15635b355ebce24e10" translate="yes" xml:space="preserve">
          <source>The Types are:</source>
          <target state="translated">这些类型是:</target>
        </trans-unit>
        <trans-unit id="a2becef736618dd80aea9ed87dc6889b0431226f" translate="yes" xml:space="preserve">
          <source>The URI parser tries all possible combinations to interpret the input and fails at the last attempt when it encounters the colon character &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Note, that the inital fault occurs when the parser attempts to interpret the character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; and after a failure back-tracks to the point where it has another possible parsing alternative.</source>
          <target state="translated">URI解析器会尝试所有可能的组合来解释输入，并且在遇到冒号 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 时在最后一次尝试时失败。请注意，当解析器尝试解释字符 &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; 时，会出现初始错误，并且在失败之后会回溯到可以进行另一种解析的位置。</target>
        </trans-unit>
        <trans-unit id="2ea556d1f13405f24d60defd343780b8d63e1882" translate="yes" xml:space="preserve">
          <source>The URL the client was on before requesting the URL (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">客户端在请求URL之前所处的URL(如果无法确定,则在此字段中放置一个减号)。</target>
        </trans-unit>
        <trans-unit id="2cd23bacb56d43630d70d816af467c37a05ab674" translate="yes" xml:space="preserve">
          <source>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; was not &lt;code&gt;NULL&lt;/code&gt;-terminated on older releases.</source>
          <target state="translated">UTF-8变体在Erlang / OTP R16中引入，并且由 &lt;code&gt;ERL_ATOM_PTR(atom)&lt;/code&gt; 返回的字符串在旧版本中不是 &lt;code&gt;NULL&lt;/code&gt; 终止的。</target>
        </trans-unit>
        <trans-unit id="c76d8253124bd005c5e7c3968606bd5eebfe787e" translate="yes" xml:space="preserve">
          <source>The Unexpected I/O Log</source>
          <target state="translated">意外的I/O日志</target>
        </trans-unit>
        <trans-unit id="615107616ab4a2ac637d22a3e97ccf0d1ff89d56" translate="yes" xml:space="preserve">
          <source>The Unicode characters need to be processed by the Erlang program, which is why library functions must be able to handle them. In some cases functionality has been added to already existing interfaces (as the &lt;code&gt;string&lt;/code&gt; module now can handle strings with any code points). In some cases new functionality or options have been added (as in the &lt;code&gt;io&lt;/code&gt; module, the file handling, the &lt;code&gt;unicode&lt;/code&gt; module, and the bit syntax). Today most modules in Kernel and STDLIB, as well as the VM are Unicode-aware.</source>
          <target state="translated">Unicode字符需要由Erlang程序处理，这就是为什么库函数必须能够处理它们。在某些情况下，功能已经添加到现有接口中（因为 &lt;code&gt;string&lt;/code&gt; 模块现在可以处理具有任何代码点的字符串）。在某些情况下，添加了新功能或选项（如 &lt;code&gt;io&lt;/code&gt; 模块，文件处理， &lt;code&gt;unicode&lt;/code&gt; 模块和位语法）。如今，内核和STDLIB中的大多数模块以及VM都支持Unicode。</target>
        </trans-unit>
        <trans-unit id="d8a64b00a37fa70a62423e7afa68917e078e3bbf" translate="yes" xml:space="preserve">
          <source>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM operating in Unicode filename translation mode can work with files having names in any language or character set (as long as it is supported by the underlying operating system and file system). The Unicode character list is used to denote filenames or directory names. If the file system content is listed, you also get Unicode lists as return value. The support lies in the Kernel and STDLIB modules, which is why most applications (that do not explicitly require the filenames to be in the ISO Latin-1 range) benefit from the Unicode support without change.</source>
          <target state="translated">Erlang/OTP R14B01中引入了Unicode文件命名支持。在Unicode文件名翻译模式下运行的虚拟机可以使用具有任何语言或字符集名称的文件(只要底层操作系统和文件系统支持它)。Unicode 字符表用于表示文件名或目录名。如果文件系统内容被列出,你也会得到Unicode列表作为返回值。支持在于Kernel和STDLIB模块,这就是为什么大多数应用程序(没有明确要求文件名在ISO Latin-1范围内)都能从Unicode支持中获益而不需要改变。</target>
        </trans-unit>
        <trans-unit id="2e08532eda1cbb1ea06bfac649530b3d005afb89" translate="yes" xml:space="preserve">
          <source>The Unicode string is returned as a Unicode list, which is recognized as such, as the Erlang shell uses the Unicode encoding (and is started with all Unicode characters considered printable). The Unicode list is valid input to function &lt;code&gt;io:put_chars/2&lt;/code&gt;, so data can be output on any Unicode-capable device. If the device is a terminal, characters are output in format &lt;code&gt;\x{&lt;/code&gt;H...&lt;code&gt;}&lt;/code&gt; if encoding is &lt;code&gt;latin1&lt;/code&gt;. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or &quot;noshell&quot;) or whatever is suitable to show the character properly (for an interactive terminal: the regular shell).</source>
          <target state="translated">Unicode字符串作为Unicode列表返回，因此被识别，因为Erlang外壳使用Unicode编码（并以所有可打印的Unicode字符开头）。 Unicode列表是功能 &lt;code&gt;io:put_chars/2&lt;/code&gt; 的有效输入，因此可以在任何支持Unicode的设备上输出数据。如果设备是终端，则在编码为 &lt;code&gt;latin1&lt;/code&gt; 的情况下以 &lt;code&gt;\x{&lt;/code&gt; H ... &lt;code&gt;}&lt;/code&gt; 格式输出字符。否则，在UTF-8中（对于非交互式终端：&amp;ldquo; oldshell&amp;rdquo;或&amp;ldquo; noshell&amp;rdquo;）或适合于正确显示字符的任何内容（对于交互式终端：常规外壳）。</target>
        </trans-unit>
        <trans-unit id="917f1b5ccc007e44df82f5ad9e8e418e0762f6b0" translate="yes" xml:space="preserve">
          <source>The Unicode support is controlled by both command-line switches, some standard environment variables, and the OTP version you are using. Most options affect mainly how Unicode data is displayed, not the functionality of the APIs in the standard libraries. This means that Erlang programs usually do not need to concern themselves with these options, they are more for the development environment. An Erlang program can be written so that it works well regardless of the type of system or the Unicode options that are in effect.</source>
          <target state="translated">对Unicode的支持由命令行开关、一些标准环境变量和你正在使用的OTP版本来控制。大多数选项主要影响Unicode数据的显示方式,而不是标准库中API的功能。这意味着Erlang程序通常不需要关注这些选项,它们更多的是为开发环境服务的。一个Erlang程序可以写得很好,无论系统的类型或Unicode选项是什么,都可以很好地工作。</target>
        </trans-unit>
        <trans-unit id="9e4f13026f64ec5f7cdd6285c03d5258bacc1cd2" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier &lt;code&gt;t&lt;/code&gt; specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &amp;gt; 255:</source>
          <target state="translated">Unicode转换修饰符 &lt;code&gt;t&lt;/code&gt; 指定如何处理原子点，字符串和二进制代码中Latin-1代码点范围之外的字符。例如，打印包含字符&amp;gt; 255的原子：</target>
        </trans-unit>
        <trans-unit id="e24a7d795c65b90caaa133aaf71048aad49fb98e" translate="yes" xml:space="preserve">
          <source>The Unicode translation modifier works as with &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">Unicode翻译修饰符与 &lt;code&gt;s&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="b61b21ce88bdc4622a6b58534472bd97a7d6b6d9" translate="yes" xml:space="preserve">
          <source>The Unix &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is to be set to the display of the master node.</source>
          <target state="translated">Unix &lt;code&gt;DISPLAY&lt;/code&gt; 环境变量将设置为主节点的显示。</target>
        </trans-unit>
        <trans-unit id="7580a1c9657bbaca0bea72d41a48c1a2c9f178ef" translate="yes" xml:space="preserve">
          <source>The VM performs tail call optimization, which does not add new entries to the stacktrace, and also limits stacktraces to a certain depth. Furthermore, compiler options, optimizations and future changes may add or remove stacktrace entries, causing any code that expects the stacktrace to be in a certain order or contain specific items to fail.</source>
          <target state="translated">虚拟机执行尾部调用优化,不会在stacktrace中添加新的条目,也会将stacktrace限制在一定的深度。此外,编译器选项、优化和未来的变化可能会增加或删除堆栈跟踪条目,导致任何期望堆栈跟踪按一定顺序或包含特定项目的代码失败。</target>
        </trans-unit>
        <trans-unit id="36921b8c054120393af51df837412dde5ebe77c2" translate="yes" xml:space="preserve">
          <source>The VM with SMP support makes quite a heavy use of atomic memory operations. An implementation providing native atomic memory operations is therefore very important when building Erlang/OTP. By default the VM will refuse to build if native atomic memory operations are not available.</source>
          <target state="translated">支持SMP的虚拟机会大量使用原子内存操作,因此,提供原生原子内存操作的实现在构建Erlang/OTP时非常重要。因此,在构建Erlang/OTP时,提供本地原子内存操作的实现非常重要。默认情况下,如果本机原子内存操作不可用,VM将拒绝构建。</target>
        </trans-unit>
        <trans-unit id="883c00fb93b6833f40d7fa937a519315da18d85d" translate="yes" xml:space="preserve">
          <source>The View Module window displays the contents of an interpreted module and makes it possible to set breakpoints.</source>
          <target state="translated">查看模块窗口显示解释模块的内容,并可设置断点。</target>
        </trans-unit>
        <trans-unit id="818a2a38b6d37966404b0037603dc28865b80d3d" translate="yes" xml:space="preserve">
          <source>The Windows messages are retrieved from the eventlog file.</source>
          <target state="translated">Windows消息是从eventlog文件中获取的。</target>
        </trans-unit>
        <trans-unit id="1ef81693a27626a4d31fec58f2301060476cd06b" translate="yes" xml:space="preserve">
          <source>The Windows system is rebooted whenever the emulator stops (a more simple form of watchdog). This can be useful for less critical systems, otherwise use the heart functionality to accomplish this.</source>
          <target state="translated">每当模拟器停止时,Windows系统就会重新启动(一种更简单的看门狗形式)。这对于不那么关键的系统来说是很有用的,否则使用心脏功能来完成这个功能。</target>
        </trans-unit>
        <trans-unit id="66afd9d96a38a37c4f7f94ff1bd05dfee703afea" translate="yes" xml:space="preserve">
          <source>The XML version shown earlier can also be used, but it is to be explicitly specified that the &lt;code&gt;ct_config_xml&lt;/code&gt; callback module is to be used by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">前面显示的XML版本也可以使用，但它是被明确指定的 &lt;code&gt;ct_config_xml&lt;/code&gt; 回调模块是通过使用 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="252a4b864e9fb6b863b0c8c232185b5a96bbfa1c" translate="yes" xml:space="preserve">
          <source>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described in the next section) in that they only ever match at the very start and end of the subject string, whatever options are set. Thus, they are independent of multiline mode. These three assertions are not affected by options &lt;code&gt;notbol&lt;/code&gt; or &lt;code&gt;noteol&lt;/code&gt;, which affect only the behavior of the circumflex and dollar metacharacters. However, if argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, indicating that matching is to start at a point other than the beginning of the subject, \A can never match. The difference between \Z and \z is that \Z matches before a newline at the end of the string and at the very end, while \z matches only at the end.</source>
          <target state="translated">\ A，\ Z和\ z断言与传统的抑扬符和美元（下一节将进行描述）的不同之处在于，无论设置了什么选项，它们都只会在主题字符串的开头和结尾处匹配。因此，它们独立于多线模式。这三个断言不受选项 &lt;code&gt;notbol&lt;/code&gt; 或 &lt;code&gt;noteol&lt;/code&gt; 的影响，它们仅影响回扬符号和美元元字符的行为。然而，如果参数 &lt;code&gt;startoffset&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 是非零，这表明匹配处于比主体的开头之外的点开始，\ A，则不能使用。 \ Z和\ z的区别在于\ Z在字符串的末尾和换行符的末尾匹配，而\ z仅在末尾匹配。</target>
        </trans-unit>
        <trans-unit id="943d4453f30bb5749d0c52004563365b21bda38a" translate="yes" xml:space="preserve">
          <source>The \C escape sequence</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="4f34ba1108b5cb6716129944fbf4f4329a0a6235" translate="yes" xml:space="preserve">
          <source>The \C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):</source>
          <target state="translated">最好避免使用&quot;/C &quot;转义序列。然而,使用它的一种方法可以避免畸形UTF字符的问题,就是使用一个lookahead来检查下一个字符的长度,就像下面的模式,它可以用于UTF-8的字符串(忽略空白和换行符)。</target>
        </trans-unit>
        <trans-unit id="c3ea67e0b67cb019dc5aaa8e95c03b5cb7572754" translate="yes" xml:space="preserve">
          <source>The \G assertion is true only when the current matching position is at the start point of the match, as specified by argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;run/3&lt;/code&gt;. It differs from \A when the value of &lt;code&gt;startoffset&lt;/code&gt; is non-zero. By calling &lt;code&gt;run/3&lt;/code&gt; multiple times with appropriate arguments, you can mimic the Perl option &lt;code&gt;/g&lt;/code&gt;, and it is in this kind of implementation where \G can be useful.</source>
          <target state="translated">仅在当前匹配位置是在比赛的开始点，如由自变量指定的\ G断言，为真 &lt;code&gt;startoffset&lt;/code&gt; 的 &lt;code&gt;run/3&lt;/code&gt; 。当 &lt;code&gt;startoffset&lt;/code&gt; 的值不为零时，它不同于\ A。通过使用适当的参数多次调用 &lt;code&gt;run/3&lt;/code&gt; ，可以模仿Perl选项 &lt;code&gt;/g&lt;/code&gt; ，在这种实现中\ G很有用。</target>
        </trans-unit>
        <trans-unit id="2f7f1b350c6833ef257bc14bd5940d6dff8095f3" translate="yes" xml:space="preserve">
          <source>The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.</source>
          <target state="translated">Q/Q.../E序列在字符类内部和外部都能被识别。一个孤立的/E,如果前面没有出现/Q,则会被忽略。如果在模式中的后面没有跟上 \E,字面解释将一直持续到模式的最后(也就是说,在最后假定有 \E)。如果被隔离的\Q在一个字符类中,这将导致一个错误,因为该字符类没有被终止。</target>
        </trans-unit>
        <trans-unit id="14658b1c2056da1457d1137feae50fbf03cef97b" translate="yes" xml:space="preserve">
          <source>The \R escape sequence</source>
          <target state="translated">R逃逸序列</target>
        </trans-unit>
        <trans-unit id="4253fcd6879a11eec01b435167179d5e15f76711" translate="yes" xml:space="preserve">
          <source>The \X escape matches any number of Unicode characters that form an &quot;extended grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to and including release 8.31, PCRE matched an earlier, simpler definition that was equivalent to &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt;. That is, it matched a character without the &quot;mark&quot; property, followed by zero or more characters with the &quot;mark&quot; property. Characters with the &quot;mark&quot; property are typically non-spacing accents that affect the preceding character.</source>
          <target state="translated">\ X转义符匹配构成&amp;ldquo;扩展字素簇&amp;rdquo;的任意数量的Unicode字符，并将该序列视为一个原子组（请参见下文）。在版本8.31（含）之前，PCRE匹配了一个更早，更简单的定义，等效于 &lt;code&gt;(?&amp;gt;\PM\pM*)&lt;/code&gt; 。也就是说，它与不具有&amp;ldquo; mark&amp;rdquo;属性的字符相匹配，然后匹配零个或多个具有&amp;ldquo; mark&amp;rdquo;属性的字符。具有&amp;ldquo; mark&amp;rdquo;属性的字符通常是会影响前一个字符的非空格重音。</target>
        </trans-unit>
        <trans-unit id="fe0ff3b7597c9ca177e61f2b7394c84224900254" translate="yes" xml:space="preserve">
          <source>The \X escape sequence</source>
          <target state="translated">逃离序列</target>
        </trans-unit>
        <trans-unit id="1a667df5d1564a7cf0ddb2cbecc475bdb5eb483f" translate="yes" xml:space="preserve">
          <source>The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.</source>
          <target state="translated">\c设施是为ASCII字符设计的,但随着对Unicode的扩展,它的作用甚至比以前更小。</target>
        </trans-unit>
        <trans-unit id="269d02430fd6e138cda2800d0af71fa652dd1cf5" translate="yes" xml:space="preserve">
          <source>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the &lt;code&gt;register/2&lt;/code&gt; and &lt;code&gt;whereis/1&lt;/code&gt; BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</source>
          <target state="translated">全局注册名称的能力是分布式Erlang系统编程中的核心概念。在此模块中，提供了等效的 &lt;code&gt;register/2&lt;/code&gt; 和 &lt;code&gt;whereis/1&lt;/code&gt; BIF（用于本地名称注册），但适用于Erlang节点网络。注册名称是进程标识符（pid）的别名。全局名称服务器监视全局注册的pid。如果进程终止，则该名称也在全局范围内未注册。</target>
        </trans-unit>
        <trans-unit id="2cc8577a293410d9b2b2308f91ef8c7aeb7972a3" translate="yes" xml:space="preserve">
          <source>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate &lt;code&gt;Mnesia&lt;/code&gt; tables.</source>
          <target state="translated">具有与顶级事务相同的语义的嵌套事务的功能使编写操作 &lt;code&gt;Mnesia&lt;/code&gt; 表的库函数更加容易。</target>
        </trans-unit>
        <trans-unit id="5d3f3d904255147f868f9a9b898334b0ed05f68e" translate="yes" xml:space="preserve">
          <source>The ability to prepare several modules in parallel is not currently used as almost all code loading is serialized by the code_server process. The BIF interface is however prepared for this.</source>
          <target state="translated">目前还没有使用并行准备多个模块的能力,因为几乎所有的代码加载都是由code_server进程串行化的。不过,BIF接口已经为此做了准备。</target>
        </trans-unit>
        <trans-unit id="89a04008ab968f22c43827dcb1f3ef8218af459a" translate="yes" xml:space="preserve">
          <source>The ability to reconfigure the system without stopping or suspending it.</source>
          <target state="translated">能够在不停止或暂停系统的情况下重新配置系统。</target>
        </trans-unit>
        <trans-unit id="129e9c30a42ceaac73e62bd0dcc82cdd40af7c03" translate="yes" xml:space="preserve">
          <source>The above commands give a bit more information than the exact answers, but adequate information when manually searching for answers to these questions.</source>
          <target state="translated">以上命令给出的信息比确切的答案要多一些,但在手动搜索这些问题的答案时,足够的信息。</target>
        </trans-unit>
        <trans-unit id="f248f43bea4cac68bcba54c041edea09e4c2df08" translate="yes" xml:space="preserve">
          <source>The above described implementation more or less minimizes the comunication needed before we can increment the global counter. The amount of communication in the system due to the thread progress functionality however also depend on the frequency with which managed threads call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt;. Today each scheduler thread calls &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; more or less each time an Erlang process is scheduled out. One way of further reducing communication due to the thread progress functionality is to only call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; every second, or third time an Erlang process is scheduled out, or even less frequently than that. However, by doing updates of thread progress less frequently all operations depending on the thread progress functionality will also take a longer time.</source>
          <target state="translated">在我们可以增加全局计数器之前，上述实现或多或少地最小化了所需的通信。但是，由于线程进度功能，系统中的通信量还取决于托管线程调用 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 的频率。今天，每次调度Erlang进程时，每个调度程序线程 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 或多或少地调用erts_thr_progress_update（）。由于线程进度功能，进一步减少通信的一种方法是仅调用 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 每隔第二或第三次调度Erlang进程，甚至比调度频率更低。但是，通过减少线程进度的更新，取决于线程进度功能的所有操作也将花费更长的时间。</target>
        </trans-unit>
        <trans-unit id="eaa2af3e34f5b33ee6c40efa2f89e63edd11857b" translate="yes" xml:space="preserve">
          <source>The above describes how it works if the configuration parameter &lt;code&gt;&lt;a href=&quot;#memsup_improved_system_memory_data&quot;&gt;memsup_improved_system_memory_data&lt;/a&gt;&lt;/code&gt; has been set to &lt;code&gt;false&lt;/code&gt; which currently also is the default behavior. If the configuration parameter is set to &lt;code&gt;true&lt;/code&gt; the behavior is slightly changed:</source>
          <target state="translated">上面描述了如何将配置参数 &lt;code&gt;&lt;a href=&quot;#memsup_improved_system_memory_data&quot;&gt;memsup_improved_system_memory_data&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; （当前也是默认行为）的工作方式。如果配置参数设置为 &lt;code&gt;true&lt;/code&gt; ,则行为会稍有变化：</target>
        </trans-unit>
        <trans-unit id="45b0784fdfa3b2b86ccd9506530ebe25156cc75c" translate="yes" xml:space="preserve">
          <source>The above domains are used for logs originating from Erlang/OTP. D1 specifies that the log event comes from Erlang/OTP in general, and D2 indicates that the log event is a so called &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上域用于源自Erlang / OTP的日志。D1指定日志事件通常来自Erlang / OTP，而D2指定日志事件是所谓的 &lt;code&gt;&lt;a href=&quot;logger_chapter#sasl_reports&quot;&gt;SASL report&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ad528c9654cb6b91e6a15396b85e360c22694a9" translate="yes" xml:space="preserve">
          <source>The above function specification uses multiple occurrences of the same type variable. That provides more type information than the following function specification, where the type variables are missing:</source>
          <target state="translated">上述函数规范使用了同一类型变量的多次出现。这比下面的函数说明提供了更多的类型信息,在下面的函数说明中没有类型变量。</target>
        </trans-unit>
        <trans-unit id="6b3999c12af345ea4567453a651d6ad765544220" translate="yes" xml:space="preserve">
          <source>The above line will create a &lt;code&gt;TAGS&lt;/code&gt; file covering all the Erlang source files in the current directory, and in the subdirectories below.</source>
          <target state="translated">上一行将创建一个 &lt;code&gt;TAGS&lt;/code&gt; 文件，该文件覆盖当前目录以及下面的子目录中的所有Erlang源文件。</target>
        </trans-unit>
        <trans-unit id="e341eaf056f6757aa8744bf39e8ccfa82e2460c2" translate="yes" xml:space="preserve">
          <source>The above problem can also be solved as follows:</source>
          <target state="translated">上述问题也可以用以下方法解决。</target>
        </trans-unit>
        <trans-unit id="492aee09cf585dc36dd1c47f1f73ebd941b86f64" translate="yes" xml:space="preserve">
          <source>The above publications can be found at &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上出版物可在 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org&quot;&gt;IETF&lt;/a&gt;&lt;/code&gt; 上找到。</target>
        </trans-unit>
        <trans-unit id="5dbb531e49f3781328d131d1418c3fc6c34074de" translate="yes" xml:space="preserve">
          <source>The above requirements makes the private task data structure a rather complex data structure. It has a queue of unprocessed tasks, and a busy queue. The busy queue contains blocked tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals, and tasks with dependencies to such tasks. The busy queue is accompanied by a table over blocked tasks based on sender with a references into last task in the busy queue from a specific sender. This since we need check for dependencies when new tasks are processed in the queue of unprocessed tasks. When a new task is processed that needs to be blocked it isn't enqueued at the end of the busy queue, but instead directly after the last task with the same sender. This in order to easily be able to detect when we have tasks that no longer have any dependencies to tasks corresponding to &lt;code&gt;command&lt;/code&gt; signals which should be moved out of the busy queue. When the port executes, it switches between processing tasks from the busy queue, and processing directly from the unprocessed queue based on its busy state. When processing directly from the unprocessed queue it might, of course, have to move a task into the busy queue instead of executing it.</source>
          <target state="translated">上述要求使私有任务数据结构成为相当复杂的数据结构。它有一个未处理的任务队列和一个繁忙的队列。繁忙队列包含与 &lt;code&gt;command&lt;/code&gt; 信号相对应的阻塞任务，以及与此类任务相关的任务。繁忙队列随附一张基于发件人的被阻止任务的表格，并带有对特定发件人的繁忙队列中最后一个任务的引用。这是因为当在未处理任务的队列中处理新任务时，我们需要检查依赖性。处理需要阻止的新任务时，它不会在繁忙队列的末尾排队，而是直接在最后一个任务与同一发送者之后排队。这样可以很容易地检测到我们何时有不再与之相对应的任务有任何依赖关系的任务 &lt;code&gt;command&lt;/code&gt; 信号，应将其移出繁忙队列。当端口执行时，它将根据繁忙状态在繁忙队列的处理任务和未处理队列的处理之间切换。当然，当直接从未处理的队列进行处理时，可能必须将任务移到繁忙的队列中而不是执行它。</target>
        </trans-unit>
        <trans-unit id="9d1f97ecba7e65750e03299b0da63791177dd464" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt; Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;release_handler:install_release/1&lt;/code&gt; 之后，上面的返回值和输出表示 &lt;code&gt;release_handler&lt;/code&gt; 通过使用 &lt;code&gt;heart&lt;/code&gt; 重新启动了节点。当升级涉及更改应用程序ERTS，内核，STDLIB或SASL时，始终会执行此操作。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt; Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="425de3e4a3c3f31918aace8062226e8cca18ed8a" translate="yes" xml:space="preserve">
          <source>The above return value and output after the call to &lt;code&gt;release_handler:install_release/1&lt;/code&gt; means that the &lt;code&gt;release_handler&lt;/code&gt; has restarted the node by using &lt;code&gt;heart&lt;/code&gt;. This is always done when the upgrade involves a change of the applications ERTS, Kernel, STDLIB, or SASL. For more information, see &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;release_handler:install_release/1&lt;/code&gt; 之后，上面的返回值和输出意味着 &lt;code&gt;release_handler&lt;/code&gt; 通过使用 &lt;code&gt;heart&lt;/code&gt; 重新启动了节点。当升级涉及更改应用程序ERTS，内核，STDLIB或SASL时，始终会执行此操作。有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;upgrade&quot;&gt;Upgrade when Erlang/OTP has Changed&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7341074eb758fc408da665455635aa8abe3e6546" translate="yes" xml:space="preserve">
          <source>The above sequence did only describe adding a new breakpoint. We do basically the same sequence to update the settings of an existing breakpoint except step 2,3 and 6 can be skipped as it has already been done.</source>
          <target state="translated">上面的顺序只是描述了添加一个新的断点。我们更新现有断点设置的顺序基本相同,只是步骤2、3和6可以跳过,因为已经完成了。</target>
        </trans-unit>
        <trans-unit id="c6d29da5725e5abb5aa97c7b81d06a71c4261fa3" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of memory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">上面的口号是Erlang终止的更常见原因之一。由于未知原因，Erlang运行系统无法分配要使用的内存。发生这种情况时，将生成故障转储，其中包含有关系统内存不足时的状态的信息。使用 &lt;code&gt;crashdump_viewer&lt;/code&gt; 可以查看正在使用的内存。查找具有大堆或许多消息，大ets表等的进程。</target>
        </trans-unit>
        <trans-unit id="782b35684c4c327f6b3806c4707f7ff71cfb9ed8" translate="yes" xml:space="preserve">
          <source>The above slogan is one of the more common reasons for Erlang to terminate. For unknown reasons the Erlang Run-Time System failed to allocate memory to use. When this happens a crash dump is generated that contains information about the state of the system as it ran out of mmeory. Use the &lt;code&gt;crashdump_viewer&lt;/code&gt; to get a view of the memory is being used. Look for processes with large heaps or many messages, large ets tables, etc.</source>
          <target state="translated">以上口号是Erlang终止的更常见原因之一。由于未知原因，Erlang运行系统无法分配要使用的内存。发生这种情况时，将生成故障转储，其中包含有关系统耗尽内存时系统状态的信息。使用 &lt;code&gt;crashdump_viewer&lt;/code&gt; 可以查看正在使用的内存。查找具有大堆或许多消息，大ets表等的进程。</target>
        </trans-unit>
        <trans-unit id="a934d4536371eb6354c38319c0a6fa99eadfdfc1" translate="yes" xml:space="preserve">
          <source>The absence of warnings does not mean that there are no remaining errors in the code.</source>
          <target state="translated">没有警告并不意味着代码中没有其余错误。</target>
        </trans-unit>
        <trans-unit id="52e22f3960de9276ce93c1885ad7150854270f91" translate="yes" xml:space="preserve">
          <source>The absolute path of directory &lt;code&gt;chat_server/ebin&lt;/code&gt; is here passed to the code server. This is essential because relative paths are stored by the code server as relative, and &lt;code&gt;Common Test&lt;/code&gt; changes the current working directory of ERTS during the test run.</source>
          <target state="translated">目录 &lt;code&gt;chat_server/ebin&lt;/code&gt; 的绝对路径在此处传递到代码服务器。这是必不可少的，因为代码服务器将相对路径存储为相对路径，并且 &lt;code&gt;Common Test&lt;/code&gt; 在测试运行期间会更改ERTS的当前工作目录。</target>
        </trans-unit>
        <trans-unit id="30fdf1cb46294b863f8e4eaed5259c72435c637c" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt; erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">计时器设置为到期的绝对时间点必须在 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt; erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 间隔内。如果指定了相对时间，则&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 值不允许为负。</target>
        </trans-unit>
        <trans-unit id="5539aa6980c3b1d4dc664f3e80f8e7768512fe3a" translate="yes" xml:space="preserve">
          <source>The absolute point in time, the timer is set to expire on, must be in the interval &lt;code&gt;[&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;. If a relative time is specified, the &lt;code&gt;Time&lt;/code&gt; value is not allowed to be negative.</source>
          <target state="translated">计时器设置为到期的绝对时间点必须在 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_end_time&quot;&gt;erlang:system_info(end_time)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 间隔内。如果指定了相对时间，则&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 值不允许为负。</target>
        </trans-unit>
        <trans-unit id="e18029dc4fbc0a03d56e79bb7184953e3744a063" translate="yes" xml:space="preserve">
          <source>The abstract layer (defined in &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;) is nicely structured and the node types are context-independent. The layer makes it possible to transparently attach source-code comments and user annotations to nodes of the tree. Using the abstract layer makes applications less sensitive to changes in the &lt;code&gt;erl_parse(3)&lt;/code&gt; data structures, only requiring the &lt;code&gt;erl_syntax&lt;/code&gt; module to be up-to-date.</source>
          <target state="translated">抽象层（在 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 中定义）结构良好，并且节点类型与上下文无关。该层使透明地将源代码注释和用户注释附加到树的节点成为可能。使用抽象层使应用程序对 &lt;code&gt;erl_parse(3)&lt;/code&gt; 数据结构的更改不那么敏感，只需要 &lt;code&gt;erl_syntax&lt;/code&gt; 模块即可。</target>
        </trans-unit>
        <trans-unit id="56d4f99e44e9cb3cc0a8743c790ec2277cddaac6" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">接受套接字继承了设置的选项 &lt;code&gt;ListenSocket&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ebbf813506aec9cb5b7febd24547c187a92185e" translate="yes" xml:space="preserve">
          <source>The accepted socket inherits the options set for &lt;code&gt;ListenSocket&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">接受套接字继承了设置的选项 &lt;code&gt;ListenSocket&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6c1f48a70d3a03fcd08b9ecaf840df566c82062" translate="yes" xml:space="preserve">
          <source>The ack_action() is either:</source>
          <target state="translated">ack_action()要么是。</target>
        </trans-unit>
        <trans-unit id="4df5499b046a3caa5c00b3bf34cda3b59c95dee6" translate="yes" xml:space="preserve">
          <source>The ack_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">这个函数的ack_data()参数是由handle_trans_request/3返回的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="573fc48700bb83712fa26ae3db5f4a997f5bdf7a" translate="yes" xml:space="preserve">
          <source>The action to take when the Erlang emulator stops unexpectedly. Default is to ignore.</source>
          <target state="translated">当Erlang模拟器意外停止时要采取的行动。默认为忽略。</target>
        </trans-unit>
        <trans-unit id="0321983ca2ab7b420ed8780bad63ee4e244c660a" translate="yes" xml:space="preserve">
          <source>The actual behavior of compiled match specifications when recreated from external format has changed and may change in future releases, but this interface remains for backward compatibility. See &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从外部格式重新创建时，已编译的匹配规范的实际行为已更改，并且在将来的发行版中可能会更改，但是保留此接口是为了向后兼容。参见 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40fdcbc6206b95ef9655638b626a5128e3d5dc2c" translate="yes" xml:space="preserve">
          <source>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</source>
          <target state="translated">实际的编码信息已经收集在每个编码类型的一个目录中,每个编码信息包含一个文件。</target>
        </trans-unit>
        <trans-unit id="1c694608beedd90d5cb7943b28c1a84362940fa0" translate="yes" xml:space="preserve">
          <source>The actual encryption or decryption is done by &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; ).</source>
          <target state="translated">实际的加密或解密由 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; ）完成。</target>
        </trans-unit>
        <trans-unit id="e7fed2c92bea1fa55e85c9f8695c1f69a2c7262b" translate="yes" xml:space="preserve">
          <source>The actual implementation of instructions are also defined in &lt;code&gt;.tab&lt;/code&gt; files processed by &lt;strong&gt;beam_makeops&lt;/strong&gt;. For practical reasons, instruction definitions are stored in several files, at the time of writing in the following files:</source>
          <target state="translated">指令的实际实现方式也在 &lt;code&gt;.tab&lt;/code&gt; 处理的&lt;strong&gt;.tab&lt;/strong&gt;文件中定义。出于实际原因，在编写以下文件时，指令定义存储在多个文件中：</target>
        </trans-unit>
        <trans-unit id="bbf119f15e4a3e4c9e43ba3da03845ee142277be" translate="yes" xml:space="preserve">
          <source>The actual message returned by the RPC server is a 2-tuple &lt;code&gt;{rex,Reply}&lt;/code&gt;. If you use &lt;code&gt;erl_rpc_from()&lt;/code&gt; in your code, this is the message you will need to parse. If you use &lt;code&gt;erl_rpc()&lt;/code&gt;, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing &lt;code&gt;Reply&lt;/code&gt; only. Replies to RPC requests are always &lt;code&gt;ERL_SEND&lt;/code&gt; messages.</source>
          <target state="translated">RPC服务器返回的实际消息是2元组 &lt;code&gt;{rex,Reply}&lt;/code&gt; 。如果在代码中使用 &lt;code&gt;erl_rpc_from()&lt;/code&gt; ，则需要解析此消息。如果使用 &lt;code&gt;erl_rpc()&lt;/code&gt; ，则将为您分析元组本身，并且返回给程序的消息是仅包含 &lt;code&gt;Reply&lt;/code&gt; 的Erlang术语。对RPC请求的回复始终是 &lt;code&gt;ERL_SEND&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3f712073d78ceb80ba4691c57506456b575aeca2" translate="yes" xml:space="preserve">
          <source>The actual number of fragments</source>
          <target state="translated">碎片的实际数量</target>
        </trans-unit>
        <trans-unit id="605930eb2c9eb4fbbdc869cc2d2017c67143a7b6" translate="yes" xml:space="preserve">
          <source>The actual padding is performed by &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">实际的填充由 &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; 执行。</target>
        </trans-unit>
        <trans-unit id="4322cef184ec5aecf9faa18423df4ee550bc1ca0" translate="yes" xml:space="preserve">
          <source>The actual supervision of execution times is in itself a CPU intensive activity. A message is written on the trace file for every function call that is made by the profiled code.</source>
          <target state="translated">对执行时间的实际监督本身就是一项CPU密集型活动。每当被剖析的代码调用一个函数,就会在跟踪文件中写下一条信息。</target>
        </trans-unit>
        <trans-unit id="d6518471a4a1665322d5954e6611844bc734d8cd" translate="yes" xml:space="preserve">
          <source>The actual supported algorithms and features depends on their availability in the actual libcrypto used. See the &lt;code&gt;crypto (App)&lt;/code&gt; about dependencies.</source>
          <target state="translated">实际支持的算法和功能取决于所使用的实际libcrypto中的可用性。有关依赖关系，请参阅 &lt;code&gt;crypto (App)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95a53d335d6385335f1d9907f4b8a879470a71f4" translate="yes" xml:space="preserve">
          <source>The actual supported named curves could be checked by examining the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(curves)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过检查 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(curves)&lt;/a&gt;&lt;/code&gt; 返回的列表来检查实际支持的命名曲线。</target>
        </trans-unit>
        <trans-unit id="4d3571545f798bc55c8050de98e521a38384a9d2" translate="yes" xml:space="preserve">
          <source>The actual timer time.</source>
          <target state="translated">实际的定时器时间。</target>
        </trans-unit>
        <trans-unit id="27345ee3cabb8f446fd8fd55e223fda324b5bab0" translate="yes" xml:space="preserve">
          <source>The actual value is the quoted atom &lt;code&gt;'NULL'&lt;/code&gt;.</source>
          <target state="translated">实际值是引用的原子 &lt;code&gt;'NULL'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72f4263f7e8c1e5785af3ae16a212b694d638c6" translate="yes" xml:space="preserve">
          <source>The address and port of the other end of the connection.</source>
          <target state="translated">连接另一端的地址和端口。</target>
        </trans-unit>
        <trans-unit id="5ae3afdabf8d69b7f030903f34729a4d0a97bc17" translate="yes" xml:space="preserve">
          <source>The address must be the IP address and cannot be the hostname.</source>
          <target state="translated">地址必须是IP地址,不能是主机名。</target>
        </trans-unit>
        <trans-unit id="45c66a6604fd97ae44d5625424f5836d3c3179c8" translate="yes" xml:space="preserve">
          <source>The address of the fun's code when HiPE is enabled.</source>
          <target state="translated">启用HiPE后,fun的代码地址。</target>
        </trans-unit>
        <trans-unit id="7ddf5f9487a859a28b6ed4d37dd3d9bebe9f2f6a" translate="yes" xml:space="preserve">
          <source>The address of the fun's code.</source>
          <target state="translated">趣的代码的地址。</target>
        </trans-unit>
        <trans-unit id="7e8bf572fd0f0bc243c5923805f5fb20ef2fe37e" translate="yes" xml:space="preserve">
          <source>The address specified in &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; overwrites the primary peer address</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 中指定的地址将覆盖主要对等地址</target>
        </trans-unit>
        <trans-unit id="ba449fc5f30a23d575fa4c4396e275fa504dce46" translate="yes" xml:space="preserve">
          <source>The adjustment of system time could have been made smother than using a time warp approach, but we think that would be a bad choice. As we can express and measure time that is not connected to calendar time by the use of Erlang monotonic time, it is better to expose the change in Erlang system time immediately. This as the Erlang applications executing on the system can react on the change in system time as soon as possible. This is also more or less exactly how most operating systems handle this (OS monotonic time and OS system time). By adjusting system time smoothly, we would just hide the fact that system time changed and make it harder for the Erlang applications to react to the change in a sensible way.</source>
          <target state="translated">系统时间的调整本来可以比使用时间翘曲的方法做得更闷,但我们认为那是一个不好的选择。因为我们可以通过使用Erlang单调时间来表达和测量与日历时间无关的时间,所以最好是立即暴露Erlang系统时间的变化。因为在系统上执行的Erlang应用可以尽快对系统时间的变化做出反应。这也差不多正是大多数操作系统的处理方式(操作系统单调时间和操作系统系统时间)。如果顺利地调整系统时间,我们只会掩盖系统时间变化的事实,让Erlang应用程序更难以合理的方式对变化做出反应。</target>
        </trans-unit>
        <trans-unit id="5f9472dc1436a5862ca0454404828318f9e56d1f" translate="yes" xml:space="preserve">
          <source>The advantage of using an extensible (agent/manager) toolkit is to remove details such as type-checking, access rights, Protocol Data Unit (PDU), encoding, decoding, and trap distribution from the programmer, who only has to write the instrumentation functions, which implement the MIBs. The &lt;code&gt;get-next&lt;/code&gt; function only has to be implemented for tables, and not for every variable in the global naming tree. This information can be deduced from the ASN.1 file.</source>
          <target state="translated">使用可扩展的（代理程序/管理器）工具包的优点是从程序员那里删除了细节，例如类型检查，访问权限，协议数据单元（PDU），编码，解码和陷阱分发，而程序员只需要编写工具即可。实现MIB的功能。在 &lt;code&gt;get-next&lt;/code&gt; 功能只需要实现对表，而不是在全球的命名树中的每个变量。该信息可以从ASN.1文件中推导出。</target>
        </trans-unit>
        <trans-unit id="9fe8e4ddaca688413966f57d082a8c9a7e076fe3" translate="yes" xml:space="preserve">
          <source>The advantages of separating the table coordinator from the SNMP tool are:</source>
          <target state="translated">将表协调器与SNMP工具分开的好处是:</target>
        </trans-unit>
        <trans-unit id="1e3ed41d7fd39c63d6b7f432ea91d01107779b41" translate="yes" xml:space="preserve">
          <source>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</source>
          <target state="translated">在恢复过程中,受影响的表被写锁定。然而,无论由此引起的锁冲突如何,应用程序都可以在恢复过程中继续工作。恢复是作为一个单一事务进行的。</target>
        </trans-unit>
        <trans-unit id="eeb577e64047dee54287b4297431d9c8f5676c03" translate="yes" xml:space="preserve">
          <source>The age is defined in milliseconds.</source>
          <target state="translated">年龄以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="e7020aa85de45cdbfd0f6571b7cc03a6fded1bbd" translate="yes" xml:space="preserve">
          <source>The agent and manager uses (application) configuration parameters to find out where these directories are located. The parameters should be defined in an Erlang system configuration file. The following configuration parameters are defined for the SNMP application:</source>
          <target state="translated">代理和管理器使用(应用程序)配置参数来找出这些目录的位置。这些参数应该在Erlang系统配置文件中定义。以下是为SNMP应用定义的配置参数。</target>
        </trans-unit>
        <trans-unit id="532498afa1ab407c6e18b6c76c06f1a8f9021335" translate="yes" xml:space="preserve">
          <source>The agent can be configured to be multi-threaded, to process one incoming request at a time, or to have a request limit enabled (this can be used for load control or to limit the effect of DoS attacks). If it is multi-threaded, read requests (&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and &lt;code&gt;get-bulk&lt;/code&gt;) and traps are processed in parallel with each other and &lt;code&gt;set&lt;/code&gt; requests. However, all &lt;code&gt;set&lt;/code&gt; requests are serialized, which means that if the agent is waiting for the application to complete a complicated write operation, it will not process any new write requests until this operation is finished. It processes read requests and sends traps, concurrently. The reason for not handle write requests in parallel is that a complex locking mechanism would be needed even in the simplest cases. Even with the scheme described above, the user must be careful not to violate that the &lt;code&gt;set&lt;/code&gt; requests are atoms. If this is hard to do, do not use the multi-threaded feature.</source>
          <target state="translated">可以将代理配置为多线程，一次处理一个传入请求，或启用请求限制（可用于负载控制或限制DoS攻击的影响）。如果它是多线程的，则读取请求（ &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;get-next&lt;/code&gt; 和 &lt;code&gt;get-bulk&lt;/code&gt; ）和陷阱将彼此并行处理并 &lt;code&gt;set&lt;/code&gt; 请求。但是，所有 &lt;code&gt;set&lt;/code&gt; 请求被序列化，这意味着如果代理程序正在等待应用程序完成复杂的写操作，则在此操作完成之前，它将不处理任何新的写请求。它同时处理读取请求并发送陷阱。无法并行处理写请求的原因是，即使在最简单的情况下，也需要复杂的锁定机制。即使采用上述方案，用户也必须注意不要违反 &lt;code&gt;set&lt;/code&gt; 请求是原子的。如果很难做到这一点，请不要使用多线程功能。</target>
        </trans-unit>
        <trans-unit id="1765275ae72c3c73846eb96f701861af075a2ade" translate="yes" xml:space="preserve">
          <source>The agent can both perform and respond to discovery.</source>
          <target state="translated">代理人既可以执行也可以响应发现。</target>
        </trans-unit>
        <trans-unit id="5fab26e9897ff23218adb34fca8afc8ac6df806b" translate="yes" xml:space="preserve">
          <source>The agent can spontaneously send a notification, for example, an alarm, to the manager.</source>
          <target state="translated">代理商可以自发的向经理发送通知,例如报警。</target>
        </trans-unit>
        <trans-unit id="d42efd7983ea3f540eeeb3f75427cd0a119a5f44" translate="yes" xml:space="preserve">
          <source>The agent communication is established through a UNIX domain socket. By default, the socket path will be fetched from the &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; enviroment variable, which is the default socket path in the agent implementation of &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">代理通信是通过UNIX域套接字建立的。默认情况下，将从 &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; 环境变量获取套接字路径，这是 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 代理实现中的默认套接字路径。</target>
        </trans-unit>
        <trans-unit id="88e6c01b1d22bf1009d4f112f5ef241f146f87bc" translate="yes" xml:space="preserve">
          <source>The agent does not check complex ranges specified for INTEGER objects. In these cases it just checks that the value lies within the minimum and maximum values specified. For example, if the range is specified as &lt;code&gt;1..10 | 12..20&lt;/code&gt; the agent would let 11 through, but not 0 or 21. The instrumentation functions must check the complex ranges itself.</source>
          <target state="translated">代理不检查为INTEGER对象指定的复杂范围。在这些情况下，它仅检查该值是否在指定的最小值和最大值之内。例如，如果范围指定为 &lt;code&gt;1..10 | 12..20&lt;/code&gt; ，代理将允许11通过，但不允许0或21。仪表功能必须检查复杂范围本身。</target>
        </trans-unit>
        <trans-unit id="821394aba5a85ee9b738eccc0b641e5e87f98f1d" translate="yes" xml:space="preserve">
          <source>The agent information should be stored in a file called &lt;code&gt;agent.conf&lt;/code&gt;.</source>
          <target state="translated">代理程序信息应存储在名为 &lt;code&gt;agent.conf&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="7d5c2b0ecab378b92db71d78b459615c0be2b937" translate="yes" xml:space="preserve">
          <source>The agent is an entity that executes within a &lt;strong&gt;Network Element (NE)&lt;/strong&gt;. In OTP, the NE can be a distributed system, meaning that the distributed system is managed as one entity. Of course, the agent can be configured to be able to run on one of several nodes, making it a distributed OTP application.</source>
          <target state="translated">代理是在&lt;strong&gt;网络元素（NE）&lt;/strong&gt;中执行的实体。在OTP中，NE可以是分布式系统，这意味着分布式系统作为一个实体进行管理。当然，可以将代理配置为能够在多个节点之一上运行，从而使其成为分布式OTP应用程序。</target>
        </trans-unit>
        <trans-unit id="b3d395baa2a805befd96447c7ba7e7fb38c483ae" translate="yes" xml:space="preserve">
          <source>The agent is configured with the configuration tool, using default suggestions for everything but the manager node.</source>
          <target state="translated">代理商是用配置工具配置的,除了经理节点外,其他都使用默认建议。</target>
        </trans-unit>
        <trans-unit id="bafc8c1a76725000dfff5c337a6c7efd569cd586" translate="yes" xml:space="preserve">
          <source>The agent is highly fault tolerant. If the manager gets an unexpected response from the agent, it is possible that some instrumentation function has returned an erroneous value. The agent will not crash even if the instrumentation does. It should be noted that if an instrumentation function enters an infinite loop, the agent will also be blocked forever. The supervisor ,or the application, specifies how to restart the agent.</source>
          <target state="translated">代理商具有高度的容错性。如果管理器从代理中得到一个意外的响应,可能是某个工具函数返回了一个错误的值。即使工具化函数发生了错误,代理也不会崩溃。需要注意的是,如果某个工具函数进入了无限循环,代理也将永远被阻塞。上级或应用程序指定如何重新启动代理。</target>
        </trans-unit>
        <trans-unit id="2c7ad18cc20a9d278d188273b0ceb93f154abb8c" translate="yes" xml:space="preserve">
          <source>The agent receives a request and maps it to calls to one or more instrumentation functions. These functions perform operations on the resources to implement the semantics associated with the MO.</source>
          <target state="translated">代理接收请求并将其映射到对一个或多个工具函数的调用。这些函数对资源进行操作,以实现与MO相关的语义。</target>
        </trans-unit>
        <trans-unit id="5394a28e8aa26b89d2b8f393dd3cca2d7c380d89" translate="yes" xml:space="preserve">
          <source>The agent responds to discovery autonomously, without interaction by the user.</source>
          <target state="translated">代理商自主响应发现,无需用户互动。</target>
        </trans-unit>
        <trans-unit id="ebd412ca77c13dc418b2ee47def2c221adc4c0fa" translate="yes" xml:space="preserve">
          <source>The agent started is called &lt;code&gt;snmp_master_agent&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; to load MIBs into the agent.</source>
          <target state="translated">启动的代理称为 &lt;code&gt;snmp_master_agent&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#load_mibs-1&quot;&gt;ct_snmp:load_mibs/1&lt;/a&gt;&lt;/code&gt; 将MIB加载到代理中。</target>
        </trans-unit>
        <trans-unit id="35fefa07539d964d08302d135b6a045a731feaec" translate="yes" xml:space="preserve">
          <source>The agent stores the values in an internal volatile database, which is based on the standard module &lt;code&gt;ets&lt;/code&gt;. However, it is possible to let the MIB compiler generate functions which use an internal, persistent database, or the Mnesia DBMS. Refer to the Mnesia User Guide and the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for more information.</source>
          <target state="translated">代理将值存储在内部易失性数据库中，该数据库基于标准模块 &lt;code&gt;ets&lt;/code&gt; 。但是，可以让MIB编译器生成使用内部持久数据库或Mnesia DBMS的函数。有关更多信息，请参阅《 Mnesia用户指南》和《参考手册》的&amp;ldquo; SNMP&amp;rdquo;模块 &lt;code&gt;snmp_generic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88cd9d752952f90596dc3746023ba01fb085191a" translate="yes" xml:space="preserve">
          <source>The agent will never generate the &lt;code&gt;wrongEncoding&lt;/code&gt; error. If a variable binding is erroneous encoded, the &lt;code&gt;asn1ParseError&lt;/code&gt; counter will be incremented.</source>
          <target state="translated">代理将永远不会产生错误的 &lt;code&gt;wrongEncoding&lt;/code&gt; 错误。如果变量绑定的编码错误，则 &lt;code&gt;asn1ParseError&lt;/code&gt; 计数器将增加。</target>
        </trans-unit>
        <trans-unit id="31dc2849b5514caeb8ae4f58e7cc8579c0d02b0d" translate="yes" xml:space="preserve">
          <source>The alarm handler is part of the SASL application.</source>
          <target state="translated">报警处理程序是SASL应用程序的一部分。</target>
        </trans-unit>
        <trans-unit id="f225b02b835111c249a55da204c91a4c1ca4bd60" translate="yes" xml:space="preserve">
          <source>The alarm handler process is a &lt;code&gt;gen_event&lt;/code&gt; event manager process that receives alarms in the system. This process is not intended to be a complete alarm handler. It defines a place to which alarms can be sent. One simple event handler is installed in the alarm handler at startup, but users are encouraged to write and install their own handlers.</source>
          <target state="translated">警报处理程序进程是 &lt;code&gt;gen_event&lt;/code&gt; 事件管理器进程，该进程在系统中接收警报。此过程并非旨在成为完整的警报处理程序。它定义了可以将警报发送到的位置。启动时在警报处理程序中安装了一个简单的事件处理程序，但是鼓励用户编写和安装自己的处理程序。</target>
        </trans-unit>
        <trans-unit id="9a1c34ac82f222f7bf20fdb60c9c70070554269a" translate="yes" xml:space="preserve">
          <source>The alarms are cleared automatically when the alarm cause is no longer valid.</source>
          <target state="translated">当报警原因不再有效时,报警会自动清除。</target>
        </trans-unit>
        <trans-unit id="986d3b30b24eb7709dfdc0693fd6abc2a7ec4e8c" translate="yes" xml:space="preserve">
          <source>The algorithm for updating &lt;code&gt;Serial&lt;/code&gt; can be described as follows:</source>
          <target state="translated">&lt;code&gt;Serial&lt;/code&gt; 更新算法可以描述如下：</target>
        </trans-unit>
        <trans-unit id="4dd9a185b05bfc6c5aca5b3488aeb8d588a949ea" translate="yes" xml:space="preserve">
          <source>The algorithm for wich the fun should implement the special matching rules</source>
          <target state="translated">乐趣的算法应该实现特殊的匹配规则。</target>
        </trans-unit>
        <trans-unit id="7bb19b504df5c1a9303c7a6f511b1fc2dc8c9766" translate="yes" xml:space="preserve">
          <source>The algorithm in &lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; is md5 to be compatible with older ssh-keygen commands. The string from the second variant is prepended by the algorithm name in uppercase as in newer ssh-keygen commands.</source>
          <target state="translated">&lt;code&gt;ssh_hostkey_fingerprint/1&lt;/code&gt; 中的算法为md5，以与较早的ssh-keygen命令兼容。与较新的ssh-keygen命令一样，第二个变体的字符串由算法名称大写。</target>
        </trans-unit>
        <trans-unit id="b2f989a67b5ca0281a96030c126b7a3d77ef6b31" translate="yes" xml:space="preserve">
          <source>The algorithm is a modification of the version attributed to Richard A. O'Keefe in the standard Prolog library.</source>
          <target state="translated">该算法是对标准Prolog库中Richard A.O'Keefe版本的修改。</target>
        </trans-unit>
        <trans-unit id="7f680b0d6e8d6f4e75e82db44978468dc45a6e99" translate="yes" xml:space="preserve">
          <source>The algorithm is the same as for send above.</source>
          <target state="translated">算法与上面的发送相同。</target>
        </trans-unit>
        <trans-unit id="230091aa46aa0a9b37e9fd8c10519ddfe76dd814" translate="yes" xml:space="preserve">
          <source>The algorithm that is used to draw a graph with as few crossed links as possible is called force graph. A force graph consists of nodes and directed links between nodes. Each node is associated with a repulsive force that pushes nodes away from each other. This force can be adjusted with the left slider or with the mouse wheel. Each link is associated with an attractive force that pulls the nodes nearer to each other. This force can be adjusted with the right slider. If this force becomes too strong, the graph will be unstable. The third parameter that can be adjusted is the length of the links. It is adjusted with the middle slider.</source>
          <target state="translated">用来绘制一个尽可能少的交叉链接的图的算法称为力图。力图由节点和节点之间的定向链接组成。每个节点都与一个排斥力相关联,这个排斥力将节点相互推开。这个力可以通过左边的滑块或鼠标滚轮来调整。每个链接都与一个吸引力相关联,它将节点拉近彼此。这个力可以用右边的滑块来调整。如果这个力变得太强,图形将不稳定。第三个可以调整的参数是链接的长度。它是用中间的滑块调整的。</target>
        </trans-unit>
        <trans-unit id="e0be3089ed3cdab42290e47bafffab640f5507bb" translate="yes" xml:space="preserve">
          <source>The algorithms should be in the preferred order. Selected signature algorithm can restrict which hash functions that may be selected. Default support for {md5, rsa} removed in ssl-8.0</source>
          <target state="translated">算法应按优先顺序排列。选择的签名算法可以限制可以选择哪些哈希函数。在ssl-8.0中删除了对{md5,rsa}的默认支持。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
