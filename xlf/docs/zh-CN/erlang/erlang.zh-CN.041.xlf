<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="b1514fe84ab0f4ebd6e6cad9a7b7bbf021b9cbbe" translate="yes" xml:space="preserve">
          <source>The registered name, if any. If a registered name is not displayed, it can be that Debugger received information about the process before the name was registered. Try selecting &lt;strong&gt;Edit &amp;gt; Refresh&lt;/strong&gt;.</source>
          <target state="translated">注册名称（如果有）。如果未显示注册名称，则可能是调试器在注册名称之前已收到有关进程的信息。尝试选择&amp;ldquo; &lt;strong&gt;编辑&amp;rdquo;&amp;gt;&amp;ldquo;刷新&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="253fb5321acafacd5bcd81a207e0260e1e20f165" translate="yes" xml:space="preserve">
          <source>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. For any action resulting in a change to the global name table, all tables on other nodes are automatically updated.</source>
          <target state="translated">注册的名称存储在每个节点上的复制全局名称表中。没有中央存储点。因此,姓名到pid的转换非常快,因为它总是在本地完成。对于任何导致改变全局名称表的行动,其他节点上的所有表都会自动更新。</target>
        </trans-unit>
        <trans-unit id="b656ecffd1ced10be89c73c0264120c641a1a963" translate="yes" xml:space="preserve">
          <source>The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type.</source>
          <target state="translated">注册表包含键和值。键就像文件系统中的目录,它们形成一个层次结构。值就像文件,它们有一个名称和一个值,还有一个类型。</target>
        </trans-unit>
        <trans-unit id="0f19e0edc2bdf4a111b804cb06a4a4fda7a24377" translate="yes" xml:space="preserve">
          <source>The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs.</source>
          <target state="translated">注册表是一个分层数据库,用于存储Windows中的各种系统和软件信息。它包含安装数据,并由安装程序和系统程序进行更新。Erlang安装程序通过添加Erlang需要的数据来更新注册表。</target>
        </trans-unit>
        <trans-unit id="a1df08771ef4b4eb79805f54d0af976d930c81c1" translate="yes" xml:space="preserve">
          <source>The registry must have been opened in write mode.</source>
          <target state="translated">注册表必须以写模式打开。</target>
        </trans-unit>
        <trans-unit id="3e31d2327ae3a594ef721ad76afd4e76d34b773c" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;(|at)&lt;/code&gt; first match at the initial position of string &lt;code&gt;cat&lt;/code&gt;, giving the result set &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; (the second &lt;code&gt;{0,0}&lt;/code&gt; is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</source>
          <target state="translated">正则表达式 &lt;code&gt;(|at)&lt;/code&gt; 首先在字符串 &lt;code&gt;cat&lt;/code&gt; 的初始位置匹配，给出结果集 &lt;code&gt;[{0,0},{0,0}]&lt;/code&gt; （第二个 &lt;code&gt;{0,0}&lt;/code&gt; 是因为用括弧）。由于比赛的长度是0，我们还没有前进到下一个位置。</target>
        </trans-unit>
        <trans-unit id="c67bde651eeeb2e55477d91b265e707252cb8bd3" translate="yes" xml:space="preserve">
          <source>The regular expression is specified as a Unicode &lt;code&gt;charlist()&lt;/code&gt; and the resulting regular expression code is to be run against a valid Unicode &lt;code&gt;charlist()&lt;/code&gt; subject. Also consider option &lt;code&gt;ucp&lt;/code&gt; when using Unicode characters.</source>
          <target state="translated">将正则表达式指定为Unicode &lt;code&gt;charlist()&lt;/code&gt; ,并且将针对有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; 主题运行所得的正则表达式代码。使用Unicode字符时，还应考虑选项 &lt;code&gt;ucp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4b1e3caf6818ade884c58fbfd440b868fffc15b" translate="yes" xml:space="preserve">
          <source>The regular expressions allowed here is a subset of the set found in &lt;code&gt;egrep&lt;/code&gt; and in the AWK programming language, as defined in the book, The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger. They are composed of the following characters:</source>
          <target state="translated">此处允许的正则表达式是在 &lt;code&gt;egrep&lt;/code&gt; 和AWK编程语言中找到的集合的子集，如AV Aho，BW Kernighan，PJ Weinberger所著的《 AWK编程语言》中所定义。它们由以下字符组成：</target>
        </trans-unit>
        <trans-unit id="7f4fcc0ee2bcb5481ad7e8a8560c012d54b3a581" translate="yes" xml:space="preserve">
          <source>The relation of equality between the elements of {a,b,c}:</source>
          <target state="translated">{a,b,c}的元素之间的平等关系。</target>
        </trans-unit>
        <trans-unit id="0c26a1fbdd58094ae590c77744a027cfe086295e" translate="yes" xml:space="preserve">
          <source>The relationships between the predefined variables &lt;code&gt;XU&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and a few others are worth elaborating upon. The reference manual mentions two ways of expressing the set of all functions, one that focuses on how they are defined: &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt;, and one that focuses on how they are used: &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt;. The reference also mentions some &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; about the variables:</source>
          <target state="translated">预定义变量 &lt;code&gt;XU&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和其他一些变量之间的关系值得详细说明。参考手册提到了两种表达所有功能的方法，一种专注于如何定义它们： &lt;code&gt;X&amp;nbsp;+&amp;nbsp;L&amp;nbsp;+&amp;nbsp;B&amp;nbsp;+&amp;nbsp;U&lt;/code&gt; ，另一种专注于如何使用它们： &lt;code&gt;UU&amp;nbsp;+&amp;nbsp;LU&amp;nbsp;+&amp;nbsp;XU&lt;/code&gt; 。该参考资料还提到了有关变量的一些 &lt;code&gt;&lt;a href=&quot;xref#simple_facts&quot;&gt;facts&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="11c6e207d55ada23ec986425dc6bc5e23db12059" translate="yes" xml:space="preserve">
          <source>The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1] &amp;times; ... &amp;times; Y[n]) to Z. The &lt;strong id=&quot;tuple_relative_product&quot;&gt;relative product&lt;/strong&gt; of TR and S is the binary relation T from X to Z defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &amp;lt;= i &amp;lt;= n such that x R[i] y[i] and (y[1], ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1] &amp;times; ... &amp;times; X[n]. The &lt;strong id=&quot;multiple_relative_product&quot;&gt;multiple relative product&lt;/strong&gt; of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n])) for some (x[1], ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &amp;lt;= i &amp;lt;= n}.</source>
          <target state="translated">二进制关系的相对乘积可以概括为n元关系，如下所示。令TR为从X到Y [i]的二元关系的有序集（R [1]，...，R [n]），而S为从（Y [1]&amp;times;...&amp;times;Y [n] TR和S 的&lt;strong id=&quot;tuple_relative_product&quot;&gt;相对乘积&lt;/strong&gt;是从X到Z的二进制关系T，定义为x T z当且仅当在Y [i]中对于每个1 &amp;lt;= i有一个元素y [i] &amp;lt;= n，使得x R [i] y [i]和（y [1]，...，y [n]）S z。现在让TR为从X [i]到Y [i]的二元关系的有序集合（R [1]，...，R [n]），S为X [1]&amp;times;...&amp;times;的子集。 X [n]。的&lt;strong id=&quot;multiple_relative_product&quot;&gt;多个相对产品&lt;/strong&gt; TR和S的定义为集合{Z：Z =（（X [1]，...，X [n]的），（Y [1]，...，Y [n]的））对于S中的某些（x [1]，...，x [n]）和R [i]中的某些（x [i]，y [i]），1 &amp;lt;= i &amp;lt;= n}。</target>
        </trans-unit>
        <trans-unit id="1a5a729dfd664ee2cc4b65eb400d7906d640d28a" translate="yes" xml:space="preserve">
          <source>The relative product of two functions F1 and F2 is called the &lt;strong id=&quot;composite&quot;&gt;composite&lt;/strong&gt; of F1 and F2 if the range of F1 is a subset of the domain of F2.</source>
          <target state="translated">如果F1的范围是F2域的子集，则两个函数F1和F2的相对乘积称为F1和F2的&lt;strong id=&quot;composite&quot;&gt;复合&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c3e4729853dcefec28c04c62495d1227e52695db" translate="yes" xml:space="preserve">
          <source>The release handler at a node running on a diskless machine, or with a read-only file system, must be configured accordingly using the following SASL configuration parameters (for details, see &lt;code&gt;sasl(6)&lt;/code&gt;):</source>
          <target state="translated">必须使用以下SASL配置参数对在无盘计算机或只读文件系统上运行的节点上的发布处理程序进行相应配置（有关详细信息，请参见 &lt;code&gt;sasl(6)&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="aba90e774f5b7292d69eb5ee7c87083b704de367" translate="yes" xml:space="preserve">
          <source>The release handler can also be used to unpack and install release packages when not running Erlang as an embedded system. However, in this case the user must somehow ensure that correct boot scripts and configuration files are used if the system must be restarted.</source>
          <target state="translated">当不作为嵌入式系统运行Erlang时,release handler也可以用来解压和安装release包,但在这种情况下,用户必须以某种方式确保在系统必须重启时使用正确的启动脚本和配置文件。然而,在这种情况下,如果系统必须重新启动,用户必须以某种方式确保使用正确的启动脚本和配置文件。</target>
        </trans-unit>
        <trans-unit id="1a98562301df489f924334591464c2abdffdac36" translate="yes" xml:space="preserve">
          <source>The release handler evalutes &lt;code&gt;apply(M, F, A)&lt;/code&gt;.</source>
          <target state="translated">释放处理程序评估 &lt;code&gt;apply(M, F, A)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5810b19374ebd0aa36b0ddc3dbb430e23ad41e2" translate="yes" xml:space="preserve">
          <source>The release handler process is a locally registered process on each node. When a release is installed in a distributed system, the release handler on each node must be called. The release installation can be synchronized between nodes. From an operator view, it can be unsatisfactory to specify each node. The aim is to install one release package in the system, no matter how many nodes there are. It is recommended that software management functions are written that take care of this problem. Such a function can have knowledge of the system architecture, so it can contact each individual release handler to install the package.</source>
          <target state="translated">发布处理程序进程是每个节点上的本地注册进程。当在分布式系统中安装一个版本时,必须调用每个节点上的发布处理程序。版本安装可以在节点之间同步。从操作者的角度来看,指定每个节点可能是不满意的。目的是无论有多少个节点,都要在系统中安装一个发布包。建议编写软件管理函数来解决这个问题。这样的函数可以对系统架构有所了解,所以它可以联系每个单独的发布处理程序来安装软件包。</target>
        </trans-unit>
        <trans-unit id="1d789ea08f7bf36cfa8a0d6324e5d810748f8d2a" translate="yes" xml:space="preserve">
          <source>The release handler suspends, asks for code change, and resumes processes by calling the functions &lt;code&gt;sys:suspend/1,2&lt;/code&gt;, &lt;code&gt;sys:change_code/4,5&lt;/code&gt;, and &lt;code&gt;sys:resume/1,2&lt;/code&gt;, respectively.</source>
          <target state="translated">释放处理程序通过分别调用函数 &lt;code&gt;sys:suspend/1,2&lt;/code&gt; ， &lt;code&gt;sys:change_code/4,5&lt;/code&gt; 和 &lt;code&gt;sys:resume/1,2&lt;/code&gt; 来挂起，请求代码更改并恢复进程。</target>
        </trans-unit>
        <trans-unit id="bd503abbdadf3c3e7f2d6dab188fa7588e61f6b8" translate="yes" xml:space="preserve">
          <source>The release handling instructions for adding, removing, and restarting applications apply to primary applications only. There are no corresponding instructions for included applications. However, since an included application is really a supervision tree with a topmost supervisor, started as a child process to a supervisor in the including application, a &lt;code&gt;relup&lt;/code&gt; file can be manually created.</source>
          <target state="translated">有关添加，删除和重新启动应用程序的发行处理说明仅适用于主应用程序。没有附带的应用程序的相应说明。但是，由于包含的应用程序实际上是具有最高主管的监视树，是作为包含应用程序中的主管的子进程启动的，因此可以手动创建 &lt;code&gt;relup&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="3463f0904903fe50d36a8d31b7efcf59b3d94b17" translate="yes" xml:space="preserve">
          <source>The release of a maintenance patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; version while the release of an emergency patch package usually imply an increase of the OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; version. This is however not necessarily always the case since changes of OTP versions are based on the actual changes in the code and not based on whether the patch was planned or not. For more information see the &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; section above.</source>
          <target state="translated">维护补丁包的发布通常意味着OTP &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 版本的增加，而紧急补丁包的发布通常意味着OTP &lt;code&gt;&amp;lt;Patch&amp;gt;&lt;/code&gt; 版本的增加。但是，并非总是如此，因为OTP版本的更改是基于代码的实际更改，而不是基于是否计划了补丁。有关更多信息，请参见上面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="2f38068eb9610d0b0cbd1a9bc480aef4c5039577" translate="yes" xml:space="preserve">
          <source>The release package by default contains:</source>
          <target state="translated">发布包默认包含:</target>
        </trans-unit>
        <trans-unit id="1ddf2f95ffb2351a4606d3527df333525dbf30af" translate="yes" xml:space="preserve">
          <source>The release package can be &lt;strong&gt;unpacked&lt;/strong&gt;, which extracts the files. An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The currently used version of the release is then upgraded or downgraded to the specified version by evaluating the instructions in the &lt;code&gt;relup&lt;/code&gt; file. An installed release can be made &lt;strong&gt;permanent&lt;/strong&gt;. Only one permanent release can exist in the system, and this release is used if the system is restarted. An installed release, except the permanent one, can be &lt;strong&gt;removed&lt;/strong&gt;. When a release is removed, all files belonging to that release only are deleted.</source>
          <target state="translated">发行包可以&lt;strong&gt;解压缩&lt;/strong&gt;，从而提取文件。可以&lt;strong&gt;安装&lt;/strong&gt;解压后的发行版。然后，通过评估 &lt;code&gt;relup&lt;/code&gt; 文件中的说明，将当前使用的发行版升级或降级为指定的版本。可以将已安装的发行版设为&lt;strong&gt;永久&lt;/strong&gt;发行版。系统中只能存在一个永久发行版，如果重新启动系统，则将使用此发行版。可以&lt;strong&gt;删除&lt;/strong&gt;已安装的发行版（永久版除外）。删除发行版后，仅删除属于该发行版的所有文件。</target>
        </trans-unit>
        <trans-unit id="e9b6c34e733e444ceb133eb0558e587c5c6c416c" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is compared with all release resource files &lt;code&gt;Name2.rel&lt;/code&gt;, specified in &lt;code&gt;UpFrom&lt;/code&gt; and &lt;code&gt;DownTo&lt;/code&gt;. For each such pair, the following is deducted:</source>
          <target state="translated">将发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt; 与在 &lt;code&gt;UpFrom&lt;/code&gt; 和 &lt;code&gt;DownTo&lt;/code&gt; 中指定的所有发布资源文件 &lt;code&gt;Name2.rel&lt;/code&gt; 进行比较。对于每个这样的对，都会扣除以下内容：</target>
        </trans-unit>
        <trans-unit id="7359f911881a84330db66568ed156a10773a2e38" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine the version and modules of each application (keys &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;).</source>
          <target state="translated">读取发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt; 以确定发布中包含哪些应用程序。然后读取相关的应用程序资源文件 &lt;code&gt;App.app&lt;/code&gt; 以确定每个应用程序的版本和模块（键 &lt;code&gt;vsn&lt;/code&gt; 和 &lt;code&gt;modules&lt;/code&gt; ，请参阅 &lt;code&gt;app(4)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="20395e6c5537d7e841a28ec3e32487d66bee87cf" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;Name.rel&lt;/code&gt; is read to determine which applications are included in the release. Then the relevant application resource files &lt;code&gt;App.app&lt;/code&gt; are read to determine which modules to be loaded, and if and how the applications are to be started. (Keys &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;, see &lt;code&gt;app(4)&lt;/code&gt;.</source>
          <target state="translated">读取发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt; 以确定发布中包含哪些应用程序。然后读取相关的应用程序资源文件 &lt;code&gt;App.app&lt;/code&gt; ，以确定要加载的模块，以及是否以及如何启动应用程序。 （密钥 &lt;code&gt;modules&lt;/code&gt; 和 &lt;code&gt;mod&lt;/code&gt; ，请参阅 &lt;code&gt;app(4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eefac0bf9340fed3bf570202c8d7eea59ecf327" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system) and the file is therefore now instead duplicated in the tar file so no manual copying is necessary.</source>
          <target state="translated">发行资源文件 &lt;code&gt;mysystem.rel&lt;/code&gt; 在tar文件中重复。最初，此文件仅存储在 &lt;code&gt;releases&lt;/code&gt; 目录中，以使 &lt;code&gt;release_handler&lt;/code&gt; 可以分别提取此文件。解压缩tar文件后， &lt;code&gt;release_handler&lt;/code&gt; 会自动将文件复制到 &lt;code&gt;releases/FIRST&lt;/code&gt; 。但是，有时会在不涉及 &lt;code&gt;release_handler&lt;/code&gt; 的情况下解压缩tar文件（例如，在解压缩第一个目标系统时），因此现在该文件已在tar文件中复制，因此无需手动复制。</target>
        </trans-unit>
        <trans-unit id="7c80217b964ae1583cdca52537267d331ce978fc" translate="yes" xml:space="preserve">
          <source>The release resource file &lt;code&gt;mysystem.rel&lt;/code&gt; is duplicated in the tar file. Originally, this file was only stored in the &lt;code&gt;releases&lt;/code&gt; directory to make it possible for the &lt;code&gt;release_handler&lt;/code&gt; to extract this file separately. After unpacking the tar file, &lt;code&gt;release_handler&lt;/code&gt; would automatically copy the file to &lt;code&gt;releases/FIRST&lt;/code&gt;. However, sometimes the tar file is unpacked without involving the &lt;code&gt;release_handler&lt;/code&gt; (for example, when unpacking the first target system). The file is therefore now instead duplicated in the tar file so no manual copying is needed.</source>
          <target state="translated">发行资源文件 &lt;code&gt;mysystem.rel&lt;/code&gt; 在tar文件中重复。最初，此文件仅存储在 &lt;code&gt;releases&lt;/code&gt; 目录中，以使 &lt;code&gt;release_handler&lt;/code&gt; 可以分别提取此文件。解压缩tar文件后， &lt;code&gt;release_handler&lt;/code&gt; 会自动将文件复制到 &lt;code&gt;releases/FIRST&lt;/code&gt; 。但是，有时在不涉及 &lt;code&gt;release_handler&lt;/code&gt; 的情况下解压缩tar文件（例如，在解压缩第一个目标系统时）。因此，现在将文件复制到tar文件中，因此不需要手动复制。</target>
        </trans-unit>
        <trans-unit id="5ef92a0cda894349ddeef7379b503e49a64bdb11" translate="yes" xml:space="preserve">
          <source>The release resource file is to be called &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">发行资源文件称为 &lt;code&gt;Name.rel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5471bf3aa3be047811963240dcf5d4400757add" translate="yes" xml:space="preserve">
          <source>The release resource file is used to generate &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt;. A system that is transferred to and installed at another site is called a &lt;strong&gt;target system&lt;/strong&gt;. How to use a release package to create a target system is described in System Principles.</source>
          <target state="translated">发布资源文件用于生成 &lt;code&gt;&lt;a href=&quot;#boot&quot;&gt;boot scripts&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#pack&quot;&gt;release packages&lt;/a&gt;&lt;/code&gt; 。转移到另一个站点并安装在另一个站点上的&lt;strong&gt;系统&lt;/strong&gt;称为&lt;strong&gt;目标系统&lt;/strong&gt;。系统原理中介绍了如何使用发行包创建目标系统。</target>
        </trans-unit>
        <trans-unit id="d5c96a363d42d5cbc941b3bdee5cae6301bb427b" translate="yes" xml:space="preserve">
          <source>The releases directory (&lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</source>
          <target state="translated">版本目录（ &lt;code&gt;&quot;/usr/local/erl-target/releases&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0ac93c2480f7003ed1b072da8ef587cc263275" translate="yes" xml:space="preserve">
          <source>The releases page is incomplete and very experimental.</source>
          <target state="translated">发布页面不完整,非常实验性。</target>
        </trans-unit>
        <trans-unit id="fca42c3d6efd5f3bf7036a14ae119c2bac9a56a9" translate="yes" xml:space="preserve">
          <source>The remaining Erlang script file can either contain Erlang &lt;strong&gt;source code&lt;/strong&gt;, an &lt;strong&gt;inlined beam file&lt;/strong&gt;, or an &lt;strong&gt;inlined archive file&lt;/strong&gt;.</source>
          <target state="translated">其余的Erlang脚本文件可以包含Erlang &lt;strong&gt;源代码&lt;/strong&gt;，&lt;strong&gt;内联的Beam文件&lt;/strong&gt;或&lt;strong&gt;内联的存档文件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="839a2a9520ffa3810212231d0366ad625cbea04a" translate="yes" xml:space="preserve">
          <source>The remaining arguments are pointers to callback functions that can be used to initialize the library. They are not used in this simple example, hence they are all set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">其余参数是可用于初始化库的回调函数的指针。在此简单示例中未使用它们，因此将它们都设置为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="848fe4988b3ebd532672ddf229d63bf17a87732d" translate="yes" xml:space="preserve">
          <source>The remaining filters only show function calls and function returns. All other trace message are discarded. To get the most out of these filters, &lt;code&gt;et_viewer&lt;/code&gt; must know the caller of each function and the time of return. This can be obtained using both the &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; flags when tracing. Notice that flag &lt;code&gt;return_to&lt;/code&gt; only works with local call trace, that is, when trace patterns are set with &lt;code&gt;ttb:tpl&lt;/code&gt;.</source>
          <target state="translated">其余过滤器仅显示函数调用和函数返回。所有其他跟踪消息都将被丢弃。为了充分利用这些过滤器， &lt;code&gt;et_viewer&lt;/code&gt; 必须知道每个函数的调用者和返回时间。跟踪时，可以使用 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;return_to&lt;/code&gt; 标志获得此信息。请注意，标志 &lt;code&gt;return_to&lt;/code&gt; 仅适用于本地呼叫跟踪，即使用 &lt;code&gt;ttb:tpl&lt;/code&gt; 设置跟踪模式时。</target>
        </trans-unit>
        <trans-unit id="ff5ca4f7571fd6b542abb7d48ce27d3b2fc439a8" translate="yes" xml:space="preserve">
          <source>The remote host &lt;code&gt;node&lt;/code&gt; is unreachable.</source>
          <target state="translated">远程主机 &lt;code&gt;node&lt;/code&gt; 不可访问。</target>
        </trans-unit>
        <trans-unit id="d37d54820fa9581d298dd9136f05c8334760d7a0" translate="yes" xml:space="preserve">
          <source>The remote mid (of the connection). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="translated">（连接的）远程中点。 &lt;code&gt;megaco_mid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bedfee181fa2c0cf108bcb6897f0543af23fb21e" translate="yes" xml:space="preserve">
          <source>The remote node &lt;code&gt;Node&lt;/code&gt; does not support this &lt;code&gt;erpc&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba62da86bb3f99cdfb2879e83169ae1e52ad3de4" translate="yes" xml:space="preserve">
          <source>The remote process was monitoring the local process at the time of the crash.</source>
          <target state="translated">崩溃时,远程进程正在监控本地进程。</target>
        </trans-unit>
        <trans-unit id="f6bb61a4811825e7030b032141e0fc103f13c80c" translate="yes" xml:space="preserve">
          <source>The remote username of the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">客户端的远程用户名（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="87cb1661c7bb66858ea881ceaeef4b6250aa903b" translate="yes" xml:space="preserve">
          <source>The renaming affects only remote calls (also when disguised by import declarations); local calls within a module are not affected, and no function definitions are renamed. Since the arity cannot change, the new name is represented by &lt;code&gt;{NewModule, NewName}&lt;/code&gt; only. Only calls matching the specified arity will match; multiple entries are necessary for renaming calls to functions that have the same module and function name, but different arities.</source>
          <target state="translated">重命名仅影响远程调用（也被导入声明掩盖）；模块内的本地调用不会受到影响，并且不会重命名任何函数定义。由于 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; 不能更改，因此新名称仅由{NewModule，NewName}表示。只有与指定Arity相匹配的呼叫才会匹配；重命名对具有相同模块和函数名称但不同Arities的函数的调用需要多个条目。</target>
        </trans-unit>
        <trans-unit id="7db0a5b5bf696ee011ef06c85df210d03986dfa2" translate="yes" xml:space="preserve">
          <source>The repair time is still proportional to the number of records in the file, but Dets repairs used to be much slower in the past. Dets has been massively rewritten and improved.</source>
          <target state="translated">修复时间仍然与文件中的记录数量成正比,但过去Dets的修复速度要慢很多。Dets已经进行了大规模的重写和改进。</target>
        </trans-unit>
        <trans-unit id="c2c4a2bf8d01876589d2d63a72ca740faf035967" translate="yes" xml:space="preserve">
          <source>The replacement string can contain the special character &lt;code&gt;&amp;amp;&lt;/code&gt;, which inserts the whole matching expression in the result, and the special sequence &lt;code&gt;\&lt;/code&gt;N (where N is an integer &amp;gt; 0), &lt;code&gt;\g&lt;/code&gt;N, or &lt;code&gt;\g{&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</source>
          <target state="translated">替换字符串可以包含特殊字符 &lt;code&gt;&amp;amp;&lt;/code&gt; ，该特殊字符＆将在结果中插入整个匹配表达式，以及特殊序列 &lt;code&gt;\&lt;/code&gt; N（其中N是&amp;gt; 0的整数）， &lt;code&gt;\g&lt;/code&gt; N或 &lt;code&gt;\g{&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; ，从而导致子表达式编号N将插入结果中。如果正则表达式未生成具有该编号的子表达式，则不会插入任何内容。</target>
        </trans-unit>
        <trans-unit id="faa500aee01a190343697194d03c438c2c602d2a" translate="yes" xml:space="preserve">
          <source>The reply will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">答复将通过调用snmpm_user回调函数 &lt;code&gt;handle_pdu&lt;/code&gt; 传递给用户。</target>
        </trans-unit>
        <trans-unit id="4a4f1cc106b1e894d4c96e8e317dc640fccb08d0" translate="yes" xml:space="preserve">
          <source>The reply, if it arrives, will be delivered to the user through a call to the snmpm_user callback function &lt;code&gt;handle_pdu&lt;/code&gt;.</source>
          <target state="translated">答复（如果到达）将通过调用snmpm_user回调函数 &lt;code&gt;handle_pdu&lt;/code&gt; 传递给用户。</target>
        </trans-unit>
        <trans-unit id="8f6b172375ebcae29181dbc0b6ea9f54803c80f5" translate="yes" xml:space="preserve">
          <source>The report browser is used to browse and format error reports written by the error logger handler &lt;code&gt;log_mf_h&lt;/code&gt; defined in STDLIB.</source>
          <target state="translated">报告浏览器用于浏览和格式化由STDLIB中定义的错误记录器处理程序 &lt;code&gt;log_mf_h&lt;/code&gt; 编写的错误报告。</target>
        </trans-unit>
        <trans-unit id="e834f0bfe944504c8960d652328e61c3c5a3b766" translate="yes" xml:space="preserve">
          <source>The report callback must be a fun with one or two arguments. If it takes one argument, this is the report itself, and the fun returns a format string and arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462562f8f81a87927a15414f09bedcc8da9f2dcf" translate="yes" xml:space="preserve">
          <source>The reports are matched using the &lt;code&gt;proplists&lt;/code&gt; module in STDLIB. The report must be a proplist to be matched against any of the filters.</source>
          <target state="translated">使用STDLIB中的 &lt;code&gt;proplists&lt;/code&gt; 模块对报告进行匹配。该报告必须是属性列表，才能与任何过滤器进行匹配。</target>
        </trans-unit>
        <trans-unit id="3841a22e3cae4249c1648495d6d06b7dc360f0ae" translate="yes" xml:space="preserve">
          <source>The representation for an empty list, that is, the Erlang syntax &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">空列表的表示形式，即Erlang语法 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90aa0c68b7c44e3dde7bae01a4485de7f117fcb2" translate="yes" xml:space="preserve">
          <source>The representation of a Diameter message as passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; or returned from a &lt;code&gt;handle_request/3&lt;/code&gt; callback. The record representation is as outlined in &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;: a message as defined in a dictionary file is encoded as a record with one field for each component AVP. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (as specified in the relevant dictionary file) and whose tail is either a list of AVP name/values pairs or a map with values keyed on AVP names. The format at decode is determined by &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt;. Any of the formats is accepted at encode.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;handle_request/3&lt;/code&gt; 回调返回的Diameter消息的表示形式。 &lt;code&gt;&lt;a href=&quot;diameter_dict#MESSAGE_RECORDS&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 表示格式（直径）（4）中概述了记录表示：字典文件中定义的消息被编码为记录，每个组件AVP具有一个字段。同样，一条消息也可以编码为一个列表，其头部是原子值的消息名称（在相关的字典文件中指定），其尾部是AVP名称/值对列表或在AVP上键入值的映射名称。解码时的格式由 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; 确定：service_opt（） &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode_format&lt;/a&gt;&lt;/code&gt; 。编码接受任何格式。</target>
        </trans-unit>
        <trans-unit id="82a411d117dc57a26bcb9e1f9d378e3ca11f15b7" translate="yes" xml:space="preserve">
          <source>The req_data() argument to this function is the Erlang term returned by handle_trans_request/3.</source>
          <target state="translated">这个函数的req_data()参数是由handle_trans_request/3返回的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="23e7ef624fc47862089915bb4bc3e847e83284d8" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;Type&lt;/code&gt; as passed to &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;. This is only mandatory when the connection has been initiated by this node. That is, the connection is set up via &lt;code&gt;setup/5&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 的请求 &lt;code&gt;Type&lt;/code&gt; 。仅当此节点已启动连接时，才必须执行此操作。也就是说，通过 &lt;code&gt;setup/5&lt;/code&gt; 来建立连接。</target>
        </trans-unit>
        <trans-unit id="bb7e74979895ad253263a88483e0213dfefa217d" translate="yes" xml:space="preserve">
          <source>The request is &lt;strong&gt;ignored&lt;/strong&gt; because &lt;code&gt;net_kernel&lt;/code&gt; is busy changing &lt;code&gt;net_ticktime&lt;/code&gt; to &lt;code&gt;NewNetTicktime&lt;/code&gt; seconds.</source>
          <target state="translated">该请求被&lt;strong&gt;忽略，&lt;/strong&gt;因为 &lt;code&gt;net_kernel&lt;/code&gt; 忙于将 &lt;code&gt;net_ticktime&lt;/code&gt; 更改为 &lt;code&gt;NewNetTicktime&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="8e8fce11312bcfaed7ec364cadd3a5f46ff33d51" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. &lt;code&gt;cast&lt;/code&gt;, and thus &lt;code&gt;free&lt;/code&gt;, then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">该请求被制成消息并发送到 &lt;code&gt;gen_server&lt;/code&gt; 。 &lt;code&gt;cast&lt;/code&gt; ，从而 &lt;code&gt;free&lt;/code&gt; ，然后返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03229c07c994ef8bacaf94e79a42852e8c89a6f8" translate="yes" xml:space="preserve">
          <source>The request is made into a message and sent to the &lt;code&gt;gen_server&lt;/code&gt;. When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{reply,Reply,State1}&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is the reply that is to be sent back to the client, and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">该请求被制成消息并发送到 &lt;code&gt;gen_server&lt;/code&gt; 。收到请求后， &lt;code&gt;gen_server&lt;/code&gt; 调用 &lt;code&gt;handle_call(Request, From, State)&lt;/code&gt; ，该方法将返回一个元组 &lt;code&gt;{reply,Reply,State1}&lt;/code&gt; 。 &lt;code&gt;Reply&lt;/code&gt; 是将要发送回客户端的答复， &lt;code&gt;State1&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 的状态的新值。</target>
        </trans-unit>
        <trans-unit id="6363c9ddb932fe00abea80ec408ab4c1cea65ddc" translate="yes" xml:space="preserve">
          <source>The request line as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请求行来自客户端（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2e51eb4e82ec44b07e0af2fe79e985e993a82848" translate="yes" xml:space="preserve">
          <source>The request line exactly as it came from the client (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">完全来自客户端的请求线（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3416c5291401473a7cf1526d471fda57329a38c" translate="yes" xml:space="preserve">
          <source>The request may have reached the server and may have been performed. However, no answer was received from the server within the expected time.</source>
          <target state="translated">该请求可能已经到达服务器,并可能已经执行。但是,在预期时间内没有收到服务器的答复。</target>
        </trans-unit>
        <trans-unit id="0609829732d849e2037ce824c383ed1a7b424ab2" translate="yes" xml:space="preserve">
          <source>The request was accepted and &lt;code&gt;SupervisorPid&lt;/code&gt; is the process identifier of the connection supervisor process (which is created in the &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; callback).</source>
          <target state="translated">该请求已被接受， &lt;code&gt;SupervisorPid&lt;/code&gt; 是连接管理器进程的进程标识符（在 &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 回调中创建）。</target>
        </trans-unit>
        <trans-unit id="d76fc415bd89f84963ae3ee419c891159d20a10c" translate="yes" xml:space="preserve">
          <source>The request was rejected. This is a fatal error. The acceptor process should terminate.</source>
          <target state="translated">该请求被拒绝。这是一个致命的错误。接受者进程应该终止。</target>
        </trans-unit>
        <trans-unit id="0af04869dc460d9fffda5c9cafebc1aa148f650e" translate="yes" xml:space="preserve">
          <source>The requests served by the EPMD are summarized in the following figure.</source>
          <target state="translated">下图概述了EPDM所提供的请求。</target>
        </trans-unit>
        <trans-unit id="766cb0fbb7f32280a11f9d0fcaaf21cc2abaa201" translate="yes" xml:space="preserve">
          <source>The resources can send notifications to the manager as well. Examples of notifications are events and alarms. The resource needs to generate protocol-independent notifications. The following picture illustrates how this is achieved:</source>
          <target state="translated">资源也可以向经理发送通知。通知的例子有事件和警报。资源需要生成与协议无关的通知。下图说明了如何实现这一点。</target>
        </trans-unit>
        <trans-unit id="2c83b49760a86aadaf5f3b2f1036293a1e089f52" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;DUMP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;DUMP_REQ&lt;/code&gt; 的响应如下：</target>
        </trans-unit>
        <trans-unit id="a65d28bc38322c3bd1cfbf2bf8711df7091101cd" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;KILL_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;KILL_REQ&lt;/code&gt; 的响应如下：</target>
        </trans-unit>
        <trans-unit id="b3c2ac7160df49c4588c05e57b87e5aff9422c1f" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;NAMES_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;NAMES_REQ&lt;/code&gt; 的响应如下：</target>
        </trans-unit>
        <trans-unit id="0dd3fa630ddc8b538f974287e27afabd12f4340d" translate="yes" xml:space="preserve">
          <source>The response for a &lt;code&gt;STOP_REQ&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;STOP_REQ&lt;/code&gt; 的响应如下：</target>
        </trans-unit>
        <trans-unit id="cbc3d39894fa2184326a46cadccf5d5f95e1ce70" translate="yes" xml:space="preserve">
          <source>The response message &lt;code&gt;ALIVE2_RESP&lt;/code&gt; is as follows:</source>
          <target state="translated">响应消息 &lt;code&gt;ALIVE2_RESP&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="218f2ad1fce75712661ee092a6b642bcf421a9a3" translate="yes" xml:space="preserve">
          <source>The response message is either &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; or &lt;code&gt;ALIVE2_RESP&lt;/code&gt; depending on distribution version. If both the node and EPMD support distribution version 6 then the response is &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; otherwise it is the older &lt;code&gt;ALIVE2_RESP&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6677705b73ca8640b5bfd49e04c30a99a6b85930" translate="yes" xml:space="preserve">
          <source>The response shows that the file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been created. This is called a backup file, and it contains an initial schema. If more than one node in the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; had been specified, identical backup files would have been created on all nodes.</source>
          <target state="translated">响应显示文件 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 已创建。这称为备份文件，它包含一个初始模式。如果在函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 中指定了多个节点，则将在所有节点上创建相同的备份文件。</target>
        </trans-unit>
        <trans-unit id="a4067e1f0937adfc4de129b497938ce1fa751f3a" translate="yes" xml:space="preserve">
          <source>The rest of the driver is more or less UDS-specific and not of general interest.</source>
          <target state="translated">其余的驱动程序或多或少都是UDS专用的,并不具有普遍意义。</target>
        </trans-unit>
        <trans-unit id="b248e72516f25e453000ce440baff629617e3ca9" translate="yes" xml:space="preserve">
          <source>The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP).</source>
          <target state="translated">因此,本节其余部分刻意不做调整,供Erlang程序员阅读,但这些例子可以帮助理解NAMES,因为它们可以被(*SKIP)使用。</target>
        </trans-unit>
        <trans-unit id="8d01a53de4ed7d8cd3faf10a1aef24441bc36b6e" translate="yes" xml:space="preserve">
          <source>The restart strategy is specified by the &lt;code&gt;strategy&lt;/code&gt; key in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">重新启动策略由回调函数 &lt;code&gt;init&lt;/code&gt; 返回的主管标志映射中的 &lt;code&gt;strategy&lt;/code&gt; 键指定：</target>
        </trans-unit>
        <trans-unit id="536cf89c0e01376b78ab828ece36006c915f41c1" translate="yes" xml:space="preserve">
          <source>The restoration is performed as a single transaction. If the database is large, it cannot always be restored online. The old database must then be restored by installing a fallback, followed by a restart.</source>
          <target state="translated">恢复是以单个事务的方式进行的。如果数据库很大,就不能总是在线恢复。那么必须通过安装后备程序,然后重新启动来恢复旧数据库。</target>
        </trans-unit>
        <trans-unit id="afdaf9dae668c3f7bdc0ca10a94463ffda8086c1" translate="yes" xml:space="preserve">
          <source>The restriction operators are defined for closures as well; &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is interpreted as the direct or indirect function calls from the &lt;code&gt;xref&lt;/code&gt; module, while the interpretation of &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; is the set of direct calls from &lt;code&gt;xref&lt;/code&gt;. If some graph is to be used in several graph analyses, it saves time to assign the &lt;code&gt;digraph&lt;/code&gt; representation of the graph to a user variable, and then make sure that every graph analysis operates on that variable instead of the list representation of the graph.</source>
          <target state="translated">限制运算符也为闭包定义； &lt;code&gt;closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; 被解释为来自 &lt;code&gt;xref&lt;/code&gt; 模块的直接或间接函数调用，而 &lt;code&gt;E&amp;nbsp;|&amp;nbsp;xref&amp;nbsp;:&amp;nbsp;Mod&lt;/code&gt; 是从 &lt;code&gt;xref&lt;/code&gt; 直接调用的集合。如果要在多个图分析中使用某个图，则可以节省时间，以将 &lt;code&gt;digraph&lt;/code&gt; 表示形式分配给用户变量，然后确保每个图分析都对该变量（而不是图的列表表示）进行操作。</target>
        </trans-unit>
        <trans-unit id="603dc83e6b9810f3ec3760b7629ba1cc75f2b142" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Excl_Message&lt;/code&gt; has the same structure as a complete decode would have, except for the parts of the top type that were not decoded. The undecoded parts are on their places in the structure on format &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Excl_Message&lt;/code&gt; 具有与完整解码相同的结构，除了top类型中未解码的部分。未解码的部分位于 &lt;code&gt;{Type_Key,Undecoded_Value}&lt;/code&gt; 格式的结构中。</target>
        </trans-unit>
        <trans-unit id="a5bf40f10fe2bffb0315d5af0604d375695096e5" translate="yes" xml:space="preserve">
          <source>The result above are the fastest of these configurations for each codec. The figures presented are the average of all used messages.</source>
          <target state="translated">上面的结果是每个编解码器的这些配置中最快的。所列数字是所有使用信息的平均值。</target>
        </trans-unit>
        <trans-unit id="32893fd2ec1b1eb00ce0a52b29ac7e0d97610291" translate="yes" xml:space="preserve">
          <source>The result contains information about the following &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">结果包含有关以下 &lt;code&gt;Item&lt;/code&gt; 的信息：</target>
        </trans-unit>
        <trans-unit id="2e8b477b4aed021fef6ebb0a1b67b1473cc13b37" translate="yes" xml:space="preserve">
          <source>The result from each test case is recorded in a dedicated HTML log file, created for the particular test run. An overview page displays each test case represented by a table row showing total execution time, if the case was successful, failed, or skipped, plus an optional user comment. For a failed test case, the reason for termination is also printed in the comment field. The overview page has a link to each test case log file, providing simple navigation with any standard HTML browser.</source>
          <target state="translated">每个测试案例的结果都记录在一个专门的HTML日志文件中,该文件是为特定的测试运行而创建的。一个概览页显示每个测试用例,用表行表示,显示总的执行时间,如果用例成功、失败或跳过,加上一个可选的用户注释。对于一个失败的测试案例,终止的原因也会被打印在注释栏中。概览页有一个链接到每个测试案例的日志文件,提供任何标准的HTML浏览器的简单导航。</target>
        </trans-unit>
        <trans-unit id="200d78a9c16efccfba75389c2e312a153f45a8e8" translate="yes" xml:space="preserve">
          <source>The result from running the test is printed in log files in HTML format (stored in unique log directories on a different level). The following illustration shows the log file structure:</source>
          <target state="translated">运行测试的结果以HTML格式打印在日志文件中(存储在不同级别的唯一日志目录中)。下图显示了日志文件的结构。</target>
        </trans-unit>
        <trans-unit id="374ecad7f3c9133bbe397289798ccaaa43ce127d" translate="yes" xml:space="preserve">
          <source>The result is &quot;normalized&quot;:</source>
          <target state="translated">其结果是 &quot;规范化&quot;。</target>
        </trans-unit>
        <trans-unit id="859cd92f58e2a9a54c26d7e8f5204e954bdffebd" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;. The fun is straightforward, so the only problem is that all the data from the table must be transferred from the table to the calling process for filtering. That is inefficient compared to the &lt;code&gt;ets:match/2&lt;/code&gt; call where the filtering can be done &quot;inside&quot; the emulator and only the result is transferred to the process.</source>
          <target state="translated">结果为 &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt; 。有趣之处很简单，因此唯一的问题是必须将表中的所有数据从表传输到调用过程以进行过滤。与 &lt;code&gt;ets:match/2&lt;/code&gt; 调用相比，效率低下，在ets：match / 2调用中，可以在仿真器内部进行过滤，并且仅将结果传输到进程。</target>
        </trans-unit>
        <trans-unit id="3cac868d8974153152b55d9efa1e40ff1114e69d" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt;, as expected. The equivalent expression using a handwritten match specification would look like this:</source>
          <target state="translated">结果是 &lt;code&gt;[&quot;052341&quot;,&quot;076324&quot;,&quot;535216&quot;,&quot;789789&quot;,&quot;989891&quot;]&lt;/code&gt; ，如预期的那样。使用手写匹配规范的等效表达式如下所示：</target>
        </trans-unit>
        <trans-unit id="d8636350d1356e8fb3f319b7140bff8ef6a16d4e" translate="yes" xml:space="preserve">
          <source>The result is a list of characters.</source>
          <target state="translated">结果是一个字符列表。</target>
        </trans-unit>
        <trans-unit id="1bedbbe8e33126fcebf6fc95fcd5a51821596e48" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt; and &lt;code&gt;Files&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details).</source>
          <target state="translated">结果是一对 &lt;code&gt;{Tree, Stubs}&lt;/code&gt; ，其中 &lt;code&gt;Tree&lt;/code&gt; 表示源代码，该源代码是合并 &lt;code&gt;Sources&lt;/code&gt; 和 &lt;code&gt;Files&lt;/code&gt; 中的所有代码的结果，而 &lt;code&gt;Stubs&lt;/code&gt; 是存根模块描述符的列表（有关详细信息，请参见 &lt;code&gt;merge_sources/3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="389d84201c8d9fc72ea3759187e87ed97f94a3cc" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see below).</source>
          <target state="translated">结果是一对 &lt;code&gt;{Tree, Stubs}&lt;/code&gt; ，其中 &lt;code&gt;Tree&lt;/code&gt; 表示源代码，是合并 &lt;code&gt;Sources&lt;/code&gt; 中所有代码的结果，而 &lt;code&gt;Stubs&lt;/code&gt; 是存根模块描述符的列表（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="9feb7727d1cbada310f559306bd354a9d4c4914e" translate="yes" xml:space="preserve">
          <source>The result is a valid URI where all the special characters are encoded as defined by the standard. Applying &lt;code&gt;&lt;a href=&quot;uri_string#parse-1&quot;&gt;uri_string:parse/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; on the URI returns the original input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1812142f22d2ec8fea49815c861b9d307af9e096" translate="yes" xml:space="preserve">
          <source>The result is an utf8 encoded binary.</source>
          <target state="translated">结果是一个utf8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="163326ca75ef4e4877fd05e7489373dbafc7e29a" translate="yes" xml:space="preserve">
          <source>The result is as follows:</source>
          <target state="translated">结果如下:</target>
        </trans-unit>
        <trans-unit id="96bc7dfc5e6c338c6e144779bbc57eea9d034108" translate="yes" xml:space="preserve">
          <source>The result is given as a list of &quot;strings&quot;, the preferred data type specified in option &lt;code&gt;return&lt;/code&gt; (default &lt;code&gt;iodata&lt;/code&gt;).</source>
          <target state="translated">结果以&amp;ldquo;字符串&amp;rdquo;列表形式给出，&amp;ldquo;字符串&amp;rdquo;是在选项 &lt;code&gt;return&lt;/code&gt; 中指定的首选数据类型（默认 &lt;code&gt;iodata&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a11b14a2bfe2822537c2166099b97fcfb96fde0" translate="yes" xml:space="preserve">
          <source>The result is returned in a form suitable for &lt;code&gt;Common Test&lt;/code&gt; test suites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b8ec2df33b161570c66397c14edb7740f68481" translate="yes" xml:space="preserve">
          <source>The result is sent to the calling process as &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt;.</source>
          <target state="translated">结果作为 &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt; 发送到调用过程。</target>
        </trans-unit>
        <trans-unit id="a900f3ce3edf2d3ac29948402338e0f316e3fe94" translate="yes" xml:space="preserve">
          <source>The result is that the child process is started by calling &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt;, or actually:</source>
          <target state="translated">结果是通过调用 &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt; 或实际上启动了子进程：</target>
        </trans-unit>
        <trans-unit id="0c3fa086682c777519a4e26ac33755c0fbf61a9a" translate="yes" xml:space="preserve">
          <source>The result is that the test case is skipped with &lt;code&gt;Reason&lt;/code&gt; printed to the log file (as described earlier) and &lt;code&gt;ConfigList&lt;/code&gt; is saved for the next test case. &lt;code&gt;ConfigList&lt;/code&gt; can be read using &lt;code&gt;?config(saved_config, Config)&lt;/code&gt;, as described earlier. &lt;code&gt;skip_and_save&lt;/code&gt; can also be returned from &lt;code&gt;init_per_suite&lt;/code&gt;. In this case, the saved data can be read by &lt;code&gt;init_per_suite&lt;/code&gt; in the suite that follows.</source>
          <target state="translated">结果是跳过了测试用例，并在日志文件中打印了 &lt;code&gt;Reason&lt;/code&gt; （如前所述），并为下一个测试用例保存了 &lt;code&gt;ConfigList&lt;/code&gt; 。 &lt;code&gt;ConfigList&lt;/code&gt; 可以使用读 &lt;code&gt;?config(saved_config, Config)&lt;/code&gt; ，如前所述。 &lt;code&gt;skip_and_save&lt;/code&gt; 也可以从 &lt;code&gt;init_per_suite&lt;/code&gt; 返回。在这种情况下，保存的数据可由 &lt;code&gt;init_per_suite&lt;/code&gt; 的套件中的init_per_suite读取。</target>
        </trans-unit>
        <trans-unit id="fdba3ae36e083e81eed5d03ef22e016c4c681e51" translate="yes" xml:space="preserve">
          <source>The result is that we prefer carriers created by the thread itself, which is good for NUMA performance. And we get more entry points when searching the pool, which will ease contention and clustering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438c51f348652f581a109f7cba2e137928b4597" translate="yes" xml:space="preserve">
          <source>The result of &lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; is an &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; event that contains, in particular, the new &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; 的结果是 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 事件，其中特别包含新的 &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="aecf003aab72f86d85e99eebdbc2c40ed626e60a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;ann_make_tree(get_ann(Node), type(Node), subtrees(Node))&lt;/code&gt; (cf. &lt;code&gt;update_tree/2&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the exact same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5e27a92975d3fafc60ea5040ed17aae30c19cc" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">的结果 &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; （见 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; ）表示相同的源代码的文本作为原始 &lt;code&gt;Node&lt;/code&gt; ，假设 &lt;code&gt;subtrees(Node)&lt;/code&gt; 产生一个非空列表。但是，它不一定具有与 &lt;code&gt;Node&lt;/code&gt; 相同的数据表示形式。</target>
        </trans-unit>
        <trans-unit id="fda083e58e6dac620272874f82b040b4ce2c7034" translate="yes" xml:space="preserve">
          <source>The result of a call to &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="7071a214aa01dd546b8a4ab94260ea66857afb3e" translate="yes" xml:space="preserve">
          <source>The result of a call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935e389e977d887f2bcee20a8d60eab32fcf9be1" translate="yes" xml:space="preserve">
          <source>The result of a successful parsing is a tuple &lt;code&gt;{DataStructure,M}&lt;/code&gt;. &lt;code&gt;M&lt;/code&gt; is the XML production Misc, which is the mark-up that comes after the element of the document. It is returned &quot;as is&quot;. &lt;code&gt;DataStructure&lt;/code&gt; is an &lt;code&gt;xmlElement&lt;/code&gt; record, that among others have the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;parents&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; like:</source>
          <target state="translated">成功解析的结果是元组 &lt;code&gt;{DataStructure,M}&lt;/code&gt; 。 &lt;code&gt;M&lt;/code&gt; 是XML生产Misc，它是文档元素之后的标记。它按&amp;ldquo;原样&amp;rdquo;返回。 &lt;code&gt;DataStructure&lt;/code&gt; 是一个 &lt;code&gt;xmlElement&lt;/code&gt; 记录，这其中包括有田 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;parents&lt;/code&gt; ， &lt;code&gt;attributes&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; ，如：</target>
        </trans-unit>
        <trans-unit id="3bdf97f5167b1c9ccc6355ba9b80fe296b53b3fa" translate="yes" xml:space="preserve">
          <source>The result of executing the command can be only one line or thousands of lines depending on the command.</source>
          <target state="translated">根据命令的不同,执行命令的结果可以是只有一行,也可以是上千行。</target>
        </trans-unit>
        <trans-unit id="d2d72cb2c002561132566b627196b081cc82e743" translate="yes" xml:space="preserve">
          <source>The result of passing the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) as a value is platform-dependent. On some platforms the variable value is set to the empty string, on others the environment variable is removed.</source>
          <target state="translated">将空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）作为值传递的结果取决于平台。在某些平台上，变量值设置为空字符串，在其他平台上，环境变量被删除。</target>
        </trans-unit>
        <trans-unit id="176ec7aa5b60be46f47fbe0fe14c3723b77fddec" translate="yes" xml:space="preserve">
          <source>The result of setting up module data is the  &lt;strong id=&quot;call_graph&quot;&gt;Call Graph&lt;/strong&gt;. A (directed) graph consists of a set of vertices and a set of (directed) edges. The edges represent  &lt;strong id=&quot;call&quot;&gt;calls&lt;/strong&gt; (From, To) between functions, modules, applications or releases. From is said to call To, and To is said to be used by From. The vertices of the Call Graph are the functions of all module data: local and exported functions of analyzed modules; used BIFs; used exported functions of library modules; and unknown functions. The functions &lt;code&gt;module_info/0,1&lt;/code&gt; added by the compiler are included among the exported functions, but only when called from some module. The edges are the function calls of all module data. A consequence of the edges being a set is that there is only one edge if a function is locally or externally used several times on one and the same line of code.</source>
          <target state="translated">设置模块数据的结果是 &lt;strong id=&quot;call_graph&quot;&gt;调用图&lt;/strong&gt;。 （有向）图由一组顶点和一组（有向）边组成。边表示 函数，模块，应用程序或发行版之间的&lt;strong id=&quot;call&quot;&gt;调用&lt;/strong&gt;（从，到）。据说From调用To，而To则被From使用。调用图的顶点是所有模块数据的功能：已分析模块的本地和导出功能；使用过的BIF；使用了库模块的导出功能；和未知的功能。函数 &lt;code&gt;module_info/0,1&lt;/code&gt; 由编译器添加的函数包括在导出的函数中，但仅当从某个模块调用时才包含。边是所有模块数据的函数调用。边为一组的结果是，如果在同一条代码行上在本地或外部多次使用某个功能，则仅存在一条边。</target>
        </trans-unit>
        <trans-unit id="b6d992ed8fa86e71532f265c49bcbb4dc25bd864" translate="yes" xml:space="preserve">
          <source>The result of the call is:</source>
          <target state="translated">呼叫的结果是:</target>
        </trans-unit>
        <trans-unit id="0e48775b9bb091eea31ee6bd2d8fe10d31512d84" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt; start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8dee4e2044b61dfd39541deba480b6fc0f212" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="translated">端口初始化的结果。可以与 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; 的返回值相同，即，该端口要使用的任何错误代码或 &lt;code&gt;ErlDrvData&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb0f3fa15c3024585e6a3271632a219e04970822" translate="yes" xml:space="preserve">
          <source>The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00d452be45830984444ced9bba7583a3c4c38e3" translate="yes" xml:space="preserve">
          <source>The result shows that &amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt; is selected instead of the shorter match &amp;lt;&amp;lt;&quot;bc&quot;&amp;gt;&amp;gt; (which would have given raise to one more match, &amp;lt;&amp;lt;&quot;de&quot;&amp;gt;&amp;gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in &lt;code&gt;re&lt;/code&gt; (and Perl), where instead lexical ordering in the search pattern selects which string matches.</source>
          <target state="translated">结果显示，选择了&amp;lt;&amp;lt;&amp;ldquo; bcde&amp;rdquo; &amp;gt;&amp;gt;而不是较短的比赛&amp;lt;&amp;lt;&amp;ldquo; bc&amp;rdquo; &amp;gt;&amp;gt;（这将导致加注另外一场比赛，&amp;lt;&amp;lt;&amp;ldquo; de&amp;rdquo; &amp;gt;&amp;gt;）。这与POSIX正则表达式（和诸如awk之类的程序）的行为相对应，但是与 &lt;code&gt;re&lt;/code&gt; （和Per​​l）中的替代匹配不一致，而是在搜索模式中按词法顺序选择匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="ea7c245c3de8a57733480ff4f2d83525a81309ec" translate="yes" xml:space="preserve">
          <source>The result value is the tuple &lt;code&gt;{ok, List}&lt;/code&gt;, where &lt;code&gt;List&lt;/code&gt; contains the zip archive comment as the first element.</source>
          <target state="translated">结果值为元组 &lt;code&gt;{ok, List}&lt;/code&gt; ，其中 &lt;code&gt;List&lt;/code&gt; 包含zip归档注释作为第一个元素。</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="3b29ae4d5e694ab8389bf2e90d3d34997e8aec86" translate="yes" xml:space="preserve">
          <source>The result would be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="f25af746c0ce14546dc62a293ebeb0fa347f8166" translate="yes" xml:space="preserve">
          <source>The result, ValidElement, is the valid element that conforms to the post-schema-validation infoset. When the validator finds an error it tries to continue and reports a list of all errors found. In those cases an unexpected error is found it may cause a single error reason.</source>
          <target state="translated">结果ValidElement是符合schema后验证信息集的有效元素。当验证器发现一个错误时,它会尝试继续,并报告所有发现的错误列表。在那些发现意外错误的情况下,它可能会引起一个单一的错误原因。</target>
        </trans-unit>
        <trans-unit id="d2c0cc39b7355bd656ef96e65ce99409f2da03cd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ETERM&lt;/code&gt; struct is converted into the Erlang external term format using the function &lt;code&gt;erl_encode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; and sent to Erlang using &lt;code&gt;write_cmd()&lt;/code&gt;:</source>
          <target state="translated">将所得 &lt;code&gt;ETERM&lt;/code&gt; 结构被转换成使用该函数的外部的Erlang术语格式 &lt;code&gt;erl_encode()&lt;/code&gt; 从 &lt;code&gt;erl_marshal&lt;/code&gt; 并使用发送到二郎 &lt;code&gt;write_cmd()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c67db894cf4a73ec37644dab582a90190d4ea154" translate="yes" xml:space="preserve">
          <source>The resulting C program is as follows:</source>
          <target state="translated">由此产生的C程序如下。</target>
        </trans-unit>
        <trans-unit id="76387c891c14647ed37c7c26b256256d64b3a197" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program is as follows:</source>
          <target state="translated">由此产生的Erlang程序如下。</target>
        </trans-unit>
        <trans-unit id="dde85e9e8384430e4dfd5c8f18cbf940581018ee" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functionality for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">由此产生的 Erlang 程序,包括停止 port 和检测 port 故障的功能,如下所示。</target>
        </trans-unit>
        <trans-unit id="b6e57ccb1752b17aec9fbb1ccc1b61f1ccbf9235" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functions for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">由此产生的 Erlang 程序,包括停止端口和检测端口故障的功能,如下所示。</target>
        </trans-unit>
        <trans-unit id="f57a31a3619a4eacb10fbb043b62b825bcea6a9d" translate="yes" xml:space="preserve">
          <source>The resulting output from the command can be read with &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt; 读取命令的结果输出。</target>
        </trans-unit>
        <trans-unit id="2db028a846be38d0f5b491dc0acc0c2de71c7201" translate="yes" xml:space="preserve">
          <source>The resulting source code is written to a file named &quot;&lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt;&quot; in the current directory, unless otherwise specified by the options &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; described below.</source>
          <target state="translated">除非通过下面描述的 &lt;code&gt;dir&lt;/code&gt; 和 &lt;code&gt;outfile&lt;/code&gt; 选项另外指定，否则将所得的源代码写入当前目录中名为&amp;ldquo; &lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt; &amp;rdquo;的文件中。</target>
        </trans-unit>
        <trans-unit id="0942845035c845f735b01ad27ac6b970e03ffed1" translate="yes" xml:space="preserve">
          <source>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</source>
          <target state="translated">由此产生的语法树通常只对漂亮的打印或类似的视觉格式化有用。</target>
        </trans-unit>
        <trans-unit id="3fac0a475f9b69478ab11507fafdcda6f58da223" translate="yes" xml:space="preserve">
          <source>The results from the measurement run (meas) is four excel-compatible textfiles:</source>
          <target state="translated">测量运行(meas)的结果是四个excel兼容的文本文件。</target>
        </trans-unit>
        <trans-unit id="f095f8b68579bff1b0c6a6018ac10269dfd93fd4" translate="yes" xml:space="preserve">
          <source>The results of calling the instrumentation are propagated back to the Master Agent.</source>
          <target state="translated">调用仪器的结果会传播回主代理。</target>
        </trans-unit>
        <trans-unit id="f749a3c0024a4110d2c9ec3020e59247d2fa1de4" translate="yes" xml:space="preserve">
          <source>The results, the mstone value(s), are written to stdout.</source>
          <target state="translated">结果,mstone的值,被写入stdout。</target>
        </trans-unit>
        <trans-unit id="68b25f8a798e229a222e707ac3c343b84eeef3a3" translate="yes" xml:space="preserve">
          <source>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</source>
          <target state="translated">这个函数的返回是一个字符串,其中包含了Erlang/OTP编译中使用的系统的PCRE版本。</target>
        </trans-unit>
        <trans-unit id="a5daa3a58a54feb209df655b37c5e59522b9e4ee" translate="yes" xml:space="preserve">
          <source>The return type is always a list of binaries that are all referencing &lt;code&gt;Subject&lt;/code&gt;. This means that the data in &lt;code&gt;Subject&lt;/code&gt; is not copied to new binaries, and that &lt;code&gt;Subject&lt;/code&gt; cannot be garbage collected until the results of the split are no longer referenced.</source>
          <target state="translated">返回类型始终是所有引用 &lt;code&gt;Subject&lt;/code&gt; 的二进制文件列表。这意味着 &lt;code&gt;Subject&lt;/code&gt; 中的数据不会复制到新的二进制文件中，并且在不再引用拆分结果之前，无法对 &lt;code&gt;Subject&lt;/code&gt; 进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="cc16505451734ce394057d5190ddadeecb680cef" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Pid&lt;/code&gt; is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</source>
          <target state="translated">返回值 &lt;code&gt;Pid&lt;/code&gt; 在所有其他函数中均用作对新创建的FTP客户端的引用，创建连接的进程将调用它们。FTP客户端进程监视创建它的进程，并在该进程终止时终止。</target>
        </trans-unit>
        <trans-unit id="f78465bb43d8aa089c1a2e5e2c700b8de6570b00" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">返回值 &lt;code&gt;Reply&lt;/code&gt; 在 &lt;code&gt;Module:handle_call/2&lt;/code&gt; 的返回值中定义。如果未安装指定的事件处理程序，则该函数返回 &lt;code&gt;{error,bad_module}&lt;/code&gt; 。如果回调函数因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回意外值 &lt;code&gt;Term&lt;/code&gt; ，则此函数分别返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 或 &lt;code&gt;{error,Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6289ce75177b974046367704a47c1b35eb2e270" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;Reply&lt;/code&gt; 在 &lt;code&gt;Module:handle_call/3&lt;/code&gt; 的返回值中定义。</target>
        </trans-unit>
        <trans-unit id="aeb167c76164cb105eb2244033c450ce12d924f6" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is generated when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returns with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; as one &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;, and that &lt;code&gt;Reply&lt;/code&gt; becomes the return value of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44772176203799075c4cf0e8094950a68499d4a6" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;RequestId&lt;/code&gt; shall later be used with &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt; wait_response/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#check_response-2&quot;&gt; check_response/2&lt;/a&gt;&lt;/code&gt; to fetch the actual result of the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e65900c2497a0e4adbf3bab8d430efb090697d7" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Result&lt;/code&gt; is not further defined, and is always to be ignored.</source>
          <target state="translated">返回值 &lt;code&gt;Result&lt;/code&gt; 没有进一步定义，始终将被忽略。</target>
        </trans-unit>
        <trans-unit id="9c23fe4eff7b888efd68f97990dace6d93d015ba" translate="yes" xml:space="preserve">
          <source>The return value and the handling of errors and warnings are the same as described for &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值以及错误和警告的处理与对 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 的描述相同。</target>
        </trans-unit>
        <trans-unit id="ba22696e46bcb1ab14efe031c40d755d114fc6e5" translate="yes" xml:space="preserve">
          <source>The return value can have one of the following types.</source>
          <target state="translated">返回值可以有以下类型之一:</target>
        </trans-unit>
        <trans-unit id="741aa2cae249c15277ff6de1b81ff1f7de2350e9" translate="yes" xml:space="preserve">
          <source>The return value consists of a &lt;code&gt;Listen&lt;/code&gt; handle (which is later passed to the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback), &lt;code&gt;Address&lt;/code&gt; which is a &lt;code&gt;#net_address{}&lt;/code&gt; record with information about the address for the node (the &lt;code&gt;#net_address{}&lt;/code&gt; record is defined in &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt;), and &lt;code&gt;Creation&lt;/code&gt; which (currently) is an integer &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">返回值包含一个 &lt;code&gt;Listen&lt;/code&gt; 句柄（此后将传递给 &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; 回调）， &lt;code&gt;Address&lt;/code&gt; 它是 &lt;code&gt;#net_address{}&lt;/code&gt; 记录和有关节点地址的信息）（ &lt;code&gt;#net_address{}&lt;/code&gt; 记录在 &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt; ），以及 &lt;code&gt;Creation&lt;/code&gt; 其中（目前）是整数 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 或 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab79f181d05026b86f1878e51d4d3441d03c4055" translate="yes" xml:space="preserve">
          <source>The return value follow the same style as for &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值采用与 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 相同的样式。</target>
        </trans-unit>
        <trans-unit id="346315afa40134fb62265d734d0e42452e705832" translate="yes" xml:space="preserve">
          <source>The return value for all output functions is &lt;code&gt;0&lt;/code&gt; for normal use. If the driver is used for distribution, it can fail and return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">正常使用时，所有输出函数的返回值为 &lt;code&gt;0&lt;/code&gt; 。如果使用驱动程序进行分发，则驱动程序可能会失败并返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43fdbaf5636b2b9f8f515ab786ad5a8feaf983bd" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt; enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe44e353cb6821f37b9d4bc7c2c6cb33639ce4d" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">&lt;code&gt;enif_make_badarg&lt;/code&gt; 的返回值只能用作（直接或间接）调用它的NIF的返回值，或传递给 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; ，但不能传递给任何其他NIF API函数。</target>
        </trans-unit>
        <trans-unit id="bc102f8ff2bc19643ee272ec79fc8cf9d22dd9ca" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt; enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dc23a005ca2cd50fc7c1d7990584e9fd2be429" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">&lt;code&gt;enif_raise_exception&lt;/code&gt; 的返回值只能用作（直接或间接）调用它的NIF的返回值，或传递给 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; ，但不能传递给任何其他NIF API函数。</target>
        </trans-unit>
        <trans-unit id="41dab507981d86110830d0fd24280799a5b4ee46" translate="yes" xml:space="preserve">
          <source>The return value from the filter fun.</source>
          <target state="translated">过滤器乐趣的返回值。</target>
        </trans-unit>
        <trans-unit id="001a5abd75600054653994ccb358aab2ae66f787" translate="yes" xml:space="preserve">
          <source>The return value from the function is in this case a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</source>
          <target state="translated">在这种情况下，函数的返回值是 &lt;code&gt;list()&lt;/code&gt; 的 &lt;code&gt;list()&lt;/code&gt; 。每个子列表都以从主题字符串中挑选出的字符串开始，然后是与每个子表达式匹配的部分（按正则表达式中出现的顺序）。</target>
        </trans-unit>
        <trans-unit id="5ccdc21b3308e8b9c79db59288c10d44a28814f7" translate="yes" xml:space="preserve">
          <source>The return value from this function is ignored by Logger.</source>
          <target state="translated">该函数的返回值被Logger忽略。</target>
        </trans-unit>
        <trans-unit id="a4da786e1a06fe4c80b86166fcf1fc85113c7b88" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;-1&lt;/code&gt; if the &lt;code&gt;driver_async&lt;/code&gt; call fails.</source>
          <target state="translated">如果 &lt;code&gt;driver_async&lt;/code&gt; 调用失败，则返回值为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c3504d0b1f9c55bafbdc1d0b5cee931f0f08b2" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt; for normal use.</source>
          <target state="translated">正常使用时，返回值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a5dc674809351c5092cd01b94fa3534964ae836" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless &lt;code&gt;ready_input&lt;/code&gt;/&lt;code&gt;ready_output&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, in which case it is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;0&lt;/code&gt; ，除非 &lt;code&gt;ready_input&lt;/code&gt; / &lt;code&gt;ready_output&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，在这种情况下为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4d60964b41244106524f6879c28f2c548eae606" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless the &lt;code&gt;now&lt;/code&gt; pointer is invalid, in which case it is &amp;lt; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;0&lt;/code&gt; ，除非 &lt;code&gt;now&lt;/code&gt; 指针无效，在这种情况下，它是&amp;lt; &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d105bd7aa7f6ee8eda692ca7d456479ff1aacb66" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e56d80f6b96cb9980b29b64b5003509e50ff6732" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Item, Value}&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the requested information as described earlier. If a pid for a dead process was specified, or the name of a non-existing function, &lt;code&gt;Value&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">返回值为 &lt;code&gt;{Item, Value}&lt;/code&gt; ，其中 &lt;code&gt;Value&lt;/code&gt; 是如前所述的请求的信息。如果指定了死进程的pid或不存在的函数的名称，则 &lt;code&gt;Value&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="086833bd7be1bf42e569670f0bbec7584dac404f" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Ret, Mon}&lt;/code&gt; where &lt;code&gt;Ret&lt;/code&gt; corresponds to the &lt;code&gt;Ret&lt;/code&gt; argument in the call to &lt;code&gt;init_ack()&lt;/code&gt;, and &lt;code&gt;Mon&lt;/code&gt; is the monitor reference of the monitor that has been set up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03446d5b267ccb3efe0ace7759b550ebc06efd8" translate="yes" xml:space="preserve">
          <source>The return value is a list of 0, 1, or 2 possible UTC times:</source>
          <target state="translated">返回值是一个0、1或2个可能的UTC时间的列表。</target>
        </trans-unit>
        <trans-unit id="ce9057d164fb05944ea3d2ae98a443e394d333df" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">返回值始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3da23e054f258b1199e04f5ad3b9dd62d3edb83" translate="yes" xml:space="preserve">
          <source>The return value is constructed using the &quot;match variables&quot; bound in &lt;code&gt;MatchHead&lt;/code&gt; or using the special match variables &lt;code&gt;'$_'&lt;/code&gt; (the whole matching object) and &lt;code&gt;'$$'&lt;/code&gt; (all match variables in a list), so that the following &lt;code&gt;match/2&lt;/code&gt; expression:</source>
          <target state="translated">返回值是使用 &lt;code&gt;MatchHead&lt;/code&gt; 中绑定的&amp;ldquo;匹配变量&amp;rdquo; 或特殊匹配变量 &lt;code&gt;'$_'&lt;/code&gt; （整个匹配对象）和 &lt;code&gt;'$$'&lt;/code&gt; （列表中的所有匹配变量）构造的，因此以下 &lt;code&gt;match/2&lt;/code&gt; 表达：</target>
        </trans-unit>
        <trans-unit id="37128074a43cf6aae3aba83c9d932bd47e3048e4" translate="yes" xml:space="preserve">
          <source>The return value is ignored by Logger.</source>
          <target state="translated">返回值被记录仪忽略。</target>
        </trans-unit>
        <trans-unit id="c1dfea7d28396da4de4489ef281ff15cca821d15" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;*rbuf&lt;/code&gt; 中返回的字节数。</target>
        </trans-unit>
        <trans-unit id="a34c82452edda3fc5f857c3e407fba4f89b70680" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;. If &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; is returned (or in fact, anything &amp;lt; 0), &lt;code&gt;erlang:port_call/3&lt;/code&gt; throws a &lt;code&gt;BAD_ARG&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;*rbuf&lt;/code&gt; 中返回的字节数。如果返回 &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; （或者实际上是任何&amp;lt;0），则 &lt;code&gt;erlang:port_call/3&lt;/code&gt; 抛出 &lt;code&gt;BAD_ARG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb09cfa81ef1177832f57170b310c9386fb04033" translate="yes" xml:space="preserve">
          <source>The return value is the number of characters written to the file or string, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;buf[index]&lt;/code&gt; does not contain a valid term. Unfortunately, I/O errors on &lt;code&gt;fp&lt;/code&gt; is not checked.</source>
          <target state="translated">返回值是写入文件或字符串的字符数；如果 &lt;code&gt;buf[index]&lt;/code&gt; 不包含有效术语，则返回 &lt;code&gt;-1&lt;/code&gt; 。不幸的是，没有检查 &lt;code&gt;fp&lt;/code&gt; 上的I / O错误。</target>
        </trans-unit>
        <trans-unit id="d80fb99a8a27fa381ecc5c817818b46b3ab15dd8" translate="yes" xml:space="preserve">
          <source>The return value is the resulting match specification.</source>
          <target state="translated">返回值是产生的匹配规范。</target>
        </trans-unit>
        <trans-unit id="57668a668af4374fe9545618abb646616a496fcc" translate="yes" xml:space="preserve">
          <source>The return value is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,module_not_found}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;Module:terminate/2&lt;/code&gt; 的返回值。如果未安装指定的事件处理程序，则该函数返回 &lt;code&gt;{error,module_not_found}&lt;/code&gt; 。如果回调函数因 &lt;code&gt;Reason&lt;/code&gt; 失败，则该函数返回 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f156a768e7d53f51540a13419deed4e225aae89a" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1dfedeee7a3af1d51782288cef9cd7e711ef3e94" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. The number of matched events are never larger than 1 as &lt;code&gt;tpe/2&lt;/code&gt; does not accept any form of wildcards for argument &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 相同。匹配事件的数量永远不会大于1，因为 &lt;code&gt;tpe/2&lt;/code&gt; 不接受参数 &lt;code&gt;Event&lt;/code&gt; 的任何形式的通配符。</target>
        </trans-unit>
        <trans-unit id="d9518162065c311fec4cb8d7246362f3b51e7aea" translate="yes" xml:space="preserve">
          <source>The return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;{error, noconnection}&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not a connected node or &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不是连接的节点或 &lt;code&gt;new&lt;/code&gt; ，则返回值与 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;{error, noconnection}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a43749a23c3f85f80f04d4b8d3793842d7c78d0b" translate="yes" xml:space="preserve">
          <source>The return value is the space left in the buffer, that is, if &lt;code&gt;ev&lt;/code&gt; contains less than &lt;code&gt;len&lt;/code&gt; bytes it is the difference, and if &lt;code&gt;ev&lt;/code&gt; contains &lt;code&gt;len&lt;/code&gt; bytes or more, it is &lt;code&gt;0&lt;/code&gt;. This is faster if there is more than one header byte, as the binary syntax can construct integers directly from the binary.</source>
          <target state="translated">返回值是缓冲区中剩余的空间，即，如果 &lt;code&gt;ev&lt;/code&gt; 包含少于 &lt;code&gt;len&lt;/code&gt; 个字节，则为差；如果 &lt;code&gt;ev&lt;/code&gt; 包含 &lt;code&gt;len&lt;/code&gt; 个字节或更大，则为 &lt;code&gt;0&lt;/code&gt; 。如果头字节不止一个，则这样做会更快，因为二进制语法可以直接从二进制构造整数。</target>
        </trans-unit>
        <trans-unit id="ac2f53a327ddcef69bcfc81c81e743ec02f58d49" translate="yes" xml:space="preserve">
          <source>The return value is to be any of the following values, indicating if the specified configuration parameter is valid:</source>
          <target state="translated">返回值为以下任意一个值,表示指定的配置参数是否有效。</target>
        </trans-unit>
        <trans-unit id="a53de66b6befed22fef727bcfc1593e2a3510e89" translate="yes" xml:space="preserve">
          <source>The return value is to be either of the following:</source>
          <target state="translated">返回值为以下任何一种:</target>
        </trans-unit>
        <trans-unit id="ceafeb40fcc33ae37d1bb500d86c43da7ff973a6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;case&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;case&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="667b4e9527fb89bbee21bc3c659692855e17e45e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;if&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="12267bfd95ce2e9cae7b8fb4988fa796d16c0a33" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;receive&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;receive&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="ea4fae033ca5b8c06d8b471ec021531504980c6e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;end_per_testcase/2&lt;/code&gt; is ignored by the test server, with exception of the &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; tuple.</source>
          <target state="translated">除了 &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;fail&lt;/code&gt; 元组，测试服务器将忽略 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="56770d741c762804a23c8684019a89bbb9d3b32f" translate="yes" xml:space="preserve">
          <source>The return value of calling this function is intended to be used in the &lt;code&gt;match_fun&lt;/code&gt; option in &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数的返回值打算在 &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;match_fun&lt;/code&gt; 选项中使用。</target>
        </trans-unit>
        <trans-unit id="76590aed6da8a4573a438a60f16632978a2bec67" translate="yes" xml:space="preserve">
          <source>The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;. If you do not want the callback to affect the outcome of the test, return the &lt;code&gt;Return&lt;/code&gt; data as it is given to the CTH. You can also modify the test result. By returning the &lt;code&gt;Config&lt;/code&gt; list with element &lt;code&gt;tc_status&lt;/code&gt; removed, you can recover from a test failure. As in all the pre hooks, it is also possible to fail/skip the test case in the post hook.</source>
          <target state="translated">CTH函数的返回值始终是套件/组/测试的结果与更新的 &lt;code&gt;CTHState&lt;/code&gt; 的组合。如果您不希望回调影响测试结果，请返回给CTH 的 &lt;code&gt;Return&lt;/code&gt; 数据。您也可以修改测试结果。通过返回删除了 &lt;code&gt;tc_status&lt;/code&gt; 元素的 &lt;code&gt;Config&lt;/code&gt; 列表，您可以从测试失败中恢复。像在所有前挂钩中一样，在后挂钩中失败/跳过测试用例也是可能的。</target>
        </trans-unit>
        <trans-unit id="dc96c849cea9a13470890e82d87865cfd4ec3cde" translate="yes" xml:space="preserve">
          <source>The return value of the expression is the resulting fun.</source>
          <target state="translated">表达式的返回值是产生的fun。</target>
        </trans-unit>
        <trans-unit id="ca104835aa5ad01d1fa3d939ad04e391832ceb22" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handler callback:</source>
          <target state="translated">fun的返回值指定日志事件是被丢弃还是转发到处理程序回调。</target>
        </trans-unit>
        <trans-unit id="d4e70786797f2c0c82a992fd6de3d9da04e6d44f" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handlers:</source>
          <target state="translated">fun的返回值指定日志事件是被丢弃还是转发到处理程序。</target>
        </trans-unit>
        <trans-unit id="8a15ba4a5d207f8ff27af670138d14092b913977" translate="yes" xml:space="preserve">
          <source>The return value of this call is:</source>
          <target state="translated">这个调用的返回值是:</target>
        </trans-unit>
        <trans-unit id="ad0e0fbdd470e29f0445d4c32a3c5589be7037b8" translate="yes" xml:space="preserve">
          <source>The return value of this function is the same as the result of the commands &lt;code&gt;openssl crl -hash&lt;/code&gt; and &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt;, when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the &lt;code&gt;c_rehash&lt;/code&gt; tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.</source>
          <target state="translated">当分别传递CRL或证书的颁发者名称时，此函数的返回值与 &lt;code&gt;openssl crl -hash&lt;/code&gt; 和 &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt; 命令的结果相同。 &lt;code&gt;c_rehash&lt;/code&gt; 工具使用此哈希来维护指向CRL文件的符号链接目录，以便于通过其发行者名称查找CRL。</target>
        </trans-unit>
        <trans-unit id="556ae7c31e2eeb819041e01f0988fe1443eb20ac" translate="yes" xml:space="preserve">
          <source>The return value reflects how many functions that matched, and is constructed as described in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. No tuple &lt;code&gt;{saved, N}&lt;/code&gt; is however ever returned (for obvious reasons).</source>
          <target state="translated">返回值反映了匹配的函数数量，并按 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 中的描述进行构造。但是，不会返回任何元组 &lt;code&gt;{saved, N}&lt;/code&gt; （出于明显的原因）。</target>
        </trans-unit>
        <trans-unit id="e0a236e08f99621d7b0efd68a7bc22730533f1a9" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt; erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2493a1b75922ce60ff03955e74f63fe68c01230" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值被 &lt;code&gt;disabled&lt;/code&gt; ， &lt;code&gt;blocked&lt;/code&gt; ， &lt;code&gt;blocked_normal&lt;/code&gt; 或 &lt;code&gt;enabled&lt;/code&gt; 。返回值描述了对 &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; 的调用之后的状态。有关返回值的信息，请参见 &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="060a85265e14ac614221fba12c3a188491993522" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt; Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a5c4a4e2556d9fc5599788448978bc86e18491" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; 相同，除了它们还包含术语 &lt;code&gt;Reply&lt;/code&gt; ，这是作为对 &lt;code&gt;call/3,4&lt;/code&gt; 的返回值的客户端答复。</target>
        </trans-unit>
        <trans-unit id="acd848a1f14ececc3a82ad290daef2754e5bb654" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt; scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16402449b6bab46b6acb25bee9687ea3d1da1cef" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="34736dd65ea7c5f985adcd3b21d438aa1d48110e" translate="yes" xml:space="preserve">
          <source>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;nlist&lt;/code&gt; varies. Often real errors are not reported as errors by &lt;code&gt;ls&lt;/code&gt;, even if, for example, a file or directory does not exist. &lt;code&gt;nlist&lt;/code&gt; is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</source>
          <target state="translated">以下函数的返回值在很大程度上取决于远程主机上FTP服务器的实现。特别是， &lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;nlist&lt;/code&gt; 的结果有所不同。 &lt;code&gt;ls&lt;/code&gt; 经常不会将实际错误报告为错误，即使例如文件或目录不存在。 &lt;code&gt;nlist&lt;/code&gt; 通常更严格，但是如果请求是存在但为空的目录内容的列表，则某些实现具有响应错误的特殊行为。</target>
        </trans-unit>
        <trans-unit id="28c7c4f49170e50d62e95547c1132e5f03288f96" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;State&lt;/code&gt; should be used in one or more subsequent calls to &lt;code&gt;&lt;a href=&quot;#mac_update-2&quot;&gt;mac_update/2&lt;/a&gt;&lt;/code&gt;. The MAC value is finally returned by calling &lt;code&gt;&lt;a href=&quot;#mac_final-1&quot;&gt;mac_final/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047a74f745ac921eabba62b69b8f674e3b65c169" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TrueListenPort&lt;/code&gt; is the port that is listened to. It is the same as &lt;code&gt;ListenPort&lt;/code&gt;, except when &lt;code&gt;ListenPort = 0&lt;/code&gt;. In that case a free port is selected by the underlying OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e4973c70cdd56da241fcf626185e66a1c55705" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UtilDesc&lt;/code&gt;(s) will be even more detailed.</source>
          <target state="translated">返回的 &lt;code&gt;UtilDesc&lt;/code&gt; 将更加详细。</target>
        </trans-unit>
        <trans-unit id="ea4255b1bb88d05e61ad743eab72330c07b40c58" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;outbound_streams&lt;/code&gt; and &lt;code&gt;inbound_streams&lt;/code&gt; are the stream numbers on the socket. These can be different from the requested values (&lt;code&gt;OutStreams&lt;/code&gt; and &lt;code&gt;MaxInStreams&lt;/code&gt;, respectively) if the peer requires lower values.</source>
          <target state="translated">返回的 &lt;code&gt;outbound_streams&lt;/code&gt; 和 &lt;code&gt;inbound_streams&lt;/code&gt; 是套接字上的流号。如果对等方要求使用较低的值，则这些值可以与请求的值（分别为 &lt;code&gt;OutStreams&lt;/code&gt; 和 &lt;code&gt;MaxInStreams&lt;/code&gt; ）不同。</target>
        </trans-unit>
        <trans-unit id="78c4a176ab5344343a3680d64f0f87276de46ba2" translate="yes" xml:space="preserve">
          <source>The returned array is suitable to use with the Unix system call &lt;code&gt;writev&lt;/code&gt;.</source>
          <target state="translated">返回的数组适合与Unix系统调用 &lt;code&gt;writev&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="45ff48530f77dbc6cc0743bbf1b0bea13f7efa44" translate="yes" xml:space="preserve">
          <source>The returned continuation either is or is not valid in the next call to this function. This is because the log can wrap and delete the file into which the continuation points. To ensure this does not occur, the log can be blocked during the search.</source>
          <target state="translated">返回的continuation在下一次调用该函数时要么有效,要么无效。这是因为日志可以包裹和删除延续指向的文件。为了确保这种情况不会发生,可以在搜索过程中屏蔽日志。</target>
        </trans-unit>
        <trans-unit id="563414bf21c4083de3c0b515b0ae801f03daf271" translate="yes" xml:space="preserve">
          <source>The returned fun augments the verify hostname matching according to the specific rules for the protocol in the argument.</source>
          <target state="translated">返回的fun会根据参数中协议的具体规则来增强验证主机名的匹配。</target>
        </trans-unit>
        <trans-unit id="1f4757970518220fdc7fe112f9433dc5ad370dd2" translate="yes" xml:space="preserve">
          <source>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</source>
          <target state="translated">返回的指针对任何适合分配的内存中的内置类型进行适当的对齐。</target>
        </trans-unit>
        <trans-unit id="b2f0dd9c815f2da7d427b069f2a9894879c7f90c" translate="yes" xml:space="preserve">
          <source>The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established.</source>
          <target state="translated">返回的引用唯一地标识服务范围内的传输。请注意,该函数会在传输连接建立之前返回。</target>
        </trans-unit>
        <trans-unit id="4e5ed52f640bec9583fe09c321a1dc7cfa7d394d" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;ListenSocket&lt;/code&gt; should be used in calls to &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; to accept incoming connection requests.</source>
          <target state="translated">返回的套接字 &lt;code&gt;ListenSocket&lt;/code&gt; 应在调用 &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; 中使用,以接受传入的连接请求。</target>
        </trans-unit>
        <trans-unit id="ab1d27e257509f8da3d8e76915e7736db74a82b0" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;Socket&lt;/code&gt; is used to send packets from this port with &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt;. When UDP packets arrive at the opened port, if the socket is in an active mode, the packets are delivered as messages to the controlling process:</source>
          <target state="translated">返回的套接字 &lt;code&gt;Socket&lt;/code&gt; 用于使用 &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt; 从此端口发送数据包。UDP数据包到达打开的端口时，如果套接字处于活动模式，则将这些数据包作为消息传递给控制进程：</target>
        </trans-unit>
        <trans-unit id="ba58f4a868c9920a0accc2470109df28ce1c8b33" translate="yes" xml:space="preserve">
          <source>The returned value equals &lt;code&gt;How&lt;/code&gt; before flag &lt;code&gt;scheduler_bind_type&lt;/code&gt; was changed.</source>
          <target state="translated">返回的值等于 &lt;code&gt;How&lt;/code&gt; 前旗 &lt;code&gt;scheduler_bind_type&lt;/code&gt; 改变。</target>
        </trans-unit>
        <trans-unit id="ad1f4738d1ee235637e8713b2fb0e1aed7b3c9ff" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;info&lt;/code&gt; is part of &lt;code&gt;OptionList&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;info&lt;/code&gt; 是 &lt;code&gt;OptionList&lt;/code&gt; 的一部分，否则返回的值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="671e79f941b79fced8adb6612252872802f7c324" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple &lt;code&gt;{NewTree, Max}&lt;/code&gt;, where &lt;code&gt;NewTree&lt;/code&gt; is the labeled tree and &lt;code&gt;Max&lt;/code&gt; is 1 plus the largest label value used. All previous annotation terms on the form &lt;code&gt;{label, X}&lt;/code&gt; are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704d94c2e818c260decb81dbc9e54e317cedcd87" translate="yes" xml:space="preserve">
          <source>The returned value is one of the following:</source>
          <target state="translated">返回的值是以下之一。</target>
        </trans-unit>
        <trans-unit id="17c9f8dadb89f1f4731e454e478946ba8977d737" translate="yes" xml:space="preserve">
          <source>The returned value of the first call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt; by a process will on most systems be the CPU utilization since system boot, but this is not guaranteed and the value should therefore be regarded as garbage. This also applies to the first call after a restart of &lt;code&gt;cpu_sup&lt;/code&gt;.</source>
          <target state="translated">自系统启动以来，在大多数系统上，进程首次调用 &lt;code&gt;util/0&lt;/code&gt; 或 &lt;code&gt;util/1&lt;/code&gt; 的返回值将是CPU利用率，但这不能保证，因此应将其视为垃圾。这也适用于 &lt;code&gt;cpu_sup&lt;/code&gt; 重新启动后的第一次调用。</target>
        </trans-unit>
        <trans-unit id="33e425aa419d45203b9e7b0885a322854194b3c4" translate="yes" xml:space="preserve">
          <source>The returned value when there are data available depends on the value of the &lt;code&gt;get_size&lt;/code&gt; option configured on the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt;. For more information see the documentation of the &lt;code&gt;get_size&lt;/code&gt; option for the &lt;code&gt;&lt;a href=&quot;#dist_ctrl_set_opt-3&quot;&gt;erlang:dist_ctrl_set_opt/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb8b0494dfde82da9ec11120fc8e7694cd4f11" translate="yes" xml:space="preserve">
          <source>The right hand side of a grammar rule may be empty. This is indicated by using the special symbol &lt;code&gt;'$empty'&lt;/code&gt; as rhs. Then the list grammar above may be simplified to:</source>
          <target state="translated">语法规则的右侧可能为空。这可以通过使用特殊符号 &lt;code&gt;'$empty'&lt;/code&gt; 作为rhs来表示。然后，上面的列表语法可以简化为：</target>
        </trans-unit>
        <trans-unit id="dc75d0c89181a304f45200607807515a4ebde020" translate="yes" xml:space="preserve">
          <source>The role of a Diameter node is determined by the user's implementation.</source>
          <target state="translated">Diameter节点的作用由用户的实现决定。</target>
        </trans-unit>
        <trans-unit id="416c824ca6a43adb95da91e2cb1751ab089f31b7" translate="yes" xml:space="preserve">
          <source>The room number is an attribute of the employee record. This is a structured attribute that consists of a tuple. The first element of the tuple identifies a corridor, and the second element identifies the room in that corridor. An alternative is to represent this as a record &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; instead of an anonymous tuple representation.</source>
          <target state="translated">房间号是员工记录的属性。这是一个由元组组成的结构化属性。元组的第一个元素标识一条走廊，第二个元素标识该走廊中的房间。一种替代方法是将其表示为一个记录 &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; 而不是匿名元组表示。</target>
        </trans-unit>
        <trans-unit id="577f0039c4fa2f0d1ea23b58d0300c235c47b7fd" translate="yes" xml:space="preserve">
          <source>The root certificate is a trusted certificate that is present in the trusted certificate database kept by the peer.</source>
          <target state="translated">根证书是对等体保存的可信证书数据库中存在的可信证书。</target>
        </trans-unit>
        <trans-unit id="52dbe02f6473ea542b1777651fa34126c38819b1" translate="yes" xml:space="preserve">
          <source>The root certificate name.</source>
          <target state="translated">根证书名称。</target>
        </trans-unit>
        <trans-unit id="53cd33d8adcdb9225af5611f87476b60c6686390" translate="yes" xml:space="preserve">
          <source>The root directory (&lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt;)</source>
          <target state="translated">根目录（ &lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="59cc46abe2ddea6a9a499abb0a284b3438d6e2bb" translate="yes" xml:space="preserve">
          <source>The routine above is called from the &lt;code&gt;uds_output&lt;/code&gt; routine:</source>
          <target state="translated">上面的例程是从 &lt;code&gt;uds_output&lt;/code&gt; 例程中调用的：</target>
        </trans-unit>
        <trans-unit id="899ef76204638a6cfef4214df04665f53c56597c" translate="yes" xml:space="preserve">
          <source>The routine builds an I/O vector containing the header bytes and the buffer (the opcode has been removed and the buffer length decreased by the output routine). If the queue is empty, we write the data directly to the socket (or at least try to). If any data is left, it is stored in the queue and then we try to send the queue (line 38). An acknowledgement is sent when the message is delivered completely (line 22). The &lt;code&gt;send_out_queue&lt;/code&gt; sends acknowledgements if the sending is completed there. If the port is in &lt;code&gt;command&lt;/code&gt; mode, the Erlang code serializes the send operations so that only one packet can be waiting for delivery at a time. Therefore the acknowledgement can be sent whenever the queue is empty.</source>
          <target state="translated">该例程将构建一个包含头字节和缓冲区的I / O向量（输出例程已删除操作码，并减小了缓冲区长度）。如果队列为空，则将数据直接写入套接字（或至少尝试写入）。如果有剩余数据，则将其存储在队列中，然后尝试发送队列（第38行）。消息完全传递后，将发送确认（第22行）。该 &lt;code&gt;send_out_queue&lt;/code&gt; 如果发送的还有完成发送确认。如果端口处于 &lt;code&gt;command&lt;/code&gt; 模式，则Erlang代码会序列化发送操作，以便一次只能等待一个数据包。因此，只要队列为空，就可以发送确认。</target>
        </trans-unit>
        <trans-unit id="673662eb2121ca41425305edda42a80c288cd1e9" translate="yes" xml:space="preserve">
          <source>The routine initializes the single global data structure and returns a pointer to the driver entry. The routine is called when &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; is called from Erlang.</source>
          <target state="translated">该例程初始化单个全局数据结构，并返回指向驱动程序条目的指针。从Erlang 调用 &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; 时将调用该例程。</target>
        </trans-unit>
        <trans-unit id="c17dc336612f84d4c81b404a94002b4ef123f628" translate="yes" xml:space="preserve">
          <source>The routine is simple: it first handles the fact that the output select will concern a socket in the business of connecting (and the connecting blocked). If the socket is in a connected state, it simply sends the output queue. This routine is called when it is possible to write to a socket where we have an output queue, so there is no question what to do.</source>
          <target state="translated">该例程很简单:它首先处理输出选择将关注一个处于连接业务中的套接字(以及连接阻塞)的事实。如果套接字处于连接状态,它只需发送输出队列。当我们可以向一个有输出队列的套接字写入时,就会调用这个例程,所以不存在该怎么做的问题。</target>
        </trans-unit>
        <trans-unit id="77a723120b7e543c1800db7036e53529bcbbae13" translate="yes" xml:space="preserve">
          <source>The routine tries to read data until a packet is read or the &lt;code&gt;buffered_read_package&lt;/code&gt; routine returns a &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (an internally defined constant for the module, which means that the read operation resulted in an &lt;code&gt;EWOULDBLOCK&lt;/code&gt;). If the port is in &lt;code&gt;command&lt;/code&gt; mode, the reading stops when one package is read. If the port is in &lt;code&gt;data&lt;/code&gt; mode, the reading continues until the socket buffer is empty (read failure). If no more data can be read and more is wanted (which is always the case when the socket is in &lt;code&gt;data&lt;/code&gt; mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_input&lt;/code&gt; callback be called when more data is available for reading.</source>
          <target state="translated">该例程尝试读取数据，直到读取了数据包或 &lt;code&gt;buffered_read_package&lt;/code&gt; 例程返回 &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; （模块的内部定义常量，这意味着读取操作导致 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; ）。如果端口处于 &lt;code&gt;command&lt;/code&gt; 模式，则在读取一个程序包时停止读取。如果端口处于 &lt;code&gt;data&lt;/code&gt; 模式，则继续读取直到套接字缓冲区为空（读取失败）。如果无法读取更多数据并且需要更多数据（在套接字处于 &lt;code&gt;data&lt;/code&gt; 模式时， &lt;code&gt;driver_select&lt;/code&gt; 就是这种情况），则在可以读取更多数据时，将调用 &lt;code&gt;uds_input&lt;/code&gt; 以使uds_input回调被调用。</target>
        </trans-unit>
        <trans-unit id="594d38181d8b0e2c57da4b81cceed123220efbd4" translate="yes" xml:space="preserve">
          <source>The row for the &lt;strong&gt;marked&lt;/strong&gt; function simply contains the sum of all &lt;strong&gt;calling&lt;/strong&gt; rows.</source>
          <target state="translated">被&lt;strong&gt;标记&lt;/strong&gt;函数的行仅包含所有&lt;strong&gt;调用&lt;/strong&gt;行的总和。</target>
        </trans-unit>
        <trans-unit id="f63f268b5b1ba7e518b6ca9840895c249dbd9600" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;called&lt;/strong&gt; functions contains statistics for the &lt;strong&gt;row's&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;marked&lt;/strong&gt; to the &lt;strong&gt;row's&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">被&lt;strong&gt;调用&lt;/strong&gt;函数的&lt;strong&gt;行&lt;/strong&gt;包含该行函数的统计信息，并具有约束条件，即仅考虑从&lt;strong&gt;标记&lt;/strong&gt;到该&lt;strong&gt;行&lt;/strong&gt;函数&lt;strong&gt;的&lt;/strong&gt;调用的情况。</target>
        </trans-unit>
        <trans-unit id="b591b9ee5241f27713065c70477c2cb23e6ae07b" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;calling&lt;/strong&gt; functions contain statistics for the &lt;strong&gt;marked&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;row's&lt;/strong&gt; function to the &lt;strong&gt;marked&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">&lt;strong&gt;调用&lt;/strong&gt;函数的行包含&lt;strong&gt;标记&lt;/strong&gt;函数的统计信息，并具有以下约束：仅考虑从该&lt;strong&gt;行的&lt;/strong&gt;函数对&lt;strong&gt;标记&lt;/strong&gt;函数进行调用的情况。</target>
        </trans-unit>
        <trans-unit id="23c9bc526d84923d88d3f3c4aca6eb88d00853db" translate="yes" xml:space="preserve">
          <source>The rules for handling the two address passing options are:</source>
          <target state="translated">两个地址传递选项的处理规则是:。</target>
        </trans-unit>
        <trans-unit id="65d47d40f9e3322daa06f6a9cc9586d8bced1031" translate="yes" xml:space="preserve">
          <source>The rules for importing variables into a fun has the consequence that certain pattern matching operations must be moved into guard expressions and cannot be written in the head of the fun. For example, you might write the following code if you intend the first clause of &lt;code&gt;F&lt;/code&gt; to be evaluated when the value of its argument is &lt;code&gt;Y&lt;/code&gt;:</source>
          <target state="translated">将变量导入有趣的规则的结果是，某些模式匹配操作必须移入保护表达式中，并且不能写在有趣的头部。例如，如果您打算在 &lt;code&gt;F&lt;/code&gt; 的第一个子句的参数值为 &lt;code&gt;Y&lt;/code&gt; 时对其进行评估，则可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="2b91da3a1a048b58314c1c111db21a5595f2f19a" translate="yes" xml:space="preserve">
          <source>The rules in an access file apply to files in the same directory and in subdirectories. If there exists more than one access file in the path to an asset, the rules in the access file nearest the requested asset is applied.</source>
          <target state="translated">访问文件中的规则适用于同一目录和子目录中的文件。如果一个资产的路径中存在多个访问文件,则适用离所请求的资产最近的访问文件中的规则。</target>
        </trans-unit>
        <trans-unit id="e5d1d20f6a0a42644b3aeca3328fe18c9290d7a4" translate="yes" xml:space="preserve">
          <source>The rules used for name binding vary between domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d38dd44eba1bb3a7ed4f14eaa12a0a33476ba0b" translate="yes" xml:space="preserve">
          <source>The running configuration cannot be deleted and &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; must be advertised by the server.</source>
          <target state="translated">运行中的配置不能删除，并且 &lt;code&gt;:candidate&lt;/code&gt; 或 &lt;code&gt;:startup&lt;/code&gt; 必须由服务器发布。</target>
        </trans-unit>
        <trans-unit id="c79b5264357f5534cee7c6ef4abc2fbac9660cbd" translate="yes" xml:space="preserve">
          <source>The runtime encoders and decoders execute within a catch and return &lt;code&gt;{ok, Data}&lt;/code&gt; or &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; where &lt;code&gt;Description&lt;/code&gt; is an Erlang term describing the error.</source>
          <target state="translated">运行时编码器和解码器在catch中执行并返回 &lt;code&gt;{ok, Data}&lt;/code&gt; 或 &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; ，其中 &lt;code&gt;Description&lt;/code&gt; 是描述错误的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="1bd1e0cd445f2587e2d274da2e56ba41b0124a77" translate="yes" xml:space="preserve">
          <source>The runtime for the process, that is, the time that the process has been scheduled in.</source>
          <target state="translated">进程的运行时间,即进程被安排的时间。</target>
        </trans-unit>
        <trans-unit id="0477f575396c2d31573bf1177d25d393514ae802" translate="yes" xml:space="preserve">
          <source>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</source>
          <target state="translated">启用时,运行时开销为每次分配一个字。这一点可能会在将来的任何时候改变。</target>
        </trans-unit>
        <trans-unit id="b52f5dd159b93b951f3b921ca939f057c72f0232" translate="yes" xml:space="preserve">
          <source>The runtime system aborts producing a core dump, if that is enabled in the OS.</source>
          <target state="translated">如果操作系统中启用了核心转储,运行时系统会中止生成核心转储。</target>
        </trans-unit>
        <trans-unit id="aedc7575975308f8d984dc3da045923bc133d996" translate="yes" xml:space="preserve">
          <source>The runtime system always takes a lock before running any code in a driver.</source>
          <target state="translated">运行时系统总是在运行驱动程序中的任何代码之前采取锁。</target>
        </trans-unit>
        <trans-unit id="0b7cb9b63bdfde371041fe9ecc549e2d3f8291fb" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in &lt;strong&gt;interactive&lt;/strong&gt; or &lt;strong&gt;embedded&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;:</source>
          <target state="translated">可以在&lt;strong&gt;交互式&lt;/strong&gt;或&lt;strong&gt;嵌入式&lt;/strong&gt;模式下启动运行系统。哪一个由命令行标志 &lt;code&gt;-mode&lt;/code&gt; 决定：</target>
        </trans-unit>
        <trans-unit id="4f194749f9a0abb8f1fc16278fdf82b7ab426657" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in either &lt;strong&gt;embedded&lt;/strong&gt; or &lt;strong&gt;interactive&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;.</source>
          <target state="translated">可以以&lt;strong&gt;嵌入式&lt;/strong&gt;或&lt;strong&gt;交互&lt;/strong&gt;方式启动运行系统。哪一个由命令行标志 &lt;code&gt;-mode&lt;/code&gt; 决定。</target>
        </trans-unit>
        <trans-unit id="15f0b229ab22b4247144711faf8addfff0acec04" translate="yes" xml:space="preserve">
          <source>The runtime system can represent binaries up to 64 bytes as heap binaries. They are always copied when sent in messages, but they require less memory if they are not sent to another process and garbage collection is cheaper.</source>
          <target state="translated">运行时系统可以将最大64字节的二进制文件表示为堆二进制文件。它们在消息中发送时总是被复制,但如果它们不被发送到另一个进程,则需要较少的内存,而且垃圾收集也比较便宜。</target>
        </trans-unit>
        <trans-unit id="52f7c1d9fec74d1d87c2aa61e92b2f7031396fc6" translate="yes" xml:space="preserve">
          <source>The runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors.</source>
          <target state="translated">运行时系统的默认操作&lt;strong&gt;不&lt;/strong&gt;绑定调度到逻辑处理器。</target>
        </trans-unit>
        <trans-unit id="fc86dfe1cb0ce649fa9cfc863da2e29d5456fcde" translate="yes" xml:space="preserve">
          <source>The runtime system exits with integer value &lt;code&gt;Status&lt;/code&gt; as status code to the calling environment (OS).</source>
          <target state="translated">运行时系统以整数值 &lt;code&gt;Status&lt;/code&gt; 退出，作为到调用环境（OS）的状态代码。</target>
        </trans-unit>
        <trans-unit id="d758492b235e5ae70fd740805f185d0f947792cf" translate="yes" xml:space="preserve">
          <source>The runtime system is halted by calling &lt;code&gt;halt/0,1&lt;/code&gt;. For details, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">通过调用 &lt;code&gt;halt/0,1&lt;/code&gt; 停止运行时系统。有关详细信息，请参见ERTS中的 &lt;code&gt;erlang(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="737f6644d46fc0b71dce7d366db4bb2df97d5f28" translate="yes" xml:space="preserve">
          <source>The runtime system is started using a &lt;strong&gt;boot script&lt;/strong&gt;. The boot script contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">运行时系统使用&lt;strong&gt;启动脚本启动&lt;/strong&gt;。启动脚本包含有关加载哪些代码以及启动哪些进程和应用程序的说明。</target>
        </trans-unit>
        <trans-unit id="f56dfcd70ad1156309d29b60e153328381d89995" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries can however fail if deprecated features are used.</source>
          <target state="translated">如果主要版本不同,或者主要版本相同,而NIF库使用的次要版本大于运行时系统使用的版本,运行时系统通常会拒绝加载NIF库。然而,在两个主要版本的过渡期内,在主要版本发生变化后,允许使用主要版本较低的旧NIF库。但是,如果使用了废弃的功能,这种旧的NIF库可能会失败。</target>
        </trans-unit>
        <trans-unit id="08dd149e2b409426602405250d51453a541efc1d" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a driver if the major versions differ, or if the major versions are equal and the minor version used by the driver is greater than the one used by the runtime system. Old drivers with lower major versions are however allowed after a bump of the major version during a transition period of two major releases. Such old drivers can, however, fail if deprecated features are used.</source>
          <target state="translated">如果主要版本不同,或者主要版本相同,而驱动程序使用的次要版本大于运行时系统使用的版本,运行时系统通常会拒绝加载驱动程序。然而,在两个主要版本的过渡期内,在主要版本发生变化后,允许使用主要版本较低的旧驱动程序。但是,如果使用了被废弃的功能,这样的旧驱动可能会失败。</target>
        </trans-unit>
        <trans-unit id="c5369a70b6288773729d2ce3df1f9a69da1e0a6d" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_cpu_quota&quot;&gt;cpu quota&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8941217d6f38b36e1857530b5476e0fe59285c" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行时系统重新读取可用的CPU信息，并更新其内部存储的有关 &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; 以及已 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt; 的逻辑处理器数量的信息。</target>
        </trans-unit>
        <trans-unit id="1318205b88fb228dd3bc1e3526e8e8a8014305b4" translate="yes" xml:space="preserve">
          <source>The runtime system sees that &lt;code&gt;Bin1&lt;/code&gt; is the result from a previous append operation (not from the latest append operation), so it &lt;strong&gt;copies&lt;/strong&gt; the contents of &lt;code&gt;Bin1&lt;/code&gt; to a new binary, reserve extra storage, and so on. (Here is not explained how the runtime system can know that it is not allowed to write into &lt;code&gt;Bin1&lt;/code&gt;; it is left as an exercise to the curious reader to figure out how it is done by reading the emulator sources, primarily &lt;code&gt;erl_bits.c&lt;/code&gt;.)</source>
          <target state="translated">运行时系统会发现 &lt;code&gt;Bin1&lt;/code&gt; 是上一个追加操作（而不是最新的追加操作）的结果，因此它将 &lt;code&gt;Bin1&lt;/code&gt; 的内容&lt;strong&gt;复制&lt;/strong&gt;到新的二进制文件中，保留了额外的存储空间，依此类推。（这里没有解释运行时系统如何知道不允许将其写入 &lt;code&gt;Bin1&lt;/code&gt; ；好奇的读者可以将其作为练习，通过读取仿真器源（主要是 &lt;code&gt;erl_bits.c&lt;/code&gt; ）来了解如何完成此操作。）</target>
        </trans-unit>
        <trans-unit id="68dc9c39652a0fdf0a0c35a5221cd9cab865f995" translate="yes" xml:space="preserve">
          <source>The runtime system terminates if the Erlang shell is terminated.</source>
          <target state="translated">如果Erlang shell被终止,运行时系统就会终止。</target>
        </trans-unit>
        <trans-unit id="8b6b04664129c94fdc81f4426dc13b0df0dd9a3c" translate="yes" xml:space="preserve">
          <source>The runtime system thread that caused the crash dump</source>
          <target state="translated">导致崩溃转储的运行时系统线程。</target>
        </trans-unit>
        <trans-unit id="4f7e46dc24b0cfeac08d7cf03ae6775df22b65c6" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt; erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788e5f8c02e60181a54b252b202da78929f68515" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在具有SMP支持的运行时系统中运行驱动程序时，运行时系统在执行此驱动程序的所有端口上使用端口级锁定，而不是驱动程序级锁定。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="625eb63fcb0f8ad6e285974d83dcb34f448ce002" translate="yes" xml:space="preserve">
          <source>The runtime user interface for exclusive decode consists of the following two functions:</source>
          <target state="translated">独占解码的运行时用户界面由以下两个函数组成。</target>
        </trans-unit>
        <trans-unit id="10052e899db5ca3ebb8a3e418f1fe079cb6f6070" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;BootArgs&lt;/code&gt; are used when restarting the system unless the &lt;code&gt;mode&lt;/code&gt; option is given, allowing the code loading mode to be set to either &lt;code&gt;embedded&lt;/code&gt; or &lt;code&gt;interactive&lt;/code&gt;. All other &lt;code&gt;BootArgs&lt;/code&gt; remain the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b6a0c2dcea74f8fdf356aa85c68643c16e46c9" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;ct_hooks&lt;/code&gt; statement without the configuration file would cause HTML logging of all NETCONF connections in to the test case HTML log.</source>
          <target state="translated">没有配置文件的相同 &lt;code&gt;ct_hooks&lt;/code&gt; 语句将导致将所有NETCONF连接的HTML日志记录到测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="a3709997045bd7e766642b396a1ae2ff1790a0c5" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#NEWER_REFERENCE_EXT&quot;&gt; NEWER_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cafba0455eaee6936a3e5ea593c4c5aeb6bf49c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt; NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; except &lt;code&gt;ID&lt;/code&gt; is only one word (&lt;code&gt;Len&lt;/code&gt; = 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea96b7a47c7fc1b8ece94f94b50b492d47704af4" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#atom_to_binary-2&quot;&gt;atom_to_binary &lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Atom, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b840cffdebe323b082a218d46a487482c44da" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom &lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Binary, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16253d023286775d0b13863a202d80291f45e4b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#binary_to_existing_atom-2&quot;&gt; binary_to_existing_atom&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(Binary, utf8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32303bc64eb7b0ab0bc9a4d9709684faf012a52" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt; check_process_code(Pid, Module, []) &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d70dc4cc333eac788e481d9bbdc225c08c481a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2aaed7b59951ec082934bf672a9d13e59338ac6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Actions = []&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered. This creates an anonymous server.</source>
          <target state="translated">与 &lt;code&gt;Actions = []&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 相同，除了必须没有注册任何 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 。这将创建一个匿名服务器。</target>
        </trans-unit>
        <trans-unit id="00ce5e89ff01ab82881d9162fffdab56312f4944" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt; garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01deb53c6f9077db7db997ce628218c4238aba6e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acdff1fb52f7f6abb40837b1c3ed5e2d87b9d73a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; but the &lt;code&gt;Option&lt;/code&gt;&lt;code&gt;{netns, Namespace}&lt;/code&gt; sets a network namespace for the OS call, on platforms that supports that feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b6d66e5228a9dab8918f6a6c98f7d11d0ba7da" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt; halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85756b3d7fbfe5ef4170983b9b2a6fc5fb5e5087" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="1e5fb0bebe29ee84d11970a1ce3108bad78b288e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="5489eea97ac0b20ab3a3e94d0baa556249bc9b91" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#restart-1&quot;&gt;restart([])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fefb7e584cdbf5a581059aa7dafa15348d8ceb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest, Msg, [nosuspend | Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ab0cbd248cdcbee578633286dab593f1d8ff75" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest, Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa8e723ce6c07be8e482111c905cf750f679e8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt; ，但是具有布尔返回值。</target>
        </trans-unit>
        <trans-unit id="d2197ab46f758634a9dcf871583d61827a00cf65" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt; ，但是如果发送了消息，则返回 &lt;code&gt;true&lt;/code&gt; ;如果未发送消息，则返回 &lt;code&gt;false&lt;/code&gt; ，因为必须暂停发送者。</target>
        </trans-unit>
        <trans-unit id="17dbd65d2e71dbcfa15810e97f9ccf3f0bc406e6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(Node,erlang,apply,[Fun,[]],Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request using the fun &lt;code&gt;Fun&lt;/code&gt; of arity zero as entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1075e0e25bfb14e858cab7e38be5445bc5ac4682" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;, except that it also include information about all dirty I/O schedulers.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 相同，除了它还包含有关所有脏I / O调度程序的信息。</target>
        </trans-unit>
        <trans-unit id="f4ceb7a27c576e85ef9e754da89ddaf1dfd654ed" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4b72b3a948c1e65ff99938c20b299ba036c263f7" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae50f76bc5179efbef54eeac2130b4b037ae6a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaf6b5c71e3fafb1e75897b45c0e3840025bb7c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt; ，保留它是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="d5a1ef850fec5e3df173bd9dd2c7e3dbb0636f60" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="619006029171444306cc4c87f6a95f63bb972338" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;compile(Regexp,[])&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;compile(Regexp,[])&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="17d52831ded701ec877189bfcc53acad1352798f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;eval/1&lt;/code&gt;, but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. For information about the variable bindings, see &lt;code&gt;erl_eval(3)&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;eval/1&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定的信息，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08c1e708a98116e2d68d4f0a5026b6a10643e95a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3ebcfaf2f1268befcb2c2ddd0543f3e6acf79842" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="47b9133116b8c5faac32e3c70f25a2bffa651d8f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;path_script/2&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">与 &lt;code&gt;path_script/2&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40cc315183d06f20b4fd979426474e04d552a45f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;script/1&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">与 &lt;code&gt;script/1&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e8982b6aae2a82fb446c9ac15561cf18afb817" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{bof, Offset}&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;{bof, Offset}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0277407f00337c8bdaf1cca96cdd266e8ea8198" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; with reasonable default values for &lt;code&gt;Size&lt;/code&gt; and &lt;code&gt;Delay&lt;/code&gt; (roughly some 64 KB, 2 seconds).</source>
          <target state="translated">与 &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; 相同，并具有合理的 &lt;code&gt;Size&lt;/code&gt; 和 &lt;code&gt;Delay&lt;/code&gt; 默认值（大约64 KB，2秒）。</target>
        </trans-unit>
        <trans-unit id="6b2899bd1d4addd7a93d120f07f6e7b10a7d0282" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{keep_state,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9abc573bcafbc0ede0496d990dff24d6e1602d6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7228431770d5bb25829bb566f3e53142c058363b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{read_ahead, Size}&lt;/code&gt; with a reasonable default value for &lt;code&gt;Size&lt;/code&gt; (roughly some 64 KB).</source>
          <target state="translated">一样 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 与用于合理的默认值 &lt;code&gt;Size&lt;/code&gt; （大致约64 KB）。</target>
        </trans-unit>
        <trans-unit id="fffe3043c0d576fd591d515cb53a9c26beff3c1c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4ea9e9c62a5f384a690dd1c1b7a864f413d95a" translate="yes" xml:space="preserve">
          <source>The same as above with &lt;code&gt;Offset&lt;/code&gt; 0.</source>
          <target state="translated">与上面的 &lt;code&gt;Offset&lt;/code&gt; 0 相同。</target>
        </trans-unit>
        <trans-unit id="b7fb7711e2123424816edf13ae376ab2d5c4aacc" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#block_call-5&quot;&gt;rpc:block_call(Node, Module, Function, Args, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3087fc6d1e1d288aa13b376d8923b63a482b45" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:call(Node,erlang,apply,[Fun,[]],Timeout)&lt;/a&gt;&lt;/code&gt;. May raise all the same exceptions as &lt;code&gt;erpc:call/5&lt;/code&gt; plus an &lt;code&gt;{erpc, badarg}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception if &lt;code&gt;Fun&lt;/code&gt; is not a fun of zero arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e22e69dc4e1d35bdb54ddabf28dba9a56102a3" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:multicall(Nodes,erlang,apply,[Fun,[]],Timeout)&lt;/a&gt;&lt;/code&gt;. May raise all the same exceptions as &lt;code&gt;erpc:multicall/5&lt;/code&gt; plus an &lt;code&gt;{erpc, badarg}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception if &lt;code&gt;Fun&lt;/code&gt; is not a fun of zero arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee35c7530384a3e971280a311d28237b1c1f4112" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;erpc:send_request(Node,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2663f078e97ac60be1391fffa07548dd9dddda25" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;rpc:call(Node, Module, Function, Args, Timeout)&lt;/a&gt;&lt;/code&gt; with the exception that it also blocks other &lt;code&gt;rpc:block_call()&lt;/code&gt; operations from executing concurrently on the node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6f525a67ffb4882ef9baaad9bc0a4226046d4a" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#cast-4&quot;&gt;erpc:cast(Node,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61097ae2d1a418f76c6a736c6fdbdb81a93b1f3" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;&lt;a href=&quot;#cast-4&quot;&gt;erpc:multicast(Nodes,erlang,apply,[Fun,[]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b12e07cbe44403181759c4034c4f3d2fe0c1ce" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="71c6f84a59f77755e69a52beb91ed4b1a4c03ff2" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="ee4e69e3e7435faa22aa0647b7b837e57300ad5e" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="4780b4915f09916bc2a903be56062c7fb948d806" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但是效率更高。</target>
        </trans-unit>
        <trans-unit id="bf890bcea15d91e1f7af9ee8721c2b6276c19354" translate="yes" xml:space="preserve">
          <source>The same as eariler with &lt;code&gt;Offset&lt;/code&gt; 0, that is, &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Offset&lt;/code&gt; 0的伯尼尔（即 &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f54a8f32c826632119e96a56421e6183f9acc41" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(Node,Fun,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e24153272f6cb2370114e16e592dbcdb26422d5" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(node(),Fun,Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e954c34db34f236fe12717f394cd92ea286c58" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-3&quot;&gt;spawn_request(node(),Fun,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba851e8e2b9c4b92403c2b4b7f3862971b2da77" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(Node,Module,Function,Args,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b62a093725450c7a9da971419193226f8402b35" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(node(),Module,Function,Args,Options)&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6560052e03ae63c0339d4867d19863becd398766" translate="yes" xml:space="preserve">
          <source>The same as the call &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request(node(),Module,Function,Args,[])&lt;/a&gt;&lt;/code&gt;. That is, a spawn request on the local node with no options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c0a4c6fa2c41025ffdbf6a4c8cdfc2dbae33ea" translate="yes" xml:space="preserve">
          <source>The same example as in the &lt;code&gt;&lt;a href=&quot;#example-of-crypto_one_time-5&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt;, but now with one call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_one_time_aead-6&quot;&gt;crypto_one_time_aead/6&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab38c5d8455e8d0889435a58218240d925e13378" translate="yes" xml:space="preserve">
          <source>The same example as in the &lt;code&gt;&lt;a href=&quot;#examples-of-crypto_init-4-and-crypto_update-2&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt;, but now with one call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efec8691cd75c256c32c494b80c6d71a6ded7b5a" translate="yes" xml:space="preserve">
          <source>The same example as the first sign example, except that a password protects the key down in the Engine.</source>
          <target state="translated">与第一个标志的例子相同,只是在Engine中用密码保护键下来。</target>
        </trans-unit>
        <trans-unit id="435f34be8c79fde6527a5114b17d96ad43869933" translate="yes" xml:space="preserve">
          <source>The same example but now using the Erlang ssh client to contact the Erlang server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6845f7d38c3df436bd3fca0892dbe8ee97c2a305" translate="yes" xml:space="preserve">
          <source>The same example but using the Erlang ssh client:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11685d22af41c7bdec311d8efb6717608cc97597" translate="yes" xml:space="preserve">
          <source>The same failure as for &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 相同的故障。</target>
        </trans-unit>
        <trans-unit id="37284fa9bdbec3125fb6f5f2938b0a9140415e5c" translate="yes" xml:space="preserve">
          <source>The same happens if you insert a binary into an Ets table, send it to a port using &lt;code&gt;erlang:port_command/2&lt;/code&gt;, or pass it to &lt;code&gt;enif_inspect_binary&lt;/code&gt; in a NIF.</source>
          <target state="translated">如果将二进制文件插入Ets表，使用 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 将其发送到端口，或者将其传递到NIF中的 &lt;code&gt;enif_inspect_binary&lt;/code&gt; ，也会发生同样的情况。</target>
        </trans-unit>
        <trans-unit id="8dd676fc032f39da8f11e805e928df982b381e69" translate="yes" xml:space="preserve">
          <source>The same logic applies to explicitly imported functions from other modules, as to locally defined functions. It is not allowed to both import a function from another module and have the function declared in the module at the same time:</source>
          <target state="translated">同样的逻辑适用于从其他模块中显式导入的函数和本地定义的函数。不允许既从另一个模块导入一个函数,同时又在该模块中声明该函数。</target>
        </trans-unit>
        <trans-unit id="c9a8dd64d3d825a10122f8306efa89f8d1dff40d" translate="yes" xml:space="preserve">
          <source>The same occurs if &lt;code&gt;Dest&lt;/code&gt; refers to a local port that is busy. For all other destinations (allowed for the ordinary send operator &lt;code&gt;'!'&lt;/code&gt;), this function sends the message and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 引用的是繁忙的本地端口，则会发生同样的情况。对于所有其他目的地（允许普通的send运算符 &lt;code&gt;'!'&lt;/code&gt; ），此函数发送消息并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c986670ac5f53fe5b7d5d769f706fae8b44b1bd" translate="yes" xml:space="preserve">
          <source>The same principles of serialization apply when passing resource terms in messages to remote nodes and back again. A resource term will act stale on all nodes except the node where its resource object is still alive in memory.</source>
          <target state="translated">在将消息中的资源项传递给远程节点并再传递回来时,同样适用序列化原则。除了其资源对象在内存中仍然有效的节点外,资源项在所有节点上都会失效。</target>
        </trans-unit>
        <trans-unit id="4f281f033368479cef02a66d827c4b8a6fe27bfd" translate="yes" xml:space="preserve">
          <source>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to &lt;code&gt;error_logger.&lt;/code&gt;</source>
          <target state="translated">脏更新可能会发生相同的问题。在当前节点上本地检测到过载，但其原因可能在另一个节点上。如果任何表驻留在另一个节点上（无论是否复制），应用程序进程都可能导致高负载。默认情况下，此事件报告给 &lt;code&gt;error_logger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb9bbb6e34766185444c1af2a9a7f778b5a58e67" translate="yes" xml:space="preserve">
          <source>The same program can also be written as:</source>
          <target state="translated">同样的程序也可以写成。</target>
        </trans-unit>
        <trans-unit id="2fc6942530a03944111630cfbde674aeb2b9833c" translate="yes" xml:space="preserve">
          <source>The same reasons for using the parse transformation apply to &lt;code&gt;dbg&lt;/code&gt;, maybe even more, as filtering using Erlang code is not a good idea when tracing (except afterwards, if you trace to file). The concept is similar to that of &lt;code&gt;ets:fun2ms/1&lt;/code&gt; except that you usually use it directly from the shell (which can also be done with &lt;code&gt;ets:fun2ms/1&lt;/code&gt;).</source>
          <target state="translated">使用parg转换的相同原因也适用于 &lt;code&gt;dbg&lt;/code&gt; ，甚至更多，因为在跟踪时使用Erlang代码进行过滤不是一个好主意（除非以后跟踪到文件，否则除外）。该概念与 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 相似，不同之处在于您通常直接从外壳中使用它（也可以使用 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 来完成）。</target>
        </trans-unit>
        <trans-unit id="be2c67bb51461ede16f91f4276fe7a51514360a8" translate="yes" xml:space="preserve">
          <source>The same result can be obtained by using the flag &lt;code&gt;call&lt;/code&gt; only and setting a match specification on local or global function calls as follows:</source>
          <target state="translated">通过仅使用标志 &lt;code&gt;call&lt;/code&gt; 并在本地或全局函数调用上设置匹配规范，可以获得相同的结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="6367b3aadbf1b22efb4fe6d60edce34f7915ed4d" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used by the preprocessor, which supports file inclusion, macros, and conditional compilation:</source>
          <target state="translated">预处理器使用与模块属性相同的语法,支持文件包含、宏和条件编译。</target>
        </trans-unit>
        <trans-unit id="1ba61a6106c571f4543444dde7af8861fee4288b" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for changing the pre-defined macros &lt;code&gt;?FILE&lt;/code&gt; and &lt;code&gt;?LINE&lt;/code&gt;:</source>
          <target state="translated">与模块属性相同的语法用于更改预定义的宏 &lt;code&gt;?FILE&lt;/code&gt; 和 &lt;code&gt;?LINE&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="49b27eed80040be071f7bd6b90b55a6ca7a1a602" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for record definitions:</source>
          <target state="translated">记录定义使用与模块属性相同的语法。</target>
        </trans-unit>
        <trans-unit id="652d4a8a5d229c7cd102ddf9155b41205986af36" translate="yes" xml:space="preserve">
          <source>The same, provided there are &amp;lt; 40 previous capturing subpatterns</source>
          <target state="translated">相同，前提是之前的捕获子图案少于40个</target>
        </trans-unit>
        <trans-unit id="1f8c820898fda9a674e186f206f12995037f99bb" translate="yes" xml:space="preserve">
          <source>The scanner will, by default, be built as a reentrant scanner &lt;strong&gt;if&lt;/strong&gt; the flex utility supports this (it depends on the version of flex). It is possible to explicitly disable this even when flex support this. Use &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; when configuring the application.</source>
          <target state="translated">&lt;strong&gt;如果&lt;/strong&gt; flex实用程序支持，则默认情况下，该扫描程序将被构建为可重入扫描程序（取决于flex的版本）。即使flex支持此功能，也可以显式禁用此功能。配置应用程序时，请使用 &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0106bb004e9ef4cae180d81bd2193ccedbf77a79" translate="yes" xml:space="preserve">
          <source>The scanning was successful. &lt;code&gt;Tokens&lt;/code&gt; is the list of tokens including &lt;strong&gt;dot&lt;/strong&gt;.</source>
          <target state="translated">扫描成功。 &lt;code&gt;Tokens&lt;/code&gt; 是令牌的列表，包括&lt;strong&gt;dot&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5b2eae5d531637391bdf1a2942db36f759f3d1ab" translate="yes" xml:space="preserve">
          <source>The scenario is illustrated in the following figure:</source>
          <target state="translated">该方案如下图所示。</target>
        </trans-unit>
        <trans-unit id="1b0072021dd8918e3e4a00150a4be77d097faeb0" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt; +sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb445fb55208c8d6300f1c0c3c7ddd0fdd5dffb" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt;+sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">也可以通过将命令行参数 &lt;code&gt;+sbt&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 来设置调度程序绑定类型。</target>
        </trans-unit>
        <trans-unit id="b9aa6c41e456afc02a165b00e6454af974767459" translate="yes" xml:space="preserve">
          <source>The scheduler ids whose allocator instances will be searched. A scheduler id of 0 will refer to the global instance that is not tied to any particular scheduler. Defaults to all schedulers and the global instance.</source>
          <target state="translated">调度器id,其分配器实例将被搜索。调度程序id为0时,指的是不与任何特定调度程序绑定的全局实例。默认为所有调度程序和全局实例。</target>
        </trans-unit>
        <trans-unit id="f8238b4700efd0d55eb3ba098718fdc8466aa0bb" translate="yes" xml:space="preserve">
          <source>The schema file and all other files that Mnesia needs are kept in the Mnesia directory. The command-line option &lt;code&gt;-mnesia dir Dir&lt;/code&gt; can be used to specify the location of this directory to the Mnesia system. If no such command-line option is found, the name of the directory defaults to &lt;code&gt;Mnesia.Node&lt;/code&gt;.</source>
          <target state="translated">Mnesia所需的架构文件和所有其他文件都保存在Mnesia目录中。命令行选项 &lt;code&gt;-mnesia dir Dir&lt;/code&gt; 可用于指定该目录在Mnesia系统中的位置。如果找不到这样的命令行选项，则目录的名称默认为 &lt;code&gt;Mnesia.Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3f92f1963a15447bf5f1771a2c485f240d49382" translate="yes" xml:space="preserve">
          <source>The schema functions are as follows:</source>
          <target state="translated">模式功能如下:</target>
        </trans-unit>
        <trans-unit id="6c514498238aab18641162374c9ebc46e751b79e" translate="yes" xml:space="preserve">
          <source>The schema in the backup file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been used to generate the file &lt;code&gt;schema.DAT&lt;/code&gt;. Since there are no other disc resident tables than the schema, no other data files were created. The file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; was removed after the successful &quot;restoration&quot;. You also see some files that are for internal use by &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">备份文件 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 中的模式已用于生成文件 &lt;code&gt;schema.DAT&lt;/code&gt; 。由于除架构外没有其他磁盘驻留表，因此未创建其他数据文件。成功的&amp;ldquo;还原&amp;rdquo;后，文件 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 被删除。您还会看到一些 &lt;code&gt;Mnesia&lt;/code&gt; 内部使用的文件。</target>
        </trans-unit>
        <trans-unit id="9c0d7180f9e8c49acad7689271d60b75c4177036" translate="yes" xml:space="preserve">
          <source>The schema itself is a table and is possibly included in the backup. Each node where the schema table resides is regarded as a &lt;code&gt;db_node&lt;/code&gt;.</source>
          <target state="translated">模式本身是一个表，可能包含在备份中。模式表所在的每个节点都被视为 &lt;code&gt;db_node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cd14602cf9237e1ff86bf0c3f394217395aea3d" translate="yes" xml:space="preserve">
          <source>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;ram_copies&lt;/code&gt; (but not &lt;code&gt;disc_only_copies&lt;/code&gt;). At startup, &lt;code&gt;Mnesia&lt;/code&gt; uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; contains a list of nodes that &lt;code&gt;Mnesia&lt;/code&gt; also is to establish contact with besides those found in the schema. Default is &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">与其他表一样，模式表可以驻留在一个或多个节点上。模式表的存储类型可以是 &lt;code&gt;disc_copies&lt;/code&gt; 或 &lt;code&gt;ram_copies&lt;/code&gt; （但不能是 &lt;code&gt;disc_only_copies&lt;/code&gt; ）。在启动时， &lt;code&gt;Mnesia&lt;/code&gt; 使用其架构来确定要与哪些节点建立联系。如果已经启动任何其他节点，则启动节点会将其表定义与从其他节点带来的表定义合并。这也适用于架构表本身的定义。应用程序参数 &lt;code&gt;extra_db_nodes&lt;/code&gt; 包含一个列表， &lt;code&gt;Mnesia&lt;/code&gt; 除了在架构中找到的那些节点之外，还将与该节点建立联系。默认值为 &lt;code&gt;[]&lt;/code&gt; （空列表）。</target>
        </trans-unit>
        <trans-unit id="503d5a4fc67df91a919a603a14d890c204b2864e" translate="yes" xml:space="preserve">
          <source>The scheme portion of the URI gets converted into atom, meaning that atom leak may occur. Specifying a scheme validation fun is recommended unless the URI is already sanitized.</source>
          <target state="translated">URI的scheme部分会被转换为atom,这意味着可能会发生atom泄漏。建议指定一个方案验证函数,除非URI已经被净化。</target>
        </trans-unit>
        <trans-unit id="d3677cc5dde8dec9f0943fbc75e45b112aeaf536" translate="yes" xml:space="preserve">
          <source>The scope for a variable is its function clause. Variables bound in a branch of an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, or &lt;code&gt;receive&lt;/code&gt; expression must be bound in all branches to have a value outside the expression. Otherwise they are regarded as 'unsafe' outside the expression.</source>
          <target state="translated">变量的范围是其功能子句。绑定在 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;receive&lt;/code&gt; 表达式的分支中的变量必须在所有分支中进行绑定，以使其值在表达式之外。否则，它们在表达式之外被视为&amp;ldquo;不安全&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c6288b2668a38169687226d8d788cc7da7e3e234" translate="yes" xml:space="preserve">
          <source>The scope of a &lt;code&gt;::&lt;/code&gt; constraint is the &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; specification after which it appears. To avoid confusion, it is suggested that different variables are used in different constituents of an overloaded contract, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 约束的范围是 &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; 规范，之后出现。为避免混淆，建议在重载合同的不同组成部分中使用不同的变量，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6888ff9909aa4d3472400691e9c55573d784edc2" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in funs are as follows:</source>
          <target state="translated">funs中出现的变量的作用域规则如下。</target>
        </trans-unit>
        <trans-unit id="4404d931933003579634af4e100185e648005e9e" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in list comprehensions are as follows:</source>
          <target state="translated">列表理解中出现的变量的范围规则如下。</target>
        </trans-unit>
        <trans-unit id="57d16d66e3e9f378f0fafcdd50a83455cdc8ed0f" translate="yes" xml:space="preserve">
          <source>The script is checked for syntactic and semantic correctness before it is run. If there are warnings (such as unused variables), they are printed and the script will still be run. If there are errors, they are printed and the script will not be run and its exit status is &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">在运行脚本之前，将检查该脚本的语法和语义正确性。如果有警告（例如未使用的变量），则会打印警告，并且脚本仍将运行。如果有错误，将打印它们并且脚本将不会运行，并且其退出状态为 &lt;code&gt;127&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb62b1588228fdb2e00bea0a69e7992a3a90205" translate="yes" xml:space="preserve">
          <source>The search is retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (&lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">在同一位置使用选项 &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; 重试搜索，该搜索不会给出任何较长长度的有趣结果，因此搜索位置将前进到下一个字符（ &lt;code&gt;a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4117f8cd43f5fed32f2aebfe701accad0f731400" translate="yes" xml:space="preserve">
          <source>The search once again matches the empty string, giving &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt;.</source>
          <target state="translated">搜索再次匹配空字符串，得到 &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2957d4c2e73e120f5160a9d5de1e8eab79ab85bf" translate="yes" xml:space="preserve">
          <source>The search results in &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt;, so this search is also repeated with the extra options.</source>
          <target state="translated">搜索结果为 &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt; ，因此还会使用其他选项重复此搜索。</target>
        </trans-unit>
        <trans-unit id="7019ec1c2fea8d709b52cfb8681127b05dd6a6ce" translate="yes" xml:space="preserve">
          <source>The second argument is a string defining the magic cookie.</source>
          <target state="translated">第二个参数是一个定义魔力饼干的字符串。</target>
        </trans-unit>
        <trans-unit id="5d7c556937d2f0d9d84069b86f16a68647203e8c" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;code&gt;Config&lt;/code&gt; key-value list of runtime configuration data, which has the same value as the list returned by &lt;code&gt;init_per_suite&lt;/code&gt;. &lt;code&gt;init_per_testcase/2&lt;/code&gt; can modify this parameter or return it &quot;as is&quot;. The return value of &lt;code&gt;init_per_testcase/2&lt;/code&gt; is passed as parameter &lt;code&gt;Config&lt;/code&gt; to the test case itself.</source>
          <target state="translated">第二个参数是运行时配置数据的 &lt;code&gt;Config&lt;/code&gt; 键值列表，其值与 &lt;code&gt;init_per_suite&lt;/code&gt; 返回的列表相同。 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 可以修改此参数或&amp;ldquo;按原样&amp;rdquo;返回它。 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 的返回值作为参数 &lt;code&gt;Config&lt;/code&gt; 传递给测试用例本身。</target>
        </trans-unit>
        <trans-unit id="ab475df1b91ae9d944e6820d1389807d78bf68f6" translate="yes" xml:space="preserve">
          <source>The second argument is the array of &lt;code&gt;ErlNifFunc&lt;/code&gt; structures containing name, arity, and function pointer of each NIF.</source>
          <target state="translated">第二个参数是 &lt;code&gt;ErlNifFunc&lt;/code&gt; 结构的数组，其中包含每个NIF的名称，Arity和函数指针。</target>
        </trans-unit>
        <trans-unit id="0886faad82449f45fc6af07be32433d58c83fd99" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the module (&lt;code&gt;ch4&lt;/code&gt;).</source>
          <target state="translated">第二个参数是模块的名称（ &lt;code&gt;ch4&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ae91f868e0e36c5aab81d0643e970c9ad85647d4" translate="yes" xml:space="preserve">
          <source>The second argument is the plain node name.</source>
          <target state="translated">第二个参数是普通节点名称。</target>
        </trans-unit>
        <trans-unit id="68aa2b0acb6c307f4edca5d2585ef7f3b4bc172b" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;erl_accept&lt;/code&gt; is a struct &lt;code&gt;ErlConnect&lt;/code&gt; which contains useful information when a connection has been established, for example, the name of the Erlang node.</source>
          <target state="translated">&lt;code&gt;erl_accept&lt;/code&gt; 的第二个参数是结构 &lt;code&gt;ErlConnect&lt;/code&gt; ，该结构包含建立连接后的有用信息，例如Erlang节点的名称。</target>
        </trans-unit>
        <trans-unit id="fa4ea88aab8e44c4912833f7bf79be8a3c8b83f1" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;select&lt;/code&gt; is a &lt;code&gt;MatchSpecification&lt;/code&gt;. A &lt;code&gt;MatchSpecification&lt;/code&gt; is a list of &lt;code&gt;MatchFunction&lt;/code&gt;s, where each &lt;code&gt;MatchFunction&lt;/code&gt; consists of a tuple containing &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 的第二个参数是 &lt;code&gt;MatchSpecification&lt;/code&gt; 。甲 &lt;code&gt;MatchSpecification&lt;/code&gt; 是列表 &lt;code&gt;MatchFunction&lt;/code&gt; s，其中每个 &lt;code&gt;MatchFunction&lt;/code&gt; 由包含元组 &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="859328262eb9b89de95770488ed8f287011c831c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;ttb:format/2&lt;/code&gt; is a list of options as follows:</source>
          <target state="translated">&lt;code&gt;ttb:format/2&lt;/code&gt; 的第二个参数是选项列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="d294655854fb12427e99c41c78c6470facb9f485" translate="yes" xml:space="preserve">
          <source>The second argument to the filter fun.</source>
          <target state="translated">过滤器乐趣的第二个参数。</target>
        </trans-unit>
        <trans-unit id="5cfc99aab85772fdcb54b5e4fa0185d94a797c5c" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the &lt;strong&gt;callback module&lt;/strong&gt;, that is, the module where the callback functions are located, which is this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06be8768f8415da3e4862a8bcd381b621322fa1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located, which is this module.</source>
          <target state="translated">第二个参数 &lt;code&gt;?MODULE&lt;/code&gt; 是回调模块的名称，即回调函数所在的模块，即该模块。</target>
        </trans-unit>
        <trans-unit id="e11f122b81a9ab6f35f17499a7c2e31dc0343a63" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">第二个参数 &lt;code&gt;[]&lt;/code&gt; 是一个原样传递给回调函数 &lt;code&gt;init&lt;/code&gt; 的术语。在此， &lt;code&gt;init&lt;/code&gt; 不需要任何indata并忽略该参数。</target>
        </trans-unit>
        <trans-unit id="b862edb2184436a21646c9503b2f3762af04c9d1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;ch3&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located.</source>
          <target state="translated">第二个参数 &lt;code&gt;ch3&lt;/code&gt; 是回调模块的名称，即回调函数所在的模块。</target>
        </trans-unit>
        <trans-unit id="12a6cc1ddca791145f200b7b0393d7c9270fb068" translate="yes" xml:space="preserve">
          <source>The second clause sends a message to &quot;pong&quot;:</source>
          <target state="translated">第二个子句向 &quot;朋 &quot;发出信息。</target>
        </trans-unit>
        <trans-unit id="ae66ead42b1de13d39f41d149d9d7854f9c8aab9" translate="yes" xml:space="preserve">
          <source>The second connection is a session resumption using keying material from the previous handshake:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7315fa80ba44205c16b829da74dfc058d1a1d7a4" translate="yes" xml:space="preserve">
          <source>The second element of the PEM-entry is the ASN.1 &lt;code&gt;DER&lt;/code&gt; encoded key data:</source>
          <target state="translated">PEM条目的第二个元素是ASN.1 &lt;code&gt;DER&lt;/code&gt; 编码的密钥数据：</target>
        </trans-unit>
        <trans-unit id="c40944389ed2e7f80311414a40c89625de90b8fe" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function.</source>
          <target state="translated">元组的第二个元素是一个字符串(字符列表),代表函数的源文件的文件名。</target>
        </trans-unit>
        <trans-unit id="30419a9fbcf62ba4094ad4eff3e638ac58c744c8" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is the line number (an integer &amp;gt; 0) in the source file where the exception occurred or the function was called.</source>
          <target state="translated">元组的第二个元素是发生异常或调用函数的源文件中的行号（整数&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="bc7d989f87dede2e2ca73a50e9ef9b041bd4465f" translate="yes" xml:space="preserve">
          <source>The second instruction, &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt;, takes component &lt;code&gt;number&lt;/code&gt; in the &lt;code&gt;handle&lt;/code&gt; component of type &lt;code&gt;Action&lt;/code&gt;. If the value is &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt;, the internal value 4711 is to be picked by &lt;code&gt;selected_decode_Action&lt;/code&gt;. In an Erlang terminal it looks as follows:</source>
          <target state="translated">第二条指令 &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt; 在 &lt;code&gt;Action&lt;/code&gt; 类型的 &lt;code&gt;handle&lt;/code&gt; 组件中获取组件 &lt;code&gt;number&lt;/code&gt; 。如果值为 &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt; ，则内部值4711将由 &lt;code&gt;selected_decode_Action&lt;/code&gt; 选择。在Erlang终端中，其外观如下：</target>
        </trans-unit>
        <trans-unit id="09b4b4758afce0f888fa8c4488323d46e48b894d" translate="yes" xml:space="preserve">
          <source>The second is the maximum value since the last call to &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">第二个是自上次调用 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 以来的最大值。</target>
        </trans-unit>
        <trans-unit id="4cb423e42dd15bcd7222df4611672554d769f082" translate="yes" xml:space="preserve">
          <source>The second level is at the MPD entry / exit point, i.e. immediately after the basic message processing (accept_recv_pdu) / immediately before the basic message processing (accept_send_pdu).</source>
          <target state="translated">第二级是在MPD的入口/出口处,即紧接着基本信息处理(accept_recv_pdu)/紧接着基本信息处理(accept_send_pdu)。</target>
        </trans-unit>
        <trans-unit id="774b9d51f0c992a280af87374e7739fea47b5a73" translate="yes" xml:space="preserve">
          <source>The second line also says that this function can be called from outside the module &lt;code&gt;tut&lt;/code&gt;. More about this later. Again, notice the &quot;.&quot; at the end of the line.</source>
          <target state="translated">第二行还说，可以从模块 &lt;code&gt;tut&lt;/code&gt; 外部调用此函数。稍后再详细介绍。再次注意&amp;ldquo;。&amp;rdquo; 在该行的末尾。</target>
        </trans-unit>
        <trans-unit id="ea3a8607657a10cb904d6d19adb9e7a687aaf47e" translate="yes" xml:space="preserve">
          <source>The second line in the example contains an optional directive to the &lt;code&gt;Emacs&lt;/code&gt; editor, which causes it to enter the major mode for editing Erlang source files. If the directive is present, it must be located on the second line.</source>
          <target state="translated">示例中的第二行包含 &lt;code&gt;Emacs&lt;/code&gt; 编辑器的可选指令，这使它进入用于编辑Erlang源文件的主要模式。如果存在该指令，则它必须位于第二行。</target>
        </trans-unit>
        <trans-unit id="e7ea568009a70c36f6990dad1c35ac2c65ca7ebb" translate="yes" xml:space="preserve">
          <source>The second line says that the module &lt;code&gt;tut&lt;/code&gt; contains a function called &lt;code&gt;double&lt;/code&gt;, which takes one argument (&lt;code&gt;X&lt;/code&gt; in our example):</source>
          <target state="translated">第二行说模块 &lt;code&gt;tut&lt;/code&gt; 包含一个名为 &lt;code&gt;double&lt;/code&gt; 的函数，该函数带有一个参数（在我们的示例中为 &lt;code&gt;X&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="1dd56257c238ab45a9b4f237dd6d44c5ddae2994" translate="yes" xml:space="preserve">
          <source>The second occurrence of &lt;code&gt;Age&lt;/code&gt; causes a test for equality between the terms, as &lt;code&gt;Age&lt;/code&gt; is already bound to &lt;code&gt;21&lt;/code&gt;. As &lt;code&gt;Age&lt;/code&gt; is bound to &lt;code&gt;21&lt;/code&gt;, the equality test succeeds and the match continues until the end of the pattern.</source>
          <target state="translated">由于 &lt;code&gt;Age&lt;/code&gt; 已经绑定到 &lt;code&gt;21&lt;/code&gt; ，因此第二次出现 &lt;code&gt;Age&lt;/code&gt; 会测试两个词之间是否相等。当 &lt;code&gt;Age&lt;/code&gt; 绑定到 &lt;code&gt;21&lt;/code&gt; 时，相等性测试成功，并且匹配持续到模式结束。</target>
        </trans-unit>
        <trans-unit id="5ada08cc44dca3d5604a8d151410616b99f7a2c2" translate="yes" xml:space="preserve">
          <source>The second operand pattern, &lt;code&gt;an&lt;/code&gt;, will match if the second operand is either an atom or NIL (the empty list). In case of a match, the &lt;code&gt;is_integer/2&lt;/code&gt; instruction will be replaced with a &lt;code&gt;jump/1&lt;/code&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03310e32ba86e2b90c5b008fd886764d7090dce" translate="yes" xml:space="preserve">
          <source>The second part -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382e51e975a6ee94aa9da00eaf8c1fd3b5f3d623" translate="yes" xml:space="preserve">
          <source>The second part says that the factorial of N is N multiplied by the factorial of N - 1:</source>
          <target state="translated">第二部分说,N的阶乘是N乘以N-1的阶乘。</target>
        </trans-unit>
        <trans-unit id="30c810f9bece7434133db436ed3f6c1cf5d3af46" translate="yes" xml:space="preserve">
          <source>The second sublist contains all elements that are greater than, or equal to, the first element in the list.</source>
          <target state="translated">第二个子列表包含所有大于或等于列表中第一个元素的元素。</target>
        </trans-unit>
        <trans-unit id="627c2faa2a7cc1454aac523f61132caf4581e1f2" translate="yes" xml:space="preserve">
          <source>The second test to run is for system &lt;code&gt;t2&lt;/code&gt;. The included suites are &lt;code&gt;t2B&lt;/code&gt; and &lt;code&gt;t2C&lt;/code&gt;. Test cases &lt;code&gt;test4&lt;/code&gt;, &lt;code&gt;test1&lt;/code&gt;, and &lt;code&gt;test7&lt;/code&gt; in suite &lt;code&gt;t2A&lt;/code&gt; are also included. The test cases are executed in the specified order.</source>
          <target state="translated">要运行的第二项测试是针对系统 &lt;code&gt;t2&lt;/code&gt; 的。包括的套件是 &lt;code&gt;t2B&lt;/code&gt; 和 &lt;code&gt;t2C&lt;/code&gt; 。还包括套件 &lt;code&gt;t2A&lt;/code&gt; 中的测试用例 &lt;code&gt;test4&lt;/code&gt; ， &lt;code&gt;test1&lt;/code&gt; 和 &lt;code&gt;test7&lt;/code&gt; 。测试用例以指定的顺序执行。</target>
        </trans-unit>
        <trans-unit id="55d61df65623e70a8f8d590c69696f032eeda08b" translate="yes" xml:space="preserve">
          <source>The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern:</source>
          <target state="translated">PCRE和Perl在递归处理中的第二个不同之处是对捕获值的处理。在Perl中,当一个子模式被递归调用或作为子模式调用时(见下一节),它无法访问递归之外捕获的任何值。在PCRE中,这些值可以被引用。考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="80e6aee2483553449b41d11b56e552008e4da471" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Definition of Instrumentation Functions&lt;/strong&gt; describes the user defined functions, which the agent calls at different times.</source>
          <target state="translated">&lt;strong&gt;工具功能&lt;/strong&gt;的定义部分介绍了用户定义的功能，代理在不同时间调用这些功能。</target>
        </trans-unit>
        <trans-unit id="44f4ef1de5e2083869238de908c1bcbfdb9de96a" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory (with exception for the ping/pong messages) messages, which Net If must send to the manager server process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273fb73a0df92aec09d70c97847239277a60baf2" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net If must send and be able to receive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8504a92d5b318cac713f3b2e89234cb14dbccfe1" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send and be able to receive.</source>
          <target state="translated">&lt;strong&gt;消息&lt;/strong&gt;部分描述了必填消息，如果必须发送并能够接收，则为Net。</target>
        </trans-unit>
        <trans-unit id="a2e0f488aa581aec3c47fd790570dbca655fc2d9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send to the manager server process.</source>
          <target state="translated">&lt;strong&gt;消息&lt;/strong&gt;部分描述了必填消息，如果必须将其发送到管理器服务器进程，则该消息为Net。</target>
        </trans-unit>
        <trans-unit id="cb5bc25d5302176ca65d13f47ab8764077fb82e9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;When to use a Sub-agent&lt;/strong&gt; describes situations where the mechanism of loading and unloading MIBs is insufficient. In these cases a sub-agent is needed.</source>
          <target state="translated">部分&lt;strong&gt;当使用子代理&lt;/strong&gt;描述的情况下装载和卸载的MIB的机构是不充分的。在这些情况下，需要一个子代理。</target>
        </trans-unit>
        <trans-unit id="e27ee525c2d7a1c95013bf055cd814b7495974ff" translate="yes" xml:space="preserve">
          <source>The section is a step-by-step explanation of the &lt;code&gt;uds_dist&lt;/code&gt; example application (in the Kernel application &lt;code&gt;examples&lt;/code&gt; directory). The &lt;code&gt;uds_dist&lt;/code&gt; application implements distribution over Unix domain sockets and is written for the Sun Solaris 2 operating environment. The mechanisms are however general and apply to any operating system Erlang runs on. The reason the C code is not made portable, is simply readability.</source>
          <target state="translated">本节是 &lt;code&gt;uds_dist&lt;/code&gt; 示例应用程序的逐步说明（在Kernel application &lt;code&gt;examples&lt;/code&gt; 目录中）。该 &lt;code&gt;uds_dist&lt;/code&gt; 在Unix域套接字的应用程序实现分发，它是太阳的Solaris 2操作环境编写。但是，这些机制是通用的，适用于运行Erlang的任何操作系统。C代码不具有可移植性的原因仅仅是可读性。</target>
        </trans-unit>
        <trans-unit id="10205e6d7e5decf9f073a8f33e8e352f8ecad2b8" translate="yes" xml:space="preserve">
          <source>The sections about release structure and release handling have been moved to section &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">有关发行结构和发行处理的部分已移至 &lt;code&gt;OTP Design Principles&lt;/code&gt; &lt;strong&gt;系统文档&lt;/strong&gt;&amp;rdquo;中的&amp;ldquo; OTP设计原则&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4e2ce648e32ac1ae793549c46cd55a4f21a2abef" translate="yes" xml:space="preserve">
          <source>The security level depends on the parameters provided to the TLS connection setup. Erlang node cookies are however always used, as they can be used to differentiate between two different Erlang networks.</source>
          <target state="translated">安全级别取决于提供给TLS连接设置的参数。然而,Erlang节点cookie总是被使用,因为它们可以用来区分两个不同的Erlang网络。</target>
        </trans-unit>
        <trans-unit id="d750bfe1fcfccb12069aea37fb0d25d1db1f996c" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes &lt;code&gt;open&lt;/code&gt; to implicitly postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d926590307164245688269e8d14c40ab7bc091d" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes implicitly &lt;code&gt;open&lt;/code&gt; to postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="translated">在这种情况下，选择性接收会导致隐式 &lt;code&gt;open&lt;/code&gt; 以将任何事件推迟到 &lt;code&gt;locked&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="5fd2a7b375c615e788c6695ee553f4da41abbaa4" translate="yes" xml:space="preserve">
          <source>The semantics is that a trace message is sent when a call traced function returns, that is, when a chain of tail recursive calls ends. Only one trace message is sent per chain of tail recursive calls, so the properties of tail recursiveness for function calls are kept while tracing with this flag. Using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; trace together makes it possible to know exactly in which function a process executes at any time.</source>
          <target state="translated">语义是当跟踪调用的函数返回时（即尾尾递归调用链结束时）发送跟踪消息。每条尾部递归调用链仅发送一条跟踪消息，因此在使用此标志进行跟踪时，将保留函数调用的尾部递归属性。一起使用 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;return_to&lt;/code&gt; 跟踪，可以随时准确地知道进程在哪个函数中执行。</target>
        </trans-unit>
        <trans-unit id="4de46ccd64eaf7c6a99ec541d1cbcc55c06b408c" translate="yes" xml:space="preserve">
          <source>The semantics of the protocol has jointly been defined by two standardization bodies:</source>
          <target state="translated">该协议的语义由两个标准化机构共同定义。</target>
        </trans-unit>
        <trans-unit id="1ff24da2ee4416d81d99c41d0ad247bd1489bb83" translate="yes" xml:space="preserve">
          <source>The semantics of them and their exact signatures are explained below.</source>
          <target state="translated">下面解释它们的语义及其确切的签名。</target>
        </trans-unit>
        <trans-unit id="b1fa04e102f76c0ed958b51776ec1323ba2b420c" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; in the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在记录中获取 &lt;code&gt;LockKind&lt;/code&gt; 类型的锁。当前，支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dec37a1381140705a37e8b22974825983130016" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在整个表或单个记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁定类型 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="544565c18f11c3bd2d1b3b57f9c37bb23e28513e" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or on a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在整个表或单个记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁定类型 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ac9b81a840d90d3353dd0dc88e91326c5df9221" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="398f5d70441c50ce9d5e9fd6b232c3ecc7fd8dc0" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. Currently, the lock types &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁类型 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb63a329083b4ebe624da3e57823d281920ca895" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. The lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d20c7795cec81709642f2df218bc112e235d99" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a read lock on the entire table.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取整个表的读锁。</target>
        </trans-unit>
        <trans-unit id="06b7f2394cceb9a5d1549e5bd69d686fb86fba7d" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires locks, otherwise it ignores the request.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取锁，否则将忽略请求。</target>
        </trans-unit>
        <trans-unit id="c555e927f36b7c980e9c0d2dd029f5af17719b16" translate="yes" xml:space="preserve">
          <source>The send handle is provided by the preferred transport module, e.g. megaco_tcp, megaco_udp. Read the documentation about each transport module about the details.</source>
          <target state="translated">发送句柄是由首选的传输模块提供的,例如 megaco_tcp,megaco_udp。请阅读每个传输模块的文档了解详情。</target>
        </trans-unit>
        <trans-unit id="8783fac7786ee217686c1dc22e76c11e2bd7dd7d" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes no use of this info, so the only use for it in such a configuration (when using the built in net-if) would be tracing.</source>
          <target state="translated">send选项 &lt;code&gt;extra&lt;/code&gt; 指定传递给net-if进程的不透明数据结构。此应用程序中包含的net-if进程不使用此信息，因此在这种配置中（当使用内置的net-if时）唯一可用于跟踪。</target>
        </trans-unit>
        <trans-unit id="461af368454e12216cec44ca03086a38551ee6d2" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes, with one exception, no use of this info, so the only use for it in such a option (when using the built in net-if) would be tracing. The one usage exception is: &lt;strong&gt;Any&lt;/strong&gt; tuple with &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; as its first element is reserved for internal use.</source>
          <target state="translated">send选项 &lt;code&gt;extra&lt;/code&gt; 指定传递给net-if进程的不透明数据结构。除了一个例外，此应用程序中包含的net-if进程不使用此信息，因此（在使用内置net-if时）在此选项中唯一可使用的将是跟踪。一个使用例外是：&lt;strong&gt;任何&lt;/strong&gt;以 &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; 作为第一个元素的元组保留供内部使用。</target>
        </trans-unit>
        <trans-unit id="f927792dbf5cf189b45274ee4c9fa05e9b3d6c92" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the management targets. The &lt;code&gt;receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">发送选项 &lt;code&gt;receiver&lt;/code&gt; 指定应将有关Inform-Requests传递的信息发送到何处。代理发送Inform-Requests并等待来自管理目标的确认。该 &lt;code&gt;receiver&lt;/code&gt; 可以有三个值：</target>
        </trans-unit>
        <trans-unit id="b674ec7cb2a069afaa45f294232597630bb8d191" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;timeout&lt;/code&gt; specifies for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">发送选项 &lt;code&gt;timeout&lt;/code&gt; 指定请求有效的时间（此后管理员可以自由删除请求）。</target>
        </trans-unit>
        <trans-unit id="a653cc1f1926ea809d716348869498af401847a8" translate="yes" xml:space="preserve">
          <source>The sender can receive this event if a send operation fails.</source>
          <target state="translated">如果发送操作失败,发送方可以收到这个事件。</target>
        </trans-unit>
        <trans-unit id="8ab6737312426170b7d594e871570564adefdefd" translate="yes" xml:space="preserve">
          <source>The sender of a transaction request has the option of deciding, whether the originating Erlang process should synchronously wait (&lt;code&gt;megaco:call/3&lt;/code&gt;) for a reply or if the message should be sent asynchronously (&lt;code&gt;megaco:cast/3&lt;/code&gt;) and the processing of the reply should be delegated this callback function.</source>
          <target state="translated">事务请求的发送者可以选择确定发起的Erlang进程是否应同步等待（ &lt;code&gt;megaco:call/3&lt;/code&gt; ）答复或是否应异步发送消息（ &lt;code&gt;megaco:cast/3&lt;/code&gt; ）以及处理应将委托委托给此回调函数。</target>
        </trans-unit>
        <trans-unit id="b4cb9ec2065f8938c37ab4fe9dffa3ac54b3a9dd" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file &quot;as is&quot; without any formatting. A link to the file is added to the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF数据被记录到一个单独的文本文件中,没有任何格式化。该文件的链接被添加到测试案例的HTML日志中。</target>
        </trans-unit>
        <trans-unit id="4c9c5717f02ffea08eb9b9a69a645cb0063d78fe" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF数据被记录在一个单独的文本文件中,XML数据被很好地缩进。该文件的链接被添加到测试案例的HTML日志中。</target>
        </trans-unit>
        <trans-unit id="97f2e4431b5646badaae5263442c80d42e8a09b1" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF traffic is pretty printed directly in the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF流量很直接地打印在测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="9b2a69f81d7c9bd014b0daeb2b91d49e6f9bb88b" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt; Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526a6b0c86f2a163790ccae9cdeca981359b2f9f" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">序列（？＃表示注释的开始，一直延续到下一个右括号。不允许使用嵌套的括号。如果设置了选项PCRE_EXTENDED，则未转义的＃字符也会引入注释，在这种情况下，注释将继续到注释之后。模式中的下一个换行符或字符序列哪些字符被解释为换行符，是由传递给编译函数的选项控制的，或由模式开头的特殊序列控制的，如前面&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; 一节中所述。</target>
        </trans-unit>
        <trans-unit id="17d5ba7a2bea4311848902de65874e5e13256c29" translate="yes" xml:space="preserve">
          <source>The sequence \g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">序列\g后面跟着一个无符号或负数,可选择用括号括起来,是一个绝对或相对的后参照。命名的后引用可以编码为 \g{name}。后引用将在后面的括号子模式讨论中讨论。</target>
        </trans-unit>
        <trans-unit id="cf397042cff1c5cb3ebfe293ff40d06f71fdc8c2" translate="yes" xml:space="preserve">
          <source>The sequence \g{-1} is a reference to the most recently started capturing subpattern before \g, that is, it is equivalent to \2 in this example. Similarly, \g{-2} would be equivalent to \1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves.</source>
          <target state="translated">序列\g{-1}是指在\g之前最近开始捕获的子模式,也就是说,它相当于本例中的\2。同样,\g{-2}也等同于\1。相对引用的使用在长模式中是很有帮助的,在通过连接包含引用的片段而创建的模式中也是如此。</target>
        </trans-unit>
        <trans-unit id="9aa5123f81409d6732a8773b396806a7d7a6c8b1" translate="yes" xml:space="preserve">
          <source>The sequence id is used to uniquely identify a fragmented message sent from one process to another on the same distributed connection. This is used to identify which sequence a fragment is a part of as the same process can be in the process of receiving multiple sequences at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78acc7e07953d38a1ab22f1d92af436b05725d02" translate="yes" xml:space="preserve">
          <source>The sequence number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="a730581ed9394e9f512b17bf00122fa40d5d6a8c" translate="yes" xml:space="preserve">
          <source>The sequence number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">端口 &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="d9835c9de2ba951e30c90819750512630463b537" translate="yes" xml:space="preserve">
          <source>The sequence of steps shown is probably more complex than normal, but it illustrates the amount of functionality which is available. The following points should be noted:</source>
          <target state="translated">所示的一系列步骤可能比正常情况下更复杂,但它说明了可用的功能数量。应注意以下几点:</target>
        </trans-unit>
        <trans-unit id="8ad58d75452c7e291a38fc9baa9ff4ed0360940a" translate="yes" xml:space="preserve">
          <source>The sequences \h, \H, \v, and \V are features that were added to Perl in release 5.10. In contrast to the other sequences, which match only ASCII characters by default, these always match certain high-valued code points, regardless if &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">序列\ h，\ H，\ v和\ V是在5.10版中添加到Perl的功能。与默认情况下仅匹配ASCII字符的其他序列相反，这些序列始终匹配某些高价值代码点，无论是否设置了 &lt;code&gt;ucp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc5373a2646de360aa46ef11847fc92698bb563" translate="yes" xml:space="preserve">
          <source>The serial number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="8111e7055dd7801086cd5e9dd759c58638f73514" translate="yes" xml:space="preserve">
          <source>The server always sends a certificate chain as part of the TLS handshake, but the client only sends one if requested by the server. If the client does not have an appropriate certificate, it can send an &quot;empty&quot; certificate to the server.</source>
          <target state="translated">服务器总是发送一个证书链作为TLS握手的一部分,但客户端只有在服务器要求时才会发送一个证书链。如果客户端没有合适的证书,它可以向服务器发送一个 &quot;空 &quot;证书。</target>
        </trans-unit>
        <trans-unit id="229d25bbfa88632fdde58ad8585ae739c0a0640c" translate="yes" xml:space="preserve">
          <source>The server can also take the options &lt;code&gt;dhfile&lt;/code&gt; and &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (also prefixed).</source>
          <target state="translated">服务器还可以采用选项 &lt;code&gt;dhfile&lt;/code&gt; 和 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; （也带有前缀）。</target>
        </trans-unit>
        <trans-unit id="1700b3d48eb2b123d28d0da14b6deae45c75c3b4" translate="yes" xml:space="preserve">
          <source>The server implements numerous features, such as:</source>
          <target state="translated">服务器实现了许多功能,如:。</target>
        </trans-unit>
        <trans-unit id="a419e1724123900e8550b29498eed9bbee902340" translate="yes" xml:space="preserve">
          <source>The server interprets the message headers and most of them are transformed into HTTP headers and sent back to the client together with the message-body.</source>
          <target state="translated">服务器对消息头进行解释,大部分消息头被转化为HTTP头,和消息体一起发回给客户端。</target>
        </trans-unit>
        <trans-unit id="0d98b27dc370a8e06dd56d795ca4cf5591347585" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e7a7b10ff76bf44d32ec3e60b336ed7bd9d091" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;. For backwards compatibility, apache-like configuration files are also supported.</source>
          <target state="translated">使用Erlang属性列表配置服务器。有关可用属性，请参见 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 。为了向后兼容，还支持类似apache的配置文件。</target>
        </trans-unit>
        <trans-unit id="5e64a9d0d0fd7079393371b1454efd0dd5fbdc81" translate="yes" xml:space="preserve">
          <source>The server name, in this example the atom &lt;code&gt;ch2&lt;/code&gt;, is hidden from the users of the client functions. This means that the name can be changed without affecting them.</source>
          <target state="translated">服务器名称（在此示例中为原子 &lt;code&gt;ch2&lt;/code&gt; )对客户端功能的用户隐藏。这意味着可以更改名称而不会影响它们。</target>
        </trans-unit>
        <trans-unit id="281168d64e74220aa9892e9cc7f847641edee61a" translate="yes" xml:space="preserve">
          <source>The server receives this message and calls:</source>
          <target state="translated">服务器收到此消息后,调用。</target>
        </trans-unit>
        <trans-unit id="e465284becdbbb53a7c1b2b2feedaf65818bc0a6" translate="yes" xml:space="preserve">
          <source>The server side must abort any ongoing operations, release any locks and resources associated with the session, and close any associated connections.</source>
          <target state="translated">服务器端必须中止任何正在进行的操作,释放任何与会话相关的锁和资源,并关闭任何相关的连接。</target>
        </trans-unit>
        <trans-unit id="1b73ca513a3d162c53b9d0f45d3fae15b51ac27d" translate="yes" xml:space="preserve">
          <source>The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's &quot;signature_algorithms&quot; extension (currently RSA, ECDSA, or EdDSA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eada9e87d673d14717c1c6d8d19ed52103f05b62" translate="yes" xml:space="preserve">
          <source>The service is being started or stopped. No event precedes a &lt;code&gt;start&lt;/code&gt; event. No event follows a &lt;code&gt;stop&lt;/code&gt; event, and this event implies the termination of all transport processes.</source>
          <target state="translated">服务正在启动或停止。 &lt;code&gt;start&lt;/code&gt; 事件之前没有事件。 &lt;code&gt;stop&lt;/code&gt; 事件之后没有事件，并且此事件表示所有传输过程的终止。</target>
        </trans-unit>
        <trans-unit id="0bb9705bf71fb4b8fce2bf74aeec82fd5334268d" translate="yes" xml:space="preserve">
          <source>The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer (&lt;code&gt;connect&lt;/code&gt;) or by accepting incoming connection requests (&lt;code&gt;listen&lt;/code&gt;). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many.</source>
          <target state="translated">该服务将根据需要启动传输过程，以通过与对等方建立连接（ &lt;code&gt;connect&lt;/code&gt; ）或接受传入的连接请求（ &lt;code&gt;listen&lt;/code&gt; ）来建立与对等方的连接。连接传输最多与一个对等点建立传输连接，侦听传输可能与许多对等点建立传输连接。</target>
        </trans-unit>
        <trans-unit id="2d32daf4aa858543bff36659b918ab0126a6b271" translate="yes" xml:space="preserve">
          <source>The session data that is stored for each session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cadccf6e95d9c9b64838c77b38958e4188f878" translate="yes" xml:space="preserve">
          <source>The session is closed.</source>
          <target state="translated">本届会议闭幕。</target>
        </trans-unit>
        <trans-unit id="7cd1dac17852f58fd5b35cb68eccba90aabb1d2d" translate="yes" xml:space="preserve">
          <source>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP, and generic &lt;code&gt;inet&lt;/code&gt; options. Only options listed here are allowed for SCTP sockets. Options can be set on the socket using &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, retrieved using &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt;. Options can be changed when calling &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">允许的SCTP套接字选项集在构造上与TCP，UDP和通用 &lt;code&gt;inet&lt;/code&gt; 选项集正交。SCTP套接字仅允许使用此处列出的选项。可以使用 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 在套接字上设置选项，并使用 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; 进行检索。调用 &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt; 时可以更改选项。</target>
        </trans-unit>
        <trans-unit id="ab0f75a569127c073d8755a64ed39c5868d2acc4" translate="yes" xml:space="preserve">
          <source>The set of algorithms that the SSH app uses by default depends on the algoritms supported by the:</source>
          <target state="translated">SSH应用程序默认使用的算法集取决于所支持的算法。</target>
        </trans-unit>
        <trans-unit id="735c513e608e0b547b56dcea8d9766ffad148df8" translate="yes" xml:space="preserve">
          <source>The set of integers returned by &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; using different sets of &lt;code&gt;Modifier&lt;/code&gt;s &lt;strong&gt;will overlap&lt;/strong&gt;. For example, by calling &lt;code&gt;unique_integer([monotonic])&lt;/code&gt;, and &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; repeatedly, you will eventually see some integers that are returned by both calls.</source>
          <target state="translated">该组由返回整数 &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; 使用不同组的 &lt;code&gt;Modifier&lt;/code&gt; 小号&lt;strong&gt;就会重叠&lt;/strong&gt;。例如，通过 &lt;code&gt;unique_integer([monotonic])&lt;/code&gt; 调用unique_integer（[monotonic]）和 &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; ，您最终将看到两个调用都返回一些整数。</target>
        </trans-unit>
        <trans-unit id="192a51abc57907a3173222d0f7d8aab02a2d5adc" translate="yes" xml:space="preserve">
          <source>The set of nodes that makes up a Mnesia system is kept in a schema. Mnesia nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function &lt;code&gt;mnesia:create_schema/1&lt;/code&gt;. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the startup procedure, Mnesia exchanges schema information between the nodes to verify that the table definitions are compatible.</source>
          <target state="translated">组成Mnesia系统的节点集保留在架构中。 Mnesia节点可以添加到架构中，也可以从架构中删除。通常使用功能 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 在磁盘上创建初始模式。在无盘节点上，每次启动Mnesia时都会生成一个很小的默认架构。在启动过程中，Mnesia在节点之间交换架构信息，以验证表定义是否兼容。</target>
        </trans-unit>
        <trans-unit id="e6b6ca74b9f0531554c93c10cb1c7070b93217b8" translate="yes" xml:space="preserve">
          <source>The set of predefined types and the syntax for types follows:</source>
          <target state="translated">预定义类型集和类型的语法如下。</target>
        </trans-unit>
        <trans-unit id="d7ecd892863675025b2a96aabc9a9af6b17ad9d4" translate="yes" xml:space="preserve">
          <source>The set of threads that we are interested in we call managed threads. The managed threads are the only threads that we get any information about. These threads &lt;strong&gt;have&lt;/strong&gt; to frequently report progress. Not all threads in the system are able to frequently report progress. Such threads cannot be allowed in the set of managed threads and are called unmanaged threads. An example of unmanaged threads are threads in the async thread pool. Async threads can be blocked for very long times and by this be prevented from frequently reporting progress. Currently only scheduler threads and a couple of other threads are managed threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57bb3e21d7efc4c4d6d866577c535b86827e6e3" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; (sometimes called guard tests) is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="translated">有效的&lt;strong&gt;保护表达式集&lt;/strong&gt;（有时称为保护测试）是有效的Erlang表达式集的子集。限制有效表达式集的原因是，必须确保对保护表达式的评估没有副作用。有效的保护表达式如下：</target>
        </trans-unit>
        <trans-unit id="38618d07bcc4ec9219110c6bac629d8ba5add3b8" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4e6c237902f03c9d37f0c7a6d60075f64b2cbe" translate="yes" xml:space="preserve">
          <source>The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that:</source>
          <target state="translated">本模块所识别的集合由关系Sets的元素表示,关系Sets被定义为最小的集合,即:</target>
        </trans-unit>
        <trans-unit id="2cd8e823885a626feb78a98cd7d6126c5141df4e" translate="yes" xml:space="preserve">
          <source>The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms:</source>
          <target state="translated">由Sets代表的集合是由Sets到Erlang项和Erlang项集合的函数Set范围的元素。</target>
        </trans-unit>
        <trans-unit id="1e6bfb67315ff8c660eaf25c1733e37c10bf2a84" translate="yes" xml:space="preserve">
          <source>The setting has no effect on a halt log.</source>
          <target state="translated">该设置对停止日志没有影响。</target>
        </trans-unit>
        <trans-unit id="708e1c55726f99e92712010fcf842caa93f6beee" translate="yes" xml:space="preserve">
          <source>The settings of the Perl-compatible options &lt;code&gt;caseless&lt;/code&gt;, &lt;code&gt;multiline&lt;/code&gt;, &lt;code&gt;dotall&lt;/code&gt;, and &lt;code&gt;extended&lt;/code&gt; can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows:</source>
          <target state="translated">Perl兼容选项 &lt;code&gt;caseless&lt;/code&gt; ， &lt;code&gt;multiline&lt;/code&gt; ， &lt;code&gt;dotall&lt;/code&gt; 和 &lt;code&gt;extended&lt;/code&gt; 可以在模式中通过用&amp;ldquo;（？&amp;rdquo;和&amp;ldquo;）&amp;rdquo;之间的一系列Perl选项字母进行更改。选项字母如下：</target>
        </trans-unit>
        <trans-unit id="20fbd9576783a14ac9df5dccf183005898be344d" translate="yes" xml:space="preserve">
          <source>The severity level for the message to be logged.</source>
          <target state="translated">要记录的消息的严重程度。</target>
        </trans-unit>
        <trans-unit id="906ae5d296f5eecb26331f0380669f16fbcadddb" translate="yes" xml:space="preserve">
          <source>The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.</source>
          <target state="translated">shell还允许用户启动多个并发作业。一个作业可以看作是一组可以与shell通信的进程。</target>
        </trans-unit>
        <trans-unit id="3c5f2ea6c7e1929748b9a3f26e85b7652daf0ffd" translate="yes" xml:space="preserve">
          <source>The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag &lt;code&gt;+Bi&lt;/code&gt;).</source>
          <target state="translated">外壳程序可以以受限模式启动。在这种模式下，shell仅在允许的情况下评估函数调用。例如，使用此功能可以防止用户从提示中意外调用可能损害正在运行的系统的功能（与系统标志 &lt;code&gt;+Bi&lt;/code&gt; 结合使用）。</target>
        </trans-unit>
        <trans-unit id="6b1db3783eaf47b941529ec43e9feba2a87d50ce" translate="yes" xml:space="preserve">
          <source>The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules &lt;code&gt;shell_default&lt;/code&gt; and &lt;code&gt;user_default&lt;/code&gt; (if loaded) are read each time a new job is started. For example, adding the following line to &lt;code&gt;user_default&lt;/code&gt; makes the definition of &lt;code&gt;file_info&lt;/code&gt; readily available in the shell:</source>
          <target state="translated">下面介绍了用于读取，定义，忘记，列出和打印记录的shell命令。请注意，每个作业都有其自己的记录定义集。为方便 &lt;code&gt;shell_default&lt;/code&gt; ，每次启动新作业时都会读取shell_default和 &lt;code&gt;user_default&lt;/code&gt; 模块（如果已加载）中的记录定义。例如，添加下列行来 &lt;code&gt;user_default&lt;/code&gt; 使得定义 &lt;code&gt;file_info&lt;/code&gt; 在壳容易获得的：</target>
        </trans-unit>
        <trans-unit id="0dffc89af87f5c93512d139994f93842341103ef" translate="yes" xml:space="preserve">
          <source>The shell escape key &lt;code&gt;^G&lt;/code&gt; (Control G) detaches the current job and activates &lt;code&gt;JCL&lt;/code&gt; mode. The &lt;code&gt;JCL&lt;/code&gt; mode prompt is &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt;. If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is entered at the prompt, the following help message is displayed:</source>
          <target state="translated">Shell退出键 &lt;code&gt;^G&lt;/code&gt; （控制G）将分离当前作业并激活 &lt;code&gt;JCL&lt;/code&gt; 模式。的 &lt;code&gt;JCL&lt;/code&gt; 模式提示是 &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; 。如果是 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 在提示符下输入时，将显示以下帮助消息：</target>
        </trans-unit>
        <trans-unit id="f22132507cc2cbecae41be645fa330c7e74cc00c" translate="yes" xml:space="preserve">
          <source>The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt;, or by setting the application configuration parameters &lt;code&gt;shell_history_length&lt;/code&gt; and &lt;code&gt;shell_saved_results&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">该外壳是用于输入表达序列的用户界面程序。计算表达式并返回一个值。历史记录机制保存以前的命令及其值，然后可以将其合并到以后的命令中。用户可以交互方式，通过调用 &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt; 或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_history_length&lt;/code&gt; 和 &lt;code&gt;shell_saved_results&lt;/code&gt; 来确定要保存多少命令和结果。</target>
        </trans-unit>
        <trans-unit id="0c05236717660c4e284c99dfbeb455aafa6a7135" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt; os:find_executable/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3c2d38847db4b9d384443450a1704fbe5a9310" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt;os:find_executable/1&lt;/code&gt;.</source>
          <target state="translated">通常不调用Shell来启动程序，而是直接执行。不搜索 &lt;code&gt;PATH&lt;/code&gt; （或等效路径）。要在 &lt;code&gt;PATH&lt;/code&gt; 中找到要执行的程序，请使用 &lt;code&gt;os:find_executable/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ba8c777e2892e18ef92162fb3ae948b677e7e96" translate="yes" xml:space="preserve">
          <source>The shell mode is useful, for example, for debugging test suites, analyzing and debugging the SUT during &quot;simulated&quot; test case execution, and trying out various operations during test suite development.</source>
          <target state="translated">例如,shell模式对于调试测试套件、在 &quot;模拟 &quot;测试用例执行过程中分析和调试SUT,以及在测试套件开发过程中尝试各种操作都很有用。</target>
        </trans-unit>
        <trans-unit id="dccc3d081d31c25afe702e15e4a49fe7f5d58e4e" translate="yes" xml:space="preserve">
          <source>The shell runs in two modes:</source>
          <target state="translated">shell以两种模式运行。</target>
        </trans-unit>
        <trans-unit id="547a340a87f4e04c610a24150bcba68bc72ae2d3" translate="yes" xml:space="preserve">
          <source>The shell script &lt;code&gt;start&lt;/code&gt;, which is generated from erts-5.10.4/bin/start.src during installation, is only an example. Edit it to suite your needs. Typically it is executed when the UNIX system boots.</source>
          <target state="translated">仅在安装过程中从erts-5.10.4 / bin / start.src生成的shell脚本 &lt;code&gt;start&lt;/code&gt; 。编辑它以满足您的需求。通常，它在UNIX系统引导时执行。</target>
        </trans-unit>
        <trans-unit id="42c1630d7f9ecc92a9f90f0627702733fa769c29" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt; catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dd983c72c713d084adde4deb3fce82550d00d2" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="translated">Shell使用帮助程序进程来评估命令，以保护历史记录机制免受异常影响。默认情况下，发生异常时，评估程序将被 &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; ，但是可以通过调用catch_exception / 1或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_catch_exception&lt;/code&gt; 来更改此行为。另请参见下面的示例。</target>
        </trans-unit>
        <trans-unit id="882fde077f4ebdd694d577f064d7d175010b3652" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one &lt;strong&gt;state callback&lt;/strong&gt; function per state; please read on...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42edd7ea14c7efba24c3aff26f9dcace9d4328" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one event handler function per state; please read on...</source>
          <target state="translated">简短的版本：选择 &lt;code&gt;state_functions&lt;/code&gt; -最类似于 &lt;code&gt;gen_fsm&lt;/code&gt; 。但是，如果您不希望状态必须是一个原子的限制，或者不想为每个状态编写一个事件处理程序函数，则可以；请继续阅读...</target>
        </trans-unit>
        <trans-unit id="8fc2135229ea382a9e721c2e40582626084b92c6" translate="yes" xml:space="preserve">
          <source>The shortcuts are as follows:</source>
          <target state="translated">捷径如下:</target>
        </trans-unit>
        <trans-unit id="ecbf2eb1175e2e5b06e38c7c0a22fd7f8f8611cd" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished repeatedly and reliably when reading time values. Precision is limited by the &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt;, but resolution and precision can differ significantly.</source>
          <target state="translated">读取时间值时可以重复可靠地区分的最短时间间隔。精度受 &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 限制，但分辨率和精度可能会有很大差异。</target>
        </trans-unit>
        <trans-unit id="f84d7886a0f9257a8fa3cb849cd4e77cfe8aa126" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished when reading time values.</source>
          <target state="translated">读取时间值时,可以区分的最短时间间隔。</target>
        </trans-unit>
        <trans-unit id="d2bb1e51130dab7f5283d9470e62aab2d5f6ca06" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">主管的子级规范中定义的关闭策略是整数超时值，而不是 &lt;code&gt;brutal_kill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c80708d1012fab3c8f472912a306a1e18b063172" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">主管的子级规范中定义的关闭策略是整数超时值，而不是 &lt;code&gt;brutal_kill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9028aec69bf73d6c7de5318e8338d0a2f1c2357" translate="yes" xml:space="preserve">
          <source>The signal &lt;code&gt;SIGUSR2&lt;/code&gt; is reserved for internal usage. No other signals are handled.</source>
          <target state="translated">信号 &lt;code&gt;SIGUSR2&lt;/code&gt; 保留供内部使用。没有其他信号被处理。</target>
        </trans-unit>
        <trans-unit id="d074b9e825fff0fd1ebfc3258cb4dafc95050e70" translate="yes" xml:space="preserve">
          <source>The signal carries information about the pid it was sent from and the exit reason.</source>
          <target state="translated">该信号携带着从哪里发出的pid和退出原因的信息。</target>
        </trans-unit>
        <trans-unit id="56c2445b0db46d08f19738e31ee8dee208c885fe" translate="yes" xml:space="preserve">
          <source>The signature schemes shall be ordered according to the client's preference (favorite choice first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186b6e9957386fe2a5f08032e0ba5ef2925f605f" translate="yes" xml:space="preserve">
          <source>The signedness specification can be either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. Notice that signedness only matters for matching.</source>
          <target state="translated">签名规范可以是已 &lt;code&gt;signed&lt;/code&gt; 或未 &lt;code&gt;unsigned&lt;/code&gt; 。请注意，签名仅对匹配很重要。</target>
        </trans-unit>
        <trans-unit id="0a422acc04b6a76708f58fc88d786a11c4476b80" translate="yes" xml:space="preserve">
          <source>The simple event handler sends all alarms as info reports to the error logger, and saves all in a list. This list can be passed to a user-defined event handler, which can be installed later. The list can grow large if many alarms are generated. This is a good reason to install a better user-defined handler.</source>
          <target state="translated">简单的事件处理程序将所有的报警以信息报告的形式发送到错误记录器,并将所有的报警保存在一个列表中。这个列表可以传递给用户定义的事件处理程序,可以在以后安装。如果产生了很多报警,这个列表可能会变得很大。这是个很好的理由,可以安装一个更好的用户自定义处理程序。</target>
        </trans-unit>
        <trans-unit id="863023573a43dd8e0ae2605daf1e7cad870d2b5e" translate="yes" xml:space="preserve">
          <source>The simple server from &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;, implemented using &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; so it fits into a supervision tree:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; 的简单服务器，使用 &lt;code&gt;sys&lt;/code&gt; 和 &lt;code&gt;proc_lib&lt;/code&gt; 实现，因此适合于监视树：</target>
        </trans-unit>
        <trans-unit id="2b9f3602307725a54911301be89734f09963d9b4" translate="yes" xml:space="preserve">
          <source>The simple-form structure is any of &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt;, &lt;code&gt;{Tag, Content}&lt;/code&gt; or &lt;code&gt;Tag&lt;/code&gt; where:</source>
          <target state="translated">简单形式的结构是 &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt; ， &lt;code&gt;{Tag, Content}&lt;/code&gt; 或 &lt;code&gt;Tag&lt;/code&gt; 中的任何一个，其中：</target>
        </trans-unit>
        <trans-unit id="020fdda90aa20fcb7b4204c69ad0944a63e101ce" translate="yes" xml:space="preserve">
          <source>The simplest SSL/TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="translated">可以通过在选项名称中添加前缀 &lt;code&gt;server_&lt;/code&gt; 或 &lt;code&gt;client_&lt;/code&gt; 来指定以下列表中最简单的SSL / TLS选项：</target>
        </trans-unit>
        <trans-unit id="37c028006985a9e5f47283f55be8c5af30259739" translate="yes" xml:space="preserve">
          <source>The simplest TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ab52b7039e217a939df83566a221e65ed54107" translate="yes" xml:space="preserve">
          <source>The simplest applications do not have any processes, but consist of a collection of functional modules. Such an application is called a &lt;strong&gt;library application&lt;/strong&gt;. An example of a library application is STDLIB.</source>
          <target state="translated">最简单的应用程序没有任何过程，但是由功能模块的集合组成。这样的应用程序称为&lt;strong&gt;库应用程序&lt;/strong&gt;。库应用程序的一个示例是STDLIB。</target>
        </trans-unit>
        <trans-unit id="9d81d04034c8d22db20deb185b1f215da194b3b1" translate="yes" xml:space="preserve">
          <source>The simplest boot script possible includes only the Kernel and STDLIB applications. Such a script is located in the &lt;code&gt;bin&lt;/code&gt; directory of the Erlang distribution. The source for the script is found under the Erlang installation top directory under &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt;.</source>
          <target state="translated">最简单的启动脚本可能仅包括内核和STDLIB应用程序。这样的脚本位于Erlang发行版的 &lt;code&gt;bin&lt;/code&gt; 目录中。该脚本的源代码位于 &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt; 下的Erlang安装目录下。</target>
        </trans-unit>
        <trans-unit id="d6fd995f7841419eb481c6384fc5f636193cf5af" translate="yes" xml:space="preserve">
          <source>The simplest case is to segment the input string into a list of identifiers (atoms) and use those atoms both as categories and values of the tokens. For example, the input string &lt;code&gt;aaa bbb 777, X&lt;/code&gt; may be scanned (tokenized) as:</source>
          <target state="translated">最简单的情况是将输入字符串分成标识符（原子）列表，并将这些原子用作标记的类别和值。例如，输入字符串 &lt;code&gt;aaa bbb 777, X&lt;/code&gt; 可能被扫描（标记为）：</target>
        </trans-unit>
        <trans-unit id="010ac940341106a56ccca622ae5fd2705ac4ec5a" translate="yes" xml:space="preserve">
          <source>The simplest form of expression is a term, that is an integer, float, atom, string, list, map, or tuple. The return value is the term itself.</source>
          <target state="translated">最简单的表达式是一个术语,即整数、浮点数、原子、字符串、列表、映射或元组。返回值是术语本身。</target>
        </trans-unit>
        <trans-unit id="544f8ad7975052237a1febdf86a30ee264923c26" translate="yes" xml:space="preserve">
          <source>The simplest possible pattern is a variable. Just like in Erlang, a variable must begin with an uppercase letter. If the same variable is used in multiple operands, the pattern will only match if the operands are equal. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0274c28625e90c70fedc79d4e866a2b95142496c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt; scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4929ec0fe8e8e239995092f36e1eed41d6db7c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最简单的用法是调用 &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc802fe07c47aed57126bce485b313dc00cf24cf" translate="yes" xml:space="preserve">
          <source>The simplest way of tracing from the Erlang shell is to use &lt;code&gt;dbg:c/3&lt;/code&gt; or &lt;code&gt;dbg:c/4&lt;/code&gt;, e.g. tracing the function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt;:</source>
          <target state="translated">从Erlang shell进行跟踪的最简单方法是使用 &lt;code&gt;dbg:c/3&lt;/code&gt; 或 &lt;code&gt;dbg:c/4&lt;/code&gt; ，例如，跟踪函数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a55bc0caa59f610838e98d74961ed6dd639de567" translate="yes" xml:space="preserve">
          <source>The simplest way to log something is by using the Logger macros and give a report to the macro. For example if you want to log an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd591e91084c3f463556c98ff8fcc73c0b642942" translate="yes" xml:space="preserve">
          <source>The simplest way to send a notification is to call the function &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt;. In this case, the agent performs a get-operation to retrieve the object values that are defined in the notification specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros). The notification is sent to all managers defined in the target and notify tables, either unacknowledged as traps, or acknowledged as inform requests.</source>
          <target state="translated">发送通知的最简单方法是调用函数 &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt; 。在这种情况下，代理执行获取操作以检索在通知规范中定义的对象值（使用TRAP-TYPE或NOTIFICATION-TYPE宏）。该通知将发送到目标和通知表中定义的所有管理器，它们要么未被确认为陷阱，要么被确认为通知请求。</target>
        </trans-unit>
        <trans-unit id="67648b768786640bf14fe9b8b58cbe1c7d6f3c6d" translate="yes" xml:space="preserve">
          <source>The simplest way to use EUnit in an Erlang module is to add the following line at the beginning of the module (after the &lt;code&gt;-module&lt;/code&gt; declaration, but before any function definitions):</source>
          <target state="translated">在Erlang模块中使用EUnit的最简单方法是在模块的开头（在 &lt;code&gt;-module&lt;/code&gt; 声明之后，但在任何函数定义之前）添加以下行：</target>
        </trans-unit>
        <trans-unit id="adfed9f44eb21dcbf877737d5382c564e366ffe7" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94829f2b959259f751a0e01f1565faf0e83453ae" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="translated">使用该设置的最简单方法是调用 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; ，它使用此函数的返回值来确定列表是否为可打印字符的字符串。</target>
        </trans-unit>
        <trans-unit id="410ab688ad74fcb927d318148676d55f9fa41dc2" translate="yes" xml:space="preserve">
          <source>The sixth argument is the instance number.</source>
          <target state="translated">第六个参数是实例号。</target>
        </trans-unit>
        <trans-unit id="09584020841c67187a5e4c45090a98af5e53582d" translate="yes" xml:space="preserve">
          <source>The size and offset of the specific field</source>
          <target state="translated">特定字段的大小和偏移量</target>
        </trans-unit>
        <trans-unit id="04a41d7d5ebfc159ad47e6d9484bf8d344a4ee18" translate="yes" xml:space="preserve">
          <source>The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later.</source>
          <target state="translated">如果表是公共的,在转储过程中,表的记录会被添加或删除,那么表头的大小字段可能与文件中的记录数不一致。在转储过程中更新的公共表,在读取时想要验证,至少需要一个字段的扩展信息,以便以后读取验证过程可靠。</target>
        </trans-unit>
        <trans-unit id="15a82dee25c7ae3a3f7d6659ea3993b106858ed6" translate="yes" xml:space="preserve">
          <source>The size includes 233 words for the heap area (which includes the stack). The garbage collector increases the heap as needed.</source>
          <target state="translated">大小包括233字的堆区(包括栈)。垃圾收集器会根据需要增加堆的大小。</target>
        </trans-unit>
        <trans-unit id="b0f54d25af981835a640f1718c86bf5f2b930bc6" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;Dgram&lt;/code&gt; is less than &lt;code&gt;4*HLen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 的大小小于 &lt;code&gt;4*HLen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="240cf2840ab83e06087b3c823b3105d452ce4e2c" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;struct tcp_info&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;struct tcp_info&lt;/code&gt; 的大小</target>
        </trans-unit>
        <trans-unit id="7ae9729d57a3cca0c039100e26f176b68d312d8b" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;, in words. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6bd4cbaa0c4a01c449ef3a984d1775fb023405" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="translated">老堆 &quot;的大小。Erlang虚拟机采用代际垃圾收集,有两代。新数据项有一个堆,两次垃圾收集后存活的数据有一个堆。假设(几乎总是正确的)是,经过两次垃圾收集幸存下来的数据可以被 &quot;终身 &quot;到一个更少被垃圾收集的堆中,因为它们会活很长时间。这在虚拟机中是一种常用的技术。堆和栈的总和一起构成了进程的大部分分配内存。</target>
        </trans-unit>
        <trans-unit id="8045fd58723fbeefad6762911d1edbd926bdac7b" translate="yes" xml:space="preserve">
          <source>The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is used, where N is public modulus of the RSA key.</source>
          <target state="translated">的大小 &lt;code&gt;PlainText&lt;/code&gt; 必须小于 &lt;code&gt;byte_size(N)-11&lt;/code&gt; 如果 &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; 被使用，并且 &lt;code&gt;byte_size(N)&lt;/code&gt; 如果 &lt;code&gt;rsa_no_padding&lt;/code&gt; 被使用，其中，N是RSA密钥的公共模量。</target>
        </trans-unit>
        <trans-unit id="20a866d073ca584886db7c9d897f09b98c62abbf" translate="yes" xml:space="preserve">
          <source>The size of the call counters is the host machine word size. One bit is used when pausing the counter, so the maximum counter value for a 32-bit host is 2147483647.</source>
          <target state="translated">调用计数器的大小是主机的字大小。暂停计数器时要用一个位,所以32位主机的最大计数器值是2147483647。</target>
        </trans-unit>
        <trans-unit id="fb56015c8eab043674edf8d83f2180e86ae9a77a" translate="yes" xml:space="preserve">
          <source>The size of the compressed file (the size of the uncompressed file is found in &lt;code&gt;info&lt;/code&gt;)</source>
          <target state="translated">压缩文件的大小（可在 &lt;code&gt;info&lt;/code&gt; 中找到未压缩文件的大小）</target>
        </trans-unit>
        <trans-unit id="2f0d2a526b810e744210895a97ddddfb9dfdd679" translate="yes" xml:space="preserve">
          <source>The size of the data that survived the previous garbage collection.</source>
          <target state="translated">上次垃圾收集后存活的数据大小。</target>
        </trans-unit>
        <trans-unit id="e9d65b80debf675400c50641feff8560b459d932" translate="yes" xml:space="preserve">
          <source>The size of the encoded values was 458 bytes for &lt;code&gt;GUI&lt;/code&gt; and 464 bytes for &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GUI&lt;/code&gt; 的编码值大小为458 字节， &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 的编码值为464字节。</target>
        </trans-unit>
        <trans-unit id="6de9b33cf1949c23faaaa88b249a1008b2802a9a" translate="yes" xml:space="preserve">
          <source>The size of the largest contiguous free memory block available to the Erlang emulator.</source>
          <target state="translated">Erlang仿真器可用的最大的连续可用内存块的大小。</target>
        </trans-unit>
        <trans-unit id="6d118a2b54a2818588ac5a0110de6ef29741d438" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the heap and the stack.</source>
          <target state="translated">用于存储堆和栈的内存块的大小。</target>
        </trans-unit>
        <trans-unit id="e6c71457bdeadfc9d10261846b10fe6f6d7f7a91" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the old heap.</source>
          <target state="translated">用于存储旧堆的内存块的大小。</target>
        </trans-unit>
        <trans-unit id="dc966159ad664aaf70a48fd1f0edce70ddc61365" translate="yes" xml:space="preserve">
          <source>The size of the process in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 获得的进程大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="764453484226497e0bb92b39542a42c4b18f03bf" translate="yes" xml:space="preserve">
          <source>The size of the process, in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 获得的进程大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="191298b20bbe06d47611b490fefa2f8a4b372b8e" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap (they share memory segment).</source>
          <target state="translated">栈和堆的大小(它们共享内存段)。</target>
        </trans-unit>
        <trans-unit id="b499431fe56f03547ddeaaaf414d227e0530ddbf" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap, in words (they share memory segment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178ae932ebc1af7c2dda4dfd8f46a38ebd32810a" translate="yes" xml:space="preserve">
          <source>The size of the stack.</source>
          <target state="translated">栈的大小。</target>
        </trans-unit>
        <trans-unit id="8f1488fc1dd7db66c80f3a57b0e5af0af66de229" translate="yes" xml:space="preserve">
          <source>The size of the tail must be evenly divisible by 8.</source>
          <target state="translated">尾巴的大小必须均匀地除以8。</target>
        </trans-unit>
        <trans-unit id="0d0d88986d4bbf13803d8e24b41f46f6997c4e2c" translate="yes" xml:space="preserve">
          <source>The size of the used part of the heap.</source>
          <target state="translated">堆中已使用部分的大小。</target>
        </trans-unit>
        <trans-unit id="2b09e2b23bece918b025556de700326cad53b8b5" translate="yes" xml:space="preserve">
          <source>The size of the used part of the old heap.</source>
          <target state="translated">旧堆的使用部分的大小。</target>
        </trans-unit>
        <trans-unit id="41304c62a18f9ce2c917c4249897d635a4661faf" translate="yes" xml:space="preserve">
          <source>The size of the user-level buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. For TCP it is recommended to have &lt;code&gt;val(buffer) &amp;gt;= val(recbuf)&lt;/code&gt; to avoid performance issues because of unnecessary copying. For UDP the same recommendation applies, but the max should not be larger than the MTU of the network path. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when &lt;code&gt;recbuf&lt;/code&gt; is set. However, as the size set for &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a8f533f48a479fd53920b8d4e9fa6257ad510" translate="yes" xml:space="preserve">
          <source>The size of the user-level software buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. It is recommended to have &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; to avoid performance issues because of unnecessary copying. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when values &lt;code&gt;sndbuf&lt;/code&gt; or &lt;code&gt;recbuf&lt;/code&gt; are set. However, as the sizes set for &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="translated">驱动程序使用的用户级软件缓冲区的大小。不要与 &lt;code&gt;sndbuf&lt;/code&gt; 和 &lt;code&gt;recbuf&lt;/code&gt; 选项混淆，它们与内核套接字缓冲区相对应。建议使 &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; 避免由于不必要的复制而导致的性能问题。当设置了值 &lt;code&gt;sndbuf&lt;/code&gt; 或 &lt;code&gt;recbuf&lt;/code&gt; 时， &lt;code&gt;val(buffer)&lt;/code&gt; 会自动设置为上述最大值。但是，由于为 &lt;code&gt;sndbuf&lt;/code&gt; 和 &lt;code&gt;recbuf&lt;/code&gt; 设置的大小通常会变大，因此建议您使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 来分析操作系统的行为。</target>
        </trans-unit>
        <trans-unit id="0337cb0052fe5c48f17d9708364b5583f847dcf3" translate="yes" xml:space="preserve">
          <source>The size used by the atom table.</source>
          <target state="translated">原子表使用的大小。</target>
        </trans-unit>
        <trans-unit id="e83812695b4a0e2f148a81a290a4a4d654c89eac" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of a log file before switching to a new log file. Defaults to 100000, minimum is 1000, maximum is about 2^30.</source>
          <target state="translated">在切换到新的日志文件之前,日志文件的大小,以字节为单位。默认为100000,最小为1000,最大约为2^30。</target>
        </trans-unit>
        <trans-unit id="50b5375e0c8bae3f537af36dd5bfe134a6c1fd3a" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel receive buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(recbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">此套接字的OS内核接收缓冲区的大小（以字节为单位）。对于大于 &lt;code&gt;val(recbuf)&lt;/code&gt; 的数据报，将发生发送错误。设置此选项还可以调整驱动程序缓冲区的大小（请参见上面的 &lt;code&gt;buffer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="744f9981cac8532f8de991a560a3c78c830d93a6" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel send buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(sndbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">此套接字的OS内核发送缓冲区的大小（以字节为单位）。对于大于 &lt;code&gt;val(sndbuf)&lt;/code&gt; 的数据报，将发生发送错误。设置此选项还可以调整驱动程序缓冲区的大小（请参见上面的 &lt;code&gt;buffer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80ca8cbf4860dc45abcab2ee816502487d967651" translate="yes" xml:space="preserve">
          <source>The sizes of the log events affect the memory needs of the handler. For information about how to limit the size of log events, see the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">日志事件的大小会影响处理程序的内存需求。有关如何限制日志事件大小的信息，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="e2bdd08787f901adfc9bda5806a8294e711f82f7" translate="yes" xml:space="preserve">
          <source>The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used.</source>
          <target state="translated">从属节点要在主节点使用相同的文件系统。至少,Erlang/OTP要安装在两台计算机的同一个地方,并且要使用相同版本的Erlang。</target>
        </trans-unit>
        <trans-unit id="f96a0c0475b2702681a975d50f5c5275575ff811" translate="yes" xml:space="preserve">
          <source>The slave node resets its &lt;code&gt;user&lt;/code&gt; process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master.</source>
          <target state="translated">从属节点重置其 &lt;code&gt;user&lt;/code&gt; 进程，以便在从属节点上生成的所有终端I / O自动中继到主节点。同样，文件过程将中继到主服务器。</target>
        </trans-unit>
        <trans-unit id="c5dfcb751ff28f219d1d581b79806c8ef4c53f7f" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt;, passing along &lt;code&gt;Name&lt;/code&gt; and, if provided, &lt;code&gt;Args&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; is used as the first part of the node names, &lt;code&gt;Args&lt;/code&gt; is used to specify command-line arguments.</source>
          <target state="translated">从节点以 &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt; 开头，并传递 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Args&lt;/code&gt; （如果提供）。 &lt;code&gt;Name&lt;/code&gt; 用作节点名称的第一部分， &lt;code&gt;Args&lt;/code&gt; 用于指定命令行参数。</target>
        </trans-unit>
        <trans-unit id="b6a9facae6762d3a2d983123523a049078f4b929" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with the &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; module. This effects terminal I/O, file I/O, and code loading.</source>
          <target state="translated">从节点通过 &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; 模块启动。这会影响终端I / O，文件I / O和代码加载。</target>
        </trans-unit>
        <trans-unit id="eff695ae8a9be5c2401875ebeb79790be1f1fe68" translate="yes" xml:space="preserve">
          <source>The slave nodes send regular reports to the master about their current load.</source>
          <target state="translated">从属节点定期向主节点发送关于当前负载的报告。</target>
        </trans-unit>
        <trans-unit id="1bd8d8ae05660e3f8d1c448fac43b54c3d2e34e2" translate="yes" xml:space="preserve">
          <source>The smallest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">最小的多块载波大小（ &lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="aa74489ccfd55ad582b4db554e67d3965db81df4" translate="yes" xml:space="preserve">
          <source>The smallest unit that the test server is concerned with is a test case. Each test case can test many things, for example, make several calls to the same interface function with different parameters.</source>
          <target state="translated">测试服务器所关注的最小单元是测试用例。每个测试用例可以测试很多东西,例如,用不同的参数对同一个接口函数进行多次调用。</target>
        </trans-unit>
        <trans-unit id="9ea79c809c45352a9e00179e7da2c36055d038e8" translate="yes" xml:space="preserve">
          <source>The snmp application provides two different modules, &lt;code&gt;snmpm_net_if&lt;/code&gt; (the default) and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;, both uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;. The difference between the two modules is that the latter is &quot;multi-threaded&quot;, i.e. for each message/request a new process is created that processes the message/request and then exits.</source>
          <target state="translated">snmp应用程序提供了两个不同的模块 &lt;code&gt;snmpm_net_if&lt;/code&gt; （默认值）和 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ，它们均使用UDP作为传输协议，即传输域 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 和/或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 。这两个模块之间的区别在于后者是&amp;ldquo;多线程的&amp;rdquo;，即，对于每个消息/请求，都会创建一个新进程来处理消息/请求，然后退出。</target>
        </trans-unit>
        <trans-unit id="b02a7822a31c2facabfac5e02e61cea15f2e0693" translate="yes" xml:space="preserve">
          <source>The socket interface (module) is basically a &quot;thin&quot; layer on top of the OS socket interface. It is assumed that, unless you have special needs, gen_[tcp|udp|sctp] should be sufficent (when they become available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d257b12c0103c2f2773954dbb3903b79d49e7" translate="yes" xml:space="preserve">
          <source>The socket is set to a busy state when the amount of data queued internally by the ERTS socket implementation reaches this limit. Defaults to 8 kB.</source>
          <target state="translated">当ERTS套接字实现内部排队的数据量达到该限制时,套接字被设置为繁忙状态。默认值为8 kB。</target>
        </trans-unit>
        <trans-unit id="ab70c80adb0296ab4476e7326e05623f1d1b81ea" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be from &lt;code&gt;gen_tcp:connect&lt;/code&gt; or &lt;code&gt;gen_tcp:accept&lt;/code&gt; with option &lt;code&gt;{active,false}&lt;/code&gt;</source>
          <target state="translated">该套接字应该来自 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 或 &lt;code&gt;gen_tcp:accept&lt;/code&gt; ,带有选项 &lt;code&gt;{active,false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44cb3c6e112d60616f61ce3179ae2f5db9db0cba" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be result of a &lt;code&gt;gen_tcp:connect&lt;/code&gt; or a &lt;code&gt;gen_tcp:accept&lt;/code&gt;. The socket must be in passive mode (that is, opened with the option &lt;code&gt;{active,false})&lt;/code&gt;.</source>
          <target state="translated">该套接字应该是 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 或 &lt;code&gt;gen_tcp:accept&lt;/code&gt; 的结果。套接字必须处于被动模式（即，使用选项 &lt;code&gt;{active,false})&lt;/code&gt; 打开）。</target>
        </trans-unit>
        <trans-unit id="925659a2ced1ee88f823aa52063a42e6955489e2" translate="yes" xml:space="preserve">
          <source>The socket message queue is set to a busy state when the amount of data on the message queue reaches this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 8 kB.</source>
          <target state="translated">当消息队列上的数据量达到这个限制时,套接字消息队列就会被设置为繁忙状态。注意,这个限制只涉及尚未到达ERTS内部套接字实现的数据。默认值为8 kB。</target>
        </trans-unit>
        <trans-unit id="f02f850d90c7fd6701fa67a1c73724ba84ac1faf" translate="yes" xml:space="preserve">
          <source>The socket owner process.</source>
          <target state="translated">套接字所有者进程。</target>
        </trans-unit>
        <trans-unit id="72f50e8cca44d427ecdea919b729a9f976d4b8f1" translate="yes" xml:space="preserve">
          <source>The socket returned can only be used with &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt;. No traffic can be sent or received before that call.</source>
          <target state="translated">返回的套接字只能与 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 。在该呼叫之前，无法发送或接收流量。</target>
        </trans-unit>
        <trans-unit id="68853c7896ab72f079055456a599e669b94ec773" translate="yes" xml:space="preserve">
          <source>The socket, in format &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;, depending on &lt;code&gt;socket_type&lt;/code&gt;.</source>
          <target state="translated">套接字，格式为 &lt;code&gt;ip_comm&lt;/code&gt; 或 &lt;code&gt;ssl&lt;/code&gt; ，具体取决于 &lt;code&gt;socket_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2268a9a9dea928b5f653dddc6d70d3d7abdecd4b" translate="yes" xml:space="preserve">
          <source>The software the client claims to be using (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">客户声称使用的软件(如果无法确定,则在此字段打上减号);</target>
        </trans-unit>
        <trans-unit id="af7122a56cc3283d794f4f2131bcb161acc514ee" translate="yes" xml:space="preserve">
          <source>The solution in R16 is instead to &lt;strong&gt;replicate&lt;/strong&gt; the code access structures. We have one set of active structures read by the running code. When new code is loaded the active structures are copied, the copy is updated to include the newly loaded module and then a switch is made to make the updated copy the new active set. The active set is identified by a single global atomic variable &lt;code&gt;the_active_code_index&lt;/code&gt;. The switch can thus be made by a single atomic write operation. The running code have to read this atomic variable when using the active access structures, which means one atomic read operation per external function call for example. The performance penalty from this extra atomic read is however very small as it can be done without any memory barriers at all (as described below). With this solution we also preserve the transactional feature of a load operation. Running code will never see the intermediate result of a half loaded module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59919acf7ad71bce9fc6539c387deaefebd73d43" translate="yes" xml:space="preserve">
          <source>The sorter uses temporary files only if &lt;code&gt;QH1&lt;/code&gt; does not evaluate to a list and the size of the binary representation of the answers exceeds &lt;code&gt;Size&lt;/code&gt; bytes, where &lt;code&gt;Size&lt;/code&gt; is the value of option &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;QH1&lt;/code&gt; 不求值到列表并且答案的二进制表示形式的 &lt;code&gt;Size&lt;/code&gt; 超过Size字节时，排序器才使用临时文件，其中 &lt;code&gt;Size&lt;/code&gt; 是option &lt;code&gt;size&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="881ec9a1f2e48b94ddfd3fa755f8d866af15e90d" translate="yes" xml:space="preserve">
          <source>The source code can be downloaded from the official site of Erlang/OTP or GitHub.</source>
          <target state="translated">源码可以从Erlang/OTP的官方网站或GitHub下载。</target>
        </trans-unit>
        <trans-unit id="1e180c78c274b1e63d26ec543874e277c8a7cd9c" translate="yes" xml:space="preserve">
          <source>The source code is indented and each line is prefixed with its line number.</source>
          <target state="translated">源代码是缩进的,每一行都以行号为前缀。</target>
        </trans-unit>
        <trans-unit id="772cf36afe48c0ca08d944464d6f5613843516b5" translate="yes" xml:space="preserve">
          <source>The source file is compiled with the the original options appended to the given &lt;code&gt;Options&lt;/code&gt;, the output replacing the old object file if and only if compilation succeeds. A function &lt;code&gt;Filter&lt;/code&gt; can be specified for removing elements from from the original compiler options before the new options are added.</source>
          <target state="translated">源文件将使用原始选项附加到给定的 &lt;code&gt;Options&lt;/code&gt; 进行编译，当且仅当编译成功时，输出才会替换旧的目标文件。可以指定功能 &lt;code&gt;Filter&lt;/code&gt; 器，以在添加新选项之前从原始编译器选项中删除元素。</target>
        </trans-unit>
        <trans-unit id="d06894cd41dc043df906ea8b5e56fb15f704aa5a" translate="yes" xml:space="preserve">
          <source>The source for a backup is an activated checkpoint. The backup function &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; is most commonly used and returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;. It has the following arguments:</source>
          <target state="translated">备份的源是激活的检查点。备份函数 &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; 最常用，并返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 。它具有以下参数：</target>
        </trans-unit>
        <trans-unit id="21ba4b6f6db86323236436d5d356017eead9a57a" translate="yes" xml:space="preserve">
          <source>The source of the message, usually the name of the application that generated it. This could be almost any string. When matching messages from certain applications, the version number of the application may have to be accounted for. This is what the NT event viewer calls &quot;source&quot;.</source>
          <target state="translated">消息的来源,通常是生成该消息的应用程序的名称。这几乎可以是任何字符串。当匹配来自某些应用程序的消息时,可能必须考虑到应用程序的版本号。这就是NT事件查看器所说的 &quot;源&quot;。</target>
        </trans-unit>
        <trans-unit id="fcf8739969b05c2227a6f3526a3eecacb416317d" translate="yes" xml:space="preserve">
          <source>The source release is delivered with a lot of platform independent build results already pre-built. If you want to remove these pre-built files, invoke &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; from the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. After you have done this, you can build exactly the same way as before, but the build process will take a much longer time.</source>
          <target state="translated">提供的源代码版本已预先构建了许多与平台无关的构建结果。如果要删除这些预构建文件， &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; 从 &lt;code&gt;$ERL_TOP&lt;/code&gt; 目录中调用./otp_build remove_prebuilt_files。完成此操作后，您可以按照与以前完全相同的方式进行构建，但是构建过程将花费更长的时间。</target>
        </trans-unit>
        <trans-unit id="a52e9171d64ddfe2904377da52809c70237ed94b" translate="yes" xml:space="preserve">
          <source>The spawn driver (used when spawning an executable) and the &lt;code&gt;fd&lt;/code&gt; driver do not disable this feature and do not adjust these limits by themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4f39d77f5cdfa59ed6968030318e46812bded4" translate="yes" xml:space="preserve">
          <source>The spawn operation fails either if creation of a new process failed or if the spawn operation was interrupted by a connection failure. When a spawn operation fails, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, error, Reason}&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is the error reason. Such a message is referred to as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c6c390b6e4eef5413283b9b82f2f391a4ea8bf" translate="yes" xml:space="preserve">
          <source>The spawn request was successfully abandoned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ba3eb61829a7833d7384b19b027906c4b3feb1" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$ROOT&lt;/code&gt; variable can only be used in the script, not as a command-line argument. The given directory is relative the Erlang installation directory.</source>
          <target state="translated">特殊的 &lt;code&gt;$ROOT&lt;/code&gt; 变量只能在脚本中使用，而不能用作命令行参数。给定目录是相对于Erlang安装目录的。</target>
        </trans-unit>
        <trans-unit id="fd2015df355d448e0a3bd19ecbc252e161ab2cfb" translate="yes" xml:space="preserve">
          <source>The special match specification variables &lt;code&gt;'$_'&lt;/code&gt; and &lt;code&gt;'$*'&lt;/code&gt; can be accessed through the pseudo functions &lt;code&gt;object()&lt;/code&gt; (for &lt;code&gt;'$_'&lt;/code&gt;) and &lt;code&gt;bindings()&lt;/code&gt; (for &lt;code&gt;'$*'&lt;/code&gt;). As an example, one can translate the following &lt;code&gt;ets:match_object/2&lt;/code&gt; call to a &lt;code&gt;ets:select/2&lt;/code&gt; call:</source>
          <target state="translated">特殊的匹配规范变量 &lt;code&gt;'$_'&lt;/code&gt; 和 &lt;code&gt;'$*'&lt;/code&gt; 可以通过伪函数 &lt;code&gt;object()&lt;/code&gt; （对于 &lt;code&gt;'$_'&lt;/code&gt; ）和 &lt;code&gt;bindings()&lt;/code&gt; （对于 &lt;code&gt;'$*'&lt;/code&gt; ）访问。例如，可以将以下 &lt;code&gt;ets:match_object/2&lt;/code&gt; 调用转换为 &lt;code&gt;ets:select/2&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="3d184230e40d23967b4ecaa91bc5e82ccd5cf4c3" translate="yes" xml:space="preserve">
          <source>The special property L&amp;amp; is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or &quot;other&quot;.</source>
          <target state="translated">还支持特殊属性L＆。它与具有Lu，Ll或Lt属性的字符匹配，即，未被分类为修饰语或&amp;ldquo;其他&amp;rdquo;的字母。</target>
        </trans-unit>
        <trans-unit id="6d78a416b1fb043fc9e7a30712c95b72e4af2747" translate="yes" xml:space="preserve">
          <source>The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.</source>
          <target state="translated">特殊的shell命令都具有(本地)函数调用的语法。它们与普通函数调用一样被评估,许多命令可以在一个表达式序列中使用。</target>
        </trans-unit>
        <trans-unit id="63aa3b1e5890590b0f6ee8261569fec19c3e02cf" translate="yes" xml:space="preserve">
          <source>The special term &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; is used to &quot;splice&quot; in a string in a list, a string specified this way is not a list in itself, but the elements are elements of the surrounding list.</source>
          <target state="translated">特殊术语 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 用于&amp;ldquo;拼接&amp;rdquo;列表中的字符串，用这种方式指定的字符串本身并不是列表，而是元素是周围列表的元素。</target>
        </trans-unit>
        <trans-unit id="3767f42dfb86884ecfa881e3b33b5f1bd1f1e163" translate="yes" xml:space="preserve">
          <source>The special value &lt;code&gt;disable&lt;/code&gt; prevents the Server Name Indication extension from being sent and disables the hostname verification check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f706ef9a4d4e07f69004ede757b96ff5ef984e0" translate="yes" xml:space="preserve">
          <source>The special value &lt;strong&gt;flag&lt;/strong&gt; instead indicates that the function &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; shall be used.</source>
          <target state="translated">相反，特殊值&lt;strong&gt;标志&lt;/strong&gt;指示应使用功能 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c180b14afbed7b4ae1c88179e9218b5daae9170a" translate="yes" xml:space="preserve">
          <source>The specific instruction &lt;code&gt;i_bs_get_integer_32&lt;/code&gt; will only be defined on a 64-bit machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf1b065f7475d6ac0e5944dcaad766452c86801" translate="yes" xml:space="preserve">
          <source>The specific instructions are known only to the runtime system and are the instructions that are actually executed. They can be changed at any time without causing compatibility issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbf785b1e1daf48fbb6ef71da6f40a7025aba2b" translate="yes" xml:space="preserve">
          <source>The specification key does not exist.</source>
          <target state="translated">规格键不存在。</target>
        </trans-unit>
        <trans-unit id="e6b11d2daf1d2fe5ce8435f49d6f63466ec21923" translate="yes" xml:space="preserve">
          <source>The specification of &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; can be hard-coded as &lt;code&gt;{index, [2]}&lt;/code&gt; and &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 和 &lt;code&gt;attributes&lt;/code&gt; 的规范可以分别硬编码为 &lt;code&gt;{index, [2]}&lt;/code&gt; 和 &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="569ad77b917c89cf2cb18ed8978c4e321b16e950" translate="yes" xml:space="preserve">
          <source>The specifications &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; were used in the test.</source>
          <target state="translated">测试中使用了 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="3c9f9bb6dda1817bac37a46fe84e1fbe4666f5af" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Filename&lt;/code&gt; is prefixed with the node name. Default &lt;code&gt;Filename&lt;/code&gt; is &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">指定的 &lt;code&gt;Filename&lt;/code&gt; 以节点名为前缀。默认 &lt;code&gt;Filename&lt;/code&gt; 名为 &lt;code&gt;ttb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a78dd1ea59140a32308f444a3d3f489add93983" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;comparing equal&lt;/strong&gt; the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table, or &lt;strong&gt;matching&lt;/strong&gt; in other types of tables (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定的 &lt;code&gt;Key&lt;/code&gt; 用于通过&lt;strong&gt;比较&lt;/strong&gt; &lt;code&gt;ordered_set&lt;/code&gt; 表中的对象的键或&lt;strong&gt;与&lt;/strong&gt;其他类型的表中的对象进行&lt;strong&gt;匹配&lt;/strong&gt;来标识对象（有关差异的详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="832d1f70c554be8c643c3c3c0c699e86c09d600d" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;matching&lt;/strong&gt; the key of an object in a &lt;code&gt;set&lt;/code&gt; table, or &lt;strong&gt;compare equal&lt;/strong&gt; to the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定的 &lt;code&gt;Key&lt;/code&gt; 所使用的任一识别对象&lt;strong&gt;匹配&lt;/strong&gt;的对象的键的 &lt;code&gt;set&lt;/code&gt; 的表，或&lt;strong&gt;比较相等&lt;/strong&gt;，以在对象的键 &lt;code&gt;ordered_set&lt;/code&gt; 表（对于该差的详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5c6caca78cf0733387e75985a561e3ed41d83af2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;logdir&lt;/code&gt; directory is used for storing the HTML log files (in subdirectories tagged with node name, date, and time).</source>
          <target state="translated">指定的 &lt;code&gt;logdir&lt;/code&gt; 目录用于存储HTML日志文件（在带有节点名称，日期和时间标记的子目录中）。</target>
        </trans-unit>
        <trans-unit id="d8f4d5f198f549cf59998ab6e9b38627280804f7" translate="yes" xml:space="preserve">
          <source>The specified XML document is sent &quot;as is&quot; to the server. This function can be used for sending XML documents that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">指定的XML文档 &quot;按原样 &quot;发送到服务器。这个函数可以用来发送本模块中其他接口函数无法表达的XML文档。</target>
        </trans-unit>
        <trans-unit id="67af2595bd4825418d486d6611387842fada4fe3" translate="yes" xml:space="preserve">
          <source>The specified XML document is wrapped in a valid NETCONF &lt;code&gt;rpc&lt;/code&gt; request and sent to the server. The &lt;code&gt;message-id&lt;/code&gt; and namespace attributes are added to element &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">指定的XML文档包装在有效的NETCONF &lt;code&gt;rpc&lt;/code&gt; 请求中，并发送到服务器。所述 &lt;code&gt;message-id&lt;/code&gt; 和名称空间的属性被添加到元件 &lt;code&gt;rpc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77ace5a3a9ee7abec7d82aa98cb78832103cfb00" translate="yes" xml:space="preserve">
          <source>The specified application is not loaded.</source>
          <target state="translated">指定的应用程序未加载。</target>
        </trans-unit>
        <trans-unit id="7d093a57604a6ecaca53b3ce36fbb95e4bc18f8a" translate="yes" xml:space="preserve">
          <source>The specified module flows from your instantiation of the &lt;code&gt;Viewer&lt;/code&gt;, to the &lt;code&gt;Collector&lt;/code&gt; that it automatically creates, gets stashed in as the &lt;code&gt;Trace Pattern&lt;/code&gt;, and eventually goes down into the bowels of the &lt;code&gt;Selector&lt;/code&gt;.</source>
          <target state="translated">指定的模块从您的 &lt;code&gt;Viewer&lt;/code&gt; 实例流向它自动创建的 &lt;code&gt;Collector&lt;/code&gt; ，将其藏入 &lt;code&gt;Trace Pattern&lt;/code&gt; 中，最后进入 &lt;code&gt;Selector&lt;/code&gt; 的肠道。</target>
        </trans-unit>
        <trans-unit id="d37865ea2af043489e228e4a87a6f2db90cb4c8d" translate="yes" xml:space="preserve">
          <source>The specified release version &lt;code&gt;Vsn&lt;/code&gt; does not exist.</source>
          <target state="translated">指定的发行版本 &lt;code&gt;Vsn&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="3b8bce2d65b733b38425b28f665ddd56d541e379" translate="yes" xml:space="preserve">
          <source>The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged</source>
          <target state="translated">指定的字符串或字符会进行大小写转换。请注意,支持的字符集是ISO/IEC 8859-1(也称为拉丁文1);该字符集之外的所有值都不会改变。</target>
        </trans-unit>
        <trans-unit id="a909f58eed86dcb459bb7e97f8bf0f61f50ce1e8" translate="yes" xml:space="preserve">
          <source>The spelling &lt;code&gt;behavior&lt;/code&gt; is also accepted.</source>
          <target state="translated">也接受拼写 &lt;code&gt;behavior&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efd3f0f6af9bad896585909bd0ff06183026aa0e" translate="yes" xml:space="preserve">
          <source>The ssh server on the remote host checks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055977833d1ee7a28dbe717c666d179fb1aed3c2" translate="yes" xml:space="preserve">
          <source>The ssh:start/0 function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5309c7fe313dda17e9facd4377c48f36ec3201cb" translate="yes" xml:space="preserve">
          <source>The stack back-trace (&lt;strong&gt;stacktrace&lt;/strong&gt;) is a list of &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; tuples. The field &lt;code&gt;Arity&lt;/code&gt; in the first tuple can be the argument list of that function call instead of an arity integer, depending on the exception.</source>
          <target state="translated">堆栈回溯（&lt;strong&gt;stacktrace&lt;/strong&gt;）是 &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; 元组的列表。根据 &lt;code&gt;Arity&lt;/code&gt; ，第一个元组中的Arity字段可以是该函数调用的参数列表，而不是arity整数。</target>
        </trans-unit>
        <trans-unit id="45ce8e9f1c15d0274292ea0288412d440ab1701d" translate="yes" xml:space="preserve">
          <source>The stack dump is a dump of the Erlang process stack. Most of the live data (that is, variables currently in use) are placed on the stack; thus this can be interesting. One has to &quot;guess&quot; what is what, but as the information is symbolic, thorough reading of this information can be useful. As an example, we can find the state variable of the Erlang primitive loader online &lt;code&gt;(5)&lt;/code&gt; and &lt;code&gt;(6)&lt;/code&gt; in the following example:</source>
          <target state="translated">堆栈转储是Erlang进程堆栈的转储。大多数实时数据（即当前正在使用的变量）都放置在堆栈中。因此这可能很有趣。人们必须&amp;ldquo;猜测&amp;rdquo;什么是什么，但是由于该信息是象征性的，因此彻底阅读此信息可能会很有用。例如，可以在以下示例中在线找到 &lt;code&gt;(5)&lt;/code&gt; 和 &lt;code&gt;(6)&lt;/code&gt; 的Erlang基本加载器的状态变量：</target>
        </trans-unit>
        <trans-unit id="f4779fab4d980187187f7b568fd5d1cecf627b61" translate="yes" xml:space="preserve">
          <source>The stack trace can be be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="translated">堆栈跟踪可被从内绑定到变量 &lt;code&gt;try&lt;/code&gt; 表达，并且返回类的异常 &lt;code&gt;error&lt;/code&gt; 由一个 &lt;code&gt;catch&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="716b4c8e42164ca68dd1eef2aad830b323c54fbe" translate="yes" xml:space="preserve">
          <source>The stack trace can be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8ca8ba7f9cf2f1cf34954b8c2fda1504010ff" translate="yes" xml:space="preserve">
          <source>The stacktrace is the same data as operator &lt;code&gt;catch&lt;/code&gt; returns, for example:</source>
          <target state="translated">stacktrace与运算符 &lt;code&gt;catch&lt;/code&gt; 返回的数据相同，例如：</target>
        </trans-unit>
        <trans-unit id="fc5e2be1fd73b3184fa33140f882adc2e4eaf503" translate="yes" xml:space="preserve">
          <source>The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the current maximum stacktrace depth.</source>
          <target state="translated">堆栈跟踪作为调用进程的异常堆栈跟踪,它被截断到当前最大的堆栈跟踪深度。</target>
        </trans-unit>
        <trans-unit id="95f65f456f73c264cfc1076a4ff37600ccf76a4a" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP behaviours are:</source>
          <target state="translated">标准的Erlang/OTP行为是。</target>
        </trans-unit>
        <trans-unit id="bf7122f2f75170b13714d7076b64a347b292a606" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP system can be reconfigured to change the default behavior on startup.</source>
          <target state="translated">可以重新配置标准的Erlang/OTP系统,以改变启动时的默认行为。</target>
        </trans-unit>
        <trans-unit id="b7b586ddbaa84cea01ad2740636b956444f85f5b" translate="yes" xml:space="preserve">
          <source>The standard behaviours (&lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, and so on) send progress and error information to Logger. Progress reports are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;. Supervisor reports, crash reports and other error and information reports are by default logged through the log handler which is set up when the Kernel application is started.</source>
          <target state="translated">标准行为（ &lt;code&gt;supervisor&lt;/code&gt; ， &lt;code&gt;gen_server&lt;/code&gt; 等）将进度和错误信息发送到Logger。默认情况下不会记录进度报告，但是可以通过将主要日志级别设置为 &lt;code&gt;info&lt;/code&gt; 来启用，例如，使用内核配置参数 &lt;code&gt;logger_level&lt;/code&gt; 。默认情况下，主管报告，崩溃报告以及其他错误和信息报告通过启动内核应用程序时设置的日志处理程序进行记录。</target>
        </trans-unit>
        <trans-unit id="2005b81eb265a1528dcd843192ed7f5d98a0c04c" translate="yes" xml:space="preserve">
          <source>The standard binary encoding is used whenever a library function in Erlang is to handle Unicode data in binaries, but is of course not enforced when communicating externally. Functions and bit syntax exist to encode and decode both UTF-8, UTF-16, and UTF-32 in binaries. However, library functions dealing with binaries and Unicode in general only deal with the default encoding.</source>
          <target state="translated">每当Erlang中的库函数要处理二进制文件中的Unicode数据时,都会使用标准的二进制编码,当然在对外通信时并不强制执行。存在着对二进制文件中UTF-8、UTF-16和UTF-32进行编码和解码的函数和位语法。然而,处理二进制文件和Unicode的库函数一般只处理默认编码。</target>
        </trans-unit>
        <trans-unit id="4183835861454020cbfc8b77885a3f621959b27b" translate="yes" xml:space="preserve">
          <source>The standard certificate extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">标准证书扩展OID名称原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="e8da6740394a506d3316b11fa47e1c984ea529f7" translate="yes" xml:space="preserve">
          <source>The standard documents that define SNMPv2 are incomplete, in the sense that they do not specify how an SNMPv2 message looks like. The message format and security issues are left to a special Administrative Framework. One such framework is the Community-based SNMPv2 Framework (SNMPv2c), which uses the same message format and framework as SNMPv1. Other experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.</source>
          <target state="translated">定义SNMPv2的标准文件是不完整的,因为它们没有规定SNMPv2消息的样子。消息格式和安全问题留给了一个特殊的管理框架。其中一个框架是基于社区的SNMPv2框架(SNMPv2c),它使用与SNMPv1相同的消息格式和框架。 其他实验性框架也存在,例如SNMPv2u和SNMPv2*。</target>
        </trans-unit>
        <trans-unit id="dc54a83b77765211d993fa09d8d0f6be7eb0aa1e" translate="yes" xml:space="preserve">
          <source>The standard example is when formatting source code as HTML to be placed within &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; markup, and using e.g. &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; to make parts of the source code stand out. In this case, the markup does not add to the width of the text when viewed in an HTML browser, so the layout engine should simply pretend that the markup has zero width.</source>
          <target state="translated">标准示例是将源代码格式化为HTML以放置在 &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; 标记内，并使用例如 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 来使部分源代码脱颖而出。在这种情况下，在HTML浏览器中查看时，标记不会增加文本的宽度，因此布局引擎应该简单地假设标记的宽度为零。</target>
        </trans-unit>
        <trans-unit id="913db80fae0242e7eb7aa0597b7610d00dd2e55e" translate="yes" xml:space="preserve">
          <source>The standard list encoding for strings was therefore easily extended to handle the whole Unicode range. A Unicode string in Erlang is a list containing integers, where each integer is a valid Unicode code point and represents one character in the Unicode character set.</source>
          <target state="translated">因此,字符串的标准列表编码很容易被扩展到处理整个Unicode范围。Erlang中的Unicode字符串是一个包含整数的列表,其中每个整数都是一个有效的Unicode码点,代表Unicode字符集中的一个字符。</target>
        </trans-unit>
        <trans-unit id="96e137cd77a79e26488628d7b4bc6d3c818af033" translate="yes" xml:space="preserve">
          <source>The standard module &lt;code&gt;lists&lt;/code&gt; also contains a function &lt;code&gt;sort(Fun, List)&lt;/code&gt; where &lt;code&gt;Fun&lt;/code&gt; is a fun with two arguments. This fun returns &lt;code&gt;true&lt;/code&gt; if the first argument is less than the second argument, or else &lt;code&gt;false&lt;/code&gt;. Sorting is added to the &lt;code&gt;convert_list_to_c&lt;/code&gt;:</source>
          <target state="translated">标准模块 &lt;code&gt;lists&lt;/code&gt; 还包含一个函数 &lt;code&gt;sort(Fun, List)&lt;/code&gt; ，其中 &lt;code&gt;Fun&lt;/code&gt; 是带有两个参数的乐趣。如果第一个参数小于第二个参数，则此fun返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。排序已添加到 &lt;code&gt;convert_list_to_c&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b21571b3224dc79a2851fad7a8fdb257c1dfd3c9" translate="yes" xml:space="preserve">
          <source>The standard shell is set for &lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;latin1&lt;/code&gt; encoding when the system is started. The encoding is set with the help of the &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in &lt;code&gt;{encoding, unicode}&lt;/code&gt; mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option.</source>
          <target state="translated">启动系统时，将标准外壳程序设置为 &lt;code&gt;unicode&lt;/code&gt; 或 &lt;code&gt;latin1&lt;/code&gt; 编码。在类Unix系统上借助 &lt;code&gt;LANG&lt;/code&gt; 或 &lt;code&gt;LC_CTYPE&lt;/code&gt; 环境变量或在其他系统上通过其他方式设置编码。因此，如果I / O设备支持，则用户可以输入Unicode字符，并且I / O设备处于 &lt;code&gt;{encoding, unicode}&lt;/code&gt; 模式。如果运行时系统的假设错误，则可以通过设置此选项来更改模式。</target>
        </trans-unit>
        <trans-unit id="60bbcd01c05d5bf0aeb5fe03e942b16191c94a69" translate="yes" xml:space="preserve">
          <source>The start function &lt;strong&gt;must create and link to&lt;/strong&gt; the child process, and must return &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, where &lt;code&gt;Child&lt;/code&gt; is the pid of the child process and &lt;code&gt;Info&lt;/code&gt; any term that is ignored by the supervisor.</source>
          <target state="translated">启动函数&lt;strong&gt;必须创建并链接到&lt;/strong&gt;子进程，并且必须返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，其中 &lt;code&gt;Child&lt;/code&gt; 是子进程的pid， &lt;code&gt;Info&lt;/code&gt; 是主管忽略的任何术语。</target>
        </trans-unit>
        <trans-unit id="32924ed60f44bfc045cee6cadfb10d688a40ff5d" translate="yes" xml:space="preserve">
          <source>The start function can also return &lt;code&gt;ignore&lt;/code&gt; if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored.</source>
          <target state="translated">如果由于某种原因无法启动子进程，则启动功能还可以返回 &lt;code&gt;ignore&lt;/code&gt; ，在这种情况下，子规范由主管保留（除非它是一个临时子进程），但是不存在的子进程将被忽略。</target>
        </trans-unit>
        <trans-unit id="a860e23df31c942b2bc0c3412b761a4dcef25730" translate="yes" xml:space="preserve">
          <source>The start function required by &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 所需的启动函数。</target>
        </trans-unit>
        <trans-unit id="27f87c72bb318d024045b5c43b6afc31f6ec794d" translate="yes" xml:space="preserve">
          <source>The start function should use the &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; and/or &lt;code&gt;Config&lt;/code&gt; to select and return an appropriate list of local IP addresses. In the connecting case, the local address list can instead be communicated in a &lt;code&gt;connected&lt;/code&gt; message (see &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; below) following connection establishment. In either case, the local address list is used to populate &lt;code&gt;Host-IP-Address&lt;/code&gt; AVPs in outgoing capabilities exchange messages if &lt;code&gt;Host-IP-Address&lt;/code&gt; is unspecified.</source>
          <target state="translated">启动功能应使用 &lt;code&gt;Svc&lt;/code&gt; 和/或 &lt;code&gt;Config&lt;/code&gt; 中的&amp;ldquo; &lt;code&gt;Host-IP-Address&lt;/code&gt; 列表来选择并返回适当的本地IP地址列表。在连接的情况下，可以在建立 &lt;code&gt;connected&lt;/code&gt; 后以连接的消息（请参见下面的 &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; ）传达本地地址列表。在这两种情况下，如果未指定 &lt;code&gt;Host-IP-Address&lt;/code&gt; ，则本地地址列表都用于在传出功能交换消息中填充 &lt;code&gt;Host-IP-Address&lt;/code&gt; AVP 。</target>
        </trans-unit>
        <trans-unit id="b96af49834b8af2976c21508cd71a9002ce8721b" translate="yes" xml:space="preserve">
          <source>The start of a sequence of fragmented messages looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cef6600c64628b5df747acb2766fd1cbe1d3b19" translate="yes" xml:space="preserve">
          <source>The start phases are defined by the application specification key &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt;. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</source>
          <target state="translated">起始阶段由应用程序规范键 &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt; 。对于包含的应用程序，一组阶段必须是为包含的应用程序定义的一组阶段的子集。</target>
        </trans-unit>
        <trans-unit id="7acb8d9625f3baf5a2f8a4a89f3e914252275eb8" translate="yes" xml:space="preserve">
          <source>The start program must call &lt;code&gt;run_erl&lt;/code&gt; as shown below. It must also take an optional parameter, which defaults to &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">启动程序必须调用 &lt;code&gt;run_erl&lt;/code&gt; ，如下所示。它还必须带有一个可选参数，默认为 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d982b4c5fe8008df5043a1839f9425b5cc9bde4b" translate="yes" xml:space="preserve">
          <source>The starting distribution header is very similar to a non-fragmented distribution header. The atom cache works the same as for normal distribution header and is the same for the entire sequence. The additional fields added are the sequence id and fragment id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dadcd9880753a230e08e39eb7ab7929eb5a6e0c2" translate="yes" xml:space="preserve">
          <source>The startup procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory is referred to as the Mnesia directory. Mnesia can also be started on disc-less nodes. For more information about disc-less nodes, see &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">一组Mnesia节点的启动过程是一个相当复杂的操作。Mnesia系统由一组节点组成，Mnesia在所有参与的节点上本地启动。通常，每个节点都有一个写入所有Mnesia文件的目录。此目录称为Mnesia目录。Mnesia也可以在无盘节点上启动。有关 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 节点的更多信息，请参见mnesia：create_schema / 1和《用户指南》。</target>
        </trans-unit>
        <trans-unit id="9ec6e88891409b6ff8f9a27843da0963ec7c3164" translate="yes" xml:space="preserve">
          <source>The state can be any term and the callback function &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; is used for all states.</source>
          <target state="translated">状态可以是任何术语，并且回调函数 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 用于所有状态。</target>
        </trans-unit>
        <trans-unit id="f731d5aeffad554f9b59f5b6251d4203c254e6c3" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; and the event dependent &lt;code&gt;EventContent&lt;/code&gt;, both described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt;Event Types and Event Content&lt;/a&gt;&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f821816af50887b3f025a4e6599280206657b6" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt;, the event dependent &lt;code&gt;EventContent&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">状态可以是函数本身的名称，也可以是其参数。其他参数是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt; 一节中描述的 &lt;code&gt;EventType&lt;/code&gt; ，事件相关的 &lt;code&gt;EventContent&lt;/code&gt; 和当前服务器 &lt;code&gt;Data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9426ff2ed56deac331065c555f73deceea5d2d1f" translate="yes" xml:space="preserve">
          <source>The state must be of type &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; and one callback function per state, that is, &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;, is used.</source>
          <target state="translated">该状态必须为 &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; 类型，并且每个状态使用一个回调函数，即 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d13d42182a76700706e21237d549fc59709fd9b9" translate="yes" xml:space="preserve">
          <source>The state of the handler.</source>
          <target state="translated">处理器的状态。</target>
        </trans-unit>
        <trans-unit id="15825c6d947625e874b105c1baf6a684fccb64cc" translate="yes" xml:space="preserve">
          <source>The state of the process. This can be one of the following:</source>
          <target state="translated">进程的状态。可以是以下几种情况之一:</target>
        </trans-unit>
        <trans-unit id="289e59e1fe9a8e03ffb9d797627caef032453480" translate="yes" xml:space="preserve">
          <source>The state returned from each call of &lt;code&gt;Function&lt;/code&gt; is passed to the next call, even if the next call is to format a message from another log file.</source>
          <target state="translated">即使下一次调用是格式化另一个日志文件中的消息，从 &lt;code&gt;Function&lt;/code&gt; 的每次调用返回的状态也会传递到下一个调用。</target>
        </trans-unit>
        <trans-unit id="dd050ef7cc16c451eba6404d640a1ee02e6c6b42" translate="yes" xml:space="preserve">
          <source>The state returned from this function can not be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="translated">与其他 &lt;code&gt;rand&lt;/code&gt; 函数一样，此函数返回的状态不能用于获取可重现的随机序列，因为可重现性与密码安全性不匹配。</target>
        </trans-unit>
        <trans-unit id="be5d6f18be3b614032f33a0c6531accfee883ec3" translate="yes" xml:space="preserve">
          <source>The state returned from this function cannot be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e921cfa26002be9bbe7c6ea7a1998649c34a25f8" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae0626bf69d79a71c33c9da2c9ae7fb12888d7" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt; 时指定的状态。跟踪器状态是一个不变的值，该值传递给 &lt;code&gt;erl_tracer&lt;/code&gt; 回调，并且包含生成跟踪事件所需的所有数据。</target>
        </trans-unit>
        <trans-unit id="1ab345b32e922b70cc7799981ef1e76b747d4f17" translate="yes" xml:space="preserve">
          <source>The state.</source>
          <target state="translated">国家。</target>
        </trans-unit>
        <trans-unit id="43d74fe2df87f64ba71d3e82fa6cf8b2cdbfe68c" translate="yes" xml:space="preserve">
          <source>The status bar at the bottom of the window shows a warning if the currently loaded dump is truncated.</source>
          <target state="translated">如果当前加载的转储被截断,窗口底部的状态栏会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="f7d04e6ac2947e96673758e3c7124714a10992b8" translate="yes" xml:space="preserve">
          <source>The status of a module can be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23fa2a9a44b4e044dab676b8f152e4bf3708f35" translate="yes" xml:space="preserve">
          <source>The status of a request. Coresponds to the &lt;code&gt;SSH_MSG_CHANNEL_SUCCESS&lt;/code&gt; and &lt;code&gt;SSH_MSG_CHANNEL_FAILURE&lt;/code&gt; values in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.4&quot;&gt;RFC 4254, Section 5.4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb7334448d68c19546b3da05bde0756339f62d8" translate="yes" xml:space="preserve">
          <source>The status of a subgroup can be returned (&lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;failed&lt;/code&gt;), to affect the execution of the group on the level above. This is accomplished by, in &lt;code&gt;end_per_group/2&lt;/code&gt;, looking up the value of &lt;code&gt;tc_group_properties&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list and checking the result of the test cases in the group. If status &lt;code&gt;failed&lt;/code&gt; is to be returned from the group as a result, &lt;code&gt;end_per_group/2&lt;/code&gt; is to return the value &lt;code&gt;{return_group_result,failed}&lt;/code&gt;. The status of a subgroup is taken into account by &lt;code&gt;Common Test&lt;/code&gt; when evaluating if execution of a group is to be repeated or not (unless the basic &lt;code&gt;repeat&lt;/code&gt; property is used).</source>
          <target state="translated">可以返回子组的状态（&amp;ldquo; &lt;code&gt;ok&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;failed&lt;/code&gt; ），以影响上一级的组执行。这是通过在 &lt;code&gt;end_per_group/2&lt;/code&gt; 中在 &lt;code&gt;Config&lt;/code&gt; 列表中 &lt;code&gt;tc_group_properties&lt;/code&gt; 的值并检查组中测试用例的结果来完成的。如果要从组返回状态 &lt;code&gt;failed&lt;/code&gt; ，则 &lt;code&gt;end_per_group/2&lt;/code&gt; 将返回值 &lt;code&gt;{return_group_result,failed}&lt;/code&gt; 。在评估是否要重复执行某个组时（除非使用基本的 &lt;code&gt;repeat&lt;/code&gt; 属性）， &lt;code&gt;Common Test&lt;/code&gt; 会考虑子组的状态。</target>
        </trans-unit>
        <trans-unit id="b85c37fec76de27c56e3406adaafa6e8b1d27921" translate="yes" xml:space="preserve">
          <source>The status of a test case explicitly skipped in any of the ways described in section &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例的状态以&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt; 一节中描述的任何方式明确地跳过了。</target>
        </trans-unit>
        <trans-unit id="96f8f991cb18b753714d9a9e860678595a4a90ad" translate="yes" xml:space="preserve">
          <source>The status value for a nested subgroup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae5f35d675d1272e78fb3eaf4d81a316518f52b" translate="yes" xml:space="preserve">
          <source>The step functionality can be used together with flag/option &lt;code&gt;suite&lt;/code&gt; and &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt;, but not together with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">step功能可以与flag / option &lt;code&gt;suite&lt;/code&gt; 和 &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt; 一起使用，但不能与 &lt;code&gt;dir&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="23a47861a1df8e95627b42341a8487a2338f8876" translate="yes" xml:space="preserve">
          <source>The stop callback was called directly by &lt;code&gt;enif_select&lt;/code&gt;.</source>
          <target state="translated">stop回调由 &lt;code&gt;enif_select&lt;/code&gt; 直接调用。</target>
        </trans-unit>
        <trans-unit id="eff8dcd2a113b22b62950f59f611b3549632ee05" translate="yes" xml:space="preserve">
          <source>The stop callback was scheduled to run on some other thread or later by this thread.</source>
          <target state="translated">停止回调被这个线程安排在其他线程或稍后运行。</target>
        </trans-unit>
        <trans-unit id="6eb9b8c23b1b206be09c84ebb2950996bdcd33b8" translate="yes" xml:space="preserve">
          <source>The storage engine must call &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; and &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt;. See the OpenSSL cryptolib's &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存储引擎必须调用 &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; 和 &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt; 。请参阅OpenSSL cryptolib的 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f1ee5838e32832bdcc704cd56398a34eb2a5f6f" translate="yes" xml:space="preserve">
          <source>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</source>
          <target state="translated">存储类型被保留下来。例如,从一个节点移出的RAM表在新节点上仍然是RAM。在表被移动时,其他事务仍然可以在表中进行读写。</target>
        </trans-unit>
        <trans-unit id="29dd2c34d1090a0d800c2e247d0fc176342cf1f0" translate="yes" xml:space="preserve">
          <source>The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first &lt;code&gt;next_event&lt;/code&gt; in the containing list becomes the first to process.</source>
          <target state="translated">存储的事件将在任何已排队事件之前插入队列中，作为下一个要处理的事件。这些存储事件的顺序得以保留，因此包含列表中的第一个 &lt;code&gt;next_event&lt;/code&gt; 成为第一个要处理的事件。</target>
        </trans-unit>
        <trans-unit id="c05a53cb68134dabc5d7bae05169ae1a11647b27" translate="yes" xml:space="preserve">
          <source>The stream hasn't been initialized, eg. if &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; wasn't called prior to a call to &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">流尚未初始化，例如。如果 &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; 以前未在呼叫之前被调用到 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a185e0a14d968eac368fafa4955a9485714c6b7e" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt; set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6455104e94ea1d2cc707927b01ebea3a44bfd27f" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="translated">流由不受控制的进程使用。如果需要将流传输到其他进程，请使用 &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e2fdb4e651b9aa41fcc3bc6966fd38ca9895ed9" translate="yes" xml:space="preserve">
          <source>The string is copied to &lt;code&gt;p&lt;/code&gt;, and enough space must be allocated. The returned string is &lt;code&gt;NULL&lt;/code&gt;-terminated, so you must add an extra byte to the memory requirement.</source>
          <target state="translated">字符串被复制到 &lt;code&gt;p&lt;/code&gt; ，并且必须分配足够的空间。返回的字符串以 &lt;code&gt;NULL&lt;/code&gt; 终止，因此您必须在内存要求中添加一个额外的字节。</target>
        </trans-unit>
        <trans-unit id="68785b1bbdb54c599efe5a2a41d523ae7b013997" translate="yes" xml:space="preserve">
          <source>The string length of &quot;&amp;szlig;&amp;uarr;e̊&quot; is 3, even though it is represented by the codepoints &lt;code&gt;[223,8593,101,778]&lt;/code&gt; or the UTF-8 binary &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">即使由代码点 &lt;code&gt;[223,8593,101,778]&lt;/code&gt; 或UTF-8二进制 &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt; 表示，&amp;ldquo;&amp;szlig;&amp;uarr;&amp;eacute;&amp;rdquo;的字符串长度也为3 。</target>
        </trans-unit>
        <trans-unit id="4cf40fddbed63f7ac0d755d714db5efcb0dab3f9" translate="yes" xml:space="preserve">
          <source>The string the daemon will present to a connecting peer initially. The default value is &quot;Erlang/VSN&quot; where VSN is the ssh application version number.</source>
          <target state="translated">守护进程最初将向连接的对等体提供的字符串,默认值是 &quot;Erlang/VSN&quot;,其中VSN是ssh应用程序的版本号。默认值是 &quot;Erlang/VSN&quot;,其中VSN是ssh应用程序的版本号。</target>
        </trans-unit>
        <trans-unit id="36753c090f707fe68109d16ad9e5e9da7b79ac27" translate="yes" xml:space="preserve">
          <source>The string was read, but more input is needed to complete the original format string. &lt;code&gt;RestFormat&lt;/code&gt; is the remaining format string, &lt;code&gt;Nchars&lt;/code&gt; is the number of characters scanned, and &lt;code&gt;InputStack&lt;/code&gt; is the reversed list of inputs matched up to that point.</source>
          <target state="translated">已读取该字符串，但需要更多输入才能完成原始格式的字符串。 &lt;code&gt;RestFormat&lt;/code&gt; 是剩余的格式字符串， &lt;code&gt;Nchars&lt;/code&gt; 是扫描的字符数，InputStack是 &lt;code&gt;InputStack&lt;/code&gt; 匹配的输入的反向列表。</target>
        </trans-unit>
        <trans-unit id="6cf01db782c53881c8e9b381ef1af37e91bea8ec" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the input characters not used.</source>
          <target state="translated">字符串被读取。 &lt;code&gt;InputList&lt;/code&gt; 是成功匹配和读取的项目的列表，而 &lt;code&gt;LeftOverChars&lt;/code&gt; 是未使用的输入字符。</target>
        </trans-unit>
        <trans-unit id="45cb7749daf0319866610d1f7a6f2fda868e24e9" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the remaining characters.</source>
          <target state="translated">字符串被读取。 &lt;code&gt;InputList&lt;/code&gt; 是成功匹配和读取的项目的列表，而 &lt;code&gt;LeftOverChars&lt;/code&gt; 是剩余的字符。</target>
        </trans-unit>
        <trans-unit id="7023fc710fcbee2ee1b2d0076f2bbb73fe92a4c8" translate="yes" xml:space="preserve">
          <source>The structure defines six tables in the database. In &lt;code&gt;Mnesia&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. &lt;code&gt;Name&lt;/code&gt; is the table name.</source>
          <target state="translated">该结构在数据库中定义了六个表。在 &lt;code&gt;Mnesia&lt;/code&gt; 中，函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 创建表。 &lt;code&gt;Name&lt;/code&gt; 是表名称。</target>
        </trans-unit>
        <trans-unit id="39d9e3d6533e72d537d969467d83db3f839ba80c" translate="yes" xml:space="preserve">
          <source>The structured types of ASN.1 are constructed from other types in a manner similar to the concepts of array and struct in C.</source>
          <target state="translated">ASN.1的结构化类型是以类似于C语言中数组和结构体概念的方式从其他类型中构造出来的。</target>
        </trans-unit>
        <trans-unit id="3d28e19e96e7591f2c1e234739ca3d285e1425a0" translate="yes" xml:space="preserve">
          <source>The structured types previously described can have other named types as their components. The general syntax to assign a value to component &lt;code&gt;C&lt;/code&gt; of a named ASN.1 type &lt;code&gt;T&lt;/code&gt; in Erlang is the record syntax &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt;. Here &lt;code&gt;Value&lt;/code&gt; can be a value of yet another type &lt;code&gt;T2&lt;/code&gt;, for example:</source>
          <target state="translated">先前描述的结构化类型可以将其他命名类型作为其组件。将值分配给Erlang中名为ASN.1类型 &lt;code&gt;T&lt;/code&gt; 的组件 &lt;code&gt;C&lt;/code&gt; 的值的通用语法是记录语法 &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt; 。这里的 &lt;code&gt;Value&lt;/code&gt; 可以是另一个 &lt;code&gt;T2&lt;/code&gt; 类型的值，例如：</target>
        </trans-unit>
        <trans-unit id="0fc0372505592d800b784db4902cf9621fae67f0" translate="yes" xml:space="preserve">
          <source>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; The syntax is as follows:</source>
          <target state="translated">订阅功能可激活事件的订阅。事件作为消息传递给评估功能 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 的过程，语法如下：</target>
        </trans-unit>
        <trans-unit id="c6fc9553c48dee56909efc052afcae5e3f5e6f87" translate="yes" xml:space="preserve">
          <source>The subset of calls from any of the vertices.</source>
          <target state="translated">来自任何一个顶点的调用子集。</target>
        </trans-unit>
        <trans-unit id="5f5b8c212a6fee019c36df2950bd77268424ff70" translate="yes" xml:space="preserve">
          <source>The subset of calls to and from any of the vertices. For all sets of calls &lt;code&gt;CS&lt;/code&gt; and all sets of vertices &lt;code&gt;VS&lt;/code&gt;, &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; is equivalent to &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt;.</source>
          <target state="translated">呼入或呼出任何顶点的子集。对于所有调用 &lt;code&gt;CS&lt;/code&gt; 和所有顶点 &lt;code&gt;VS&lt;/code&gt; ， &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; 相当于 &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5085549ad982bc38493bd15cfb61ace15049e68" translate="yes" xml:space="preserve">
          <source>The subset of calls to any of the vertices.</source>
          <target state="translated">对任何一个顶点的调用的子集。</target>
        </trans-unit>
        <trans-unit id="3cacc7a2a8051e8a0c0ddaf8749a37e9f9e9ee95" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt; Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe87376a37704db2bf21986e270c17fe93f1cb0" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">子系统可以使用生成的密钥在主机&lt;strong&gt;tarlop&lt;/strong&gt;上 &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt; ，如运行Erlang ssh守护程序一节中所述：</target>
        </trans-unit>
        <trans-unit id="e7163b547fafca1e1a01c6c85101dafd95545463" translate="yes" xml:space="preserve">
          <source>The subtype constraint (&lt;code&gt;CONTAINING&lt;/code&gt;/&lt;code&gt;ENCODED BY&lt;/code&gt;) to constrain the content of an octet string or a bit string is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">编译时会分析用于约束八位位组字符串或位字符串的内容的子类型约束（ &lt;code&gt;CONTAINING&lt;/code&gt; / &lt;code&gt;ENCODED BY&lt;/code&gt; ），但不会采取进一步的措施。此约束不是PER可见约束。</target>
        </trans-unit>
        <trans-unit id="996c8474dfc5442a02a67e994d403bba3cebf442" translate="yes" xml:space="preserve">
          <source>The subtype constraint by regular expressions (&lt;code&gt;PATTERN&lt;/code&gt;) for character string types is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">编译时会分析正则表达式（ &lt;code&gt;PATTERN&lt;/code&gt; ）对字符串类型的子类型约束，但不会采取进一步的措施。此约束不是PER可见约束。</target>
        </trans-unit>
        <trans-unit id="449b6a9e34717e9034f068e9ddd7557ac6068822" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;FuncCallCount&lt;/code&gt; values for all functions in module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mod&lt;/code&gt; 模块中所有函数的 &lt;code&gt;FuncCallCount&lt;/code&gt; 值的总和。</target>
        </trans-unit>
        <trans-unit id="3234d4076f0843a2b33750a12acc0b2c6ea1ad8f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;ModCallCount&lt;/code&gt; values for all modules concerned in &lt;code&gt;ModAnalysisList&lt;/code&gt;.</source>
          <target state="translated">总和 &lt;code&gt;ModCallCount&lt;/code&gt; 所有有关模块值 &lt;code&gt;ModAnalysisList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7d6e1d3697888bda0178100688b0ec34a104aff" translate="yes" xml:space="preserve">
          <source>The sum of all memory categories.</source>
          <target state="translated">所有记忆类别的总和。</target>
        </trans-unit>
        <trans-unit id="ff0037c4e027cabbd2193a3640bbe8630c8ea4e3" translate="yes" xml:space="preserve">
          <source>The sum of all off-heap binaries allocated.</source>
          <target state="translated">分配的所有离堆二进制文件的总和。</target>
        </trans-unit>
        <trans-unit id="b154828ab69194ef3277c5a0a09ca37fe5a5d84e" translate="yes" xml:space="preserve">
          <source>The sum of all process memory used.</source>
          <target state="translated">使用的所有进程内存的总和。</target>
        </trans-unit>
        <trans-unit id="caa888756fcb43497a5008a81fd1856a0639ea65" translate="yes" xml:space="preserve">
          <source>The super carrier feature was introduced in OTP R16B03. It is enabled with command line option +MMscs &amp;lt;size in Mb&amp;gt; and can be configured with other options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0c117fe89fdcf6ec7fbdc8b7f9539c319a847f" translate="yes" xml:space="preserve">
          <source>The super carrier thus contains two areas. One area for MBCs growing from the bottom and up. And one area for SBCs growing from the top and down. Like a process with a heap and a stack growing towards each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dab01c88ded1b7b32e51ef73e1252818de000b" translate="yes" xml:space="preserve">
          <source>The supervision tree is a hierarchical arrangement of code into supervisors and workers, which makes it possible to design and program fault-tolerant software.</source>
          <target state="translated">监督树是将代码按层次排列成主管和工人,这使得设计和编程容错软件成为可能。</target>
        </trans-unit>
        <trans-unit id="2b52420c5f524763cf64a935f578714dd96d159c" translate="yes" xml:space="preserve">
          <source>The supervisor behaviour supports changing the internal state, that is, changing the restart strategy and maximum restart frequency properties, as well as changing the existing child specifications.</source>
          <target state="translated">主管行为支持改变内部状态,即改变重启策略和最大重启频率属性,以及改变现有的子规范。</target>
        </trans-unit>
        <trans-unit id="cffb4f2e0dfb75d9604922d437c1a8dd8826e6a0" translate="yes" xml:space="preserve">
          <source>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">监督器负责启动、停止和监控它的子进程。监督者的基本思想是,它必须在必要时通过重新启动子进程来保持其活力。</target>
        </trans-unit>
        <trans-unit id="768e22d6442b06516d91f5426c41a68d034c3f04" translate="yes" xml:space="preserve">
          <source>The supervisor must be registered as &lt;code&gt;ch_sup&lt;/code&gt; for the script to work. If the supervisor is not registered, it cannot be accessed directly from the script. Instead a help function that finds the pid of the supervisor and calls &lt;code&gt;supervisor:restart_child&lt;/code&gt;, and so on, must be written. This function is then to be called from the script using the &lt;code&gt;apply&lt;/code&gt; instruction.</source>
          <target state="translated">主管必须注册为 &lt;code&gt;ch_sup&lt;/code&gt; ，脚本才能正常工作。如果主管未注册，则不能直接从脚本中访问它。相反，必须编写一个帮助函数，该函数查找主管的pid并调用 &lt;code&gt;supervisor:restart_child&lt;/code&gt; 等。然后，使用 &lt;code&gt;apply&lt;/code&gt; 指令从脚本中调用此函数。</target>
        </trans-unit>
        <trans-unit id="dd784bb324ef894ad782bd6fc54c8cbffbd00c9c" translate="yes" xml:space="preserve">
          <source>The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows:</source>
          <target state="translated">主管属性是由主管标志来定义的。监管人标志的类型定义如下。</target>
        </trans-unit>
        <trans-unit id="445d5aae8f507ca020cd700c1e982027b7aa04d5" translate="yes" xml:space="preserve">
          <source>The supervisor then starts all its child processes according to the child specifications in the start specification. In this case there is one child process, &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">然后，主管根据启动规范中的子规范启动其所有子进程。在这种情况下，有一个子进程 &lt;code&gt;ch3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1ea33c0638456c050fb5c1069b48715bb9e4c7a" translate="yes" xml:space="preserve">
          <source>The supervisor tree of an included application is started as part of the supervisor tree of the including application. If there is a need for synchronization between processes in the including and included applications, this can be achieved by using &lt;strong&gt;start phases&lt;/strong&gt;.</source>
          <target state="translated">作为包含应用程序的主管树的一部分，将启动包含应用程序的主管树。如果需要在包含应用程序和包含应用程序中的进程之间进行同步，则可以通过使用&lt;strong&gt;启动阶段&lt;/strong&gt;来实现。</target>
        </trans-unit>
        <trans-unit id="a588b6125bf699dd160cdf7a903456eed3b8cbe9" translate="yes" xml:space="preserve">
          <source>The supervisors have a built-in mechanism to limit the number of restarts which can occur in a given time interval. This is specified by the two keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">主管具有内置机制，可以限制在给定时间间隔内可能发生的重新启动次数。这由回调函数 &lt;code&gt;init&lt;/code&gt; 返回的主管标志映射中的两个键 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 指定：</target>
        </trans-unit>
        <trans-unit id="2b2633e4167b1433781a2f1a62c27832d676f8d6" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;Reason&lt;/code&gt; becomes the exit reason for the server process. Default Any &lt;code&gt;Reason&lt;/code&gt; other than &lt;code&gt;kill&lt;/code&gt; sends a request to the server and waits for it to clean up, reply and exit. If &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;kill&lt;/code&gt;, the server is bluntly killed.</source>
          <target state="translated">提供的 &lt;code&gt;Reason&lt;/code&gt; 将成为服务器进程的退出原因。缺省值除 &lt;code&gt;kill&lt;/code&gt; 以外的任何其他 &lt;code&gt;Reason&lt;/code&gt; 都会向服务器发送请求，并等待其清理，回复并退出。如果 &lt;code&gt;Reason&lt;/code&gt; 为 &lt;code&gt;kill&lt;/code&gt; ，则服务器将被直接杀死。</target>
        </trans-unit>
        <trans-unit id="96f30a73bfb2b83438049030688c67e96198fa91" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. It is released before it is ready to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release.</source>
          <target state="translated">对从存档文件加载代码的支持是试验性的。它是在获得早期反馈之前发布的。文件格式、语义、接口等可以在未来的版本中进行修改。</target>
        </trans-unit>
        <trans-unit id="7908060a0b898a45469fbc25ab16112e1c77d124" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. The purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The function &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; and flag &lt;code&gt;-code_path_choice&lt;/code&gt; are also experimental.</source>
          <target state="translated">从存档文件加载代码的支持是实验性的。在准备就绪之前将其释放的目的是获得早期反馈。在将来的版本中，可以更改文件格式，语义，接口等。函数 &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; 和标志 &lt;code&gt;-code_path_choice&lt;/code&gt; 也是实验性的。</target>
        </trans-unit>
        <trans-unit id="0fc1d82ce90810c32581e8a0920c335e0c517632" translate="yes" xml:space="preserve">
          <source>The support for loading of code from archive files is experimental. The only purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The &lt;code&gt;-code_path_choice&lt;/code&gt; flag is also experimental.</source>
          <target state="translated">从存档文件加载代码的支持是实验性的。在准备就绪之前将其释放的唯一目的是获得早期反馈。在将来的版本中，可以更改文件格式，语义，接口等。该 &lt;code&gt;-code_path_choice&lt;/code&gt; 标志也是实验。</target>
        </trans-unit>
        <trans-unit id="e2394cc20beed2954b20caec09868b8789fdcf8c" translate="yes" xml:space="preserve">
          <source>The support for sequential tracing provided by Trace Tool Builder includes the following:</source>
          <target state="translated">Trace Tool Builder 提供的顺序跟踪支持包括以下内容。</target>
        </trans-unit>
        <trans-unit id="6228d25d9b25f4927da788e40437ce4f4ff23407" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;'-&amp;gt;'&lt;/code&gt;, and &lt;code&gt;':'&lt;/code&gt; have to be treated in a special way, as they are meta symbols of the grammar notation, as well as terminal symbols of the Yecc grammar.</source>
          <target state="translated">符号 &lt;code&gt;'-&amp;gt;'&lt;/code&gt; 和 &lt;code&gt;':'&lt;/code&gt; 必须以特殊方式处理，因为它们既是语法符号的元符号，又是Yecc语法的末尾符号。</target>
        </trans-unit>
        <trans-unit id="b5b1fca95a16b28d8128e58b5512a0179363f6cf" translate="yes" xml:space="preserve">
          <source>The symbols in front of the application names are intended to describe the status of the application. There are error and warning symbols to signalize that there is something which needs attention. The tick symbol means that the application is included or derived and no problem has been detected. The cross symbol means that the application is excluded or available and no problem has been detected. Applications with error symbols are listed first in each category and are followed by the warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">应用程序名称前的符号旨在描述应用程序的状态。还有错误和警告符号,表示有需要注意的地方。勾号表示应用程序被包含或派生,并且没有发现问题。十字符号表示应用程序被排除或可用,并且没有发现问题。每类应用中首先列出有错误符号的应用,后面是警告,最后是正常的应用(打勾和交叉)。</target>
        </trans-unit>
        <trans-unit id="4ff1d477dc7a2e1cb7c0f348638a12a2059b2005" translate="yes" xml:space="preserve">
          <source>The symbols in front of the module names are intended to describe the status of the module. There are error and and warning symbols to signalize that there is something that needs attention. The tick symbol means that the module is included or derived and no problem has been detected. The cross symbol means that the module is excluded or available and no problem has been detected. Modules with error symbols are listed first in each category and are followed by warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">模块名称前面的符号是用来描述模块的状态。有错误符号和警告符号,表示有需要注意的地方。勾号表示该模块被包含或派生,没有发现问题。十字符号表示该模块被排除或可用,没有发现问题。带有错误符号的模块在每个类别中首先列出,后面是警告,最后是正常的警告(tick和cross)。</target>
        </trans-unit>
        <trans-unit id="9cf67be71d81d661199fd8c3ef66c9bc2a23e743" translate="yes" xml:space="preserve">
          <source>The synchronous request &lt;code&gt;alloc()&lt;/code&gt; is implemented using &lt;code&gt;gen_server:call/2&lt;/code&gt;:</source>
          <target state="translated">同步请求 &lt;code&gt;alloc()&lt;/code&gt; 使用 &lt;code&gt;gen_server:call/2&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="63eb54580b86c06f3268ea4e7b5bcac96de253d8" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material.</source>
          <target state="translated">PCRE支持的正则表达式的语法和语义将在下面的章节中详细介绍。Perl的正则表达式在它自己的文档中也有介绍,一般的正则表达式在很多书中都有介绍,有些书中还有大量的例子。Jeffrey Friedl的《掌握正则表达式》(O'Reilly出版)对正则表达式的介绍非常详细。这篇关于PCRE正则表达式的描述是作为参考资料。</target>
        </trans-unit>
        <trans-unit id="d795ae62867dbcf3f58c156eb06c595d167b51ae" translate="yes" xml:space="preserve">
          <source>The syntax for an external generic instruction is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9bb02b3f5ad3403931d50bf02d3305e9416e42" translate="yes" xml:space="preserve">
          <source>The syntax for an internal generic instruction is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7e6289b406769100c4fe1cdd3bffd156db1884" translate="yes" xml:space="preserve">
          <source>The syntax highlighting can be activated from the Erlang menu. There are four different alternatives:</source>
          <target state="translated">语法高亮可以从Erlang菜单中激活。有四种不同的选择。</target>
        </trans-unit>
        <trans-unit id="817a7b6234953ff285a5cf26b3d3913052cb1f96" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows (requires a list within the groups list):</source>
          <target state="translated">Erlang shell中的语法如下(需要在group列表中加入一个列表)。</target>
        </trans-unit>
        <trans-unit id="c11a6d8aa6d68bd5c6fc23a6b8b784283b982fbc" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows:</source>
          <target state="translated">Erlang shell中的语法如下。</target>
        </trans-unit>
        <trans-unit id="21b1becf4be6592870e0896862b9b302a4959623" translate="yes" xml:space="preserve">
          <source>The syntax of  &lt;strong id=&quot;variable&quot;&gt;variables&lt;/strong&gt; is simple:</source>
          <target state="translated">&lt;strong id=&quot;variable&quot;&gt;变量&lt;/strong&gt;的语法 很简单：</target>
        </trans-unit>
        <trans-unit id="f3c5861c6322d86304cb4290ee33a8caf450460f" translate="yes" xml:space="preserve">
          <source>The syntax of Erlang tokens allow the use of the full ISO-8859-1 (Latin-1) character set. This is noticeable in the following ways:</source>
          <target state="translated">Erlang tokens的语法允许使用完整的ISO-8859-1(Latin-1)字符集。这在以下几个方面很明显。</target>
        </trans-unit>
        <trans-unit id="094c638d5ce58e342260cad1fbc3fff0f35b6a88" translate="yes" xml:space="preserve">
          <source>The syntax of each file is similar to C code. In fact, most of the contents &lt;strong&gt;is&lt;/strong&gt; C code, interspersed with macro invocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8d5f699e53e1bdc1770774109fbc1b5599f479" translate="yes" xml:space="preserve">
          <source>The system call failed to add the event object to the poll set.</source>
          <target state="translated">系统调用失败,未能将事件对象添加到投票集。</target>
        </trans-unit>
        <trans-unit id="401fca03bc6c302beb7da6e4fb8eca70f288ed7b" translate="yes" xml:space="preserve">
          <source>The system can become inconsistent as a result of a power failure. The UNIX feature &lt;code&gt;fsck&lt;/code&gt; can possibly repair the file system, but there is no guarantee that the file content is consistent.</source>
          <target state="translated">由于电源故障，系统可能会变得不一致。UNIX功能 &lt;code&gt;fsck&lt;/code&gt; 可能可以修复文件系统，但是不能保证文件内容是一致的。</target>
        </trans-unit>
        <trans-unit id="11ac012ee2a6049d1c81dbfe5e5bcc868023bccc" translate="yes" xml:space="preserve">
          <source>The system configuration files for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;cp3@cave&lt;/code&gt; are identical, except for the list of mandatory nodes, which is to be &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; for &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cp2@cave&lt;/code&gt; 和 &lt;code&gt;cp3@cave&lt;/code&gt; 的系统配置文件是相同的，除了必需节点的列表，对于 &lt;code&gt;cp2@cave&lt;/code&gt; 和 &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; cp1 @ cave &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; ，它们是[cp1 @ cave，cp3 @ cave]。对于 &lt;code&gt;cp3@cave&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88a86df323fb5ec0c1b444523d82be4cff548c59" translate="yes" xml:space="preserve">
          <source>The system configuration is to be called &lt;code&gt;Name.config&lt;/code&gt; and Erlang is to be started with the command-line argument &lt;code&gt;-config Name&lt;/code&gt;. For details, see the &lt;code&gt;config(4)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">系统配置将称为 &lt;code&gt;Name.config&lt;/code&gt; ,而Erlang将使用命令行参数 &lt;code&gt;-config Name&lt;/code&gt; 来启动。有关详细信息，请参见内核中的 &lt;code&gt;config(4)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9f6cd0cc01a1dae027af31ac2b3320efd5d91c8a" translate="yes" xml:space="preserve">
          <source>The system events are as follows:</source>
          <target state="translated">系统事件如下:</target>
        </trans-unit>
        <trans-unit id="40222a7fb3caf074645df66a48dca922ad535e5b" translate="yes" xml:space="preserve">
          <source>The system has run out of memory. &amp;lt;A&amp;gt; is the allocator that failed to allocate memory, &amp;lt;N&amp;gt; is the number of bytes that &amp;lt;A&amp;gt; tried to allocate, and &amp;lt;T&amp;gt; is the memory block type that the memory was needed for. The most common case is that a process stores huge amounts of data. In this case &amp;lt;T&amp;gt; is most often &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;old_heap&lt;/code&gt;, &lt;code&gt;heap_frag&lt;/code&gt;, or &lt;code&gt;binary&lt;/code&gt;. For more information on allocators, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统内存不足。&amp;lt;A&amp;gt;是分配内存失败的分配器，&amp;lt;N&amp;gt;是&amp;lt;A&amp;gt;尝试分配的字节数，而&amp;lt;T&amp;gt;是需要内存的内存块类型。最常见的情况是一个进程存储大量数据。在这种情况下，&amp;lt;T&amp;gt;通常是 &lt;code&gt;heap&lt;/code&gt; ， &lt;code&gt;old_heap&lt;/code&gt; ， &lt;code&gt;heap_frag&lt;/code&gt; 或 &lt;code&gt;binary&lt;/code&gt; 。有关分配器的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6876d9a2709d42d9bf8117946f6bf8730f5ef93a" translate="yes" xml:space="preserve">
          <source>The system information should be stored in a file called &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">系统信息应存储在名为 &lt;code&gt;standard.conf&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="b6783eebca0127687dc6f7166b232d99095419a8" translate="yes" xml:space="preserve">
          <source>The system is delivered as a Windows Installer executable. Get it from http://www.erlang.org/download.html</source>
          <target state="translated">该系统以Windows安装程序可执行文件的形式交付。从 http://www.erlang.org/download.html 获取。</target>
        </trans-unit>
        <trans-unit id="eede666990492464e7d117dc5860f19affbbfd3e" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0ed26a1f271e06db89ef0fba3d2b075b59188d" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started. The same &lt;code&gt;BootArgs&lt;/code&gt; are used again.</source>
          <target state="translated">系统将&lt;strong&gt;在&lt;/strong&gt;正在运行的Erlang节点&lt;strong&gt;内&lt;/strong&gt;重新启动，这意味着模拟器不会重新启动。顺利重新启动所有应用程序，卸载所有代码并关闭所有端口，然后以与最初启动相同的方式再次引导系统。再次使用相同的 &lt;code&gt;BootArgs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a035d0281caa4cfae8d815a43e248cd4f5e42d" translate="yes" xml:space="preserve">
          <source>The system keeps information about which versions are old and permanent in the files &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">系统在文件 &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; 和 &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt; 保留有关哪个版本旧且永久的信息。</target>
        </trans-unit>
        <trans-unit id="6da0e848ff2fa7a0109efc8207e6e2b2e7ad33b9" translate="yes" xml:space="preserve">
          <source>The system must be configured using only one system configuration file, called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">必须仅使用一个名为 &lt;code&gt;sys.config&lt;/code&gt; 的系统配置文件来配置系统。</target>
        </trans-unit>
        <trans-unit id="534f8510b4ab2486a116f82477cc86a51046615f" translate="yes" xml:space="preserve">
          <source>The system settings page is rather incomplete.</source>
          <target state="translated">系统设置页面比较不完整。</target>
        </trans-unit>
        <trans-unit id="b9d981657e3a5548cb7241507be1ea948d7f1448" translate="yes" xml:space="preserve">
          <source>The system tracer only receives those trace events that occur locally within the Erlang node. To get the whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system tracer on each involved node must be merged (offline).</source>
          <target state="translated">系统跟踪器只接收那些发生在本地的Erlang节点的跟踪事件。为了得到一个连续跟踪的全貌,涉及到许多Erlang节点上的进程,系统跟踪器在每个涉及到的节点上的输出必须被合并(离线)。</target>
        </trans-unit>
        <trans-unit id="d708a25f112a938c386e67dff885572e579436bd" translate="yes" xml:space="preserve">
          <source>The system version of the node from which the dump originates</source>
          <target state="translated">源于转储的节点的系统版本。</target>
        </trans-unit>
        <trans-unit id="bc82ebf34afcabbe0cf21d28525ebd613647d5a2" translate="yes" xml:space="preserve">
          <source>The system window consists of four main pages (tabs):</source>
          <target state="translated">系统窗口由四个主要页面(标签)组成。</target>
        </trans-unit>
        <trans-unit id="b7bde4446c570b77fe2a6f9c4779d3be956d8d0b" translate="yes" xml:space="preserve">
          <source>The system window is started with the function &lt;code&gt;reltool:start/1&lt;/code&gt;. At startup the tool will process all &lt;code&gt;beam&lt;/code&gt; files and &lt;code&gt;app&lt;/code&gt; files in order to find out dependencies between applications and their modules. Once all this information has been derived, it will be possible to explore the tool.</source>
          <target state="translated">使用功能 &lt;code&gt;reltool:start/1&lt;/code&gt; 启动系统窗口。在启动时，该工具将处理所有 &lt;code&gt;beam&lt;/code&gt; 文件和 &lt;code&gt;app&lt;/code&gt; 文件，以找出应用程序及其模块之间的依赖关系。一旦获得所有这些信息，便有可能探索该工具。</target>
        </trans-unit>
        <trans-unit id="041698f829edd5b26d5d0d6979109c4827078e80" translate="yes" xml:space="preserve">
          <source>The system writes the crash dump in the current directory of the emulator or in the file pointed out by the environment variable (whatever that means on the current operating system) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt;. For a crash dump to be written, a writable file system must be mounted.</source>
          <target state="translated">系统将故障转储写入仿真器的当前目录或环境变量指出的文件中（无论在当前操作系统上是什么） &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt; 。要写入故障转储，必须安装可写文件系统。</target>
        </trans-unit>
        <trans-unit id="279b6ca3b37adc0893d23faefa9739dedcc3dbfa" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;Tab&lt;/code&gt; must have an index on position &lt;code&gt;Pos&lt;/code&gt;.</source>
          <target state="translated">表格 &lt;code&gt;Tab&lt;/code&gt; 必须在位置 &lt;code&gt;Pos&lt;/code&gt; 上具有索引。</target>
        </trans-unit>
        <trans-unit id="3dc16fbae2468b67b551f7fca9afb369e0f25872" translate="yes" xml:space="preserve">
          <source>The table access rights.</source>
          <target state="translated">表的访问权限。</target>
        </trans-unit>
        <trans-unit id="4c50c3a237a03f8cc2707518e27535b691ad5345" translate="yes" xml:space="preserve">
          <source>The table below summarizes the diameter application's compliance with RFC 6733. Since the diameter application isn't a Diameter node on its own, compliance is strictly the responsibility of the user in many cases, diameter providing the means for the user to be compliant rather than being compliant on its own.</source>
          <target state="translated">下表总结了直径应用对RFC 6733的合规性。由于diameter应用本身并不是Diameter节点,所以在很多情况下,合规性严格来说是用户的责任,diameter为用户提供了合规的手段,而不是自己合规。</target>
        </trans-unit>
        <trans-unit id="074dbae85c16822f44b3981f3ee41b05515202d3" translate="yes" xml:space="preserve">
          <source>The table contains a 64-bit atomic variable of the last identifier used. Only the least significant bits will be used when actually creating the identifier. This identifier is where the search begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25afd1e5876ef9e8eeb6a3459a04948d4b88d14d" translate="yes" xml:space="preserve">
          <source>The table content is placed in a &lt;code&gt;.DCD&lt;/code&gt; file on the disc. When the &lt;code&gt;Mnesia&lt;/code&gt; system is started, the RAM table is initially loaded with data from its &lt;code&gt;.DCD&lt;/code&gt; file.</source>
          <target state="translated">表内容放置在光盘上的 &lt;code&gt;.DCD&lt;/code&gt; 文件中。当 &lt;code&gt;Mnesia&lt;/code&gt; 系统启动时，RAM表最初会加载来自其 &lt;code&gt;.DCD&lt;/code&gt; 文件的数据。</target>
        </trans-unit>
        <trans-unit id="1a0aa2d29620215b66b862b74a258da9f0952597" translate="yes" xml:space="preserve">
          <source>The table identifier.</source>
          <target state="translated">表的标识符。</target>
        </trans-unit>
        <trans-unit id="d6e8f6600b6898b285183c9a2efcd8e9919e547e" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;bag&lt;/code&gt; table, which can have many objects, but only one instance of each object, per key.</source>
          <target state="translated">该表是一个 &lt;code&gt;bag&lt;/code&gt; 表，每个键可以有许多对象，但每个对象只能有一个实例。</target>
        </trans-unit>
        <trans-unit id="1326636cb8d9d2c6e8abd48a67ecc64dc60e8dbf" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;duplicate_bag&lt;/code&gt; table, which can have many objects, including multiple copies of the same object, per key.</source>
          <target state="translated">该表是一个 &lt;code&gt;duplicate_bag&lt;/code&gt; 表，每个键可以有许多对象，包括同一对象的多个副本。</target>
        </trans-unit>
        <trans-unit id="f70ade515d71247538e9584965be02630fd1a515" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;ordered_set&lt;/code&gt; table: one key, one object, ordered in Erlang term order, which is the order implied by the &amp;lt; and &amp;gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the &lt;code&gt;ordered_set&lt;/code&gt; tables regard keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt;, not only when they match. This means that to an &lt;code&gt;ordered_set&lt;/code&gt; table, &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; and &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; are regarded as equal. This also means that the key used to lookup an element not necessarily &lt;strong&gt;matches&lt;/strong&gt; the key in the returned elements, if &lt;code&gt;float()&lt;/code&gt;'s and &lt;code&gt;integer()&lt;/code&gt;'s are mixed in keys of a table.</source>
          <target state="translated">该表是 &lt;code&gt;ordered_set&lt;/code&gt; 表：一个键，一个对象，按照Erlang术语顺序（即&amp;lt;和&amp;gt;运算符所隐含的顺序）进行排序。这种类型的表在某些情况下的行为与其他类型的表有些不同。最值得注意的是，在 &lt;code&gt;ordered_set&lt;/code&gt; 表把钥匙作为平等的，当他们&lt;strong&gt;比较平等的&lt;/strong&gt;，而不是只有当它们匹配。这意味着对于 &lt;code&gt;ordered_set&lt;/code&gt; 表， &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; 被视为相等。这也意味着，如果 &lt;code&gt;float()&lt;/code&gt; 和 &lt;code&gt;integer()&lt;/code&gt; 在一起，则用于查找元素的键不一定&lt;strong&gt;与&lt;/strong&gt;返回的元素&lt;strong&gt;中&lt;/strong&gt;的键&lt;strong&gt;匹配&lt;/strong&gt;。混合在表的键中。</target>
        </trans-unit>
        <trans-unit id="272d7513098b30b16e878b3eb48399c3327cbbea" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;set&lt;/code&gt; table: one key, one object, no order among objects. This is the default table type.</source>
          <target state="translated">该表是一个 &lt;code&gt;set&lt;/code&gt; 表：一个键，一个对象，对象之间没有顺序。这是默认表类型。</target>
        </trans-unit>
        <trans-unit id="b9f8a5943e8075893eb3b3474ba785f08fed2473" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;match/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;match/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="9881ec6398c8615af13073d22ceceab6e1d017fd" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match_object/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match_object/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;match_object/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;match_object/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="e2da56b6127d8f8b1f1475a198ead6fa8576cef3" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;select/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;select/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;select/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;select/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="a15b4f96977744e9f06d4a053061f2ae406c3cc5" translate="yes" xml:space="preserve">
          <source>The table is read or written in chunks of &lt;code&gt;?CHARS_PER_REC&lt;/code&gt;, overwriting when necessary. The implementation is clearly not efficient, it is just working.</source>
          <target state="translated">在 &lt;code&gt;?CHARS_PER_REC&lt;/code&gt; 的块中读取或写入表，必要时覆盖。实施显然效率不高，只是有效。</target>
        </trans-unit>
        <trans-unit id="216abe432d30c693518496ed41d4537b67851e03" translate="yes" xml:space="preserve">
          <source>The table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. Option &lt;code&gt;n_objects&lt;/code&gt; determines the number of objects returned (the third argument of &lt;code&gt;select/3&lt;/code&gt;); the default is to return &lt;code&gt;100&lt;/code&gt; objects at a time. The &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (the second argument of &lt;code&gt;select/3&lt;/code&gt;) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 遍历该表。选项 &lt;code&gt;n_objects&lt;/code&gt; 确定返回的对象数（ &lt;code&gt;select/3&lt;/code&gt; 的第三个参数）；默认值是一次返回 &lt;code&gt;100&lt;/code&gt; 个对象。的 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; （第二个参数 &lt;code&gt;select/3&lt;/code&gt; 是由QLC组装）：简单过滤器被转换成等效的匹配规格而更复杂的过滤器必须被应用到的所有对象通过返回 &lt;code&gt;select/3&lt;/code&gt; 给出一个匹配规范的所有对象相匹配。</target>
        </trans-unit>
        <trans-unit id="3e9b781613899199f74480c8df4e129f831967a1" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 一次遍历一个表。</target>
        </trans-unit>
        <trans-unit id="7b596d446b0a8770a2196be90fa1f23b7bdccfe0" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 一次遍历一个表。</target>
        </trans-unit>
        <trans-unit id="e8716b30387dd883800492663d7d3d90e4516d46" translate="yes" xml:space="preserve">
          <source>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP.</source>
          <target state="translated">该表可以作为普通的Mnesia表使用,在应用程序内部使用Mnesia API,同时通过SNMP可见。</target>
        </trans-unit>
        <trans-unit id="3d172554a6c6306bf28a607a5a2963fa7455c502" translate="yes" xml:space="preserve">
          <source>The table must be created in Mnesia before the manager can use it. The table must be declared as type &lt;code&gt;snmp&lt;/code&gt;. This makes the table ordered in accordance with the lexicographical ordering rules of SNMP. The name of the Mnesia table must be identical to the SNMP table name. The types of the INDEX fields in the corresponding SNMP table must be specified.</source>
          <target state="translated">该表必须在Mnesia中创建，管理员才能使用它。该表必须声明为 &lt;code&gt;snmp&lt;/code&gt; 类型。这使得表按照SNMP的字典顺序规则进行排序。Mnesia表的名称必须与SNMP表名称相同。必须指定相应SNMP表中INDEX字段的类型。</target>
        </trans-unit>
        <trans-unit id="75b5a69a501aab4ff4e7aeebea0d27ed7fcb4181" translate="yes" xml:space="preserve">
          <source>The table name, regardless of if it is a &lt;code&gt;named_table&lt;/code&gt; or not.</source>
          <target state="translated">表名，无论它是否是 &lt;code&gt;named_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="905054fe1aefc5725eea1173de784dd765e8936b" translate="yes" xml:space="preserve">
          <source>The table name.</source>
          <target state="translated">表名:</target>
        </trans-unit>
        <trans-unit id="aba015ed958a70d6fa81d83ffe73faad038149fe" translate="yes" xml:space="preserve">
          <source>The table property &lt;code&gt;frag_properties&lt;/code&gt; can be read with the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt;. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers &lt;code&gt;Mnesia&lt;/code&gt; to regard the table as fragmented. The fragmentation properties are as follows:</source>
          <target state="translated">可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt; 读取表属性 &lt;code&gt;frag_properties&lt;/code&gt; 。碎片属性是带有Arity 2的已标记元组的列表。默认情况下，该列表为空，但是当它为非空时，它将触发 &lt;code&gt;Mnesia&lt;/code&gt; 将表视为碎片。碎片属性如下：</target>
        </trans-unit>
        <trans-unit id="d01afc3037ddbf804c41230f3010100787c86042" translate="yes" xml:space="preserve">
          <source>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function.</source>
          <target state="translated">表的副本可以从RAM中备份,也可以从光盘中备份,如果用这个功能转储到那里的话。</target>
        </trans-unit>
        <trans-unit id="015f395b52e0bf9602a397e1f420732c71594a61" translate="yes" xml:space="preserve">
          <source>The table type is not &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">表类型未 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e38c104619f1b370bd6dfa294f10929d5f26c0d" translate="yes" xml:space="preserve">
          <source>The table type, that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;dublicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">表格类型，即 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ， &lt;code&gt;dublicate_bag&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2206ddd6a97bccbdb41e1737af06cd4da0bcb9" translate="yes" xml:space="preserve">
          <source>The table type.</source>
          <target state="translated">表格类型:</target>
        </trans-unit>
        <trans-unit id="d1da328209adecc0d90374bccf49a5ac8565208f" translate="yes" xml:space="preserve">
          <source>The table-related events that can occur are as follows:</source>
          <target state="translated">可能发生的与表有关的事件如下:</target>
        </trans-unit>
        <trans-unit id="6b7e8b80ac770e54ad2093b66bc38848a1574359" translate="yes" xml:space="preserve">
          <source>The tables are backed up to external media using backup module &lt;code&gt;BackupMod&lt;/code&gt;. Tables with the local contents property are backed up as they exist on the current node. &lt;code&gt;BackupMod&lt;/code&gt; is the default backup callback module obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;. For information about the exact callback interface (the &lt;code&gt;mnesia_backup behavior&lt;/code&gt;), see the User's Guide.</source>
          <target state="translated">使用备份模块 &lt;code&gt;BackupMod&lt;/code&gt; 将表备份到外部介质。具有本地内容属性的表将被备份，因为它们存在于当前节点上。 &lt;code&gt;BackupMod&lt;/code&gt; 是 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 获得的默认备份回调模块。有关确切的回调接口（ &lt;code&gt;mnesia_backup behavior&lt;/code&gt; ）的信息，请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="a50fefb12e96d03c248f13811ba0df12461ae0eb" translate="yes" xml:space="preserve">
          <source>The tables only documents the supported cryptos and key lengths. The user should not draw any conclusion on security from the supplied tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf13625217c16a91aadb6ca3932c666df7c246ce" translate="yes" xml:space="preserve">
          <source>The tag for the messages that are sent to the error logger in the Erlang runtime system</source>
          <target state="translated">发送给Erlang运行时系统中错误记录器的消息的标签。</target>
        </trans-unit>
        <trans-unit id="dea673760fa272778aeb2296bada6c28ed936886" translate="yes" xml:space="preserve">
          <source>The tags, their arguments and the contents of each corresponding section are as follows. Each section can occur multiple times unless otherwise specified. The order in which sections are specified is unimportant.</source>
          <target state="translated">標籤、標籤的參數及每一節的內容如下。除非另有说明,否则每个章节可以出现多次。指定章节的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="043e9fad0f693d524a84cb1e4b574f9675842439" translate="yes" xml:space="preserve">
          <source>The tail variables &lt;code&gt;RestDgram&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; bind to binaries, as all tail variables do. Both can bind to empty binaries.</source>
          <target state="translated">尾变量 &lt;code&gt;RestDgram&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 绑定到二进制文件，就像所有尾变量一样。两者都可以绑定到空二进制文件。</target>
        </trans-unit>
        <trans-unit id="7e9693ae2473d33274921bc96471864fb339cde4" translate="yes" xml:space="preserve">
          <source>The target data must exist in a configuration file. The connection can be associated with &lt;code&gt;Name&lt;/code&gt; and/or the returned &lt;code&gt;Handle&lt;/code&gt;. To allocate a name for the target, use one of the following alternatives:</source>
          <target state="translated">目标数据必须存在于配置文件中。该连接可以与 &lt;code&gt;Name&lt;/code&gt; 和/或返回的 &lt;code&gt;Handle&lt;/code&gt; 关联。要为目标分配名称，请使用以下替代方法之一：</target>
        </trans-unit>
        <trans-unit id="bba902f624a3f363faa2c1c1baf548942d9ee3b6" translate="yes" xml:space="preserve">
          <source>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, &quot;\\r\\n&quot; has been removed.</source>
          <target state="translated">telnet行尾的字符,从FTP协议的定义中,CRLF例如&quot;\\r\\n &quot;已被删除。</target>
        </trans-unit>
        <trans-unit id="85e11e994e429cc2b8651f58111eb62a63c0aeb2" translate="yes" xml:space="preserve">
          <source>The template describes how the formatted string is composed by combining different data values from the log event. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information about this.</source>
          <target state="translated">该模板描述了如何通过组合来自日志事件的不同数据值来构成格式化的字符串。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 类型的描述。</target>
        </trans-unit>
        <trans-unit id="eb1a8be6676238f92f5d9b5d87374d91e2e26ce8" translate="yes" xml:space="preserve">
          <source>The template is a list of atoms, atom lists, tuples and strings. The atoms &lt;code&gt;level&lt;/code&gt; or &lt;code&gt;msg&lt;/code&gt;, are treated as placeholders for the severity level and the log message, respectively. Other atoms or atom lists are interpreted as placeholders for metadata, where atoms are expected to match top level keys, and atom lists represent paths to sub keys when the metadata is a nested map. For example the list &lt;code&gt;[key1,key2]&lt;/code&gt; is replaced by the value of the &lt;code&gt;key2&lt;/code&gt; field in the nested map below. The atom &lt;code&gt;key1&lt;/code&gt; on its own is replaced by the complete value of the &lt;code&gt;key1&lt;/code&gt; field. The values are converted to strings.</source>
          <target state="translated">模板是原子列表，原子列表，元组和字符串。原子 &lt;code&gt;level&lt;/code&gt; 或 &lt;code&gt;msg&lt;/code&gt; 分别被视为严重性级别和日志消息的占位符。其他原子或原子列表被解释为元数据的占位符，其中原子应与顶级键匹配，并且原子列表表示当元数据是嵌套映射时子键的路径。例如，列表 &lt;code&gt;[key1,key2]&lt;/code&gt; 被下面的嵌套映射中的 &lt;code&gt;key2&lt;/code&gt; 字段的值替换。 &lt;code&gt;key1&lt;/code&gt; 的原子key1将替换为 &lt;code&gt;key1&lt;/code&gt; 字段的完整值。值将转换为字符串。</target>
        </trans-unit>
        <trans-unit id="1689a0a33b1df848c6a808be824bdd29e81b6532" translate="yes" xml:space="preserve">
          <source>The term &quot;user&quot; is used differently in OpenSSH and SSH in Erlang/OTP: see more in the &lt;code&gt;&lt;a href=&quot;terminology#the-term--user-&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8501f8ff2d84842e337cdcce3f99664ae391737b" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;&amp;lt;&amp;lt;42, 1:1&amp;gt;&amp;gt;&lt;/code&gt; was encoded as &lt;code&gt;{&amp;lt;&amp;lt;42, 128&amp;gt;&amp;gt;, 1}&lt;/code&gt;. The first element of the tuple is a binary and the second element denotes how many bits of the last bytes are part of the bit string. In this example only the most significant bit of the last byte (128) is part of the bit string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e28f12366708f6b889216805c88be5b281bf16" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;define&lt;/code&gt; introduces a constant that is used to replace the name &lt;code&gt;Constant&lt;/code&gt; with &lt;code&gt;Value&lt;/code&gt;, wherever it is found in the test specification. This replacement occurs during an initial iteration through the test specification. Constants can be used anywhere in the test specification, for example, in any lists and tuples, and even in strings and inside the value part of other constant definitions. A constant can also be part of a node name, but that is the only place where a constant can be part of an atom.</source>
          <target state="translated">术语&amp;ldquo; &lt;code&gt;define&lt;/code&gt; 引入了一个常量，该常量用于在测试规范中的任何位置用&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 替换名称&amp;ldquo; &lt;code&gt;Constant&lt;/code&gt; 。这种替换发生在通过测试规范的初始迭代期间。常量可以在测试规范的任何地方使用，例如，在任何列表和元组中，甚至在字符串中以及在其他常量定义的值部分内部都可以使用。常量也可以是节点名称的一部分，但这是常量可以是原子的一部分的唯一位置。</target>
        </trans-unit>
        <trans-unit id="f0ffe8b43fa9a9a57ebc915f442685927b0ceb78" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;fun lists:map/2&lt;/code&gt; was encoded as &lt;code&gt;{lists,map}&lt;/code&gt;. A tuple with the module, function and a missing arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33125cbeb164cf4f6a823b4bcb06baf40cb7cda" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;specs&lt;/code&gt; can be used to nest specifications, that is, have one specification include other specifications, which in turn include others, and so no</source>
          <target state="translated">术语&amp;ldquo; &lt;code&gt;specs&lt;/code&gt; 可用于嵌套规范，即，一个规范包括其他规范，而其他规范又包括其他规范，因此没有</target>
        </trans-unit>
        <trans-unit id="e318201a8b40a1dad67bec55bab55db8fcdcc917" translate="yes" xml:space="preserve">
          <source>The term is used differently in &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; and SSH in Erlang/OTP. The reason is the different environments and use cases that are not immediatly obvious.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1d039344650bb5818e83c555d5196b81ddbd6e" translate="yes" xml:space="preserve">
          <source>The term representing a collection of annotations. It is either a &lt;code&gt;location()&lt;/code&gt; or a list of key-value pairs.</source>
          <target state="translated">表示注释集合的术语。它可以是 &lt;code&gt;location()&lt;/code&gt; 或键值对列表。</target>
        </trans-unit>
        <trans-unit id="206bdfd6f6a1886654062cc692aecc040226c259" translate="yes" xml:space="preserve">
          <source>The terms &lt;code&gt;incl_dirs_r&lt;/code&gt; and &lt;code&gt;excl_dirs_r&lt;/code&gt; tell &lt;code&gt;Common Test&lt;/code&gt; to search the specified directories recursively and include or exclude any module found during the search. The terms &lt;code&gt;incl_dirs&lt;/code&gt; and &lt;code&gt;excl_dirs&lt;/code&gt; result in a non-recursive search for modules (that is, only modules found in the specified directories are included or excluded).</source>
          <target state="translated">术语 &lt;code&gt;incl_dirs_r&lt;/code&gt; 和 &lt;code&gt;excl_dirs_r&lt;/code&gt; 告诉 &lt;code&gt;Common Test&lt;/code&gt; 递归搜索指定的目录，并包括或排除在搜索过程中找到的任何模块。术语 &lt;code&gt;incl_dirs&lt;/code&gt; 和 &lt;code&gt;excl_dirs&lt;/code&gt; 导致对模块的非递归搜索（即，仅包括或排除在指定目录中找到的模块）。</target>
        </trans-unit>
        <trans-unit id="9ddcad5286af6cdd21c133d5d7ddb5de84e979bf" translate="yes" xml:space="preserve">
          <source>The test case can also be marked as failed without executing it by returning a tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; from &lt;code&gt;init_per_testcase&lt;/code&gt;.</source>
          <target state="translated">还可以通过从 &lt;code&gt;init_per_testcase&lt;/code&gt; 返回一个元组 &lt;code&gt;{fail,Reason}&lt;/code&gt; 来将测试用例标记为失败而不执行它。</target>
        </trans-unit>
        <trans-unit id="c6380cface8a9ffcf2f270eb92121974a48a9e6f" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt; ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8af161d95302d88592feab6a61159ca646e5862" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="translated">不要将测试用例函数的参数 &lt;code&gt;Config&lt;/code&gt; 与可以从配置文件中检索到的信息（使用 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt; ）相混淆。测试用例参数 &lt;code&gt;Config&lt;/code&gt; 将用于测试套件和测试用例的运行时配置，而配置文件将包含与SUT相关的数据。这两种类型的配置数据的处理方式不同。</target>
        </trans-unit>
        <trans-unit id="22d7a935338112ce920c6d20731f07d69ad88ede" translate="yes" xml:space="preserve">
          <source>The test case function takes one argument, &lt;code&gt;Config&lt;/code&gt;, which contains configuration information such as &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt;. (For details about these, see section &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt;. The value of &lt;code&gt;Config&lt;/code&gt; at the time of the call, is the same as the return value from &lt;code&gt;init_per_testcase&lt;/code&gt;, mentioned earlier.</source>
          <target state="translated">测试用例函数采用一个参数 &lt;code&gt;Config&lt;/code&gt; ，该参数包含配置信息，例如 &lt;code&gt;data_dir&lt;/code&gt; 和 &lt;code&gt;priv_dir&lt;/code&gt; 。（有关这些的详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt; 。调用时 &lt;code&gt;Config&lt;/code&gt; 的值与 &lt;code&gt;init_per_testcase&lt;/code&gt; 提到的init_per_testcase的返回值相同。</target>
        </trans-unit>
        <trans-unit id="f3d78685ce4bc3a852ca4f95b85dea262a2dbfd5" translate="yes" xml:space="preserve">
          <source>The test case function.</source>
          <target state="translated">测试案例功能。</target>
        </trans-unit>
        <trans-unit id="772472b0e7495bb1b3ea5fe4354a4abec00b3983" translate="yes" xml:space="preserve">
          <source>The test case group information function, &lt;code&gt;group(GroupName)&lt;/code&gt;, serves the same purpose as the suite- and test case information functions previously described. However, the scope for the group information function, is all test cases and subgroups in the group in question (&lt;code&gt;GroupName&lt;/code&gt;).</source>
          <target state="translated">测试用例组信息功能 &lt;code&gt;group(GroupName)&lt;/code&gt; 的作用与前述的套件和测试用例信息功能相同。但是，组信息功能的范围是相关组（ &lt;code&gt;GroupName&lt;/code&gt; ）中的所有测试用例和子组。</target>
        </trans-unit>
        <trans-unit id="0e361a6c5d543d0ec29b4b4738869aef2ab9cb85" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2f40a449aa01ec3c8d9cd4d1b80e618a045844" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例组信息功能。应该返回一个标记元组的列表，该列表指定了与测试用例组（即其测试用例和子组）的执行相关的各种属性。由 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 设置的属性将覆盖先前由 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 设置的相同键的属性。</target>
        </trans-unit>
        <trans-unit id="fc2a92c03b710e68d01915fb812b8e75a0b574d1" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Module:Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc2d22e0d7f34017553a5d0de008034c64289ba" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例信息功能。应该返回一个加标签的元组列表，该列表指定了与此特定测试用例的执行相关的各种属性。由 &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; 设置的属性会覆盖先前由 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 为测试用例设置的属性。</target>
        </trans-unit>
        <trans-unit id="c528968b61f60ab84b8bb693468a7bbe033dbb46" translate="yes" xml:space="preserve">
          <source>The test case is implemented as follows:</source>
          <target state="translated">测试用例的实现方式如下。</target>
        </trans-unit>
        <trans-unit id="561ea1ed4002a2f665fd14f2b18b980f0debbc51" translate="yes" xml:space="preserve">
          <source>The test case is skipped in the following two cases:</source>
          <target state="translated">在以下两种情况下,测试用例被跳过。</target>
        </trans-unit>
        <trans-unit id="acb7aee40da2324bbced996f9d61c0d108e566ea" translate="yes" xml:space="preserve">
          <source>The test cases verify, by parsing a log file, that our SUT has performed a successful restart and that no unexpected errors are printed.</source>
          <target state="translated">测试用例通过解析日志文件来验证我们的SUT是否已经成功重启,是否有意外的错误被打印出来。</target>
        </trans-unit>
        <trans-unit id="efc4c3530fced19d9cbc7b2225463ba3c8ff70fc" translate="yes" xml:space="preserve">
          <source>The test compares the following encoder/decoders:</source>
          <target state="translated">该测试比较了以下编码器/解码器。</target>
        </trans-unit>
        <trans-unit id="1270d4393c0694cbb6ad986297c7c536eca317f0" translate="yes" xml:space="preserve">
          <source>The test group definition, as returned by &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3ccb28e1c0e973d6192fea8f8c8d2cd0b4ea0a" translate="yes" xml:space="preserve">
          <source>The test now fails with &lt;code&gt;{badmatch,24}&lt;/code&gt; because the atom &lt;code&gt;toy_table&lt;/code&gt; does not match the number returned for an unnamed table. So, the problem is found, the table is to be named, and the arguments supplied by the test program do not include &lt;code&gt;named_table&lt;/code&gt;. We rewrite the start function:</source>
          <target state="translated">现在，测试失败并显示 &lt;code&gt;{badmatch,24}&lt;/code&gt; ,因为原子 &lt;code&gt;toy_table&lt;/code&gt; 与未命名表返回的数字不匹配。因此，发现了问题，表将被命名，并且测试程序提供的参数不包括 &lt;code&gt;named_table&lt;/code&gt; 。我们重写start函数：</target>
        </trans-unit>
        <trans-unit id="3bf97f87b41a6f29d2b30317c0ec60daf7647ab1" translate="yes" xml:space="preserve">
          <source>The test program runs 10000 decodes on the value, resulting in an output with the elapsed time in microseconds for the total number of decodes.</source>
          <target state="translated">测试程序对该值运行10000次解码,结果输出总解码次数的经过时间,单位为微秒。</target>
        </trans-unit>
        <trans-unit id="3633648c5d3cca8dc486b6dee36d903c368bcf6f" translate="yes" xml:space="preserve">
          <source>The test specification uses the same mechanism for specifying test case groups through names and paths, as explained in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt;, with the addition of element &lt;code&gt;GroupSpec&lt;/code&gt;.</source>
          <target state="translated">测试规范使用相同的机制通过名称和路径指定测试用例组，如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt; 一节中所述，并添加了元素 &lt;code&gt;GroupSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784058b40fd83e13e1f3df9bc88ef815cead679e" translate="yes" xml:space="preserve">
          <source>The test specifications used as input to &lt;code&gt;Common Test&lt;/code&gt; Master are fully compatible with the specifications used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The syntax is described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">用作 &lt;code&gt;Common Test&lt;/code&gt; Master的输入的测试规范与用作常规 &lt;code&gt;Common Test&lt;/code&gt; 服务器的输入的规范完全兼容。语法在&amp;ldquo;运行 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 和分析结果&amp;rdquo; 部分的&amp;ldquo; 测试规范 &amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="ce12c5a86679e02b3e5d37feffd481cfa1a9e63a" translate="yes" xml:space="preserve">
          <source>The test suite definition, as returned by &lt;code&gt;&lt;a href=&quot;#Module:all-0&quot;&gt;Module:all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15500e2662eb6cf2096b1c33acff5c731c7b2d5b" translate="yes" xml:space="preserve">
          <source>The test suite information function. Returns a list of tagged tuples specifying various properties related to the execution of this test suite (common for all test cases in the suite).</source>
          <target state="translated">测试套件信息函数。Returns a list of tagged tuples specifing various properties related to the execution of this test suite (common for all test cases in the suite).</target>
        </trans-unit>
        <trans-unit id="4ce6fe4d39f0fcb69c9b74055b99a80993ff6554" translate="yes" xml:space="preserve">
          <source>The test suite information, as returned by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Module:Testcase/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4bd482d9cff3e45eb13e9917fb381a5f26152b" translate="yes" xml:space="preserve">
          <source>The test suite module must conform to a &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; specified by the &lt;code&gt;Common Test&lt;/code&gt; test server. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试套件模块必须符合 &lt;code&gt;Common Test&lt;/code&gt; 测试服务器指定的 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; 。有关详细信息，请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="bd0f930877592ca670db8a085bb70953a2a40661" translate="yes" xml:space="preserve">
          <source>The test suites overview page includes a link to the Unexpected I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt;, as well as captured system error- and progress reports, which cannot be associated with particular test cases and therefore cannot be written to individual test case log files. This occurs, for example, if a log printout is made from an external process (not a test case process), &lt;strong&gt;or&lt;/strong&gt; if an error- or progress report comes in, during a short interval while &lt;code&gt;Common Test&lt;/code&gt; is not executing a test case or configuration function, &lt;strong&gt;or&lt;/strong&gt; while &lt;code&gt;Common Test&lt;/code&gt; is currently executing a parallel test case group.</source>
          <target state="translated">测试套件概述页面包含指向意外I / O日志的链接。在此日志中， &lt;code&gt;Common Test&lt;/code&gt; 保存了使用 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 生成的打印输出，以及捕获的系统错误和进度报告，不能与特定的测试用例相关联，因此不能写入单个测试用例日志文件。例如，如果在 &lt;code&gt;Common Test&lt;/code&gt; 未执行测试用例或配置的短暂间隔内，是从外部流程（不是测试用例流程）打印日志，&lt;strong&gt;或者&lt;/strong&gt;出现了错误或进度报告，则会发生这种情况功能，&lt;strong&gt;或者&lt;/strong&gt;当 &lt;code&gt;Common Test&lt;/code&gt; 当前正在执行并行测试用例组时。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8134f6c45a2f73ed264b68d4ba70993d25134c43" translate="yes" xml:space="preserve">
          <source>The tests can be read as documentation, typically showing both examples of correct and incorrect usage, along with the expected consequences.</source>
          <target state="translated">测试可以作为文档来阅读,通常会展示正确和不正确使用的例子,以及预期的后果。</target>
        </trans-unit>
        <trans-unit id="ab59e3293af2eeab2e6a44396959211db748141a" translate="yes" xml:space="preserve">
          <source>The tests will be released into &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt;. After releasing the tests you have to install the tests on the build machine. You supply the same xcomp file as to &lt;code&gt;./otp_build&lt;/code&gt; in (9).</source>
          <target state="translated">测试将发布到 &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; 。发布测试之后，您必须在构建计算机上安装测试。您提供与（9）中的 &lt;code&gt;./otp_build&lt;/code&gt; 相同的xcomp文件。</target>
        </trans-unit>
        <trans-unit id="6461764795f9a7e6a1ca8fecef822585f15dd414" translate="yes" xml:space="preserve">
          <source>The text encoding config.</source>
          <target state="translated">文本编码配置。</target>
        </trans-unit>
        <trans-unit id="0912732fbe8b51c591e00170193eac6690100280" translate="yes" xml:space="preserve">
          <source>The text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt;, which is part of the source code, contains information about all OTP versions from OTP 17.0 up to the current OTP version. Each line contains information about application versions that are part of a specific OTP version, and has the following format:</source>
          <target state="translated">作为源代码一部分的文本文件 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt; 包含有关从OTP 17.0到当前OTP版本的所有OTP版本的信息。每行包含有关属于特定OTP版本的应用程序版本的信息，并具有以下格式：</target>
        </trans-unit>
        <trans-unit id="f468d3e883b219b9301214ec34fa66d1174c9bd6" translate="yes" xml:space="preserve">
          <source>The text given to a &lt;code&gt;?Q(Text)&lt;/code&gt; macro can be either a single string, or a list of strings. The latter is useful when you need to split a long expression over multiple lines, e.g.:</source>
          <target state="translated">提供给 &lt;code&gt;?Q(Text)&lt;/code&gt; 宏的文本可以是单个字符串，也可以是字符串列表。当您需要将长表达式拆分成多行时，后者非常有用，例如：</target>
        </trans-unit>
        <trans-unit id="02aabeed8f889ebc3fe270b684693102faf40262" translate="yes" xml:space="preserve">
          <source>The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</source>
          <target state="translated">与子表达式相匹配的文本(由正则表达式中的括号标记)被插入到找到它的结果列表中。这意味着,如果将整个正则表达式是一个单一的子表达式的拆分结果进行连接(如上一个例子),其结果总是原始字符串。</target>
        </trans-unit>
        <trans-unit id="522fb2d0051c3d9be5f7edef8910c5e365ade309" translate="yes" xml:space="preserve">
          <source>The third and final part -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f15d959ef8fc520df7e2a55f83ecd2a324cb0e0" translate="yes" xml:space="preserve">
          <source>The third argument is &lt;code&gt;Vsn&lt;/code&gt; or &lt;code&gt;{down,Vsn}&lt;/code&gt;, as described for &lt;code&gt;gen_server:code_change/3&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第三个参数是 &lt;code&gt;Vsn&lt;/code&gt; 或 &lt;code&gt;{down,Vsn}&lt;/code&gt; ，作为用于描述 &lt;code&gt;gen_server:code_change/3&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98495365dd14291e5d0887711f1c5c3436964748" translate="yes" xml:space="preserve">
          <source>The third argument is an integer that is used to identify a particular instance of a C node.</source>
          <target state="translated">第三个参数是一个整数,用来标识C节点的一个特定实例。</target>
        </trans-unit>
        <trans-unit id="b22885d6c6999fdcc81a99f8b75e55f5d786c841" translate="yes" xml:space="preserve">
          <source>The third argument is the full node name.</source>
          <target state="translated">第三个参数是完整的节点名称。</target>
        </trans-unit>
        <trans-unit id="365807a93bdba62a0a00761a03b6e541034bb449" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;Code&lt;/code&gt;, is a list of digits, which is the correct unlock code that is passed to callback function &lt;code&gt;init/1&lt;/code&gt;.</source>
          <target state="translated">第三个参数， &lt;code&gt;Code&lt;/code&gt; ，是数字的列表，这是传递到回调函数正确的解锁码 &lt;code&gt;init/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b4235e17037973516e425fe018a785d1dc11753" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">第三个参数 &lt;code&gt;[]&lt;/code&gt; 是直接传递给回调函数 &lt;code&gt;init&lt;/code&gt; 的术语。在此， &lt;code&gt;init&lt;/code&gt; 不需要任何indata并忽略该参数。</target>
        </trans-unit>
        <trans-unit id="2a25200e085552c647a791d385625d025a3908db" translate="yes" xml:space="preserve">
          <source>The third component is a term providing additional information about the cause of the error.</source>
          <target state="translated">第三个组成部分是一个术语,提供有关错误原因的额外信息。</target>
        </trans-unit>
        <trans-unit id="263e38347244b9c29c16011be163dc8c74039614" translate="yes" xml:space="preserve">
          <source>The third element of the &lt;code&gt;update&lt;/code&gt; instruction is a tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;, which says that the affected processes are to do a state transformation before loading the new version of the module. This is done by the processes calling the callback function &lt;code&gt;code_change&lt;/code&gt; (see the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in STDLIB). The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to the function:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 指令的第三个元素是元组 &lt;code&gt;{advanced,Extra}&lt;/code&gt; ，它表示受影响的进程将在加载模块的新版本之前进行状态转换。这是通过调用回调函数 &lt;code&gt;code_change&lt;/code&gt; 的进程完成的（请参阅STDLIB中的 &lt;code&gt;gen_server(3)&lt;/code&gt; 手册页）。术语 &lt;code&gt;Extra&lt;/code&gt; （在这种情况下为 &lt;code&gt;[]&lt;/code&gt; ）按原样传递给该函数：</target>
        </trans-unit>
        <trans-unit id="ab1e993eaa153cf69b806d94010676be4ba79b9d" translate="yes" xml:space="preserve">
          <source>The third instruction, &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;, works as follows:</source>
          <target state="translated">第三条指令 &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 的工作方式如下：</target>
        </trans-unit>
        <trans-unit id="0c296204e008ff6b192a1e6549228a85ab543274" translate="yes" xml:space="preserve">
          <source>The third is the maximum value since the emulator was started.</source>
          <target state="translated">第三个是仿真器启动后的最大值。</target>
        </trans-unit>
        <trans-unit id="2f8559770f8f26c04a07a718464d482640f01d42" translate="yes" xml:space="preserve">
          <source>The thread has executed a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f336924d314b911c8bf63b44ab8037d465beb03f" translate="yes" xml:space="preserve">
          <source>The thread has returned from other code to a known state in the thread progress functionality, which is independent of any other code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53980cbfc9a30778a14bd5b2052c49935bce4336" translate="yes" xml:space="preserve">
          <source>The threads and states are subject to change without any prior notice.</source>
          <target state="translated">线路和状态如有变更,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="110848e2d40c2615a11026b769bd376100abd56b" translate="yes" xml:space="preserve">
          <source>The threads for long running I/O work. See &lt;code&gt;erl +SDio&lt;/code&gt; for more details.</source>
          <target state="translated">长时间运行的I / O工作的线程。有关更多详细信息，请参见 &lt;code&gt;erl +SDio&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86c3f72d097c7761a31ae09180cc6b2d4d48d019" translate="yes" xml:space="preserve">
          <source>The threads for long running cpu intensive work. See &lt;code&gt;erl +SDcpu&lt;/code&gt; for more details.</source>
          <target state="translated">长时间运行cpu的线程需要大量工作。有关更多详细信息，请参见 &lt;code&gt;erl +SDcpu&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aece34de50ec637e00271fb64aadf70ca0063d4f" translate="yes" xml:space="preserve">
          <source>The three Erlang (&lt;code&gt;.erl&lt;/code&gt;) files in the messenger example are individually compiled into object code file (&lt;code&gt;.beam&lt;/code&gt;). The Erlang system loads and links these files into the system when they are referred to during execution of the code. In this case, they are simply put in our current working directory (that is, the place you have done &quot;cd&quot; to). There are ways of putting the &lt;code&gt;.beam&lt;/code&gt; files in other directories.</source>
          <target state="translated">Messenger示例中的三个Erlang（ &lt;code&gt;.erl&lt;/code&gt; ）文件分别编译为目标代码文件（ &lt;code&gt;.beam&lt;/code&gt; ）。当在代码执行期间引用这些文件时，Erlang系统将这些文件加载​​并链接到系统中。在这种情况下，它们只是放在我们当前的工作目录中（即您完成&amp;ldquo; cd&amp;rdquo;操作的位置）。有几种方法可以将 &lt;code&gt;.beam&lt;/code&gt; 文件放在其他目录中。</target>
        </trans-unit>
        <trans-unit id="3179e67fe382f9002d115e1d41e6ed750c972cbf" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">阈值,占系统内存的百分比,指在设置相应的报警之前可以分配多少系统内存。默认值为0.80(80%)。</target>
        </trans-unit>
        <trans-unit id="abb964e16a15aea3574dff337699e7babb0b88a4" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set. The default is 0.05 (5%).</source>
          <target state="translated">在设置相应的报警之前,一个Erlang进程可以分配多少系统内存的阈值,占系统内存的百分比。默认值是0.05(5%)。</target>
        </trans-unit>
        <trans-unit id="e98007a7e215201117e788dbb3276465ac6d78e0" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of total disk space, for how much disk can be utilized before the &lt;code&gt;disk_almost_full&lt;/code&gt; alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">在设置 &lt;code&gt;disk_almost_full&lt;/code&gt; 警报之前，可以使用多少磁盘的阈值（占总磁盘空间的百分比）。默认值为0.80（80％）。</target>
        </trans-unit>
        <trans-unit id="feab1aae2bdfc2e74927bee2d91bb36426d8246c" translate="yes" xml:space="preserve">
          <source>The time for calculating the length of a list is proportional to the length of the list, as opposed to &lt;code&gt;tuple_size/1&lt;/code&gt;, &lt;code&gt;byte_size/1&lt;/code&gt;, and &lt;code&gt;bit_size/1&lt;/code&gt;, which all execute in constant time.</source>
          <target state="translated">计算列表长度的时间与列表的长度成正比，与 &lt;code&gt;tuple_size/1&lt;/code&gt; ， &lt;code&gt;byte_size/1&lt;/code&gt; 和 &lt;code&gt;bit_size/1&lt;/code&gt; 相反，它们都在恒定的时间内执行。</target>
        </trans-unit>
        <trans-unit id="9fd990e3b9e2b09e602b014e1bf744386f4c5083" translate="yes" xml:space="preserve">
          <source>The time for file operations in the linked in driver distributes itself as 1 % for open, 11 % for write and 87 % for close. All data is probably buffered in the operating system until the close.</source>
          <target state="translated">link in驱动中文件操作的时间分布为:打开1%,写入11%,关闭87%。所有的数据可能都在操作系统中缓冲,直到关闭。</target>
        </trans-unit>
        <trans-unit id="9a190b1ab4466c628fefcec59c8cb2184c9a131f" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. The is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="translated">该模块中的时间函数 &lt;code&gt;local_time/0&lt;/code&gt; 和 &lt;code&gt;universal_time/0&lt;/code&gt; 都返回日期和时间。这是因为日期和时间的单独功能可能导致日期/时间组合错开24小时。如果其中一个功能在午夜之前调用，而另一个功能在午夜之后调用，则会发生这种情况。此问题也适用于Erlang BIF &lt;code&gt;date/0&lt;/code&gt; 和 &lt;code&gt;time/0&lt;/code&gt; ，如果需要可靠的日期/时间戳，强烈建议不要使用它们。</target>
        </trans-unit>
        <trans-unit id="7e455cab1124e78b64c4ae934600680a5bd96fdf" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. This is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69208e9c32fc9f7e1bfe894a2034c5bf8bcec375" translate="yes" xml:space="preserve">
          <source>The time in seconds the web server waits between each chunk of data from the script. If the CGI script does not deliver any data before the timeout, the connection to the client is closed. Default is &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">Web服务器在脚本的每个数据块之间等待的时间（以秒为单位）。如果CGI脚本在超时之前未传送任何数据，则将关闭与客户端的连接。默认值为 &lt;code&gt;15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83fde948bd1a784c99ccd55cd88c7ae69cfaa7fb" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic disk space check. The default is 30 minutes.</source>
          <target state="translated">定期检查磁盘空间的时间间隔,以分钟为单位。默认为30分钟。</target>
        </trans-unit>
        <trans-unit id="f648e7e2912e2b6d60327d6a0acc64bb170e218b" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic memory check. The default is one minute.</source>
          <target state="translated">定期检查内存的时间间隔,以分钟为单位。默认为一分钟。</target>
        </trans-unit>
        <trans-unit id="6dc4a14921776a9a6e79ea069562a5ef16a83ecc" translate="yes" xml:space="preserve">
          <source>The time is specified as a fraction, in percent, of a full time-slice that a port is allowed to execute before it is to surrender the CPU to other runnable ports or processes. Valid range is &lt;code&gt;[1, 100]&lt;/code&gt;. The scheduling time-slice is not an exact entity, but can usually be approximated to about 1 millisecond.</source>
          <target state="translated">将时间指定为允许端口在将CPU交还给其他可运行端口或进程之前执行的完整时间片段的百分比（以百分比为单位）。有效范围是 &lt;code&gt;[1, 100]&lt;/code&gt; 。调度时间片不是确切的实体，但是通常可以大约为1毫秒。</target>
        </trans-unit>
        <trans-unit id="68613cc82c2c14fbfd127a4e01a552399427b53f" translate="yes" xml:space="preserve">
          <source>The time of the least number of consecutive &lt;code&gt;MTTI&lt;/code&gt;s to cover &lt;code&gt;TransitionPeriod&lt;/code&gt; seconds following the call to &lt;code&gt;set_net_ticktime/2&lt;/code&gt; (that is, ((&lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; milliseconds).</source>
          <target state="translated">调用 &lt;code&gt;set_net_ticktime/2&lt;/code&gt; 之后，覆盖 &lt;code&gt;TransitionPeriod&lt;/code&gt; 秒的最少连续 &lt;code&gt;MTTI&lt;/code&gt; 的时间（即（（（ &lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; 毫秒）。</target>
        </trans-unit>
        <trans-unit id="6e174adfced39af8e0e284588941d85b0bfefb31" translate="yes" xml:space="preserve">
          <source>The time offset can change at any time without limitations. That is, Erlang system time can perform time warps both forwards and backwards at &lt;strong&gt;any&lt;/strong&gt; time. As we align Erlang system time with OS system time by changing the time offset, we can enable a time correction that tries to adjust the frequency of the Erlang monotonic clock to be as correct as possible. This makes time measurements using Erlang monotonic time more accurate and precise.</source>
          <target state="translated">时间偏移量可以随时更改，没有限制。也就是说，Erlang系统时间可以在&lt;strong&gt;任何&lt;/strong&gt;时候向前和向后执行时间扭曲。通过更改时间偏移将Erlang系统时间与OS系统时间对齐时，我们可以启用时间校正，尝试将Erlang单调时钟的频率调整为尽可能正确。这使得使用Erlang单调时间的时间测量更加准确和精确。</target>
        </trans-unit>
        <trans-unit id="d2d5aace605853ec8fe0539020e963801c0f8996" translate="yes" xml:space="preserve">
          <source>The time offset is determined at runtime system start and does not change later. This is the default behavior, but not because it is the best mode (which it is not). It is default &lt;strong&gt;only&lt;/strong&gt; because this is how the runtime system behaved until ERTS 7.0. Ensure that your Erlang code that can execute during a time warp is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; before enabling other modes.</source>
          <target state="translated">时间偏移是在运行系统启动时确定的，以后不会更改。这是默认行为，但不是因为它是最佳模式（不是）。这是默认&lt;strong&gt;只&lt;/strong&gt;因为这是运行系统表现如何，直到ERTS 7.0。在启用其他模式之前，请确保可以在时间扭曲期间执行的Erlang代码是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07e55769f0c90da00308e78b47db1584a4fbdcad" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt; no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a05290e0120252e64339359ca4738dbe7f2ecf8" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">时间偏移是最终的。这是因为 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; ，或者是因为在使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 时已确定了时间偏移。</target>
        </trans-unit>
        <trans-unit id="c0957ac47e0e7e0c4aad16f53fa2e9c24f33cc8d" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt; single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75246e26b9078dfc246576a8981834ffa66ca0f1" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">时间偏移是初步的，将在以后更改和确定。初步时间偏移用于 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 的初步阶段。</target>
        </trans-unit>
        <trans-unit id="7b00c96b81b3952f08dae1ef8d280a0739f7dec6" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt; multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a542b4a11973e3e77034a41b121ba9735a608c2b" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">时间偏移是易失的。也就是说，它可以随时更改。这是因为使用了 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe4b21df9a3383d5eec3e415625b8f307797fe41" translate="yes" xml:space="preserve">
          <source>The time offset may or may not change during operation depending on the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used.</source>
          <target state="translated">时间偏移量可能会或可能不会在操作期间更改，具体取决于所使用的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5747e4d4272d9517822c11117ba6680478fe811f" translate="yes" xml:space="preserve">
          <source>The time offset, either a string or an integer, to be used when formatting the timestamp.</source>
          <target state="translated">时间偏移,可以是字符串或整数,在格式化时间戳时使用。</target>
        </trans-unit>
        <trans-unit id="01e05d873bba0338059375e3eba7a363e13a9238" translate="yes" xml:space="preserve">
          <source>The time to start the Erlang node, in seconds. Defaults to 3 seconds. If the node is not pingable within this time, the result &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">启动Erlang节点的时间，以秒为单位。默认为3秒。如果该节点在此时间内不可ping &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; 则返回结果{error，boot_timeout，NodeName}。</target>
        </trans-unit>
        <trans-unit id="c2b0569acb74ea5c562c3c099098eac517911fa3" translate="yes" xml:space="preserve">
          <source>The time to wait for the node until it calls the internal callback function informing master about a successful startup. Defaults to 1 second. In case of a timed out message, the result &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">等待节点直到它调用内部回调函数通知主设备成功启动的时间。默认为1秒。如果消息超时 &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; 则返回结果{error，init_timeout，NodeName}。</target>
        </trans-unit>
        <trans-unit id="6b1ed69df7a8c67ce8c0a0d212b6e1372ea7bd21" translate="yes" xml:space="preserve">
          <source>The time to wait until the node stops to run &lt;code&gt;StartupFunctions&lt;/code&gt;. Defaults to 1 second. If this time-out occurs, the result &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">等待节点停止运行 &lt;code&gt;StartupFunctions&lt;/code&gt; 的时间。默认为1秒。如果发生此超时，将返回结果 &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa9c4628387e5d0232143d2f5ae73813eebb7d09" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中返回的时间类型取决于在 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 设置的时间类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="025c3e1a1b5155e5b0e031d4135009cedb0e5183" translate="yes" xml:space="preserve">
          <source>The time type set in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; depends on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中设置的时间类型取决于在 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 设置的时间类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="b611e039fc45e31859a16123e8fec64f9c4d2359" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt; os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4f9d85f1388b8c9748c712e4d020e326e2e9ee" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt;os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="translated">时间单位与 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 返回的时间单位相同。因此，要将其转换为毫秒，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="12219f11b7eb31ef4590154a3caff4c692e2fc9c" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second.</source>
          <target state="translated">的时间单位 &lt;code&gt;Time&lt;/code&gt; 。默认值为 &lt;code&gt;second&lt;/code&gt; 。如果给定其他单位（ &lt;code&gt;millisecond&lt;/code&gt; ， &lt;code&gt;microsecond&lt;/code&gt; 或 &lt;code&gt;nanosecond&lt;/code&gt; ），则格式化的字符串包括一秒的分数。</target>
        </trans-unit>
        <trans-unit id="392c6bce329c78bf91e4cd21377be4fb3bee4780" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second. The number of fractional second digits is three, six, or nine depending on what time unit is chosen. Notice that trailing zeros are not removed from the fraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1430c59740c5ce36e77e21d493e646f47e818719" translate="yes" xml:space="preserve">
          <source>The time unit of the return value. The default is &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">返回值的时间单位。默认值为 &lt;code&gt;second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6064d2834424e42c0c9064187c8cad80d5a77e73" translate="yes" xml:space="preserve">
          <source>The time warp made when finalizing the time offset can only be done forwards without encountering problems. This implies that the user must ensure that OS system time is set to a time earlier or equal to actual POSIX time before starting the Erlang runtime system.</source>
          <target state="translated">在最终确定时间偏移时所做的时间翘曲只能向前进行,而不会遇到问题。这意味着用户在启动Erlang运行系统之前,必须确保操作系统系统时间被设置为早于或等于实际POSIX时间。</target>
        </trans-unit>
        <trans-unit id="d4fbb252f5f519e910d0858637bda3afb5fe08b3" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS.</source>
          <target state="translated">时区和夏令时校正取决于底层操作系统。</target>
        </trans-unit>
        <trans-unit id="46decb898c0ad74d50df552bed6180379c34d8f6" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</source>
          <target state="translated">时区和夏令时校正取决于基础操作系统。例如</target>
        </trans-unit>
        <trans-unit id="c1ff4d23080563c54d4def9701098918387b1c59" translate="yes" xml:space="preserve">
          <source>The time-out (&lt;code&gt;after 5000&lt;/code&gt;) is started when &lt;code&gt;receive&lt;/code&gt; is entered. The time-out is canceled if &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is received. If &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is not received, the actions following the time-out are done after 5000 milliseconds. &lt;code&gt;after&lt;/code&gt; must be last in the &lt;code&gt;receive&lt;/code&gt;, that is, preceded by all other message reception specifications in the &lt;code&gt;receive&lt;/code&gt;. It is also possible to call a function that returned an integer for the time-out:</source>
          <target state="translated">输入 &lt;code&gt;receive&lt;/code&gt; 时开始超时（ &lt;code&gt;after 5000&lt;/code&gt; ）。如果收到 &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; ,则超时将被取消。如果未收到 &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; ，则超时后的操作将在5000毫秒后执行。 &lt;code&gt;after&lt;/code&gt; 必须排在最后的 &lt;code&gt;receive&lt;/code&gt; ，也就是说，所有其他消息接待规格之前在 &lt;code&gt;receive&lt;/code&gt; 。也可以调用返回超时整数的函数：</target>
        </trans-unit>
        <trans-unit id="a74551537c5a43771b2d27e385232c7f56d26101" translate="yes" xml:space="preserve">
          <source>The time-out is set in:</source>
          <target state="translated">超时的设置在。</target>
        </trans-unit>
        <trans-unit id="b43eb0e0eaef9c040d6d8272e488450d475f41d0" translate="yes" xml:space="preserve">
          <source>The time-out values that can be returned have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">可以返回的超时值具有与 &lt;code&gt;gen_server&lt;/code&gt; 相同的语义。如果发生超时， &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 称为 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23098336c20c6b0d05b70cb1a61cba6bfe7c35df" translate="yes" xml:space="preserve">
          <source>The time-outs are applied as follows:</source>
          <target state="translated">超时工作按以下方式进行:</target>
        </trans-unit>
        <trans-unit id="a92d7be64c5181c10f9b9787e69692d9bd980a7b" translate="yes" xml:space="preserve">
          <source>The time-outs are not exact, but are &lt;strong&gt;at least&lt;/strong&gt; as long as requested.</source>
          <target state="translated">超时时间不精确，但&lt;strong&gt;至少要&lt;/strong&gt;长一些。</target>
        </trans-unit>
        <trans-unit id="15c1ab79429f67483e0c01a31557346bcc864b3f" translate="yes" xml:space="preserve">
          <source>The timeout is not active until channels are started, so it does not limit the time from the connection creation to the first channel opening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5997cb057fe175060411534263631407871803d" translate="yes" xml:space="preserve">
          <source>The timeout time can have the values: &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">超时时间的值可以是： &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e975fa79f9358d6848c00dddda11ae68d145e5e9" translate="yes" xml:space="preserve">
          <source>The timeout time is in milliseconds. A value of 0 (zero) means that the proxy process will exit directly after the reply has been delivered.</source>
          <target state="translated">超时时间的单位是毫秒。值为0(0)时,表示代理进程将在回复发送后直接退出。</target>
        </trans-unit>
        <trans-unit id="6942299da0c7028fdc30f81f96ae8da61dd1bd71" translate="yes" xml:space="preserve">
          <source>The timeout value in a &lt;code&gt;receive..after&lt;/code&gt; expression is evaluated to something else than an integer or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;receive..after&lt;/code&gt; 表达式中的超时值将计算为除整数或 &lt;code&gt;infinity&lt;/code&gt; 之外的其他值。</target>
        </trans-unit>
        <trans-unit id="a58b363626052caadeef7377d180027acba06268" translate="yes" xml:space="preserve">
          <source>The timeout values that can be returned by the callback functions have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">回调函数可以返回的超时值具有与 &lt;code&gt;gen_server&lt;/code&gt; 相同的语义。如果发生超时， &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 称为 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="746fc091a3bbb9211a083b1f5ae06872c6f4470d" translate="yes" xml:space="preserve">
          <source>The timer associated with &lt;code&gt;Timeout&lt;/code&gt; only supervises IP resolution of &lt;code&gt;Addr&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Timeout&lt;/code&gt; 相关的计时器仅监督 &lt;code&gt;Addr&lt;/code&gt; 的 IP分辨率。</target>
        </trans-unit>
        <trans-unit id="09b399a5a75126e8cb452f47bf0a1a5174ce3ebb" translate="yes" xml:space="preserve">
          <source>The timer created using &lt;code&gt;dist_util:start_timer/1&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;dist_util:start_timer/1&lt;/code&gt; 创建的计时器。</target>
        </trans-unit>
        <trans-unit id="4e1cbb1460f78d41a3f7701791a14cffbd170fdb" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine changes states. You can restart a state time-out by setting it to a new time, which cancels the running timer and starts a new. This implies that you can cancel a state time-out by restarting it with time &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">当状态机更改状态时，将自动取消状态超时计时器。您可以通过将状态超时设置为新的时间来重新启动它，这会取消正在运行的计时器并重新开始。这意味着您可以通过以time &lt;code&gt;infinity&lt;/code&gt; 重启状态来取消状态超时。</target>
        </trans-unit>
        <trans-unit id="784479951805b5cf7d975c9fc1d861e0d1536750" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine does a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64045eba1ed6044b87952089dc11046d257dec70" translate="yes" xml:space="preserve">
          <source>The timer is cancelled when a reply is received.</source>
          <target state="translated">当收到回复时,定时器被取消。</target>
        </trans-unit>
        <trans-unit id="3e5d9243b241f9d1ac98de61c38151d7c0aed4f0" translate="yes" xml:space="preserve">
          <source>The timer is started with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;, so any trace patterns must be set up in advance. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; always sets up all patterns before invoking &lt;code&gt;ttb:p/2&lt;/code&gt;.</source>
          <target state="translated">计时器以 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 开头，因此必须预先设置任何跟踪模式。 &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 始终在调用 &lt;code&gt;ttb:p/2&lt;/code&gt; 之前设置所有模式。</target>
        </trans-unit>
        <trans-unit id="2045d1e31e58946973b89bfa19e30a90c88aef6e" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in a critical path, and can do other things while waiting for the result of this operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process is blocked until the operation has been performed.</source>
          <target state="translated">可以将管理计时器的计时器服务与另一个调度程序放在同一位置，而不是在其上执行调用过程的调度程序。如果是这样，与计时器服务的通信要比其位于本地的时间长得多。如果调用过程处于关键路径中，并且在等待此操作的结果时可以执行其他操作，则需要使用选项 &lt;code&gt;{async, true}&lt;/code&gt; 。如果使用选项 &lt;code&gt;{async, false}&lt;/code&gt; ，则调用过程将被阻塞，直到执行该操作为止。</target>
        </trans-unit>
        <trans-unit id="ea274128cf86d631de77306142f2359eec7a59d8" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in critical path, and can do other things while waiting for the result of this operation, or is not interested in the result of the operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process blocks until the operation has been performed.</source>
          <target state="translated">可以将管理计时器的计时器服务与另一个调度程序放在同一位置，而不是在其上执行调用过程的调度程序。如果是这样，与计时器服务的通信要比其位于本地的时间长得多。如果调用进程处于关键路径中，并且可以在等待此操作的结果时执行其他操作，或者对该操作的结果不感兴趣，则可以使用选项 &lt;code&gt;{async, true}&lt;/code&gt; 。如果使用选项 &lt;code&gt;{async, false}&lt;/code&gt; ，则调用过程将阻塞，直到执行该操作为止。</target>
        </trans-unit>
        <trans-unit id="01c4aedfbe422c954419af25bc2a44ca29efec29" translate="yes" xml:space="preserve">
          <source>The title bar shows the name of the currently loaded crashdump.</source>
          <target state="translated">标题栏显示的是当前加载的crashdump的名称。</target>
        </trans-unit>
        <trans-unit id="ab7219cf5f8f02500259c90d49cef81093f63f21" translate="yes" xml:space="preserve">
          <source>The token's text.</source>
          <target state="translated">令牌的文字。</target>
        </trans-unit>
        <trans-unit id="6e8012793487b53f45a7c5a13441809363cbd8df" translate="yes" xml:space="preserve">
          <source>The tokenization succeeded.</source>
          <target state="translated">标记化成功了。</target>
        </trans-unit>
        <trans-unit id="e263b7ae6b2b75806ba8e04c9ad5e6232730c3db" translate="yes" xml:space="preserve">
          <source>The tokenizer &lt;code&gt;Function&lt;/code&gt; is either a fun or a tuple &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt;. The call &lt;code&gt;apply(Function, Args)&lt;/code&gt; or &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; is executed whenever a new token is needed. This, for example, makes it possible to parse from a file, token by token.</source>
          <target state="translated">标记器 &lt;code&gt;Function&lt;/code&gt; 可以是一个乐趣，也可以是一个元组 &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt; 。每当需要新令牌时，都会执行调用 &lt;code&gt;apply(Function, Args)&lt;/code&gt; 或 &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; 。例如，这使得从文件中逐个令牌解析成为可能。</target>
        </trans-unit>
        <trans-unit id="eecca73e115331e619af23f47c2166b9740b978b" translate="yes" xml:space="preserve">
          <source>The tokenizer used above has to be implemented so as to return one of the following:</source>
          <target state="translated">上面使用的tokenizer必须被实现,以便返回以下之一。</target>
        </trans-unit>
        <trans-unit id="9fe8d55f2a73cae0cc9b243cca2beb4f78cc27a7" translate="yes" xml:space="preserve">
          <source>The tool contain four things:</source>
          <target state="translated">该工具包含四样东西。</target>
        </trans-unit>
        <trans-unit id="fdec03acdbb06629e6819b263973cb293a015233" translate="yes" xml:space="preserve">
          <source>The tool is a textual based tool that asks some questions and generates &lt;code&gt;sys.config&lt;/code&gt; and &lt;code&gt;*.conf&lt;/code&gt; files.</source>
          <target state="translated">该工具是基于文本的工具，它会询问一些问题并生成 &lt;code&gt;sys.config&lt;/code&gt; 和 &lt;code&gt;*.conf&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2cceab8c0f08bcd5eba3c48a52f4f32cc7451571" translate="yes" xml:space="preserve">
          <source>The tool makes it easy to dynamically extend an SNMP agent in run-time. MIBs can be loaded and unloaded at any time. It is also easy to change the implementation of an MIB in run-time, without having to recompile the MIB. The MIB implementation is clearly separated from the agent.</source>
          <target state="translated">该工具可以很容易地在运行时动态扩展SNMP代理。MIB可以在任何时候被加载和卸载。在运行时也很容易改变MIB的实现,而无需重新编译MIB。MIB的实现与代理明确分离。</target>
        </trans-unit>
        <trans-unit id="c57eb5d97f3d1b93c6dc787ae451b8dff86780d1" translate="yes" xml:space="preserve">
          <source>The tool requires Erlang release 4.7 or later.</source>
          <target state="translated">该工具需要 Erlang 4.7 或更高版本。</target>
        </trans-unit>
        <trans-unit id="4074bd4d79edc126504be2941fab21e73161d7fa" translate="yes" xml:space="preserve">
          <source>The tool uses an installed Erlang/OTP system as input. &lt;code&gt;root_dir&lt;/code&gt; is the root directory of the analysed system and it defaults to the system executing Reltool. Applications may also be located outside &lt;code&gt;root_dir&lt;/code&gt;. &lt;code&gt;lib_dirs&lt;/code&gt; defines library directories where additional applications may reside and it defaults to the directories listed by the operating system environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. See the module &lt;code&gt;code&lt;/code&gt; for more info.</source>
          <target state="translated">该工具使用已安装的Erlang / OTP系统作为输入。 &lt;code&gt;root_dir&lt;/code&gt; 是被分析系统的根目录，默认为执行Reltool的系统。应用程序也可能位于 &lt;code&gt;root_dir&lt;/code&gt; 之外。 &lt;code&gt;lib_dirs&lt;/code&gt; 定义了其他应用程序可能驻留的库目录，并且默认为操作系统环境变量 &lt;code&gt;ERL_LIBS&lt;/code&gt; 列出的目录。有关更多信息，请参见模块 &lt;code&gt;code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ed25be45c8a83c834fb6f6c553fb74ad08b92fe" translate="yes" xml:space="preserve">
          <source>The tool(s) are located in the example/meas directory.</source>
          <target state="translated">该工具位于example/meas目录中。</target>
        </trans-unit>
        <trans-unit id="32614a53fcfaa9dead51313db65f2664ea439d19" translate="yes" xml:space="preserve">
          <source>The toolkit allows different kinds of sub-agents at the same time. Accordingly, different MIBs can have different &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt; mechanisms.</source>
          <target state="translated">该工具包允许同时使用不同种类的子代理。因此，不同的MIB可以具有不同的 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 机制。</target>
        </trans-unit>
        <trans-unit id="13a0a8edd61587bef6f837bb6b651cc3f7feb62a" translate="yes" xml:space="preserve">
          <source>The toolkit provides the following:</source>
          <target state="translated">该工具包提供了以下内容:</target>
        </trans-unit>
        <trans-unit id="faaee45e85eb745fc476496ed2d34dbbfaf2f6f6" translate="yes" xml:space="preserve">
          <source>The toolkit supports the use of different types of sub-agents, but not the construction of sub-agents.</source>
          <target state="translated">该工具包支持使用不同类型的子代理,但不支持子代理的构建。</target>
        </trans-unit>
        <trans-unit id="5eca4fd89becaf65e9a29ecebed7de54b42d7b29" translate="yes" xml:space="preserve">
          <source>The tools are further described in &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该工具进一步描述 &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ae2ecc76d77c89a869d00df8f45f0ef79d0325" translate="yes" xml:space="preserve">
          <source>The top directories &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are treated differently from other files. All other files are by default copied to the target system. The &lt;code&gt;releases&lt;/code&gt; directory contains generated &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, and &lt;code&gt;boot&lt;/code&gt; files. The &lt;code&gt;lib&lt;/code&gt; directory contains the applications. Which applications are included and if they should be customized (archived, stripped from debug info etc.) is specified with various configuration parameters. The files in the &lt;code&gt;bin&lt;/code&gt; directory are copied from the &lt;code&gt;erts-vsn/bin&lt;/code&gt; directory, but only those files that were originally included in the &lt;code&gt;bin&lt;/code&gt; directory of the source system.</source>
          <target state="translated">顶级目录 &lt;code&gt;bin&lt;/code&gt; ， &lt;code&gt;releases&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 与其他文件不同。默认情况下，所有其他文件都复制到目标系统。该 &lt;code&gt;releases&lt;/code&gt; 目录包含生成的 &lt;code&gt;rel&lt;/code&gt; ， &lt;code&gt;script&lt;/code&gt; 和 &lt;code&gt;boot&lt;/code&gt; 文件。该 &lt;code&gt;lib&lt;/code&gt; 目录中包含的应用程序。使用各种配置参数指定了包括哪些应用程序以及是否应对其进行定制（已归档，已从调试信息中删除等）。 &lt;code&gt;bin&lt;/code&gt; 目录中的文件是从 &lt;code&gt;erts-vsn/bin&lt;/code&gt; bin目录中复制的，但是只有那些最初包含在 &lt;code&gt;bin&lt;/code&gt; 中的文件 源系统的目录。</target>
        </trans-unit>
        <trans-unit id="ccc5aad2efbe05e6d9003238cc37f069c3a6a12a" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SASL application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="translated">顶级OTP MIB称为 &lt;code&gt;OTP-REG&lt;/code&gt; ，它包含在SASL应用程序中。所有其他OTP MIB都从该MIB导入一些对象。</target>
        </trans-unit>
        <trans-unit id="cf7f727f503b613e132bb04bae92664656fb55cd" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SNMP application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1305c8508861263b9b6e7fe0cb4ed0b43d358486" translate="yes" xml:space="preserve">
          <source>The total amount of memory (measured in bytes) used by all persistent terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84531a2a9183b1d9855e02a467fa0f45db6199b5" translate="yes" xml:space="preserve">
          <source>The total amount of memory available to the Erlang emulator, allocated and free. May or may not be equal to the amount of memory configured in the system.</source>
          <target state="translated">Erlang模拟器可用的内存总量,分配的和空闲的。可能等于也可能不等于系统中配置的内存量。</target>
        </trans-unit>
        <trans-unit id="21349daddbe9f78057ffe41633d03aeff5b4dfff" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for ETS tables. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为ETS表分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="95625ce6b2bc15c6368f74e2c9f00e33024f644c" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for Erlang code. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为Erlang代码分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="92570f02d253003fe52d361898384d0a6cc00fde" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for atoms. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为原子分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="cc60a6cee6312a43f557d00bfccf3deeac83faed" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for binaries. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前分配给二进制文件的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="14e4c7529d5fddaff839bbeef6fdabaf59af1c55" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the Erlang processes.</source>
          <target state="translated">当前为Erlang进程分配的内存总量。</target>
        </trans-unit>
        <trans-unit id="dcd35c53d248b540387eb3145fc89f0c11b8c11e" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt; instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35fa37b02db12b38c932bf76bd09f88b68c5aa2" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="translated">当前为模拟器分配的与任何Erlang进程没有直接关系的内存总量。作为 &lt;code&gt;processes&lt;/code&gt; 显示的内存不包含在此内存中。 &lt;code&gt;instrument(3)&lt;/code&gt; 可以用来更详细地分类该类型的内存。</target>
        </trans-unit>
        <trans-unit id="215b071b6a42f1da89b3697d1f496f661d6aa206" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated. This is the same as the sum of the memory size for &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">当前分配的内存总量。这与 &lt;code&gt;processes&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; 的内存大小总和相同。</target>
        </trans-unit>
        <trans-unit id="a938e56ba158faaa85844dc2539f443bb5a124d9" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used by the Erlang processes. This is part of the memory presented as &lt;code&gt;processes&lt;/code&gt; memory.</source>
          <target state="translated">Erlang进程当前使用的内存总量。这是作为 &lt;code&gt;processes&lt;/code&gt; 内存呈现的一部分内存。</target>
        </trans-unit>
        <trans-unit id="cdab624b2930e224876509f0c625e5e845b4ff1f" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used for atoms. This memory is part of the memory presented as &lt;code&gt;atom&lt;/code&gt; memory.</source>
          <target state="translated">当前用于原子的内存总量。此内存是表示为 &lt;code&gt;atom&lt;/code&gt; 内存的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="1b71f34e8c31d850375dfce0787bd29c0a726617" translate="yes" xml:space="preserve">
          <source>The total lack of memory barrier when reading &lt;code&gt;the_active_code_index&lt;/code&gt; has one interesting consequence however. Different processes may see the new code at different point in time depending on when different cores happen to refresh their hardware caches. This may sound unsafe but it actually does not matter. The only property we must guarantee is that the ability to see the new code must spread with process communication. After receiving a message that was triggered by new code, the receiver must be guaranteed to also see the new code. This will be guaranteed as all types of process communication involves memory barriers in order for the receiver to be sure to read what the sender has written. This implicit memory barrier will then also make sure that the receiver reads the new value of &lt;code&gt;the_active_code_index&lt;/code&gt; and thereby also sees the new code. This is true for all kinds of inter process communication (TCP, ETS, process name registering, tracing, drivers, NIFs, etc) not just Erlang messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73082f62676cad7da8a6972b89ea87b89c66b8f" translate="yes" xml:space="preserve">
          <source>The total memory used by this process, in bytes. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt; erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4493719e0d656453847edcf986d8ecdd8e5d76e" translate="yes" xml:space="preserve">
          <source>The total memory used by this process. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此过程使用的总内存。这包括调用堆栈，堆和内部结构。与 &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="87ecdfb27347e35b213d203586b4706d6725a207" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated, equivalent to &lt;code&gt;c:memory(total)&lt;/code&gt;.</source>
          <target state="translated">分配的字节总数，等于 &lt;code&gt;c:memory(total)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4aacb9a69b73478d5cf380558cf1c9d0f0a175d" translate="yes" xml:space="preserve">
          <source>The total number of bytes, including field &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">字节总数，包括字段 &lt;code&gt;Size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ade9bc9096e43152fdc50c7d93977a724953c2a8" translate="yes" xml:space="preserve">
          <source>The total number of items in all wrap log files.</source>
          <target state="translated">所有包装日志文件中的项目总数。</target>
        </trans-unit>
        <trans-unit id="e26f652c13c599e84a51a316ff52e72ae6c6a549" translate="yes" xml:space="preserve">
          <source>The total run-time of all threads in the system. This is what you get if you call &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt;</source>
          <target state="translated">系统中所有线程的总运行时间。如果调用 &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt; 这就是您得到的。</target>
        </trans-unit>
        <trans-unit id="1a21c70804496cb28140caf8b69b9295c32be2b1" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</source>
          <target state="translated">在做垃圾回收之前,进程中允许虚拟堆中的二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="d53cdb49b3477b983e3f0debbb9d2b84b083cc6a" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</source>
          <target state="translated">在做垃圾回收之前,进程中允许虚拟旧堆中的二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="ebb9f6115c8a24e5086416d9ee44573eb18624a0" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process heap.</source>
          <target state="translated">从进程堆引用的唯一离堆二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="0b0eb863d44dbd5b8e589949207744e47251159f" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process old heap.</source>
          <target state="translated">进程旧堆引用的唯一离堆二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="32449a2d53f2b352b6abd6b8f47cee02d2cabee9" translate="yes" xml:space="preserve">
          <source>The total space required is the result calculated from the information above, plus 1 more byte for a version identifier.</source>
          <target state="translated">所需的总空间是由上述信息计算出来的结果,再加一个字节作为版本标识符。</target>
        </trans-unit>
        <trans-unit id="bd7a2f2d43f93a16c0153ab5248fa17162eed576" translate="yes" xml:space="preserve">
          <source>The total system memory reported under UNIX is the number of physical pages of memory times the page size, and the available memory is the number of available physical pages times the page size. This is a reasonable measure as swapping should be avoided anyway, but the task of defining total memory and available memory is difficult because of virtual memory and swapping.</source>
          <target state="translated">UNIX下报告的系统总内存是内存的物理页数乘以页数,可用内存是可用物理页数乘以页数。这是一个合理的衡量标准,因为无论如何都应该避免交换,但由于虚拟内存和交换,定义总内存和可用内存的任务是困难的。</target>
        </trans-unit>
        <trans-unit id="933816d7250e3513ec4007a083bc6d450febc23e" translate="yes" xml:space="preserve">
          <source>The trace &lt;code&gt;Events&lt;/code&gt; that are hosted by the &lt;code&gt;Collector&lt;/code&gt; may be stored to file and later be loaded by selecting &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; entries in the &lt;code&gt;Viewers&lt;/code&gt;&lt;code&gt;File&lt;/code&gt; menu or via the &lt;code&gt;et_collector&lt;/code&gt; API.</source>
          <target state="translated">可以将 &lt;code&gt;Collector&lt;/code&gt; 托管的跟踪 &lt;code&gt;Events&lt;/code&gt; 存储到文件中，然后通过在 &lt;code&gt;Viewers&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 菜单中选择 &lt;code&gt;save&lt;/code&gt; 和 &lt;code&gt;load&lt;/code&gt; 条目或通过 &lt;code&gt;et_collector&lt;/code&gt; API来加载。</target>
        </trans-unit>
        <trans-unit id="451f68a1cb2620369fda9754c56e9d6942f0eb42" translate="yes" xml:space="preserve">
          <source>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</source>
          <target state="translated">跟踪控制字是一个32位无符号整数,用于通用的跟踪控制。跟踪控制字可以在跟踪匹配规范和BIF中进行测试和设置。只有在跟踪时才允许调用。</target>
        </trans-unit>
        <trans-unit id="c3874cc2a63c677a77b05397368808af525c7352" translate="yes" xml:space="preserve">
          <source>The trace message is passed as the second argument (&lt;code&gt;Trace&lt;/code&gt;). The possible values of &lt;code&gt;Trace&lt;/code&gt; are the following:</source>
          <target state="translated">跟踪消息作为第二个参数（ &lt;code&gt;Trace&lt;/code&gt; ）传递。 &lt;code&gt;Trace&lt;/code&gt; 的可能值如下：</target>
        </trans-unit>
        <trans-unit id="57fe6c1b5e0592fa7721c5593926798fe2d07b25" translate="yes" xml:space="preserve">
          <source>The trace token contains a component called &lt;code&gt;serial&lt;/code&gt;. It consists of two integers, &lt;code&gt;Previous&lt;/code&gt; and &lt;code&gt;Current&lt;/code&gt;. The purpose is to uniquely identify each traced event within a trace sequence, as well as to order the messages chronologically and in the different branches, if any.</source>
          <target state="translated">跟踪令牌包含一个名为 &lt;code&gt;serial&lt;/code&gt; 的组件。它由两个整数组成，即 &lt;code&gt;Previous&lt;/code&gt; 和 &lt;code&gt;Current&lt;/code&gt; 。目的是唯一地标识跟踪序列中的每个跟踪事件，以及按时间顺序并在不同分支（如果有）中对消息进行排序。</target>
        </trans-unit>
        <trans-unit id="ff16088c10d9e1f1e816f51d73d899ab7bb112e4" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="translated">进程每次在接收语句中匹配消息时,都会根据接收到的消息所携带的跟踪令牌设置进程的跟踪令牌,无论是否为空。</target>
        </trans-unit>
        <trans-unit id="ef85d34b0942f0b1907381b47e1d3cc50996d00f" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process receives information. This is typically when the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87d83f502b06a08e3c1d588f50aebd3ae24bfd2" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the information passed to the other process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252314f7c0c5e289f2fcfda50b4df8414eb39ecb" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the message.</source>
          <target state="translated">然后将带有 &lt;code&gt;tprev&lt;/code&gt; 和 &lt;code&gt;tcurr&lt;/code&gt; 的跟踪令牌与消息一起传递。</target>
        </trans-unit>
        <trans-unit id="04a1f28d66267b53ccd9a52f89433c7d9b1ac837" translate="yes" xml:space="preserve">
          <source>The tracing process receives the &lt;strong&gt;trace messages&lt;/strong&gt; described in the following list. &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the traced process in which the traced event has occurred. The third tuple element is the message tag.</source>
          <target state="translated">跟踪过程接收以下列表中描述的&lt;strong&gt;跟踪消息&lt;/strong&gt;。 &lt;code&gt;Pid&lt;/code&gt; 是发生跟踪事件的跟踪进程的进程标识符。第三个元组元素是消息标签。</target>
        </trans-unit>
        <trans-unit id="b59d7a5b365a7b486e7d3f659201ca1fdb7e58e1" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables.</source>
          <target state="translated">事务处理程序确保一个放在事务内部的Fun在对表执行一系列操作时,不会干扰其他事务中嵌入的操作。</target>
        </trans-unit>
        <trans-unit id="70062fd2b1013f2420ee7dc801bcf2c7a5b9ebce" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node.</source>
          <target state="translated">事务处理程序确保事务中的所有操作在所有节点上原子性地成功执行,或者事务失败而对任何节点没有永久影响。</target>
        </trans-unit>
        <trans-unit id="b86538eb6924e406301e4e0cc389da5c07adc8a0" translate="yes" xml:space="preserve">
          <source>The transaction sender is a process (one per connection), which handle all transaction sending, if so configured (see &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">事务发送方是一个进程（每个连接一个），它处理所有事务发送（如果已配置）（请参阅 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="713f769ddf2bd92a6f2c46e6fb622ca19e8a8704" translate="yes" xml:space="preserve">
          <source>The transformation is done _after_ the actual decode has been done.</source>
          <target state="translated">转换是在实际解码完成后进行的。</target>
        </trans-unit>
        <trans-unit id="8ea5cd69dbba346421c19ed7295d3d9115fee3a0" translate="yes" xml:space="preserve">
          <source>The transformation module</source>
          <target state="translated">转换模块</target>
        </trans-unit>
        <trans-unit id="d3b5dbd701325ece1005f2efa209fdb4382b77de" translate="yes" xml:space="preserve">
          <source>The transient mode is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">过渡模式几乎没有实际用途，因为当监视树终止时，原因被设置为 &lt;code&gt;shutdown&lt;/code&gt; ，而不是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279a8ee545cd6d6b2240b842b45553a898172100" translate="yes" xml:space="preserve">
          <source>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply is always very straightforward, but the translation from a v2 MIB to a v1 reply is somewhat more complicated. There is one data type in SMIv2, called &lt;code&gt;Counter64&lt;/code&gt;, that an SNMPv1 manager cannot decode correctly. Therefore, an agent may never send a &lt;code&gt;Counter64&lt;/code&gt; object to an SNMPv1 manager. The common practice in these situations is to simple ignore any &lt;code&gt;Counter64&lt;/code&gt; objects, when sending a reply or a trap to an SNMPv1 manager. For example, if an SNMPv1 manager tries to GET an object of type &lt;code&gt;Counter64&lt;/code&gt;, he will get a &lt;code&gt;noSuchName&lt;/code&gt; error, while an SNMPv2 manager would get a correct value.</source>
          <target state="translated">从SMIv1 MIB到SNMPv2c或SNMPv3答复的转换始终非常简单，但是从v2 MIB到v1答复的转换有些复杂。 SMIv2中有一种称为 &lt;code&gt;Counter64&lt;/code&gt; 的数据类型，SNMPv1管理器无法正确解码。因此，代理可能永远不会将 &lt;code&gt;Counter64&lt;/code&gt; 对象发送到SNMPv1管理器。在这些情况下，通常的做法是在向SNMPv1管理器发送答复或陷阱时简单地忽略任何 &lt;code&gt;Counter64&lt;/code&gt; 对象。例如，如果SNMPv1管理器尝试获取 &lt;code&gt;Counter64&lt;/code&gt; 类型的对象，则将获得 &lt;code&gt;noSuchName&lt;/code&gt; 错误，而SNMPv2管理器将获取正确的值。</target>
        </trans-unit>
        <trans-unit id="d1002669f8eb3c39bdb5b7b84f078a3d57742186" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">通过两个&amp;ldquo;伪函数&amp;rdquo; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 可以访问从funs到匹配规范的转换。</target>
        </trans-unit>
        <trans-unit id="44fa72e8417ca847548609a0551ee3e367444c94" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions.</source>
          <target state="translated">从funs到匹配规格的翻译是在编译时完成的,所以使用这些伪函数不会影响运行时性能。</target>
        </trans-unit>
        <trans-unit id="2cc78b834cad87c9de51c585d4cf589e52c474cd" translate="yes" xml:space="preserve">
          <source>The transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; allows the user to implement their own methods. Ready support is provided for TCP, TCP/TLS, and SCTP, but not DTLS/SCTP.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 记录的传输接口允许用户实现自己的方法。为TCP，TCP / TLS和SCTP提供了就绪支持，但没有提供DTLS / SCTP。</target>
        </trans-unit>
        <trans-unit id="eaa2313e85adab97ab81e1b1e732d457a7d158cf" translate="yes" xml:space="preserve">
          <source>The traversal may fail with &lt;code&gt;badarg&lt;/code&gt; exception if keys are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ad4b1a8b0a2c9907fe25c46b068e77d9c7a9" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and it is not returned by the Solaris API function &lt;code&gt;getaddrinfo()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e689615a4328c7bb2be0d06728d745d0225ff3fd" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and only the superuser can read such addresses.</source>
          <target state="translated">在Solaris上不返回元组 &lt;code&gt;{hwaddr,_}&lt;/code&gt; ，因为硬件地址在历史上属于链接层，并且只有超级用户才能读取此类地址。</target>
        </trans-unit>
        <trans-unit id="734c3a9accbed59c68b041ca30504d986c5e8330" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt; in &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">元组 &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; 包含在 &lt;code&gt;nodedown&lt;/code&gt; 消息的 &lt;code&gt;InfoList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3f43f11b1eaa009f61e78aef8e72ca0bfe4ae132" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c413d0bf6ec66eace53dd4e7a39e8c1f75c0b563" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93c35c8a52aab9fd8efd803c8922b473482b1bda" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">保留元组格式仅是为了向后兼容。首选地图； &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 查看更多详细信息。</target>
        </trans-unit>
        <trans-unit id="2050463a23b37d880e27e3e31bb499a655c1dd4d" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">保留元组格式仅是为了向后兼容。首选地图； &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 查看更多详细信息。</target>
        </trans-unit>
        <trans-unit id="3c70d1de1443033613ebef26319653a179cc6b15" translate="yes" xml:space="preserve">
          <source>The tuple returned from one &lt;code&gt;setelement/3&lt;/code&gt; call must only be used in the subsequent call to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">从一个返回的元组 &lt;code&gt;setelement/3&lt;/code&gt; 呼叫必须只在到随后调用中使用 &lt;code&gt;setelement/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2734d075420144dd036b93083d684214e1714fcd" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,Netmask}&lt;/code&gt;, and possibly &lt;code&gt;{broadaddr,Broadaddr}&lt;/code&gt; or &lt;code&gt;{dstaddr,Dstaddr}&lt;/code&gt; are repeated in the list if the interface has got multiple addresses. An interface may have multiple &lt;code&gt;{flag,_}&lt;/code&gt; tuples for example if it has different flags for different address families. Multiple &lt;code&gt;{hwaddr,Hwaddr}&lt;/code&gt; tuples is hard to say anything definite about, though. The tuple &lt;code&gt;{flag,Flags}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ff128add1588c52d8394da93cf96f601027206" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,_}&lt;/code&gt;, and &lt;code&gt;{broadaddr,_}&lt;/code&gt; are repeated in the result list if the interface has multiple addresses. If you come across an interface with multiple &lt;code&gt;{flag,_}&lt;/code&gt; or &lt;code&gt;{hwaddr,_}&lt;/code&gt; tuples, you have a strange interface or possibly a bug in this function. The tuple &lt;code&gt;{flag,_}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="translated">如果接口具有多个地址，则在结果列表中重复元组 &lt;code&gt;{addr,Addr}&lt;/code&gt; ， &lt;code&gt;{netmask,_}&lt;/code&gt; 和 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 。如果遇到带有多个 &lt;code&gt;{flag,_}&lt;/code&gt; 或 &lt;code&gt;{hwaddr,_}&lt;/code&gt; 元组的接口，那么您的接口可能很奇怪，或者此功能可能有错误。元组 &lt;code&gt;{flag,_}&lt;/code&gt; 是必需的，所有其他都是可选的。</target>
        </trans-unit>
        <trans-unit id="bffca28a508475c37df7d5a78d73209432e6424e" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c792192eae5af5df8655eee98e78f1050f5569af" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="translated">两种 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 提供了不同的可能性和限制，其一个共同目标是：处理事件和状态的所有可能组合。</target>
        </trans-unit>
        <trans-unit id="0298b22c480eceedcea59bf7361f3f9da67e49ce" translate="yes" xml:space="preserve">
          <source>The two flag values can be combined with bitwise OR. The resource type name is local to the calling module. Argument &lt;code&gt;module_str&lt;/code&gt; is not (yet) used and must be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;dtor&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if no destructor is needed.</source>
          <target state="translated">这两个标志值可以与按位OR组合。资源类型名称在调用模块本地。参数 &lt;code&gt;module_str&lt;/code&gt; 没有（还）使用，必须为 &lt;code&gt;NULL&lt;/code&gt; 。如果不需要析构函数，则 &lt;code&gt;dtor&lt;/code&gt; 可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12cd5775794850530c69243a0b35a79255f52a0" translate="yes" xml:space="preserve">
          <source>The two following &lt;code&gt;setelement/3&lt;/code&gt; calls modify the tuple in place.</source>
          <target state="translated">接下来的两个 &lt;code&gt;setelement/3&lt;/code&gt; 调用在适当位置修改了元组。</target>
        </trans-unit>
        <trans-unit id="65274f8639b74e1c1addc358f6c4f02af0256408" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;until_newline/3&lt;/code&gt; and &lt;code&gt;until_enough/3&lt;/code&gt; are helpers used together with function &lt;code&gt;get_until/5&lt;/code&gt; to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; (inefficiently):</source>
          <target state="translated">这两个函数 &lt;code&gt;until_newline/3&lt;/code&gt; 和 &lt;code&gt;until_enough/3&lt;/code&gt; 是与函数 &lt;code&gt;get_until/5&lt;/code&gt; 一起使用的 &lt;code&gt;get_chars&lt;/code&gt; ， &lt;code&gt;get_line&lt;/code&gt; （无效地）实现get_chars和get_line：</target>
        </trans-unit>
        <trans-unit id="66b4872540376e34796f1ec9e420e0053c6366ad" translate="yes" xml:space="preserve">
          <source>The two functions for reloading drivers are to be used together with corresponding load functions to support the two different behaviors concerning open ports:</source>
          <target state="translated">这两个用于重装驱动程序的函数要和相应的加载函数一起使用,以支持关于开放端口的两种不同行为。</target>
        </trans-unit>
        <trans-unit id="9c0c4d47161e2b26102273194fa251a585e05de6" translate="yes" xml:space="preserve">
          <source>The two index search functions described here are automatically started when searching tables with &lt;code&gt;qlc&lt;/code&gt; list comprehensions and also when using the low-level &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; functions.</source>
          <target state="translated">当使用 &lt;code&gt;qlc&lt;/code&gt; 列表理解搜索表时以及使用低级 &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; 函数时，将自动启动此处描述的两个索引搜索功能。</target>
        </trans-unit>
        <trans-unit id="246d94548a4e439a2a10c8f1eb4458a0f48f069d" translate="yes" xml:space="preserve">
          <source>The two main interfaces for running tests with &lt;code&gt;Common Test&lt;/code&gt; are an executable program named &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; and the Erlang module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_run&lt;/code&gt; is compiled for the underlying operating system (for example, Unix/Linux or Windows) during the build of the Erlang/OTP system, and is installed automatically with other executable programs in the top level &lt;code&gt;bin&lt;/code&gt; directory of Erlang/OTP. The &lt;code&gt;ct&lt;/code&gt; interface functions can be called from the Erlang shell, or from any Erlang function, on any supported platform.</source>
          <target state="translated">使用 &lt;code&gt;Common Test&lt;/code&gt; 运行测试的两个主要接口是名为 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 的可执行程序和Erlang模块 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ct_run&lt;/code&gt; 在构建Erlang / OTP系统期间针对基础操作系统（例如Unix / Linux或Windows）进行编译，并与其他可执行程序一起自动安装在Erlang / OTP的顶级 &lt;code&gt;bin&lt;/code&gt; 目录中。在 &lt;code&gt;ct&lt;/code&gt; 接口功能可以从Erlang shell的调用，也可以从任何Erlang的功能，在任何支持的平台。</target>
        </trans-unit>
        <trans-unit id="1eed66d650bf2a2472423671355f16a5f1ae975a" translate="yes" xml:space="preserve">
          <source>The two major components of the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; tool is a graphical sequence chart viewer (&lt;code&gt;et_viewer&lt;/code&gt;) and its backing storage (&lt;code&gt;et_collector&lt;/code&gt;). One &lt;code&gt;Collector&lt;/code&gt; may be used as backing storage for several simultaneous &lt;code&gt;Viewers&lt;/code&gt; where each one may display a different view of the same trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 工具的两个主要组件是图形序列图查看器（ &lt;code&gt;et_viewer&lt;/code&gt; ）及其后备存储（ &lt;code&gt;et_collector&lt;/code&gt; ）。一个 &lt;code&gt;Collector&lt;/code&gt; 可以用作多个同时 &lt;code&gt;Viewers&lt;/code&gt; 备份存储，其中每个查看器可以显示相同跟踪数据的不同视图。</target>
        </trans-unit>
        <trans-unit id="b0b98c5ee144a7e629e6a186d5b34f7dc5bb41d7" translate="yes" xml:space="preserve">
          <source>The two occurrences of &lt;code&gt;N&lt;/code&gt; are not related. The compiler will complain that the &lt;code&gt;N&lt;/code&gt; in the size field is unbound.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 的两次出现无关。编译器将抱怨size字段中的 &lt;code&gt;N&lt;/code&gt; 未绑定。</target>
        </trans-unit>
        <trans-unit id="8c1e49fb3411cc8e5831e0be0f58277a39603aae" translate="yes" xml:space="preserve">
          <source>The two parts of the &lt;code&gt;convert&lt;/code&gt; function are called its clauses. As shown, &lt;code&gt;miles&lt;/code&gt; is not part of either of the clauses. The Erlang system cannot &lt;strong&gt;match&lt;/strong&gt; either of the clauses so an error message &lt;code&gt;function_clause&lt;/code&gt; is returned. The shell formats the error message nicely, but the error tuple is saved in the shell's history list and can be output by the shell command &lt;code&gt;v/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 函数的两个部分称为其子句。如图所示， &lt;code&gt;miles&lt;/code&gt; 数不是任何条款的一部分。Erlang系统无法&lt;strong&gt;匹配&lt;/strong&gt;任何一个子句，因此将返回错误消息 &lt;code&gt;function_clause&lt;/code&gt; 。Shell很好地格式化了错误消息，但是错误元组保存在Shell的历史记录列表中，并且可以由Shell命令 &lt;code&gt;v/1&lt;/code&gt; 输出：</target>
        </trans-unit>
        <trans-unit id="ef209651a9fdf27bee622b273ceb5f16c1a1ba01" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;BIT STRING&lt;/code&gt; can be used to model information that is made up of arbitrary length series of bits. It is intended to be used for selection of flags, not for binary files.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 类型可用于对由任意长度的位系列组成的信息进行建模。它旨在用于选择标志，而不用于二进制文件。</target>
        </trans-unit>
        <trans-unit id="ae16e6086ff80fdbd8c4ef671e6092d385270bd3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;CHOICE&lt;/code&gt; is a space saver and is similar to the concept of a 'union' in C.</source>
          <target state="translated">&lt;code&gt;CHOICE&lt;/code&gt; 类型可节省空间，类似于C语言中&amp;ldquo;联合&amp;rdquo;的概念。</target>
        </trans-unit>
        <trans-unit id="965f2c85137cbf54f06adf43202eea3af0164d29" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;ENUMERATED&lt;/code&gt; can be used when the value you want to describe can only take one of a set of predefined values. Example:</source>
          <target state="translated">当您要描述的值只能采用一组预定义值之一时，可以使用 &lt;code&gt;ENUMERATED&lt;/code&gt; 类型。例：</target>
        </trans-unit>
        <trans-unit id="c0ca634710fd8cc8e3767efb8dc71dc3f784baaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;EXTERNAL&lt;/code&gt; had a slightly different associated type before 1994. X.691 states that encoding must follow the older associated type. So, generated encode/decode functions convert values of the newer format to the older format before encoding. This implies that it is allowed to use &lt;code&gt;EXTERNAL&lt;/code&gt; type values of either format for encoding. Decoded values are always returned in the newer format.</source>
          <target state="translated">在1994年之前，类型 &lt;code&gt;EXTERNAL&lt;/code&gt; 的关联类型略有不同。X.691声明编码必须遵循旧的关联类型。因此，生成的编码/解码函数在编码之前将较新格式的值转换为较旧格式。这意味着允许使用两种格式的 &lt;code&gt;EXTERNAL&lt;/code&gt; 类型值进行编码。解码后的值始终以较新的格式返回。</target>
        </trans-unit>
        <trans-unit id="b96d9ad7628789a455a00e354d8f85bc83f8dcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;MACRO&lt;/code&gt; is not supported. It is no longer part of the ASN.1 standard.</source>
          <target state="translated">不支持 &lt;code&gt;MACRO&lt;/code&gt; 类型。它不再是ASN.1标准的一部分。</target>
        </trans-unit>
        <trans-unit id="aa57b7a761159ee02439dd9f7a7248614deec258" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;NULL&lt;/code&gt; is suitable where supply and recognition of a value is important but the actual value is not.</source>
          <target state="translated">在提供和识别值很重要而实际值不重要的情况下， &lt;code&gt;NULL&lt;/code&gt; 类型适用。</target>
        </trans-unit>
        <trans-unit id="8f171db85c218b70d6addcc8e6fc151a7cbbadd9" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is used whenever a unique identity is required. An ASN.1 module, a transfer syntax, and so on, is identified with an &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. Assume the following example:</source>
          <target state="translated">只要需要唯一 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 就使用对象标识类型。ASN.1模块，传输语法等由 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 标识。假设以下示例：</target>
        </trans-unit>
        <trans-unit id="9360300fbf341e9ae2dadc1fc262f79e78fb2fc1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TimeOut&lt;/code&gt; has the default value &lt;code&gt;infinity&lt;/code&gt;, so for instance:</source>
          <target state="translated">类型 &lt;code&gt;TimeOut&lt;/code&gt; 具有默认值 &lt;code&gt;infinity&lt;/code&gt; ，因此例如：</target>
        </trans-unit>
        <trans-unit id="25b9026ac150bd3535441298ee5fe811ce22b776" translate="yes" xml:space="preserve">
          <source>The type a port has when it is opened, but not bound to any file descriptor.</source>
          <target state="translated">端口打开时的类型,但不与任何文件描述符绑定。</target>
        </trans-unit>
        <trans-unit id="92d522e36d256191ae801d58140abe1b10a81a7f" translate="yes" xml:space="preserve">
          <source>The type checking in the SEQUENCE construct is non-strict (i.e. subtypes may be specified). The reason for this is that some standard MIBs use this.</source>
          <target state="translated">SEQUENCE构造中的类型检查是非严格的(即可以指定子类型)。这样做的原因是一些标准的MIB使用了这一点。</target>
        </trans-unit>
        <trans-unit id="1be2df477daeda02d0883ed07f5157d20b6857d8" translate="yes" xml:space="preserve">
          <source>The type definition for a child specification is as follows:</source>
          <target state="translated">子规范的类型定义如下:</target>
        </trans-unit>
        <trans-unit id="a191726a17db26ad276e59c3d2dbd9a5d58a79fa" translate="yes" xml:space="preserve">
          <source>The type definition of a child specification is as follows:</source>
          <target state="translated">子规范的类型定义如下:</target>
        </trans-unit>
        <trans-unit id="6def97965eb0171fce707fed1d80f680f68afe44" translate="yes" xml:space="preserve">
          <source>The type name is the atom &lt;code&gt;my_struct_type&lt;/code&gt;, followed by parentheses. &lt;code&gt;Type&lt;/code&gt; is a type as defined in the previous section. A current restriction is that &lt;code&gt;Type&lt;/code&gt; can contain only predefined types, or user-defined types which are either of the following:</source>
          <target state="translated">类型名称是原子 &lt;code&gt;my_struct_type&lt;/code&gt; ，后跟括号。 &lt;code&gt;Type&lt;/code&gt; 是上一节中定义的类型。当前的限制是 &lt;code&gt;Type&lt;/code&gt; 只能包含预定义类型或以下两种用户定义的类型：</target>
        </trans-unit>
        <trans-unit id="309c924e1cd088d894f3ed5124531ce4037037e9" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55a401f10752570792b382f21d74eedbc9c46cc7" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88149033eb0717d0b52143637014a89740d11a73" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e5d162e866719ba45f57bb291d7dab0d1fc5d64" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="329ae914482ca32cea66526a39a0dbcd107a797e" translate="yes" xml:space="preserve">
          <source>The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are &lt;code&gt;undefined&lt;/code&gt; and the Diameter types: &lt;code&gt;OctetString&lt;/code&gt;, &lt;code&gt;Integer32&lt;/code&gt;, &lt;code&gt;Integer64&lt;/code&gt;, &lt;code&gt;Unsigned32&lt;/code&gt;, &lt;code&gt;Unsigned64&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, &lt;code&gt;Float64&lt;/code&gt;, &lt;code&gt;Grouped&lt;/code&gt;, &lt;code&gt;Enumerated&lt;/code&gt;, &lt;code&gt;Address&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;UTF8String&lt;/code&gt;, &lt;code&gt;DiameterIdentity&lt;/code&gt;, &lt;code&gt;DiameterURI&lt;/code&gt;, &lt;code&gt;IPFilterRule&lt;/code&gt; and &lt;code&gt;QoSFilterRule&lt;/code&gt;.</source>
          <target state="translated">在相关字典文件（或它继承的字典文件）中指定的AVP类型。可能的类型是 &lt;code&gt;undefined&lt;/code&gt; 和Diameter类型： &lt;code&gt;OctetString&lt;/code&gt; ， &lt;code&gt;Integer32&lt;/code&gt; ， &lt;code&gt;Integer64&lt;/code&gt; ， &lt;code&gt;Unsigned32&lt;/code&gt; ， &lt;code&gt;Unsigned64&lt;/code&gt; ， &lt;code&gt;Float32&lt;/code&gt; ， &lt;code&gt;Float64&lt;/code&gt; ， &lt;code&gt;Grouped&lt;/code&gt; ， &lt;code&gt;Enumerated&lt;/code&gt; ， &lt;code&gt;Address&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;UTF8String&lt;/code&gt; ， &lt;code&gt;DiameterIdentity&lt;/code&gt; ， &lt;code&gt;DiameterURI&lt;/code&gt; ， &lt;code&gt;IPFilterRule&lt;/code&gt; 和 &lt;code&gt;QoSFilterRule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">文件的类型。</target>
        </trans-unit>
        <trans-unit id="e102bd5c8529a3fcee9a46e71dac57efe0a0a2dd" translate="yes" xml:space="preserve">
          <source>The type of the padding as provided in the call ot &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0aaded2e1891fac9206e8409a5f01261f2d116" translate="yes" xml:space="preserve">
          <source>The type tag of a syntax tree node may also be used as a primary tag by the &lt;code&gt;erl_parse&lt;/code&gt; representation; in that case, the selector functions for that node type &lt;strong&gt;must&lt;/strong&gt; handle both the abstract syntax tree and the &lt;code&gt;erl_parse&lt;/code&gt; form. The function &lt;code&gt;type(T)&lt;/code&gt; should return the correct type tag regardless of the representation of &lt;code&gt;T&lt;/code&gt;, so that the user sees no difference between &lt;code&gt;erl_syntax&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt; nodes.</source>
          <target state="translated">语法树节点的类型标签也可以通过 &lt;code&gt;erl_parse&lt;/code&gt; 表示用作主要标签；在这种情况下，该节点类型的选择器函数&lt;strong&gt;必须同时&lt;/strong&gt;处理抽象语法树和 &lt;code&gt;erl_parse&lt;/code&gt; 形式。无论 &lt;code&gt;T&lt;/code&gt; 的表示形式如何，函数 &lt;code&gt;type(T)&lt;/code&gt; 都应返回正确的类型标记，以便用户看不到 &lt;code&gt;erl_syntax&lt;/code&gt; 和 &lt;code&gt;erl_parse&lt;/code&gt; 节点之间的区别。</target>
        </trans-unit>
        <trans-unit id="fe3202d206f4f93d7d4689f53e891b3fc4e897bc" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt; have been removed from the standard since 1994. It is recommended not to use these types any more. They can, however, exist in some old ASN.1 modules. The idea with this type was to leave a &quot;hole&quot; in a definition where it was possible to put unspecified data of any kind, even non-ASN.1 data.</source>
          <target state="translated">自1994年以来已将 &lt;code&gt;ANY&lt;/code&gt; 和 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 类型从标准中删除。建议不要再使用这些类型。但是，它们可以存在于某些旧的ASN.1模块中。这种类型的想法是在定义中留下&amp;ldquo;漏洞&amp;rdquo;，在其中可以放置任何类型的未指定数据，甚至是非ASN.1数据。</target>
        </trans-unit>
        <trans-unit id="7d97ad7fc3d758f8f7503253b112a82e8b959c1f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;EXTERNAL&lt;/code&gt;, &lt;code&gt;EMBEDDED PDV&lt;/code&gt;, and &lt;code&gt;CHARACTER STRING&lt;/code&gt; are used in presentation layer negotiation. They are encoded according to their associated type, see X.680.</source>
          <target state="translated">表示层协商中使用 &lt;code&gt;EXTERNAL&lt;/code&gt; ， &lt;code&gt;EMBEDDED PDV&lt;/code&gt; 和 &lt;code&gt;CHARACTER STRING&lt;/code&gt; 类型。它们根据其关联的类型进行编码，请参阅X.680。</target>
        </trans-unit>
        <trans-unit id="31206f08c9e0b285f83486faa623acb15de23275" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt; correspond to the concept of an array in several programming languages. The Erlang syntax for both types is straightforward, for example:</source>
          <target state="translated">&lt;code&gt;SET OF&lt;/code&gt; 和 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 类型对应于几种编程语言中的数组概念。两种类型的Erlang语法都很简单，例如：</target>
        </trans-unit>
        <trans-unit id="b29412cfed4840e6735cd1786ded80d86e51e8fe" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; specifies encoding/decoding of the &lt;strong&gt;Unicode Transformation Format&lt;/strong&gt;s UTF-8, UTF-16, and UTF-32, respectively.</source>
          <target state="translated">类型 &lt;code&gt;utf8&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 分别指定&lt;strong&gt;Unicode转换格式&lt;/strong&gt;的UTF-8，UTF-16和UTF-32的编码/解码。</target>
        </trans-unit>
        <trans-unit id="45d28fc4f610ea2772ed9802ce16df2bd01cc6f6" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt; relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397ab02499d0458aff045535e75d83bc31f4cbeb" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="translated">这些类型用于实现集合必须满足的各种条件。例如，考虑两组R和S的相对乘积，并回想一下，如果R是与Y的二元关系，而S是来自Y的二元关系，则定义R和S的相对积。实现该相对关系的函数产品， &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt; ，通过将[{A，B}]与第一个参数的类型（例如Arg1说）和[{C，D}]与第二个参数的类型（例如Arg2说）进行匹配来检查参数是否表示二进制关系。 [{A，B}]与Arg1类型匹配的事实将被解释为Arg1，代表从X到Y的二进制关系，其中X被定义为Set中的某个元素x的所有Set Set（x）。这是A，并且类似地表示Y。以相同的方式，将Arg2解释为表示从W到Z的二进制关系。最后检查B是否匹配C，这足以确保W等于Y。 set单独处理：其类型['_']与任何无序集合的类型匹配。</target>
        </trans-unit>
        <trans-unit id="92a2f2f4039eb9cab39f41c392f86d30d282c1cf" translate="yes" xml:space="preserve">
          <source>The types of errors that may occur can be divide into the following categories.</source>
          <target state="translated">可能出现的错误类型可分为以下几类。</target>
        </trans-unit>
        <trans-unit id="ccc80a70996f3fb5f7ac83b02a6f6f55b6b8c98c" translate="yes" xml:space="preserve">
          <source>The types of record fields can be specified in the declaration of the record. The syntax for this is as follows:</source>
          <target state="translated">记录字段的类型可以在记录的声明中指定。其语法如下:</target>
        </trans-unit>
        <trans-unit id="b0b9fd9ae89eff0834b9b47daece1217c2da1a05" translate="yes" xml:space="preserve">
          <source>The types that follow do a type test of the operand at runtime; thus, they are generally more expensive in terms of runtime than the types described earlier. However, those operand types are needed to avoid a combinatorial explosion in the number of specific instructions and overall code size of &lt;code&gt;process_main()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b6e93a6a81ebbecd527612eefc77626b9faa25" translate="yes" xml:space="preserve">
          <source>The types that follows are all applied to an operand that has the &lt;code&gt;u&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015a6a68261fd2baee3f181670e406ef25582853" translate="yes" xml:space="preserve">
          <source>The typical round-trip of a message can be viewed as follows. Firstly we view the call flow on the originating side:</source>
          <target state="translated">一个消息的典型往返可以这样来看。首先我们查看发信端的呼叫流程。</target>
        </trans-unit>
        <trans-unit id="ffb34ce1e3c3b26351d07518729543600aa64ad5" translate="yes" xml:space="preserve">
          <source>The typical use case for &lt;code&gt;write_concurrency&lt;/code&gt; is when concurrent calls to &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; toward the same counters are very frequent, while calls to &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;get &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;put&lt;/a&gt;&lt;/code&gt; are much less frequent. The lack of absolute read consistency must also be acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a092e2bd3b4745048655568b0b490cb79d98d82c" translate="yes" xml:space="preserve">
          <source>The unit of measurement is memory words. There exists both a 32-bit and a 64-bit implementation. A word is therefore 4 bytes or 8 bytes, respectively.</source>
          <target state="translated">计量单位是内存字。有32位和64位两种实现方式。因此,一个字分别是4个字节或8个字节。</target>
        </trans-unit>
        <trans-unit id="d78579febd40e018de674b923ab2dd8480cc6d1a" translate="yes" xml:space="preserve">
          <source>The unit size is given as &lt;code&gt;unit:IntegerLiteral&lt;/code&gt;. The allowed range is 1-256. It is multiplied by the &lt;code&gt;Size&lt;/code&gt; specifier to give the effective size of the segment. The unit size specifies the alignment for binary segments without size.</source>
          <target state="translated">单位大小以 &lt;code&gt;unit:IntegerLiteral&lt;/code&gt; 的形式给出。允许的范围是1-256。乘以 &lt;code&gt;Size&lt;/code&gt; 说明符即可得出段的有效大小。单位大小指定没有大小的二进制段的对齐方式。</target>
        </trans-unit>
        <trans-unit id="5ee4d7b5711971b4db427f1d7dcb1848a313bcc2" translate="yes" xml:space="preserve">
          <source>The unload request is registered, but other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still hold the driver. Notice that the term &lt;code&gt;pending_process&lt;/code&gt; can refer to the running process; there can be more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; in the same process.</source>
          <target state="translated">卸载请求已注册，但其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 仍保留驱动程序。注意，术语&amp;ldquo; &lt;code&gt;pending_process&lt;/code&gt; &amp;rdquo;可以指代正在运行的进程。同一过程中可以有多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92c5b2b8040b8ecbc28851e51c3e75943648293" translate="yes" xml:space="preserve">
          <source>The unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver in question while in progress.</source>
          <target state="translated">卸载/加载是作为一个原子操作来完成的,在进行中会阻止系统中的所有进程使用相关驱动。</target>
        </trans-unit>
        <trans-unit id="b2bb7ad491dec5db9c49126bb51367d385e40bcc" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt64&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt64&lt;/code&gt; are always 64 bits wide. They were introduced in ERTS 5.7.4.</source>
          <target state="translated">无符号整数数据类型 &lt;code&gt;ErlDrvUInt64&lt;/code&gt; 和有符号整数数据类型 &lt;code&gt;ErlDrvSInt64&lt;/code&gt; 始终为64位宽。它们是在ERTS 5.7.4中引入的。</target>
        </trans-unit>
        <trans-unit id="06cd090adf77b790656c62fa3caa0f561db0b42b" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt&lt;/code&gt; are 64 bits wide on a 64-bit runtime system and 32 bits wide on a 32-bit runtime system. They were introduced in ERTS 5.6 and replaced some of the &lt;code&gt;int&lt;/code&gt; arguments in the list above.</source>
          <target state="translated">在64位运行时系统中，无符号整数数据类型 &lt;code&gt;ErlDrvUInt&lt;/code&gt; 和有符号整数数据类型 &lt;code&gt;ErlDrvSInt&lt;/code&gt; 为64位宽，在32位运行时系统中为32位宽。它们是在ERTS 5.6中引入的，并替换了上面列表中的一些 &lt;code&gt;int&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="d4dbe8cb85a6484b8db2e5ddc4f7e81602e6c250" translate="yes" xml:space="preserve">
          <source>The unsigned integer value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="634b3eb0cccf55ffe20b68558982833221c90d25" translate="yes" xml:space="preserve">
          <source>The unsleeping reader may notice that the ACC times for &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; and &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; is not equal between the paragraphs above, even though it is easy to believe that &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is just a passthrough function.</source>
          <target state="translated">熟睡中的读者可能会注意到 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 和 &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 的ACC时间在以上各段之间并不相等，尽管很容易相信 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 只是一个传递函数。</target>
        </trans-unit>
        <trans-unit id="53c140ed888506c0fa3ce30e4732a3ab8d9bef72" translate="yes" xml:space="preserve">
          <source>The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if the request is acknowledged, the upgrade to tls is performed.</source>
          <target state="translated">升级分两个阶段进行:首先询问服务器是否允许升级。第二,如果请求被确认,则升级到tls。</target>
        </trans-unit>
        <trans-unit id="f1abe4219b1176145faaf51a5d5248cfe9c5cdbb" translate="yes" xml:space="preserve">
          <source>The upgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;upgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">然后可以使用 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 评估升级脚本。建议改用 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; ，但是此函数（ &lt;code&gt;upgrade_script&lt;/code&gt; ）对检查脚本的内容很有用。</target>
        </trans-unit>
        <trans-unit id="66b6bbe8cee241bbe5ef7774f674afa0a63f5765" translate="yes" xml:space="preserve">
          <source>The upgrade was refused by the LDAP server. The &lt;code&gt;ResponseFromServer&lt;/code&gt; is an atom delivered byt the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is still un-encrypted.</source>
          <target state="translated">LDAP服务器拒绝升级。该 &lt;code&gt;ResponseFromServer&lt;/code&gt; 是BYT LDAP服务器递送的原子在部分RFC 2830的连接的2.3不受影响解释的，所以还是未加密。</target>
        </trans-unit>
        <trans-unit id="24e4c40c9265bed4ba5b9b42f433f1e4b84ab6f0" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the allocated block size histograms. Defaults to 128.</source>
          <target state="translated">分配的块大小直方图中第一个区间的上界。默认值为128。</target>
        </trans-unit>
        <trans-unit id="cbc1809e93754ae11d777adddcabee5582e3ea4f" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the free block size histograms. Defaults to 512.</source>
          <target state="translated">自由块大小直方图中第一个区间的上界。默认值为512。</target>
        </trans-unit>
        <trans-unit id="49138c2017ae769df1dbe3fdeaaab6a9e2775cc2" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval is provided by the function that returned the histogram, and the last interval has no upper bound.</source>
          <target state="translated">第一个区间的上界由返回直方图的函数提供,最后一个区间没有上界。</target>
        </trans-unit>
        <trans-unit id="0dc8cf3ce6b3c8880a720af10de4f0e69e030978" translate="yes" xml:space="preserve">
          <source>The uppercase escapes match the inverse sets of characters. Notice that \d matches only decimal digits, while \w matches any Unicode digit, any Unicode letter, and underscore. Notice also that &lt;code&gt;ucp&lt;/code&gt; affects \b and \B, as they are defined in terms of \w and \W. Matching these sequences is noticeably slower when &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">大写转义符与字符的相反集合匹配。请注意，\ d仅匹配十进制数字，而\ w匹配任何Unicode数字，任何Unicode字母和下划线。还要注意， &lt;code&gt;ucp&lt;/code&gt; 影响\ b和\ B，因为它们是根据\ w和\ W定义的。设置 &lt;code&gt;ucp&lt;/code&gt; 时，匹配这些序列的速度明显较慢。</target>
        </trans-unit>
        <trans-unit id="b043a2c5698c1e7d1fd873979502125e49e702d8" translate="yes" xml:space="preserve">
          <source>The use and effect of the actions are as follows:</source>
          <target state="translated">这些行动的用途和效果如下:</target>
        </trans-unit>
        <trans-unit id="ca7d622dd82e1d3aeae321fc0b43126901f71c4f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt; enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea64d7717e78cf5f593ec4e6046b9c45fcf5ca9f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="translated">使用资源对象是从NIF返回指向本机数据结构的指针的安全方法。资源对象只是使用 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 分配的内存块。然后，可以使用 &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 将指向该内存块的句柄（&amp;ldquo;安全指针&amp;rdquo;）返回给Erlang 。 &lt;code&gt;enif_make_resource&lt;/code&gt; 返回的术语实际上是不透明的。可以在进程之间存储和传递它，但真正的最终用途是将其作为参数传递回NIF。然后，NIF可以调用 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 并返回指向该内存块的指针，该指针仍然有效。直到最后一个句柄项被VM垃圾回收并且使用以下命令释放资源后，才释放资源对象： &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; （不一定按此顺序）。</target>
        </trans-unit>
        <trans-unit id="7d704eb78317ca9acd08384d4f2bcb2bb1355fb7" translate="yes" xml:space="preserve">
          <source>The use of the &lt;code&gt;flags&lt;/code&gt; field is that any flag provided must exist for the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd42e11d00d705e28195f82bd49864a0d14541e" translate="yes" xml:space="preserve">
          <source>The use of the match operator is particularly useful for pulling apart Erlang terms and creating new ones.</source>
          <target state="translated">匹配操作符的使用对于拆分Erlang术语和创建新的术语特别有用。</target>
        </trans-unit>
        <trans-unit id="9361a4a5f036e16a92bbb4fe0af3e2c751d37ab7" translate="yes" xml:space="preserve">
          <source>The use of this option has always been discouraged. As from R14A, it is an error to use it.</source>
          <target state="translated">一直不鼓励使用该选项。从R14A开始,使用该选项是一种错误。</target>
        </trans-unit>
        <trans-unit id="6184f0737f651dbcd0feb09612ee2a07afce0951" translate="yes" xml:space="preserve">
          <source>The use of this strategy of abandoning carriers with poor utilization and reusing them in allocator instances with an increased carrier demand is extremely effective and completely eliminates the problems that otherwise sometimes occurred when CPU load dropped while memory load did not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7051fa8cce86b7e9e63652f268c7db87c6180ee0" translate="yes" xml:space="preserve">
          <source>The used memory for all ETS tables.</source>
          <target state="translated">所有ETS表的使用内存。</target>
        </trans-unit>
        <trans-unit id="8f9be74fa1ece2bebb8a5ba0433d42158ebba618" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;otptest&lt;/code&gt;, which has bash as default shell, uses the &lt;code&gt;ssh:shell/1&lt;/code&gt; client to connect to the &lt;strong&gt;openssh&lt;/strong&gt; daemon running on a host called &lt;strong&gt;tarlop&lt;/strong&gt;:</source>
          <target state="translated">拥有 &lt;code&gt;otptest&lt;/code&gt; 作为默认shell 的用户otptest使用 &lt;code&gt;ssh:shell/1&lt;/code&gt; 客户端连接到在名为&lt;strong&gt;tarlop&lt;/strong&gt;的主机上运行的&lt;strong&gt;openssh&lt;/strong&gt;守护程序：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d301c340a5de16be3a33995e9e04d1a25c73f970" translate="yes" xml:space="preserve">
          <source>The user can include this AVP as required.</source>
          <target state="translated">用户可以根据需要加入这个AVP。</target>
        </trans-unit>
        <trans-unit id="b476a06d8305252521da860471bca0c708d1246d" translate="yes" xml:space="preserve">
          <source>The user can provide a test specification including (for &lt;code&gt;Common Test&lt;/code&gt;) unrecognizable terms. If this is desired, use flag &lt;code&gt;-allow_user_terms&lt;/code&gt; when starting tests with &lt;code&gt;ct_run&lt;/code&gt;. This forces &lt;code&gt;Common Test&lt;/code&gt; to ignore unrecognizable terms. In this mode, &lt;code&gt;Common Test&lt;/code&gt; is not able to check the specification for errors as efficiently as if the scanner runs in default mode. If &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; is used for starting the tests, the relaxed scanner mode is enabled by tuple &lt;code&gt;{allow_user_terms,true}&lt;/code&gt;.</source>
          <target state="translated">用户可以提供测试规范，包括（对于 &lt;code&gt;Common Test&lt;/code&gt; ）无法识别的术语。如果 &lt;code&gt;-allow_user_terms&lt;/code&gt; 在使用ct_run启动测试时使用标志 &lt;code&gt;ct_run&lt;/code&gt; 。这迫使 &lt;code&gt;Common Test&lt;/code&gt; 忽略无法识别的术语。在这种模式下， &lt;code&gt;Common Test&lt;/code&gt; 无法像在默认模式下运行扫描程序那样高效地检查规范中的错误。如果使用 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 启动测试，则元组 &lt;code&gt;{allow_user_terms,true}&lt;/code&gt; 启用宽松的扫描器模式。</target>
        </trans-unit>
        <trans-unit id="aec8dfaf1d2231e245fe0cd75a270293f3d428b2" translate="yes" xml:space="preserve">
          <source>The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; when starting Erlang.</source>
          <target state="translated">用户可以请求通过外壳程序和格式化功能在字符串的启发式检测中被认为可打印的一系列字符。这是通过在启动Erlang时提供 &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="5ae2400e1fce55a0b4d9b7318948b8627b3d6a40" translate="yes" xml:space="preserve">
          <source>The user can specify a specific group path with parameter &lt;code&gt;group_names_or_paths&lt;/code&gt;. With this type of specification execution of unwanted groups (in otherwise matching paths), and/or the execution of subgroups can be avoided. The command line syntax of the group path is a list of group names in the path, for example:</source>
          <target state="translated">用户可以使用参数 &lt;code&gt;group_names_or_paths&lt;/code&gt; 指定特定的组路径。通过这种类型的规范，可以避免执行不需要的组（在其他匹配路径中）和/或执行子组。组路径的命令行语法是路径中组名称的列表，例如：</target>
        </trans-unit>
        <trans-unit id="0130ad65a7625b17e035e835fe6eaf0679e0f246" translate="yes" xml:space="preserve">
          <source>The user can specify configuration data on a different format than key-value tuples in a text file, as described so far. The data can, for example, be read from any files, fetched from the web over HTTP, or requested from a user-specific process. To support this, &lt;code&gt;Common Test&lt;/code&gt; provides a callback module plugin mechanism to handle configuration data.</source>
          <target state="translated">到目前为止，用户可以使用与文本文件中的键值元组不同的格式来指定配置数据。例如，可以从任何文件中读取数据，通过HTTP从Web上获取数据，或从特定于用户的进程中请求数据。为此， &lt;code&gt;Common Test&lt;/code&gt; 提供了一个回调模块插件机制来处理配置数据。</target>
        </trans-unit>
        <trans-unit id="660461224293f1991c368482cebc005aee961e52" translate="yes" xml:space="preserve">
          <source>The user configures diameter with the identifiers to send at capabilities exchange, along with corresponding dictionaries defining the messages of the applications.</source>
          <target state="translated">用户在能力交换时配置直径与要发送的标识符,以及相应的字典,定义应用的消息。</target>
        </trans-unit>
        <trans-unit id="b475ffe342e790093cd964ba6cc829f6bd45785f" translate="yes" xml:space="preserve">
          <source>The user constructs application-specific messages, but diameter provides failed AVPs in message callbacks. Failed component AVPs are grouped within the relevant Grouped AVPs.</source>
          <target state="translated">用户构建特定的应用程序消息,但直径在消息回调中提供失败的AVP。失败的组件AVPs被归入相关的Grouped AVPs中。</target>
        </trans-unit>
        <trans-unit id="3591203b72caf861e6110120cbe93c01af2b88a2" translate="yes" xml:space="preserve">
          <source>The user decides whether or not to process a request locally in the request callback from diameter.</source>
          <target state="translated">用户在来自直径的请求回调中决定是否在本地处理一个请求。</target>
        </trans-unit>
        <trans-unit id="3464961bd356a69bfcff6ac160a461e76a93d25f" translate="yes" xml:space="preserve">
          <source>The user has explicitly cancelled the wait (megaco:cancel/2).</source>
          <target state="translated">用户明确取消了等待(megaco:cancel/2)。</target>
        </trans-unit>
        <trans-unit id="d18a93e929b37cd21f4c79e7536ff6532ff0f893" translate="yes" xml:space="preserve">
          <source>The user has logged off (the &quot;logoff&quot; message is removed).</source>
          <target state="translated">用户已经注销(&quot;注销 &quot;信息被删除)。</target>
        </trans-unit>
        <trans-unit id="66d08744fcbef8850f22e132fcee2b95959ddf93" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用户密钥目录可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="c9960888cee8c9b6bfc6612c16d696a491bd6e28" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf02e29035334a18d18c5e1b94c79095367bd56" translate="yes" xml:space="preserve">
          <source>The user may (for special purposes) create additional nodes with other type tags, using the &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">用户可以使用 &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; 函数（出于特殊目的）使用其他类型的标签创建其他节点。</target>
        </trans-unit>
        <trans-unit id="ddc2e0d09942d83a7b04fe20082be1f80957f4d6" translate="yes" xml:space="preserve">
          <source>The user must also be prepared to receive an abort message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f40f2ea6a4143c3ec3b1ecd54ea0fd079d720a" translate="yes" xml:space="preserve">
          <source>The user name of the OS process running the Erlang virtual machine (emulator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a184f2287a73fa0e22dbeefc3837ae54223d8d" translate="yes" xml:space="preserve">
          <source>The user name, public key and cryptographic data (a signature) that is sent by the client, are used as follows (some steps left out for clearity):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee238ea123b1d44a60398d5285952819fc3ede9" translate="yes" xml:space="preserve">
          <source>The user should implement a scanner that segments the input text, and turns it into one or more lists of tokens. Each token should be a tuple containing information about syntactic category, position in the text (e.g. line number), and the actual terminal symbol found in the text: &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt;.</source>
          <target state="translated">用户应实现一种扫描器，该扫描器可以对输入文本进行分段，并将其转换为一个或多个令牌列表。每个令牌应该是一个元组，其中包含有关语法类别，文本中的位置（例如，行号）以及在文本中找到的实际终端符号的信息： &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9c7796fd10aeef2e76370d88ff426dec7a02695" translate="yes" xml:space="preserve">
          <source>The user tag is provided to the user probes triggered by calls top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; as well as probes in the efile_driver. In the future, user tags might be added to more probes.</source>
          <target state="translated">该用户标签提供给通过调用top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; 触发的用户探针，以及efile_driver中的探针。将来，用户标签可能会添加到更多探针中。</target>
        </trans-unit>
        <trans-unit id="935cfbe6393df2b605ae54a72dfb24e180f2b45e" translate="yes" xml:space="preserve">
          <source>The user timetrap function can be used for two things as follows:</source>
          <target state="translated">用户计时功能可用于以下两个方面。</target>
        </trans-unit>
        <trans-unit id="2f2130a51941a7dd2f7d9af37266ecb1c20f0d79" translate="yes" xml:space="preserve">
          <source>The user timetrap function can return a time value after a delay. The effective timetrap time is then the delay time &lt;strong&gt;plus&lt;/strong&gt; the returned time.</source>
          <target state="translated">用户时间陷阱功能可以在延迟后返回时间值。那么，有效的时间陷阱时间就是延迟时间&lt;strong&gt;加上&lt;/strong&gt;返回的时间。</target>
        </trans-unit>
        <trans-unit id="b5ee7bda12decc24125202f276f6922f07234b3a" translate="yes" xml:space="preserve">
          <source>The user(s) register their agents.</source>
          <target state="translated">用户注册其代理人。</target>
        </trans-unit>
        <trans-unit id="1d94abedc5a45d3a00396f6b9115ee0199e9b2d1" translate="yes" xml:space="preserve">
          <source>The user-defined CPU topology can also be set by passing command-line argument &lt;code&gt;+sct&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">还可以通过将命令行参数 &lt;code&gt;+sct&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 来设置用户定义的CPU拓扑。</target>
        </trans-unit>
        <trans-unit id="3eac153a48412697b04bd3f7c3679f6e2cb43d77" translate="yes" xml:space="preserve">
          <source>The user-specific handler can be written to handle special configuration file formats. The parameter can be either file names or configuration strings (the empty list is valid).</source>
          <target state="translated">可以编写用户专用的处理程序来处理特殊的配置文件格式。参数可以是文件名或配置字符串(空列表有效)。</target>
        </trans-unit>
        <trans-unit id="070ed6c048e93f78c36ea8f0ccfec711d97f3991" translate="yes" xml:space="preserve">
          <source>The user/operator can specify the order at will, and maybe a different execution order is sometimes more relevant or efficient.</source>
          <target state="translated">用户/操作者可以随意指定顺序,也许不同的执行顺序有时更有针对性或效率。</target>
        </trans-unit>
        <trans-unit id="816667b752baf90b5891d2f5483693ef98e188ca" translate="yes" xml:space="preserve">
          <source>The username used for authentication.</source>
          <target state="translated">用于认证的用户名。</target>
        </trans-unit>
        <trans-unit id="32f031cef47e0932c6309630147b6b75921f94b2" translate="yes" xml:space="preserve">
          <source>The utilities are also suitable to use in system testing on large systems, where other tools have too much impact on the system performance. Some primitive support for sequential tracing is also included, see the &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">该实用程序还适用于在大型系统上进行系统测试，而其他工具对系统性能的影响太大。还包括对顺序跟踪的一些原始支持，请参阅 &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="1b998cc802660cc78a04365f6fb84a62e62e8e56" translate="yes" xml:space="preserve">
          <source>The utility &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">实用程序 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 提供了一个备用编译接口。</target>
        </trans-unit>
        <trans-unit id="88c9fe090556e5d2d20b460fae9afd89cea9e45c" translate="yes" xml:space="preserve">
          <source>The utility function &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; can be used to easily transform a string of text into a &lt;code&gt;par&lt;/code&gt; representation by splitting it into words.</source>
          <target state="translated">实用程序函数 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 可用于将文本字符串拆分为单词，从而轻松地将其转换为 &lt;code&gt;par&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="fd02acb46e123ade0af1cb132c81a7c98e6cbd55" translate="yes" xml:space="preserve">
          <source>The utility module &lt;code&gt;msacc(3)&lt;/code&gt; can be used to more easily analyse these statistics.</source>
          <target state="translated">实用程序模块 &lt;code&gt;msacc(3)&lt;/code&gt; 可用于更轻松地分析这些统计信息。</target>
        </trans-unit>
        <trans-unit id="86003c423491838636e87b46780a42310a82d73b" translate="yes" xml:space="preserve">
          <source>The valid configuration parameters are as follows:</source>
          <target state="translated">有效的配置参数如下。</target>
        </trans-unit>
        <trans-unit id="98a22ffb82809edcc4e94af08c6c5c821a27b003" translate="yes" xml:space="preserve">
          <source>The valid values are &lt;code&gt;0&lt;/code&gt; (&quot;normal&quot;) and &lt;code&gt;1&lt;/code&gt; (&quot;stderr&quot;), see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#page/8&quot;&gt;RFC 4254, Section 5.2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb94796638387a4f1cb0c6ac15343b38548969a" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. See the &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; function for more info on the &lt;code&gt;Validate&lt;/code&gt; fun.</source>
          <target state="translated">验证乐趣 &lt;code&gt;Validate&lt;/code&gt; 允许对 &lt;code&gt;DateAndTime&lt;/code&gt; 参数进行更&amp;ldquo;灵活&amp;rdquo;的验证。每当发现数据不遵循RFC2579时，都会调用此乐趣以允许更&amp;ldquo;宽松&amp;rdquo;的验证。有关 &lt;code&gt;Validate&lt;/code&gt; 乐趣的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="60c703f2c6b10b3e79aabc8eaf2dfdc52607c370" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. The input to the validation fun looks like this:</source>
          <target state="translated">验证乐趣 &lt;code&gt;Validate&lt;/code&gt; 允许对 &lt;code&gt;DateAndTime&lt;/code&gt; 参数进行更&amp;ldquo;灵活&amp;rdquo;的验证。每当发现数据不遵循RFC2579时，都会调用此乐趣以允许更多&amp;ldquo;宽松&amp;rdquo;的验证。验证乐趣的输入如下所示：</target>
        </trans-unit>
        <trans-unit id="58a5e20ed6c2d29e3e861f7702b4763df798e9a1" translate="yes" xml:space="preserve">
          <source>The validity of the options is &lt;strong&gt;not&lt;/strong&gt; checked by the HTTP client they are assumed to be correct and passed on to ssl application and inet driver, which may reject them if they are not correct.</source>
          <target state="translated">HTTP客户端&lt;strong&gt;未&lt;/strong&gt;检查选项的有效性，并认为这些选项是正确的，并传递给ssl应用程序和inet驱动程序，如果它们不正确，它们可能会拒绝它们。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
