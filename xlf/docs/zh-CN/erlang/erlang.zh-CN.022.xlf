<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="ac9629aacf5a541205c4ec779ff11edb1576409e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;context&lt;/code&gt; is specified, the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;, is used.</source>
          <target state="translated">如果没有 &lt;code&gt;context&lt;/code&gt; 指定，默认情况下， &lt;code&gt;&quot;&quot;&lt;/code&gt; ，被使用。</target>
        </trans-unit>
        <trans-unit id="ed97555002c32aa9440a97e73ca69137e2f1b0fe" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;epmd&lt;/code&gt; (TCP port mapper daemon) is used, also command-line option &lt;code&gt;-no_epmd&lt;/code&gt; is to be specified, which makes Erlang skip the &lt;code&gt;epmd&lt;/code&gt; startup, both as an OS process and as an Erlang ditto.</source>
          <target state="translated">如果未使用 &lt;code&gt;epmd&lt;/code&gt; （TCP端口映射器守护程序），则还将指定命令行选项 &lt;code&gt;-no_epmd&lt;/code&gt; ，这将使Erlang 既作为OS进程又作​​为Erlang同上，跳过 &lt;code&gt;epmd&lt;/code&gt; 启动。</target>
        </trans-unit>
        <trans-unit id="a8006619350a5226e5dc4b2683c9eea3a8bdbda4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;extended_info&lt;/code&gt; is present in the file and &lt;code&gt;{verify,true}&lt;/code&gt; is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was &lt;code&gt;public&lt;/code&gt; and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;, which extends the information in the file with the number of objects written.</source>
          <target state="translated">如果没有 &lt;code&gt;extended_info&lt;/code&gt; 是存在于文件中，并 &lt;code&gt;{verify,true}&lt;/code&gt; 指定，则转储启动时写对象的数量是比较原始表的大小。如果表是 &lt;code&gt;public&lt;/code&gt; ，并且在表转储到文件时添加或删除了对象，这会使验证失败。为避免此问题，请要么不验证同时更新时转储的文件，要么对 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 使用选项 &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; ，这会扩展文件中的信息并增加写入的对象数。</target>
        </trans-unit>
        <trans-unit id="8a45ca5e05cc70fae2783d55cbff20b1f8725403" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;name&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets.</source>
          <target state="translated">如果未指定 &lt;code&gt;name&lt;/code&gt; （或者为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ），则通知将发送到所有管理目标。</target>
        </trans-unit>
        <trans-unit id="32886c8cd8eda5943ea7814b65ec8cd639317821" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;tracer&lt;/code&gt; is specified, the calling process receives all the trace messages.</source>
          <target state="translated">如果未指定 &lt;code&gt;tracer&lt;/code&gt; ，则调用过程将接收所有跟踪消息。</target>
        </trans-unit>
        <trans-unit id="8acb8279a4661a4f996c3af79ec9be1db1d63648" translate="yes" xml:space="preserve">
          <source>If no BEAM file contains debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果没有BEAM文件包含调试信息,那么将返回一个元组列表。每个元组的第一个元素是以下之一:</target>
        </trans-unit>
        <trans-unit id="44e5f3c4af2c18aaf89a34918cf838e205862cec" translate="yes" xml:space="preserve">
          <source>If no BOM is found, the function returns &lt;code&gt;{latin1,0}&lt;/code&gt;.</source>
          <target state="translated">如果未找到BOM，则该函数返回 &lt;code&gt;{latin1,0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07f0cc9e55f8b5cf0585baaee7cd300085bb99c" translate="yes" xml:space="preserve">
          <source>If no CPU topology is available when flag &lt;code&gt;+sbt&lt;/code&gt; is processed and &lt;code&gt;BindType&lt;/code&gt; is any other type than &lt;code&gt;u&lt;/code&gt;, the runtime system fails to start. CPU topology can be defined using flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt;. Notice that flag &lt;code&gt;+sct&lt;/code&gt; can have to be passed before flag &lt;code&gt;+sbt&lt;/code&gt; on the command line (if no CPU topology has been automatically detected).</source>
          <target state="translated">如果在处理标志 &lt;code&gt;+sbt&lt;/code&gt; 且 &lt;code&gt;BindType&lt;/code&gt; 是 &lt;code&gt;u&lt;/code&gt; 以外的任何其他类型时没有CPU拓扑可用，则运行时系统将无法启动。可以使用标志 &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt; 定义CPU拓扑。请注意，必须在命令行上在 &lt;code&gt;+sbt&lt;/code&gt; 标志之前传递 &lt;code&gt;+sct&lt;/code&gt; 标志（如果未自动检测到CPU拓扑）。</target>
        </trans-unit>
        <trans-unit id="dccd7290f5c52ab540d1d1066d43a3aaf228c19a" translate="yes" xml:space="preserve">
          <source>If no argument is provided, Debugger starts in global mode.</source>
          <target state="translated">如果没有提供参数,Debugger在全局模式下启动。</target>
        </trans-unit>
        <trans-unit id="1fe7b07f514dd69941a31088b490f38f80374e4c" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未指定启动脚本，则默认为 &lt;code&gt;ROOT/bin/start&lt;/code&gt; ，请参见 &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b11dd24d2508db0b969937d6f16c64e7e9a757da" translate="yes" xml:space="preserve">
          <source>If no command-line flag is entered, the &lt;code&gt;Mnesia&lt;/code&gt; directory becomes the current working directory on the node where the Erlang shell is started.</source>
          <target state="translated">如果未输入命令行标志，则 &lt;code&gt;Mnesia&lt;/code&gt; 目录将成为启动Erlang Shell的节点上的当前工作目录。</target>
        </trans-unit>
        <trans-unit id="19b61bf39702f61088362c4f3caf5fec39790a79" translate="yes" xml:space="preserve">
          <source>If no configuration exists for a server, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead, and specify all necessary options in the &lt;code&gt;Options&lt;/code&gt; parameter.</source>
          <target state="translated">如果服务器没有配置，请改用 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; ，然后在 &lt;code&gt;Options&lt;/code&gt; 参数中指定所有必需的选项。</target>
        </trans-unit>
        <trans-unit id="a0a2525519fce3b84f0628d21fec24d0d54a30b8" translate="yes" xml:space="preserve">
          <source>If no configuration file is specified with command &lt;code&gt;ct_run&lt;/code&gt;, a warning is displayed. If &lt;code&gt;Common Test&lt;/code&gt; has been run from the same directory earlier, the same configuration file(s) are used again. If &lt;code&gt;Common Test&lt;/code&gt; has not been run from this directory before, no configuration files are available.</source>
          <target state="translated">如果未使用 &lt;code&gt;ct_run&lt;/code&gt; 命令指定配置文件，则会显示警告。如果先前已从同一目录运行过 &lt;code&gt;Common Test&lt;/code&gt; ，则将再次使用相同的配置文件。如果以前从未从此目录运行过 &lt;code&gt;Common Test&lt;/code&gt; ，则没有配置文件可用。</target>
        </trans-unit>
        <trans-unit id="905acdf151b0fff2093942d03e8fda7ba4d6ef97" translate="yes" xml:space="preserve">
          <source>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned &lt;code&gt;pid&lt;/code&gt; for this process is to be used as input to all other API functions in this module.</source>
          <target state="translated">如果没有提供连接引用，则建立连接，并返回新的连接。启动SSH通道进程以处理与SFTP服务器的通信。此过程返回的 &lt;code&gt;pid&lt;/code&gt; 将用作此模块中所有其他API函数的输入。</target>
        </trans-unit>
        <trans-unit id="a012950e61dc5d03cdb78960de0564c38b5541f9" translate="yes" xml:space="preserve">
          <source>If no encoder module is given, the default is used (which is pretty).</source>
          <target state="translated">如果没有给出编码器模块,则使用默认值(很好看)。</target>
        </trans-unit>
        <trans-unit id="9348a769518853e44d89b99ac342c57ff1b5e15b" translate="yes" xml:space="preserve">
          <source>If no error occurs, the second phase is performed. This phase calls the user defined &lt;code&gt;set&lt;/code&gt; function for all variables.</source>
          <target state="translated">如果没有错误发生，则执行第二阶段。此阶段为所有变量调用用户定义的 &lt;code&gt;set&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3b135a2849366f4513f0e061b53465a7e3a779a4" translate="yes" xml:space="preserve">
          <source>If no exports are listed by an &lt;code&gt;export&lt;/code&gt; option (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details), then if &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under &lt;code&gt;merge/3&lt;/code&gt;.</source>
          <target state="translated">如果没有通过 &lt;code&gt;export&lt;/code&gt; 选项列出任何导出（有关详细信息，请参见 &lt;code&gt;merge_sources/3&lt;/code&gt; ），那么如果 &lt;code&gt;Name&lt;/code&gt; 也是输入模块之一的名称，则将导出该模块；否则，将导出该模块。否则，将导出第一个列出的模块。cf. 在 &lt;code&gt;merge/3&lt;/code&gt; 下的示例。</target>
        </trans-unit>
        <trans-unit id="186696412f510e31ad8ed3a38fb86c31cd6ca5ca" translate="yes" xml:space="preserve">
          <source>If no extra options are specified with flag/option &lt;code&gt;step&lt;/code&gt;, breakpoints are set automatically on the test cases that are to be executed by &lt;code&gt;Common Test&lt;/code&gt;, and those functions only. If step option &lt;code&gt;config&lt;/code&gt; is specified, breakpoints are also initially set on the configuration functions in the suite, that is, &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, &lt;code&gt;end_per_group/2&lt;/code&gt;, &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2&lt;/code&gt;.</source>
          <target state="translated">如果没有通过flag / option &lt;code&gt;step&lt;/code&gt; 指定额外的选项，则将在 &lt;code&gt;Common Test&lt;/code&gt; 和仅那些功能要执行的测试用例上自动设置断点。如果指定了step选项 &lt;code&gt;config&lt;/code&gt; ，则还会在套件的配置函数上初始设置断点，即 &lt;code&gt;init_per_suite/1&lt;/code&gt; ， &lt;code&gt;end_per_suite/1&lt;/code&gt; ， &lt;code&gt;init_per_group/2&lt;/code&gt; ， &lt;code&gt;end_per_group/2&lt;/code&gt; ， &lt;code&gt;init_per_testcase/2&lt;/code&gt; 和 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e1803a2624ccbd4e21f90db6095850fb9331a7" translate="yes" xml:space="preserve">
          <source>If no formatter information is specified for a handler, Logger uses &lt;code&gt;logger_formatter&lt;/code&gt; as default. See the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page for more information about this module.</source>
          <target state="translated">如果未为处理程序指定格式化程序信息，则Logger &lt;code&gt;logger_formatter&lt;/code&gt; 用作默认值。有关此模块的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="534f259af2115bebe106710668093e3ef6ffd155" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未指定图类型，则使用 &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; 创建有向图，否则将 &lt;code&gt;GraphType&lt;/code&gt; 参数作为第二个参数传递给 &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eb03e181763fc340f89dd2fee8a41ea21ee5c23" translate="yes" xml:space="preserve">
          <source>If no guard sequence is evaluated as true, an &lt;code&gt;if_clause&lt;/code&gt; run-time error occurs. If necessary, the guard expression &lt;code&gt;true&lt;/code&gt; can be used in the last branch, as that guard sequence is always true.</source>
          <target state="translated">如果没有任何保护序列被评估为true，则会发生 &lt;code&gt;if_clause&lt;/code&gt; 运行时错误。如有必要，可以在最后一个分支中使用保护表达式 &lt;code&gt;true&lt;/code&gt; ，因为该保护序列始终为true。</target>
        </trans-unit>
        <trans-unit id="b9f6b9adc1152f1b0fd0e1ed73ad8eec4e1f624e" translate="yes" xml:space="preserve">
          <source>If no log with the specified name exist on the specified node, &lt;code&gt;no_such_log&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定节点上不存在具有指定名称的日志，则返回 &lt;code&gt;no_such_log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f6ab79d1d5e9e2cd8b43d5f286fe816764eabff" translate="yes" xml:space="preserve">
          <source>If no match is found for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt; will be the empty string (&lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">如果找不到与 &lt;code&gt;Tag&lt;/code&gt; 匹配的 &lt;code&gt;Result&lt;/code&gt; ，则结果将为空字符串（ &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="668861363db131d12510c671297ba7af08f41273" translate="yes" xml:space="preserve">
          <source>If no more event handlers exist after the deletion, &lt;code&gt;error_logger&lt;/code&gt; is removed as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is stopped.</source>
          <target state="translated">如果删除后不存在任何事件处理程序，则将 &lt;code&gt;error_logger&lt;/code&gt; 删除为Logger处理程序，并停止 &lt;code&gt;error_logger&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="97bba64e22bb5e3d712c27f199cd41bb5ed00da4" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor bridge is not registered.</source>
          <target state="translated">如果没有提供名称,则没有注册主管桥。</target>
        </trans-unit>
        <trans-unit id="145b04378100b2af31635cfab7037e102fc50e14" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor is not registered.</source>
          <target state="translated">如果没有提供姓名,则没有登记监理。</target>
        </trans-unit>
        <trans-unit id="962cccbaba0fe2900b8b208ab74fd43b13540b3f" translate="yes" xml:space="preserve">
          <source>If no object with key &lt;code&gt;Key&lt;/code&gt; exists, the function exits with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果不存在带有键 &lt;code&gt;Key&lt;/code&gt; 的对象，则函数以 &lt;code&gt;badarg&lt;/code&gt; 原因退出。</target>
        </trans-unit>
        <trans-unit id="f3ace922192dd1a66ce93d65f216be69e6bdcfa0" translate="yes" xml:space="preserve">
          <source>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and &lt;code&gt;select&lt;/code&gt; is used to traverse the table, that is:</source>
          <target state="translated">如果未指定选项，则将获取读取锁定，每个块中返回100个结果，并使用 &lt;code&gt;select&lt;/code&gt; 遍历表，即：</target>
        </trans-unit>
        <trans-unit id="be43c0999b074d475f47490047515316aff57a56" translate="yes" xml:space="preserve">
          <source>If no or an unknown version is given, the &lt;strong&gt;best&lt;/strong&gt; version is used (which is v3).</source>
          <target state="translated">如果没有给出或未知的版本，则使用&lt;strong&gt;最佳&lt;/strong&gt;版本（即v3）。</target>
        </trans-unit>
        <trans-unit id="bc0db3920bc02374e1ab1e1eb3ced79753b79531" translate="yes" xml:space="preserve">
          <source>If no output comes from the Erlang shell, but the Erlang machine still seems to be alive, an &quot;ALIVE&quot; message is written to the log; it is a time stamp and is written, by default, after 15 minutes of inactivity. Also, if output from Erlang is logged, but more than 5 minutes (default) has passed since last time we got anything from Erlang, a time stamp is written in the log. The &quot;ALIVE&quot; messages look as follows:</source>
          <target state="translated">如果Erlang shell没有任何输出,但是Erlang机器似乎还活着,那么 &quot;ALIVE &quot;消息会被写入日志;这是一个时间戳,默认情况下,在15分钟没有活动之后写入。另外,如果Erlang的输出被记录下来,但距离上次从Erlang得到任何东西已经超过5分钟(默认),那么日志中会写下一个时间戳。ALIVE &quot;消息的内容如下。</target>
        </trans-unit>
        <trans-unit id="609daf9d4941227cdd07f7a145c9f4b97a9dd23d" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果不存在任何进程元数据，则该函数的行为为 &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="129f0fba3cda34f511f81ef498c5983a08b6fef4" translate="yes" xml:space="preserve">
          <source>If no service name is specified, a brief listing of all Erlang services is presented. If a service name is supplied, all options for that service are presented.</source>
          <target state="translated">如果没有指定服务名称,则会显示所有 Erlang 服务的简要列表。如果提供了服务名称,则会显示该服务的所有选项。</target>
        </trans-unit>
        <trans-unit id="f74a0bc86a24e556d294700bf2367dba448274f4" translate="yes" xml:space="preserve">
          <source>If no specific browser start command is specified, Firefox is the default browser on Unix platforms, and Internet Explorer on Windows. If &lt;code&gt;Common Test&lt;/code&gt; fails to start a browser automatically, or &lt;code&gt;none&lt;/code&gt; is specified as the value for &lt;code&gt;-browser&lt;/code&gt; (that is, &lt;code&gt;-browser none&lt;/code&gt;), start your favourite browser manually and type the URL that &lt;code&gt;Common Test&lt;/code&gt; displays in the shell.</source>
          <target state="translated">如果未指定特定的浏览器启动命令，则Firefox是Unix平台上的默认浏览器，而是Windows上的Internet Explorer。如果 &lt;code&gt;Common Test&lt;/code&gt; 无法自动启动浏览器，或者 &lt;code&gt;none&lt;/code&gt; 被指定为值 &lt;code&gt;-browser&lt;/code&gt; （即 &lt;code&gt;-browser none&lt;/code&gt; ），手动启动你喜欢的浏览器，键入URL是 &lt;code&gt;Common Test&lt;/code&gt; 显示在外壳。</target>
        </trans-unit>
        <trans-unit id="3bd56a176fb29e1e8248ad526f6f69316f9b58af" translate="yes" xml:space="preserve">
          <source>If no such fun is registered, &lt;code&gt;beam_lib&lt;/code&gt; instead searches for an &lt;code&gt;.erlang.crypt&lt;/code&gt; file, see the next section.</source>
          <target state="translated">如果未注册此类乐趣，则 &lt;code&gt;beam_lib&lt;/code&gt; 会搜索 &lt;code&gt;.erlang.crypt&lt;/code&gt; 文件，请参阅下一节。</target>
        </trans-unit>
        <trans-unit id="d1d762df86c391a1b492c91b19c8e6c06437bbda" translate="yes" xml:space="preserve">
          <source>If no user configuration file is specified and Erlang is started in non-distributed or short name distributed mode, Erlang uses default configuration settings and a native lookup method that works correctly under most circumstances. Erlang reads no information from system &lt;code&gt;inet&lt;/code&gt; configuration files (such as &lt;code&gt;/etc/host.conf&lt;/code&gt; and &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;) in these modes, except for &lt;code&gt;/etc/resolv.conf&lt;/code&gt; and &lt;code&gt;/etc/hosts&lt;/code&gt; that is read and monitored for changes on Unix platforms for the internal DNS client &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">如果未指定用户配置文件，并且以非分布式或短名称分布式模式启动Erlang，则Erlang使用默认配置设置和本机查找方法，该方法在大多数情况下都可以正常工作。在这些模式下，Erlang不会从系统 &lt;code&gt;inet&lt;/code&gt; 配置文件（例如 &lt;code&gt;/etc/host.conf&lt;/code&gt; 和 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ）中读取任何信息，除了 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 和 &lt;code&gt;/etc/hosts&lt;/code&gt; 会读取并监视其更改之外在Unix平台上用于内部DNS客户端 &lt;code&gt;inet_res(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13936c5aba4f403aada92256e268f1fefbc0b6d4" translate="yes" xml:space="preserve">
          <source>If no value for &lt;code&gt;Retries&lt;/code&gt; is specified, &lt;code&gt;infinity&lt;/code&gt; is used.</source>
          <target state="translated">如果未指定&amp;ldquo; &lt;code&gt;Retries&lt;/code&gt; 值，则使用 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94c3223fb92528e085bdc89d88a03ccfd3c590d9" translate="yes" xml:space="preserve">
          <source>If none of the above are available for your architecture/compiler, you are recommended to build and install &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; before building Erlang/OTP. The &lt;code&gt;libatomic_ops&lt;/code&gt; library provides native atomic memory operations for a variety of architectures and compilers. When building Erlang/OTP you need to inform the build system of where the &lt;code&gt;libatomic_ops&lt;/code&gt; library is installed using the &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt;&lt;code&gt;configure&lt;/code&gt; switch.</source>
          <target state="translated">如果以上都不适用于您的体系结构/编译器，建议您在构建Erlang / OTP之前先构建并安装 &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;libatomic_ops&lt;/code&gt; 库提供原生原子存储器操作，适用于各种架构和编译器。在构建Erlang / OTP时，您需要使用 &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt; &lt;code&gt;configure&lt;/code&gt; 开关来通知构建系统 &lt;code&gt;libatomic_ops&lt;/code&gt; 库的安装位置。</target>
        </trans-unit>
        <trans-unit id="9440ff5a97925b9c13d62c177e03518391502a24" translate="yes" xml:space="preserve">
          <source>If none of the first three clauses match, the fourth clause match as a variable always matches.</source>
          <target state="translated">如果前三个子句都不匹配,第四个子句匹配作为一个变量总是匹配的。</target>
        </trans-unit>
        <trans-unit id="f62e5b4dade736a66aa048e49499435f1f4d7fdc" translate="yes" xml:space="preserve">
          <source>If none of the strings in &lt;code&gt;Pattern&lt;/code&gt; is found, the atom &lt;code&gt;nomatch&lt;/code&gt; is returned.</source>
          <target state="translated">如果在 &lt;code&gt;Pattern&lt;/code&gt; 中找不到任何字符串，则返回原子不 &lt;code&gt;nomatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeb11b61b9cc24cd2031d9dda015e2462ccc0499" translate="yes" xml:space="preserve">
          <source>If none of the strings in a pattern is found, an empty list is returned.</source>
          <target state="translated">如果在模式中没有找到任何字符串,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="652472f45cf3561f5b3dd17763a17700dfcd88cc" translate="yes" xml:space="preserve">
          <source>If not empty, a scheduler internal auxiliary work is scheduled to be done.</source>
          <target state="translated">如果不为空,则安排做一个调度器内部辅助工作。</target>
        </trans-unit>
        <trans-unit id="9937b44a2ec57528d4de1534b4257202ba316ad9" translate="yes" xml:space="preserve">
          <source>If not implemented, the CTH acts as if this function returned a call to &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">如果未实现，则CTH就像该函数返回了对 &lt;code&gt;make_ref/0&lt;/code&gt; 的调用一样。</target>
        </trans-unit>
        <trans-unit id="c288cca9f0fb59e5fd99ac4b40424bd7ecc21978" translate="yes" xml:space="preserve">
          <source>If not present, audit trail logging is not used.</source>
          <target state="translated">如果不存在,则不使用审计线索记录。</target>
        </trans-unit>
        <trans-unit id="29e29374c41854c469f97e992cbb29625d1d3ef4" translate="yes" xml:space="preserve">
          <source>If not, this is the atom &lt;code&gt;all&lt;/code&gt; which implies that the &lt;code&gt;UtilDesc&lt;/code&gt; contains information about all CPUs.</source>
          <target state="translated">如果不是，则这是原子的 &lt;code&gt;all&lt;/code&gt; ，这意味着 &lt;code&gt;UtilDesc&lt;/code&gt; 包含有关所有CPU的信息。</target>
        </trans-unit>
        <trans-unit id="f15293549ba601ce95a5307be4274cf3a235ee45" translate="yes" xml:space="preserve">
          <source>If not, this is the sum of the percentage shares of the CPU cycles spent in all states identified as busy.</source>
          <target state="translated">如果没有,则是在所有确定为繁忙的状态中所花费的CPU周期的百分比份额之和。</target>
        </trans-unit>
        <trans-unit id="a5425f5051ad47a7b173e5435c9b894080331b92" translate="yes" xml:space="preserve">
          <source>If nothing else is stated, it is presumed that the &lt;code&gt;otptest&lt;/code&gt; user has an entry in the &lt;strong&gt;authorized_keys&lt;/strong&gt; file of &lt;strong&gt;tarlop&lt;/strong&gt; (allowed to log in over &lt;code&gt;ssh&lt;/code&gt; without entering a password). Also, &lt;strong&gt;tarlop&lt;/strong&gt; is a known host in the &lt;code&gt;known_hosts&lt;/code&gt; file of the user &lt;code&gt;otptest&lt;/code&gt;. This means that host-verification can be done without user-interaction.</source>
          <target state="translated">如果没有其他说明，推测该 &lt;code&gt;otptest&lt;/code&gt; 用户在入口&lt;strong&gt;的authorized_keys&lt;/strong&gt;的文件&lt;strong&gt;tarlop&lt;/strong&gt;（允许登录过 &lt;code&gt;ssh&lt;/code&gt; 无需输入密码）。另外，&lt;strong&gt;tarlop&lt;/strong&gt;是用户 &lt;code&gt;otptest&lt;/code&gt; 的 &lt;code&gt;known_hosts&lt;/code&gt; 文件中的已知主机。这意味着无需用户交互即可完成主机验证。</target>
        </trans-unit>
        <trans-unit id="85b52863c7b73a113224224b8a0c4d01a407b7d9" translate="yes" xml:space="preserve">
          <source>If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.</source>
          <target state="translated">如果在表被固定的时候已经添加了对象,那么当表被释放时,哈希列表就会开始增长,这就会在一段时间内大大降低对表的访问速度。</target>
        </trans-unit>
        <trans-unit id="828acc15f06ea3d0ebf75bc3294946979fd85c6d" translate="yes" xml:space="preserve">
          <source>If on the other hand the Version argument is an integer, it means that this is the expected version of the message and the decoder for that version should be used.</source>
          <target state="translated">如果另一方面,Version参数是一个整数,这意味着这是消息的预期版本,应该使用该版本的解码器。</target>
        </trans-unit>
        <trans-unit id="7ee7ad00a53993074166a752357e3a491c2d6eb1" translate="yes" xml:space="preserve">
          <source>If one &lt;strong&gt;really&lt;/strong&gt; wants to monitor when the driver gets unloaded, this message distorts the picture, because no unloading was done. Option &lt;code&gt;unloaded_only&lt;/code&gt; creates a monitor similar to an &lt;code&gt;unloaded&lt;/code&gt; monitor, but never results in this message.</source>
          <target state="translated">如果&lt;strong&gt;确实&lt;/strong&gt;要监视何时卸载驱动程序，此消息会使图片失真，因为没有完成卸载。选项 &lt;code&gt;unloaded_only&lt;/code&gt; 创建类似于监控器 &lt;code&gt;unloaded&lt;/code&gt; 的显示器，但决不会导致此消息。</target>
        </trans-unit>
        <trans-unit id="c5ebea37f196f871b2a70d380f83941fc18ead49" translate="yes" xml:space="preserve">
          <source>If one UTF character is split over two consecutive binaries in the &lt;code&gt;Data&lt;/code&gt;, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring.</source>
          <target state="translated">如果将一个UTF字符分成两个连续的二进制 &lt;code&gt;Data&lt;/code&gt; ，则转换成功。这意味着只要将整个范围指定为输入而不会发生错误，就可以从一定范围的二进制文件中解码字符。</target>
        </trans-unit>
        <trans-unit id="90ed92af5805bd230adc121faf96993bce08b918" translate="yes" xml:space="preserve">
          <source>If one of the &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</source>
          <target state="translated">如果设置了 &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; 标志之一，并且运行时系统不支持脏调度程序，则运行时系统将拒绝加载NIF库。</target>
        </trans-unit>
        <trans-unit id="da2865f4d243741aece7d05e455898a782a870b4" translate="yes" xml:space="preserve">
          <source>If one of the nodes cannot process monitors, for example, C or Java nodes, and the &lt;code&gt;gen_server&lt;/code&gt; process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole &lt;code&gt;Timeout&lt;/code&gt;, which may be infinity.</source>
          <target state="translated">如果某个节点无法处理监视器（例如C或Java节点），并且 &lt;code&gt;gen_server&lt;/code&gt; 进程在发送请求时未启动，而是在2秒内启动，则此函数将等待整个 &lt;code&gt;Timeout&lt;/code&gt; ，这可能是无限的。</target>
        </trans-unit>
        <trans-unit id="2ff50154efe11e68e30a0801c8327e55b0714e5d" translate="yes" xml:space="preserve">
          <source>If one or more carriers could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">如果一个或多个载波无法在不损害系统响应能力的情况下进行完整扫描，则 &lt;code&gt;UnscannedSize&lt;/code&gt; 是必须跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="9b3b6b44750cd929fb5194f2e7f17a52f91bfeb2" translate="yes" xml:space="preserve">
          <source>If only one access file exists, setting this parameter to &lt;code&gt;none&lt;/code&gt; can ease the burden on the server as the server then stops looking for access files.</source>
          <target state="translated">如果只有一个访问文件，则将此参数设置为 &lt;code&gt;none&lt;/code&gt; 可以减轻服务器的负担，因为服务器随后将停止寻找访问文件。</target>
        </trans-unit>
        <trans-unit id="78efdbd37020ca2e2d25f04642dce2c0495aa809" translate="yes" xml:space="preserve">
          <source>If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:</source>
          <target state="translated">如果只有一个字母被指定为\p或\P,它包括所有以该字母开头的一般类别属性。在这种情况下,如果没有否定句,转义序列中的大括号是可选的。下面的两个例子具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="d1f740d3ae5b1c6572bd4172c4f16e8373ec6b45" translate="yes" xml:space="preserve">
          <source>If only one value is present, it is the current value. &lt;code&gt;fix_alloc&lt;/code&gt; memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</source>
          <target state="translated">如果仅存在一个值，则为当前值。 &lt;code&gt;fix_alloc&lt;/code&gt; 内存块类型由两个值表示。第一个值是内存池大小，第二个值是已用内存大小。</target>
        </trans-unit>
        <trans-unit id="c5da55d1092af23b098acf7d69c8679113b881cd" translate="yes" xml:space="preserve">
          <source>If only the module name (i.e. not the full name of the &lt;code&gt;.beam&lt;/code&gt; file) is given to this function, the &lt;code&gt;.beam&lt;/code&gt; file is found by calling &lt;code&gt;code:which(Module)&lt;/code&gt;. If no &lt;code&gt;.beam&lt;/code&gt; file is found, the error reason &lt;code&gt;non_existing&lt;/code&gt; is returned. If the module is already cover compiled with &lt;code&gt;compile_beam/1&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; file will be picked from the same location as the first time it was compiled. If the module is already cover compiled with &lt;code&gt;compile/1,2&lt;/code&gt;, there is no way to find the correct &lt;code&gt;.beam&lt;/code&gt; file, so the error reason &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; is returned.</source>
          <target state="translated">如果仅给该函数指定模块名称（即不是 &lt;code&gt;.beam&lt;/code&gt; 文件的全名），则可以通过调用 &lt;code&gt;code:which(Module)&lt;/code&gt; 找到 &lt;code&gt;.beam&lt;/code&gt; 文件。如果未找到 &lt;code&gt;.beam&lt;/code&gt; 文件，则返回错误原因 &lt;code&gt;non_existing&lt;/code&gt; 。如果模块已经覆盖编译 &lt;code&gt;compile_beam/1&lt;/code&gt; 时， &lt;code&gt;.beam&lt;/code&gt; 文件将作为第一次被编在同一位置进行挑选。如果模块已经被 &lt;code&gt;compile/1,2&lt;/code&gt; 编译，则无法找到正确的 &lt;code&gt;.beam&lt;/code&gt; 文件，因此返回错误原因 &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84bdcab65ed9e153d52722d8ccf698faa98c0614" translate="yes" xml:space="preserve">
          <source>If only undefined options are requested the resulting list can be empty.</source>
          <target state="translated">如果只要求未定义的选项,结果列表可以是空的。</target>
        </trans-unit>
        <trans-unit id="c3d6b0c4be9ac174bfcec9988c3498fdbe5d2f55" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">如果选项 &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; ，通过调试 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 被激活。</target>
        </trans-unit>
        <trans-unit id="769611976869b84c5779bcf180081ddcd9ad1bfa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;c&lt;/code&gt; is used with &lt;code&gt;oldshell&lt;/code&gt; on Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; will restart the shell process rather than interrupt it.</source>
          <target state="translated">如果选项 &lt;code&gt;c&lt;/code&gt; 与Unix 上的 &lt;code&gt;oldshell&lt;/code&gt; 一起使用，则 &lt;code&gt;Ctrl-C&lt;/code&gt; 将重新启动shell进程而不是中断它。</target>
        </trans-unit>
        <trans-unit id="096a0eaa955fff41e809fc817940102bc82e3b7a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compact&lt;/code&gt; is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option &lt;code&gt;decimals&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;compact&lt;/code&gt; ，则列表末尾的结尾零将被截断。此选项仅与选项 &lt;code&gt;decimals&lt;/code&gt; 一起有意义。</target>
        </trans-unit>
        <trans-unit id="e006a20906cf19e410666b42e37a9c3e19a3e41a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compressed&lt;/code&gt; is provided, the external term format is compressed. The compressed format is automatically recognized by &lt;code&gt;binary_to_term/1&lt;/code&gt; as from Erlang/OTP R7B.</source>
          <target state="translated">如果提供了 &lt;code&gt;compressed&lt;/code&gt; 选项，则外部术语格式将被压缩。从Erlang / OTP R7B开始， &lt;code&gt;binary_to_term/1&lt;/code&gt; 会自动识别压缩格式。</target>
        </trans-unit>
        <trans-unit id="5de3ee850f4f14cadbc9c1e776ec192b168f5ad1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;decimals&lt;/code&gt; is specified, the returned value contains at most &lt;code&gt;Decimals&lt;/code&gt; number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果选择 &lt;code&gt;decimals&lt;/code&gt; 指定，返回值包含最多 &lt;code&gt;Decimals&lt;/code&gt; 的位数过去的小数点数。如果该数字不适合256个字节的内部静态缓冲区，则该函数将抛出 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d32ea21453f7c1a1069cac8907bb379c47719c1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;eof&lt;/code&gt; is specified also, the messages &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;exit_status&lt;/code&gt; appear in an unspecified order.</source>
          <target state="translated">如果还指定了选项 &lt;code&gt;eof&lt;/code&gt; ，则消息 &lt;code&gt;eof&lt;/code&gt; 和 &lt;code&gt;exit_status&lt;/code&gt; 将以未指定的顺序显示。</target>
        </trans-unit>
        <trans-unit id="32ae7856c177425822832835b7fef1768d20a52e" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;force&lt;/code&gt; has been passed, but the driver of the port does not allow forcing through a busy port.</source>
          <target state="translated">如果已通过选件 &lt;code&gt;force&lt;/code&gt; ，但端口的驱动程序不允许强制通过繁忙的端口。</target>
        </trans-unit>
        <trans-unit id="441c9bb025fc2889c41f42aea8b90d9817c38b34" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the formatting is automatically done when stopping &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">如果将选项 &lt;code&gt;format&lt;/code&gt; 指定为 &lt;code&gt;ttb:stop/1&lt;/code&gt; ，则在停止 &lt;code&gt;ttb&lt;/code&gt; 时会自动进行格式化。</target>
        </trans-unit>
        <trans-unit id="5d2376aceac49d07a344ae2362a017172221e3a6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the trace logs are automatically formatted after tracing is stopped.</source>
          <target state="translated">如果将选项 &lt;code&gt;format&lt;/code&gt; 指定为 &lt;code&gt;ttb:stop/1&lt;/code&gt; ，则在停止跟踪之后将自动格式化跟踪日志。</target>
        </trans-unit>
        <trans-unit id="06c4d5d9e31e528aa6774014ad6ec78d401b5e9f" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;info&lt;/code&gt; is combined with option &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is returned if a flush was needed, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;info&lt;/code&gt; 与选项 &lt;code&gt;flush&lt;/code&gt; 结合使用，则需要刷新时返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6534bbbe7210a2a4f9c6ad85ccdb4879fb04d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;kill_ports&lt;/code&gt; is used, monitor trigging is crucial, as the ports are not guaranteed to be killed until the driver is unloaded. Thus, a monitor must be triggered for at least the &lt;code&gt;pending_driver&lt;/code&gt; case.</source>
          <target state="translated">如果使用选项 &lt;code&gt;kill_ports&lt;/code&gt; ，则监视触发至关重要，因为在卸载驱动程序之前，不能保证杀死端口。因此，必须至少在 &lt;code&gt;pending_driver&lt;/code&gt; 情况下触发监视器。</target>
        </trans-unit>
        <trans-unit id="6aa1db8f0800b8eada993c86c8a59c1d17dfb52c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, all other options return &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt;, respectively.</source>
          <target state="translated">如果选项 &lt;code&gt;linked_in_driver&lt;/code&gt; 或 &lt;code&gt;permanent&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则所有其他选项分别返回 &lt;code&gt;linked_in_driver&lt;/code&gt; 或 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c57ff6b7c6782f60fe59ca940f65912e4d479346" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;monitor&lt;/code&gt; is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;monitor&lt;/code&gt; ，则将监视新创建的进程，并返回该监视器的pid和引用。</target>
        </trans-unit>
        <trans-unit id="04d4436e947c7fe2bfe4be7b9ccd10a7ac2337af" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;no_dot_erlang&lt;/code&gt; is specified, the instruction to load the &lt;code&gt;.erlang&lt;/code&gt; file during boot is &lt;strong&gt;not&lt;/strong&gt; included.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;no_dot_erlang&lt;/code&gt; ，&lt;strong&gt;则不&lt;/strong&gt;包括在引导过程中加载 &lt;code&gt;.erlang&lt;/code&gt; 文件的指令。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd0a5200f0c674efc5a1ca9a83309cd9b7fe26b6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;noexec&lt;/code&gt; is specified, the function returns the same values as for &lt;code&gt;silent&lt;/code&gt; but no &lt;code&gt;relup&lt;/code&gt; file is created.</source>
          <target state="translated">如果选项 &lt;code&gt;noexec&lt;/code&gt; 指定，则函数返回值相同的 &lt;code&gt;silent&lt;/code&gt; ，但没有 &lt;code&gt;relup&lt;/code&gt; 创建文件。</target>
        </trans-unit>
        <trans-unit id="3c2f80ddb4accdf1246a3219780f43c13b4e27f2" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;purge&lt;/code&gt; is specified, all old code that can be soft-purged is purged after all other checks are successfully completed. This can be useful to reduce the time needed by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;purge&lt;/code&gt; 选项，则在所有其他检查成功完成后，将清除所有可以软清除的旧代码。这对于减少 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt; 所需的时间很有用。</target>
        </trans-unit>
        <trans-unit id="f207e9cbf62b31891d035fb3346f08b4121c927b" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;restart_emulator&lt;/code&gt; is specified, a low-level instruction to restart the emulator is appended to the &lt;code&gt;relup&lt;/code&gt; file. This ensures that a complete reboot of the system is done when the system is upgraded or downgraded.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;restart_emulator&lt;/code&gt; ，则将重新启动仿真器的低级指令附加到 &lt;code&gt;relup&lt;/code&gt; 文件中。这样可以确保在升级或降级系统时，完全重启系统。</target>
        </trans-unit>
        <trans-unit id="ef31277dfcdd9b3fea33e70696e85cc6a58e6495" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;scientific&lt;/code&gt; is specified, the float is formatted using scientific notation with &lt;code&gt;Decimals&lt;/code&gt; digits of precision.</source>
          <target state="translated">如果指定了 &lt;code&gt;scientific&lt;/code&gt; 选项，则使用科学计数法将浮点数格式化为精度的 &lt;code&gt;Decimals&lt;/code&gt; 位数。</target>
        </trans-unit>
        <trans-unit id="68354b12f57b501c10eb39d65b11549593ad808d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;src_tests&lt;/code&gt; is specified, a warning is issued if the source code for a module is missing or is newer than the object code.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;src_tests&lt;/code&gt; ，则如果模块的源代码丢失或比目标代码新，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="3b698628086185a232f3b1c8c64f2b5821c29478" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;sync&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it ensures that the content of the file is written to the disk before &lt;code&gt;tab2file&lt;/code&gt; returns. Defaults to &lt;code&gt;{sync, false}&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;sync&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则确保在 &lt;code&gt;tab2file&lt;/code&gt; 返回之前将文件的内容写入磁盘。默认为 &lt;code&gt;{sync, false}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16c1274c0980810787faf4c8323f084b49c5a2fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;ungreedy&lt;/code&gt; is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior.</source>
          <target state="translated">如果设置了选项 &lt;code&gt;ungreedy&lt;/code&gt; （Perl中不提供该选项），则默认情况下，量词不是贪婪的，但是可以通过在问号后面加上问号来使各个量词成为贪婪的对象。也就是说，它会反转默认行为。</target>
        </trans-unit>
        <trans-unit id="6ebecfa9ef794349da407c48663db38e0205dfc1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;url_base&lt;/code&gt; is set, an extra attribute named &lt;code&gt;url&lt;/code&gt; is added to each &lt;code&gt;testsuite&lt;/code&gt; and &lt;code&gt;testcase&lt;/code&gt; XML element. The value is constructed from &lt;code&gt;url_base&lt;/code&gt; and a relative path to the test suite or test case log, respectively, for example:</source>
          <target state="translated">如果设置了选项 &lt;code&gt;url_base&lt;/code&gt; ，则将一个名为 &lt;code&gt;url&lt;/code&gt; 的额外属性添加到每个 &lt;code&gt;testsuite&lt;/code&gt; 和 &lt;code&gt;testcase&lt;/code&gt; XML元素。该值分别由 &lt;code&gt;url_base&lt;/code&gt; 和测试套件或测试用例日志的相对路径构造而成，例如：</target>
        </trans-unit>
        <trans-unit id="7a53503422cb0ac19329aceb31af878b5ec300e5" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;warnings_as_errors&lt;/code&gt; is specified, warnings are treated as errors.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;warnings_as_errors&lt;/code&gt; ，则将警告视为错误。</target>
        </trans-unit>
        <trans-unit id="41ac36f3b8b38269747bee1634966538895f2ee4" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{debug,Dbgs}&lt;/code&gt; is present, the corresponding &lt;code&gt;sys&lt;/code&gt; function is called for each item in &lt;code&gt;Dbgs&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;{debug,Dbgs}&lt;/code&gt; 存在，则相应的 &lt;code&gt;sys&lt;/code&gt; 函数被调用用于每个项目 &lt;code&gt;Dbgs&lt;/code&gt; ; 参见 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e804aab039286890448ffee48895432a1b352c17" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{handshake, hello}&lt;/code&gt; 则握手在收到客户端问候消息后暂停，并且成功响应为 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 而不是 &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。此后，通过调用 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 来继续或取消握手。</target>
        </trans-unit>
        <trans-unit id="9802b121f3f842baa16ccec18f6827e8efefe976" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_event&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; ，则 &lt;code&gt;gen_event&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80d6ad9348d486b54eb01008ea70fa22ab22a998" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1afccf80e87b972a02a03ba25b3fcfd4c6d492f1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. A directory in the path can be specified with a wildcard &lt;code&gt;*&lt;/code&gt;, this is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{path,[Dir]}&lt;/code&gt; ，则此路径将附加到当前路径。路径中的目录可以用通配符 &lt;code&gt;*&lt;/code&gt; 指定，该目录会扩展到所有匹配的目录。示例： &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="521a357383f837ccbed508cea165f5ba1a72a4ba" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories, for example, &lt;code&gt;lib/*/ebin&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{path,[Dir]}&lt;/code&gt; ，则此路径将附加到当前路径。通配符 &lt;code&gt;*&lt;/code&gt; 会扩展到所有匹配的目录，例如 &lt;code&gt;lib/*/ebin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="319e803f0c4dc5797ff076e88abf3ae72c4731f8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt;spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; ， &lt;code&gt;SOpts&lt;/code&gt; 作为选项列表传递给 &lt;code&gt;spawn_opt&lt;/code&gt; BIF，该BIF用于生成 &lt;code&gt;gen_server&lt;/code&gt; 进程；参见 &lt;code&gt;spawn_opt/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f134a5284d4d1605e5d535d5f02614e7f9564b83" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">如果选项 &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; ， &lt;code&gt;SpawnOpts&lt;/code&gt; 作为选项列表以传递 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; ，其用于产卵 &lt;code&gt;gen_statem&lt;/code&gt; 过程。</target>
        </trans-unit>
        <trans-unit id="c971670358afb5846db5d77c2b0b19aad5a3c579" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果选择 &lt;code&gt;{timeout,Time}&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; 的 &lt;code&gt;gen_statem&lt;/code&gt; 允许花 &lt;code&gt;Time&lt;/code&gt; 毫秒初始化或将终止，并开始函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="341a32ddba103c08ae86b78ec53524b7702998b8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it is terminated and the start function returns &lt;code&gt;{error,timeout}&lt;/code&gt;.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{timeout,Time}&lt;/code&gt; ，则允许 &lt;code&gt;gen_server&lt;/code&gt; 进程花费 &lt;code&gt;Time&lt;/code&gt; 毫秒初始化或终止它，并且start函数返回 &lt;code&gt;{error,timeout}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a928786d0e9ca7308ebc039e35ade6afdfb8bc1d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{tls, tls_options()}&lt;/code&gt; ，则FTP会话通过 &lt;code&gt;tls&lt;/code&gt; （ &lt;code&gt;ftps&lt;/code&gt; ，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt; ）进行传输。列表 &lt;code&gt;tls_options()&lt;/code&gt; 可以为空。函数 &lt;code&gt;ssl:connect/3&lt;/code&gt; 用于保护控制连接和数据会话。</target>
        </trans-unit>
        <trans-unit id="20a3a531905a20d30fd9f374cce827942989f5e9" translate="yes" xml:space="preserve">
          <source>If option&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;gen_statem&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2fd0a104622064a3e02a4f4c3eca0f47d309b91b" translate="yes" xml:space="preserve">
          <source>If or when &lt;code&gt;monitor/2&lt;/code&gt; is extended, other possible values for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;Info&lt;/code&gt; in the monitor message will be introduced.</source>
          <target state="translated">如果或当 &lt;code&gt;monitor/2&lt;/code&gt; 扩展时，将在监视器消息中引入 &lt;code&gt;Tag&lt;/code&gt; ， &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Info&lt;/code&gt; 的其他可能值。</target>
        </trans-unit>
        <trans-unit id="a47b00202aed4c182ff58ce236e280bf55db7d71" translate="yes" xml:space="preserve">
          <source>If other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have the driver loaded, this option has no effect.</source>
          <target state="translated">如果其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 已加载驱动程序，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="56b3ce2063e2924ca7e8faa87611f5b6c2819567" translate="yes" xml:space="preserve">
          <source>If parameter &lt;code&gt;Dates&lt;/code&gt; is specified, the reports are filtered according to the date when they occurred. If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateFrom, from}&lt;/code&gt;, reports that occurred after &lt;code&gt;DateFrom&lt;/code&gt; are displayed.</source>
          <target state="translated">如果指定参数&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; ，则根据报告的发生日期对报告进行过滤。如果&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; 的格式为 &lt;code&gt;{DateFrom, from}&lt;/code&gt; ，则显示在 &lt;code&gt;DateFrom&lt;/code&gt; 之后发生的报告。</target>
        </trans-unit>
        <trans-unit id="6511239690521e295477c51f44e7169510af0e54" translate="yes" xml:space="preserve">
          <source>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">如果可能的话,在对表进行迭代之前,避免在同一个事务中写入或删除记录。</target>
        </trans-unit>
        <trans-unit id="3eb1eeddf032eb186133fc7df8919fb2d11d384d" translate="yes" xml:space="preserve">
          <source>If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application.</source>
          <target state="translated">如果可能的话,客户端会根据配置和当前的情况,保持其连接的活力,并使用有或没有管道的持久连接。HTTP/1.1规范并没有为在持久连接上发送多少个理想的请求提供一个准则。这在很大程度上取决于应用程序。</target>
        </trans-unit>
        <trans-unit id="6eb80024b1f8a5a58791d40e0d60ce7a9e24c7b7" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</source>
          <target state="translated">如有可能,应将注释移到同一行的任何前面的分隔符之前。例如:</target>
        </trans-unit>
        <trans-unit id="11f459fa45ff86ea26d4123b486b2667eb195a88" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</source>
          <target state="translated">如果可能的话,应将注释移到同一行的任何分隔符之后,而不是将分隔符放在下一行。例如:</target>
        </trans-unit>
        <trans-unit id="0e22a764d95b33db30751234a49a657e83e7510e" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; module to extract the compiler options and the abstract code format from the Beam file and compile that instead.</source>
          <target state="translated">如果可能，请使用 &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; 模块从Beam文件中提取编译器选项和抽象代码格式，然后进行编译。</target>
        </trans-unit>
        <trans-unit id="aede57d6ae41eb953c1c470da89fb0e057e8b902" translate="yes" xml:space="preserve">
          <source>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</source>
          <target state="translated">如果优先级是客户端,则协商后的协议是客户端优先级列表中最先显示的协议,同时也是服务器广告列表中的协议。</target>
        </trans-unit>
        <trans-unit id="51ff54d9c737f36da2074bfa07dabdd6029e6f8a" translate="yes" xml:space="preserve">
          <source>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</source>
          <target state="translated">如果优先级是服务器,则协商后的协议是服务器广告列表中最先显示的协议,也就是客户端优先级列表中的协议。</target>
        </trans-unit>
        <trans-unit id="6739d735ae41522a99fdf3833670c2cb63d21a98" translate="yes" xml:space="preserve">
          <source>If present, this option specifies the options for the &lt;strong&gt;audit trail logging&lt;/strong&gt;. The &lt;code&gt;disk_log&lt;/code&gt; module is used to maintain a wrap log. If present, the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; options are mandatory.</source>
          <target state="translated">如果存在，则此选项指定&lt;strong&gt;审核跟踪日志记录&lt;/strong&gt;的选项。该 &lt;code&gt;disk_log&lt;/code&gt; 模块用于维护一个包的日志。如果存在，则必须使用 &lt;code&gt;dir&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="c374078c3ce837fa7c145904897f0747ce0fa052" translate="yes" xml:space="preserve">
          <source>If process metadata exists for the current process, this function behaves as if it was implemented as follows:</source>
          <target state="translated">如果当前进程存在进程元数据,这个函数的行为就像它的实现一样。</target>
        </trans-unit>
        <trans-unit id="6453efa6a699c594656266a7d0d5934c8aa65586" translate="yes" xml:space="preserve">
          <source>If pseudo function triggering the translation is &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single tuple. If the pseudo function is &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single list.</source>
          <target state="translated">如果触发转换的伪函数为 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; ，则fun的头必须包含单个变量或单个元组。如果伪函数是 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; ，则fun的头必须包含单个变量或单个列表。</target>
        </trans-unit>
        <trans-unit id="3bbf5cb920ce0732e8a77fc0ab511fa8e53d27bc" translate="yes" xml:space="preserve">
          <source>If quantifier is {0,n}, where n &amp;gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier.</source>
          <target state="translated">如果量词为{0，n}，其中n&amp;gt; 0，则将其视为{0,1}。在运行时，在有或没有断言的情况下尝试其余模式匹配，顺序取决于量词的贪婪程度。</target>
        </trans-unit>
        <trans-unit id="a4e6534fccad96b9c365841e907e49b7cde2c28d" translate="yes" xml:space="preserve">
          <source>If records are written and deleted during the traversal, use the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;write&lt;/code&gt; lock. Or the function &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; when using &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">如果在遍历期间写入和删除记录，请使用具有 &lt;code&gt;write&lt;/code&gt; 锁定功能的 &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 。或使用 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 时使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="169c4bd14dbb4d6e16657fce0c0a61cc8e3f8798" translate="yes" xml:space="preserve">
          <source>If reloading is not requested, it can still be useful to specify option &lt;code&gt;monitor&lt;/code&gt;, as forced unloads (driver option &lt;code&gt;kill_ports&lt;/code&gt; or option &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;) trigger a transient state where driver loading cannot be performed until all closing ports are closed. Thus, as &lt;code&gt;try_unload&lt;/code&gt; can, in almost all situations, return &lt;code&gt;{ok, pending_driver}&lt;/code&gt;, always specify at least &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; in production code (see the monitor discussion earlier).</source>
          <target state="translated">如果不要求重新加载，则指定option &lt;code&gt;monitor&lt;/code&gt; 仍然有用，因为强制卸载（驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 或option &lt;code&gt;kill_ports&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; ）会触发一个过渡状态，在该状态下，直到所有关闭端口都关闭后才能执行驱动程序加载。因此，由于 &lt;code&gt;try_unload&lt;/code&gt; 在几乎所有情况下都可以返回 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; ，所以请始终在生产代码中至少指定 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; （请参阅前面的监视器讨论）。</target>
        </trans-unit>
        <trans-unit id="55c076ea86b99a552c3ee63a0beaa5dfb25c1e33" translate="yes" xml:space="preserve">
          <source>If resolver option &lt;code&gt;inet6&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, an IPv6 address is looked up.</source>
          <target state="translated">如果resolver选项 &lt;code&gt;inet6&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则查找IPv6地址。</target>
        </trans-unit>
        <trans-unit id="71218f752e39cbf302806385e7e620598fcd4560" translate="yes" xml:space="preserve">
          <source>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</source>
          <target state="translated">如果在某个节点上启用了受限模式,连接到这个节点的远程shell也会以受限模式运行。</target>
        </trans-unit>
        <trans-unit id="81be79c2e31a4efcff85293a46775d5d0aa9c619" translate="yes" xml:space="preserve">
          <source>If run with option &lt;code&gt;caseless&lt;/code&gt;, this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop.</source>
          <target state="translated">如果使用option &lt;code&gt;caseless&lt;/code&gt; 运行，则此模式将匹配诸如&amp;ldquo;一个人，一个计划，一条运河：巴拿马！&amp;rdquo;之类的短语。它在PCRE和Perl中都可以很好地工作。注意使用所有格量词* +以避免回溯到非单词字符序列中。没有这个，PCRE需要更长的时间（10倍或更多）来匹配典型短语，而Perl花费的时间如此之长，以至于您认为它陷入了循环。</target>
        </trans-unit>
        <trans-unit id="56762a0f1f42178490b0db9862f2814f477e1842" translate="yes" xml:space="preserve">
          <source>If set before start, the &lt;code&gt;epmd&lt;/code&gt; daemon behaves as if option &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified at startup. Consequently, if this option is set before starting the Erlang virtual machine, the automatically started &lt;code&gt;epmd&lt;/code&gt; accepts the &lt;code&gt;-kill&lt;/code&gt; and &lt;code&gt;-stop&lt;/code&gt; commands without restrictions.</source>
          <target state="translated">如果在启动之前设置，则 &lt;code&gt;epmd&lt;/code&gt; 守护程序的行为就像在启动时指定了选项 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 一样。因此，如果在启动Erlang虚拟机之前设置了此选项，则自动启动的 &lt;code&gt;epmd&lt;/code&gt; 会不受限制地接受 &lt;code&gt;-kill&lt;/code&gt; 和 &lt;code&gt;-stop&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="9f59dad82faaa4c2914703b6f2eec0c0bd7bf03c" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置了hibernate &lt;code&gt;gen_statem&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt; 部分处理</target>
        </trans-unit>
        <trans-unit id="60eef1c452cfc1dd1bd601c01baa121d5df8c903" translate="yes" xml:space="preserve">
          <source>If set in binary mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;{binary, true}&lt;/code&gt;), the I/O server sends binary data (encoded in UTF-8) as answers to the &lt;code&gt;get_line&lt;/code&gt;, &lt;code&gt;get_chars&lt;/code&gt;, and, if possible, &lt;code&gt;get_until&lt;/code&gt; requests (for details, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt;) in the User's Guide). The immediate effect is that &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; return UTF-8 binaries instead of lists of characters for the affected I/O device.</source>
          <target state="translated">如果设置为二进制模式（ &lt;code&gt;binary&lt;/code&gt; 或 &lt;code&gt;{binary, true}&lt;/code&gt; ），则I / O服务器发送二进制数据（以UTF-8编码）作为对 &lt;code&gt;get_line&lt;/code&gt; ， &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_until&lt;/code&gt; 请求的答复（有关详细信息，请参见部分 &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; ）的用户指南中）。即时效果是 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 返回UTF-8二进制文件，而不是受影响的I / O设备的字符列表。</target>
        </trans-unit>
        <trans-unit id="60e11f2d401fbb6a7bc13e95b2d0df9464865aea" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置为推迟当前事件，请参阅 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt; 部分</target>
        </trans-unit>
        <trans-unit id="ff2642f766dbab3720562602e51b82a07e9e8906" translate="yes" xml:space="preserve">
          <source>If set the scheduler id is to be included by the tracer.</source>
          <target state="translated">如果设置了调度器ID,那么追踪器就会被包括在内。</target>
        </trans-unit>
        <trans-unit id="b36ae2f0946222aa466ec9f357bec978063329ec" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果设置，跟踪点将包含有关跟踪事件的其他数据。附加数据是什么取决于已触发的 &lt;code&gt;TraceTag&lt;/code&gt; 。所述 &lt;code&gt;extra&lt;/code&gt; 迹线数据对应于在跟踪元组的第五元素中描述 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="537421ac5bc876e1157770197d20f5be1d7bdfa8" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include a time stamp.</source>
          <target state="translated">如果设置了,则跟踪器已被要求包含一个时间戳。</target>
        </trans-unit>
        <trans-unit id="ebb92b7f506965bd75353ec4f02388501a5389c5" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include the output of a match specification that was run.</source>
          <target state="translated">如果设置,追踪器已被要求包含运行的匹配规范的输出。</target>
        </trans-unit>
        <trans-unit id="c658f8f2f205584d1fb8b1c5da7c1178ed36dd48" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, error reports are not displayed.</source>
          <target state="translated">如果设置为 &lt;code&gt;false&lt;/code&gt; ，则不显示错误报告。</target>
        </trans-unit>
        <trans-unit id="310d96f77be1e1791ce6fea41e63aca706ddcee9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; a header field is added to logger_formatter's part of &lt;code&gt;Metadata&lt;/code&gt;. The value of this field is a string similar to the header created by the old &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; event handlers. It can be included in the log event by adding the list &lt;code&gt;[logger_formatter,header]&lt;/code&gt; to the template. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则将头字段添加到logger_formatter的 &lt;code&gt;Metadata&lt;/code&gt; 部分。该字段的值是一个类似于旧的 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 事件处理程序创建的标头的字符串。通过将列表 &lt;code&gt;[logger_formatter,header]&lt;/code&gt; 添加到模板，可以将其包含在日志事件中。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 类型的描述。</target>
        </trans-unit>
        <trans-unit id="4ce4e9a3ec15985becd6d1fc4438e42ee9f02d87" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, all newlines in the message are replaced with &lt;code&gt;&quot;, &quot;&lt;/code&gt;, and white spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则消息中的所有换行符均被替换为 &lt;code&gt;&quot;, &quot;&lt;/code&gt; ，并且在换行符之后紧跟的空格被删除。请注意，不会替换由 &lt;code&gt;template&lt;/code&gt; 参数添加的换行符。</target>
        </trans-unit>
        <trans-unit id="d7bc2e449028a1b238287b1e7e1da57633ce0aa2" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;ct_master logs&lt;/code&gt; are written on a primitive HTML format, not using the &lt;code&gt;Common Test&lt;/code&gt; CSS style sheet.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;ct_master logs&lt;/code&gt; 以原始HTML格式编写，而不使用 &lt;code&gt;Common Test&lt;/code&gt; CSS样式表。</target>
        </trans-unit>
        <trans-unit id="c67db27336a237041f3f770706b8f2027a618516" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts &lt;code&gt;++&lt;/code&gt;-operators between string literals and macros where it looks like concatenation was intended. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，这会使 &lt;code&gt;epp_dodger&lt;/code&gt; 尝试在看起来合适的情况下修复源代码，在某些情况下，否则解析将失败。当前，它在看起来像串联的字符串文字和宏之间插入 &lt;code&gt;++&lt;/code&gt; -运算符。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553412c0540657c6dfbc0cf5ff30e8dae32d51db" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, use the server preference for cipher selection. If set to &lt;code&gt;false&lt;/code&gt; (the default), use the client preference.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则使用服务器首选项进行密码选择。如果设置为 &lt;code&gt;false&lt;/code&gt; （默认值），请使用客户端首选项。</target>
        </trans-unit>
        <trans-unit id="845d16e801c4d035d7da73e779db3b12f92e8193" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, workarounds for known server deviations from the HTTP-standard are enabled.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则启用针对服务器偏离HTTP标准的已知变通办法。</target>
        </trans-unit>
        <trans-unit id="4e5151c0c30a4e7bb11fe24669fcb768cff8dff0" translate="yes" xml:space="preserve">
          <source>If set to anything else than &lt;code&gt;0&lt;/code&gt;, it makes all times displayed by &lt;code&gt;run_erl&lt;/code&gt; to be in UTC (GMT, CET, MET, without Daylight Saving Time), rather than in local time. This does not affect data coming from Erlang, only the logs output directly by &lt;code&gt;run_erl&lt;/code&gt;. Application SASL can be modified accordingly by setting the Erlang application variable &lt;code&gt;utc_log&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;0&lt;/code&gt; 以外的任何值，它将使 &lt;code&gt;run_erl&lt;/code&gt; 显示的所有时间都以UTC（GMT，CET，MET，没有夏令时）显示，而不是本地时间。这不会影响来自Erlang的数据，只会影响 &lt;code&gt;run_erl&lt;/code&gt; 直接输出的日志。通过将Erlang应用程序变量 &lt;code&gt;utc_log&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,可以相应地修改应用程序SASL 。</target>
        </trans-unit>
        <trans-unit id="54ecba8897a2d3cf6ca4714afe4059ed1a0bc69c" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously.</source>
          <target state="translated">如果设置为false(默认值),则每次只处理一次登录。如果设置为 &quot;true&quot;,则允许同时进行无限次的登录尝试。</target>
        </trans-unit>
        <trans-unit id="f7e5e755a8f0aa4316d9b9f5d9dcea02be971e72" translate="yes" xml:space="preserve">
          <source>If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file.</source>
          <target state="translated">如果将密码设置为 &quot;NoPassword &quot;以外的其他选项,则所有API调用都需要密码。密码设置为 &quot;DummyPassword &quot;的情况下,其他的API调用前必须更改密码。为了保证验证数据的安全,密码必须在Web服务器启动后更改。否则,它将以清晰的文本写在配置文件中。</target>
        </trans-unit>
        <trans-unit id="cbc8baf201837b9902d99d9c6ceeaafc45b233fd" translate="yes" xml:space="preserve">
          <source>If several fields are to be assigned the same value, the following construction can be used:</source>
          <target state="translated">如果要给几个字段分配相同的值,可以使用以下结构。</target>
        </trans-unit>
        <trans-unit id="21ef3b935d35dcc97954564f91b02dc29963a181" translate="yes" xml:space="preserve">
          <source>If so, or if possibly needed in future versions, then you should consider using &lt;code&gt;gen_statem&lt;/code&gt; over &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">如果是这样，或者在将来的版本中可能需要，那么您应该考虑在 &lt;code&gt;gen_server&lt;/code&gt; 上使用 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33f2cb0ac87e42cdbdf8827c536efd85bb8b5ca2" translate="yes" xml:space="preserve">
          <source>If some of the found BEAM files contain &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then those modules are checked and a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果找到的某些BEAM文件包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则将检查这些模块并返回元组列表。每个元组的第一个元素是以下之一：</target>
        </trans-unit>
        <trans-unit id="6a5a8a25ced47d4519279df0ad60d300b9fdd3ac" translate="yes" xml:space="preserve">
          <source>If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.</source>
          <target state="translated">如果一些变量存在于配置中,但没有使用该函数加载,它们将和它们的别名一起从配置表中删除。</target>
        </trans-unit>
        <trans-unit id="908c252e088323e888f147ff16d100c7706161d0" translate="yes" xml:space="preserve">
          <source>If something goes wrong, the function can also return an error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">如果出现问题，该函数还可以返回一个错误元组 &lt;code&gt;{error,Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70476ad38abe74628a91e231b10da869d250c572" translate="yes" xml:space="preserve">
          <source>If specified by its filename, the filename can include a path and the &lt;code&gt;.erl&lt;/code&gt; extension can be omitted. The object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to it, and then in the current path.</source>
          <target state="translated">如果由其文件名指定，则文件名可以包含路径，并且可以省略 &lt;code&gt;.erl&lt;/code&gt; 扩展名。首先在与源代码相同的目录中搜索目标代码 &lt;code&gt;Module.beam&lt;/code&gt; ，然后在其旁边的 &lt;code&gt;ebin&lt;/code&gt; 目录中搜索，然后在当前路径中搜索。</target>
        </trans-unit>
        <trans-unit id="50b19f1c8b9a65cb742065615e51dec1da364a91" translate="yes" xml:space="preserve">
          <source>If specified by its module name, the object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path. The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in the same directory as the object code, then in an &lt;code&gt;src&lt;/code&gt; directory next to it.</source>
          <target state="translated">如果通过其模块名称指定，则在当前路径中搜索对象代码 &lt;code&gt;Module.beam&lt;/code&gt; 。首先在与目标代码相同的目录中搜索源代码 &lt;code&gt;Module.erl&lt;/code&gt; ，然后在其旁边的 &lt;code&gt;src&lt;/code&gt; 目录中进行搜索。</target>
        </trans-unit>
        <trans-unit id="a8d0b6cf013a5c0d8770719696ef065b65aefbe7" translate="yes" xml:space="preserve">
          <source>If starting the test with a general verbosity level of 50 (&lt;code&gt;?STD_VERBOSITY&lt;/code&gt;):</source>
          <target state="translated">如果以一般详细度级别50（ &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; ）开始测试：</target>
        </trans-unit>
        <trans-unit id="bff20119788e7f9fcb0386bb0ba5f7207f1771ed" translate="yes" xml:space="preserve">
          <source>If starting the test with:</source>
          <target state="translated">如果以下列方式开始测试:</target>
        </trans-unit>
        <trans-unit id="26a65a58a274c5e83de124292f3254f1ac090467" translate="yes" xml:space="preserve">
          <source>If status was &lt;code&gt;alive&lt;/code&gt;, node &lt;code&gt;A&lt;/code&gt; answers with another status message containing either &lt;code&gt;true&lt;/code&gt;, which means that the connection is to continue (the old connection from this node is broken), or &lt;code&gt;false&lt;/code&gt;, which means that the connection is to be closed (the connection attempt was a mistake.</source>
          <target state="translated">如果status处于 &lt;code&gt;alive&lt;/code&gt; 状态，则节点 &lt;code&gt;A&lt;/code&gt; 回答另一个状态消息，其中包含 &lt;code&gt;true&lt;/code&gt; 表示连接将继续（此节点的旧连接断开）或 &lt;code&gt;false&lt;/code&gt; 表示将关闭连接（连接尝试是错误的。</target>
        </trans-unit>
        <trans-unit id="7b9b70b7cbd405f4ef48bddbc33725b6c4cf3c30" translate="yes" xml:space="preserve">
          <source>If sticky locks are used, the code must first be changed as follows:</source>
          <target state="translated">如果使用粘性锁,必须先修改代码,如下。</target>
        </trans-unit>
        <trans-unit id="c7eb71447bfe22582a45b3625c21c45102fb30a5" translate="yes" xml:space="preserve">
          <source>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</source>
          <target state="translated">如果在正则表达式中指定了子表达式,那么在生成的列表中也会返回匹配的子表达式。例如</target>
        </trans-unit>
        <trans-unit id="0b8ddaa042ba6e6a6e6f3aa8c56ca060f0b33630" translate="yes" xml:space="preserve">
          <source>If successful</source>
          <target state="translated">如果成功</target>
        </trans-unit>
        <trans-unit id="211664819a4310bd77112b972f6e1afd6ef67b18" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state in an &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple.</source>
          <target state="translated">如果成功，该函数必须在 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 元组中返回更新的内部状态。</target>
        </trans-unit>
        <trans-unit id="4e8c6ee9fde6d55757690d169dc69ff0e99e718e" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state.</source>
          <target state="translated">如果成功,该函数必须返回更新的内部状态。</target>
        </trans-unit>
        <trans-unit id="932989b7c1361152a0b0809cc73761645d677b31" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; exists but the corresponding child process is running or is about to be restarted, the function returns &lt;code&gt;{error,running}&lt;/code&gt; or &lt;code&gt;{error,restarting}&lt;/code&gt;, respectively. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;ok&lt;/code&gt; 。如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范存在，但相应的子进程正在运行或将要重新启动，则该函数分别返回 &lt;code&gt;{error,running}&lt;/code&gt; 或 &lt;code&gt;{error,restarting}&lt;/code&gt; 。如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范不存在，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a7459c85147eae0af4289577e8d8cb1033070c0" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is no child specification with the specified &lt;code&gt;Id&lt;/code&gt;, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;ok&lt;/code&gt; 。如果没有带有指定 &lt;code&gt;Id&lt;/code&gt; 子规范，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c554336fd49d3d6148f3873055df50396396c91" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;{ok,State}&lt;/code&gt; or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial internal state of the event handler.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;{ok,State}&lt;/code&gt; 或 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是事件处理程序的初始内部状态。</target>
        </trans-unit>
        <trans-unit id="2203259483f235e1b092ade2119d4c07d6241b2e" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map or if it does not contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;map_in&lt;/code&gt; 不是地图或不包含 &lt;code&gt;key&lt;/code&gt; ,则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba18cbb490e9c8d2f3b6ef180516f04715f3defa" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;map_in&lt;/code&gt; 不是地图，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c57bdf287994755b6e44fdfc60facab5a9f11a53" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; there are any duplicate keys.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。返回 &lt;code&gt;false&lt;/code&gt; 有任何重复的键。</target>
        </trans-unit>
        <trans-unit id="235077c5f09d774b9f3db45cd19ec2e827847cd9" translate="yes" xml:space="preserve">
          <source>If such a clause cannot be found, a &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">如果找不到这样的子句，则会发生 &lt;code&gt;function_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="283f86d98b5d92d6ad1ce6bfc63055da78218576" translate="yes" xml:space="preserve">
          <source>If such a clause is found, the corresponding clause body is evaluated. That is, the expressions in the body are evaluated sequentially and the value of the last expression is returned.</source>
          <target state="translated">如果找到了这样的子句,就会对相应的子句体进行评估。也就是说,正文中的表达式依次被评估,最后一个表达式的值被返回。</target>
        </trans-unit>
        <trans-unit id="b2fcf16676aca666b69b183aa34b448a75829f94" translate="yes" xml:space="preserve">
          <source>If synchronization is not possible, an error report is sent to the error logger (see also &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果无法同步，则​​会将错误报告发送到错误记录器（另请参见 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="36f347d7b778b3a4f6fb90496e2acb23c2a7a864" translate="yes" xml:space="preserve">
          <source>If syntax errors are discovered in these files they are reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; at start-up.</source>
          <target state="translated">如果在这些文件中发现语法错误，则会在启动时通过 &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; 的功能 &lt;code&gt;config_err/2&lt;/code&gt; 报告它们。</target>
        </trans-unit>
        <trans-unit id="e5db19b0c235be5b01f2325198c01dc60d89585f" translate="yes" xml:space="preserve">
          <source>If tagged allocations are not enabled on any of the specified allocator types, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">如果未在任何指定的分配器类型上启用标记的分配，则调用将失败，并显示 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="430e9485ed1c99e4dac7dca3da3dfa4aa8c39ab8" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; cannot be compiled (does not represent a valid match specification), a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果无法编译术语 &lt;code&gt;MatchSpec&lt;/code&gt; （不表示有效的匹配规范），则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="b34a1091c99e6fe485396a9633ee9cf35b5e6022" translate="yes" xml:space="preserve">
          <source>If test suites or help modules include header files stored in other locations than the test directory, these include directories can be specified by using flag &lt;code&gt;-include&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, or option &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. Also, an include path can be specified with an OS environment variable, &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt;.</source>
          <target state="translated">如果测试套件或帮助模块包括存储在与测试目录的其它位置的头文件，这些包括可通过使用标志来指定的目录 &lt;code&gt;-include&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; ，或选项 &lt;code&gt;include&lt;/code&gt; 与 &lt;code&gt;ct:run_test/1&lt;/code&gt; 。另外，可以使用OS环境变量 &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt; 指定包含路径。</target>
        </trans-unit>
        <trans-unit id="c9279b9016abb718b19436b545788de84fa2134f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, BEAM files that contain no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">如果外部参照服务器的 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;functions&lt;/code&gt; ，则不包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; BEAM文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="c813a10d16024092b88cb717d0c880a3632b14a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, and the BEAM file contains no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, the error message &lt;code&gt;no_debug_info&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;no_debug_info&lt;/code&gt; 参照服务器的 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;functions&lt;/code&gt; ，并且BEAM文件不包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则返回错误消息no_debug_info。</target>
        </trans-unit>
        <trans-unit id="0b9197e338e3401c234d140df6601d7f0bd0de9f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;handle_event_function&lt;/code&gt; ，则状态可以为任何术语。状态更改后（ &lt;code&gt;NextState =/= State&lt;/code&gt; ），将重试所有延迟的事件。</target>
        </trans-unit>
        <trans-unit id="74c7a5f40b37419e0dfdb9c000a09ebaefa7ede7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be of this type. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;state_functions&lt;/code&gt; ，则状态必须为这种类型。状态更改后（ &lt;code&gt;NextState =/= State&lt;/code&gt; ），将重试所有延迟的事件。</target>
        </trans-unit>
        <trans-unit id="720d616c478f9b1d1e0e376e567468c7cbccb10c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">如果已在 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ，即使驱动器已表示忙，也可以通过 &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; 将数据强制进入驱动器。</target>
        </trans-unit>
        <trans-unit id="b5b8a260b0935e82c1c23c647ce2490c52e709f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_control/3&lt;/code&gt; is a binary, the driver will be passed a pointer to the contents of the binary and the binary will not be copied. If the &lt;code&gt;Data&lt;/code&gt; argument is an iolist (list of binaries and lists), all binaries in the iolist will be copied.</source>
          <target state="translated">如果 &lt;code&gt;port_control/3&lt;/code&gt; 的 &lt;code&gt;Data&lt;/code&gt; 参数是二进制文件，则将向驱动程序传递指向二进制文件内容的指针，并且不会复制二进制文件。如果 &lt;code&gt;Data&lt;/code&gt; 参数是iolist（二进制文件和列表的列表），则将复制iolist中的所有二进制文件。</target>
        </trans-unit>
        <trans-unit id="9f73654015166f98aadbf7b3b123e17e68232e9b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HEART_COMMAND&lt;/code&gt; environment variable is to be set in the &lt;code&gt;start&lt;/code&gt; script in &lt;strong&gt;Starting Erlang&lt;/strong&gt;, and if the value is to be set to the path of the Solaris &lt;code&gt;reboot&lt;/code&gt; command, that is:</source>
          <target state="translated">如果要在&amp;ldquo; &lt;code&gt;start&lt;/code&gt; &lt;strong&gt;Erlang&amp;rdquo;&lt;/strong&gt;中的启动脚本中设置 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 环境变量，并且要将值设置为Solaris &lt;code&gt;reboot&lt;/code&gt; 命令的路径，即：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="944e73a76d9846f1844b61fadd1ef6be5fa46f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Item&lt;/code&gt; is a string &quot;&amp;lt;X.Y.Z&amp;gt;&quot; as returned from &lt;code&gt;pid_to_list/1&lt;/code&gt;, the process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">如果 &lt;code&gt;Item&lt;/code&gt; 是从 &lt;code&gt;pid_to_list/1&lt;/code&gt; 返回的字符串&amp;ldquo; &amp;lt;XYZ&amp;gt;&amp;rdquo; ，则将跟踪进程 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eca5d5aa872cbcbe9a56199f7268cf843102ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Mod&lt;/code&gt; argument is given, the result contains a &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for module &lt;code&gt;Mod&lt;/code&gt; only, otherwise the result contains one &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for all modules returned from &lt;code&gt;code:all_loaded()&lt;/code&gt; except &lt;code&gt;cprof&lt;/code&gt; itself.</source>
          <target state="translated">如果给出了 &lt;code&gt;Mod&lt;/code&gt; 参数，则结果仅包含模块 &lt;code&gt;Mod&lt;/code&gt; 的 &lt;code&gt;ModAnalysis&lt;/code&gt; 元组，否则结果包含从 &lt;code&gt;code:all_loaded()&lt;/code&gt; 返回的所有模块（ &lt;code&gt;cprof&lt;/code&gt; 本身除外）的一个 &lt;code&gt;ModAnalysis&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="692d7ddeb29364bd451d87d06edbd7eec80bea02" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has been set, a &lt;code&gt;NewAtomCacheRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">如果 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 下一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 已定，一个 &lt;code&gt;NewAtomCacheRef&lt;/code&gt; 以下格式如下：</target>
        </trans-unit>
        <trans-unit id="04c0254fa6d70d431ad5a486ddf123ee44618a15" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has not been set, a &lt;code&gt;CachedAtomRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">如果 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 为下一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 设置 &lt;code&gt;CachedAtomRef&lt;/code&gt; ，则遵循以下格式的CachedAtomRef：</target>
        </trans-unit>
        <trans-unit id="5abbbca51e0d96970bfc6e932a6073fa6c1b8d91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WrapSize&lt;/code&gt; is specified as &lt;code&gt;{time, WrapTime}&lt;/code&gt;, the current file is closed when it has been open more than &lt;code&gt;WrapTime&lt;/code&gt; milliseconds, regardless of it being empty or not.</source>
          <target state="translated">如果 &lt;code&gt;WrapSize&lt;/code&gt; 指定为 &lt;code&gt;{time, WrapTime}&lt;/code&gt; ，则当前文件在打开超过 &lt;code&gt;WrapTime&lt;/code&gt; 毫秒后将关闭，无论它是否为空。</target>
        </trans-unit>
        <trans-unit id="3bce9200cd49c0302061751c509bff17706e1d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;collector_pid&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; a new &lt;code&gt;et_collector&lt;/code&gt; will be started with the following parameter settings: &lt;code&gt;parent_pid&lt;/code&gt;, &lt;code&gt;event_order&lt;/code&gt;, &lt;code&gt;trace_global&lt;/code&gt;, &lt;code&gt;trace_pattern&lt;/code&gt;, &lt;code&gt;trace_port&lt;/code&gt;, &lt;code&gt;trace_max_queue&lt;/code&gt;, &lt;code&gt;trace_client&lt;/code&gt;, &lt;code&gt;dict_insert&lt;/code&gt; and &lt;code&gt;dict_delete&lt;/code&gt;. The new &lt;code&gt;et_viewer&lt;/code&gt; will register itself as an &lt;code&gt;et_collector&lt;/code&gt; subscriber.</source>
          <target state="translated">如果 &lt;code&gt;collector_pid&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 新 &lt;code&gt;et_collector&lt;/code&gt; 将以下参数设置开始： &lt;code&gt;parent_pid&lt;/code&gt; ， &lt;code&gt;event_order&lt;/code&gt; ， &lt;code&gt;trace_global&lt;/code&gt; ， &lt;code&gt;trace_pattern&lt;/code&gt; ， &lt;code&gt;trace_port&lt;/code&gt; ， &lt;code&gt;trace_max_queue&lt;/code&gt; ， &lt;code&gt;trace_client&lt;/code&gt; ， &lt;code&gt;dict_insert&lt;/code&gt; 和 &lt;code&gt;dict_delete&lt;/code&gt; 。新的 &lt;code&gt;et_viewer&lt;/code&gt; 将自己注册为 &lt;code&gt;et_collector&lt;/code&gt; 订阅者。</target>
        </trans-unit>
        <trans-unit id="1705267e03ee01724d59b40bc5f0214567319c46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; and/or &lt;code&gt;per_cpu&lt;/code&gt; option is given, this is the CPU number, or a list of the CPU numbers.</source>
          <target state="translated">如果 &lt;code&gt;detailed&lt;/code&gt; 和/或 &lt;code&gt;per_cpu&lt;/code&gt; 选项，则这是CPU数量或CPU号码列表。</target>
        </trans-unit>
        <trans-unit id="e77d603a3001a1e9c1762cdeaacfe7bfa22a3f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; option is given, this is a list of &lt;code&gt;{State, Share}&lt;/code&gt; tuples, where each tuple contains information about a processor state that has been identified as a busy processor state (see below). The atom &lt;code&gt;State&lt;/code&gt; is the name of the state, and the float &lt;code&gt;Share&lt;/code&gt; represents the percentage share of the CPU cycles spent in this state since the last call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;detailed&lt;/code&gt; 选项，则这是 &lt;code&gt;{State, Share}&lt;/code&gt; 元组的列表，其中每个元组都包含有关已被标识为繁忙处理器状态的处理器状态的信息（请参见下文）。 &lt;code&gt;State&lt;/code&gt; 原子是状态的名称，float &lt;code&gt;Share&lt;/code&gt; 代表自从上次调用 &lt;code&gt;util/0&lt;/code&gt; 或 &lt;code&gt;util/1&lt;/code&gt; 以来在此状态下花费的CPU周期所占的百分比。</target>
        </trans-unit>
        <trans-unit id="01f6b148b35fa3a772ed4cf02b8f14d1a3fb663b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;excl_lib&lt;/code&gt; option is set to &lt;code&gt;otp_root&lt;/code&gt; then reltool will not copy anything from the Erlang/OTP installation ($OTP_ROOT) into the target structure. The goal is to create a &quot;slim&quot; release which can be used together with an existing Erlang/OTP installation. The target structure will therefore only contain a &lt;code&gt;lib&lt;/code&gt; directory with the applications that were found outside of $OTP_ROOT (typically your own applications), and a &lt;code&gt;releases&lt;/code&gt; directory with the generated &lt;code&gt;.rel,&lt;/code&gt;&lt;code&gt;.script&lt;/code&gt; and &lt;code&gt;.boot&lt;/code&gt; files.</source>
          <target state="translated">如果将 &lt;code&gt;excl_lib&lt;/code&gt; 选项设置为 &lt;code&gt;otp_root&lt;/code&gt; ,则reltool不会将任何内容从Erlang / OTP安装（$ OTP_ROOT）复制到目标结构中。目标是创建一个&amp;ldquo;超薄&amp;rdquo;发行版，可与现有的Erlang / OTP安装一起使用。因此，目标结构将只包含一个 &lt;code&gt;lib&lt;/code&gt; 与所发现的$ OTP_ROOT（通常是您自己的应用程序）以外的应用程序目录，并且 &lt;code&gt;releases&lt;/code&gt; 与生成目录 &lt;code&gt;.rel,&lt;/code&gt; &lt;code&gt;.script&lt;/code&gt; 和 &lt;code&gt;.boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="be47c608e84207db441f123dc3b022c3bdfe3832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fprof&lt;/code&gt; server is not running, this function returns immediately with the same return value.</source>
          <target state="translated">如果 &lt;code&gt;fprof&lt;/code&gt; 服务器未运行，则此函数将立即以相同的返回值返回。</target>
        </trans-unit>
        <trans-unit id="4cfc64c80cf0754288971ed2f55082185d9efbaf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_event&lt;/code&gt; is to be able to receive other messages than events, the callback function &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_event&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">如果 &lt;code&gt;gen_event&lt;/code&gt; 能够接收事件以外的其他消息，则必须实现回调函数 &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; 来处理它们。其他消息的示例是退出消息，如果 &lt;code&gt;gen_event&lt;/code&gt; 链接到其他进程（而不是主管），并且捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="5aad944a4a47c5bc78a9273e949274df0e9ed557" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is not part of a supervision tree, a stop function can be useful, for example:</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 不属于监督树，则停止功能可能很有用，例如：</target>
        </trans-unit>
        <trans-unit id="4832a13c9684cb02c06fa828f9150cd6ab481d33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_server&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 是监视树的一部分，则不需要停止功能。该 &lt;code&gt;gen_server&lt;/code&gt; 由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="3b4cc7e563bc4ab43d392728008910f94dfb10ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is to be able to receive other messages than requests, the callback function &lt;code&gt;handle_info(Info, State)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_server&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 能够接收请求以外的其他消息，则必须实现回调函数 &lt;code&gt;handle_info(Info, State)&lt;/code&gt; 来处理它们。其他消息的示例是退出消息，如果 &lt;code&gt;gen_server&lt;/code&gt; 链接到其他进程（而不是主管），并且捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="2f9738619fd7812022c1fdbad1b01a2e041bfacc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason=shutdown&lt;/code&gt; if the following conditions apply:</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 过程监督树的一部分，由监管当局终止命令，这个函数被调用， &lt;code&gt;Reason=shutdown&lt;/code&gt; 如果满足下列条件：</target>
        </trans-unit>
        <trans-unit id="deb0cd9df07520473713789c264957ed22e0fd37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is successfully created and initialized, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the &lt;code&gt;gen_server&lt;/code&gt; process. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果成功创建并初始化了 &lt;code&gt;gen_server&lt;/code&gt; 进程，则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 进程的pid 。如果具有指定 &lt;code&gt;ServerName&lt;/code&gt; 的进程已经存在，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="7b56e5a9d7d5389ddf0dc35b8aa333d9d01bbefc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return &lt;code&gt;{continue,Continue}&lt;/code&gt; in place of the time-out or hibernation value, which will immediately invoke the &lt;code&gt;handle_continue/2&lt;/code&gt; callback.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 进程需要在初始化后立即执行操作或将回调的执行分为多个步骤，则可以返回 &lt;code&gt;{continue,Continue}&lt;/code&gt; 来代替超时或休眠值，后者将立即调用 &lt;code&gt;handle_continue/2&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="490e75ed674d410c271a45a56872f3c49ab0b58b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is not part of a supervision tree, it can be stopped using &lt;code&gt;gen_statem:stop&lt;/code&gt;, preferably through an API function:</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 不是监视树的一部分，则可以使用 &lt;code&gt;gen_statem:stop&lt;/code&gt; 停止它，最好通过API函数停止：</target>
        </trans-unit>
        <trans-unit id="36f4edf0379e907c933af357c419f98ac2861c66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason = shutdown&lt;/code&gt; if both the following conditions apply:</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 是监视树的一部分，并且由其主管命令终止，则如果同时满足以下两个条件，则使用 &lt;code&gt;Reason = shutdown&lt;/code&gt; 调用此函数：</target>
        </trans-unit>
        <trans-unit id="ac199e9236c5ed4f285d3986ed2287bb9a4c55ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_statem&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 是监视树的一部分，则不需要停止功能。该 &lt;code&gt;gen_statem&lt;/code&gt; 由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="622dc023e6ca738739a4198b61e3fabf701c009b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is successfully created and initialized, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of that process.</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 成功创建和初始化，这个函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; 中的 &lt;code&gt;gen_statem&lt;/code&gt; 。如果已经存在具有指定 &lt;code&gt;ServerName&lt;/code&gt; 的进程，则此函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的 &lt;code&gt;pid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7d4b7b9947ceb2e1f75b847cb2c2cefc610ce87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inform request behaviour&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">如果 &lt;code&gt;inform request behaviour&lt;/code&gt; 配置选项设置为 &lt;code&gt;user&lt;/code&gt; 或 &lt;code&gt;{user, integer()}&lt;/code&gt; ，则在此函数返回时将发送对此通知请求的响应（确认）。</target>
        </trans-unit>
        <trans-unit id="f12a4aa7db27654fb06f0356ee419770a3c5990d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;main/1&lt;/code&gt; function in the script returns successfully, the exit status for the script is &lt;code&gt;0&lt;/code&gt;. If an exception is generated during execution, a short message is printed and the script terminates with exit status &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">如果脚本中的 &lt;code&gt;main/1&lt;/code&gt; 函数成功返回，则脚本的退出状态为 &lt;code&gt;0&lt;/code&gt; 。如果在执行期间生成异常，则会打印一条短消息，并且脚本以退出状态 &lt;code&gt;127&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="6df86c1718762f44b04c0cb308484d1d6c310a34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;max_sessions&lt;/code&gt; option is set to &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;parallel_login&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the maximum number of simultaneous login attempts at any time is limited to &lt;code&gt;N-K&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; is the number of authenticated connections present at this daemon.</source>
          <target state="translated">如果将 &lt;code&gt;max_sessions&lt;/code&gt; 选项设置为 &lt;code&gt;N&lt;/code&gt; 并将 &lt;code&gt;parallel_login&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则在任何时候的最大同时登录尝试次数将限制为 &lt;code&gt;N-K&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 是此守护程序中已认证连接的数量。</target>
        </trans-unit>
        <trans-unit id="279c740df4997832935268858ff97ba56a5fb972" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;parse_transform&lt;/code&gt; is not applied to a module that calls this pseudo function, the call fails in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; module exports a function with this name, but it is never to be called except when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including header file &lt;code&gt;ms_transform.hrl&lt;/code&gt;, compiled code never calls the function, but the function call is replaced by a literal match specification.</source>
          <target state="translated">如果 &lt;code&gt;parse_transform&lt;/code&gt; 没有应用于调用此伪函数的模块，则调用将在运行时失败（带有 &lt;code&gt;badarg&lt;/code&gt; ）。在 &lt;code&gt;ets&lt;/code&gt; 模块导出的函数使用这个名称，但它永远不会被称为在外壳使用功能时除外。如果 &lt;code&gt;parse_transform&lt;/code&gt; 正确通过包含头文件应用 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，编译的代码永远不会调用的功能，但功能调用由字面匹配规范所取代。</target>
        </trans-unit>
        <trans-unit id="91c8b62af5511bc181fbe7c0815f7318805644f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;per_cpu&lt;/code&gt; is not given, the value(s) presented are the average of all CPUs.</source>
          <target state="translated">如果未给出 &lt;code&gt;per_cpu&lt;/code&gt; ，则显示的值是所有CPU的平均值。</target>
        </trans-unit>
        <trans-unit id="2c4b5f09b562c0e8df5ab61a0939a3cca6eab6e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;qlc&lt;/code&gt; module at compile time can determine that some constant is free of integers, it does not matter which one of &lt;code&gt;==/2&lt;/code&gt; or &lt;code&gt;=:=/2&lt;/code&gt; is used:</source>
          <target state="translated">如果 &lt;code&gt;qlc&lt;/code&gt; 模块在编译时可以确定某个常量没有整数，则使用 &lt;code&gt;==/2&lt;/code&gt; 或 &lt;code&gt;=:=/2&lt;/code&gt; 中的哪一个都没有关系：</target>
        </trans-unit>
        <trans-unit id="345d6310f85895e6842a34eabfe92151229e6b95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It it only to contain low-level instructions.</source>
          <target state="translated">如果 &lt;code&gt;relup&lt;/code&gt; 文件相对简单，则可以手动创建。它仅包含低级指令。</target>
        </trans-unit>
        <trans-unit id="c30c579f26aae9f62a722f68b38557366dc19832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令在脚本中，发现 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。这是因为 &lt;code&gt;restart_new_emulator&lt;/code&gt; 要求在执行其余升级指令之前必须启动新版本的模拟器，并且只能通过 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="a3734548d24c8fafceb3c3b7a48423c44c0a982c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在脚本中找到 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令，则 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。这是因为 &lt;code&gt;restart_new_emulator&lt;/code&gt; 要求在执行其余升级指令之前必须启动新版本的模拟器，并且只能通过 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="52741bb5942e459f72dab152ca12b8b26eff70c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/3,4&lt;/code&gt; function is used, all management targets are selected, as defined in RFC2273. The &lt;code&gt;Receiver&lt;/code&gt; parameter defines where the agent should send information about the delivery of inform requests.</source>
          <target state="translated">如果使用 &lt;code&gt;send_notification/3,4&lt;/code&gt; 函数，则将选择所有管理目标，如RFC2273中所定义。所述 &lt;code&gt;Receiver&lt;/code&gt; 参数定义了代理应该发送有关传输的信息通知请求。</target>
        </trans-unit>
        <trans-unit id="4e603d462637bea7ebad3ed1b02ae3e6befcd5e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/5&lt;/code&gt; function is used, an &lt;code&gt;NotifyName&lt;/code&gt; must be provided. This parameter is used as an index in the &lt;code&gt;snmpNotifyTable&lt;/code&gt;, and the management targets defined by that single entry is used.</source>
          <target state="translated">如果使用 &lt;code&gt;send_notification/5&lt;/code&gt; 函数， &lt;code&gt;NotifyName&lt;/code&gt; 必须提供一个NotifyName。此参数用作 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 中的索引，并且使用由该单个条目定义的管理目标。</target>
        </trans-unit>
        <trans-unit id="13bd2cdf7f65d1258410067e1dbfa02e06ec92b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">如果 &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; 未启用 &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt; ，启用它。</target>
        </trans-unit>
        <trans-unit id="275e62491f49fb1a70d7127de6210ff8d9a19127" translate="yes" xml:space="preserve">
          <source>If the ASN.1 module has been compiled with option &lt;code&gt;maps&lt;/code&gt;, the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; are represented as maps.</source>
          <target state="translated">如果ASN.1模块已使用选项 &lt;code&gt;maps&lt;/code&gt; 进行编译，则 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 类型将表示为映射。</target>
        </trans-unit>
        <trans-unit id="722c5c772253cfa0375f5705288b0321c521aa8d" translate="yes" xml:space="preserve">
          <source>If the AckStatus is ok, it is indicating that this is a true acknowledgement of the transaction reply.</source>
          <target state="translated">如果AckStatus是ok,说明这是一个真实的事务回复确认。</target>
        </trans-unit>
        <trans-unit id="d0f84b01e010783659e66100fe954814d18e563f" translate="yes" xml:space="preserve">
          <source>If the AckStatus is {error, Reason}, it is an indication that the acknowledgement or even the reply (for which this is an acknowledgement) was not delivered, but there is no point in waiting any longer for it to arrive. This happens when:</source>
          <target state="translated">如果AckStatus是{error,Reason},则表明确认甚至是回复(对其而言,这是一个确认)没有送达,但没有必要再等待它的到来。这种情况发生在:</target>
        </trans-unit>
        <trans-unit id="88faac2c33abe1fdc3fc1b10f5136c262bb64e7a" translate="yes" xml:space="preserve">
          <source>If the BEAM file contains &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果BEAM文件包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则返回元组列表。每个元组的第一个元素是以下之一：</target>
        </trans-unit>
        <trans-unit id="52ebbcd03e14972b092b8f0cc1bbe4c3dd868b59" translate="yes" xml:space="preserve">
          <source>If the BEAM file does not contain debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果BEAM文件不包含调试信息,那么将返回一个元组列表。每个元组的第一个元素是以下之一:</target>
        </trans-unit>
        <trans-unit id="5e318cbbe5a1c0ec48c8b2b2021ac1f10131570e" translate="yes" xml:space="preserve">
          <source>If the C node acts as a server, it must first create a socket (call &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;) listening to a certain port number &lt;code&gt;port&lt;/code&gt;. It then publishes its name and port number with &lt;code&gt;epmd&lt;/code&gt;, the Erlang port mapper daemon. For details, see the &lt;code&gt;epmd&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">如果C节点充当服务器，则它必须首先创建一个侦听某个端口号 &lt;code&gt;port&lt;/code&gt; 的套接字（调用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;listen()&lt;/code&gt; ）。然后，它使用Erlang端口映射器守护程序 &lt;code&gt;epmd&lt;/code&gt; 发布其名称和端口号。有关详细信息，请参见ERTS中的 &lt;code&gt;epmd&lt;/code&gt; 手册页：</target>
        </trans-unit>
        <trans-unit id="82d38ec527a550307461604062c03b211a833f6c" translate="yes" xml:space="preserve">
          <source>If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).</source>
          <target state="translated">如果COND1模式匹配,则尝试FOO(如果FOO成功,则可能在该组结束后再尝试其他项目)。失败时,匹配器跳转到第二个选项,并尝试COND2,而不回溯到COND1。如果成功而BAR失败,则尝试COND3。如果BAZ再失败,就没有更多的备选方案了,所以要回溯到整个组之前的任何方案。如果(*THEN)不在一个交替范围内,它的作用就像(*PRUNE)。</target>
        </trans-unit>
        <trans-unit id="ac5eaef6ff1820888de0ffa5ad9b4186d0234433" translate="yes" xml:space="preserve">
          <source>If the CPU information has changed since the last time it was read, the atom &lt;code&gt;changed&lt;/code&gt; is returned, otherwise the atom &lt;code&gt;unchanged&lt;/code&gt;. If the CPU information has changed, you probably want to &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt;. You typically want to have as many schedulers online as &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果因为它读取的最后一次CPU的信息发生了变化，原子 &lt;code&gt;changed&lt;/code&gt; 返回，否则原子 &lt;code&gt;unchanged&lt;/code&gt; 。如果CPU的信息发生了变化，你可能要 &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt; 。您通常希望在线拥有尽可能多的调度程序与 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674a0c6bf29cc8c8f0b253946e997318f6046675" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the &lt;code&gt;auth_group_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">如果使用Dets存储方法，则组数据库由Dets维护，并且不能手工编辑。使用模块 &lt;code&gt;mod_auth&lt;/code&gt; 的API 创建/编辑组数据库。如果使用Mnesia存储方法，则忽略此伪指令。出于安全原因，请确保 &lt;code&gt;auth_group_file&lt;/code&gt; 存储在Web服务器的文档树之外。如果将其放置在受保护的目录中，则客户端可以下载它。</target>
        </trans-unit>
        <trans-unit id="2690e1607b444fbdfb4354a7fc5e69fab4fc5a65" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that &lt;code&gt;auth_user_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">如果使用Dets存储方法，则用户数据库由Dets维护，并且不能手工编辑。使用模块 &lt;code&gt;mod_auth&lt;/code&gt; 中的API函数来创建/编辑用户数据库。如果使用Mnesia存储方法，则忽略此伪指令。出于安全原因，请确保 &lt;code&gt;auth_user_file&lt;/code&gt; 存储在Web服务器的文档树之外。如果将其放置在受保护的目录中，则客户端可以下载它。</target>
        </trans-unit>
        <trans-unit id="5d6f0952016312ac237e99b15d9161adf55f700d" translate="yes" xml:space="preserve">
          <source>If the Erlang node was alive, that is, set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</source>
          <target state="translated">如果Erlang节点是活着的,也就是说,设置了与其他节点的通信,这部分列出了活跃的连接。可以存在以下字段。</target>
        </trans-unit>
        <trans-unit id="18daf2db870215dd47d6849bc420623f1e0d4030" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</source>
          <target state="translated">如果Erlang运行时系统是唯一一个将线程绑定到逻辑处理器的操作系统进程,这就会提高运行时系统的性能。但是,如果其他OS进程(例如,另一个Erlang运行时系统)也将线程绑定到逻辑处理器上,反而会出现性能惩罚。有时这种性能惩罚可能很严重。如果是这样,建议不要绑定调度器。</target>
        </trans-unit>
        <trans-unit id="3549c6b8d3c0426e098c164e7bd7160b6e4be362" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system. However, if other operating system processes (for example another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. This performance penalty can sometimes be severe. If so, you are advised not to bind the schedulers.</source>
          <target state="translated">如果Erlang运行时系统是唯一一个将线程绑定到逻辑处理器的操作系统进程,这就会提高运行时系统的性能。但是,如果其他操作系统进程(例如另一个Erlang运行时系统)也将线程绑定到逻辑处理器上,反而会出现性能惩罚。这种性能惩罚有时会很严重。如果是这样,建议你不要绑定调度器。</target>
        </trans-unit>
        <trans-unit id="78b8e3a5a6a0636736a794de9e5a1415d4c36fbf" translate="yes" xml:space="preserve">
          <source>If the Erlang shell buffer would be killed the command line history is saved to a file. The command line history is automatically retrieved when a new Erlang shell is started.</source>
          <target state="translated">如果Erlang shell缓冲区被杀死,命令行历史记录会被保存到一个文件中。当一个新的 Erlang shell 启动时,命令行历史记录会被自动检索。</target>
        </trans-unit>
        <trans-unit id="5ad331d93d63bf83b44ef888cb4e43e94ea364bb" translate="yes" xml:space="preserve">
          <source>If the INDEX column is of type INTEGER, or derived from INTEGER, the corresponding type should be &lt;code&gt;integer&lt;/code&gt;. If it is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING), the corresponding type should be &lt;code&gt;string&lt;/code&gt;. Finally, if the type is of variable length, but with a fixed size restriction (e.g. IpAddress), the corresponding type should be &lt;code&gt;fix_string&lt;/code&gt;.</source>
          <target state="translated">如果INDEX列的类型为INTEGER或从INTEGER派生，则对应的类型应为 &lt;code&gt;integer&lt;/code&gt; 。如果是可变长度类型（例如OBJECT IDENTIFIER，OCTET STRING），则对应的类型应该是 &lt;code&gt;string&lt;/code&gt; 。最后，如果类型具有可变长度，但是具有固定的大小限制（例如IpAddress），则对应的类型应该为 &lt;code&gt;fix_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27815f723f23d4e4cf3d912f3476eb64c838477e" translate="yes" xml:space="preserve">
          <source>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">如果MG不能提供MGC的MID,MG可以使用原子'priminary_mid'作为megaco:connect/4的RemoteMid参数,调用流程是这样的。</target>
        </trans-unit>
        <trans-unit id="291d17d4be116cb44759c41864d170474773407f" translate="yes" xml:space="preserve">
          <source>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">如果MG已经配置了MGC的MID,它可以作为megaco:connect/4的RemoteMid参数,呼叫流程如下。</target>
        </trans-unit>
        <trans-unit id="3d3ec8b1bad21c29a9fcf6552b6d84ffcf7600b8" translate="yes" xml:space="preserve">
          <source>If the Mnesia database is used, this function calls &lt;code&gt;mnesia:write&lt;/code&gt; to store the values. This means that this function must be called from within a transaction (&lt;code&gt;mnesia:transaction/1&lt;/code&gt; or &lt;code&gt;mnesia:dirty/1&lt;/code&gt;).</source>
          <target state="translated">如果使用Mnesia数据库，则此函数调用 &lt;code&gt;mnesia:write&lt;/code&gt; 来存储值。这意味着必须从事务（ &lt;code&gt;mnesia:transaction/1&lt;/code&gt; 或 &lt;code&gt;mnesia:dirty/1&lt;/code&gt; ）中调用此函数。</target>
        </trans-unit>
        <trans-unit id="40a56f15bd541bd82f926eed2c112eaac90f9e71" translate="yes" xml:space="preserve">
          <source>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</source>
          <target state="translated">如果NIF调用太长,必须用以下方式之一来处理,以避免响应能力下降、调度器负载平衡问题和其他奇怪的行为。</target>
        </trans-unit>
        <trans-unit id="436a83604c57a3e3475d1d2d6359ca37e137b110" translate="yes" xml:space="preserve">
          <source>If the OBJECT IDENTIFIER is longer than an OBJECT IDENTIFIER of an object type in the MIB, it refers to object instances. Because of this, it is possible to control whether or not particular rows in a table shall be visible.</source>
          <target state="translated">如果OBJECT IDENTIFIER比MIB中某一对象类型的OBJECT IDENTIFIER长,则是指对象实例。正因为如此,可以控制表中的特定行是否可见。</target>
        </trans-unit>
        <trans-unit id="b1b26d2a72fe7f32dcd9c24e2f00608157279f71" translate="yes" xml:space="preserve">
          <source>If the OS used does not support non-blocking &lt;code&gt;sendfile&lt;/code&gt;, an Erlang fallback using &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果使用不支持非阻塞的OS &lt;code&gt;sendfile&lt;/code&gt; ，一个Erlang使用回退 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="b3598222fc1bb53b9989c1f5e6bfd02eed50487d" translate="yes" xml:space="preserve">
          <source>If the SNMP agent needs to interact with sub-agents constructed in another package, a special sub-agent should be used, which communicates through a protocol specified by the other package.</source>
          <target state="translated">如果SNMP代理需要与另一个包中构建的子代理进行交互,则应使用一个特殊的子代理,该子代理通过另一个包指定的协议进行通信。</target>
        </trans-unit>
        <trans-unit id="1c500f599c51107a79c77a136f03f46d05fafc58" translate="yes" xml:space="preserve">
          <source>If the SNMP table has more than one INDEX column, the corresponding Mnesia row is a tuple, where the first element is a tuple with the INDEX columns. Generally, if the SNMP table has &lt;strong&gt;N&lt;/strong&gt; INDEX columns and &lt;strong&gt;C&lt;/strong&gt; data columns, the Mnesia table is of arity &lt;strong&gt;(C-N)+1&lt;/strong&gt;, where the key is a tuple of arity &lt;strong&gt;N&lt;/strong&gt; if &lt;strong&gt;N &amp;gt; 1&lt;/strong&gt;, or a single term if &lt;strong&gt;N = 1&lt;/strong&gt;.</source>
          <target state="translated">如果SNMP表具有多个INDEX列，则对应的Mnesia行是一个元组，其中第一个元素是带有INDEX列的元组。通常，如果SNMP表具有&lt;strong&gt;&amp;Ntilde;&lt;/strong&gt; INDEX列和&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt;数据列，则Mnesia的表是元数的&lt;strong&gt;（CN）1&lt;/strong&gt;，其中关键是元数元组&lt;strong&gt;&amp;Ntilde;&lt;/strong&gt;如果&lt;strong&gt;N&amp;gt; 1&lt;/strong&gt;，或一个单一的术语，如果&lt;strong&gt;N = 1&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3c217a2396ebcee146469f461600abdf337e010c" translate="yes" xml:space="preserve">
          <source>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</source>
          <target state="translated">如果TFTP服务器收到来自同一个客户端的另一个请求(相同的主机和端口),而它已经与客户端建立了一个活动的连接,如果新的请求与第一个请求相同(相同的文件名和选项),那么它将忽略这个新的请求。这意味着(新的)客户端将由服务器端已经在进行的连接提供服务。通过不建立与正在进行的连接并行的另一个连接,服务器消耗的资源更少。</target>
        </trans-unit>
        <trans-unit id="89cbc4f7538c3f8a055eafb734ab8d43e17f7e9a" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF:</source>
          <target state="translated">如果Unicode转换修饰符（ &lt;code&gt;t&lt;/code&gt; ）有效，则integer参数可以是表示有效Unicode代码点的任何数字，否则应为小于或等于255的整数，否则将被16＃FF屏蔽：</target>
        </trans-unit>
        <trans-unit id="cc5c86359b9d2f999369876543233d4ea822c7b0" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used in the format string, all event handlers must ensure that the formatted output is correctly encoded for the I/O device.</source>
          <target state="translated">如果在格式字符串中使用了Unicode转换修饰符（ &lt;code&gt;t&lt;/code&gt; ），则所有事件处理程序都必须确保为I / O设备正确编码了格式化的输出。</target>
        </trans-unit>
        <trans-unit id="9a64305e88f74d03f63e30e4aff9344ad3928f49" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function clause:</source>
          <target state="translated">如果在子句级别进行分析，则结果以元组列表 &lt;code&gt;{Clause,Calls}&lt;/code&gt; 的形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是对每个函数子句的调用次数：</target>
        </trans-unit>
        <trans-unit id="7bb518d0fd97d3152a60a637270e37af04b13222" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt;, one for each function clause in the module. A clause is specified by its module name, function name, arity and position within the function definition:</source>
          <target state="translated">如果在子句级别进行分析，则结果以元组 &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt; 的列表的形式给出，该列表用于模块中的每个函数子句。子句由其模块名称，函数名称，函数和在函数定义中的位置指定：</target>
        </trans-unit>
        <trans-unit id="2478a8c8617596c655cc3da82b5c379b47e51b09" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function:</source>
          <target state="translated">如果在函数级别进行分析，则结果以元组 &lt;code&gt;{Function,Calls}&lt;/code&gt; 的列表形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是每个函数的调用次数：</target>
        </trans-unit>
        <trans-unit id="55b7df1c13246cf49b1f19e127c65003b3a10d37" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt;, one for each function in the module. A function is specified by its module name, function name and arity:</source>
          <target state="translated">如果在功能级别进行分析，则结果以元组 &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt; 的列表的形式给出，每个元组用于模块中的每个功能。函数由其模块名称，函数名称和属性指定：</target>
        </trans-unit>
        <trans-unit id="77e592dc92d7ea0f9403bfb4d1e1860bc8a3fe5a" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given as a tuple &lt;code&gt;{Module,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the total number of calls to functions in the module:</source>
          <target state="translated">如果在模块级别进行分析，则结果以元组 &lt;code&gt;{Module,Calls}&lt;/code&gt; 的形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是模块中对函数的调用总数：</target>
        </trans-unit>
        <trans-unit id="5cba27c146502c3ec8e1044a59eca78a126f8832" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given for the entire module as a tuple &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt;:</source>
          <target state="translated">如果在模块级别进行分析，则将整个模块的结果作为元组 &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt; 给出：</target>
        </trans-unit>
        <trans-unit id="cde9769f09668ea79529ce6edefab85a0899d6da" translate="yes" xml:space="preserve">
          <source>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. &lt;code&gt;MasterNodes&lt;/code&gt; can only contain nodes where the table has a replica. If the &lt;code&gt;MasterNodes&lt;/code&gt; list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</source>
          <target state="translated">如果应用程序检测到可能导致数据库不一致的通信故障（在潜在的分区网络中），则可以使用函数 &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; 定义从哪个节点加载每个表。在启动时，无论Mnesia何时以及是否在其他节点上终止，Mnesia普通表加载算法都会被绕过，并从为该表定义的主节点之一加载表。 &lt;code&gt;MasterNodes&lt;/code&gt; 只能包含表具有副本的节点。如果 &lt;code&gt;MasterNodes&lt;/code&gt; 列表为空，则将重置特定表的主节点恢复机制，并在下次重新启动时使用常规加载机制。</target>
        </trans-unit>
        <trans-unit id="130ab90516f90ac945b3ebb327eb04a5eb66e021" translate="yes" xml:space="preserve">
          <source>If the application detects that there has been a communication failure that can have caused an inconsistent database, it can use the function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; to pinpoint from which nodes each table can be loaded.</source>
          <target state="translated">如果应用程序检测到可能导致数据库不一致的通信故障，则可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; 来确定可以从中加载每个表的节点。</target>
        </trans-unit>
        <trans-unit id="afc60992fdf5138ada7ac0487b61ff57acf63af0" translate="yes" xml:space="preserve">
          <source>If the application is distributed, setting the permission to &lt;code&gt;false&lt;/code&gt; means that the application will be started at, or moved to, another node according to how its distribution is configured (see &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果应用程序是分布式的，则将权限设置为 &lt;code&gt;false&lt;/code&gt; 意味着该应用程序将根据其分发的配置方式在另一个节点上启动或移动到另一个节点（请参阅 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff80acb30d9dab81e0a46a50c51388e4dd17f7a3" translate="yes" xml:space="preserve">
          <source>If the application is not already loaded, the application controller first loads it using &lt;code&gt;application:load/1&lt;/code&gt;. It checks the value of the &lt;code&gt;applications&lt;/code&gt; key, to ensure that all applications that are to be started before this application are running.</source>
          <target state="translated">如果尚未加载应用程序，则应用程序控制器首先使用 &lt;code&gt;application:load/1&lt;/code&gt; 加载它。它检查 &lt;code&gt;applications&lt;/code&gt; 密钥的值，以确保该应用程序运行之前要启动的所有应用程序。</target>
        </trans-unit>
        <trans-unit id="60e7f4b69d5dbe87fef4344be83c638457c7eec7" translate="yes" xml:space="preserve">
          <source>If the application needs to include the generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">如果应用程序需要包括生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件，则对Erlang编译器使用 &lt;code&gt;-include_lib&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="683ef606c81dc1c47b5d3b9c095a4243030bc6f8" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;Func&lt;/code&gt;, the timetrap is triggered when this function returns. &lt;code&gt;Func&lt;/code&gt; can also return a new &lt;code&gt;Time&lt;/code&gt; value, which in that case is the value for the new timetrap.</source>
          <target state="translated">如果参数为 &lt;code&gt;Func&lt;/code&gt; ，则此函数返回时将触发时间陷阱。 &lt;code&gt;Func&lt;/code&gt; 还可以返回一个新的 &lt;code&gt;Time&lt;/code&gt; 值，在这种情况下，该值是新timetrap的值。</target>
        </trans-unit>
        <trans-unit id="0044e9d649274cc90388ee08844dd19dea89fffe" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt;, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</source>
          <target state="translated">如果该参数为 &lt;code&gt;false&lt;/code&gt; ，则针对此调用和所有后续调用，将当前进程的调用跟踪消息模式设置为正常（非静默）。</target>
        </trans-unit>
        <trans-unit id="580f4ef0ac5467ad7d400143bdf178fbf747f519" translate="yes" xml:space="preserve">
          <source>If the argument is invalid</source>
          <target state="translated">如果参数无效</target>
        </trans-unit>
        <trans-unit id="c3def1ea3a84c13010f731140dbb829f22745007" translate="yes" xml:space="preserve">
          <source>If the argument is not &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the call trace message mode is unaffected.</source>
          <target state="translated">如果参数不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，那么呼叫跟踪消息模式将不受影响。</target>
        </trans-unit>
        <trans-unit id="259c1b3a1fe7d6190505c0293c344282223212ec" translate="yes" xml:space="preserve">
          <source>If the arguments or options are malformed, the function throws a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">如果参数或选项格式错误，则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="6b60aa2a26e0a24944e43c25dc549ab30b52857b" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, and &lt;code&gt;I&lt;/code&gt; is greater than &lt;code&gt;size(Array)-1&lt;/code&gt;, the array grows to size &lt;code&gt;I+1&lt;/code&gt;.</source>
          <target state="translated">如果数组没有固定大小，并且 &lt;code&gt;I&lt;/code&gt; 大于 &lt;code&gt;size(Array)-1&lt;/code&gt; ，则数组将增长为大小 &lt;code&gt;I+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e97eb155a25d26096ef78fc2b67cf5447071cfc9" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, the default value for any index &lt;code&gt;I&lt;/code&gt; greater than &lt;code&gt;size(Array)-1&lt;/code&gt; is returned.</source>
          <target state="translated">如果数组的大小不固定，则返回任何大于 &lt;code&gt;size(Array)-1&lt;/code&gt; 的索引 &lt;code&gt;I&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="5552e65bff8e7b19a94e0b983a0ae9846e97b32b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;len&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">如果原子已经存在，则此函数将术语存储在 &lt;code&gt;*atom&lt;/code&gt; 中,并返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;len&lt;/code&gt; 超过一个原子所允许的最大长度（255个字符），则还返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d657f088165dffa1fac0e9bbe37e81e0983227b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if the length of &lt;code&gt;name&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">如果原子已经存在，则此函数将术语存储在 &lt;code&gt;*atom&lt;/code&gt; 中,并返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 的长度超过一个原子允许的最大长度（255个字符），则还返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbc8e0e10b7bf47bd128f48e3648baa81fc6271d" translate="yes" xml:space="preserve">
          <source>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">如果截断日志的尝试失败，则磁盘日志进程将以EXIT消息 &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt; 终止。 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 请求排队的其他进程收到消息{disk_log，Node，{error，disk_log_stopped}}。</target>
        </trans-unit>
        <trans-unit id="e7576e0423d861bfb48c83bfa3b5b0c281c96ce4" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt;systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">如果引导脚本包含 &lt;code&gt;$ROOT&lt;/code&gt; 以外的路径变量 &lt;code&gt;Var&lt;/code&gt; ，则此变量将扩展为 &lt;code&gt;Dir&lt;/code&gt; 。当应用程序安装在 &lt;code&gt;$ROOT/lib&lt;/code&gt; 以外的其他目录中时使用。请参阅SASL中的 &lt;code&gt;systools:make_script/1,2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc4746e92bb60b88599fe7a3e474a68b05603534" translate="yes" xml:space="preserve">
          <source>If the call times out, a &lt;code&gt;timeout&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果呼叫 &lt;code&gt;timeout&lt;/code&gt; 则会引发超时异常。</target>
        </trans-unit>
        <trans-unit id="55cc2b4bba08ca73afe9b3ccf29541b97304c864" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;erlang:load_nif/2&lt;/code&gt; fails, the module is unloaded and a warning report is sent to the error loader.</source>
          <target state="translated">如果对 &lt;code&gt;erlang:load_nif/2&lt;/code&gt; 的调用失败，则卸载模块，并向错误加载器发送警告报告。</target>
        </trans-unit>
        <trans-unit id="4b48d532db57aebd987ac6820de7ad7436dd64ed" translate="yes" xml:space="preserve">
          <source>If the callback module cannot be loaded, an error tuple is returned. The &lt;code&gt;Reason&lt;/code&gt; in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</source>
          <target state="translated">如果无法加载回调模块，则返回错误元组。错误元组中的 &lt;code&gt;Reason&lt;/code&gt; 是代码加载器在尝试加载回调模块的代码时返回的原因。</target>
        </trans-unit>
        <trans-unit id="8bf050fe2cb79b5d36a88eaed63edd7eed898889" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_get_state/1&lt;/code&gt; function, &lt;code&gt;get_state/1,2&lt;/code&gt; assumes that the &lt;code&gt;Misc&lt;/code&gt; value is the state of the callback module and returns it directly instead.</source>
          <target state="translated">如果回调模块未导出 &lt;code&gt;system_get_state/1&lt;/code&gt; 函数，则 &lt;code&gt;get_state/1,2&lt;/code&gt; 假定 &lt;code&gt;Misc&lt;/code&gt; 值是回调模块的状态，而是直接返回它。</target>
        </trans-unit>
        <trans-unit id="883a1351f7fb38c93f27abac246b139ddf314ded" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_replace_state/2&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; assumes that &lt;code&gt;Misc&lt;/code&gt; is the state of the callback module, passes it to &lt;code&gt;StateFun&lt;/code&gt; and uses the return value as both the new state and as the new value of &lt;code&gt;Misc&lt;/code&gt;.</source>
          <target state="translated">如果回调模块未导出 &lt;code&gt;system_replace_state/2&lt;/code&gt; 函数，则 &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; 假定 &lt;code&gt;Misc&lt;/code&gt; 是回调模块的状态，将其传递给 &lt;code&gt;StateFun&lt;/code&gt; 并将返回值用作新状态和 &lt;code&gt;Misc&lt;/code&gt; 的新值。</target>
        </trans-unit>
        <trans-unit id="6b0469d22f2398ad4902a9f0274d691cde96d200" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">如果回调模块导出 &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; 函数，则在目标进程 &lt;code&gt;StateFun&lt;/code&gt; 其调用以使用StateFun替换其状态。它的两个参数是 &lt;code&gt;StateFun&lt;/code&gt; 和 &lt;code&gt;Misc&lt;/code&gt; ，其中 &lt;code&gt;Misc&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;Misc&lt;/code&gt; 值相同。甲 &lt;code&gt;system_replace_state/2&lt;/code&gt; 功能预计返回 &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; ，其中 &lt;code&gt;NewState&lt;/code&gt; 是回调模块，通过调用获得的新状态 &lt;code&gt;StateFun&lt;/code&gt; ，和 &lt;code&gt;NewMisc&lt;/code&gt; 是用来取代原来的一个可能的新值 &lt;code&gt;Misc&lt;/code&gt; （需要作为 &lt;code&gt;Misc&lt;/code&gt; 通常在其中包含回调模块的状态。</target>
        </trans-unit>
        <trans-unit id="22c3eecf9345190c4251d4199b67e06fe9f176a1" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">如果回调模块导出函数 &lt;code&gt;system_get_state/1&lt;/code&gt; ，则在目标进程中调用它以获取其状态。它的参数与 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;Misc&lt;/code&gt; 值相同，并且函数 &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; 应该从中提取回调模块的状态。函数 &lt;code&gt;system_get_state/1&lt;/code&gt; 必须返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是回调模块的状态。</target>
        </trans-unit>
        <trans-unit id="01c2d9fbdbf4902fbd9ed598640b451a617bf5cc" translate="yes" xml:space="preserve">
          <source>If the callback module's &lt;code&gt;system_get_state/1&lt;/code&gt; function crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception.</source>
          <target state="translated">如果回调模块的 &lt;code&gt;system_get_state/1&lt;/code&gt; 函数崩溃或引发异常，则调用者退出，错误为 &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt; ，其中 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Reason&lt;/code&gt; 指示详细信息例外。</target>
        </trans-unit>
        <trans-unit id="7986fc8d38f019b96fd636349aa5cfd63d9efc6a" translate="yes" xml:space="preserve">
          <source>If the callback module's function &lt;code&gt;system_replace_state/2&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception. If the callback module does not provide a &lt;code&gt;system_replace_state/2&lt;/code&gt; function and &lt;code&gt;StateFun&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt;.</source>
          <target state="translated">如果回调模块的函数 &lt;code&gt;system_replace_state/2&lt;/code&gt; 崩溃或引发异常，则调用者退出，错误为 &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt; ，其中 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Reason&lt;/code&gt; 指示详细信息例外。如果回调模块不提供 &lt;code&gt;system_replace_state/2&lt;/code&gt; 函数，并且 &lt;code&gt;StateFun&lt;/code&gt; 崩溃或引发异常，则调用方退出，错误为 &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20f590333f587ce4f158c6bd3d9e3042df378fe" translate="yes" xml:space="preserve">
          <source>If the caller of the function wants to know whether or not acknowledgments are received for a certain notification (provided it is sent as an inform), the &lt;code&gt;Receiver&lt;/code&gt; parameter can be specified as &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (refer to the Reference Manual, section snmp, module &lt;code&gt;snmp&lt;/code&gt; for more details). In this case, the agent send a message &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; or &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; for each management target.</source>
          <target state="translated">如果函数的调用者想知道是否收到了针对某个通知的确认（假设它是作为通知发送的），则可以将 &lt;code&gt;Receiver&lt;/code&gt; 参数指定为 &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; （请参见参考手册的snmp部分） ，请参阅模块 &lt;code&gt;snmp&lt;/code&gt; 以获得更多详细信息）。在这种情况下，代理会为每个管理目标发送一条消息 &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; 或 &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d99e3904aef3995d136af596a2f043101aa1f9" translate="yes" xml:space="preserve">
          <source>If the calling process is not trapping exits, and checking &lt;code&gt;PidOrPort&lt;/code&gt; is cheap (that is, if &lt;code&gt;PidOrPort&lt;/code&gt; is local), &lt;code&gt;link/1&lt;/code&gt; fails with reason &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">如果调用过程未捕获陷阱，并且检查 &lt;code&gt;PidOrPort&lt;/code&gt; 是否便宜（也就是说，如果 &lt;code&gt;PidOrPort&lt;/code&gt; 是本地的），则 &lt;code&gt;link/1&lt;/code&gt; 失败，原因为 &lt;code&gt;noproc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49a8b4f21577fe3cc5ca8d0fd53bd3ee9424f7f7" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">如果调用过程以后因 &lt;code&gt;Reason&lt;/code&gt; 终止，则事件管理器通过使用 &lt;code&gt;{stop,Reason}&lt;/code&gt; 作为参数调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 来删除事件处理程序。</target>
        </trans-unit>
        <trans-unit id="f41eb527b8f8f2ec9a45659469012def9325921e" translate="yes" xml:space="preserve">
          <source>If the capture options describe that no substring capturing is to be done (&lt;code&gt;{capture, none}&lt;/code&gt;), the function returns the single atom &lt;code&gt;match&lt;/code&gt; upon successful matching, otherwise the tuple &lt;code&gt;{match, ValueList}&lt;/code&gt;. Disabling capturing can be done either by specifying &lt;code&gt;none&lt;/code&gt; or an empty list as &lt;code&gt;ValueSpec&lt;/code&gt;.</source>
          <target state="translated">如果捕获选项描述无子捕获是必须要做的（ &lt;code&gt;{capture, none}&lt;/code&gt; ），该函数返回的单原子 &lt;code&gt;match&lt;/code&gt; 在成功匹配，否则该元组 &lt;code&gt;{match, ValueList}&lt;/code&gt; 。可以通过不指定 &lt;code&gt;none&lt;/code&gt; 或将空白列表指定为 &lt;code&gt;ValueSpec&lt;/code&gt; 来禁用捕获。</target>
        </trans-unit>
        <trans-unit id="8dfe9740232e522c9dccf1bcdb49e9bacfa76b87" translate="yes" xml:space="preserve">
          <source>If the carrier could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">如果在不损害系统响应能力的情况下无法完全扫描载体，则 &lt;code&gt;UnscannedSize&lt;/code&gt; 是必须跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="b3d882b62bc462be24a22c4ebd1a0b80e4bbf23e" translate="yes" xml:space="preserve">
          <source>If the character escaping feature needs to be disabled (typically for backwards compatibility reasons), use the &lt;code&gt;ct_run&lt;/code&gt; start flag &lt;code&gt;-no_esc_chars&lt;/code&gt;, or the &lt;code&gt;ct:run_test/1&lt;/code&gt; start option &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (this start option is also supported in test specifications).</source>
          <target state="translated">如果需要禁用字符转义功能（通常是出于向后兼容的原因），请使用 &lt;code&gt;ct_run&lt;/code&gt; 开始标志 &lt;code&gt;-no_esc_chars&lt;/code&gt; 或 &lt;code&gt;ct:run_test/1&lt;/code&gt; 开始选项 &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; （测试规范中也支持此开始选项） 。</target>
        </trans-unit>
        <trans-unit id="93733502359d2306f277753fcf5f39262e0db10b" translate="yes" xml:space="preserve">
          <source>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning and &lt;code&gt;restart_child/2&lt;/code&gt; cannot be used for these children.</source>
          <target state="translated">如果子级是临时的，则该子级规范将在过程终止后立即删除。这意味着 &lt;code&gt;delete_child/2&lt;/code&gt; 没有意义，并且 &lt;code&gt;restart_child/2&lt;/code&gt; 不能用于这些子级。</target>
        </trans-unit>
        <trans-unit id="43bb63cf5661d4a237a06093eced5cd149d67b35" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">如果子进程是另一个主管，则应将其设置为 &lt;code&gt;infinity&lt;/code&gt; ,以使子树有足够的时间关闭。如果子进程是工作进程，也可以将其设置为 &lt;code&gt;infinity&lt;/code&gt; 。请参阅以下警告：</target>
        </trans-unit>
        <trans-unit id="04ca616fb018a5f7ed9b1457ccf717eb545a0d6c" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">如果子进程是另一个主管，则将关闭时间设置为 &lt;code&gt;infinity&lt;/code&gt; ,以使子树有足够的时间关闭。如果子进程是工作进程，也可以将其设置为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6c8d2313d1867bff7ceabb992796a9dc2cb660e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the child specification is added to the supervisor (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, see below), the pid is set to &lt;code&gt;undefined&lt;/code&gt;, and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则将子规范添加到主管（除非该主管是 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管，请参见下文），将pid设置为 &lt;code&gt;undefined&lt;/code&gt; ，并且该函数返回 &lt;code&gt;{ok,undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ef5502f7b080e1244d616694cf24b3ea2478505" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则pid保持设置为 &lt;code&gt;undefined&lt;/code&gt; ，该函数返回 &lt;code&gt;{ok,undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7a47396e2013d77055f46cf69011c8dbc710aa" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the child specification and pid are added to the supervisor and the function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，则将子规范和pid添加到主管中，并且该函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="48c5d696f2b0fd45c1b44f5e625a2accf1b0ea21" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the pid is added to the supervisor and the function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，则将pid添加到主管中，并且该函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="6d773deb857a328ed14a9080339dfab940c8161a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，函数返回 &lt;code&gt;{error,Error}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是一个包含有关错误和子规范的信息的术语。</target>
        </trans-unit>
        <trans-unit id="1b122e474c03f3cefc84e42bbf3408fd35e5bb5e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则该函数返回 &lt;code&gt;{error,Error}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是包含有关错误信息的术语。</target>
        </trans-unit>
        <trans-unit id="4b1288099957500451c193cb8d9ad26569f30036" translate="yes" xml:space="preserve">
          <source>If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification exists but the corresponding process is already running, the function returns &lt;code&gt;{error,running}&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范不存在，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。如果子规范存在但相应的进程已在运行，则该函数返回 &lt;code&gt;{error,running}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdb0f0cbc98dc7d94d6b59162ff7e5e589d60364" translate="yes" xml:space="preserve">
          <source>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</source>
          <target state="translated">如果客户端不支持任何服务器公布的协议,或者服务器没有公布任何协议,客户端将返回到其列表中的第一个协议或默认协议(如果提供了默认协议)。如果服务器不支持下一个协议协商,如果没有提供默认协议,连接就会终止。</target>
        </trans-unit>
        <trans-unit id="1eacb16ee64844ecf9771b5e95710813db228ddf" translate="yes" xml:space="preserve">
          <source>If the client earlier has acquired a lock through &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt;, this operation releases the associated lock. To access another target than &lt;code&gt;running&lt;/code&gt;, the server must support &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">如果客户端之前已通过 &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt; 获得了锁，则此操作将释放关联的锁。要访问 &lt;code&gt;running&lt;/code&gt; 以外的其他目标，服务器必须支持 &lt;code&gt;:candidate&lt;/code&gt; 和/或 &lt;code&gt;:startup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc1ef493c0d6b60856faddf62e5c3f0669465abe" translate="yes" xml:space="preserve">
          <source>If the code cannot be structured as in the &lt;code&gt;multiple_setelement/1&lt;/code&gt; example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</source>
          <target state="translated">如果代码不能像 &lt;code&gt;multiple_setelement/1&lt;/code&gt; 示例中那样构造，则修改大型元组中的多个元素的最佳方法是将元组转换为列表，修改列表，然后将其转换回元组。</target>
        </trans-unit>
        <trans-unit id="f0b7ca0808d04f400f34111028c04d20133e9b2d" translate="yes" xml:space="preserve">
          <source>If the common event handler needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">如果公共事件处理程序需要了解当前状态，则可以使用 &lt;code&gt;handle_common/4&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ff5b1741be466acda153b10a36fc7487f2ca70d6" translate="yes" xml:space="preserve">
          <source>If the compiler is to warn for missing callback functions, as it does for the OTP behaviours, add &lt;code&gt;-callback&lt;/code&gt; attributes in the behaviour module to describe the expected callbacks:</source>
          <target state="translated">如果编译器像OTP行为一样警告缺少的回调函数，请在行为模块中添加 &lt;code&gt;-callback&lt;/code&gt; 属性以描述预期的回调：</target>
        </trans-unit>
        <trans-unit id="523bb4f391597ed38f62115f28e3a49961855867" translate="yes" xml:space="preserve">
          <source>If the complete history is to be stored in the configuration file, &lt;code&gt;Config&lt;/code&gt; must be &lt;code&gt;all&lt;/code&gt;. If only a selected number of entries from the history are to be stored, &lt;code&gt;Config&lt;/code&gt; must be a list of integers pointing out the entries to be stored.</source>
          <target state="translated">如果要将完整的历史记录存储在配置文件中，则 &lt;code&gt;Config&lt;/code&gt; 必须为 &lt;code&gt;all&lt;/code&gt; 。如果仅要存储历史记录中选定数量的条目，则 &lt;code&gt;Config&lt;/code&gt; 必须是一个整数列表，指出要存储的条目。</target>
        </trans-unit>
        <trans-unit id="21e0716b03f7aa9ffd13782b0d420ef9a664a3d2" translate="yes" xml:space="preserve">
          <source>If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:</source>
          <target state="translated">如果条件不是上述任何一种格式,它必须是一个断言。这可以是一个正面或负面的lookahead或lookbehind断言。考虑下面的模式,包含非显著的空白,并且在第二行有两个选项。</target>
        </trans-unit>
        <trans-unit id="8a2fdb8b039278dbbab74f5b7bfb97af967770cd" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:</source>
          <target state="translated">如果满足条件,则使用 &quot;是 &quot;模式,否则使用 &quot;否 &quot;模式(如果存在)。如果子模式中存在两个以上的备选方案,就会出现编译时错误。两个备选方案中的每个方案本身都可以包含任何形式的嵌套子模式,包括条件子模式;对两个备选方案的限制只适用于条件的层次。下面的模式片段是一个替代品很复杂的例子。</target>
        </trans-unit>
        <trans-unit id="fa304219623acf477a2744ed1bbab72da379738b" translate="yes" xml:space="preserve">
          <source>If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</source>
          <target state="translated">如果条件是字符串(DEFINE),并且没有名称为DEFINE的子模式,那么条件总是false。在这种情况下,子模式中只能有一个选择。如果控制到模式中的这一点,则总是跳过。DEFINE的想法是,它可以用来定义 &quot;子程序&quot;,这些子程序可以从其他地方引用。(子程序的使用将在下面描述。)例如,一个匹配IPv4地址的模式,如 &quot;192.168.23.245&quot;,可以这样写(忽略空格和换行符)。</target>
        </trans-unit>
        <trans-unit id="8e3f4e65a85b857108a35b24009e6fe7e2ac2084" translate="yes" xml:space="preserve">
          <source>If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:</source>
          <target state="translated">如果条件是字符串(R),并且没有名称为R的子模式,那么如果对整个模式或任何子模式进行了递归调用,则条件为真。如果数字或名称前面有安培符,例如字母R后面有数字或名称。</target>
        </trans-unit>
        <trans-unit id="95c431a360008991bb1b7759c9f06391d6e75043" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, or if the initiation fails, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果配置错误或启动失败，则回调函数必须返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18a294113eb6042d9ad2a36514917a6dc077c344" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果配置错误，则回调函数必须返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a82e12e149afd95e3ddf1bb75d52a9982f828ca" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the same arguments as when &lt;code&gt;enable/2&lt;/code&gt; was called.</source>
          <target state="translated">如果配置参数 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;os_sup&lt;/code&gt; 会使用与调用 &lt;code&gt;enable/2&lt;/code&gt; 时相同的参数来自动调用此函数。</target>
        </trans-unit>
        <trans-unit id="aedee7601f2ce3a18dc9a8c63054f54ca3093e3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the values of &lt;code&gt;os_sup_own&lt;/code&gt; and &lt;code&gt;os_sup_syslogconf&lt;/code&gt; as arguments.</source>
          <target state="translated">如果配置参数 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;os_sup&lt;/code&gt; 会使用 &lt;code&gt;os_sup_own&lt;/code&gt; 和 &lt;code&gt;os_sup_syslogconf&lt;/code&gt; 的值作为参数来自动调用此函数。</target>
        </trans-unit>
        <trans-unit id="b2ffcf1c22e3ce76143a4b07b440007a5df05ea7" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;relocatable&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt; there is no need to install the target system with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be started. In that case the file tree containing the target system can be moved without re-installation.</source>
          <target state="translated">如果配置参数 &lt;code&gt;relocatable&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 没有必要与安装在目标系统 &lt;code&gt;reltool:install/2&lt;/code&gt; 就可以开始了。在这种情况下，可以移动包含目标系统的文件树，而无需重新安装。</target>
        </trans-unit>
        <trans-unit id="90f42cb19285f317fb015c9fad2016cce36110ed" translate="yes" xml:space="preserve">
          <source>If the connection timeout option &lt;code&gt;connect_timeout&lt;/code&gt; is set, that value is used also for the negotiation timeout and this option (&lt;code&gt;timeout&lt;/code&gt;) is ignored.</source>
          <target state="translated">如果设置了连接超时选项 &lt;code&gt;connect_timeout&lt;/code&gt; ，则该值也将用于协商超时，并且该选项（ &lt;code&gt;timeout&lt;/code&gt; ）将被忽略。</target>
        </trans-unit>
        <trans-unit id="860a4598c1d1ec6a83570120e591b858d6e8f890" translate="yes" xml:space="preserve">
          <source>If the connection to a remote node goes down, the main node will mark it as lost. If the node comes back it will be added again. If the remote node was alive during the disconnected periode, cover data from before and during this periode will be included in the analysis.</source>
          <target state="translated">如果与远程节点的连接中断,主节点会将其标记为丢失。如果该节点恢复,则会再次添加。如果远程节点在断开的周期内还活着,那么在这个周期之前和期间的覆盖数据将包括在分析中。</target>
        </trans-unit>
        <trans-unit id="c3b7535bf38d5e1053e0dcfad4dfa786c040f2e7" translate="yes" xml:space="preserve">
          <source>If the contents of &lt;code&gt;.erlang&lt;/code&gt; are changed and a private version of &lt;code&gt;user_default&lt;/code&gt; is defined, the Erlang/OTP environment can be customized. More powerful changes can be made by supplying command-line arguments in the startup script &lt;code&gt;erl&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果更改 &lt;code&gt;.erlang&lt;/code&gt; 的内容并定义了 &lt;code&gt;user_default&lt;/code&gt; 的私有版本，则可以自定义Erlang / OTP环境。通过在启动脚本 &lt;code&gt;erl&lt;/code&gt; 中提供命令行参数，可以进行更强大的更改。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6279554b0d57c5f26b8ffa794daeaf8c67036750" translate="yes" xml:space="preserve">
          <source>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the &lt;code&gt;909&lt;/code&gt;-prefix and lift/glob markers) ends in a &lt;code&gt;9&lt;/code&gt;, the integer will become an Erlang-level variable prefixed with &lt;code&gt;Q&lt;/code&gt;, and if it ends with &lt;code&gt;99&lt;/code&gt; it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</source>
          <target state="translated">如果上下文需要整数而不是变量，原子或字符串，则不能使用大写约定来标记自动元变量。相反，如果整数（不带 &lt;code&gt;909&lt;/code&gt; 前缀和lift / glob标记）以 &lt;code&gt;9&lt;/code&gt; 结尾，则该整数将成为Erlang级变量的前缀 &lt;code&gt;Q&lt;/code&gt; ，如果以 &lt;code&gt;99&lt;/code&gt; 结尾，则该整数也将自动抽象。例如，以下将增加导出函数f的arity：</target>
        </trans-unit>
        <trans-unit id="e14244783ffadbf99f1d872c65ba8477af77375e" translate="yes" xml:space="preserve">
          <source>If the converse of a function F is a function F', then F' is called the &lt;strong id=&quot;inverse&quot;&gt;inverse&lt;/strong&gt; of F.</source>
          <target state="translated">如果函数F的逆是函数F'，则F'被称为F的&lt;strong id=&quot;inverse&quot;&gt;逆&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="04e1722c7eed1557956908ac595866c524c53815" translate="yes" xml:space="preserve">
          <source>If the cross compilation tools are prefixed by &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; you probably do not need to set these variables (where &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; is what has been passed as &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt;).</source>
          <target state="translated">如果交叉编译工具的前缀为 &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; 您可能不需要设置这些变量（其中 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 是通过 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 参数传递的 &lt;code&gt;configure&lt;/code&gt; 变量）。</target>
        </trans-unit>
        <trans-unit id="693638c468a0a688aceae31ef9d5b589f67e3d3d" translate="yes" xml:space="preserve">
          <source>If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag &lt;code&gt;error&lt;/code&gt;, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;.</source>
          <target state="translated">如果由于列表中的非法Unicode / ISO Latin-1字符或任何二进制文件中的UTF编码无效而导致数据无法转换，则返回错误元组。错误元组包含标签 &lt;code&gt;error&lt;/code&gt; ，一个代表在错误发生之前可以转换的字符的列表以及一个包括和在令人讨厌的整数/字节之后的字符的表示形式。最后一部分主要用于调试，因为它仍然构成了可能很深的列表或混合列表，或两者兼有，不一定与原始数据具有相同的深度。在遍历列表时发生错误，并且剩下要解码的内容按&amp;ldquo;原样&amp;rdquo;返回。</target>
        </trans-unit>
        <trans-unit id="830c19e2812b5ad638344d6692b4a5d1c14189d2" translate="yes" xml:space="preserve">
          <source>If the data in the table is to be accessed so that the order of the keys in the table is significant, the table type &lt;code&gt;ordered_set&lt;/code&gt; can be used instead of the more usual &lt;code&gt;set&lt;/code&gt; table type. An &lt;code&gt;ordered_set&lt;/code&gt; is always traversed in Erlang term order regarding the key field so that the return values from functions such as &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;match_object&lt;/code&gt;, and &lt;code&gt;foldl&lt;/code&gt; are ordered by the key values. Traversing an &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; operations also returns the keys ordered.</source>
          <target state="translated">如果要访问表中的数据，以便表中键的顺序很重要，则可以使用表类型 &lt;code&gt;ordered_set&lt;/code&gt; 代替更常用的 &lt;code&gt;set&lt;/code&gt; 表类型。一个 &lt;code&gt;ordered_set&lt;/code&gt; 始终贯穿在Erlang项顺序有关的关键领域，以便从功能，如返回值 &lt;code&gt;select&lt;/code&gt; ， &lt;code&gt;match_object&lt;/code&gt; ，并 &lt;code&gt;foldl&lt;/code&gt; 由键值进行排序。使用第 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 操作遍历 &lt;code&gt;ordered_set&lt;/code&gt; 还返回有序的键。</target>
        </trans-unit>
        <trans-unit id="c7cef7dde804ec38da41a38a959068e58669e710" translate="yes" xml:space="preserve">
          <source>If the data is to be sent from the driver to the port owner process, it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要将数据从驱动程序发送到端口所有者进程，则使用 &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="d69f0718531a0dc4b5192097fe34a9a400874115" translate="yes" xml:space="preserve">
          <source>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</source>
          <target state="translated">如果数据库很大,不一定能在线恢复。在这种情况下,通过安装后备程序恢复旧数据库,然后重新启动。</target>
        </trans-unit>
        <trans-unit id="1a465de33f0929289f4ba867f52979d6f1b60be6" translate="yes" xml:space="preserve">
          <source>If the decoded message happens to be received before the connection is established, a new &quot;virtual&quot; connection is established. This is typically the case for the Media Gateway Controller (MGC) upon the first Service Change. When this occurs the following callback function will be invoked:</source>
          <target state="translated">如果在建立连接之前恰好收到了解码信息,则会建立一个新的 &quot;虚拟 &quot;连接。媒体网关控制器(MGC)在第一次服务变更时通常会出现这种情况。当这种情况发生时,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="fbdce8830ddb42e0e285519e4fb52411ce2090fe" translate="yes" xml:space="preserve">
          <source>If the decoded message instead of transactions contains a message error, the following callback function will be invoked:</source>
          <target state="translated">如果解码后的消息而不是事务包含消息错误,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="e05877711912cb7abc7753f9ce969b4440e6bb55" translate="yes" xml:space="preserve">
          <source>If the definitions are identical, the output module keeps only one definition with the original name.</source>
          <target state="translated">如果定义相同,输出模块只保留一个原名的定义。</target>
        </trans-unit>
        <trans-unit id="709eb064721592f0145e0c9870df4b79e36f2fb2" translate="yes" xml:space="preserve">
          <source>If the definitions have the same name and differs in the definition, they are renamed. The new names are the definition name and the original module name concatenated.</source>
          <target state="translated">如果定义的名称相同而定义不同,则重新命名。新的名称是定义名称和原模块名称的组合。</target>
        </trans-unit>
        <trans-unit id="c3055c07c7bca6e36c452534d5a6de3daec9136a" translate="yes" xml:space="preserve">
          <source>If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.</source>
          <target state="translated">如果被删除的条目是一个注册的订阅者,它将意味着订阅者进程得到的是未注册的订阅者,以及它得到它的最终消息。</target>
        </trans-unit>
        <trans-unit id="818e5bafa76101bf732fc51de14593ea48da629f" translate="yes" xml:space="preserve">
          <source>If the destination node would have to be auto-connected to do the send, &lt;code&gt;noconnect&lt;/code&gt; is returned instead.</source>
          <target state="translated">如果必须自动连接目标节点以进行发送， &lt;code&gt;noconnect&lt;/code&gt; 返回noconnect。</target>
        </trans-unit>
        <trans-unit id="fa49b96a6e23a80a21210ac903528ecee8169a93" translate="yes" xml:space="preserve">
          <source>If the directory for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is &lt;code&gt;/etc&lt;/code&gt;, the line in &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is as follows:</source>
          <target state="translated">如果文件 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 的目录是 &lt;code&gt;/etc&lt;/code&gt; ，则 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 中的行如下：</target>
        </trans-unit>
        <trans-unit id="1cfa13bd96270a398f97e146ebd653c8f1622e36" translate="yes" xml:space="preserve">
          <source>If the directory is not found</source>
          <target state="translated">如果没有找到该目录</target>
        </trans-unit>
        <trans-unit id="ee9c7c20028055c752f1006405fb6ac3dd62c654" translate="yes" xml:space="preserve">
          <source>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; is in the path, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</source>
          <target state="translated">如果目录引用存档中的目录，则在返回路径之前，将删除存档名称。例如，如果目录 &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; 在路径中，则 &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; 返回。这意味着应用程序的库目录是相同的，而不管应用程序是否驻留在归档中。</target>
        </trans-unit>
        <trans-unit id="f85643a441c622fdd2576beffc4873deda4e4256" translate="yes" xml:space="preserve">
          <source>If the dirty NIF is expected to be CPU-bound, its &lt;code&gt;flags&lt;/code&gt; field is to be set to &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt;.</source>
          <target state="translated">如果脏NIF预计将与CPU绑定，则将其 &lt;code&gt;flags&lt;/code&gt; 字段设置为 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; 或 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2ddfd812a9a461d82c50bcdf565e3ca018a4da" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">如果驱动程序出于某种原因希望将驱动程序二进制文件保留在例如静态变量中，则将增加引用计数，并且稍后可以使用 &lt;code&gt;driver_free_binary&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 回调中释放该二进制文件。</target>
        </trans-unit>
        <trans-unit id="a12df4e4fa0309d2f4f4f74b51f81225f4bdeeaf" translate="yes" xml:space="preserve">
          <source>If the driver has option &lt;code&gt;kill_ports&lt;/code&gt; set, or if &lt;code&gt;kill_ports&lt;/code&gt; is specified as an option to this function, all pending ports using this driver are killed when unloading is done by the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. If no port-killing is involved and there are open ports, the unloading is delayed until no more open ports use the driver. If, in this case, another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (or even this user) loads the driver again before the driver is unloaded, the unloading never takes place.</source>
          <target state="translated">如果驱动程序设置了选项 &lt;code&gt;kill_ports&lt;/code&gt; 或将此功能选项指定为 &lt;code&gt;kill_ports&lt;/code&gt; ，则最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 完成卸载时，将杀死使用该驱动程序的所有挂起端口。如果不涉及杀死端口并且有开放端口，则卸载将延迟，直到不再有开放端口使用驱动程序为止。在这种情况下，如果另一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; （甚至该用户）在卸载驱动程序之前再次加载了该驱动程序，则永远不会进行卸载。</target>
        </trans-unit>
        <trans-unit id="fcf785a336b2c213c45577e83eb09e396c7e3eab" translate="yes" xml:space="preserve">
          <source>If the driver is unloaded (not present in the system), error code &lt;code&gt;not_loaded&lt;/code&gt; is returned. Option &lt;code&gt;reload&lt;/code&gt; is intended for when the user has already loaded the driver in advance.</source>
          <target state="translated">如果驱动程序已卸载（系统中不存在），则返回错误代码 &lt;code&gt;not_loaded&lt;/code&gt; 。选项 &lt;code&gt;reload&lt;/code&gt; 适用于用户已预先加载驱动程序的情况。</target>
        </trans-unit>
        <trans-unit id="af3e2b2e4d5d486f038ae4047d709485c51ebafd" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果驱动程序要返回数据，则在 &lt;code&gt;rbuf&lt;/code&gt; 中返回它。当 &lt;code&gt;control&lt;/code&gt; 被调用时， &lt;code&gt;*rbuf&lt;/code&gt; 点的默认缓冲 &lt;code&gt;rlen&lt;/code&gt; 字节，其可用于返回数据。根据端口控制标志（使用 &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; 设置的那些标志），返回的数据有所不同。</target>
        </trans-unit>
        <trans-unit id="f299a698f91b18144d2db6873d22e3355371e343" translate="yes" xml:space="preserve">
          <source>If the driver was previously unloaded, but is still present because of open ports to it, a call to &lt;code&gt;load/2&lt;/code&gt; stops the unloading and keeps the driver (as long as &lt;code&gt;Path&lt;/code&gt; is the same), and &lt;code&gt;ok&lt;/code&gt; is returned. If you really want the object code to be reloaded, use &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; or the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead. See also the description of &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; for loading/unloading in the introduction.</source>
          <target state="translated">如果驱动程序以前已卸载，但是由于打开了端口而仍然存在，则对 &lt;code&gt;load/2&lt;/code&gt; 的调用将停止卸载并保留驱动程序（只要 &lt;code&gt;Path&lt;/code&gt; 相同），然后返回 &lt;code&gt;ok&lt;/code&gt; 。如果您确实希望重新加载目标代码，请改用 &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; 或低级接口 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。另请参见引言 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; 有关加载/卸载的不同方案的描述。</target>
        </trans-unit>
        <trans-unit id="73cd90e7e567fcfaa60abf0aba49564831915adf" translate="yes" xml:space="preserve">
          <source>If the edge would create a cycle in an &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; is returned. If &lt;code&gt;G&lt;/code&gt; already has an edge with value &lt;code&gt;E&lt;/code&gt; connecting a different pair of vertices, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; is returned. If either of &lt;code&gt;V1&lt;/code&gt; or &lt;code&gt;V2&lt;/code&gt; is not a vertex of digraph &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt;V&lt;code&gt;}}&lt;/code&gt; is returned, V = &lt;code&gt;V1&lt;/code&gt; or V = &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">如果边缘将在创建周期 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; 返回。如果 &lt;code&gt;G&lt;/code&gt; 已经具有连接另一对顶点的，具有值 &lt;code&gt;E&lt;/code&gt; 的边，则返回 &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; 。如果任一的 &lt;code&gt;V1&lt;/code&gt; 或 &lt;code&gt;V2&lt;/code&gt; 不是有向图的顶点 &lt;code&gt;G&lt;/code&gt; ， &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt; V &lt;code&gt;}}&lt;/code&gt; 被返回，V = &lt;code&gt;V1&lt;/code&gt; 或V = &lt;code&gt;V2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88548b0769c08599153c91bedffecba4076939a2" translate="yes" xml:space="preserve">
          <source>If the emulator detects an internal error (or runs out of memory), it, by default, generates both a crash dump and a core dump. The core dump is, however, not very useful as the content of process heaps is destroyed by the crash dump generation.</source>
          <target state="translated">如果仿真器检测到内部错误(或内存耗尽),默认情况下,它会生成一个崩溃转储和一个核心转储。然而,核心转储并不是很有用,因为进程堆的内容会被崩溃转储的生成所破坏。</target>
        </trans-unit>
        <trans-unit id="1c268e0a4f924dc7fcacea261eaf98d33a0b39dd" translate="yes" xml:space="preserve">
          <source>If the emulator needs to be restarted after upgrading or downgrading, that is, if the ERTS version differs between &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">如果在升级或降级后需要重新启动仿真器，即， &lt;code&gt;Name.rel&lt;/code&gt; 和 &lt;code&gt;Name2.rel&lt;/code&gt; 之间的ERTS版本不同</target>
        </trans-unit>
        <trans-unit id="0e5cf3cf162417b51e0a5af24e5040b612349b1b" translate="yes" xml:space="preserve">
          <source>If the emulator needs to write a crash dump, the value of this variable is the filename of the crash dump file. If the variable is not set, the name of the crash dump file is &lt;code&gt;erl_crash.dump&lt;/code&gt; in the current directory.</source>
          <target state="translated">如果仿真器需要编写故障转储，则此变量的值是故障转储文件的文件名。如果未设置该变量，则故障转储文件的 &lt;code&gt;erl_crash.dump&lt;/code&gt; 在当前目录中为erl_crash.dump。</target>
        </trans-unit>
        <trans-unit id="40c61683ad15fa177c304fbdf476f8b2479cdc64" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">如果模拟器是在支持 &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt; 程序的情况下构建的，则在线更改调度程序的数量也可以在线更改脏CPU调度程序的数量。例如，如果12个调度程序和6个脏CPU调度程序处于联机状态，并且使用 &lt;code&gt;system_flag/2&lt;/code&gt; 将联机的调度程序数设置为6，则联机的脏CPU调度程序数也会自动减少一半，降至3。同样，联机的肮脏CPU调度程序的数量与联机调度程序的数量成比例地增加。</target>
        </trans-unit>
        <trans-unit id="b9353bd702a35793ac18305b8482171f21007231" translate="yes" xml:space="preserve">
          <source>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</source>
          <target state="translated">如果到达模式的终点,则匹配成功,可以检索变量的内容。</target>
        </trans-unit>
        <trans-unit id="ec86b8e10359d9eb0c69eab5270c60f057cce319" translate="yes" xml:space="preserve">
          <source>If the engine is located in the OpenSSL/LibreSSL installation &lt;code&gt;engines&lt;/code&gt; directory.</source>
          <target state="translated">如果引擎位于OpenSSL / LibreSSL安装 &lt;code&gt;engines&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="17edef4a35e3cca0ca8935fe0f2de48f9e5dfe47" translate="yes" xml:space="preserve">
          <source>If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.</source>
          <target state="translated">如果该条目是一个新的订阅者,它将意味着新的订阅者进程首先将为每一个已经存储的字典条目获得一条消息,然后它和所有老的订阅者将获得这个特定的条目。收集器进程链接到订阅者进程,然后监督订阅者进程。如果订阅者进程死亡,它将意味着它将像普通的dict_delete/2那样被取消注册。</target>
        </trans-unit>
        <trans-unit id="a094e54489c949e55e10b1bfd099675a9945d8d2" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果对 &lt;code&gt;Exprs&lt;/code&gt; 的评估毫无例外地成功进行，则将模式 &lt;code&gt;Pattern&lt;/code&gt; 与结果按顺序进行匹配（与 &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; 表达式相同），不同的是，如果匹配失败，则会发生 &lt;code&gt;try_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="631031b9e342940aba31e2236569e617b51e7128" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">如果由于调用 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt; 而添加了事件处理程序，则 &lt;code&gt;InitArgs&lt;/code&gt; 是这些函数的 &lt;code&gt;Args&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="3160cb662d43645579ff66ccf206017473a57cb3" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">如果事件处理程序是由于调用 &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 而被删除的，则 &lt;code&gt;Arg&lt;/code&gt; 是此函数调用的 &lt;code&gt;Args&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="89ab1aecc97fe6f0f9ffea8f0aa54544b441d79d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted later, the event manager sends a message &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; to the calling process. &lt;code&gt;Reason&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果以后删除事件处理程序，则事件管理器将消息 &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; 发送到调用进程。 &lt;code&gt;Reason&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="b6a4d7864917b404d52d14fae5596ac8786e5389" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果事件处理程序是由于调用 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 或由于其他回调函数之一的 &lt;code&gt;swap&lt;/code&gt; 返回元组而替换了另一个事件处理程序，则 &lt;code&gt;InitArgs&lt;/code&gt; 是一个元组 &lt;code&gt;{Args,Term}&lt;/code&gt; ，其中 &lt;code&gt;Args&lt;/code&gt; 是函数调用/返回元组和 &lt;code&gt;Term&lt;/code&gt; 中提供的参数是终止旧事件处理程序的结果，请参见 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd74a922c6e5b981bbc80b4da38fda2c75c0b1ea" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. It however detects this state and loses no records that are not overwritten.</source>
          <target state="translated">如果将事件日志配置为自动回绕，则丢失到日志并在 &lt;code&gt;nteventlog&lt;/code&gt; 不运行时被覆盖的记录将丢失。但是，它会检测到此状态，并且不会丢失未覆盖的记录。</target>
        </trans-unit>
        <trans-unit id="1781a9137364e9b0633c2b37fb076419c90678b9" translate="yes" xml:space="preserve">
          <source>If the event manager is part of a supervision tree, no stop function is needed. The event manager is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果事件管理器是监视树的一部分，则不需要停止功能。事件管理器由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="23a26a698f7576e3a5781ee1ace5ea565efded8a" translate="yes" xml:space="preserve">
          <source>If the event manager is successfully created, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the event manager. If a process with the specified &lt;code&gt;EventMgrName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果成功创建了事件管理器，则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是事件管理器的pid。如果具有指定 &lt;code&gt;EventMgrName&lt;/code&gt; 的进程已经存在，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="85c7349696150a1895889e8faf7c4713894d022f" translate="yes" xml:space="preserve">
          <source>If the exclusive decode function has, for example, the name &lt;code&gt;decode_exclusive&lt;/code&gt; and an ASN.1 encoded message &lt;code&gt;Bin&lt;/code&gt; is to be exclusive decoded, the call is as follows:</source>
          <target state="translated">例如，如果排他解码功能具有名称 &lt;code&gt;decode_exclusive&lt;/code&gt; ,并且要对ASN.1编码消息 &lt;code&gt;Bin&lt;/code&gt; 进行排他解码，则调用如下：</target>
        </trans-unit>
        <trans-unit id="03f0f3b2eabafa60c9e9c721aa1cad9fcc5b78a3" translate="yes" xml:space="preserve">
          <source>If the failed test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">如果失败的测试用例属于测试用例组，则第一个参数是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="ae5596ad95475cf2f268aa093acd0a50a12f5551" translate="yes" xml:space="preserve">
          <source>If the file contains source code (as in the example above), it is processed by the &lt;code&gt;epp&lt;/code&gt; preprocessor. This means that you, for example, can use predefined macros (such as &lt;code&gt;?MODULE&lt;/code&gt;) and include directives like the &lt;code&gt;-include_lib&lt;/code&gt; directive. For example, use</source>
          <target state="translated">如果文件包含源代码（如上例所示），则由 &lt;code&gt;epp&lt;/code&gt; 预处理程序对其进行处理。例如，这意味着您可以使用预定义的宏（例如 &lt;code&gt;?MODULE&lt;/code&gt; ）并包含 &lt;code&gt;-include_lib&lt;/code&gt; 指令之类的指令。例如使用</target>
        </trans-unit>
        <trans-unit id="09f7b5f0081b8333cb37ae76ae1513548332cd8c" translate="yes" xml:space="preserve">
          <source>If the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</source>
          <target state="translated">如果文件以二进制模式打开,读取的字节以二进制形式返回,否则以列表形式返回。</target>
        </trans-unit>
        <trans-unit id="d43d376c036cd6704fab6602e0a821d2fca0f536" translate="yes" xml:space="preserve">
          <source>If the file is opened with &lt;code&gt;encoding&lt;/code&gt; set to something else than &lt;code&gt;latin1&lt;/code&gt;, each byte written can result in many bytes being written to the file, as the byte range 0..255 can represent anything between one and four bytes depending on value and UTF encoding type.</source>
          <target state="translated">如果打开的文件的 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 以外的其他值，则写入的每个字节都可能导致将许多字节写入文件，因为字节范围0..255可以表示一到四个字节之间的任意值，具体取决于值和UTF编码类型。</target>
        </trans-unit>
        <trans-unit id="3ff2942f4038fb71563badd19ea96ee04bc36590" translate="yes" xml:space="preserve">
          <source>If the file is read past &lt;code&gt;eof&lt;/code&gt;, only the remaining bytes are read and returned. If no bytes are read, &lt;code&gt;eof&lt;/code&gt; is returned.</source>
          <target state="translated">如果通过 &lt;code&gt;eof&lt;/code&gt; 读取了文件，则仅读取并返回剩余的字节。如果未读取任何字节，则返回 &lt;code&gt;eof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0301143503899c06f595e73d4da8e12a605f082d" translate="yes" xml:space="preserve">
          <source>If the file is specified as an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, no file is read or monitored in the future. This emulates the old behavior of not configuring the DNS client when the node is started in short name distributed mode.</source>
          <target state="translated">如果文件指定为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，则以后不会读取或监视文件。这模仿了以短名称分布式模式启动节点时不配置DNS客户端的旧行为。</target>
        </trans-unit>
        <trans-unit id="f524572ea2342154f69f71b644500e15cc9901dc" translate="yes" xml:space="preserve">
          <source>If the file server of this node is not a slave, the file was opened by the file server of this node (this implies that &lt;code&gt;Pid&lt;/code&gt; must be a local pid) and the file is not closed. &lt;code&gt;Filename&lt;/code&gt; is the filename in flat string format.</source>
          <target state="translated">如果此节点的文件服务器不是从服务器，则该节点的文件服务器已打开文件（这意味着 &lt;code&gt;Pid&lt;/code&gt; 必须是本地pid），并且文件未关闭。 &lt;code&gt;Filename&lt;/code&gt; 是平面字符串格式的文件名。</target>
        </trans-unit>
        <trans-unit id="19dad8b9ff6393c913546c9bff544a5e8d858493" translate="yes" xml:space="preserve">
          <source>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary is shorter than the number of bytes requested if end of file was reached.</source>
          <target state="translated">如果文件以二进制模式打开,读取的字节以二进制形式返回,否则以列表形式返回。列表或二进制比文件结束时要求的字节数要短。</target>
        </trans-unit>
        <trans-unit id="ead416d9e5e17b9f14938d13eb799b54c7ee7032" translate="yes" xml:space="preserve">
          <source>If the file write fails (for example, &lt;code&gt;enospc&lt;/code&gt;), the command is aborted and &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; is returned. However, the file is &lt;strong&gt;not&lt;/strong&gt; removed.</source>
          <target state="translated">如果文件写入失败（例如 &lt;code&gt;enospc&lt;/code&gt; ），该命令将中止，并返回 &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; 。但是，&lt;strong&gt;不会&lt;/strong&gt;删除该文件。</target>
        </trans-unit>
        <trans-unit id="3f0c09a69dc8ebf1e91578b9796f029369abc850" translate="yes" xml:space="preserve">
          <source>If the filename &lt;code&gt;File&lt;/code&gt; is absolute (possibly after variable substitution), the include file with that name is included. Otherwise, the specified file is searched for in the following directories, and in this order:</source>
          <target state="translated">如果文件名 &lt;code&gt;File&lt;/code&gt; 是绝对文件名（可能在变量替换之后），则包含具有该名称的包含文件。否则，将按照以下顺序在以下目录中搜索指定的文件：</target>
        </trans-unit>
        <trans-unit id="f6fdb5791718e9cf14d2a9c0a809646872e636fd" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, decide if the event is allowed or not.</source>
          <target state="translated">如果过滤器不匹配，则返回 &lt;code&gt;ignore&lt;/code&gt; ，这意味着其他过滤器或配置参数 &lt;code&gt;filter_default&lt;/code&gt; 的值决定是否允许该事件。</target>
        </trans-unit>
        <trans-unit id="298fc01aae2302d31a30ab2828690b737a94df8b" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, will decide if the event is allowed or not.</source>
          <target state="translated">如果过滤器不匹配，则返回 &lt;code&gt;ignore&lt;/code&gt; ，这意味着其他过滤器或配置参数 &lt;code&gt;filter_default&lt;/code&gt; 的值将决定是否允许该事件。</target>
        </trans-unit>
        <trans-unit id="3e713bc836d6d924cbd200c2e55ce5f9136754b5" translate="yes" xml:space="preserve">
          <source>If the filter function returns &lt;code&gt;ignore&lt;/code&gt;, it means that it did not recognize the log event, and thus leaves to other filters to decide the event's destiny.</source>
          <target state="translated">如果过滤器函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则意味着它无法识别日志事件，因此留给其他过滤器来决定事件的命运。</target>
        </trans-unit>
        <trans-unit id="957041343c23aa2d4654805ac48c48dc4fb915f8" translate="yes" xml:space="preserve">
          <source>If the filter has the form &lt;code&gt;{Key, RegExp, re}&lt;/code&gt;, the report must contain an element with key equal to &lt;code&gt;Key&lt;/code&gt; and the value must match the regular expression &lt;code&gt;RegExp&lt;/code&gt;.</source>
          <target state="translated">如果过滤器的格式为 &lt;code&gt;{Key, RegExp, re}&lt;/code&gt; ，则报告必须包含一个键值等于 &lt;code&gt;Key&lt;/code&gt; 的元素，并且该值必须与正则表达式 &lt;code&gt;RegExp&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6e1184361ce4e087a6b4dd8211b45d80ed4f9e48" translate="yes" xml:space="preserve">
          <source>If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the log event is allowed. If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the log event is stopped.</source>
          <target state="translated">如果过滤器匹配且 &lt;code&gt;Action&lt;/code&gt; 为 &lt;code&gt;log&lt;/code&gt; ，则允许日志事件。如果过滤器匹配且 &lt;code&gt;Action&lt;/code&gt; 为 &lt;code&gt;stop&lt;/code&gt; ，则日志事件停止。</target>
        </trans-unit>
        <trans-unit id="32e9da768719e8b90b1faba156fc380cf35dffea" translate="yes" xml:space="preserve">
          <source>If the final string is too long, it is truncated according to the value of configuration parameter &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果最后一个字符串太长，则会根据配置参数 &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; 的值将其截断。</target>
        </trans-unit>
        <trans-unit id="f6ebf0a745164970b389f3300cbccd27f4b3b5d3" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">如果该标志设置为 &lt;code&gt;0&lt;/code&gt; ，则数据以整数列表形式返回。使用默认缓冲区或设置 &lt;code&gt;*rbuf&lt;/code&gt; 指向使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; 分配的更大缓冲区。 &lt;code&gt;control&lt;/code&gt; 返回后，缓冲区将自动释放。</target>
        </trans-unit>
        <trans-unit id="3fdf06cbeca702cf9635bd5a2282dbe52c9f9489" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">如果该标志设置为 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; ，则返回一个二进制文件。通过将原始数据写入默认缓冲区，可以返回小型二进制文件。还可以通过将 &lt;code&gt;*rbuf&lt;/code&gt; 设置为指向 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 分配的二进制文件来返回二进制文件。 &lt;code&gt;control&lt;/code&gt; 返回后，此二进制文件将自动释放。驱动程序可以使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 保留二进制文件以进行&lt;strong&gt;只读&lt;/strong&gt;访问，稍后再使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; 释放该二进制文件。 &lt;code&gt;control&lt;/code&gt; 返回后，绝对不允许更改二进制文件。如果 &lt;code&gt;*rbuf&lt;/code&gt; 设置为 &lt;code&gt;NULL&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="ba4d8831063581aeb6c792a1b032f97e23a799b0" translate="yes" xml:space="preserve">
          <source>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</source>
          <target state="translated">如果将以下模式应用于非以 &quot;a &quot;或 &quot;b &quot;开头的字符串,它通常会匹配主题开头的空字符串。</target>
        </trans-unit>
        <trans-unit id="2009a1faa40085a7c2fd996ec540bc12d65d8f07" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">如果格式化程序模块导出了可选的回调函数 &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt; ，则在设置或修改格式化程序信息时，Logger会调用此函数，以验证格式化程序配置的有效性。</target>
        </trans-unit>
        <trans-unit id="05f7a6a810b002e4a0681949501258c2a927f78c" translate="yes" xml:space="preserve">
          <source>If the fragment option is &lt;code&gt;true&lt;/code&gt;, the URI fragment is returned as part of the parsing result, otherwise it is ignored.</source>
          <target state="translated">如果fragment选项为 &lt;code&gt;true&lt;/code&gt; ，则将URI片段作为解析结果的一部分返回，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="a9f39219b3544f3ad6a57e7c4b45e2e83b08a49c" translate="yes" xml:space="preserve">
          <source>If the fully connected network is not set up properly, try first to increase the value of &lt;code&gt;net_setuptime&lt;/code&gt;.</source>
          <target state="translated">如果未正确设置完全连接的网络，请首先尝试增加 &lt;code&gt;net_setuptime&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e9be0c3ab255377067e7c9ca15639a8fa64c8dbb" translate="yes" xml:space="preserve">
          <source>If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">如果使用fun/3,则在实际认证发生时被调用,因此可能返回动态数据,如时间、远程ip等。</target>
        </trans-unit>
        <trans-unit id="a10d9917bf561ed6546055b4ad6ae668ede9a486" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;mnesia:table_info/2&lt;/code&gt; is started in the activity context of module &lt;code&gt;mnesia_frag&lt;/code&gt;, information of several new items can be obtained:</source>
          <target state="translated">如果在模块 &lt;code&gt;mnesia_frag&lt;/code&gt; 的活动上下文中启动功能 &lt;code&gt;mnesia:table_info/2&lt;/code&gt; ,则可以获得以下几个新项的信息：</target>
        </trans-unit>
        <trans-unit id="b7b2e6d233f123be817d60a836703d289792c0af" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;print_name/1&lt;/code&gt;, and so on, had been interface functions, the situation would have been different, as you do not want the user of the interface to know about the internal data representation.</source>
          <target state="translated">如果函数 &lt;code&gt;print_name/1&lt;/code&gt; 等是接口函数，则情况将有所不同，因为您不希望接口的用户知道内部数据表示形式。</target>
        </trans-unit>
        <trans-unit id="ac91618962c7d06d3c9f00caac895bd89a410ca3" translate="yes" xml:space="preserve">
          <source>If the function is called, it will be called again with &lt;code&gt;undo&lt;/code&gt;, or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">如果调用了该函数，则将使用 &lt;code&gt;undo&lt;/code&gt; 或以 &lt;code&gt;set&lt;/code&gt; 作为第一个参数再次调用它。</target>
        </trans-unit>
        <trans-unit id="40c262c2c2a844d0cf26a7433449f15feea3fd0e" translate="yes" xml:space="preserve">
          <source>If the function is found, the function clauses are scanned sequentially until a clause is found that fulfills both of the following two conditions:</source>
          <target state="translated">如果找到函数,则依次扫描函数子句,直到找到满足以下两个条件的子句。</target>
        </trans-unit>
        <trans-unit id="c5c83cab902e2b61262a72c526eeaa77228c4460" translate="yes" xml:space="preserve">
          <source>If the function is rewritten as follows, the compiler is free to rearrange the clauses:</source>
          <target state="translated">如果将函数重写如下,编译器可以自由地重新排列子句。</target>
        </trans-unit>
        <trans-unit id="b63119293c0f8660be248a19b2479210b58e3c5a" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;ignore&lt;/code&gt;, then it is assumed that either:</source>
          <target state="translated">如果该函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则假定：</target>
        </trans-unit>
        <trans-unit id="d3d840a1e8e533a047b65414d5bcef0d60c4bcbd" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{cancel, Reason}&lt;/code&gt;, this means the transport module decided not to send the message. This is &lt;strong&gt;not&lt;/strong&gt; an error. No error messages will be issued and no error counters incremented. What actions this will result in depends on what kind of message was sent.</source>
          <target state="translated">如果函数返回 &lt;code&gt;{cancel, Reason}&lt;/code&gt; ，则意味着传输模块决定不发送消息。这&lt;strong&gt;不是&lt;/strong&gt;错误。将不会发出错误消息，并且不会增加错误计数器。这将导致什么动作取决于所发送的消息类型。</target>
        </trans-unit>
        <trans-unit id="7fa5ac3ae4df99fa5b9b2dd8db96506aecf3fefc" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release.</source>
          <target state="translated">如果函数返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ，则正在进行的升级将失败并回滚到旧版本。</target>
        </trans-unit>
        <trans-unit id="cace8ed5fbcae8411e61d141c38b3af395942b38" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; can not be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">如果该函数返回失败 &lt;code&gt;Reason&lt;/code&gt; ，则正在进行的升级将失败并回滚到旧版本。请注意， &lt;code&gt;Reason&lt;/code&gt; 不能是 &lt;code&gt;{ok,_,_}&lt;/code&gt; 元组，因为它将被视为 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 元组，并且与 &lt;code&gt;{ok,_}&lt;/code&gt; 匹配的元组也是无效的 &lt;code&gt;Reason&lt;/code&gt; 原因。建议将原子用作&amp;ldquo; &lt;code&gt;Reason&lt;/code&gt; 因为它将被包裹在 &lt;code&gt;{error,Reason}&lt;/code&gt; 元组中。</target>
        </trans-unit>
        <trans-unit id="23b279a0456aa090aac1cc8d9973e0efdd61b891" translate="yes" xml:space="preserve">
          <source>If the function returns anything else, the test case is considered successful. The return value always gets printed in the test case log file.</source>
          <target state="translated">如果函数返回任何其他值,则认为测试用例成功。返回值总是被打印在测试用例的日志文件中。</target>
        </trans-unit>
        <trans-unit id="f7a01fb7804d1dc8b9d59f7e2487cb33130c4689" translate="yes" xml:space="preserve">
          <source>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</source>
          <target state="translated">如果一个长期运行的NIF的功能可以拆分,使其工作可以通过一系列较短的NIF调用来实现,那么应用程序有两种选择。</target>
        </trans-unit>
        <trans-unit id="ba5aec2652bfb4fd0698f0092b5faec8c5e7749c" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;ebin&lt;/code&gt;, modules (BEAM files) are searched for in that directory, otherwise modules are searched for in the given directory.</source>
          <target state="translated">如果给定目录具有名为 &lt;code&gt;ebin&lt;/code&gt; 的子目录，则在该目录中搜索模块（BEAM文件），否则在给定目录中搜​​索模块。</target>
        </trans-unit>
        <trans-unit id="206b9b6e0e97d510493a5ac088ad8e22427aae29" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;lib&lt;/code&gt;, the directories in that directory are assumed to be application directories, otherwise all subdirectories of the given directory are assumed to be application directories. If there are several versions of some application, the one with the highest version is chosen.</source>
          <target state="translated">如果给定目录具有名为 &lt;code&gt;lib&lt;/code&gt; 的子目录，则假定该目录中的目录为应用程序目录，否则，假定给定目录的所有子目录均为应用程序目录。如果某个应用程序有多个版本，则选择具有最高版本的应用程序。</target>
        </trans-unit>
        <trans-unit id="33fb4bc732c4bac52e2f3ecc8dc02b6458e5f64a" translate="yes" xml:space="preserve">
          <source>If the global name server fails to connect nodes (&lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; in the Erlang shell), but it indicates a network problem.</source>
          <target state="translated">如果全局名称服务器无法连接节点（在示例中为 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N3&lt;/code&gt; ），则会将警告事件发送到错误记录器。此类事件的存在并不排除以后要连接的节点（例如，您可以在Erlang Shell中尝试命令 &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; ），但它指示网络问题。</target>
        </trans-unit>
        <trans-unit id="90420c92850a1634589e73fa3152ae2df519947e" translate="yes" xml:space="preserve">
          <source>If the guard test &lt;code&gt;is_integer(Int)&lt;/code&gt; succeeds, the fourth clause is executed.</source>
          <target state="translated">如果防护测试 &lt;code&gt;is_integer(Int)&lt;/code&gt; 成功，则执行第四个子句。</target>
        </trans-unit>
        <trans-unit id="51156ed0f0b60bdec0db2a3c5c342e77e9337761" translate="yes" xml:space="preserve">
          <source>If the guard test fails, the input value is compared to &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, and the appropriate clause is selected. (There is a &lt;code&gt;function_clause&lt;/code&gt; exception if none of the values matched.)</source>
          <target state="translated">如果保护测试失败，则输入值与 &lt;code&gt;four&lt;/code&gt; ， &lt;code&gt;five&lt;/code&gt; ，和 &lt;code&gt;six&lt;/code&gt; ，并且选择适当的子句。（如果两个值都不匹配，则存在 &lt;code&gt;function_clause&lt;/code&gt; 异常。）</target>
        </trans-unit>
        <trans-unit id="042ae23e884f62c0355d18895948d09799091a5c" translate="yes" xml:space="preserve">
          <source>If the handler is meant to replace the default handler, the Kernel's default handler have to be disabled before the new handler is added. A &lt;code&gt;sys.config&lt;/code&gt; file that disables the Kernel handler and adds a custom handler could look like this:</source>
          <target state="translated">如果要使用处理程序替换默认处理程序，则必须在添加新处理程序之前禁用内核的默认处理程序。禁用内核处理程序并添加自定义处理程序的 &lt;code&gt;sys.config&lt;/code&gt; 文件可能如下所示：</target>
        </trans-unit>
        <trans-unit id="65f1827df55837b13a3b7ed59d4d8ea4a1983d32" translate="yes" xml:space="preserve">
          <source>If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value &lt;code&gt;infinity&lt;/code&gt; prevents restarts.</source>
          <target state="translated">如果处理程序终止，则它会在指定的延迟（以毫秒为单位）后自动重新启动。值 &lt;code&gt;infinity&lt;/code&gt; 可防止重新启动。</target>
        </trans-unit>
        <trans-unit id="b7ef0ec4d5b98a48302f9d89b544d31dce7e98f5" translate="yes" xml:space="preserve">
          <source>If the handler process is terminated because of overload, it prints information about it in the log. It also prints information about when a restart has taken place, and the handler is back in action.</source>
          <target state="translated">如果处理程序因为过载而终止,它就在日志中打印相关信息。它还会打印关于何时重新启动和处理程序恢复运行的信息。</target>
        </trans-unit>
        <trans-unit id="71ca4e1b2a57423c539bf11275ee92c1598c8e04" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to listen on.</source>
          <target state="translated">如果主机有很多网络接口,这个选项可以指定监听哪一个。</target>
        </trans-unit>
        <trans-unit id="5938c2bcb45adfa6db096780d07c1f69ca15570f" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to use.</source>
          <target state="translated">如果主机有很多网络接口,这个选项可以指定使用哪一个。</target>
        </trans-unit>
        <trans-unit id="7a3654ae9fae9da43a3b1501da91842a28524e6b" translate="yes" xml:space="preserve">
          <source>If the included application itself contains included applications, instead the &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; option must be included.</source>
          <target state="translated">如果包含的应用程序本身包含包含的应用程序，则必须包含 &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="93280124390abf78f821c80eb86f0bf50631ec9d" translate="yes" xml:space="preserve">
          <source>If the initial call is to one of the system-defined behaviors such as &lt;code&gt;gen_server&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;, it is translated to more useful information. If a &lt;code&gt;gen_server&lt;/code&gt; is spawned, the returned &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Function&lt;/code&gt; is &lt;code&gt;init&lt;/code&gt; (the function that initiates the new server).</source>
          <target state="translated">如果初始调用是针对系统定义的行为之一，例如 &lt;code&gt;gen_server&lt;/code&gt; 或 &lt;code&gt;gen_event&lt;/code&gt; ，它将被转换为更多有用的信息。如果生成了 &lt;code&gt;gen_server&lt;/code&gt; ，则返回的 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Function&lt;/code&gt; 是 &lt;code&gt;init&lt;/code&gt; （启动新服务器的函数）。</target>
        </trans-unit>
        <trans-unit id="e36a8cae40a2ccda598cbf83afe268a5c720aa0e" translate="yes" xml:space="preserve">
          <source>If the initial encode of the outgoing request fails, then the request process fails and &lt;code&gt;{error,encode}&lt;/code&gt; is returned.</source>
          <target state="translated">如果传出请求的初始编码失败，则请求过程失败，并返回 &lt;code&gt;{error,encode}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512a1cbc51d5459f85caaea2fd4bfade04f37668" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">如果初始化失败，则函数将返回 &lt;code&gt;{error,Error}&lt;/code&gt; （其中 &lt;code&gt;Error&lt;/code&gt; 是任何术语）或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4efffcc1b527bd1b225e810cb600a2ae77401619" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{stop,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">如果初始化失败，则函数将返回 &lt;code&gt;{stop,Reason}&lt;/code&gt; （其中 &lt;code&gt;Reason&lt;/code&gt; 是任何术语）或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9346621e797dd1360944a672ab82ead28612c984" translate="yes" xml:space="preserve">
          <source>If the initialization is successful, the function is to return &lt;code&gt;{ok,State}&lt;/code&gt;, &lt;code&gt;{ok,State,Timeout}&lt;/code&gt;, or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">如果初始化成功，则函数将返回 &lt;code&gt;{ok,State}&lt;/code&gt; ， &lt;code&gt;{ok,State,Timeout}&lt;/code&gt; 或 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 进程的内部状态。</target>
        </trans-unit>
        <trans-unit id="eddc615bd88d8608ab31b9841323633dc12870aa" translate="yes" xml:space="preserve">
          <source>If the installation fails, the system can be rebooted. The old release version is then automatically used.</source>
          <target state="translated">如果安装失败,可以重新启动系统。然后自动使用旧版本。</target>
        </trans-unit>
        <trans-unit id="c0e9d4940ae270a2841d572606f563a099b85e09" translate="yes" xml:space="preserve">
          <source>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</source>
          <target state="translated">如果安装成功,新的版本将成为默认版本,如果系统重启,将使用该版本。</target>
        </trans-unit>
        <trans-unit id="08dbb0e86d47275a0a4e636be8892780b15448e3" translate="yes" xml:space="preserve">
          <source>If the instruction appears after instruction &lt;code&gt;point_of_no_return&lt;/code&gt; and the function call fails, the system is restarted.</source>
          <target state="translated">如果指令在 &lt;code&gt;point_of_no_return&lt;/code&gt; 指令之后出现并且函数调用失败，则系统将重新启动。</target>
        </trans-unit>
        <trans-unit id="efab2c6cbaff99e6149cda9413164011c49b633d" translate="yes" xml:space="preserve">
          <source>If the instruction appears before instruction &lt;code&gt;point_of_no_return&lt;/code&gt;, a failure is caught. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; then returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt;, unless &lt;code&gt;{error,Error}&lt;/code&gt; is thrown or returned. Then it returns &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">如果该指令出现在指令 &lt;code&gt;point_of_no_return&lt;/code&gt; 之前，则会捕获失败。 &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; 然后返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; ，除非抛出或返回了 &lt;code&gt;{error,Error}&lt;/code&gt; 。然后返回 &lt;code&gt;{error,Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6accd78db997b4f0cc8c3eb17cc0cfe9969dd581" translate="yes" xml:space="preserve">
          <source>If the instrumentation functions communicate with UNIX processes, it might be a good idea to use a special sub-agent. This sub-agent sends the SNMP request to the other process in one packet in order to minimize context switches. For example, if a whole MIB is implemented on the C level in UNIX, but you still want to use the Erlang SNMP tool, then you may have one special sub-agent, which sends the variables in the request as a single operation down to C.</source>
          <target state="translated">如果仪器仪表功能与 UNIX 进程通信,那么使用一个特殊的子代理可能是个好主意。这个子代理在一个数据包中向另一个进程发送SNMP请求,以减少上下文切换。例如,如果整个MIB是在UNIX的C层上实现的,但你仍然想使用Erlang SNMP工具,那么你可以有一个特殊的子代理,它将请求中的变量作为一个单一的操作下发到C层。</target>
        </trans-unit>
        <trans-unit id="6073ddc2f6ff51455fef10943643ff33d4a41b31" translate="yes" xml:space="preserve">
          <source>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as &lt;code&gt;'_'&lt;/code&gt; or &lt;code&gt;'$1'&lt;/code&gt;, the whole &lt;code&gt;employee&lt;/code&gt; table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt;) if the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果将key属性绑定到模式中，则匹配操作将非常有效。但是，如果将模式中的键属性指定为 &lt;code&gt;'_'&lt;/code&gt; 或 &lt;code&gt;'$1'&lt;/code&gt; ，则必须在整个 &lt;code&gt;employee&lt;/code&gt; 表中搜索匹配的记录。因此，如果表很大，这可能会成为一项耗时的操作，但是如果使用了函数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; ，则可以使用索引（请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt; ）进行补救。</target>
        </trans-unit>
        <trans-unit id="702da889833ee1dc6797c2ff9a6559f2d21f93ff" translate="yes" xml:space="preserve">
          <source>If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large.</source>
          <target state="translated">如果在模式中指定了键,则匹配的效率很高。如果没有指定键,也就是说,如果它是一个变量或下划线,则必须搜索整个表。如果表非常大,搜索时间会非常长。</target>
        </trans-unit>
        <trans-unit id="006f97d543b8ad5e428fa64fac1606142a9e3339" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 绑定，匹配规范应用到使用正确的密钥（或多个）表中的所有对象。如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 是未结合的，匹配规范应用于表中的所有对象， &lt;code&gt;N&lt;/code&gt; 对象的时间，直到达到至少一个对象匹配时，或表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有对象始终都在同一时间处理，这意味着匹配规范可以应用于N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="5b16233e004fe373963364905dc9a2ad762556f0" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 绑定，匹配规范应用于具有仅正确的密钥（或多个）对象。</target>
        </trans-unit>
        <trans-unit id="f90ff4fedc7cf136ced2894c42e307fbd5a5c73b" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 是未结合的，匹配规范应用于表中的所有对象。如果绑定了第keypos个元素，则将匹配规范仅应用于具有正确密钥的对象。</target>
        </trans-unit>
        <trans-unit id="c802fc2a3fde97f62fdbabfc7b66189e18b5dfc7" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则所有表对象都匹配。如果keypos的元素未绑定，则所有表对象都匹配，一次 &lt;code&gt;N&lt;/code&gt; 个对象，直到至少一个对象匹配或到达表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有匹配对象总是在同一回复中返回，这意味着有时可以返回N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="ee8399b71f2614d1c169eead97f1d70700fb4b6e" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则所有表对象都将匹配。如果keypos的元素未绑定，则所有表对象都匹配，一次 &lt;code&gt;N&lt;/code&gt; 个对象，直到至少一个对象匹配或到达表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有对象总是同时匹配，这意味着有时可以匹配N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="81cd44a63c897e4a4fbbf303d633ae129d55b04f" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则仅匹配具有正确键的对象。</target>
        </trans-unit>
        <trans-unit id="519fdb3cbbeb8df2c304203d27f11912d501b21d" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is unbound, all table objects are matched. If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">如果 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素未绑定，则所有表对象都将匹配。如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则仅匹配具有正确键的对象。</target>
        </trans-unit>
        <trans-unit id="56e84a693998be360a017f2de3532689d94a7f87" translate="yes" xml:space="preserve">
          <source>If the last expression of a function body is a function call, a &lt;strong&gt;tail recursive&lt;/strong&gt; call is done. This is to ensure that no system resources, for example, call stack, are consumed. This means that an infinite loop can be done if it uses tail-recursive calls.</source>
          <target state="translated">如果函数主体的最后一个表达式是函数调用，则执行&lt;strong&gt;尾递归&lt;/strong&gt;调用。这是为了确保不消耗系统资源，例如调用堆栈。这意味着，如果使用尾递归调用，则可以完成无限循环。</target>
        </trans-unit>
        <trans-unit id="9ae06ba70f228c8b154f39f0df23503609bcb3bd" translate="yes" xml:space="preserve">
          <source>If the length of the message queue grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the messages in the message queue by receiving them in a loop without logging. Client processes waiting for a response from a synchronous log request receive a reply from the handler indicating that the request is dropped. The handler process increases its priority during the flush loop to make sure that no new events are received during the operation. Notice that after the flush operation is performed, the handler prints information in the log about how many events have been deleted.</source>
          <target state="translated">如果消息队列的长度大于这个阈值,就会发生刷新(删除)操作。为了刷新事件,处理程序通过在循环中接收消息队列中的消息而不进行日志记录,从而丢弃这些消息。等待同步日志请求响应的客户端进程会收到处理程序的回复,表示请求被丢弃。处理程序进程在刷新循环中增加其优先级,以确保在操作过程中没有收到新的事件。注意,在执行完刷新操作后,处理程序会在日志中打印出有多少事件被删除的信息。</target>
        </trans-unit>
        <trans-unit id="d10dfdc12d1915667ccceb0a8869e7352174a1a5" translate="yes" xml:space="preserve">
          <source>If the level for &lt;code&gt;mymodule&lt;/code&gt; is now set to &lt;code&gt;debug&lt;/code&gt;, then debug events from this module will be logged by the handler &lt;code&gt;h2&lt;/code&gt;, but not by handler &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;mymodule&lt;/code&gt; 的级别现在设置为 &lt;code&gt;debug&lt;/code&gt; ，则来自该模块的调试事件将由处理程序 &lt;code&gt;h2&lt;/code&gt; 记录，而不由处理程序 &lt;code&gt;h1&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="57aa00c976a435bf8bda5a05ad6230ef4e15342c" translate="yes" xml:space="preserve">
          <source>If the library path is set to &lt;code&gt;code_path&lt;/code&gt;, the set of library modules is not determined, and the &lt;code&gt;info&lt;/code&gt; functions will return empty lists of library modules.</source>
          <target state="translated">如果库路径设置为 &lt;code&gt;code_path&lt;/code&gt; ，则不确定库模块的集合，并且 &lt;code&gt;info&lt;/code&gt; 函数将返回库模块的空列表。</target>
        </trans-unit>
        <trans-unit id="5a12290de86cdc8197c1cbb41227356d8ad7a7f4" translate="yes" xml:space="preserve">
          <source>If the list contains more than one object with &lt;strong&gt;matching&lt;/strong&gt; keys and the table type is &lt;code&gt;set&lt;/code&gt;, one is inserted, which one is not defined. The same holds for table type &lt;code&gt;ordered_set&lt;/code&gt; if the keys &lt;strong&gt;compare equal&lt;/strong&gt;.</source>
          <target state="translated">如果列表包含多个具有&lt;strong&gt;匹配&lt;/strong&gt;键的对象，并且 &lt;code&gt;set&lt;/code&gt; 了表类型，则插入一个，但未定义。如果键&lt;strong&gt;比较相等&lt;/strong&gt;，则表类型 &lt;code&gt;ordered_set&lt;/code&gt; 的情况&lt;strong&gt;相同&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="306fdef74e5ed0763cd6967950f14b6cd849bc3e" translate="yes" xml:space="preserve">
          <source>If the list of applications contains core applications, i.e &lt;code&gt;erts&lt;/code&gt;, &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt; or &lt;code&gt;sasl&lt;/code&gt;, the &lt;code&gt;Install&lt;/code&gt; script in the patched Erlang/OTP installation must be rerun.</source>
          <target state="translated">如果应用程序列表包含核心应用程序，即 &lt;code&gt;erts&lt;/code&gt; ， &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 或 &lt;code&gt;sasl&lt;/code&gt; ，则必须重新运行修补的Erlang / OTP安装中的 &lt;code&gt;Install&lt;/code&gt; 脚本。</target>
        </trans-unit>
        <trans-unit id="8acd485e36998d865f417532aa218ed4f2b0d80e" translate="yes" xml:space="preserve">
          <source>If the local node is part of a global group, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;synced&lt;/code&gt;. If no global groups are defined, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;no_conf&lt;/code&gt;.</source>
          <target state="translated">如果本地节点是全局组的一部分，则 &lt;code&gt;State&lt;/code&gt; 等于 &lt;code&gt;synced&lt;/code&gt; 。如果未定义全局组，则 &lt;code&gt;State&lt;/code&gt; 等于 &lt;code&gt;no_conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3dc78cf933189665aca88d0f65ce3644c34d9ac" translate="yes" xml:space="preserve">
          <source>If the log event is returned, the next filter function is called with the returned value as the first argument. That is, if a filter function modifies the log event, the next filter function receives the modified event. The value returned from the last filter function is the value that the handler callback receives.</source>
          <target state="translated">如果日志事件被返回,下一个过滤函数就会以返回的值作为第一个参数被调用。也就是说,如果一个过滤函数修改了日志事件,下一个过滤函数就会接收修改后的事件。上一个过滤函数返回的值就是处理程序回调接收的值。</target>
        </trans-unit>
        <trans-unit id="d41baef54ef4b512298e69bbec24ae875c8c68a0" translate="yes" xml:space="preserve">
          <source>If the log is blocked by the closing process, the log is also unblocked.</source>
          <target state="translated">如果日志被关闭过程阻塞,日志也会被解封。</target>
        </trans-unit>
        <trans-unit id="8605585ed728deb58354312d2da402db9d75ef1c" translate="yes" xml:space="preserve">
          <source>If the log is local on the current node, &lt;code&gt;Dist&lt;/code&gt; has the value &lt;code&gt;local&lt;/code&gt;, otherwise all nodes where the log is distributed are returned as a list.</source>
          <target state="translated">如果日志在当前节点上是本地的，则 &lt;code&gt;Dist&lt;/code&gt; 的值为 &lt;code&gt;local&lt;/code&gt; ，否则将分发日志的所有节点作为列表返回。</target>
        </trans-unit>
        <trans-unit id="dafa7b7f2609edae55f58fdb8dad531885491f7e" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">如果将日志消息指定为 &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;report_cb&lt;/code&gt; 键可以与将报告转换为格式字符串和参数的fun（报告回调）关联。有关报告回调的更多信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="de16ab6d2dd843eaf98a56613e46e210c0e2c90f" translate="yes" xml:space="preserve">
          <source>If the log size is decreased, for example, to save space, function &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; can be used to force the log to wrap.</source>
          <target state="translated">例如，如果减小了日志大小以节省空间，则可以使用函数 &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; 强制对日志进行换行。</target>
        </trans-unit>
        <trans-unit id="720cb0ae706744e4ee9df32b00d37adc564581fe" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined before the &lt;code&gt;merl.hrl&lt;/code&gt; header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions &lt;code&gt;?Q(...) = ...&lt;/code&gt;, case switches using &lt;code&gt;?Q(...)&lt;/code&gt; patterns, and automatic metavariables like &lt;code&gt;_@Tuple&lt;/code&gt; cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the &lt;code&gt;?Q(Text, Map)&lt;/code&gt; macro, e.g.:</source>
          <target state="translated">如果宏 &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; 的之前定义 &lt;code&gt;merl.hrl&lt;/code&gt; 包括头文件，解析变换使用MERL将被禁用，并且在这种情况下，匹配表达式 &lt;code&gt;?Q(...) = ...&lt;/code&gt; ，情况切换使用 &lt;code&gt;?Q(...)&lt;/code&gt; 模式和 &lt;code&gt;_@Tuple&lt;/code&gt; 类的自动元变量无法在您的代码中使用，但是Merl宏和函数仍然有效。要进行元变量替换，您需要使用 &lt;code&gt;?Q(Text, Map)&lt;/code&gt; 宏，例如：</target>
        </trans-unit>
        <trans-unit id="2f7a0ebf63b23efbe71cc89202b72b358a0f129b" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NOASSERT&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果在包含EUnit头文件之前定义了 &lt;code&gt;NOASSERT&lt;/code&gt; 宏，则在禁用测试的情况下，这些宏也无效。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146cb0ce4e92421175ea3746cf274e2455137df9" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NODEBUG&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果在包含EUnit头文件之前定义了宏 &lt;code&gt;NODEBUG&lt;/code&gt; ，则这些宏无效；否则，这些宏将无效。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b5a901ceceb4e69c701bf0dc03c50b6bae11f7b" translate="yes" xml:space="preserve">
          <source>If the manager is not configured to use any particular transport domain, the behaviour &lt;code&gt;handle_agent/4&lt;/code&gt; will for backwards copmpatibility reasons be called with the old &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments</source>
          <target state="translated">如果未将管理器配置为使用任何特定的传输域，则出于向后兼容性的原因，将使用旧的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数调用行为 &lt;code&gt;handle_agent/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6efb33521a71965325da2bbd03e23ab8ae58659" translate="yes" xml:space="preserve">
          <source>If the manager tries to set the same variable many times in the same PDU, the agent is free to improvise. There is no definition which determines if the instrumentation will be called once or twice. If called once only, there is no definition that determines which of the new values is going to be supplied.</source>
          <target state="translated">如果管理者在同一个PDU中多次尝试设置同一个变量,代理人可以自由地随机应变。没有任何定义来决定这个工具是被调用一次还是两次。如果只调用一次,则没有定义决定哪一个新的值将被提供。</target>
        </trans-unit>
        <trans-unit id="74415b1346dd0ddc93d29cb9c0389734be028243" translate="yes" xml:space="preserve">
          <source>If the master node fails, the entire pool exits.</source>
          <target state="translated">如果主节点失效,整个池子就会退出。</target>
        </trans-unit>
        <trans-unit id="ada210019d5db3434b3a98372ed4ed0f124b6d6b" translate="yes" xml:space="preserve">
          <source>If the match specification contains errors, tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">如果匹配规范包含错误，则返回元组 &lt;code&gt;{error, Errors}&lt;/code&gt; ，其中 &lt;code&gt;Errors&lt;/code&gt; 是匹配规范存在问题的自然语言描述的列表。</target>
        </trans-unit>
        <trans-unit id="73520de0bbd30344138b28e89ae6e3ad45ab6a3d" translate="yes" xml:space="preserve">
          <source>If the match specification is executed when selecting objects from an ETS table:</source>
          <target state="translated">如果从ETS表中选择对象时执行匹配规范。</target>
        </trans-unit>
        <trans-unit id="c4b956c127ba515516d186daa8a6509787e44051" translate="yes" xml:space="preserve">
          <source>If the match specification is executing when tracing:</source>
          <target state="translated">如果追踪时匹配规范正在执行。</target>
        </trans-unit>
        <trans-unit id="8673441fb53d8c53d833ea8413d411b45f3c363b" translate="yes" xml:space="preserve">
          <source>If the match specification is syntactically correct, the function either returns &lt;code&gt;{ok,Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">如果匹配规范在语法上是正确的，则该函数将返回 &lt;code&gt;{ok,Result}&lt;/code&gt; ，其中 &lt;code&gt;Result&lt;/code&gt; 是实际 &lt;code&gt;select/2&lt;/code&gt; 调用中的结果，否则返回 &lt;code&gt;false&lt;/code&gt; ,如果匹配规范与对象 &lt;code&gt;Tuple&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="760d740968a06c49ac007f36a245af2196bd1b34" translate="yes" xml:space="preserve">
          <source>If the matching conditions are not met, the match fails, either with:</source>
          <target state="translated">如果不满足匹配条件,则匹配失败,要么用。</target>
        </trans-unit>
        <trans-unit id="1935f33d435bd33bb34072fa05214583d09d6dc0" translate="yes" xml:space="preserve">
          <source>If the matching fails, a &lt;code&gt;badmatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果匹配失败， &lt;code&gt;badmatch&lt;/code&gt; 发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="5e6c9dcffff87aa8aa658e5eae30b4366a1b2bb3" translate="yes" xml:space="preserve">
          <source>If the matching subpart of &lt;code&gt;Subject&lt;/code&gt; giving raise to the replacement is to be inserted in the result, option &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; inserts the matching part into &lt;code&gt;Replacement&lt;/code&gt; at the specified position (or positions) before inserting &lt;code&gt;Replacement&lt;/code&gt; into &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">如果要在结果中插入提供替换的 &lt;code&gt;Subject&lt;/code&gt; 的匹配子部分，则选项 &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; 将匹配的部分插入到 &lt;code&gt;Replacement&lt;/code&gt; 中指定位置（或多个指定位置），然后再将 &lt;code&gt;Replacement&lt;/code&gt; 插入 &lt;code&gt;Subject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdd041679c28a1dfb5c5129e21e191da62b2500c" translate="yes" xml:space="preserve">
          <source>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of &lt;code&gt;Expr2&lt;/code&gt; is returned.</source>
          <target state="translated">如果匹配成功，则模式中任何未绑定的变量都将被绑定，并返回 &lt;code&gt;Expr2&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5059fa619d98d60a3d0f2e7f4484d57de08a27f3" translate="yes" xml:space="preserve">
          <source>If the maximum depth is reached, it cannot be read in the resultant output. Also, the &lt;code&gt;,...&lt;/code&gt; form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</source>
          <target state="translated">如果达到最大深度，则无法在结果输出中读取该深度。此外，元组中的 &lt;code&gt;,...&lt;/code&gt; 表示元组中还有更多元素，但这些元素低于打印深度。</target>
        </trans-unit>
        <trans-unit id="6c939753050268aea10f52760cad514608911137" translate="yes" xml:space="preserve">
          <source>If the message cannot be decoded the following callback function will be invoked:</source>
          <target state="translated">如果消息不能被解码,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="fa13ca2255dfd047e4217a3af88a01b044ce4d8d" translate="yes" xml:space="preserve">
          <source>If the message is on report form, it is converted to &lt;code&gt;{Format,Args}&lt;/code&gt; by calling the report callback. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information about report callbacks and valid forms of log messages.</source>
          <target state="translated">如果该消息位于报告表单上，则通过调用报告回调将其转换为 &lt;code&gt;{Format,Args}&lt;/code&gt; 。见 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 内核用户指南中有关报告回调和日志信息的有效形式的更多信息。</target>
        </trans-unit>
        <trans-unit id="c5713a5c2133c11304f85627e2ccde367a7ac635" translate="yes" xml:space="preserve">
          <source>If the minimum repetition is &amp;gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching.</source>
          <target state="translated">如果最小重复次数&amp;gt; 0，则忽略量词。在匹配过程中遇到断言时，仅遵守一次。</target>
        </trans-unit>
        <trans-unit id="5f724a3bd58fe6f9ce42fc406728de7f89ce0ad1" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;m1&lt;/code&gt; is introduced in version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt;, it must also be loaded when upgrading and deleted when downgrading:</source>
          <target state="translated">如果模块 &lt;code&gt;m1&lt;/code&gt; 在 &lt;code&gt;ch_app&lt;/code&gt; 的版本&amp;ldquo; 2&amp;rdquo;中引入，则还必须在升级时加载它，而在降级时删除它：</target>
        </trans-unit>
        <trans-unit id="7aff411ea6299d7bca7ad227ec0e1bc26a882a00" translate="yes" xml:space="preserve">
          <source>If the module cannot be found, &lt;code&gt;non_existing&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到模块，则返回 &lt;code&gt;non_existing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5745afeece7b41ec1bfc061d3b5f18d8e8d1dfba" translate="yes" xml:space="preserve">
          <source>If the module is Cover-compiled, &lt;code&gt;cover_compiled&lt;/code&gt; is returned.</source>
          <target state="translated">如果模块是Cover-compiled，则返回 &lt;code&gt;cover_compiled&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52f516f712d9242bfd152b08a6fd0f4a2793c3fd" translate="yes" xml:space="preserve">
          <source>If the module is loaded, it returns the name of the file containing the loaded object code.</source>
          <target state="translated">如果模块被加载,则返回包含加载对象代码的文件名。</target>
        </trans-unit>
        <trans-unit id="46dba590f6c1f6f800702e68508881918dc97bf9" translate="yes" xml:space="preserve">
          <source>If the module is not loaded, this function searches the code path for the first file containing object code for &lt;code&gt;Module&lt;/code&gt; and returns the absolute filename.</source>
          <target state="translated">如果未加载模块，则此函数在代码路径中搜索包含 &lt;code&gt;Module&lt;/code&gt; 目标代码的第一个文件，并返回绝对文件名。</target>
        </trans-unit>
        <trans-unit id="229acd9737c1671ac97dd505de45081f475b5a4e" translate="yes" xml:space="preserve">
          <source>If the module is preloaded, &lt;code&gt;preloaded&lt;/code&gt; is returned.</source>
          <target state="translated">如果模块已预加载，则返回预 &lt;code&gt;preloaded&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea6cb550bcdaadfe5116319b2dd6e7b241b066a1" translate="yes" xml:space="preserve">
          <source>If the module is successfully Cover compiled, the function returns &lt;code&gt;{ok,Module}&lt;/code&gt;. Otherwise the function returns &lt;code&gt;{error,File}&lt;/code&gt;. Errors and warnings are printed as they occur.</source>
          <target state="translated">如果模块成功Cover编译，则函数返回 &lt;code&gt;{ok,Module}&lt;/code&gt; 。否则，该函数返回 &lt;code&gt;{error,File}&lt;/code&gt; 。错误和警告会在发生时立即打印出来。</target>
        </trans-unit>
        <trans-unit id="1e0a91a6b9e2e2cfbc8f28ae6d3d48928ca8ba21" translate="yes" xml:space="preserve">
          <source>If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; processes. The message is &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt;. The reply to this message is &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt;, where &lt;code&gt;Modules&lt;/code&gt; is a list of the currently active modules in the process.</source>
          <target state="translated">如果用于实现流程的模块在运行时动态更改，则该流程必须再了解一条消息。一个示例是 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 进程。消息是 &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt; 。对此消息的回复是 &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt; ，其中 &lt;code&gt;Modules&lt;/code&gt; 是进程中当前活动模块的列表。</target>
        </trans-unit>
        <trans-unit id="df61dd8b4c6d4d214b129a5077aaee5f7910b304" translate="yes" xml:space="preserve">
          <source>If the name after the prefix and any lift and glob markers is &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, the variable is treated as an anonymous catch-all pattern in matches. For example, &lt;code&gt;_@_&lt;/code&gt;, &lt;code&gt;_@@_&lt;/code&gt;, &lt;code&gt;_@__&lt;/code&gt;, or even &lt;code&gt;_@__@_&lt;/code&gt;.</source>
          <target state="translated">如果前缀后面的名称以及任何提升标记和glob标记之后的名称是 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ，则该变量将被视为匹配项中的匿名全包模式。例如 &lt;code&gt;_@_&lt;/code&gt; ， &lt;code&gt;_@@_&lt;/code&gt; ， &lt;code&gt;_@__&lt;/code&gt; ，甚至 &lt;code&gt;_@__@_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c34344ea584c9364120e1acb56d82e908a1af1b" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_server&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the &lt;code&gt;gen_server&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果省略名称，则不注册 &lt;code&gt;gen_server&lt;/code&gt; 。而是必须使用其pid。名称也可以指定为 &lt;code&gt;{global, Name}&lt;/code&gt; ，在这种情况下， &lt;code&gt;gen_server&lt;/code&gt; 是使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册的。</target>
        </trans-unit>
        <trans-unit id="5f90545e460868142094a7469ef7c519e7a99526" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_statem&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be specified as &lt;code&gt;{global,Name}&lt;/code&gt;, then the &lt;code&gt;gen_statem&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt; in Kernel.</source>
          <target state="translated">如果省略该名称，则不会注册 &lt;code&gt;gen_statem&lt;/code&gt; 。而是必须使用其pid。该名称也可以指定为 &lt;code&gt;{global,Name}&lt;/code&gt; ，然后在内核中使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bce770e9e17197a693d6f9ec8afdca775fdac582" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the event manager is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the event manager is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果省略名称，则不会注册事件管理器。而是必须使用其pid。名称也可以指定为 &lt;code&gt;{global, Name}&lt;/code&gt; ，在这种情况下，将使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册事件管理器。</target>
        </trans-unit>
        <trans-unit id="980ec5f2e4cbb3a6bcddf606d02e3f399d751b31" translate="yes" xml:space="preserve">
          <source>If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.</source>
          <target state="translated">如果这类条件中使用的名称是重复的,那么测试就会应用于所有相同名称的子模式,如果其中任何一个子模式已经匹配,那么测试就为真。</target>
        </trans-unit>
        <trans-unit id="49bffa909b81c50ee39e3329bfdea53c42d35846" translate="yes" xml:space="preserve">
          <source>If the node is distributed, all referenced nodes are visible. Column &lt;strong&gt;Connection type&lt;/strong&gt; shows if the node is visible, hidden, or not connected. Visible nodes are alive nodes with a living connection to the originating node. Hidden nodes are the same as visible nodes, except they are started with flag &lt;code&gt;-hidden&lt;/code&gt;. Not connected nodes are nodes that are not connected to the originating node anymore, but references (that is, process or port identifiers) exist.</source>
          <target state="translated">如果该节点是分布式的，则所有引用的节点都是可见的。列&lt;strong&gt;连接类型&lt;/strong&gt;显示节点是否可见，隐藏或未连接。可见节点是活动节点，与原始节点之间存在活动连接。隐藏节点与可见节点相同，除了它们以flag &lt;code&gt;-hidden&lt;/code&gt; 开头。未连接的节点是不再与原始节点连接的节点，但是存在引用（即，进程或端口标识符）。</target>
        </trans-unit>
        <trans-unit id="9c56f0553bb17f48448269d8c3f6b6f7e5b7e66d" translate="yes" xml:space="preserve">
          <source>If the node is started with command-line flag &lt;code&gt;-sname&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the short name of the host (not the fully qualified domain name). If started with flag &lt;code&gt;-name&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified domain name. For more information, see &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">如果该节点以命令行标志 &lt;code&gt;-sname&lt;/code&gt; 开头，则节点名称为 &lt;code&gt;foobar@Host&lt;/code&gt; ，其中 &lt;code&gt;Host&lt;/code&gt; 是主机的简称（不是完全限定的域名）。如果以flag &lt;code&gt;-name&lt;/code&gt; 开头，则节点名称为 &lt;code&gt;foobar@Host&lt;/code&gt; ，其中 &lt;code&gt;Host&lt;/code&gt; 是标准域名。有关更多信息，请参见 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95b56bcd18c923019bf4643e2b58f9471a6acfb9" translate="yes" xml:space="preserve">
          <source>If the node was not distributed.</source>
          <target state="translated">如果节点没有分布。</target>
        </trans-unit>
        <trans-unit id="aedd11aac41ef6bf71a8b2c8d09b6e7316fb0ef3" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, &lt;code&gt;0&lt;/code&gt; is returned, otherwise &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">如果该节点已成功从EPMD注销，则返回 &lt;code&gt;0&lt;/code&gt; ，否则返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9460cf94d8c06eac24b50547fafb0d6e9b4fd6e1" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, the function returns &lt;code&gt;0&lt;/code&gt;. Otherwise, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">如果已成功从EPMD注销该节点，则该函数返回 &lt;code&gt;0&lt;/code&gt; 。否则，返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d5ac939fb10f304c0c8f3c91721403a64646c5e" translate="yes" xml:space="preserve">
          <source>If the node where the application is running goes down, the application is restarted (after the specified time-out) at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. This is called a &lt;strong&gt;failover&lt;/strong&gt;.</source>
          <target state="translated">如果运行应用程序的节点发生故障，则将在 &lt;code&gt;distributed&lt;/code&gt; 配置参数的节点列表中列出的第一个可操作节点处重新启动应用程序（在指定的超时后）。这称为&lt;strong&gt;故障转移&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d2b0ad4edfef4bb3e88a7ddeeff16d1de18813" translate="yes" xml:space="preserve">
          <source>If the number of arguments are known at compile time, the call is better written as &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt;.</source>
          <target state="translated">如果在编译时知道参数的数量，则最好将调用编写为 &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37c7a476d1b0b827d6493e10ef324cd201488a29" translate="yes" xml:space="preserve">
          <source>If the number of elements in the arguments are known at compile time, the call is better written as &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt;.</source>
          <target state="translated">如果在编译时知道参数中元素的数量，则调用最好写成 &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f1678d016c144fe15d956c065fed8204d1f4e8c" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">如果首选旧行为，则可以将内核配置参数 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。的 &lt;code&gt;SASL configuration parameters&lt;/code&gt; 然后可被用作前，如果SASL应用程序正在运行的SASL报告只会被打印，通过命名第二日志处理程序 &lt;code&gt;sasl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5231cf8edc57a7fbd05d3b31ba66fb76e90acd0" translate="yes" xml:space="preserve">
          <source>If the operation fails, a bad match error occurs that terminates the test case.</source>
          <target state="translated">如果操作失败,就会发生坏匹配错误,终止测试用例。</target>
        </trans-unit>
        <trans-unit id="965b40d04fea8544035ae2adb0a45bfab2ddc16f" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned.</source>
          <target state="translated">如果设置了 &lt;code&gt;raw&lt;/code&gt; 选项，则不会调用文件服务器，并且仅返回有关本地文件的信息。</target>
        </trans-unit>
        <trans-unit id="5e127046f0102151c6ef18467d6c0abf9dd2f077" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置了 &lt;code&gt;raw&lt;/code&gt; 选项，则不会调用文件服务器，并且仅返回有关本地文件的信息。请注意，这将破坏该模块的原子性保证，因为它可以与并发调用 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt; 竞争</target>
        </trans-unit>
        <trans-unit id="4d027da67948b3928fcb8c40cf4bee29a349c9ad" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is proably not what you want.</source>
          <target state="translated">如果选项 &lt;code&gt;verify&lt;/code&gt; 设置为 &lt;code&gt;verify_peer&lt;/code&gt; ，则还应指定选项 &lt;code&gt;server_name_indication&lt;/code&gt; ，如果不是，则不发送服务器名称指示扩展名，并且将使用连接的IP地址作为 &lt;code&gt;ReferenceID&lt;/code&gt; 调用 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; ，可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="c3a18e0b35e87dbcf1a9dcdd4db312f82e11bde7" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;{handshake, hello}&lt;/code&gt; 则在收到服务器问候消息后握手将暂停，并且成功响应为 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 而不是 &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。此后，通过调用 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 来继续或取消握手。</target>
        </trans-unit>
        <trans-unit id="06f7f3873edec45c49aeb8ad204a603fa73eff84" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;allow deny&lt;/code&gt;, the users network address is first controlled to be in the allow subset. If the user network address is not in the allowed subset, the user is denied to get the asset. If the network address is in the allowed subset, a second control is performed. That is, the user network address is not in the subset of network addresses to be denied as specified by parameter &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">如果顺序设置为 &lt;code&gt;allow deny&lt;/code&gt; ，则首先将用户网络地址控制为允许子集。如果用户网络地址不在允许的子集中，则拒绝用户获取资产。如果网络地址在允许的子集中，则执行第二个控制。也就是说，用户网络地址不在参数 &lt;code&gt;deny&lt;/code&gt; 指定的要拒绝的网络地址子集中。</target>
        </trans-unit>
        <trans-unit id="48d8a47c543c2d39d92d2c1d202bacab80c1642d" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;deny allow&lt;/code&gt;, only users from networks specified to be in the allowed subset succeeds to request assets in the limited area.</source>
          <target state="translated">如果将顺序设置为 &lt;code&gt;deny allow&lt;/code&gt; ，则只有指定为允许子集中的网络中的用户才能成功请求限制区域内的资产。</target>
        </trans-unit>
        <trans-unit id="5413791d17ed0b4814f8fb694ad1efb815f76c05" translate="yes" xml:space="preserve">
          <source>If the order of the answers is not important, there is an alternative to the &lt;code&gt;unique&lt;/code&gt; option, namely to sort the answers uniquely:</source>
          <target state="translated">如果答案的顺序不重要，则可以使用 &lt;code&gt;unique&lt;/code&gt; 选项替代方法，即对答案进行唯一排序：</target>
        </trans-unit>
        <trans-unit id="b054305581b7663ed91514b307669add31ca5b5b" translate="yes" xml:space="preserve">
          <source>If the packet does not conform to the protocol format, &lt;code&gt;{error,Reason}&lt;/code&gt; is returned.</source>
          <target state="translated">如果数据包不符合协议格式，则返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2c9f15b9a918cfc529cc22dc69ae62a00c732a6" translate="yes" xml:space="preserve">
          <source>If the page is empty, it means either of the following:</source>
          <target state="translated">如果页面是空的,说明有以下情况之一。</target>
        </trans-unit>
        <trans-unit id="f52fa558245396ce59f0c16eb282e09760e84891" translate="yes" xml:space="preserve">
          <source>If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The module &lt;code&gt;dbg&lt;/code&gt; actually exports a function with this name, but it should never really be called except for when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including the &lt;code&gt;ms_transform.hrl&lt;/code&gt; header file, compiled code will never call the function, but the function call is replaced by a literal match_spec.</source>
          <target state="translated">如果parse_transform不应用于调用此伪函数的模块，则该调用将在运行时失败（带有 &lt;code&gt;badarg&lt;/code&gt; ）。实际上，模块 &lt;code&gt;dbg&lt;/code&gt; 会导出具有该名称的函数，但是除非在shell中使用该函数，否则绝对不要真正调用它。如果 &lt;code&gt;parse_transform&lt;/code&gt; 正确通过包括应用 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 头文件，编译的代码永远不会调用函数，但函数调用由字面match_spec取代。</target>
        </trans-unit>
        <trans-unit id="7c4c35e1fed61f85f87d7154c2244f967d2936c6" translate="yes" xml:space="preserve">
          <source>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</source>
          <target state="translated">如果图案没有锚定,那么就会发生正常的 &quot;bumpalong &quot;前进到下一个起始字符。在到达(*PRUNE)的左边,或者在到达(*PRUNE)之前,或者在匹配到(*PRUNE)的右边时,可以像往常一样发生回溯,但如果右边没有匹配,回溯就不能跨越(*PRUNE)。在简单的情况下,(*PRUNE)的使用只是原子组或占有式量词的替代物,但(*PRUNE)的一些使用是不能用其他方式表达的。在锚定模式中,(*PRUNE)与(*COMMIT)具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="caf53e7076db6e332a206c64cff8afbb0ab34c47" translate="yes" xml:space="preserve">
          <source>If the permission of a loaded, but not started, application is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; but the application is not started until the permission is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果将已加载但未启动的应用程序的许可权设置为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;start&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; ,但直到许可权设置为 &lt;code&gt;true&lt;/code&gt; ，应用程序才启动。</target>
        </trans-unit>
        <trans-unit id="fb5424927d13c1c2f8655ecb9fa4aea52eaa565c" translate="yes" xml:space="preserve">
          <source>If the permission of a running application is set to &lt;code&gt;false&lt;/code&gt;, the application is stopped. If the permission later is set to &lt;code&gt;true&lt;/code&gt;, it is restarted.</source>
          <target state="translated">如果正在运行的应用程序的权限设置为 &lt;code&gt;false&lt;/code&gt; ，则该应用程序将停止。如果稍后将权限设置为 &lt;code&gt;true&lt;/code&gt; ，那么它将重新启动。</target>
        </trans-unit>
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果port命令中止，则返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">如果端口驱动程序不支持同步控制操作。</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">如果端口驱动程序出于某种原因而做出决定（可能是 &lt;code&gt;Operation&lt;/code&gt; 或 &lt;code&gt;Data&lt;/code&gt; 出了点问题）。</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">如果端口因某种原因而终止。</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果端口标识的 &lt;code&gt;Port&lt;/code&gt; 未打开，则返回 &lt;code&gt;undefined&lt;/code&gt; 。如果端口是关闭的，并且调用过程先前已链接到该端口，则可以保证在 &lt;code&gt;port_info/2&lt;/code&gt; 返回 &lt;code&gt;undefined&lt;/code&gt; 之前传递该端口的退出信号。</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">如果端口繁忙,则暂停呼叫过程,直到端口不再繁忙。</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">如果端口繁忙,则暂停呼叫过程,直到端口不再繁忙。</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">如果端口程序没有退出就关闭其 &lt;code&gt;stdout&lt;/code&gt; ，则选项 &lt;code&gt;exit_status&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">如果要更新端口程序，则可以使用 &lt;code&gt;code_change&lt;/code&gt; 函数扩展 &lt;code&gt;gen_server&lt;/code&gt; 的代码，该函数将关闭旧端口并打开新端口。（如果需要， &lt;code&gt;gen_server&lt;/code&gt; 可以首先请求必须从端口程序中保存的数据，并将该数据传递到新端口）：</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">如果调用 &lt;code&gt;erlang:resume_process/1&lt;/code&gt; 的进程先前未增加 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程的挂起计数。</target>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果该进程不存在，则会引发 &lt;code&gt;noproc&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">如果进程在它的消息队列中有任何消息,那么进程就会被立即唤醒,方法和前面描述的一样。</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">如果由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程具有注册名称，则还将包含一个带有 &lt;code&gt;registered_name&lt;/code&gt; 项的 &lt;code&gt;InfoTuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 标识的进程不是现有的本地进程。</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">如果被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程被调用过程挂起的次数多于当前使用的内部数据结构所表示的时间。系统限制是&amp;gt; 2,000,000,000挂起，并且永远不会更低。</target>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">如果被 &lt;code&gt;Suspendee&lt;/code&gt; 确定的过程尚未生效。</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程与调用 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的进程相同。</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程是否位于另一个节点上。</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">如果该进程处于活动状态并且指定了单个 &lt;code&gt;Item&lt;/code&gt; ，则返回的值是对应的 &lt;code&gt;InfoTuple&lt;/code&gt; ，除非 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 且该进程没有注册名称。在这种情况下，返回 &lt;code&gt;[]&lt;/code&gt; 。这种奇怪的行为是由于历史原因造成的，并且为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">如果该过程是使用有趣的 &lt;code&gt;StateFun&lt;/code&gt; 替换其状态，则 &lt;code&gt;handle_system_msg&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">如果进程要返回其状态，则 &lt;code&gt;handle_system_msg&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">如果进程或端口已经被注册 (已经有了名字)。</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">如果该进程可能在其队列中获取许多消息，建议您将标志设置为 &lt;code&gt;off_heap&lt;/code&gt; 。这是因为在堆上放置许多消息的垃圾回收可能变得非常昂贵，并且该过程会消耗大量内存。但是，当不使用标志 &lt;code&gt;off_heap&lt;/code&gt; 时，实际消息传递的性能通常会更好。</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">如果该进程由于 &lt;code&gt;normal&lt;/code&gt; 或 &lt;code&gt;shutdown&lt;/code&gt; 以外的其他原因终止，则会生成崩溃报告。有关崩溃报告的更多信息，请参见《 SASL用户指南》。</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">如果使用fun生成了该过程，则 &lt;code&gt;initial_call/1&lt;/code&gt; 不再返回fun，而是实现该fun的本地函数的模块，函数以及arity，例如 &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; （意味着乐趣是在 &lt;code&gt;some_module:work/3&lt;/code&gt; 函数中创建的）。原因是保持乐趣会阻止模块的代码升级，并且可能浪费大量内存。</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">如果程序太大而无法通过 &lt;code&gt;fprof&lt;/code&gt; 或 &lt;code&gt;eprof&lt;/code&gt; 进行概要分析， &lt;code&gt;cprof&lt;/code&gt; 可以使用cprof来定位要使用 &lt;code&gt;fprof&lt;/code&gt; 或 &lt;code&gt;eprof&lt;/code&gt; 进行概要分析的代码部分。</target>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">如果纯粹的编码/解码性能真的是一个严重的问题,可以使用我们的 erl_dist 编码器,因为 erlang 分发格式的编码/解码速度比所有其他选择快得多。它的主要缺点是还没有被批准为有效的Megaco/H.248信息编码。</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">如果量化符为{0},则在匹配过程中从不服从该断言。但是,它可以包含通过子程序机制从其他地方调用的内部捕获小括号组。</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">如果正则表达式包含捕捉子模式,比如在。</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">如果正则表达式之前已被编译,则选项列表只能包含以下选项。</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">如果正则表达式以前是使用 &lt;code&gt;unicode&lt;/code&gt; 选项编译的，则 &lt;code&gt;Subject&lt;/code&gt; 将作为有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; 提供，否则任何 &lt;code&gt;iodata()&lt;/code&gt; 都可以。如果涉及编译并且指定了 &lt;code&gt;unicode&lt;/code&gt; 选项，则必须将 &lt;code&gt;Subject&lt;/code&gt; 和正则表达式都指定为有效的Unicode &lt;code&gt;charlists()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">如果要升级版本,还必须包括SASL应用。</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">如果发行版软件包包含一个新的Erlang运行时系统，则将指定的运行时系统 &lt;code&gt;{erts,Dir}&lt;/code&gt; 的 &lt;code&gt;bin&lt;/code&gt; 目录复制到 &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">如果答复在呼叫超时后到达，则没有消息污染呼叫者的消息队列，因为此函数产生一个中间人进程，以充当此类孤立答复的（无效）目的地。此功能还使此功能比呼叫者端的 &lt;code&gt;call/4&lt;/code&gt; 更为昂贵。</target>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">如果报表浏览器是脱机使用的，则可以将报表复制到启动浏览器时指定的另一个目录。如果未指定此类目录，则浏览器将从SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; 中读取报告。</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">如果对SFTP通道的请求功能返回 &lt;code&gt;{error, timeout}&lt;/code&gt; ，则在预期时间内未收到来自服务器的答复。</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">如果请求是HTTP / 1.1请求，则URI可以采用绝对URI格式。在这种情况下， &lt;code&gt;httpd&lt;/code&gt; 会将绝对URI保存在此字段中。绝对URI的示例是 &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">如果请求已成功编码和发送，但应答超时，则将发生 &lt;code&gt;handle_error/4&lt;/code&gt; 回调，且 &lt;code&gt;Reason = timeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">如果请求已成功编码和发送，但在接收到答案之前已停止相关服务，则将使用 &lt;code&gt;Reason = cancel&lt;/code&gt; 进行 &lt;code&gt;handle_error/4&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">如果请求的数据可用，则该子条目与 &lt;code&gt;Name&lt;/code&gt; 关联，以便可以使用 &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; 读取元素的值，前提是使用 &lt;code&gt;Name&lt;/code&gt; 而不是整个 &lt;code&gt;Required&lt;/code&gt; 术语。</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">如果在仿真器启动过程中通过设置STDLIB变量来激活受限外壳，并且无法加载回调模块，则默认的受限外壳仅允许使用 &lt;code&gt;q()&lt;/code&gt; 和 &lt;code&gt;init:stop()&lt;/code&gt; 命令作为后备。</target>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; 激活了受限制的外壳程序，并且无法加载回调模块，则会向错误记录器发送错误报告，并且调用返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">如果&lt;strong&gt;显然&lt;/strong&gt;不使用列表理解的结果，则不会构造列表。例如，在此代码中：</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">如果运行时系统处于 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; ，则当运行时系统检测到 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 已更改时，时间偏移也会更改。但是，运行时系统不会立即检测到它。检查时间偏移的任务计划至少每分钟执行一次，因此在正常操作下，应在一分钟内检测到该任务，但是在重负载期间可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">如果运行时系统处于 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; ，则当运行时系统检测到 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 已更改时，时间偏移也会更改。但是，运行时系统不会立即检测到它。检查时间偏移的任务计划至少每分钟执行一次；因此，在正常操作下，一分钟之内即可检测到，但是在重负载下，则可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">如果使用方案 &lt;code&gt;https&lt;/code&gt; ，则必须启动 &lt;code&gt;SSL&lt;/code&gt; 应用程序。当 &lt;code&gt;https&lt;/code&gt; 链接需要通过代理时，使用HTTP-1.1的CONNECT方法扩展来建立隧道，然后将连接升级到TLS。但是，不支持根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; 的 &amp;ldquo; TLS升级&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">如果必须暂停发送方以进行发送， &lt;code&gt;nosuspend&lt;/code&gt; 返回nosuspend。</target>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果未在配置文件中指定服务器，请改用 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果未在配置文件中指定服务器，请改用 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在配置文件中指定了服务器选项，或者需要使用命名客户端进行日志记录（请参阅&amp;ldquo; 在此模块中 &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 一节），请改用 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在配置文件中指定了服务器选项，请改用 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">如果服务器从客户端收到与 &lt;code&gt;sni_hosts&lt;/code&gt; 选项中列出的主机匹配的SNI（服务器名称指示），则该主机的特定选项将覆盖先前指定的选项。选项 &lt;code&gt;sni_fun&lt;/code&gt; 和 &lt;code&gt;sni_hosts&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">如果服务器从客户端接收到SNI（服务器名称指示），则将调用给定函数以检索所指示服务器的 &lt;code&gt;[ssl_option()]&lt;/code&gt; 。这些选项将合并到预定义的 &lt;code&gt;[ssl_option()]&lt;/code&gt; 中。该函数应定义为： &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; 并且可以指定为fun或命名为 &lt;code&gt;fun module:function/1&lt;/code&gt; 选项 &lt;code&gt;sni_fun&lt;/code&gt; 和 &lt;code&gt;sni_hosts&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">如果减小文件的大小,该变化会立即影响当前的日志。在下次使用之前,它不会改变已经满的日志文件的大小。</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">如果进程中的活数据大小小于最小堆大小,则进程被唤醒后发生的第一次垃圾收集会确保堆大小改为不小于最小堆大小。</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">如果跳过的测试用例属于测试用例组，则第一个参数是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">如果snmp代理被配置为分布式Erlang应用程序,它将在接管过程中尝试加载与老节点相同的MIB。它使用与旧节点相同的文件名。如果MIBs不在不同节点的相同路径中,则必须在接管后显式加载MIBs。</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">如果套接字是一个监听套接字,我们使用一个单独的(常规)文件来实现两个目的。</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">如果套接字被关闭,则会传递以下信息。</target>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">如果套接字处于 &lt;code&gt;{active, N}&lt;/code&gt; 模式（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; ），并且其消息计数器降至 &lt;code&gt;0&lt;/code&gt; ，则传递以下消息以指示套接字已转换为被动（ &lt;code&gt;{active, false}&lt;/code&gt; ）模式：</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">如果套接字处于繁忙状态,当ERTS套接字实现内部排队的数据量低于此限制时,套接字将被设置为不繁忙状态。默认值为4 kB。</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">如果套接字未处于活动模式，则可以通过 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; 调用来检索数据。请注意，长度超过接收缓冲区选项指定的到达UDP数据包可以被截断而不会发出警告。</target>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">如果套接字被设置为活动模式,该函数将把调用者邮箱中的任何消息传输到新的控制进程。如果在传输过程中,有其他进程与套接字进行交互,那么传输可能无法正常进行,消息可能会留在调用者的邮箱中。例如,在传输完成之前改变套接字的活动模式可能会导致这种情况。</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">如果套接字消息队列处于繁忙状态,当消息队列中排队的数据量低于这个限制时,套接字消息队列被设置为不繁忙状态。注意,这个限制只涉及尚未到达ERTS内部套接字实现的数据。默认值为4 kB。</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">如果无法使用 &lt;code&gt;file:open/2&lt;/code&gt; 打开源文件和/或输出文件，则该函数返回 &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; ，其中 &lt;code&gt;File&lt;/code&gt; 是文件名， &lt;code&gt;Reason&lt;/code&gt; 是错误原因。</target>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">如果特殊进程被设置为陷阱退出,如果父进程终止,预期的行为是以同样的理由终止。</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">如果指定的 &lt;code&gt;SessionId&lt;/code&gt; 等于当前会话ID，则返回错误。</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">如果未启用指定的分配器类型，则调用将失败，并显示 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果未加载指定的应用程序，或者执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果未加载指定的应用程序，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。如果执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果指定的进程不属于任何应用程序，或者指定的进程或模块不存在，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">如果启动过程失败，则函数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 返回神秘的元组 &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; 。要获取有关启动失败的更多信息，请使用命令行参数 &lt;code&gt;-boot start_sasl&lt;/code&gt; 作为 &lt;code&gt;erl&lt;/code&gt; 脚本的参数。</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">如果状态发生变化,传入事件的队列将被重置,从最老的推迟开始。</target>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">如果状态为 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;ok_simultaneous&lt;/code&gt; ，则握手继续，并且 &lt;code&gt;B&lt;/code&gt; 向 &lt;code&gt;A&lt;/code&gt; 发送另一条消息，即质询。质询包含与最初从 &lt;code&gt;A&lt;/code&gt; 发送到 &lt;code&gt;B&lt;/code&gt; 的&amp;ldquo;名称&amp;rdquo;消息相同类型的信息，外加一个32位质询：</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">如果架构的存储类型为 &lt;code&gt;ram_copies&lt;/code&gt; ，即无盘节点，则 &lt;code&gt;Mnesia&lt;/code&gt; 不会在该特定节点上使用该盘。通过将表 &lt;code&gt;schema&lt;/code&gt; 的存储类型更改为 &lt;code&gt;disc_copies&lt;/code&gt; 来启用光盘使用。</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">如果结构化类型的组件具有嵌入的 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; ,而嵌入的类型又是 &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; ，则它会提供带有 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; 的记录，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">如果按照本示例那样安装样式表，则类别对于所讨论的套件是私有的。它们可以被套件中的所有测试用例使用，但不能被其他套件使用。使用套件私有样式表（如果已指定），则倾向于使用全局样式表（用flag &lt;code&gt;-stylesheet&lt;/code&gt; 指定的样式表）。样式表元组（由上面的 &lt;code&gt;suite/0&lt;/code&gt; 返回）也可以从测试用例信息函数中返回。在这种情况下，样式表中指定的类别只能在该特定测试用例中使用。使用测试用例专用样式表来代替套件或全局级别的样式表。</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">如果主语是 &quot;aaac...&quot;,在第一次匹配尝试失败后(从字符串中的第一个字符开始),起点会跳转到 &quot;c &quot;处开始下一次尝试。请注意,占有式定语符的效果与本例不同;虽然它将抑制第一次匹配尝试时的回溯,但第二次尝试将从第二个字符开始,而不是跳转到 &quot;c&quot;。</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">如果主题是 &quot;abac&quot;,Perl就会匹配,但PCRE失败了,因为组的第二个重复中的(*COMMIT)作用。</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">如果主题是 &quot;ba&quot;,这个模式就不匹配。由于.*?是不贪婪的,它最初匹配的字符为零。然后条件(?=a)失败,字符 &quot;b &quot;被匹配,但 &quot;c &quot;没有被匹配。这时,匹配并没有回溯到.*?,也许可以从存在的|字符中得到预期。条件子模式是构成整个模式的单一选项的一部分,因此匹配失败。(如果有一个回溯到.*?,允许它匹配 &quot;b&quot;,匹配就会成功。)</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">如果主题是 &quot;xyz123abc123&quot;,匹配点是第四个字符。因此,这样的模式不是隐性锚定的。</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">如果子系统选项不存在，则使用 &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; 的值。默认情况下，这将启用sftp子系统。如果您不希望守护程序运行任何子系统，则可以将该选项设置为空列表。</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">如果成功创建了主管及其子进程（即，如果所有子进程启动函数都返回 &lt;code&gt;{ok,Child}&lt;/code&gt; ， &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; ），则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是主管的pid。</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">如果主管桥和子系统已成功启动，则函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是主管桥的pid。</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">如果主管是 &lt;code&gt;simple_one_for_one&lt;/code&gt; ，则 &lt;code&gt;Id&lt;/code&gt; 必须是子进程的 &lt;code&gt;pid()&lt;/code&gt; 。如果指定的进程处于活动状态，但不是指定的主管的子进程，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。如果指定了子规范标识符而不是 &lt;code&gt;pid()&lt;/code&gt; ，则函数返回 &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">如果主管不是 &lt;code&gt;simple_one_for_one&lt;/code&gt; ，则 &lt;code&gt;Id&lt;/code&gt; 必须是子规范标识符。该过程（如果有的话）将终止，除非它是一个临时子进程，否则该子进程规范将由主管保留。子进程以后可以由主管重新启动。子进程也可以通过调用 &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; 显式重启。使用 &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; 删除子级规范。</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;badarg&lt;/code&gt; 未运行，则该函数失败，原因是badarg。</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程的挂起计数增加，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">如果递归子模式调用的语法(无论是数字还是名称)被用在它所引用的括号之外,它的操作就像编程语言中的子程序一样。被调用的子模式可以在引用之前或之后定义。编号引用可以是绝对的,也可以是相对的,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">如果系统由多个Erlang节点组成，则每个节点都可以使用自己的发行版。发布处理程序是一个本地注册的进程，必须在需要升级或降级的每个节点上调用它。释放处理指令 &lt;code&gt;sync_nodes&lt;/code&gt; 可以用于在多个节点上同步释放处理程序进程，请参阅SASL中的 &lt;code&gt;appup(4)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">如果系统被BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; 暂停，则口号是传递给BIF的字符串参数，否则是由仿真器或（Erlang）内核生成的描述。通常，该消息足以理解问题，但是此处描述了一些消息。请注意，崩溃的建议原因&lt;strong&gt;仅是建议&lt;/strong&gt;。错误的确切原因可能会因本地应用程序和底层操作系统而异。</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">如果由于缺少心跳或终止的Erlang运行系统而要重新引导系统， &lt;code&gt;HEART_COMMAND&lt;/code&gt; 必须在启动系统之前设置环境变量HEART_COMMAND。如果未设置此变量，则会打印警告文本，但系统不会重新引导。</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">如果系统升级失败，则必须在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上重新启动 &lt;code&gt;Mnesia&lt;/code&gt; ,以还原旧数据库。成功启动后，将自动卸载后备。成功升级系统后，函数 &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; 也可用于卸载后备。同样，这是在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上执行的分布式操作，或者不执行任何操作。后备的安装和卸载都要求Erlang在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上都可运行，但是 &lt;code&gt;Mnesia&lt;/code&gt; 是否正在运行都没有关系。</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">如果系统使用发布处理，则应将其设置为类似于 &lt;code&gt;start_erl.exe&lt;/code&gt; 的程序。</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">如果已使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 修复了该表，则该调用将返回一个元组，其中 &lt;code&gt;FixationTime&lt;/code&gt; 是该表首次由某个进程修复的时间，而该进程是现在已修复的进程之一，也可能不是该进程已修复的进程之一。</target>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">如果该表是哈希表，即它不是 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">如果该表是哈希表。包含有关该表的统计数据,如最大、最小和平均链长。最大值远大于平均值,标准差远大于预期标准差,这表明术语的哈希值由于某种原因表现得很糟糕。</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">如果表是 &lt;code&gt;ordered_set&lt;/code&gt; 。（元素的数量与表中对象的数量相同。）</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">如果删除了该表，则即使使用相同名称创建另一个命名表， &lt;code&gt;tid()&lt;/code&gt; 也将无效。</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">如果表为空，则返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">如果表是使用 &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; 或某些内部机制固定的。</target>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该表从未修复过，则调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">如果表类型为 &lt;code&gt;ordered_set&lt;/code&gt; ,并且插入对象的键与表中任何对象的键&lt;strong&gt;相等&lt;/strong&gt;，则替换旧对象。</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且给定键存在多个对象，则选择其中一个对象。这不一定是输入函数返回的对象序列中具有给定键的最后一个对象。避免使用重复的密钥，否则文件将不必要地分散。这也适用于存储在 &lt;code&gt;bag&lt;/code&gt; 类型表中的重复对象。</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且给定键存在多个对象，则选择其中一个对象。这不一定是输入函数返回的对象序列中具有给定键的最后一个对象。这也适用于存储在 &lt;code&gt;bag&lt;/code&gt; 类型表中的重复对象。</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且插入对象的键与表中任何对象的键&lt;strong&gt;匹配&lt;/strong&gt;，则替换旧对象。</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，则该函数将返回空列表或具有一个对象的列表，因为具有给定键的对象不能超过一个。如果表类型是 &lt;code&gt;bag&lt;/code&gt; 或 &lt;code&gt;duplicate_bag&lt;/code&gt; ，则该函数返回任意长度的列表。</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">如果在比较键是否相等时该表使用 &lt;code&gt;==/2&lt;/code&gt; ，则 &lt;code&gt;qlc&lt;/code&gt; 模块将查找常量，而不管QLC中使用了哪个运算符。但是， &lt;code&gt;==/2&lt;/code&gt; 是首选：</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">如果表格被压缩。</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">如果目标主机是 &quot;特殊 &quot;节点,则必须在配置文件中指定FTP地址,如下所示。</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">如果目标主机是其他的东西,例如,UNIX主机,配置文件还必须包括用户名和密码(两个字符串)。</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">如果测试用例函数崩溃或故意退出，则认为它&lt;strong&gt;失败&lt;/strong&gt;。如果它返回一个值（无论是什么值），则认为它是成功的。此规则的例外是返回值 &lt;code&gt;{skip,Reason}&lt;/code&gt; 。如果返回该元组，则认为该测试用例已跳过并被记录下来。</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果测试用例返回元组 &lt;code&gt;{comment,Comment}&lt;/code&gt; ，则认为该用例成功，并且 &lt;code&gt;Comment&lt;/code&gt; 被打印在概述日志文件中。这等于调用 &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">如果测试是在选项 &lt;code&gt;create_priv_dir&lt;/code&gt; 设置为 &lt;code&gt;manual_per_tc&lt;/code&gt; 的情况下启动的，为了使测试用例使用私有目录，它必须首先通过调用此函数来创建它。</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">如果改为通过调用 &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; 来启动测试会话，则结果是测试 &lt;code&gt;t1&lt;/code&gt; 不会在 &lt;code&gt;ct_node@host_x&lt;/code&gt; （或任何其他节点）上运行测试 &lt;code&gt;t3&lt;/code&gt; 在 &lt;code&gt;ct_node@host_y&lt;/code&gt; 和 &lt;code&gt;ct_node@host_z&lt;/code&gt; 上都运行。</target>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">如果括号之间的文本由一个数字序列组成，则该条件为true，前提是该数字的捕获子模式先前已匹配。如果存在多个具有相同编号的捕获子模式（请参见前面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 一节），则条件是正确的，前提是它们中的任何一个都已匹配。另一种表示法是在数字前加上加号或减号。在这种情况下，子模式编号是相对的而不是绝对的。最近打开的括号可以用（？（-1）引用，下一个最近的括号可以用（？（-2）引用，依此类推。在循环内，引用后续组也很有意义。可以将其打开称为（？（+ 1），依此类推。（不使用任何这些形式的值零；它会引发编译时错误。）</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">如果计时器的类型为 &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ，则对于每个中间的timout，将重新发送答复（在接收到确认或计时器到期之前这是有效的）。</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">如果跟踪元组包含五个元素，则第五个元素将作为 &lt;code&gt;Opts&lt;/code&gt; 映射中的 &lt;code&gt;extra&lt;/code&gt; 值发送。</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">如果被跟踪的节点是无磁盘的， &lt;code&gt;ttb&lt;/code&gt; 必须从具有磁盘访问权限的跟踪控制节点启动ttb，并且必须将选项 &lt;code&gt;file&lt;/code&gt; 指定为函数 &lt;code&gt;tracer/2&lt;/code&gt; ，其值为 &lt;code&gt;{local, File}&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">如果跟踪进程/端口死亡或跟踪器模块返回 &lt;code&gt;remove&lt;/code&gt; ，则将静默删除这些标志。</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">如果跟踪应在函数返回后继续进行（例如，如果它是启动函数以生成要分析的进程），则可以使用 &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; 。必须在以后的适当时间使用 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 停止跟踪。</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">如果与对等方的传输连接在发送请求后但未收到应答之前断开，则尝试将请求重新发送给备用对等方。如果没有可用的此类对等方，或者后续的 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调拒绝候选者，则将发生 &lt;code&gt;handle_error/4&lt;/code&gt; 回调，并带有 &lt;code&gt;Reason = failover&lt;/code&gt; 。如果选择了对等方，则发生 &lt;code&gt;prepare_retransmit/3&lt;/code&gt; 回调，此后的语义与执行初始 &lt;code&gt;prepare_request/3&lt;/code&gt; 回调之后的语义相同。</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">如果升级或降级失败,应用程序可能最终处于不一致的状态。</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">如果用户出于某种原因想要将跟踪令牌传递给端口，则必须在端口控制过程的代码中手动完成此操作。端口控制进程必须检查适当的顺序跟踪设置（从 &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; 获得），并将跟踪信息包含在发送到各自端口的消息数据中。</target>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">如果用户为测试指定了整个目录的测试套件,套件的执行顺序取决于操作系统对文件的排列方式,不同系统之间的排列方式有所不同。</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">如果用户仅通过指定顶层目录（例如，使用start flag / option &lt;code&gt;dir&lt;/code&gt; ）来运行测试对象（或OTP应用程序）的所有测试套件，则 &lt;code&gt;Common Test&lt;/code&gt; 主要在名为 &lt;code&gt;test&lt;/code&gt; 的子目录中查找测试套件模块。。如果此子目录不存在，则假定指定的顶层目录为测试目录，并从那里读取测试套件。</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">如果用户想要更新记录，它是更有效地使用 &lt;code&gt;write/sticky_write&lt;/code&gt; 作为 &lt;code&gt;LockKind&lt;/code&gt; 。如果多数检查在表上处于活动状态，则在尝试写锁定时将对其进行检查。如果不满足多数条件，这可以用来快速结束。</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">如果用户想以机器容量的百分比来查看负载值,那么这种测量方式就会出现一个问题,因为负载值并不限制在一个固定的区间内。在这种情况下,以下简单的数学变换就可以得出负载值的百分比。</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">如果用户的DSA、RSA或ECDSA密钥受密码保护,可以提供这些选项。</target>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">如果值为 &lt;code&gt;false&lt;/code&gt; （被动模式），则该进程必须通过调用 &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; 来显式接收传入的数据（取决于套接字的类型） ）。</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">如果该值为 &lt;code&gt;false&lt;/code&gt; ，则Igor将读取源文件而不将其通过Erlang预处理程序（ &lt;code&gt;epp&lt;/code&gt; ），以避免扩展诸如 &lt;code&gt;-include(...).&lt;/code&gt; 类的预处理程序指令。， &lt;code&gt;-define(...).&lt;/code&gt; 和 &lt;code&gt;-ifdef(...)&lt;/code&gt; 以及诸如 &lt;code&gt;?LINE&lt;/code&gt; 和 &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; 类的宏调用。默认值为 &lt;code&gt;false&lt;/code&gt; ，即未完成预处理。 （有关详细信息，请参见模块 &lt;code&gt;epp_dodger&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;once&lt;/code&gt; （ &lt;code&gt;{active, once}&lt;/code&gt; ），则来自套接字的&lt;strong&gt;一条&lt;/strong&gt;数据消息将发送到该进程。要再接收一条消息，必须使用选项 &lt;code&gt;{active, once}&lt;/code&gt; 再次调用 &lt;code&gt;setopts/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则原始代码中的所有 &lt;code&gt;-import(...)&lt;/code&gt; 声明都将在结果中扩展；否则，将保留尽可能多的原始进口申报单。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将删除所有import语句，并且对导入函数的调用将扩展为显式远程调用。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，那么将禁止显示所有信息消息和警告消息。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则所有匹配项&amp;ldquo; &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; &amp;rdquo;，其中 &lt;code&gt;E&lt;/code&gt; 是case-，if-或receive-expression，其分支均返回n个元组（或显式抛出异常）。直接绑定并导出变量 &lt;code&gt;V1&lt;/code&gt; ，...， &lt;code&gt;Vn&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则所有影响修改代码方式的选项都设置为&amp;ldquo;无更改&amp;rdquo;。例如，仅更新防护测试， &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; 更新其他任何内容，请使用选项[new_guard_tests，idem]。（请记住，靠近列表开头的选项具有更高的优先级。）</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则将使用列表推导重写对 &lt;code&gt;lists:map/2&lt;/code&gt; 和 &lt;code&gt;lists:filter/2&lt;/code&gt; 的调用。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在打开新文件进行写入之前，将重命名现有文件。通过将 &lt;code&gt;backup_suffix&lt;/code&gt; 选项给定的字符串附加到原始名称中来形成新名称。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则防护测试将更改为使用旧名称代替新名称，例如，使用&amp;ldquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;rdquo;代替&amp;ldquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;rdquo;。默认值为 &lt;code&gt;false&lt;/code&gt; 。此选项将覆盖 &lt;code&gt;new_guard_tests&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则防护测试将更新为使用新名称，例如&amp;ldquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;rdquo;而不是&amp;ldquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;rdquo;。默认值为 &lt;code&gt;true&lt;/code&gt; 。另请参见 &lt;code&gt;old_guard_tests&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则不会将文件写入磁盘，而是将其打印到stdout。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则即使目标模块的名称与任何输入模块的名称不同，也不会在结果模块的顶部添加任何标题注释。相反，Igor将尝试保留其代码位于输出顶部的模块的外观。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则不会修改任何文件。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则不会修改任何文件；如果启用了 &lt;code&gt;verbose&lt;/code&gt; 标志，这通常最有用，以生成有关程序文件的报告而不影响它们。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在源自特定输入模块的代码的每个部分的开头，都不会将标题注释添加到结果模块中。默认值为 &lt;code&gt;false&lt;/code&gt; ，这意味着通常在合并两个以上模块时会添加节头。</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在读取源代码时将进行预处理。有关详细信息，请参见 &lt;code&gt;merge_files/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息，除非 &lt;code&gt;quiet&lt;/code&gt; 选项为 &lt;code&gt;true&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息，除非 &lt;code&gt;quiet&lt;/code&gt; 选项为 &lt;code&gt;true&lt;/code&gt; 。当调用默认值 &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息；否则，将显示进度消息。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则原始文件中的源代码注释将保留在输出中。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，那么将为所有与目标模块名称不同的导出模块自动生成存根模块文件。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将递归访问子目录。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将跟随符号目录链接。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值是 &lt;code&gt;true&lt;/code&gt; ，所得到的代码将使用被处理 &lt;code&gt;erl_tidy&lt;/code&gt; 模块，其中删除未使用的功能和一般不代码清理。（有关其他选项，请参见 &lt;code&gt;erl_tidy:module/2&lt;/code&gt; 。）默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则等效于在 &lt;code&gt;export&lt;/code&gt; 选项中列出所有输入模块。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则未使用的功能不会从代码中删除。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，这是默认值，那么将从套接字接收的所有内容都作为消息发送到接收进程。</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;yes&lt;/code&gt; ，则输入源中的所有文件属性 &lt;code&gt;-file(...)&lt;/code&gt; 将保留在结果代码中。如果值是 &lt;code&gt;comment&lt;/code&gt; ，它们将被转换为注释，但相对于其他源代码形式，它们将保留在代码中的原始位置。如果值为 &lt;code&gt;no&lt;/code&gt; ，则所有文件属性都将从代码中删除，除非它们附加了注释，在这种情况下，将按 &lt;code&gt;comment&lt;/code&gt; 方式处理它们。默认值为 &lt;code&gt;no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;yes&lt;/code&gt; ，则将在代码中进行了重要更改的位置插入注释。如果该值 &lt;code&gt;always&lt;/code&gt; ，则将注释&lt;strong&gt;所有&lt;/strong&gt;对代码的更改。如果值为 &lt;code&gt;no&lt;/code&gt; ，则将进行更改而不会添加注释。默认值为 &lt;code&gt;yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">如果该值是-32768到32767（含）之间的整数 &lt;code&gt;N&lt;/code&gt; ，则将该值添加到套接字发送给控制进程的数据消息的计数中。套接字的默认消息计数为 &lt;code&gt;0&lt;/code&gt; 。如果指定了负值，并且其大小等于或大于套接字的当前消息计数，则套接字的消息计数将设置为 &lt;code&gt;0&lt;/code&gt; 。一旦套接字的消息计数达到 &lt;code&gt;0&lt;/code&gt; ，要么是由于向进程发送已接收的数据消息，要么是由于显式设置了套接字，然后通过特定于套接字类型的特殊消息通知该进程该套接字已进入被动模式。套接字进入被动模式后，要接收更多消息 &lt;code&gt;setopts/2&lt;/code&gt; 必须再次调用以将套接字设置回活动模式。</target>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">如果该值未达到,则该连接的套接字关闭。</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">如果期权的价值 &lt;code&gt;keep_labels&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，这是默认情况下， &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; 顶点和边缘的 &lt;code&gt;Digraph&lt;/code&gt; 被用于子为好。如果值为 &lt;code&gt;false&lt;/code&gt; ，则默认标签 &lt;code&gt;[]&lt;/code&gt; 用于子组的顶点和边缘。</target>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">如果期权的价值 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;inherit&lt;/code&gt; ，这是默认的类型， &lt;code&gt;Digraph&lt;/code&gt; 用于子为好。否则，将 &lt;code&gt;type&lt;/code&gt; 的选项值用作 &lt;code&gt;digraph:new/1&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_mon.app&lt;/code&gt; 中列出的值不适合您的需求，请&lt;strong&gt;不要&lt;/strong&gt;编辑该文件。而是&lt;strong&gt;覆盖&lt;/strong&gt;&lt;strong&gt;系统配置文件中&lt;/strong&gt;的值，该&lt;strong&gt;文件&lt;/strong&gt;的完整路径名在命令行上提供给 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">如果变量 &lt;code&gt;V&lt;/code&gt; 是未绑定的，则它将绑定到与键 &lt;code&gt;K&lt;/code&gt; 关联的值，该键K必须存在于映射 &lt;code&gt;M&lt;/code&gt; 中。如果变量 &lt;code&gt;V&lt;/code&gt; 被绑定，它必须与相关联的值相匹配 &lt;code&gt;K&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">如果将该变量设置为 &lt;code&gt;0&lt;/code&gt; 秒，则运行时系统甚至不会尝试写入故障转储文件。它只会终止。这是如果选项默认 &lt;code&gt;-heart&lt;/code&gt; 传递给 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">如果变量设置为正值 &lt;code&gt;S&lt;/code&gt; ，则等待 &lt;code&gt;S&lt;/code&gt; 秒以完成故障转储文件，然后使用 &lt;code&gt;SIGALRM&lt;/code&gt; 信号终止运行系统。</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">如果verify回调函数总是返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则关于验证失败，TLS / DTLS握手不会终止，并且连接已建立。</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">如果verify回调fun返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ，则立即停止验证过程，向对等方发送警报，并且TLS / DTLS握手终止。</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">如果verify回调fun返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ，则验证过程将立即停止。如果verify回调函数返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则验证过程将继续。这可以用来接受特定的路径验证错误，例如 &lt;code&gt;selfsigned_peer&lt;/code&gt; ，以及验证特定于应用程序的扩展。如果使用用户应用程序未知的扩展名进行调用，则将使用返回值 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">如果验证回调函数返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则验证过程将继续。</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">如果从开发系统中的 &lt;code&gt;OTP_VERSION&lt;/code&gt; 文件读取的版本带有 &lt;code&gt;**&lt;/code&gt; 后缀，则已使用 &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; 工具对系统进行了修补。在这种情况下，系统由来自多个OTP版本的应用程序版本组成。后缀 &lt;code&gt;**&lt;/code&gt; 之前的版本对应于已打补丁的基本系统的OTP版本。请注意，如果通过 &lt;code&gt;otp_patch_apply&lt;/code&gt; 以外的其他方式更新了开发系统，则文件 &lt;code&gt;OTP_VERSION&lt;/code&gt; 可以标识不正确的OTP版本。</target>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">如果由于尚未使用所有文件而导致包装日志未满 &lt;code&gt;{error, end_of_log}&lt;/code&gt; 如果尝试跳出日志，则会返回{错误，end_of_log}。</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">如果随后加载了一个新的模块实例(例如,由于纠错),前一个实例的代码将变成 &quot;旧的&quot;,所有指向前一个实例的导出条目将被删除。之后,新的实例会像第一次一样被加载,并成为 &quot;当前&quot;。</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">如果已经存在带有指定标识符的子规范， &lt;code&gt;ChildSpec&lt;/code&gt; 丢弃ChildSpec，并且该函数将根据相应的子进程是否在运行而返回 &lt;code&gt;{error,already_present}&lt;/code&gt; 或 &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果已经存在具有指定 &lt;code&gt;SupBridgeName&lt;/code&gt; 的进程，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果已经存在具有指定 &lt;code&gt;SupName&lt;/code&gt; 的进程，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">如果模块已经有当前代码，则该代码将保持当前状态，并且可以调用该代码，直到返回 &lt;code&gt;on_load&lt;/code&gt; 函数为止。如果 &lt;code&gt;on_load&lt;/code&gt; 函数失败，则当前代码（如果有）将保持最新。如果没有模块的当前代码，则在 &lt;code&gt;on_load&lt;/code&gt; 函数完成之前对模块进行外部调用的任何过程都将被挂起，直到 &lt;code&gt;on_load&lt;/code&gt; 函数完成。</target>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">如果存在排队事件，则使用最早的排队事件调用可能的新状态的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，然后从该列表的顶部重新开始。</target>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">如果在请求休眠时有排队事件要处理，则通过不休眠而是调用 &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; 来模拟 &lt;code&gt;gen_statem&lt;/code&gt; 进入休眠状态并立即被排队事件唤醒来优化此过程。</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">如果有多个modify_algorithms选项,结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">如果在迭代器没有更多的关联， &lt;code&gt;none&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">如果表中没有记录，则此函数返回原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。不建议将此原子用作任何用户记录的键。</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">如果表中没有记录，则此函数返回原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。因此，将原子作为任何用户记录的键是非常不希望的，但也是不允许的。</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">如果没有合适的对等体，或者如果 &lt;code&gt;pick_peer/4&lt;/code&gt; 次品他们通过返回 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;{error,no_connection}&lt;/code&gt; 被返回。否则， &lt;code&gt;pick_peer/4&lt;/code&gt; 之后是 &lt;code&gt;prepare_request/3&lt;/code&gt; 回调，对消息进行编码然后发送。</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果连接上有打开的NETCONF会话，这些会话将被残酷地中止。为避免这种情况，请使用 &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt; 关闭每个会话</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">如果驾驶员的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则仅减少驾驶员的参考计数，从而不再将呼叫者视为驾驶员的 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。有关使用场景，请参阅本模块开头的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">如果驾驶员的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则仅减少驾驶员的参考数量，从而不再将呼叫者视为 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。有关使用场景，请参阅本模块开头的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">如果有该驱动程序的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则该函数返回 &lt;code&gt;{error, pending_process}&lt;/code&gt; ，但是如果没有其他用户，该函数的调用将挂起，直到关闭所有打开的端口。</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">如果有两个活动的表副本,如果一个副本失败,所有信息仍然可用。在许多应用中,这可能是一个重要的属性。此外,如果一个表副本存在于两个特定的节点上,那么在其中任何一个节点上执行的应用程序都可以在不访问网络的情况下从表中读取数据。网络操作比本地操作慢得多,消耗的资源也多。</target>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果进程中没有任何异常，则stacktrace为 &lt;code&gt;[]&lt;/code&gt; 。在为该过程更改代码后，还可以将stacktrace重置为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">如果没有&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段，将选中&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 字段。所有 &lt;code&gt;CN&lt;/code&gt; 名称将与所有主机名进行比较</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">如果有一个 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段中， &lt;code&gt;{uri_id,string()}&lt;/code&gt; 在函数调用将被比作任何 &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; 在证书字段。如果两个 &lt;code&gt;strings()&lt;/code&gt; 相等（不区分大小写），则存在匹配项。这同样适用于任何 &lt;code&gt;{dns_id,string()}&lt;/code&gt; 在呼叫时，所有比较 &lt;code&gt;{dNSName,string()}&lt;/code&gt; 在证书字段。</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;List&lt;/code&gt; 存在一个 &lt;code&gt;Value&lt;/code&gt; ，使得 &lt;code&gt;Pred(Value)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则为第一个此类 &lt;code&gt;Value&lt;/code&gt; 返回 &lt;code&gt;{value, Value}&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">如果右边有匹配失败,回溯到 (*PRUNE)会导致它被触发,并采取其行动。永远不能回溯到(*COMMIT)。</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">如果文本中的某个地方出现了语法错误(比如上面第二个子句中缺少的分号),这允许Merl生成一个错误信息,指向源代码中的准确行。(只需记住将列表中的字符串用逗号隔开,否则Erlang会将这些字符串片段连接起来,就像它们是一个单一的字符串一样。)</target>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果套接字端口中缓冲了数据，则将尝试关闭套接字的操作推迟到该数据写入内核套接字发送缓冲区中为止。如果遇到任何错误，则关闭套接字，并在下一个 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 上返回 &lt;code&gt;{error, closed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">如果有一个以上同名的子模式,则使用最早的一个。</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">如果邮箱中没有匹配的信息,则立即发生超时。</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果没有具有正确保护序列的匹配模式，则会发生 &lt;code&gt;case_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">如果没有指定类型的公钥可用,那么相应的条目将被忽略。请注意,可用集取决于底层的密码库和当前用户的公钥。</target>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">如果在 &lt;code&gt;Handler1&lt;/code&gt; 和进程 &lt;code&gt;Pid&lt;/code&gt; 之间存在监督连接，则在 &lt;code&gt;Handler2&lt;/code&gt; 和 &lt;code&gt;Pid&lt;/code&gt; 之间存在监督连接。</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">如果 &lt;code&gt;lists:reverse/1&lt;/code&gt; 中存在一些错误，当它以 &lt;code&gt;[1,2]&lt;/code&gt; 作为输入时使它返回 &lt;code&gt;[2,1]&lt;/code&gt; 以外的内容，那么上面的最后一个测试将引发不 &lt;code&gt;badmatch&lt;/code&gt; 错误。前两个（我们假设它们没有出现不 &lt;code&gt;badmatch&lt;/code&gt; ）将分别简单地返回 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;[1]&lt;/code&gt; ，因此都成功。 （请注意，EUnit不是出于心理考虑：如果编写的测试返回一个值，即使它是错误的值，EUnit也会认为它是成功的。结果不是应该的。）</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">如果不满足这些要求,系统可能会表现得非常糟糕。</target>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">如果没有指定这个属性,版本默认为模块的MD5校验和。</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">如果此回调已导出但失败，以隐藏可能的敏感数据，则默认函数将返回 &lt;code&gt;{State,Info}&lt;/code&gt; ，其中 &lt;code&gt;Info&lt;/code&gt; 仅表示 &lt;code&gt;format_status/2&lt;/code&gt; 崩溃的事实。</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">如果设置了这个配置参数,它就会取代默认的报表回调,以及元数据中发现的任何报表回调。也就是说,所有的报表都会被这个配置函数所转换。</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">如果这在你的系统上不起作用,文档会以HTML的形式包含在Erlang/OTP版本中。你也可以从 www.erlang.se (商业版 Erlang)或 www.erlang.org (开源版)阅读 HTML 文档或下载 PDF 文档。例如,对于Erlang/OTP版本R9B。</target>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">如果存在此标志，则 &lt;code&gt;global&lt;/code&gt; 不会维护分布式Erlang节点的完全连接的网络，因此无法使用全局名称注册；参见 &lt;code&gt;global(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置了此标志，则当有错误时，将返回 &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">如果设置了此标志，则出现错误时将返回 &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置了此标志，则将包含 &lt;code&gt;Warnings&lt;/code&gt; 的额外字段添加到成功返回的元组中。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">如果设置了此标志，则将一个包含 &lt;code&gt;WarningList&lt;/code&gt; 的额外字段添加到成功返回的元组中。</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">这个函数是否被调用是由前面调用handle_trans_request/3的回复控制的。handle_trans_request/3函数可以决定自己处理动作请求,也可以将处理工作委托给这个函数。</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">这个函数是否被调用,由前面调用handle_trans_request/3的响应控制。handle_trans_request/3函数可能会决定返回{handle_ack,ack_data()}或{handle_sloppy_ack,ack_data()},意思是你需要一个立即确认的回复,这个函数应该被调用来处理这个确认。</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">如果调用此函数，则只能调用一次，并且必须在调用 &lt;code&gt;ei&lt;/code&gt; 库中的任何其他函数之前调用它。</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调用此函数，则只能在调用函数 &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; 之后直接调用一次。</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">如果调用此函数，则将使用 &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 作为第一个参数再次调用它。</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">如果这个函数没有被调用,启动函数会返回一个错误元组(如果使用了链接和/或超时),否则就会挂起。</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">如果此函数返回的下一个状态与当前状态不相等（ &lt;code&gt;=/=&lt;/code&gt; ），则所有延迟事件将在下一个状态中重试。</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">如果这个函数的主体没有返回一个内联常量值,那么回调模块正在做一些奇怪的事情。</target>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">如果这是个问题;要生成一个布尔值,使用类似这样的方法。</target>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">如果定义了这个宏,它就会覆盖NOASSERT宏,迫使断言宏始终处于启用状态,而不考虑其他设置。</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">如果定义了这个宏,它就会覆盖NODEBUG宏,强制启用调试宏。</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">如果定义了此宏，则在禁用测试的情况下，断言宏将无效。请参见声明 &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; 。启用测试后，断言宏始终自动启用，不能禁用。</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">如果定义了这个宏,测试功能的自动导出或剥离将被禁用。</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">如果定义了此宏，则调试宏将无效。请参阅 &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 。除非启用了测试，否则 &lt;code&gt;NODEBUG&lt;/code&gt; 也暗含 &lt;code&gt;NOASSERT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">如果存在此选项，则表数据将以更紧凑的格式存储，以消耗更少的内存。但是，这会使表操作变慢。尤其是需要检查整个对象的操作，例如 &lt;code&gt;match&lt;/code&gt; 和 &lt;code&gt;select&lt;/code&gt; ，速度会慢很多。关键元素未压缩。</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">如果存在此选项，则表将在其 &lt;code&gt;Name&lt;/code&gt; 下注册，然后可在后续操作中使用该表而不是表标识符。</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">如果设置了此选项，则模式中的大多数空白字符都将被完全忽略，除非进行转义或在字符类内部。但是，不允许在诸如 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 这样的序列中引入空白，该序列会引入各种带括号的子模式，也不允许在数字量词诸如 &lt;code&gt;{1,3}&lt;/code&gt; 之内。但是，在项目与后续量词之间以及在量词和以下+表示所有格。</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">如果此选项作为 &lt;code&gt;-compile&lt;/code&gt; 指令写在源代码中，则可以使用语法 &lt;code&gt;F/A&lt;/code&gt; 代替 &lt;code&gt;{F,A}&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">如果未指定此参数，则除非设置了环境变量 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; ，否则它将默认为 &lt;code&gt;/etc/hosts&lt;/code&gt; ，该环境变量将该文件的目录定义为 &lt;code&gt;/etc&lt;/code&gt; 以外的其他目录。</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">如果未指定此参数，则除非设置了环境变量 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; ，否则它将默认为 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; ，该环境变量将该文件的目录定义为 &lt;code&gt;/etc&lt;/code&gt; 以外的其他目录。</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">如果这个模式被嵌入到一个更大的模式中,可以使用一个相对引用。</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">如果定义了此属性，则 &lt;code&gt;Inets&lt;/code&gt; 希望找到此文件中定义的所有其他属性，这些文件使用类似Apache的语法。该文件必须包括在强制属性下列出的所有属性。类似于Apache的语法是属性，写为一个单词，其中每个新单词都以大写字母开头，后跟空白，然后是值，然后是新行。</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">如果定义了此属性，则 &lt;code&gt;Inets&lt;/code&gt; 希望找到此文件中定义的所有其他属性。该文件必须包括在强制属性下列出的所有属性。</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">如果这种情况不能接受,可以用这个函数来覆盖Mnesia表加载算法的策略。这可能会导致一些事务效果丢失的情况,结果是数据库不一致,但对于某些应用来说,高可用性比数据一致更重要。</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">如果这个值为false,那么当加载一个mib时,每个mib-条目都会在安装mib之前被检查。检查的目的是为了防止相同的符号mibentry名称被用于不同的id。</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">如果这个值为false,那么当加载一个mib时,每个陷阱都会在安装mib之前被检查。检查的目的是为了防止相同的符号陷阱名被用于不同的陷阱。</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">如果这是更大的模式的一部分,你就不希望将整个模式递归,所以你可以使用。</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">如果禁用了时间校正,二郎单调时间就会向前翘起或停止,甚至长时间冻结。那么就不能保证二郎单调时钟的频率是准确的或稳定的。</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">如果禁用了时间校正,如果OS系统时间向前跃进,则Erlang单调时间向前跃进。如果OS系统时间向后跃迁,则Erlang单调时间会短暂停止,但不会长时间冻结。这是因为改变了时间偏移,使Erlang系统时间与OS系统时间一致。</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果禁用了时间校正，则OS系统时间的更改会像使用 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 时一样影响单调时钟。</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">如果启用了时间校正，则将对Erlang单调时钟进行调整，以使其频率尽可能保持正确。但是，在尝试调整Erlang系统时间和OS系统时间时，&lt;strong&gt;没有&lt;/strong&gt;进行&lt;strong&gt;任何&lt;/strong&gt;调整。也就是说，在预备阶段，Erlang系统时间和OS系统时间可能会彼此偏离，因此未尝试阻止此情况。</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">如果启用了时间校正，则Erlang运行时系统将同时使用 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 来调整Erlang单调时钟的频率。时间校正可确保 &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 不会扭曲，并且频率相对准确。频率调整的类型取决于所使用的时间扭曲模式。部分 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; 提供了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">如果没有启用时间校正,当操作系统的时间向后跳跃时,Erlang的单调时间就会冻结。单调时间的冻结会一直持续到OS系统时间追上为止。冻结可以持续很长时间。当OS系统时间向前跳动时,Erlang单调时间也会向前跳动。</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">如果开启了跟踪模式,这将告诉ODBC驱动将跟踪日志写到文件SQL.LOG中,该文件被放置在erlang模拟器的当前目录下。如果你怀疑erlang的ODBC程序中存在bug,那么这些信息可能会很有用,你可以把这个文件发送给我们的支持人员。否则你可能不会有什么用处。</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">如果跟踪可以为启用 &lt;code&gt;P&lt;/code&gt; 和所有进程 &lt;code&gt;Rootset&lt;/code&gt; ，该函数返回 &lt;code&gt;{ok,Value}&lt;/code&gt; 当 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 与价值回报 &lt;code&gt;Value&lt;/code&gt; ，或 &lt;code&gt;{error,Reason}&lt;/code&gt; 如果 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 失败，退出原因 &lt;code&gt;Reason&lt;/code&gt; 。否则，它将立即返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">如果为真,使用服务器的ECC曲线选择偏好。如果为false(默认值),则使用客户端的偏好。</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">如果为真,则使用服务器的偏好来选择密码。如果为false(默认),则使用客户端的偏好。</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">如果指定了两个 &lt;code&gt;Dates&lt;/code&gt; ，则返回在这些日期之间发生的报告。</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">如果声明了两个匹配键,则后一个键优先。</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">如果两个进程通过给出相同的名称和参数打开同一个表,那么这个表就有两个用户。如果一个用户关闭了该表,那么在第二个用户关闭该表之前,该表一直是开放的。</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">如果两个进程同时执行 &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; ，则两个更新都将生效，而不会丢失其中一个更新。返回计数器的新值 &lt;code&gt;NewVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在后卫的顶层使用，它将测试参数是否为浮点数；为了清楚起见，请改用 &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">如果打开了验证，并且使用选项 &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; 写入了文件，则读取文件的速度较慢，并且从根本上消耗更多的CPU时间。</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">如果打开了警告（ &lt;code&gt;report_warnings&lt;/code&gt; 介绍了选项report_warnings），则以下选项控制生成的警告类型。除了 &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; 以外，以下选项具有两种形式：</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">如果我们已连接（并且连接句柄不是 &lt;code&gt;NULL&lt;/code&gt; ），则从数据库中注销。我们需要检查是否应该对 &lt;code&gt;'ok'&lt;/code&gt; 进行编码，因为我们可以从函数 &lt;code&gt;stop&lt;/code&gt; 获得此处，该函数不会将数据返回给仿真器：</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">如果我们不是安全级别的 &lt;code&gt;noAuthNoPriv&lt;/code&gt; ，这可能会很复杂，因为代理将继续进行阶段2，在此之前必须完成与usm相关的更新。</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">如果未连接，则等待 &lt;code&gt;PQsendQuery&lt;/code&gt; 的结果，因此我们获取结果并将其返回。编码使用与先前示例相同的功能完成。</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">如果我们确定这种情况不会发生,我们可以将涉及的模块指定为 &quot;安全&quot;,它们之间的所有调用都将变成本地调用。需要注意的是,如果目标模块本身被指定为安全模块,那么对它本身的 &quot;远程 &quot;调用将变成本地调用。这将破坏典型服务器循环等的代码替换属性。</target>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">如果我们有一个连接结果（表示 &lt;code&gt;x&lt;/code&gt; 缓冲区中有数据），则不再需要在输出（ &lt;code&gt;ready_output&lt;/code&gt; ）上进行选择，因此可以通过调用 &lt;code&gt;driver_select&lt;/code&gt; 来删除它。</target>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">如果现在将过滤器添加到正在运行的 &lt;code&gt;Collector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">如果现在我们从节点 &lt;code&gt;ant@stack&lt;/code&gt; 上的外壳发送消息，则跟踪从外壳发送的所有消息：</target>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">如果我们像这样运行它： &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; 结果将是 &lt;code&gt;result_xs.html&lt;/code&gt; 。当输入文件的结构与先前的&amp;ldquo;摩托车&amp;rdquo; XML文件的结构相同，但是输入文件中的&amp;ldquo;自行车&amp;rdquo;元素更多，而&amp;ldquo;制造商&amp;rdquo;元素则没有顺序。</target>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">如果x &lt;code&gt;F&lt;/code&gt; y和y &lt;code&gt;F&lt;/code&gt; x，则x = y（ &lt;code&gt;F&lt;/code&gt; 是反对称的）。</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">如果x &lt;code&gt;F&lt;/code&gt; y和y &lt;code&gt;F&lt;/code&gt; z，则x &lt;code&gt;F&lt;/code&gt; z（ &lt;code&gt;F&lt;/code&gt; 是可传递的）。</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">如果x是一个从I到X的族,那么x[i]表示函数在索引i处的值,这样的族用 &quot;X中的一个族 &quot;的记号。</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">如果x是X的子集族，则x范围的并集称为x &lt;strong&gt;族&lt;/strong&gt;的&lt;strong&gt;并集&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">如果x为非空（索引集为非空），&lt;strong&gt;则族&lt;/strong&gt; x的交集为x范围的交集。</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">如果&lt;strong&gt;必须&lt;/strong&gt;返回存储在Ets表中的所有数据，则可以使用 &lt;code&gt;ets:tab2list/1&lt;/code&gt; 。但是，通常您只对信息的子集感兴趣，在这种情况下， &lt;code&gt;ets:tab2list/1&lt;/code&gt; 是昂贵的。如果只想从每条记录中提取一个字段，例如每个人的年龄，则：</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">如果要从git构建Erlang / OTP，则需要运行 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 来生成配置脚本。</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">如果你正在构建一个64位版本的Erlang,你应该用不同的方式设置PATHs等。我们有两个模板可以在Cygwin和MSYS中工作,但需要编辑以在MSYS2中工作(见脚本中的注释)。以下是32位的模板。</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">如果要构建64位版本，请为 &lt;code&gt;otp_build&lt;/code&gt; 提供一个体系结构参数：</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">如果要在 &lt;code&gt;git&lt;/code&gt; 中构建，则首先需要生成 &lt;code&gt;configure&lt;/code&gt; 脚本：</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">如果要在Git中进行构建，则在继续操作之前，请先阅读 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 进行构建&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">如果你要发布你的应用程序的源代码供其他人编译和运行,你可能要确保代码在EUnit不可用的情况下也能编译。就像上一节的例子一样,你可以在一个普通的头文件中加入以下几行。</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">如果你在时间偏移可能发生变化的模式下执行,而你想得到事件发生时实际的Erlang系统时间,你可以将时间偏移保存为元组中的第三个元素(比较三个元组时最不重要的元素)。</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">如果你要建立一个64位的Windows版本,你应该确保安装MinGW的64位gcc与Cygwin。它在一个开发包中。</target>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">如果您对事件发生时的Erlang系统时间感兴趣，还可以使用 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 保存事件之前或之后的时间偏移。加上时间偏移量的Erlang单调时间对应于Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">如果您不熟悉Cygwin，MSYS，MSYS2或Unix环境，则可能需要阅读一些有关其工作原理的信息。在线上有很多关于此的文档。</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">如果你不确定操作系统的时间是否正确,为了安全起见,在启动Erlang运行系统之前,将其设置为一个保证比实际POSIX时间早的时间。</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">如果你只对所有名叫 &quot;Bryan &quot;的人的年龄感兴趣,那么:</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">如果你运行在支持HiPE的平台上,如果你没有禁用HiPE,你可以在Erlang shell中把一个模块编译成这样的本地代码。</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要测试分布式Erlang应用程序，则可能要在代码覆盖率分析中包含的代码在另一个Erlang节点上执行，而不是在运行&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 情况下。如果是这样，则必须在Cover Specification文件中指定这些其他节点，或将它们动态添加到节点的代码覆盖集。有关后者的详细信息，请参见模块 &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">如果你不确定自己是否正确释放了条款,可以使用以下函数查看固定条款分配器的状态。</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果可以编辑和重新编译源代码，则在要分析的代码之前和之后插入 &lt;code&gt;fprof:trace(start)&lt;/code&gt; 和 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 会很方便。还跟踪所有产生的过程。如果要使用默认 &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; 以外的其他文件名，请尝试fprof：trace（start，&amp;ldquo; my_fprof.trace&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">如果将此函数的捕获异常与 &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; 结合使用，以避免调用超时而导致调用进程死亡，则必须准备好处理较晚的答复。请注意，即使在出现网络问题的情况下，即使使用 &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; 或 &lt;code&gt;infinity&lt;/code&gt; ，也有可能获得延迟答复。那么，为什么不通过不捕获异常而让调用过程终止呢？</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">如果你的代码比较，你会看到有也是 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 被称为只能从 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 和本身，而只调用 &lt;code&gt;file:write/2&lt;/code&gt; ，注意呼叫的号码 &lt;code&gt;file:write/2&lt;/code&gt; 。但是在这里我们看到 &lt;code&gt;suspend&lt;/code&gt; 被调用了几次。这是一个伪函数，表示在 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 中执行时进程已挂起，并且由于代码中没有 &lt;code&gt;receive&lt;/code&gt; 或 &lt;code&gt;erlang:yield/0&lt;/code&gt; ，因此它必须是Erlang调度挂起，或者跟踪文件驱动程序正在补偿适用于大文件写入操作（这些被视为调度，然后是同一进程的调度）。</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">如果使用以下命令进行编译，则结果将是一个合并的模块 &lt;code&gt;MyModule.erl&lt;/code&gt; ，其中包含根据三个ASN.1规范生成的代码：</target>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">如果您决定根本不运行测试用例，请返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 。然后将 &lt;code&gt;Reason&lt;/code&gt; 打印在HTML结果页面上的字段 &lt;code&gt;Comment&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">如果您开发链接驱动程序（共享库），则需要使用 &lt;code&gt;gcc&lt;/code&gt; 和标志 &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; 进行链接。编译时，还将在 &lt;code&gt;CFLAGS&lt;/code&gt; 中包括 &lt;code&gt;-fno-common&lt;/code&gt; 。使用 &lt;code&gt;.so&lt;/code&gt; 作为库后缀。</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">如果您没有文件内容的完整二进制文件，则可以对文件进行分块并进行逐部分检查。函数 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 的返回元组 &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; 很方便。从文件中读取的一个数据块的剩余部分不完整，将被添加到下一个块中，因此，当以UTF-8编码读取字节块时，我们避免了字符边界的问题：</target>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">如果您不需要在NIF调用之间重新分配数据或使数据保持活动状态，请考虑使用 &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; ,因为它会在可能的情况下在进程堆上分配小的二进制文件。</target>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">如果你不使用X-windows,你可能想通过在控制台系统菜单中选择属性来设置Windows控制台窗口(窗口的左上角,标题栏中的Cygwin图标)。特别是设置一个较大的屏幕缓冲区大小(行)是很有用的,因为它可以让你得到一个滚动条,这样你就可以看到任何可能出现的错误信息。</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">如果您明确希望在参数向量中设置程序名称，则可以使用选项 &lt;code&gt;arg0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">如果在让仿真器线程脱离你的控制之前,你没有清除它的特定线程数据,你可能永远无法清除这些数据,以后系统的其他部分会因此出现意外错误。</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">如果您对环境和构建系统感到满意，并且拥有所有必需的工具，那么您就有很大的机会使Windows的Erlang / OTP发行版更好。请向 &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; 提交任何建议，并向 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; 提交补丁，以使他们找到进入下一版Erlang的方式。如果要对构建系统进行更改（例如makefile等），请记住，在Unix / VxWorks上使用了相同的makefile，以使您的更改不会破坏其他平台。当然，这也适用于C代码。系统特定的代码主要位于 &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; 目录中。在 &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; 目录是通用代码。</target>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">如果你经常对一个不是表的键的字段进行查找,那么使用 &quot;mnesia:select/match_object &quot;就会损失性能,因为这个函数会遍历整个表。你可以创建一个二级索引来代替,并使用 &quot;mnesia:index_read &quot;来获得更快的访问速度,然而这需要更多的内存。</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">如果获得了 &lt;code&gt;ssh_decode/2&lt;/code&gt; 返回的公共密钥 &lt;code&gt;PubKey&lt;/code&gt; 和相关的属性 &lt;code&gt;Attributes&lt;/code&gt; 列表，则可以创建一个新的SSH文件，例如：</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">如果您破解了模拟器，则可以通过站在 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 来构建模拟器可执行文件，并执行一个简单的操作</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">如果您使用的是Xcode 4.3或更高版本,您还需要通过Xcode的下载偏好面板下载 &quot;命令行工具&quot;。</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">如果您有一个列表列表 &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; ，则可以将 &lt;code&gt;L&lt;/code&gt; 中所有字符串的长度求和，如下所示：</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">如上所述，如果已将声明 &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; 到模块中，则只需编译模块，然后运行自动导出的函数 &lt;code&gt;test()&lt;/code&gt; 即可。例如，如果您的模块名为 &lt;code&gt;m&lt;/code&gt; ，则调用 &lt;code&gt;m:test()&lt;/code&gt; 将在模块中定义的所有测试上运行EUnit。您无需为测试功能编写 &lt;code&gt;-export&lt;/code&gt; 声明。这一切都是由魔术完成的。</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">如果已使用 &lt;code&gt;install&lt;/code&gt; 目标安装了Erlang / OTP ，请使用 &lt;code&gt;install-docs&lt;/code&gt; 目标安装文档。将使用由 &lt;code&gt;configure&lt;/code&gt; 确定的安装位置。 &lt;code&gt;$DESTDIR&lt;/code&gt; 使用方式与 &lt;code&gt;make install&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">如果已使用 &lt;code&gt;release&lt;/code&gt; 目标安装了Erlang / OTP，则使用发行版 &lt;code&gt;release_docs&lt;/code&gt; 目标安装文档。通常，您希望使用与调用 &lt;code&gt;make release&lt;/code&gt; 相同的 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">如果你在OTP安装中安装了文档,也要建立文档。</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">如果您刚刚在当前源代码树中构建了Erlang / OTP，则您已经运行了 &lt;code&gt;configure&lt;/code&gt; ，因此无需再次执行此操作。否则，运行 &lt;code&gt;configure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">如果您在一个节点中有许多服务器，并且它们在生命周期中处于某些状态（可以预期服务器空闲一会儿），并且所有这些服务器所需的堆内存量是个问题，那么内存占用量可以通过 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 使其休眠，以最小化服务器的数量。</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">如果您有一个函数可以执行要分析的任务，并且该函数在分析应停止时返回，则可以使用 &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; 并将其用于跟踪步骤。</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">如果您具有公共密钥数据并想要创建PEM文件，则可以通过调用函数 &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; 和 &lt;code&gt;pem_encode/1&lt;/code&gt; 并将结果保存到文件中来完成。例如，假设您具有 &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; 。然后，您可以创建一个PEM-&amp;ldquo; RSA PUBLIC KEY&amp;rdquo;文件（ASN.1类型为 &lt;code&gt;'RSAPublicKey'&lt;/code&gt; RSAPublicKey&amp;rdquo;）或一个PEM-&amp;ldquo; PUBLIC KEY&amp;rdquo;文件（ &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1类型）。</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">如果您具有既不依赖于文件位置也不依赖于站点的系统配置数据，则尽早创建 &lt;code&gt;sys.config&lt;/code&gt; 可能很方便，因此它成为 &lt;code&gt;target_system:create/1&lt;/code&gt; 创建的目标系统tar文件的一部分。实际上，如果您在当前目录中不仅创建文件 &lt;code&gt;mysystem.rel&lt;/code&gt; ，还创建文件 &lt;code&gt;sys.config&lt;/code&gt; ，则将后一个文件默认放置在适当的目录中。</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">如果您在文件中具有交叉编译配置，请使用 &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; 命令行参数传递它。如果不是，请在命令行上使用 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 语法传递 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; ，-- &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 和配置变量（与（3）中相同）。注意， &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; 必须以一种方式传递。通过在配置文件中使用 &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; ，或使用 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 命令行参数。</target>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">例如，如果您使用 &lt;code&gt;gen_statem&lt;/code&gt; ，将一个事件推迟到一个状态，然后再调用您的另一个状态回调，则您尚未更改状态，因此不会重试被推迟的事件，这是合乎逻辑的，但可能会造成混淆。</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果您改为以字符串形式接收XML文档，则可以通过 &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; 对其进行解析。file / 2和string / 2都存在，其中第二个参数是解析器的选项列表，请参见 &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">如果您知道返回的二进制文件总是很小，建议您使用不需要预分配二进制文件的驱动程序API调用，例如使用 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 格式的 &lt;code&gt;driver_output()&lt;/code&gt; 或 &lt;code&gt;erl_drv_output_term()&lt;/code&gt; 来允许运行时构造一个堆二进制文件。</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">如果您知道 &lt;code&gt;escript&lt;/code&gt; 可执行文件的位置，则第一行可以直接提供 &lt;code&gt;escript&lt;/code&gt; 的路径，例如：</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">如果在让线程退出控件时将互斥锁锁定在仿真器线程中，则&lt;strong&gt;很可能会&lt;/strong&gt;死锁整个仿真器。</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">如果在让线程脱离控制时将rwlock锁定在仿真器线程中，则&lt;strong&gt;很可能会&lt;/strong&gt;死锁整个仿真器。</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">如果必须与USTAR tar格式保持兼容，则必须确保存储的文件路径总共少于255个字节，文件名组件的最大长度为100个字节。 USTAR除了名称字段外，还使用头字段（前缀），并将长度超过100字节的文件路径分为两部分。这种拆分是在目录边界上进行的，并且以充分利用这两个字段中可用空间的方式进行，但是实际上，这通常意味着路径少于255个字节。 &lt;code&gt;erl_tar&lt;/code&gt; 将自动将格式升级为PAX以处理更长的文件名，因此，仅当您需要使用较旧的 &lt;code&gt;erl_tar&lt;/code&gt; 或 &lt;code&gt;tar&lt;/code&gt; 实现提取档案文件时，这才是问题。不支持PAX。在这种情况下，PAX标头将被提取为常规文件，您将需要手动应用它们。</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">如果你需要所有存储在Ets表中的名为 &quot;Bryan &quot;的人的信息,那么:</target>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">如果您需要使用Erlang ODBC接口从erlang应用程序访问诸如 &lt;code&gt;sqlserver&lt;/code&gt; ， &lt;code&gt;mysql&lt;/code&gt; ， &lt;code&gt;postgres&lt;/code&gt; ， &lt;code&gt;oracle&lt;/code&gt; ， &lt;code&gt;cybase&lt;/code&gt; 等关系数据库，则是解决该问题的好方法。</target>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">如果由于其他事件需要取消计时器，可以使用 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 。请注意，除非您之前已将超时消息推迟（请参阅下一节），否则超时消息将无法在此之后到达，因此请确保不要意外地推迟此类消息。还要注意，超时消息可能在取消之前就已到达，因此您可能必须根据 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 的返回值从进程邮箱中读取此类消息。</target>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">如果需要执行配置操作以运行测试，则可以在套件中实现配置功能。配置功能的结果是配置数据或 &lt;code&gt;Config&lt;/code&gt; 。这是键值元组的列表，这些键值元组从配置函数传递到测试用例（可能通过&amp;ldquo;较低级别&amp;rdquo;的配置函数）。数据流如下所示：</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">如果需要使用 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; Erlang代码，并且需要在更正OS系统时间之前启动Erlang运行时系统，则可能要使用单一时间扭曲模式。</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">如果你需要在仿真器线程中使用线程专用数据,只有在线程在你的控制下时才有线程专用数据集,在让线程脱离你的控制之前清除线程专用数据。</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">如果需要验证引导程序束文件是否与提供的源文件匹配，请使用 &lt;code&gt;./otp_build update_primary&lt;/code&gt; 创建一个包含差异（如果存在）的新提交。</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">如果您或您的系统有特殊要求，请阅读 &lt;code&gt;Makefile&lt;/code&gt; 以获取其他配置信息。</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">如果您打算在不重新启动系统的情况下更改代码，则必须使用外部fun（ &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ）作为 &lt;code&gt;Resolve&lt;/code&gt; 函数。如果您使用本地娱乐，则永远无法替换该娱乐所属模块的代码。</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 读回选项值，但未获取任何值，则该选项在主机操作系统中不存在。IPv6和IPv4套接字在同一端口上侦听的行为以及获取IPv4流量的IPv6套接字的行为不再可预测。</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">如果你真的,真的想,你可以叫它 &quot;英嘉&quot;。</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">如果设置了 &lt;code&gt;call&lt;/code&gt; 跟踪标志，则还必须为要&lt;strong&gt;跟踪&lt;/strong&gt;的功能设置&lt;strong&gt;跟踪模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">如果只想格式化纯文本的段落，则可能要使用 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 函数，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">如果使用 &lt;code&gt;code_lock:start([17])&lt;/code&gt; 启动此程序，则可以使用 &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt; 解锁。</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">如果您成功通过以下方式对XML文件进行了验证： &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; ,则您知道XML文档是有效的，并且具有符合DTD的结构。</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">如果你试图对另一个城市再次进行同样的操作,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">如果您试图在注册表中存储一个对象,而现有的对象具有相同的键,则新的值将取代旧的对象。无论新对象和旧对象是否具有相同的类型,都会这样做,因此,例如,您可以用整数替换字符串。如果现有的值是字符串或二进制,那么在分配新的值之前,它将被释放。</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">如果您使用 &lt;code&gt;erl_connect_init()&lt;/code&gt; ，则您的节点将具有简称，即它不是完全合格的。如果需要使用完全限定的（长）名称，请改用 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;systools&lt;/code&gt; （用于打包代码的Erlang / OTP工具）（请参见 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ），则每个应用程序的代码将按照预定义的 &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; 放在单独的目录中。</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">如果你使用的是一个老式的类似apace的配置文件。</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">如果使用多个CTH，则返回元组的第一部分用作下一个CTH的输入。因此，在前面的示例中，下一个CTH可以将 &lt;code&gt;{fail,Reason}&lt;/code&gt; 作为第二个参数。如果有多个CTH交互，请不要让每个CTH返回 &lt;code&gt;fail&lt;/code&gt; 或 &lt;code&gt;skip&lt;/code&gt; 。相反，通过 &lt;code&gt;Config&lt;/code&gt; 列表返回要执行的操作，并实现CTH，最后执行正确的操作。</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">如果您在基于POSIX线程或Solaris线程的线程应用程序中使用 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数，则 &lt;code&gt;Erl_Interface&lt;/code&gt; 需要访问您的线程包中的某些同步工具。您必须指定额外的编译器标志，以指示您使用哪个软件包。定义 &lt;code&gt;_REENTRANT&lt;/code&gt; 以及 &lt;code&gt;STHREADS&lt;/code&gt; 或 &lt;code&gt;PTHREADS&lt;/code&gt; 。如果指定了 &lt;code&gt;_REENTRANT&lt;/code&gt; ,则默认值为使用POSIX线程。</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;ct_run&lt;/code&gt; 程序，则可以使用标志 &lt;code&gt;-shell&lt;/code&gt; 以及标志 &lt;code&gt;-config&lt;/code&gt; 和/或 &lt;code&gt;-userconfig&lt;/code&gt; 一次性启动Erlang Shell和 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">如果您希望Erlang节点从一开始就激活一个远程作业（而不是默认的本地作业），请使用 &lt;code&gt;-remsh&lt;/code&gt; 标志启动Erlang ，例如， &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">如果只想将连接与 &lt;code&gt;Handle&lt;/code&gt; 关联（例如，如果您需要打开一个主机的多个连接），则使用 &lt;code&gt;Key&lt;/code&gt; （配置变量名称）来指定目标。请注意，没有关联目标名称的连接只能使用 &lt;code&gt;Handle&lt;/code&gt; 值关闭。</target>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要使用与 &lt;code&gt;erlang:now/0&lt;/code&gt; 返回的格式相同的格式，请使用 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">如果你想在motorcycles.xml文档中添加2003年的黑色哈雷Davidsson 1200 cc Sportster摩托车的信息,它的形状和新的一样,你可以把数据放在一个简单形式的数据结构中,比如。</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">如果你想应用多个OTP应用程序的补丁,并驻留在不同的OTP版本中,你必须分步应用这些补丁。只有在同一个OTP版本中,才有可能一次应用多个OTP应用程序的补丁。</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">如果要构建 &lt;code&gt;wx&lt;/code&gt; 应用程序，则需要从 &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; 获得wxWidgets-3.0（ &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; 3.0.3.tar.bz2）或通过错误修复从github获取：</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">如果要在 &lt;code&gt;$PATH&lt;/code&gt; 使用兼容的Erlang / OTP系统进行构建，请跳至（3）。</target>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">如果你想把一个新建立的库(应用程序)复制到一个发布区,你可以像模拟器那样做。</target>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">如果你想在模式中的某一点强制匹配失败,最方便的方法是用(?!),因为空字符串总是匹配。所以,一个要求不存在空字符串的断言必须总是失败。回溯控制动词(*FAIL)或(*F)是(?!)的同义词。</target>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">如果要忽略当前状态下的特定事件并在将来的状态下处理该事件，则可以推迟该事件。状态更改（即， &lt;code&gt;OldState =/= NewState&lt;/code&gt; 更改后，重试延迟的事件。</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">如果要限制跟踪日志的大小，则可以使用自动换行日志。这几乎就像循环缓冲区一样工作。您可以指定二进制日志的最大数量以及每个日志的最大大小。 &lt;code&gt;ttb&lt;/code&gt; 然后在每次日志达到最大大小时创建一个新的二进制日志。当达到最大日志数时，将删除最早的日志，然后再创建新的日志。</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">如果要匹配典型的词组,模式必须忽略所有非单词字符,可以按以下方法进行。</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">如果你想只打印每个线程类型的运行时间,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">如果要输出XML元素或属性的内容，则可以通过 &lt;code&gt;value_of&lt;/code&gt; 函数将值作为字符串获取：</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">如果你想解析XML文件motorcycles.xml,你可以在Erlang shell中运行它,比如。</target>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">如果你想传递一个二进制文件，还没有二进制的一个内容 &lt;code&gt;ErlDrvBinary&lt;/code&gt; ，您可以使用受益 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; ，而不是创建一个 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 然后通过传递二进制 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 。如果使用 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; ,则运行时系统通常会更智能地分配二进制文件。但是，如果要传递的二进制文件的内容已经位于 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 中，则通常最好使用所 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 和 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 传递二进制文件。</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果要将测试代码与常规代码分开（至少用于测试导出的函数），则可以简单地将测试函数编写在名为 &lt;code&gt;m_tests&lt;/code&gt; 的模块中（注意：不是 &lt;code&gt;m_test&lt;/code&gt; ）（如果模块名为 &lt;code&gt;m&lt;/code&gt; )。然后，每当您要求EUnit测试模块 &lt;code&gt;m&lt;/code&gt; 时，它也会寻找模块 &lt;code&gt;m_tests&lt;/code&gt; 并运行这些测试。有关详细信息，请参见&amp;ldquo;基 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分中的 &lt;code&gt;ModuleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">如果你想定制你的Erlang/OTP构建和安装,请继续阅读关于各个步骤的详细信息。</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">如果要跟踪函数调用（即，如果在任何进程上都设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; ），则还必须使用 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; 在所需的函数上设置跟踪模式。/ 2,3,4。只有具有跟踪模式的函数才能被跟踪。跟踪模式指定如何使用匹配规范来跟踪功能。比赛规格在《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果要改为将系统日志打印到文件中，则必须配置默认处理程序来这样做。最简单的方法是在 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; 中包括以下内容：</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">如果您希望退出交互模式（例如，使用 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 启动自动化测试运行），请调用函数 &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; 。这将关闭正在运行的 &lt;code&gt;ct&lt;/code&gt; 应用程序。因此，将删除配置名称与使用 &lt;code&gt;require&lt;/code&gt; 创建的数据之间的关联。函数 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 将您带回到交互模式，但不会恢复以前的状态。</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">如果你希望一个任意指针存储在注册表中，指定 &lt;code&gt;size&lt;/code&gt; 的 &lt;code&gt;0&lt;/code&gt; 。在这种情况下，对象本身不会通过 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 操作进行传输，而仅通过指针值进行传输。</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">如果你无法在键盘上产生回拨,你可以使用ksh变体。</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">如果您使用的是MinGW的MSYS，则需要更改 &lt;code&gt;C_DRV&lt;/code&gt; 设置，其内容为：</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">如果您已使用补丁程序升级了源代码，则可能需要在新版本之前从以前的版本中清除。在进行 &lt;code&gt;make clean&lt;/code&gt; 之前，请确保阅读下面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">如果您的应用程序有多个级别的监督,那么不要简单地将所有级别的重启强度设置为相同的值。请记住,重启的总次数(在顶层监督者放弃并终止应用程序之前)将是失败的子程序上面所有监督者的强度值的乘积。</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">如果你的驱动支持可滚动的光标,你就有更多的自由,可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">如果您的过程逻辑可以方便地描述为状态机，并且您想要以下任何 &lt;code&gt;gen_statem&lt;/code&gt; 关键功能，则：</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">如果您的测试代码写入标准输出，则可能会惊讶地发现，在运行测试时，文本未出现在控制台上。这是因为EUnit会捕获测试功能的所有标准输出（这也包括设置和清除功能，但不包括生成器功能），以便在发生错误时将其包含在测试报告中。要在测试过程中绕过EUnit并直接在控制台中打印文本，可以像 &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; 一样写入 &lt;code&gt;user&lt;/code&gt; 输出流。推荐的方法是使用EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; ，这使它更加简单。</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">例如，如果仅对源自UNIX内核的信息进行监督，则该行将从 &lt;code&gt;kern.LEVEL&lt;/code&gt; 开头。有关 &lt;code&gt;LEVEL&lt;/code&gt; 的可能值，请参见 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">但是，如果首选更残酷的变体，则可以仅使用单个升级指令 &lt;code&gt;restart_emulator&lt;/code&gt; 手写发行升级文件。与 &lt;code&gt;restart_new_emulator&lt;/code&gt; 相比，此指令使模拟器使用&lt;strong&gt;所有&lt;/strong&gt;应用程序的新版本重新启动。</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">但是,如果剖析时间很短,而主机操作系统又不支持高分辨率的cpu时间测量,一些少数操作系统的调度可能会出现实际上什么都不做的函数执行时间长得离谱的情况。曾见过一个例子,一个函数或多或少只是组成一个元组,执行时间是正常执行时间的100倍左右,当重复追踪时,执行时间变得正常。</target>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">忽略下一届。</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igor将在编译选项中查找术语 &lt;code&gt;{igor, List}&lt;/code&gt; ，其中 &lt;code&gt;List&lt;/code&gt; 是Igor特定选项的列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">Igor:模块合并和重命名器。</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">非法使用记录</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">想象两个节点， &lt;code&gt;A&lt;/code&gt; 启动握手， &lt;code&gt;B&lt;/code&gt; 接受连接。</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;{addr,_}&lt;/code&gt; 之后紧随 &lt;code&gt;{netmask,_}&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">立即关闭一个或两个方向的插座。</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">如果&lt;strong&gt;未&lt;/strong&gt;设置标志 &lt;code&gt;broadcast&lt;/code&gt; 并且设置了标志 &lt;code&gt;pointtopoint&lt;/code&gt; &lt;strong&gt;则&lt;/strong&gt;此后紧跟 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">在驱动程序中实现 &lt;code&gt;outputv&lt;/code&gt; 回调（而不是 &lt;code&gt;output&lt;/code&gt; 回调）。如果驱动程序具有 &lt;code&gt;outputv&lt;/code&gt; 回调，则将在 &lt;code&gt;port_command/2&lt;/code&gt; 的 &lt;code&gt;Data&lt;/code&gt; 参数的iolist中传递的refc二进制文件作为对驱动程序的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">实施用户(的)。</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">实现。采用平衡二元搜索树。时间复杂度与对数N成正比,其中N是自由块的数量。</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">实现。采用平衡二元搜索树。时间复杂度与对数N成正比,其中N是自由块的大小数。</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">实现。采用平衡的二元搜索树。时间复杂度与对数N成正比,其中N是自由块的数量。</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">实施。检查自由列表中的第一个区块。如果它满足请求,则使用它,否则会创建一个新的载体。该实现的时间复杂度为常数。</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">实施：该实施使用最大块搜索深度（在每个列表中）的隔离的空闲列表来快速找到合适的对象。当最大块搜索深度较小时（默认为3），此实现的时间复杂度是恒定的。可以使用参数 &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; 来配置最大块搜索深度。</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">实现经理人的应用。</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">实施MIB可能是一项繁琐的任务。最有可能需要在实现所有表和变量之前测试代理。在这种情况下，默认的检测功能很有用。该工具包可以为变量以及表生成默认的检测功能。因此，无需任何编程即可生成可处理 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;get-next&lt;/code&gt; 和表操作的运行中原型代理。</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">实现对Unicode字符集的支持是一个持续的过程。Erlang增强提案(EEP)10概述了支持Unicode的基础知识,并在二进制文件中指定了一个默认编码,所有具有Unicode意识的模块将来都要处理这个编码。</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">实施MIB</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">&lt;strong&gt;用promises&lt;/strong&gt;实现&lt;strong&gt;调用流，promise&lt;/strong&gt;是一种RPC，在结果完成之前不会挂起调用方。而是返回一个键，以后可以使用它来收集值。关键可以看作是提供答案的承诺。</target>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">实现内部CRL（证书吊销列表）缓存。除了实现 &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 行为外，还可以使用以下功能。</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">实现全局（重复）搜索（Perl中的标志 &lt;code&gt;g&lt;/code&gt; ）。每个匹配项都作为单独的 &lt;code&gt;list()&lt;/code&gt; 返回，该list（）包含特定匹配项和任何匹配的子表达式（或由option &lt;code&gt;capture&lt;/code&gt; 指定。因此，当指定此选项时，返回值的 &lt;code&gt;Captured&lt;/code&gt; 部分为 &lt;code&gt;list()&lt;/code&gt; 的 &lt;code&gt;list()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">在编译时实现转换。如果源文件中包含头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，则编译器将调用此函数以进行源代码转换。</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">当从shell调用 &lt;code&gt;fun2ms/1&lt;/code&gt; 函数时，实现转换。在这种情况下，抽象形式是一种乐趣（由Erlang shell解析）。所有导入的变量都将在作为 &lt;code&gt;BoundEnvironment&lt;/code&gt; 传递的键值列表中。结果是一个标准化的术语，即不是抽象格式。</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">导入配置数据（类似于 &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">导入的函数。可以像本地函数一样调用,也就是说,没有任何模块前缀。</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">从使用 &lt;code&gt;cover:export/1,2&lt;/code&gt; 创建的 &lt;code&gt;ExportFile&lt;/code&gt; 文件中导入coverage数据。此后执行的任何分析都将包括导入的数据。</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">使用不当会严重降低系统性能。</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">在.emacs中,斜杠字符&quot;/&quot;可以用作路径分隔符。但如果你决定使用反斜杠字符&quot;/&quot;,请不要使用双反斜杠,因为Emacs将其视为转义字符。</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">1994年，引入了全局标记模式 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 。通过将 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 放在模块头中，ASN.1编译器会在需要时自动添加标签。以下是&amp;ldquo; &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 模式下的相同规格：</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">在8位非UTF-8模式下，仅码点&amp;lt;256个字符的字符相关。</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">在 &lt;code&gt;$ERL_TOP&lt;/code&gt; ，有一个名为 &lt;code&gt;otp_build&lt;/code&gt; 的脚本。该脚本解决了提供所有正确的参数来 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 的麻烦，并且还可以帮助您设置正确的环境变量以与Cygwin / MSYS / MSYS2下的Erlang源一起使用。</target>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ID&lt;/code&gt; 中，只有18位有效。在 &lt;code&gt;Creation&lt;/code&gt; 中，只有两位有效。其余为0。请参见 &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 中，表中的所有记录必须具有相同的名称。所有记录必须是相同记录类型的实例。但是，记录名称不一定必须与表名称相同，尽管在本《用户指南》的大多数示例中都是如此。如果创建的表没有属性 &lt;code&gt;record_name&lt;/code&gt; ，则以下代码确保该表中的所有记录都具有与该表相同的名称：</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">在 &lt;code&gt;Module:Name/Arity&lt;/code&gt; 中， &lt;code&gt;Module&lt;/code&gt; 和 &lt;code&gt;Name&lt;/code&gt; 是原子，而 &lt;code&gt;Arity&lt;/code&gt; 是整数。从Erlang / OTP R15开始， &lt;code&gt;Module&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Arity&lt;/code&gt; 也可以是变量。以这种方式定义的乐趣是在模块 &lt;code&gt;Module&lt;/code&gt; 的&lt;strong&gt;最新&lt;/strong&gt;版本中引用具有 &lt;code&gt;Arity&lt;/code&gt; 的功能 &lt;code&gt;Name&lt;/code&gt; 。以这种方式定义的乐趣并不取决于定义它的模块的代码。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">在 &lt;code&gt;Name/Arity&lt;/code&gt; 中， &lt;code&gt;Name&lt;/code&gt; 是一个原子， &lt;code&gt;Arity&lt;/code&gt; 是一个整数。 &lt;code&gt;Name/Arity&lt;/code&gt; 必须指定一个现有的本地功能。该表达式是用于以下方面的语法糖：</target>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Type_List&lt;/code&gt; 中,描述了从顶部类型到每个未解码子组件的&amp;ldquo;路径&amp;rdquo;。路径的顶部类型是原子，即原子。 &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; 中的一个描述了随后对每个组件/类型的操作。</target>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;attr&lt;/code&gt; 中，对象的属性存储为其类型（ &lt;code&gt;EI_INT&lt;/code&gt; ， &lt;code&gt;EI_FLT&lt;/code&gt; ， &lt;code&gt;EI_BIN&lt;/code&gt; 和 &lt;code&gt;EI_STR&lt;/code&gt; 之一）的逻辑&lt;strong&gt;或&lt;/strong&gt;，是否将其标记为删除（ &lt;code&gt;EI_DELET&lt;/code&gt; ），以及自从上次备份以来是否已对其进行了修改 &lt;code&gt;Mnesia&lt;/code&gt; （ &lt;code&gt;EI_DIRTY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">在上面的 &lt;code&gt;ch1.erl&lt;/code&gt; 和 &lt;code&gt;ch2.erl&lt;/code&gt; 中，有意地省略了 &lt;code&gt;channels/0&lt;/code&gt; ， &lt;code&gt;alloc/1&lt;/code&gt; 和 &lt;code&gt;free/2&lt;/code&gt; 的实现，因为它与示例无关。为了完整起见，下面给出了编写这些函数的一种方法。这仅是示例，现实的实现必须能够处理诸如用尽分配通道之类的情况。</target>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">在 &lt;code&gt;ei_s_print_term()&lt;/code&gt; 中，参数 &lt;code&gt;s&lt;/code&gt; 指向 &lt;code&gt;BUFSIZ&lt;/code&gt; 字节的动态（malloc）分配字符串或 &lt;code&gt;NULL&lt;/code&gt; 指针。如果结果超过 &lt;code&gt;BUFSIZ&lt;/code&gt; 个字符，则可以使用此函数重新分配字符串（并且 &lt;code&gt;*s&lt;/code&gt; 可以更新）。返回的字符串以 &lt;code&gt;NULL&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;file_logger&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">在 &lt;code&gt;latin1&lt;/code&gt; 模式下，文件名按字节编码。这允许系统中所有文件名的列表表示。但是，名为&amp;ldquo;&amp;Ouml;stersund.txt&amp;rdquo;的 &lt;code&gt;file:list_dir/1&lt;/code&gt; 在文件：list_dir / 1中显示为&amp;ldquo;&amp;Ouml;stersund.txt&amp;rdquo;（如果文件名是由创建该文件的程序按字节ISO ISO Latin-1编码的），或者更可能显示为 &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; ，这是一个包含UTF-8字节的列表（不是您想要的）。如果在这样的系统上使用Unicode文件名转换，则诸如 &lt;code&gt;file:list_dir/1&lt;/code&gt; 之类的函数会忽略非UTF-8文件名。可以使用功能 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; 检索它们，但是编码错误的文件名显示为&amp;ldquo;原始文件名&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">在 &lt;code&gt;latin1&lt;/code&gt; 模式下，Erlang VM不会更改文件名的编码。在 &lt;code&gt;utf8&lt;/code&gt; 模式下，文件名可以包含大于255的Unicode字符，并且VM将文件名来回转换为本地文件名编码（通常为UTF-8，但在Windows上为UTF-16）。</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">在 &lt;code&gt;list_max/2&lt;/code&gt; ，你走在列表并使用 &lt;code&gt;Head&lt;/code&gt; ，而不是 &lt;code&gt;Result_so_far&lt;/code&gt; 当 &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;when&lt;/code&gt; 是在函数中的-&amp;gt;之前使用的特殊词，表示您仅在后面的测试为true时才使用函数的这一部分。这种测试称为&lt;strong&gt;警卫&lt;/strong&gt;。如果防护是错误的（即防护失败），则尝试功能的下一部分。在这种情况下，如果 &lt;code&gt;Head&lt;/code&gt; 不大于 &lt;code&gt;Result_so_far&lt;/code&gt; ，则它必须小于或等于它。这意味着不需要保护该功能的下一部分。</target>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">在 &lt;code&gt;sort&lt;/code&gt; 的乐趣是使用：</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;terminal_logger&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">在 &lt;code&gt;unicode&lt;/code&gt; 模式下，反斜杠后只有ASCII数字和字母具有特殊含义。所有其他字符（尤其是那些代码点大于127的字符）都被视为文字。</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">在AEAD（具有关联数据的身份验证加密）模式下，根据 &lt;code&gt;Type&lt;/code&gt; 块密码解密 &lt;code&gt;CipherText&lt;/code&gt; ，并使用 &lt;code&gt;CipherTag&lt;/code&gt; 来检查 &lt;code&gt;PlainText&lt;/code&gt; 和 &lt;code&gt;AAD&lt;/code&gt; （关联的身份验证数据）的真实性。如果解密或验证失败，则可能返回 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">在AEAD（具有关联数据的身份验证加密）模式下，根据 &lt;code&gt;Type&lt;/code&gt; 块密码对 &lt;code&gt;PlainText&lt;/code&gt; 进行加密，并计算也对 &lt;code&gt;AAD&lt;/code&gt; （关联的身份验证数据）进行身份验证的 &lt;code&gt;CipherTag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">在ASN.1中,也可以有本身是结构类型的组件。例如,可以有以下几种类型:</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">在ASN.1中,可以有:</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">在ASN.1中， &lt;code&gt;BIT STRING&lt;/code&gt; 定义可以如下所示：</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">在Megaco/H.248规范(RFC 3525)的附录A中,有大约30条信息显示了一个有代表性的呼叫流程。我们还增加了一些额外的版本1、版本2和版本3的信息。我们使用这些信息作为我们测量的基础。我们的数字没有根据媒体网关与其控制器之间发送的不同种类的消息的频率进行加权。</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">在Erlang代码中,它可以如下所示。</target>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">在Erlang中，BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; 用于将术语转换为外部格式。要将二进制数据编码转换为术语，请使用BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">在Erlang中,可以应用以下内容。</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">在Erlang中,Bin用于构造二进制和匹配二进制模式。Bin的语法如下。</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">在Erlang中,字符串是整数的列表,在Erlang/OTP R13之前,字符串被定义为ISO Latin-1(ISO 8859-1)字符集,也就是一个个码点,Unicode字符集的子范围。在Erlang/OTP R13之前,字符串被定义为ISO Latin-1(ISO 8859-1)字符集的编码,也就是一个个码点,是Unicode字符集的子范围。</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">在Erlang中， &lt;code&gt;SET&lt;/code&gt; 类型与 &lt;code&gt;SEQUENCE&lt;/code&gt; 完全相同。请注意，如果使用BER或DER编码规则，则对 &lt;code&gt;SET&lt;/code&gt; 进行解码比对 &lt;code&gt;SEQUENCE&lt;/code&gt; 进行解码要慢，因为必须对组件进行排序。</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">在Erlang中，如果适用，则支持完整的UTF-16范围，例如 &lt;code&gt;unicode&lt;/code&gt; 模块和bit语法。</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">在Erlang中，没有接口来检索带有 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 的标记，因此只有次要目的与Erlang程序员有关。</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">在Erlang/OTP 17.0中,Erlang源文件的默认编码被改成了UTF-8。</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">在 Erlang/OTP 20.0 中,原子和函数可以包含 Unicode 字符。模块名称、应用程序名称和节点名称仍然被限制在ISO Latin-1范围内。</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">在Erlang / OTP 21.0中，添加了用于日志记录的新API。旧的 &lt;code&gt;error_logger&lt;/code&gt; 模块仍可用于旧代码，但日志事件将重定向到新的Logger API。新代码应直接使用Logger API。</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">在Erlang / OTP R16B中，Erlang令牌的语法已扩展为可处理Unicode。支持仅限于字符串文字和注释。有关在Erlang源文件中使用Unicode的更多信息，请参见 &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">在Erlang / OTP R5B和更高版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 目录位于 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 下，其中 &lt;code&gt;OTPROOT&lt;/code&gt; 是OTP安装的根目录（在最近的示例中为 &lt;code&gt;/usr/local/otp&lt;/code&gt; ）， &lt;code&gt;VSN&lt;/code&gt; 是Erl_Interface应用程序的版本（在最近的示例中为3.2.1）。</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">在Erlang / OTP R5B和更高版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 目录位于 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 下，其中 &lt;code&gt;OTPROOT&lt;/code&gt; 是OTP安装的根目录（在最近的示例中为 &lt;code&gt;/usr/local/otp&lt;/code&gt; ）， &lt;code&gt;VSN&lt;/code&gt; 是Erl_interface应用程序的版本（在最近的示例中为3.2.1）。</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">在Erlang / OTP R6B中，添加了一个类似于Java的Erl_Interface的库，称为&lt;strong&gt;jinterface&lt;/strong&gt;。它为Java程序提供了与Erlang节点进行通信的工具。</target>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">在Erlang / OTP中，内核中的 &lt;code&gt;gen_tcp&lt;/code&gt; 和 &lt;code&gt;gen_udp&lt;/code&gt; 模块提供对TCP / IP和UDP套接字的访问。两者都易于使用，并且不需要有关套接字概念的详细知识。</target>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">在FIPS模式下，所有不符合FIPS的算法均被禁用，并引发 &lt;code&gt;not_supported&lt;/code&gt; 异常。Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; 在FIPS模式下返回可用算法的受限列表。</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">在FIPS模式下,非验证的算法被禁用。这可能会在依赖加密技术的应用中引起一些意想不到的问题。</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">在德语中，字母&amp;ldquo;&amp;szlig;&amp;rdquo;（sharp s）为小写字母，但大写字母为&amp;ldquo; SS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">在希腊文中，字母&amp;ldquo;&amp;Sigma;&amp;rdquo;具有两种不同的小写形式，&amp;ldquo;-&amp;sigmaf;&amp;rdquo;处于字尾位置，&amp;ldquo;&amp;sigma;&amp;rdquo;位于其他位置。</target>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">在OTP 20中,最好删除所有使用rsa kexchange的密码套件(在21中从默认情况下删除)。</target>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">在OTP R16中，选项得到了简化。使用 &lt;code&gt;ber&lt;/code&gt; ， &lt;code&gt;per&lt;/code&gt; 或 &lt;code&gt;uper&lt;/code&gt; 选项之一选择后端。不再需要选项 &lt;code&gt;optimize&lt;/code&gt; ， &lt;code&gt;nif&lt;/code&gt; 和 &lt;code&gt;driver&lt;/code&gt; 选项（如果使用了ASN.1编译器，则会生成警告）。选项 &lt;code&gt;ber_bin&lt;/code&gt; ， &lt;code&gt;per_bin&lt;/code&gt; 和 &lt;code&gt;uper_bin&lt;/code&gt; 选项仍然有效，但是会生成警告。</target>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">在R9C之前的OTP版本中，经过更多处理的抽象代码存储在Beam文件中。元组的第一个元素将是 &lt;code&gt;abstract_v1&lt;/code&gt; （在OTP R7B中）或 &lt;code&gt;abstract_v2&lt;/code&gt; （在OTP R8B中）。</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">在OTP中，&lt;strong&gt;应用程序&lt;/strong&gt;表示实现某些特定功能的组件，该组件可以作为一个单元启动和停止，并且可以在其他系统中重用。该模块与&lt;strong&gt;应用程序控制器&lt;/strong&gt;交互，该&lt;strong&gt;控制器&lt;/strong&gt;在每个Erlang运行时系统中启动。该模块包含用于控制应用程序的功能（例如，启动和停止应用程序），以及用于访问有关应用程序的信息的功能（例如，配置参数）。</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">在OTP中，&lt;strong&gt;事件管理器&lt;/strong&gt;是可以向其发送事件的命名对象。一个&lt;strong&gt;事件&lt;/strong&gt;可以是，例如，错误，警报，或一些信息，这些信息将被记录。</target>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">在PCRE，一个子模式可以通过以下三种方式之一被命名为： &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 或 &lt;code&gt;(?'name'...)&lt;/code&gt; 在Perl或 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 作为蟒蛇。可以通过名称和编号来引用从模式的其他部分捕获括号的引用，例如反向引用，递归和条件。</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">在PCRE中,它与 &quot;bab &quot;匹配。第一组捕获括号匹配 &quot;b&quot;,然后在第二组中,当后引用/1未能匹配 &quot;b &quot;时,第二组选择匹配 &quot;a&quot;,然后递归。在递归过程中,\1现在确实匹配了 &quot;b&quot;,所以整个匹配成功了。在Perl中,模式失败是因为在递归调用中,\1不能访问外部设置的值。</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">在Perl中,字符串处理程序可以识别出序列\l、\L、\u和\U,并用于修改以下字符的情况。PCRE不支持这些转义序列。</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">在R4B和早期版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 位于 &lt;code&gt;OTPROOT/usr&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">在SNMP中， &lt;code&gt;set&lt;/code&gt; 操作是原子的。 &lt;code&gt;set&lt;/code&gt; 操作中指定的所有变量都将更改，或者不更改。因此， &lt;code&gt;set&lt;/code&gt; 操作分为两个阶段。在第一阶段，将根据MIB中变量的定义检查每个变量的新值。检查以下定义：</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">在SNMPv1和SNMPv2c中,消息中的社区字符串被用于(至少)三种不同的目的。</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">在SNMPv3中，每个使用区域都有其自己独特的机制。上下文由SNMP实体的名称 &lt;code&gt;contextEngineID&lt;/code&gt; 和上下文的名称 &lt;code&gt;contextName&lt;/code&gt; 标识。每个SNMPv3消息均包含这两个参数的值。</target>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">在土耳其语中,有点和无点的 &quot;i &quot;都以小写和大写的形式存在。</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">在UTF-8模式下，值&amp;gt; 255（0xffff）的字符可以作为数据单元的文字字符串包含在类中，或者使用\ x {转义机制。</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Unicode文件名模式下，使用选项 &lt;code&gt;{spawn_executable,...}&lt;/code&gt; 指定给BIF &lt;code&gt;open_port/2&lt;/code&gt; 的文件名也被解释为Unicode。使用 &lt;code&gt;spawn_executable&lt;/code&gt; 时，选项 &lt;code&gt;args&lt;/code&gt; 中指定的参数列表也可用。使用二进制文件可以避免参数的UTF-8转换，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">在Unicode模式下,量化符适用于字符而不是单个数据单位。因此,例如,\x{100}{2}匹配两个字符,每个字符由UTF-8字符串中的一个2字节序列表示。同样,\X{3}匹配三个Unicode扩展字词簇,每个字词簇可以有很多数据单位长(而且它们可以有不同的长度)。</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">在Unicode模式下，又添加了两个代码点大于255的字符：LS（行分隔符，U + 2028）和PS（段分隔符，U + 2029）。不需要Unicode字符属性支持即可识别这些字符。</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">在Windows中,所有的目录分隔符都是正向斜杠,驱动器字母是小写的。</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Windows中，即使参数包含反斜杠，所有函数也仅返回带有正斜杠的文件名。要通过删除多余的目录分隔符来标准化文件名，请使用 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">在 CTH 中,行为可以在以下功能后挂入。</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">在 CTH 中,行为可以在以下函数前挂接。</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">在KDE环境中，选择&amp;ldquo; &lt;strong&gt;KDE控制中心（个人设置）&lt;/strong&gt; &amp;gt; &lt;strong&gt;区域和可访问性&lt;/strong&gt; &amp;gt; &lt;strong&gt;键盘布局&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">在UTF模式下,PCRE不允许在lookbehind断言中出现\C转义(即使在UTF模式下也能匹配单个数据单元),因为这使得无法计算lookbehind的长度。\X和\R转义也不允许,它们可以匹配不同数量的数据单元。</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">在Unix (Bourne)shell中,它可以如下所示(换行符是为了便于阅读,打字时不需要)。</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">在黑盒测试方案中，基于 &lt;code&gt;Common Test&lt;/code&gt; 的测试程序通过标准O＆M和CLI协议连接到目标系统。 &lt;code&gt;Common Test&lt;/code&gt; 提供了其中一些协议的实现和包装器接口（其中大多数协议作为OTP中的独立组件和应用程序存在）。包装器简化了配置并添加了详细信息以进行日志记录。 &lt;code&gt;Common Test&lt;/code&gt; 通过有用的支持模块不断扩展。但是，请注意，使用任何Erlang / OTP组件通过 &lt;code&gt;Common Test&lt;/code&gt; 进行测试是一项简单的任务，而无需使用 &lt;code&gt;Common Test&lt;/code&gt; 包装器。就像调用Erlang函数一样简单。在以下版本中支持许多与目标无关的接口 &lt;code&gt;Common Test&lt;/code&gt; ，例如通用Telnet和FTP。这些可以是专门的，也可以直接用于控制仪表，交通负载生成器等。</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">在一个回调模块中。</target>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">在分布式Erlang系统中，有时连接到节点而不同时连接到所有其他节点很有用。一个示例是用于在不干扰系统状态的情况下检查系统状态的某种O＆M功能。为此，可以使用&lt;strong&gt;隐藏节点&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">在一个有多个Erlang节点的分布式系统中,可能需要以分布式的方式来控制应用程序。如果运行某个应用程序的节点宕机了,就要在另一个节点上重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">在未来的Erlang/OTP版本中,可能会实现一种(可选择的)保留共享的方式。</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">在将来的版本中，参数 &lt;code&gt;Dir&lt;/code&gt; 的错误类型可能会生成异常。</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">在将来的版本中，参数 &lt;code&gt;Filename&lt;/code&gt; 的类型错误可能会生成异常。</target>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在将来的版本中，此函数可能返回更多的值和范围。为了避免兼容性问题，建议使用 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">在一个较大的模式中,跟踪小括号的数字可能很棘手。通过使用相对引用可以使这一点变得更容易。在上面的模式中,你可以写(?1)来代替(?-2)来引用在递归之前最近打开的第二个小括号。也就是说,负数从遇到的点开始向左捕捉小括号算。</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">在一个更大的系统中,一个用户(这里是一个MGC)分布在几个Erlang节点上,它看起来有点不同。在这里,编码是在起源的Erlang节点(1)上进行的,二进制被转发到有物理网络接口的节点(2)上。当节点(2)的接口上收到潜在的消息回复时,会在那里进行解码,然后对消息中的每个事务采取不同的操作。交易回复将以其解码后的形式转发给发起节点(1),而其他类型的交易将在节点(2)上进行本地处理。</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">以类似于函数 &lt;code&gt;mnesia:index_read/3&lt;/code&gt; 的方式，尝试匹配记录时可以使用任何索引信息。该函数采用的模式遵循与 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 函数相同的规则，但该函数需要满足以下条件：</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">在一个单调递增的数值序列中,所有具有前级的数值都大于或等于其前级。</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">在该发行版的新版本中，应用程序 &lt;code&gt;ch_app&lt;/code&gt; 将包含在 &lt;code&gt;prim_app&lt;/code&gt; 中。也就是说，其最高主管 &lt;code&gt;ch_sup&lt;/code&gt; 将作为 &lt;code&gt;prim_sup&lt;/code&gt; 的子进程启动。</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">在一个模式匹配，一左手侧 &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 是针对右手侧匹配 &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; 。如果匹配成功，则模式中所有未绑定的变量都将被绑定。如果匹配失败，则会发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">在一个严格的单调递增的数值序列中,所有有前级的数值都比它的前级大。</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">在一棵监督树中,很多过程都有相似的结构,它们遵循相似的模式。例如,监督者的结构是相似的。它们之间唯一的区别是它们监督哪些子进程。许多工作者是服务器-客户关系中的服务器,有限状态机,或者是错误记录器等事件处理程序。</target>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">在系统中根据OTP设计原理，所有过程，除了系统进程和特殊工艺，驻留在行为之一实现 &lt;code&gt;supervisor&lt;/code&gt; ， &lt;code&gt;gen_server&lt;/code&gt; ， &lt;code&gt;gen_fsm&lt;/code&gt; ， &lt;code&gt;gen_statem&lt;/code&gt; 或 &lt;code&gt;gen_event&lt;/code&gt; 。这些属于STDLIB应用程序，升级/降级通常需要重新启动模拟器。</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 节点的系统中，每个节点都知道所有表的当前位置。在此示例中，数据在两个节点上都被复制，并且可以在两个节点中的任何一个上执行操作表中数据的功能。无论数据位于何处，操纵 &lt;code&gt;Mnesia&lt;/code&gt; 数据的代码的行为都相同。</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">在根据OTP设计原则构造的系统中，任何流程都将是属于主管的子流程，请参阅&amp;ldquo; 更改主管&amp;rdquo;中的 &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">在使用相对较少的处理的系统中，性能&lt;strong&gt;可能&lt;/strong&gt;通过使用的增加最小堆大小来改善 &lt;code&gt;+h&lt;/code&gt; 为选项 &lt;code&gt;erl&lt;/code&gt; 或关于使用的处理的每次过程基础 &lt;code&gt;min_heap_size&lt;/code&gt; 为选项 &lt;code&gt;spawn_opt/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">在基于TCP的分发系统中，此数据保存在&lt;strong&gt;Erlang端口映射器守护程序&lt;/strong&gt;（ &lt;code&gt;epmd&lt;/code&gt; ）中，当分布式节点启动时将与该&lt;strong&gt;守护程序&lt;/strong&gt;联系。使用此分发模块时，锁定文件和UDS侦听套接字名称的约定消除了对 &lt;code&gt;epmd&lt;/code&gt; 的需要。UDS始终限于一台主机，因此避免端口映射器很容易。</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">在SNMP监控的表中,所有元素必须是整数、字符串或整数列表。</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">在目标系统中，版本升级文件位于 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">在测试套件中，必须&lt;strong&gt;要求&lt;/strong&gt;存在配置变量（先前定义中为 &lt;code&gt;CfgVarName&lt;/code&gt; ），然后才能尝试在测试用例或配置函数中读取关联的值。</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">在元组 &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; 中，如果 &lt;code&gt;CSSFile&lt;/code&gt; 是用路径指定的，例如 &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; ，则使用此全名来查找文件。但是，如果仅指定文件名，例如 &lt;code&gt;categories.css&lt;/code&gt; ，则认为CSS文件位于套件的数据目录 &lt;code&gt;data_dir&lt;/code&gt; 中。推荐使用后者，因为与套件中的硬编码路径名相比，它是便携式的。</target>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">除了为 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;{Item,Value}&lt;/code&gt; 对之外，还允许以下各项：</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">除了&amp;ldquo;调用图&amp;rdquo;之外，还有一个称为&amp;ldquo; &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&amp;rdquo;的图&lt;/strong&gt;。这是一个调用图（从，到），因此在调用图中有从从到到的调用链，每个从和到都是导出函数或未使用的局部函数。顶点与&amp;ldquo;调用图&amp;rdquo;相同。</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">除了由密码套件协商的用于密钥交换，有效负载加密，消息认证和伪随机计算的算法 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; 还可以使用RFC 5246中 TLS签名算法扩展第7.4.1.4.1节（从TLS 1.2开始）来协商哪个算法。 TLS握手期间使用的签名算法。如果不支持低于1.2的TLS版本，则客户端将使用此选项指定的算法发送TLS签名算法扩展。默认为</target>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">除了这里的文档外,在最近的几本书中也有对Erlang的描述,比如。</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">除了之前的。</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">除了必需的回调函数 &lt;code&gt;log/2&lt;/code&gt; 之外，处理程序模块还可以导出可选的回调函数 &lt;code&gt;adding_handler/1&lt;/code&gt; ， &lt;code&gt;changing_config/2&lt;/code&gt; 和remove_handler &lt;code&gt;removing_handler/1&lt;/code&gt; 。有关这些功能的更多信息，请参见logger（3）手册页中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">除了用于接收和发送文件的常规功能（请参见 &lt;code&gt;recv/2&lt;/code&gt; ， &lt;code&gt;recv/3&lt;/code&gt; ， &lt;code&gt;send/2&lt;/code&gt; 和 &lt;code&gt;send/3&lt;/code&gt; ）之外，还有一些功能可以将远程文件作为二进制文件接收（请参见 &lt;code&gt;recv_bin/2&lt;/code&gt; ）并将二进制文件发送到被存储为远程文件（请参见 &lt;code&gt;send_bin/3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">除了前面描述的表示形式之外，如果使用选项 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 编译了规范，则还可以使用以下不推荐使用的表示形式：</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">除了表单的表示形式之外，表示模块声明的列表（由 &lt;code&gt;epp(3)&lt;/code&gt; 和 &lt;code&gt;erl_parse(3)&lt;/code&gt; 中的函数返回）还可以包含以下内容：</target>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">除了前面描述的标准Unicode属性外，PCRE还支持另外四个，可以转换传统的转义序列，例如\ w和\ s以使用Unicode属性。传递 &lt;code&gt;ucp&lt;/code&gt; 选项时，PCRE在内部使用这些非标准的非Perl属性。但是，它们也可以显式使用。属性如下：</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">除了静态监督树外,还可以通过以下调用将动态子进程添加到现有监督器中。</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">除了跟踪日志文件以外，在启动跟踪工具生成器时 &lt;code&gt;.ti&lt;/code&gt; 创建扩展名为.ti的文件。这是跟踪信息文件。它是一个二进制文件，其中包含进程信息，使用的跟踪标志，它所属的节点的名称以及所有使用 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 函数编写的信息。跟踪停止时， &lt;code&gt;.ti&lt;/code&gt; 文件始终与其他日志一起获取。</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">除这些选项外，还可以使用&lt;strong&gt;原始&lt;/strong&gt;选项规格。将原始选项指定为三元组的元组，以标记 &lt;code&gt;raw&lt;/code&gt; 开头，然后是协议级别，选项号和指定为二进制的选项值。这对应于C套接字API中 &lt;code&gt;setsockopt&lt;/code&gt; 调用的第二，第三和第四个参数。选项值必须以平台的本地字节序编码，并且，如果需要结构，则必须遵循特定平台上的结构对齐约定。</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">除此之外，Logger还将自动插入以下字段，这些值取自前两个参数的 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">除了本介绍性章节之外，《 &lt;code&gt;Event Tracers&lt;/code&gt; 跟踪程序用户指南》还包含以下章节：</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,Megaco用户指南还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,Reltool用户指南还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,《SNMP用户指南》还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">另外， &lt;code&gt;#Record.Name&lt;/code&gt; 返回记录 &lt;code&gt;Record&lt;/code&gt; 的 &lt;code&gt;Name&lt;/code&gt; 的元组表示形式中的索引。</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">此外，EUnit还将寻找另一个名为 &lt;code&gt;ModuleName&lt;/code&gt; 加上后缀 &lt;code&gt;_tests&lt;/code&gt; 的模块，如果存在，还将添加该模块的所有测试。（如果 &lt;code&gt;ModuleName&lt;/code&gt; 已经包含后缀 &lt;code&gt;_tests&lt;/code&gt; ，则不会这样做。）例如，规范 &lt;code&gt;{module, mymodule}&lt;/code&gt; 将运行模块 &lt;code&gt;mymodule&lt;/code&gt; 和 &lt;code&gt;mymodule_tests&lt;/code&gt; 中的所有测试。通常， &lt;code&gt;_tests&lt;/code&gt; 模块应仅包含使用主模块的公共接口的测试用例（不得包含其他代码）。</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此外，可以设置和更改表属性。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">此外,还存在以下三种内置类型,可以认为它们的定义如下,尽管严格来说,它们的 &quot;类型定义 &quot;根据上面定义的类型语言不是有效的语法。</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">此外,使用记录类型时,还可以通过添加字段的类型信息进一步指定记录字段,具体如下。</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">另外，您可能需要熟悉 &lt;code&gt;dbg&lt;/code&gt; 模块，也可能要熟悉 &lt;code&gt;seq_trace&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">在所有函数中，都可以引发 &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; 错误，其中 &lt;code&gt;Reason&lt;/code&gt; 描述了错误。</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">在所有这些情况下， &lt;code&gt;ReplyInfo&lt;/code&gt; 具有以下结构：</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">在所有其他情况下:</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">在所有其他意义上， &lt;code&gt;_tmo&lt;/code&gt; 函数都继承了不带 &lt;code&gt;_tmo&lt;/code&gt; 后缀的函数的所有返回值和语义。</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">在上面所有的例子中,对象必须存在,而且必须是指定操作的正确类型。如果你不知道一个对象的类型,你可以问。</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">在OTP源代码树中，可以从文本文件 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; 中读取OTP版本。可以通过调用 &lt;code&gt;filename:join([&lt;/code&gt; [ &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; 来构造文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">在此API的早期版本中， &lt;code&gt;lookup&lt;/code&gt; 函数收到两个参数，省略了 &lt;code&gt;Issuer&lt;/code&gt; 。为了兼容性，它仍然受支持：如果回调模块中没有 &lt;code&gt;lookup/3&lt;/code&gt; 函数，则改为调用 &lt;code&gt;lookup/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">在嵌入式系统中，通常没有交互式外壳。但是，操作员可以通过命令 &lt;code&gt;to_erl&lt;/code&gt; 连接到Erlang系统。然后，操作员将连接到Erlang外壳并可以发出普通的Erlang命令。通过此Shell与系统进行的所有交互都记录在一个特殊目录中。</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">在已安装的OTP开发系统中，可以从文本文件 &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; 。通过调用 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; 可以构造文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">在交互式系统中，代码加载器提供需求驱动的代码加载，但是在嵌入式系统中，代码加载器立即加载所有代码。在两种情况下都使用相同版本的 &lt;code&gt;code&lt;/code&gt; 。代码服务器调用 &lt;code&gt;init:get_argument(mode)&lt;/code&gt; 以确定它是在需求模式还是非需求驱动模式下运行。</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">在这两种情况下,都会设置当前令牌。特别是,如果收到的消息的令牌是空的,则进程的当前令牌被设置为空。</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">在这两种情况下,应该返回表中第一个可访问的元素。由于关键列是不可访问的,这意味着第三列是第一行。</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">在上述两个示例中， &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; 都将在跟踪函数之后立即重置跟踪令牌，以避免由于Erlang Shell中的打印输出而产生许多跟踪消息。</target>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">简而言之， &lt;code&gt;Common Test&lt;/code&gt; 支持：</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">简而言之,CTH允许你做以下事情。</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">简而言之,CTH允许你。</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">简而言之，一个简单的测试对象由一个不带参数的函数组成（可能带有一些其他元数据，即行号）。通过返回某个值（被忽略）来对函数求值&lt;strong&gt;成功&lt;/strong&gt;，或者通过抛出异常而对函数求值&lt;strong&gt;失败&lt;/strong&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
