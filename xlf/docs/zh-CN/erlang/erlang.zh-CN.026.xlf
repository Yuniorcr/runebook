<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="1adf89e8e92228a60dd07895fb1499d746d2f997" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,ANNO,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果T是地图类型 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联类型），则Rep（T）= &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="a3d2ad35675d5afe54ca0bd9c3179fed7255c00e" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,map,any}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">如果T是地图类型 &lt;code&gt;map()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="393b51301cf31a12b2c86b8f1d9bbdef7251ed54" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是预定义（或内置）类型 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca56d7b0dd371abffc166a298e3aa5c771e44b2d" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,ANNO,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">如果T是记录类型 &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; ，其中每个 &lt;code&gt;F_i&lt;/code&gt; 是记录字段类型，则Rep（T）= &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; 。对于Rep（F），请参见下文。</target>
        </trans-unit>
        <trans-unit id="3222c4ffd098914385913646a36a5eb933808ff6" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,ANNO,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">如果T是远程类型 &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8647f8866bf0895e0a5b40a325be9d138c2a1081" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,any}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个元组类型 &lt;code&gt;tuple()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207c50704c87beebe7a6e20ca5b5d3c04f6d1d99" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个元组类型 &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a938cb6958277c0935e0d57bb6651a672684a8d4" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是类型并集 &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; ，然后Rep（T）= &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da23467e91ab40f667601ddef52da4d45d5feefe" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">如果T是类型变量 &lt;code&gt;V&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。类型变量是除下划线（ &lt;code&gt;_&lt;/code&gt; ）之外的任何变量。</target>
        </trans-unit>
        <trans-unit id="9009a6974b8dc4d03f245e007c8f49b5b6d34b52" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是用户定义的类型 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f07bf781162482afd2013d4024c6c725654680a1" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,ANNO,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是带注释的类型 &lt;code&gt;A :: T_0&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是变量，则Rep（T）= &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">如果T是一个原子或整数文字L,那么Rep(T)=Rep(L)。</target>
        </trans-unit>
        <trans-unit id="88da671c68682a76fd63acbbd82cd33cfc329377" translate="yes" xml:space="preserve">
          <source>If T is an atom, a character, or an integer literal L, then Rep(T) = Rep(L).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0240293ad37bae225227647e0e3b7e2bac07ec" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是整数范围类型 &lt;code&gt;L .. H&lt;/code&gt; ，其中 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;H&lt;/code&gt; 是单例整数类型，则Rep（T）= &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc03bf3c127d2db614b6ef5e1997a93c0412bfa2" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">如果T是运算符类型 &lt;code&gt;Op T_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符（这是一个表达式的出现，可以在编译时将其评估为整数），则Rep（T）= &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ccf953cec087c4f37edbb5474ed7922f3550a3" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个运算符类型 &lt;code&gt;T_1 Op T_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一个二进制运算符（这是一个表达式的出现，可以在编译时将其评估为整数），则Rep（T）= &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0cf8513a746893009eda27d45a4780f2cc888dc" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,nil,[]}&lt;/code&gt;, that is, the empty list type &lt;code&gt;[]&lt;/code&gt; cannot be distinguished from the predefined type &lt;code&gt;nil()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">如果T是空列表类型 &lt;code&gt;[]&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">如果请求TLS（ &lt;code&gt;Bool=true&lt;/code&gt; ），则连接过程应与对等方发起TLS握手，并且接受过程应准备接受握手。成功握手后，应向父进程发送一条 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 消息。握手失败应导致进程退出。</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">如果TS是类型说明符 &lt;code&gt;A:Value&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是原子，而 &lt;code&gt;Value&lt;/code&gt; 是整数，则Rep（TS）= &lt;code&gt;{A,Value}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果TS是一个类型说明符 &lt;code&gt;A&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，然后代表（TS）= &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">如果要对远程节点使用跟踪工具生成器，强烈建议将跟踪控制节点启动为&lt;strong&gt;hidden&lt;/strong&gt;。这样，它可以连接到被跟踪的节点而不会被它&amp;ldquo;看到&amp;rdquo;，也就是说，如果在被跟踪的节点上调用 &lt;code&gt;nodes()&lt;/code&gt; BIF，则不会显示跟踪控制节点。要启动隐藏节点，请在 &lt;code&gt;erl&lt;/code&gt; 命令中添加 &lt;code&gt;-hidden&lt;/code&gt; 选项，例如：</target>
        </trans-unit>
        <trans-unit id="f981e82f10b1b120a81d1801123ff119c9dd5647" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57716f17031652959455a3f19555742110bf4198" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc97ec63a0f0a73856ddcd04133122fc9570583f" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参见 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串 &lt;code&gt;VarName&lt;/code&gt; 可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参见 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串 &lt;code&gt;VarName&lt;/code&gt; 和 &lt;code&gt;Value&lt;/code&gt; 可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">如果Unicode文件名编码有效（请参阅 &lt;code&gt;erlmanual page&lt;/code&gt; ），则字符串可以包含代码点&amp;gt; 255的字符。</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">如果Unicode文件名转换有效并且文件系统是透明的，则可能会遇到无法解释为Unicode的文件名，在这种情况下，必须准备好 &lt;code&gt;fun()&lt;/code&gt; 来处理原始文件名（即二进制文件）。如果正则表达式包含&amp;gt; 255的代码点，则它与不符合预期字符编码的文件名不匹配（即，未以有效的UTF-8编码）。</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">如果启用了Unicode文件名，则对 &lt;code&gt;os:getenv/0,1&lt;/code&gt; ， &lt;code&gt;os:putenv/2&lt;/code&gt; 和 &lt;code&gt;os:unsetenv/1&lt;/code&gt; 的调用将处理Unicode字符串。在类似Unix的平台上，内置函数可能会将UTF-8中的环境变量转换为Unicode字符串或从Unicode字符串转换为环境变量，而代码点可能大于255。在Windows上，使用了环境系统API的Unicode版本，并且代码点大于255被允许。</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">如果Unicode翻译有效（ &lt;code&gt;~ts&lt;/code&gt; ），则接受大于255的字符，否则不接受。使用translation修饰符，返回的列表因此也可以包含大于255的整数：</target>
        </trans-unit>
        <trans-unit id="3e9eb4fb01bd12ad300a0a96c219b150663189ba" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A :: T&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（V）= &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6fe32cd5968d212727cb82bd15e47cc5d23b10" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A = E :: T&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 是一个表达式， &lt;code&gt;T&lt;/code&gt; 是一个类型，则Rep（V）= &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc17addad3b18cec2f98a0aa96fe46ca497758bf" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果V是 &lt;code&gt;A = E&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 是一个表达式，则Rep（V）= &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530b26a08f1369a0dde3ebbcc4e657abbc43c708" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果V为 &lt;code&gt;A&lt;/code&gt; ，则Rep（V）= &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">如果VM处于Unicode文件名模式，则 &lt;code&gt;string()&lt;/code&gt; 和 &lt;code&gt;char()&lt;/code&gt; 的值应大于255。另请参见 &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; 类型的文档。</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">如果VM处于Unicode文件名模式，则允许的字符&amp;gt; &lt;code&gt;RawFilename&lt;/code&gt; 是不受Unicode转换限制的文件名，这意味着它可以包含不符合文件系统预期的Unicode编码的字符（即非UTF） -8个字符（尽管VM以Unicode文件名模式启动）。空字符（整数值为零）的&lt;strong&gt;未&lt;/strong&gt;在文件名中不允许（未甚至在结束时）。</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">如果X = Y，则R被称为关系&lt;strong&gt;在&lt;/strong&gt; X.</target>
        </trans-unit>
        <trans-unit id="00c65a44486df5482c6dc2dd5875d8d6aaf46534" translate="yes" xml:space="preserve">
          <source>If a &quot;traditional&quot; transport is specified (without explicit &lt;code&gt;Kind&lt;/code&gt;, handling both requests and traps) for a transport domain, its &lt;strong&gt;not&lt;/strong&gt; possible to also specify a transport (for that domain) with a specific &lt;code&gt;Kind&lt;/code&gt;. This is for example &lt;strong&gt;not&lt;/strong&gt; allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果通过顶点 &lt;code&gt;V&lt;/code&gt; 存在长度为2或更大的 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; ，则该循环将作为顶点列表 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 返回。如果一个 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 通过 &lt;code&gt;V&lt;/code&gt; 存在，则循环返回为一个列表 &lt;code&gt;[V]&lt;/code&gt; 。如果不存在通过 &lt;code&gt;V&lt;/code&gt; 的循环，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">如果代码路径中已存在 &lt;code&gt;Dir&lt;/code&gt; ，则将其从旧位置删除。</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">如果 &lt;code&gt;StateFun&lt;/code&gt; 函数崩溃或引发异常，则 &lt;code&gt;gen_server&lt;/code&gt; 和 &lt;code&gt;gen_statem&lt;/code&gt; 进程的原始状态不变。对于 &lt;code&gt;gen_event&lt;/code&gt; 进程，崩溃或失败的 &lt;code&gt;StateFun&lt;/code&gt; 函数意味着只有失败或崩溃时正在处理的特定事件处理程序的状态不变；它仍然可以成功更改在同一 &lt;code&gt;gen_event&lt;/code&gt; 进程中注册的其他事件处理程序的状态。</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">如果 &lt;code&gt;StateFun&lt;/code&gt; 函数决定不对进程状态进行任何更改，则无论进程类型如何，它都可以返回其 &lt;code&gt;State&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="9f3a01e0c748edc694108fe2d71299f36d697f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is specified, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定了 &lt;code&gt;Tag&lt;/code&gt; ，则返回的 &lt;code&gt;Match&lt;/code&gt; 还包括匹配的 &lt;code&gt;Tag&lt;/code&gt; 。否则，仅返回 &lt;code&gt;RxMatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">如果指定了 &lt;code&gt;Threshold&lt;/code&gt; ，则在发生以下情况时，计数器将重置为值 &lt;code&gt;SetValue&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;pid()&lt;/code&gt; ，则存在元组 &lt;code&gt;{timeout, Millis}&lt;/code&gt; ， &lt;code&gt;{in, Location}&lt;/code&gt; 和 &lt;code&gt;{out, Location}&lt;/code&gt; ，其中 &lt;code&gt;Location&lt;/code&gt; 是描述该函数的MFA（ &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; ）被安排进/出，或原子 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">如果 &lt;code&gt;port()&lt;/code&gt; ，则存在元组 &lt;code&gt;{timeout, Millis}&lt;/code&gt; 和 &lt;code&gt;{port_op,Op}&lt;/code&gt; 。 &lt;code&gt;Op&lt;/code&gt; 是 &lt;code&gt;proc_sig&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; ， &lt;code&gt;input&lt;/code&gt; ， &lt;code&gt;output&lt;/code&gt; ， &lt;code&gt;event&lt;/code&gt; 或 &lt;code&gt;dist_cmd&lt;/code&gt; 之一，具体取决于正在执行的驱动程序回调。</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">如果发现 &lt;code&gt;property_parm()&lt;/code&gt; 作为输入（ &lt;code&gt;SDP&lt;/code&gt; ）的一部分，则将其保持不变。</target>
        </trans-unit>
        <trans-unit id="85b487c95345f7250096baeb7f6ceb5385465d9a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pwdfun&lt;/code&gt; is defined, that one is called and the returned boolean is the authentication result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;relup&lt;/code&gt; 文件和/或名为 &lt;code&gt;sys.config&lt;/code&gt; 的系统配置文件或 &lt;code&gt;sys.config.src&lt;/code&gt; ，则这些文件也将包含在发行包中。请参阅 &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">如果出现&lt;strong&gt;滴答声&lt;/strong&gt;，即连接另一端的Erlang节点已轮询该节点以查看其是否仍然存在，则该函数返回 &lt;code&gt;ERL_TICK&lt;/code&gt; 且缓冲区中未放置任何消息。同样， &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EAGAIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">如果出现&lt;strong&gt;滴答声&lt;/strong&gt;，即连接另一端的Erlang节点已轮询该节点以查看其是否仍在运行，则该函数返回 &lt;code&gt;ERL_TICK&lt;/code&gt; ,指示已接收并响应了滴答声，但未放置任何消息在缓冲区中。在这种情况下，您将再次调用 &lt;code&gt;erl_receive_msg()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="688f42cde6aa17e471ac615786a4c6b4015e0179" translate="yes" xml:space="preserve">
          <source>If a URI component has a character that is not allowed, it will be percent-encoded when the URI is produced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">如果将二进制文件作为消息发送到进程或端口，则该二进制文件将缩小，并且任何进一步的追加操作会将二进制数据复制到新的二进制文件中。例如，在下面的代码片段中， &lt;code&gt;Bin1&lt;/code&gt; 将被复制到第三行：</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">如果二进制文件引用了较大的二进制文件（通常描述为子二进制文件），则获取所引用二进制文件的大小可能很有用。可以在程序中使用此功能来触发 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; 的使用。通过复制二进制文件，可以取消引用原始的（可能是较大的）二进制文件，而较小的二进制文件将对其进行引用。</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">如果将调用添加到此函数（例如在模块 &lt;code&gt;m1&lt;/code&gt; 中)，则如果首先加载新版本的 &lt;code&gt;m1&lt;/code&gt; 并在加载新版本的 &lt;code&gt;ch3&lt;/code&gt; 之前调用 &lt;code&gt;ch3:available/0&lt;/code&gt; ，则在发行升级期间可能会发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">如果回调(在TFTP服务器中执行文件访问)需要的时间太长(超过TFTP的双倍超时),服务器就会中止连接,并向客户端发送一个错误回复。这意味着服务器比以前更快地释放连接上的资源。服务器只是认为客户端已经放弃了。</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">如果回调函数失败或返回错误值，则 &lt;code&gt;gen_server&lt;/code&gt; 进程终止。</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">如果回调函数失败或返回错误值，除非另有说明，否则 &lt;code&gt;gen_statem&lt;/code&gt; 终止。但是，类 &lt;code&gt;throw&lt;/code&gt; 的异常不被视为错误，而是所有回调函数的有效返回。</target>
        </trans-unit>
        <trans-unit id="cb6c6d4e44bcb4f44a78613ffcfcc49d8fc1ed0e" translate="yes" xml:space="preserve">
          <source>If a carrier employed by a foreign allocator becomes empty, it will be passed back to the owner for deallocation using the delayed dealloc functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4900c7b9d94d3b64a0cfc23cc79861beaa9067fc" translate="yes" xml:space="preserve">
          <source>If a carrier in the pool becomes empty, it will be withdrawn from the pool and be deallocated by the owner which already employs it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">如果一个子进程终止,其他所有的子进程都会被终止,然后包括被终止的子进程在内的所有子进程都会被重新启动。</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">如果一个子进程终止,只有该进程被重新启动。</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">如果一个子进程终止,其余的子进程(也就是按启动顺序排在终止进程之后的子进程)就会被终止。然后,终止的子进程和其余的子进程被重新启动。</target>
        </trans-unit>
        <trans-unit id="d930d204b5a28f5ad0b963925f58f75368275cfb" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to a TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">如果客户端和服务器想要使用升级机制,比如RFC 2817定义的升级机制,将普通的TCP/IP连接升级为TLS连接,那么Erlang SSL应用API就支持这个机制。这对于在同一端口上支持HTTP和HTTPS以及实现虚拟主机等都很有用。注意这只是TLS功能。</target>
        </trans-unit>
        <trans-unit id="6fb7903555258379fa86ef3cac0cdacd6a86b7aa" translate="yes" xml:space="preserve">
          <source>If a client is started (ssh:connect et al), the environment variable &lt;code&gt;client_options&lt;/code&gt; is used. Similarly for a daemon the &lt;code&gt;server_options&lt;/code&gt; variable is handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">如果客户端发送了多个限制服务器响应权限的头字段，则标准未指定如何处理。 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 按以下顺序控制每个字段，如果其中一个字段与当前状态不匹配，则请求将被拒绝并给出适当的响应：</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">如果外壳无法识别命令（本地函数调用），则首先尝试在 &lt;code&gt;user_default&lt;/code&gt; 模块中找到可以放置自定义本地命令的函数。如果找到，则对函数进行评估，否则尝试在模块 &lt;code&gt;shell_default&lt;/code&gt; 中评估该函数。必须明确加载模块 &lt;code&gt;user_default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">如果存在选择 &lt;code&gt;encoding&lt;/code&gt; 的注释，则该注释可以位于第二行。</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">如果完整的系统由无磁盘和/或只读客户机节点组成，则将 &lt;code&gt;clients&lt;/code&gt; 目录添加到 &lt;code&gt;$ROOT&lt;/code&gt; 目录中。只读节点是具有只读文件系统的节点。</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">如果将具有较大窗口大小的压缩流指定为输入，则 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 会引发 &lt;code&gt;data_error&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">如果一个已经匹配的子模式的条件测试指的是一个非唯一的数字,那么如果该数字的任何一个子模式已经匹配,则测试为真。</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">如果在多个文件中定义了配置变量，并且您想访问所有可能的值，请使用函数 &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; 并在选项列表中指定 &lt;code&gt;all&lt;/code&gt; 变量。然后，这些值将以列表形式返回，并且元素的顺序与启动时指定配置文件的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">如果在多个文件中定义了配置变量，请使用选项 &lt;code&gt;all&lt;/code&gt; 访问所有可能的值。这些值将在列表中返回。元素的顺序与启动时指定配置文件的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">如果配置变量键已与名称关联（通过 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 语句），则可以使用名称代替键来读取值：</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">如果连接尝试失败,可以检查以下内容。</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">如果在执行此指令后发生崩溃，则系统将无法恢复并从旧发行版重新启动。该指令只能在脚本中出现一次。它应放置在所有 &lt;code&gt;load_object_code&lt;/code&gt; 指令之后。</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">如果发生碰撞，一个 &lt;code&gt;erl_crash.dump&lt;/code&gt; 是&lt;strong&gt;不&lt;/strong&gt;写，除非环境变量 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 是集：</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">如果安装了定制CLI（请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; ），则上述规则将替换为定制CLI所暗示的思想。</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">如果指定了默认对象 &lt;code&gt;Default&lt;/code&gt; ，则在表中缺少键时，它将用作要更新的对象。代替键的值将被忽略，并由正确的键值代替。返回值就像未使用默认对象一样，即单个更新的元素或它们的列表。</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">如果目录同时受HTTP服务器配置文件中的身份验证指令和 &lt;code&gt;htaccess&lt;/code&gt; 文件的限制，则两种方法都必须允许用户访问该文件，请求才能成功。</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">如果发生灾难并且 &lt;code&gt;Mnesia&lt;/code&gt; 数据库已损坏，则可以从备份中重建它。将此作为万不得已的方法，因为备份中包含旧数据。希望数据是一致的，但是当使用旧备份还原数据库时，数据肯定会丢失。</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">如果无盘和/或只读客户端节点将要启动，则文件 &lt;code&gt;start_erl.data&lt;/code&gt; 位于主节点的客户端目录中。因此， &lt;code&gt;START_ERL_DATA&lt;/code&gt; 行如下所示：</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">如果无盘和/或只读客户端节点与SASL配置参数 &lt;code&gt;static_emulator&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 即将启动，将 &lt;code&gt;-boot&lt;/code&gt; 和 &lt;code&gt;-config&lt;/code&gt; 标志必须改变。</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">如果使用的是功能型驱动(就是不持有任何状态,只是做一些繁重的计算和返回结果),可以事先打开几个注册名称的端口,根据调度器ID选择要使用的端口,如下图。</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">如果在R13A或以后的版本中增加了某个功能,则会在文中提及。</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">如果指定一个文件名作为参数,Debugger会尝试从这个文件中加载其设置。有关设置的详细信息,请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">如果某个过滤器或处理程序仍然崩溃,Logger 将从配置中删除相关的过滤器或处理程序,并向终端打印一条简短的错误信息。还会发出一个包含崩溃原因和其他细节的调试事件。</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">如果在尝试注册乐趣时已经注册了乐趣，则返回 &lt;code&gt;{error, exists}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">如果将一个函数指定为输入，并且最后一个输入函数返回 &lt;code&gt;{end_of_input, Value}&lt;/code&gt; ，则指定为输出的函数将使用参数 &lt;code&gt;{value, Value}&lt;/code&gt; 调用。这样就很容易用输入函数计算出的值来初始化输出函数的序列。</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">如果系统中的垃圾回收导致分配的堆大小至少为 &lt;code&gt;Size&lt;/code&gt; 字 &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; 将消息{monitor，GcPid，large_heap，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;GcPid&lt;/code&gt; 和 &lt;code&gt;Info&lt;/code&gt; 与先前的 &lt;code&gt;long_gc&lt;/code&gt; 相同，除了不存在带有 &lt;code&gt;timeout&lt;/code&gt; 标记的元组。</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">如果系统中的垃圾回收至少花费了 &lt;code&gt;Time&lt;/code&gt; 墙上时钟毫秒 &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; 一条消息{monitor，GcPid，long_gc，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;GcPid&lt;/code&gt; 是被垃圾回收的pid。 &lt;code&gt;Info&lt;/code&gt; 是一个由两个元素组成的元组的列表，描述了垃圾回收的结果。</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">如果给定的模块不是Cover编译的，则由错误原因 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">如果组包含子组，则还可以在组元组中指定这些组的执行属性： &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; 其中， &lt;code&gt;SubGroups&lt;/code&gt; 是元组列表， &lt;code&gt;{GroupName,Properties}&lt;/code&gt; 或 &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; 代表子组。在&amp;ldquo; &lt;code&gt;group/0&lt;/code&gt; 为组定义的，未在&amp;ldquo; &lt;code&gt;SubGroups&lt;/code&gt; 列表中指定的任何子组都将使用其预定义的属性执行。</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">如果组具有并行属性，则同时生成其测试用例并并行执行。但是，不允许一个测试用例与 &lt;code&gt;end_per_group/2&lt;/code&gt; 并行执行，这意味着执行并行组的时间等于该组中最慢的测试用例的执行时间。并行运行测试用例的负面影响是，直到该组的功能 &lt;code&gt;end_per_group/2&lt;/code&gt; 完成，HTML摘要页面才会使用指向各个测试用例日志的链接进行更新。</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">如果与当前配置相比删除了一个键,并且记录仪知道该键,则使用默认值。如果是自定义键,那么是删除该值还是插入默认值,则由处理程序实现。</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">如果与当前配置相比,删除一个键,则使用默认值。</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">如果给出 &lt;code&gt;ModFiles&lt;/code&gt; 列表作为输入，则将返回 &lt;code&gt;Result&lt;/code&gt; 列表。返回列表的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如果在 &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; 中使用了标识符列表：</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">如果本地函数与自动导入的BIF具有相同的名称，则语义是隐式限定的函数调用将定向到本地定义的函数，而不是BIF。为避免混淆，有一个可用的编译器指令 &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; ，该指令不会自动导入BIF。在某些情况下，这样的编译指令是强制性的。</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">如果日志事件通过特定处理程序的所有主过滤器和所有处理程序过滤器，则Logger会将事件转发到&lt;strong&gt;处理程序回调&lt;/strong&gt;。处理程序将事件格式化并打印到其目的地。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">如果将日志配置为分发，则可能未在所有节点上记录所有项目。 &lt;code&gt;wrap_log_reader&lt;/code&gt; 只读取被调用节点上的日志。用户应确保已阅读所有项目。</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">如果具有指定名称的日志在某个节点上是本地的，并且试图打开分布在同一节点上的日志，则返回元组 &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; 。如果日志分布在某个节点上，则返回相同的元组，并且尝试在同一节点上本地打开日志。首次打开单个分布式磁盘日志时，会将这些日志添加到（可能为空）分布式磁盘日志中。所提供的选项值可用于option &lt;code&gt;distributed&lt;/code&gt; 提到的所有节点上。单个分布式日志对彼此的选项值一无所知，因此可以通过创建一个分布式日志来给每个节点唯一的选项值，该分布式日志包含对 &lt;code&gt;open/1&lt;/code&gt; 的多次调用。</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">如果一个宏在多个模块中使用,建议将宏定义放在一个include文件中。</target>
        </trans-unit>
        <trans-unit id="0bac8e18db1d29ae2b7dd77be807faeccb09df3e" translate="yes" xml:space="preserve">
          <source>If a match specification (applicable only for &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; tracing) contains a &lt;code&gt;{message}&lt;/code&gt; action function with a non-boolean value, that value is added as an extra element to the message tuple either in the last position or before the timestamp (if it is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0e324c5eb502ceba59e0414f16795091f6741d" translate="yes" xml:space="preserve">
          <source>If a match specification passed as argument has excessive nesting which causes scheduler stack exhaustion for the scheduler that the calling process is executing on. &lt;code&gt;Scheduler stack size&lt;/code&gt; can be configured when starting the runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">如果匹配失败，则在某些情况下仍应接受证书。例如，以您选择接受过期证书的Web浏览器为例。此选项可启用此功能。这个 &lt;code&gt;fun/1&lt;/code&gt; 被调用时没有 &lt;code&gt;ReferenceID&lt;/code&gt; 匹配。fun的返回值（ &lt;code&gt;boolean()&lt;/code&gt; ）决定结果。如果为 &lt;code&gt;true&lt;/code&gt; ，则证书被接受，否则被拒绝。请参阅 &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; 用户指南》中的&amp;ldquo;固定&amp;rdquo;证书。</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">如果成员终止,则会自动从组中删除。</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">如果在 &quot;虚拟 &quot;连接建立之前收到消息,连接将自动建立。MGC可以真正的开放,根据传输层接触的方式,动态决定使用哪种编码和传输服务。对于IP传输来说,有两个端口是标准化的,一个用于文本编码,一个用于二进制编码。例如在文本端口上收到一个UDP数据包,就可以在飞行中决定编码和传输。</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">如果模块不是Cover编译的，则由错误原因 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">如果模块是从 &lt;code&gt;.beam&lt;/code&gt; 文件编译而来的，即使用 &lt;code&gt;compile_beam/1&lt;/code&gt; 或 &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; ，则假定可以在与 &lt;code&gt;.beam&lt;/code&gt; 文件相同的目录中找到源代码，相对于 &lt;code&gt;../src&lt;/code&gt; 到该目录，或使用 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 中的源路径。使用后者时，将检查两条路径：首先是通过连接 &lt;code&gt;../src&lt;/code&gt; 和在尾随 &lt;code&gt;src&lt;/code&gt; 组件下方的已编译路径的尾部构造的路径，然后是已编译路径本身。如果未找到源代码，则由错误原因 &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">如果一个监控进程变得如此之大,以至于自己在垃圾收集时开始引起系统监控消息,这些消息扩大了进程消息队列,很可能使问题变得更糟。</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">如果进行了更复杂的更改（例如，更改 &lt;code&gt;gen_server&lt;/code&gt; 内部状态的格式），则简单的代码替换是不够的。相反，必须：</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">如果发生名称冲突，则编译器将报告 &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; 消息，该消息表明是否重命名了定义以及必须用于编码/解码数据的新名称。</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Files&lt;/code&gt; 中的名称不是现有文件的名称，则Igor会假定它代表模块名称，并尝试查找和读取相应的源文件。解析的文件被附加到 &lt;code&gt;Sources&lt;/code&gt; 并传递到 &lt;code&gt;merge_sources/3&lt;/code&gt; ，即 &lt;code&gt;Sources&lt;/code&gt; 中的条目在从文件读取条目之前被列出。</target>
        </trans-unit>
        <trans-unit id="5f3d40f62d554584090ae4d71b42895c212400c3" translate="yes" xml:space="preserve">
          <source>If a name is given by a single atom, it should either be a &quot;simple&quot; atom which does not need to be single-quoted in Erlang, or otherwise its print name should correspond to a proper Erlang variable, i.e., begin with an uppercase character or an underscore. Names on the form &lt;code&gt;{A, N}&lt;/code&gt; represent function name variables &quot;&lt;code&gt;A/N&lt;/code&gt;&quot;; these are special variables which may be bound only in the function definitions of a module or a &lt;code&gt;letrec&lt;/code&gt;. They may not be bound in &lt;code&gt;let&lt;/code&gt; expressions and cannot occur in clause patterns. The atom &lt;code&gt;A&lt;/code&gt; in a function name may be any atom; the integer &lt;code&gt;N&lt;/code&gt; must be nonnegative. The functions &lt;code&gt;c_fname/2&lt;/code&gt; etc. are utilities for handling function name variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">如果使用与现有记录相同的键插入新项，则旧记录将被覆盖。但是，如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ，则每个键都可以映射到多个记录。类型 &lt;code&gt;bag&lt;/code&gt; 表中的所有记录都是唯一的，只有密钥可以重复。</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">如果引入新模块,则使用以下指令。</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">如果一个节点在脏操作过程中宕机,表加载机制会确保更新在所有副本上执行,或者不执行。异步脏更新和同步脏更新都使用与轻量级事务相同的恢复原理。</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">如果某个节点发生故障，则将删除与该节点的所有连接。调用 &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; 强制断开节点连接。</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">如果启动了一个节点，该节点根据 &lt;code&gt;distributed&lt;/code&gt; 优先级高于运行分布式应用程序的节点，则该应用程序将在新节点处重新启动，并在旧节点处停止。这称为&lt;strong&gt;收购&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bc63ca0578b8d746c309ca79e6507b21130aadd5" translate="yes" xml:space="preserve">
          <source>If a particular clause can be selected, the function returns &lt;code&gt;{true, {Clause, Bindings}}&lt;/code&gt;, where &lt;code&gt;Clause&lt;/code&gt; is the selected clause and &lt;code&gt;Bindings&lt;/code&gt; is a list of pairs &lt;code&gt;{Var, SubExpr}&lt;/code&gt; associating the variables occurring in the patterns of &lt;code&gt;Clause&lt;/code&gt; with the corresponding subexpressions in &lt;code&gt;Exprs&lt;/code&gt;. The list of bindings is given in innermost-first order; see the &lt;code&gt;match/2&lt;/code&gt; function for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">如果使用选项 &lt;code&gt;extended&lt;/code&gt; 编译模式，则模式中的空格（字符类中的字符除外）以及字符类外部的＃与下一个换行符之间的字符将被忽略。转义的反斜杠可用于在模式中包含空格或＃字符。</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">如果模式以。*或。{0，}开头，并且设置了 &lt;code&gt;dotall&lt;/code&gt; 选项（等效于Perl选项 &lt;code&gt;/s&lt;/code&gt; ），从而允许该点与换行符匹配，则该模式将隐式锚定，因为以下内容将针对每个字符位置进行尝试在主题字符串中。因此，在第一个位置之后的任何位置重试整个比赛都没有意义。PCRE通常将模式视为\ A开头。</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">如果模式以 &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; 开头，则其作用与在编译时设置选项 &lt;code&gt;no_start_optimize&lt;/code&gt; 的作用相同。</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">如果一个永久的应用程序终止,所有其他应用程序和整个Erlang节点也会被终止。</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">如果一个永久应用程序终止,所有其他应用程序和运行时系统也会被终止。</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">如果将端口放入运行队列或从运行队列中删除 &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; ，则会向 &lt;code&gt;ProfilerPid&lt;/code&gt; 发送一条消息{profile，Port，State，0，Ts}。</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">如果一个包含一个或多个捕获子模式的正断言成功了,但在模式的后面未能匹配导致在这个断言上回溯,那么只有在没有更高编号的捕获已经被设置的情况下,断言内的捕获才会被重置。不幸的是,这是当前实现的一个基本限制,而且由于PCRE1现在只处于维护状态,所以不太可能改变。</target>
        </trans-unit>
        <trans-unit id="9cb8ee97edf59cd0007ed1238bc9ac0388e87e9d" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">如果需要预设字典来进一步解压缩，则此函数返回 &lt;code&gt;need_dictionary&lt;/code&gt; 元组。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">如果某个进程在未先设置种子的情况下调用了 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; ,则将自动调用 &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">如果某个进程在没有先设置种子的情况下调用了 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; ，则使用默认算法自动调用 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; ，并创建一个非恒定种子。</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">如果加载了驱动程序的进程死亡,则与卸载时的效果相同。</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">如果在系统中的处理被暂停，因为它发送到一个繁忙的港口，消息 &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; 被发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;SusPid&lt;/code&gt; 是发送到 &lt;code&gt;Port&lt;/code&gt; 时挂起的pid 。</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">如果系统中的某个进程由于发送到远程节点上的某个进程而挂起，则该节点的节点间通信已由繁忙端口处理，则消息 &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; 发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;SusPid&lt;/code&gt; 是通过节点间通信端口 &lt;code&gt;Port&lt;/code&gt; 发送时挂起的pid 。</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">如果将某个进程放入或从运行队列中删除，则将 &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; 发送到 &lt;code&gt;ProfilerPid&lt;/code&gt; 。被抢占后重新插入到运行队列中的正在运行的进程不会触发此消息。</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">如果系统中的进程或端口至少在 &lt;code&gt;Time&lt;/code&gt; 墙上时钟毫秒内未中断运行 &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; 消息{monitor，PidOrPort，long_schedule，Info}发送到 &lt;code&gt;MonitorPid&lt;/code&gt; 。 &lt;code&gt;PidOrPort&lt;/code&gt; 是正在运行的进程或端口。 &lt;code&gt;Info&lt;/code&gt; 是描述事件的包含两个元素的元组的列表。</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">如果一个进程只是简单地保留二进制文件(无论是在 &quot;循环数据 &quot;中还是在进程字典中),垃圾收集器最终可以收缩这些二进制文件。如果只保留一个这样的二进制,它将不会被收缩。如果进程后来追加到一个被收缩的二进制,二进制对象将被重新分配,以给要追加的数据腾出位置。</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">如果持有锁的进程死亡,或者节点宕机,该进程持有的锁就会被删除。</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">如果一个注册了名字的进程死亡,或者节点宕机,该名字在所有节点上都会被取消注册。</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">如果在执行 &lt;code&gt;init_per_suite/1&lt;/code&gt; 的过程中产生了进程 &lt;code&gt;P&lt;/code&gt; ，则它会继承 &lt;code&gt;init_per_suite&lt;/code&gt; 进程的组长。该组负责人是前面提到的中央I / O服务器进程。如果稍后&lt;strong&gt;在并行测试用例执行期间&lt;/strong&gt;，某个事件触发进程 &lt;code&gt;P&lt;/code&gt; 调用 &lt;code&gt;io:format/1/2&lt;/code&gt; ，则该调用永不返回（因为组长处于非响应状态）并导致 &lt;code&gt;P&lt;/code&gt; 挂起。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bf8390a7e5daa53c1c72aaa18283abc83275ce3" translate="yes" xml:space="preserve">
          <source>If a public key is used for logging in, there is normally no checking of the user name. It could be enabled by setting the option &lt;code&gt;&lt;a href=&quot;ssh#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. In that case the pwdfun will get the atom &lt;code&gt;pubkey&lt;/code&gt; in the password argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">设置无大小写匹配时，如果使用包含字母的范围，则在两种情况下都将匹配字母。例如，[Wc]等效于[] [\\ ^ _`wxyzabc]，不区分大小写。在非UTF模式下，如果使用的是法语语言环境的字符表，则在两种情况下[\ xc8- \ xcb]都匹配带重音符号的E字符。在UTF模式下，PCRE仅在使用Unicode属性支持进行编译时才支持大小写大于255的字符的大小写概念。</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">如果收到的消息包含多个事务请求，则此选项指示是应在同一进程中按顺序处理请求（ &lt;code&gt;false&lt;/code&gt; ），还是应由自己的进程处理每个请求（为 &lt;code&gt;true&lt;/code&gt; ,即为每个请求派生一个单独的进程） 。</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">如果一条记录卡在节点 &lt;code&gt;N1&lt;/code&gt; 上,并且您尝试为该节点 &lt;code&gt;N2&lt;/code&gt; 上的记录设置粘滞锁，则该记录必须是未粘住的。此操作很昂贵，并且会降低性能。如果在 &lt;code&gt;N2&lt;/code&gt; 发出 &lt;code&gt;s_write/1&lt;/code&gt; 请求，则自动执行取消粘帖操作。</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">如果一个记录在多个模块中使用,建议将记录定义放在一个include文件中。</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">如果发生可恢复的错误，该函数将返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ,并且将恢复原始应用程序规范。如果发生不可恢复的错误，则系统将重新启动。</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">如果经常性核心转储想，让 &lt;code&gt;heart&lt;/code&gt; 通过kill信号设置为中止使用环境变量知道 &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; 。如果未设置或未设置为 &lt;code&gt;SIGABRT&lt;/code&gt; ，则默认行为是使用 &lt;code&gt;SIGKILL&lt;/code&gt; 的终止信号：</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">如果在带有 &lt;code&gt;ebin&lt;/code&gt; 子目录的代码路径中存在一个名为 &lt;code&gt;Name&lt;/code&gt; 或 &lt;code&gt;Name-Vsn&lt;/code&gt; 的常规目录，则返回此目录的路径（不是 &lt;code&gt;ebin&lt;/code&gt; 目录）。</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">如果没有及时收到请求的回复,megaco栈会从它的表中删除所有关于请求的信息。如果在这之后才收到回复,那么应用程序就无法知道该把这个消息发送到哪里。通过在本地节点(拥有链接的节点)上调用这个函数,消息就会被传递给 &quot;用户&quot;。</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">如果创建了一行，我们总是将内部列设置为 &lt;code&gt;&quot;internal&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bcc6cd834e1b61a016a579e0ab9636b50732f34" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调度程序无法绑定，则通常会默默地忽略它，因为并非总是可能验证有效的逻辑处理器标识符。如果报告错误，则会记录一个错误事件。要验证调度程序是否已按要求绑定，请调用 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a0818c4665c47cbb9e80ed0764a80aff0ec1b7a" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调度程序无法绑定，则通常会默默地忽略它，因为并非总是可能验证有效的逻辑处理器标识符。如果报告了错误，则将其报告给 &lt;code&gt;error_logger&lt;/code&gt; 。如果要验证调度程序是否已按要求绑定，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">如果调度程序进入睡眠或唤醒 &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; 向 &lt;code&gt;ProfilerPid&lt;/code&gt; 发送一条消息{profile，scheduler，Id，State，NoScheds，Ts}。</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">如果一个调度器线程每纳秒创建一个新的引用,引用最早将在超过584年后被重复使用。也就是说,在可预见的未来,它们是足够唯一的。</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">如果找到脚本，则第一件事就是根据属于发行版本 &lt;code&gt;Vsn&lt;/code&gt; 的 &lt;code&gt;.app&lt;/code&gt; 文件和 &lt;code&gt;sys.config&lt;/code&gt; 更新应用程序规范。</target>
        </trans-unit>
        <trans-unit id="332eeb8191104a7c5c740b708710a7e691d869fa" translate="yes" xml:space="preserve">
          <source>If a shell service request arrives to the server, an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">如果重复洗牌的测试用例组,轮次之间不重置种子。</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">如果对功能模块进行了简单扩展，则足以将模块的新版本加载到系统中，并删除旧版本。这称为&lt;strong&gt;简单代码替换&lt;/strong&gt;，为此使用以下指令：</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">如果以某种方式连接了套接字而不使用 &lt;code&gt;gen_tcp&lt;/code&gt; ，请使用此选项传递文件描述符。</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">如果以某种方式连接了套接字而不使用 &lt;code&gt;gen_tcp&lt;/code&gt; ，请使用此选项传递文件描述符。如果将 &lt;code&gt;{ip, Address}&lt;/code&gt; 和/或 &lt;code&gt;{port, port_number()}&lt;/code&gt; 与该选项结合使用，则在连接前将 &lt;code&gt;fd&lt;/code&gt; 绑定到指定的接口和端口。如果未指定这些选项，则假定 &lt;code&gt;fd&lt;/code&gt; 已被适当绑定。</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">如果不使用 &lt;code&gt;gen_udp&lt;/code&gt; 就以某种方式打开了套接字，请使用此选项传递文件描述符。如果 &lt;code&gt;Port&lt;/code&gt; 未设置为 &lt;code&gt;0&lt;/code&gt; 和/或 &lt;code&gt;{ip, ip_address()}&lt;/code&gt; 与该选项结合使用，则 &lt;code&gt;fd&lt;/code&gt; 在打开后将绑定到指定的接口和端口。如果未指定这些选项，则假定 &lt;code&gt;fd&lt;/code&gt; 已被适当绑定。</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">如果已经连接了套接字，则可以使用选项 &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; 将打开的文件描述符传递给 &lt;code&gt;gen_udp&lt;/code&gt; 。这可以通过使用命令行参数自动说明预绑定文件描述符号来实现。例如，如果端口为69，并且文件描述符22由 &lt;code&gt;setuid_socket_wrap&lt;/code&gt; 打开，则命令行参数&amp;ldquo; -tftpd_69 22&amp;rdquo;将触发使用预绑定文件描述符22而不是打开端口69。UDP选项 &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; 自动添加。有关命令行参数，请参见 &lt;code&gt;init:get_argument/&lt;/code&gt; 有关UDP选项，请参见 &lt;code&gt;gen_udp:open/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">如果在具有 &lt;code&gt;shuffle&lt;/code&gt; 属性的组中指定了一个子组，则该子组相对于该组中的测试用例（和其他子组）的执行顺序是随机的。但是，子组中测试用例的顺序不是随机的（除非子组具有 &lt;code&gt;shuffle&lt;/code&gt; 属性）。</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">如果完成了从进程到端口的同步调用，则在对端口的调用运行时期间，该调用进程被视为不可运行。调用进程被通知为 &lt;code&gt;inactive&lt;/code&gt; ，后来 &lt;code&gt;active&lt;/code&gt; 当端口回调的回报。</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ，则有时可能需要删除具有特定键的某些记录。这可以通过 &lt;code&gt;delete_object/3&lt;/code&gt; 函数来完成。必须为此功能提供完整的记录。</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">如果表的类型为 &lt;code&gt;set&lt;/code&gt; ，则每个键都将导致一个或零个记录。</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">如果一个临时申请终止,会被报告,但没有其他申请被终止。</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">如果终端符号是类别的唯一成员，并且符号名称与类别名称相同，则标记格式可以为 &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">如果属于一个组的测试用例(根据组定义)在没有组规范的情况下被执行,也就是说,只是通过(使用命令行)。</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果测试用例失败，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果跳过测试用例，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">如果测试用例需要暂停自己的时间，并且该时间也 &lt;code&gt;multiply_timetraps&lt;/code&gt; multiple_timetraps （并且如果启用了 &lt;code&gt;scale_timetraps&lt;/code&gt; ,则可能还会放大），则可以使用功能 &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; （而不是例如 &lt;code&gt;timer:sleep/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">如果该模块的第三个实例被加载,代码服务器会删除(清除)旧的代码,并终止任何滞留在其中的进程。然后第三个实例变成 &quot;当前&quot;,之前的当前代码变成 &quot;旧&quot;。</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">如果模块的第三个实例被加载,代码服务器会删除(清除)旧的代码,并终止任何滞留在其中的进程。然后第三个实例变成 &quot;当前&quot;,之前的当前代码变成 &quot;旧&quot;。</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">如果一个线程已经在工作,则调用会排队并按顺序执行。对每个驱动实例使用相同的线程可以确保调用按顺序进行。</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">如果线程池可用，则使用线程。如果参数 &lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，则以循环方式使用池中的线程，每次对 &lt;code&gt;driver_async&lt;/code&gt; 的调用都使用池中的下一个线程。设置参数 &lt;code&gt;key&lt;/code&gt; ，此行为将更改。 &lt;code&gt;*key&lt;/code&gt; 的两个相同值始终获得相同的线程。</target>
        </trans-unit>
        <trans-unit id="2ae4841a41da1bafc39b445eb14fcf5adc83b911" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;0&lt;/code&gt; it will actually not be started. Instead the time-out event will immediately be inserted to be processed after any events already enqueued, and before any not yet received external events. Note that some time-outs are automatically cancelled so if you for example combine &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponing&lt;/a&gt;&lt;/code&gt; an event in a &lt;strong&gt;state change&lt;/strong&gt; with starting an &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;event time-out&lt;/a&gt;&lt;/code&gt; with time &lt;code&gt;0&lt;/code&gt; there will be no time-out event inserted since the event time-out is cancelled by the postponed event that is delivered due to the state change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed3fc97d55d4fa64719146d29086a7ad193da5e" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;infinity&lt;/code&gt; it will never time out, in fact it will not even be started, and any running time-out with the same tag will be cancelled. The &lt;code&gt;EventContent&lt;/code&gt; will in this case be ignored, so why not set it to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果在本地节点上运行跟踪端口（请参见 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ），则无法使用跟踪器进程跟踪远程节点。返回错误原因 &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; 。但是，可以使用 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 功能在远程节点上启动跟踪端口。</target>
        </trans-unit>
        <trans-unit id="be4166c81b6aa45a3706a93a3be13529c5b52b9c" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes cannot be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">如果在两个列表中都指定了跟踪器,则优先使用启用列表中的跟踪器。如果没有指定tracer,则使用与执行匹配规范的进程相同的tracer(不是元tracer)。如果该进程也没有 tracer,则忽略跟踪标志。</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">如果一个事务涉及到不对称复制的表的更新或模式表的更新,就会使用重磅提交协议。无论表是如何复制的,这个协议都可以完成事务。重磅事务的典型用途是当一个副本要从一个节点移动到另一个节点时。然后确保复制本要么完全被移动,要么保持原样。千万不要最后出现两个节点上都有副本,或者根本没有节点的情况。即使一个节点在提交协议中间崩溃,也必须保证事务是原子的。与轻量级协议相比,重量级提交协议涉及到事务协调器和参与者之间更多的消息,而且它在启动时执行恢复工作,以完成终止或提交工作。</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">如果交易异常终止， &lt;code&gt;Mnesia&lt;/code&gt; 会自动释放该交易持有的锁。</target>
        </trans-unit>
        <trans-unit id="ddb095e9f47a7e392a2d545f1d0433b6aff3499a" translate="yes" xml:space="preserve">
          <source>If a transformation rule matched, the loader applies the transformation rules again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">如果一个瞬态应用异常终止,所有其他应用和整个Erlang节点也会被终止。</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">如果瞬态应用程序因 &lt;code&gt;Reason == normal&lt;/code&gt; 终止，则会报告此情况，但不会终止其他应用程序。</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">如果瞬态应用程序以 &lt;code&gt;normal&lt;/code&gt; 理由终止，则将报告此情况，但不会终止其他应用程序。如果瞬态应用程序异常终止（除 &lt;code&gt;normal&lt;/code&gt; 原因外），则所有其他应用程序和运行时系统也会终止。</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">如果每一纳秒都会产生一个唯一的整数,那么唯一的整数最早将在584年以上后被重复使用。也就是说,在可预见的未来,它们足够独特。</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">如果用户只想运行一个测试套件的子集,那么一个测试用例就不可能成功地依赖于另一个测试用例。</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">如果未将对象的值提供给 &lt;code&gt;send_notification&lt;/code&gt; 函数，则子代理将执行获取操作以检索它。如果未在此子代理程序中实现对象，则其父代理程序将尝试执行get操作来检索它。如果该对象也未在此代理中实现，则它将对象转发给其父对象，依此类推。最终到达主代理，此时必须解析所有未知的对象值。如果某个对象甚至是主代理都不知道，则将其视为错误，并通过调用错误报告模块的 &lt;code&gt;user_err/2&lt;/code&gt; 进行报告。在这种情况下，不会发送任何通知。</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">如果通知中的变量是表元素，则该元素的 &lt;code&gt;RowIndex&lt;/code&gt; 必须在 &lt;code&gt;Varbinds&lt;/code&gt; 列表中给出。在这种情况下，通知中发送的OBJECT IDENTIFIER是标识此元素的OBJECT IDENTIFIER。此对象标识符可在以后的get操作中使用。</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">如果在一个为真的正断言中遇到一个带名字的动词,如果是最后遇到的名字,则会被记录下来并传回。这不会发生在消极断言或失败的积极断言中。</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">如果一个词是SMIv1或SMIv2中的任何一个关键字,那么它就是编译器中的关键字(只偏离SMIv1)。</target>
        </trans-unit>
        <trans-unit id="626f4bf2cfcfd59884034c767d316b8382a2cf65" translate="yes" xml:space="preserve">
          <source>If all above checks passed both &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt; Bloom filters are checked to detect if binder was already seen. Being a probabilistic data structure, false positives can occur and they trigger a full handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">如果一切顺利，则返回 &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; ，其中 &lt;code&gt;ResultOfFun&lt;/code&gt; 是 &lt;code&gt;Fun&lt;/code&gt; 中最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">如果一个模式的所有选项都以\G开头,那么这个表达式就会被锚定在起始匹配位置,并且在编译后的正则表达式中设置了 &quot;anchored &quot;标志。</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">如果找到 &lt;code&gt;.erlang&lt;/code&gt; 文件，则假定它包含有效的Erlang表达式。这些表达式的计算方式就像它们是输入到外壳程序一样。</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 分配器已禁用。</target>
        </trans-unit>
        <trans-unit id="09d966cba699040070b071c5c784aefbdf8752e2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, connection loss, or an improper &lt;code&gt;Nodes&lt;/code&gt; list), the caller will not receive any further information about the result if/when the applied function completes. If the applied function communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">如果将I / O设备设置为二进制模式，则函数 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 可以返回二进制文件而不是列表。从Erlang / OTP R13A开始，二进制文件以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">如果I / O服务器遇到无法识别的请求（即 &lt;code&gt;io_request&lt;/code&gt; 元组具有预期的格式，但是 &lt;code&gt;Request&lt;/code&gt; 未知），则I / O服务器将发送带有错误元组的有效回复：</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">如果一个MIB对象实例正好属于一个子树,那么根据该条目的类型,该实例将被包含在相关的MIB视图中,或者被排除在该视图之外。</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">如果一个MIB对象实例属于一个以上的子树,那么就使用由最多子标识符组成的子树,并且在词法上是最大的子树。</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">如果一个MIB对象实例不属于任何相关的子树,那么该实例就不在MIB视图中。</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">如果algs_list()中缺少一个alg_entry(),则对该条目使用默认值。</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">如果一个算法名称在列表中出现一次以上,则行为未定义。属性列表中的标记也被认为最多出现一次。</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">如果在处理请求时进行的应用程序回调失败（pick_peer，prepare_request，prepare_retransmission，handle_answer或handle_error），则根据是否尝试发送请求返回 &lt;code&gt;{error,encode}&lt;/code&gt; 或 &lt;code&gt;{error,failure}&lt;/code&gt; 在运输中。</target>
        </trans-unit>
        <trans-unit id="9bc38fb01d5bf31a73055c19a3816c95b41bcc62" translate="yes" xml:space="preserve">
          <source>If an application is given more than once or if an application has the same key given more than once, the behaviour is undefined and a warning message will be logged. In future releases, an error will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39738be45b65649837e2fb936bf724db2dc8cf3a" translate="yes" xml:space="preserve">
          <source>If an argument is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">如果一个算术表达式、一个布尔表达式、一个短路表达式或对守卫BIF的调用失败(因为无效参数),则整个守卫失败。如果该守卫是守卫序列的一部分,则会评估序列中的下一个守卫(即下一个分号后面的守卫)。</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">如果首次尝试打开日志文件失败，则磁盘日志进程将以EXIT消息 &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; 终止。该函数针对所有其他错误返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">如果尝试重新打开或截断日志失败（请参阅 &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; ），则磁盘日志进程将立即终止。在该过程终止之前，将删除到所有者和阻止过程的链接（请参阅 &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; ）。结果是链接仅在一个方向上起作用。如果某个其他进程同时截断或重新打开该日志，则任何使用磁盘日志的进程都必须检查错误消息 &lt;code&gt;no_such_log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">如果边缘从v发出并入射在w上，则称w为 v &lt;strong id=&quot;out_neighbour&quot;&gt;的邻居&lt;/strong&gt;，而v为w &lt;strong id=&quot;in_neighbour&quot;&gt;的邻居&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果员工从1997年或更晚开始，但在2001年之前，返回 &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果某个员工在1997年之前开始工作，请返回元组 &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">如果必须重新启动模拟器并且不需要升级说明，也就是说，如果重新启动本身足以使升级后的应用程序开始运行新版本，则可以手动创建一个简单的 &lt;code&gt;relup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">如果在重传期间发生编码错误，则请求过程将失败并返回 &lt;code&gt;{error,failure}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Bin&lt;/code&gt; 中包含整个数据包，则将其与二进制文件的其余部分一起作为 &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">如果返回错误代码,则表示 port 没有启动。</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">如果在配置文件中发现错误，则使用错误报告模块的函数 &lt;code&gt;config_err/2&lt;/code&gt; 报告该错误，并且该函数失败，原因为 &lt;code&gt;configuration_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">如果返回错误，则可能是由于匹配规范的编译中存在错误。这些错误以元组列表 &lt;code&gt;{error, string()}&lt;/code&gt; 其中字符串是编译错误的文字说明。一个例子：</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">如果返回错误，则可能是由于跟踪程序服务器已在运行（ &lt;code&gt;{error,already_started}&lt;/code&gt; ），也可能是由于 &lt;code&gt;HandlerFun&lt;/code&gt; 引发了异常。</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">如果发生错误，则在调用 &lt;code&gt;is_set_ok&lt;/code&gt; 函数之后将调用此函数。如果为此对象调用 &lt;code&gt;set&lt;/code&gt; ，则不调用 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">如果在安装过程中发生错误,系统将使用旧版本的版本重新启动。如果安装成功,系统随后将使用新版本的版本,但如果发生任何事情并重新启动系统,系统将重新开始使用以前的版本。</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">如果套接字上发生错误，则会传递以下消息（除非在套接字的选项列表中指定了 &lt;code&gt;{active, false}&lt;/code&gt; ，在这种情况下，可通过调用 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 来检索数据包）：</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">如果使用模块 &lt;code&gt;io&lt;/code&gt; 访问打开的文件时发生错误，则退出处理该文件的过程。如果某个进程稍后尝试访问该文件，则死进程可能会挂起。这将在将来的版本中修复。</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">如果发生错误，则在 &lt;code&gt;is_set_ok&lt;/code&gt; 函数之后调用函数 &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 。如果为此对象调用 &lt;code&gt;set&lt;/code&gt; ，则不调用 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;is_set_ok&lt;/code&gt; 阶段或在 &lt;code&gt;set&lt;/code&gt; 阶段发生错误，则所有用 &lt;code&gt;is_set_ok&lt;/code&gt; 调用但未 &lt;code&gt;set&lt;/code&gt; 函数都将用 &lt;code&gt;undo&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">如果发生错误,该函数启动的应用程序将被停止,使正在运行的应用程序集恢复到初始状态。</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">如果发生错误，则退出并返回一个错误元组 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">如果发生错误，则退出并返回一个错误元组 &lt;code&gt;{error, Reason}&lt;/code&gt; 。错误元组不返回，因为它不能与键区分开。</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">如果发生错误,在这种情况下,堆栈跟踪会变成空的。</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">如果发生错误,则没有输出。例如:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;AfterBody&lt;/code&gt; 自身评估期间发生异常，则不会捕获该异常。所以，如果 &lt;code&gt;AfterBody&lt;/code&gt; 在异常后评估 &lt;code&gt;Exprs&lt;/code&gt; ， &lt;code&gt;Body&lt;/code&gt; ，或 &lt;code&gt;ExceptionBody&lt;/code&gt; ，该异常丢失，在异常掩盖 &lt;code&gt;AfterBody&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">如果在 &lt;code&gt;ExceptionBody&lt;/code&gt; 评估期间发生异常，则不会捕获该异常。</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">如果在评估 &lt;code&gt;Exprs&lt;/code&gt; 时发生异常，但没有正确的带有正确保护序列的正确 &lt;code&gt;Class&lt;/code&gt; 的 &lt;code&gt;ExceptionPattern&lt;/code&gt; 匹配，则将异常传递 &lt;code&gt;Exprs&lt;/code&gt; 就好像Exprs没有包含在 &lt;code&gt;try&lt;/code&gt; 表达式中一样。</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">如果如上所述接收到退出信号，则使用 &lt;code&gt;server_logoff&lt;/code&gt; 函数从服务器 &lt;code&gt;User_List&lt;/code&gt; 中删除元组 &lt;code&gt;{From,Name}&lt;/code&gt; 。如果运行服务器的节点发生故障，则退出信号（由系统自动生成）将发送到所有客户端进程： &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; 导致所有客户端进程终止。</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">如果在编译MIB时关联文件中变量 &lt;code&gt;myVar&lt;/code&gt; 的检测函数没有名称，则编译器将生成一个条目。</target>
        </trans-unit>
        <trans-unit id="b4e274b3831003e60f76d89037c8e16f5e3d04d9" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt; Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">如果提供整数超时值，则除非在 &lt;code&gt;Timeout&lt;/code&gt; 毫秒内收到请求或消息，否则将发生超时。原子 &lt;code&gt;timeout&lt;/code&gt; 表示超时，该超时由 &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; 回调函数处理。原子 &lt;code&gt;infinity&lt;/code&gt; 可用于无限期等待，这是默认值。</target>
        </trans-unit>
        <trans-unit id="f34784d34b261e41d724f171d45d4c2db9bc38eb" translate="yes" xml:space="preserve">
          <source>If an option is set in more than one way, what happens?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">如果所有者尝试再次以所有者身份打开日志，则会使用返回值 &lt;code&gt;{ok, Log}&lt;/code&gt; 确认它，但是磁盘日志的状态不受影响。</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果指定了无法识别的类型选项 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;Type&lt;/code&gt; 不是正确的列表，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">如果 &lt;code&gt;modify_algs_list()&lt;/code&gt; 中包含不受支持的算法，它将被静默忽略</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">如果升级包含从OTP R15之前的仿真器到OTP R15或更高版本的仿真器的更改，则会发出警告 &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; 。有关此的更多信息，请参见 &lt;code&gt;Design Principles&lt;/code&gt; &lt;strong&gt;系统文档&lt;/strong&gt;》中的&amp;ldquo; 设计原则&lt;strong&gt;&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">是否以及如何压缩消息。示例为 &lt;code&gt;none&lt;/code&gt; ，即没有压缩和 &lt;code&gt;zlib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">当且仅当在格式字符串中使用Unicode翻译修饰符（即 &lt;code&gt;~ts&lt;/code&gt; 或 &lt;code&gt;~tc&lt;/code&gt; ）时，结果列表才能包含超出ISO Latin-1字符范围的字符（即数字&amp;gt; 255）。如果是这样，结果仍然是普通的Erlang &lt;code&gt;string()&lt;/code&gt; ，并且可以在允许Unicode数据的任何上下文中很好地使用。</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">如果并且当您想启动和操作 &lt;code&gt;Mnesia&lt;/code&gt; 时，将定义和数据写入普通文本文件通常会更容易。最初，没有表，也没有数据，或者需要哪些表。在原型设计的初始阶段，谨慎的做法是将所有数据写入一个文件，对该文件进行处理，然后将文件中的数据插入数据库中。可以使用从文本文件读取的数据来初始化 &lt;code&gt;Mnesia&lt;/code&gt; 。以下两个功能可用于处理文本文件。</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">如果需要这些变量中的任何一个的另一种实现方式，例如将持久性变量存储在Mnesia数据库中，则必须对这些变量进行自己的实现。该MIB将被编译和加载，而不是默认的MIB。新的已编译MIB必须与原始MIB具有相同的名称（即STANDARD-MIB或SNMPv2-MIB），并且位于SNMP配置目录中（请参阅 &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2491a0f8f402474246f9fb8f195513ec14b76dd" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; is present, the one with the highest level is used, that is, the &lt;code&gt;Option&lt;/code&gt; list parameter has the highest priority. Then the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; on all levels in order starting with level 0 are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">如果任何 &lt;code&gt;Dir&lt;/code&gt; 不是目录名</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">如果系统中的任何Erlang进程 &lt;code&gt;Pid&lt;/code&gt; 已分配了超过一定数量的系统总内存，则会设置警报 &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">如果脚本添加了任何HTTP标头字段，则它们必须在对 &lt;code&gt;deliver/2&lt;/code&gt; 的第一次调用中，并且调用中的数据必须为字符串。标头完成后的调用可以包含二进制数据，以减少复制开销。不要假定任何有关 &lt;code&gt;SessionID&lt;/code&gt; 数据类型的信息。 &lt;code&gt;SessionID&lt;/code&gt; 必须是您实现的ESI回调函数的输入值。</target>
        </trans-unit>
        <trans-unit id="5adb78f4f1efbc66139e964187c434397d354611" translate="yes" xml:space="preserve">
          <source>If any argument has the wrong format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">如果任何子进程启动函数失败或返回错误的元组或错误值，则主管首先使用原因 &lt;code&gt;shutdown&lt;/code&gt; 终止所有已经启动的子进程，然后终止自身并返回 &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从Erlang Shell调用使用&amp;ldquo;必需的配置数据&amp;rdquo;的任何功能（例如Telnet或FTP），则必须首先使用 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 来要求配置数据。</target>
        </trans-unit>
        <trans-unit id="784d2fd65e27ddf88a5b740f50b285e092cfde1d" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt; ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要从Erlang shell调用任何使用&amp;ldquo;必需的配置数据&amp;rdquo;的函数（例如，函数 &lt;code&gt;ct_telnet&lt;/code&gt; 或 &lt;code&gt;ct_ftp&lt;/code&gt; ），则首先需要使用 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 的配置数据。这等效于 &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果任何参数无效，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="b3295c7085224a5c975d29da6224a233ad1e1a01" translate="yes" xml:space="preserve">
          <source>If any of the socket &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; are active, the &lt;code&gt;RecvData&lt;/code&gt; tuple contains an &lt;code&gt;AncData&lt;/code&gt; field, otherwise it does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果任何表都不存在或 &lt;code&gt;badarg&lt;/code&gt; 表未打开，则会引发badarg异常。</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">如果在传递 &lt;code&gt;+sbt&lt;/code&gt; 时发生任何这些错误，则运行时系统将显示一条错误消息，并拒绝启动。如果在传递 &lt;code&gt;+stbt&lt;/code&gt; 时发生任何这些错误，则运行时系统将静默忽略该错误，并使用未绑定的调度程序启动。</target>
        </trans-unit>
        <trans-unit id="eaa7aa976033707bd386e9983d12159b899132bc" translate="yes" xml:space="preserve">
          <source>If any one of these are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果在 &lt;code&gt;InsPos&lt;/code&gt; &amp;gt;替换二进制文件的大小中指定了任何位置，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">如果未指定参数 &lt;code&gt;-daemon&lt;/code&gt; ，则 &lt;code&gt;epmd&lt;/code&gt; 将与启动它的shell的控制终端一起作为普通程序运行。通常，它将作为守护程序运行。</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">如果将参数 &lt;code&gt;Archive&lt;/code&gt; 指定为二进制文件，则假定二进制文件的内容为zip归档文件，否则为文件名。</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">如果参数 &lt;code&gt;MFA&lt;/code&gt; 是原子 &lt;code&gt;on_load&lt;/code&gt; ，则匹配规范和标志列表将在所有新加载的模块上使用。</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">如果将参数 &lt;code&gt;Name&lt;/code&gt; 指定为 &lt;code&gt;{binary,Binary}&lt;/code&gt; ，则二进制文件的内容假定为tar存档。</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">如果参数 &lt;code&gt;Name&lt;/code&gt; 指定为 &lt;code&gt;{file,Fd}&lt;/code&gt; ，则假定 &lt;code&gt;Fd&lt;/code&gt; 是从函数 &lt;code&gt;file:open/2&lt;/code&gt; 返回的文件描述符。</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">如果指定了参数 &lt;code&gt;type&lt;/code&gt; ，则将显示此类型的所有已加载报告。如果指定了整数参数，则显示具有此参考编号的报告。如果未指定任何参数，则显示所有报告。</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">如果原子 &lt;code&gt;start&lt;/code&gt; 被指定为延续，盘记录来自被选择为读条款。当前节点上的本地或分布式磁盘日志比其他节点上的单个分布式日志更可取。</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">如果在前面的示例中使用了原子分组，则匹配器在第一次不匹配&amp;ldquo; foo&amp;rdquo;时会立即放弃。该符号是一种特殊的括号，以 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 开头，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">如果在创建表时指定了属性 &lt;code&gt;{local_content, true}&lt;/code&gt; ，则该表将位于您指定该表存在的节点上，但是对表的写操作仅在本地副本上执行。</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">如果使用身份验证或加密（仅SNMPv3），请启动 &lt;code&gt;crypto&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">如果使用认证或加密（SNMPv3的只），启动 &lt;code&gt;crypto&lt;/code&gt; 应用程序。如果忘记了此步骤，则代理将不会启动，而是报告 &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">如果自动跳过测试用例不影响退出状态。默认的行为可以使用启动标志来改变。</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">如果自动提交模式被打开,每个查询将被视为一个单独的事务,并在执行后自动提交。如果你想让多个查询成为同一个事务的一部分,那么自动提交模式应该被关闭。那么你将不得不显式调用commit/3来结束一个事务。</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">如果转储中可用,则是原子表中的原子总数。如果没有原子表的大小,则显示转储中可见的原子数。</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">如果不再使用二进制文件，则应尽快将其丢弃。（将 &lt;code&gt;Number&lt;/code&gt; 设置为零。）</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">如果不支持调度器的绑定。</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Source&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Destination&lt;/code&gt; 引用文件名，则分别在文件的模式列表前添加 &lt;code&gt;[read, binary]&lt;/code&gt; 和 &lt;code&gt;[write, binary]&lt;/code&gt; 来打开文件，以优化副本。</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">如果已在运行中开始呼叫计数跟踪，则计数将从零重新开始。要暂停运行中的计数器，请使用 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 。暂停和运行中的计数器可以使用 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 从零重新启动。</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">如果在执行 &lt;code&gt;analyse/0..2&lt;/code&gt; 的同时呼叫计数器仍在运行，则可能会得到不一致的结果。如果执行了 &lt;code&gt;analyse/0..2&lt;/code&gt; 的进程被调度了，因此其他进程可以增加正在分析的计数器，则会发生这种情况，在分析之前调用 &lt;code&gt;pause()&lt;/code&gt; 可以解决问题。</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">如果已经在运行时开始通话时间跟踪，则计数和时间将从零开始。要暂停运行中的计数器，请使用 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 。暂停和运行中的计数器可以使用 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 从零重新启动。</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">如果多次调用，则仅打印最后一条注释。测试用例的返回值 &lt;code&gt;{comment,Comment}&lt;/code&gt; 将覆盖此函数设置的字符串。</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">如果使用用户应用程序未知的扩展名进行调用，则将使用返回值 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">如果在调用 &lt;code&gt;FormatFun&lt;/code&gt; 与包括参数 &lt;code&gt;NElements&lt;/code&gt; 和 &lt;code&gt;DepthFun&lt;/code&gt; 失败， &lt;code&gt;FormatFun&lt;/code&gt; 与变量排除再次呼吁 &lt;code&gt;NElements&lt;/code&gt; 和 &lt;code&gt;DepthFun&lt;/code&gt; （ &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; 或 &lt;code&gt;all&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">如果在回参时实行的是caseful匹配,则与字母的情况有关。例如,下面匹配 &quot;rah rah &quot;和 &quot;RAH RAH&quot;,但不匹配 &quot;RAH rah&quot;,尽管原捕获子模式是无大小写匹配的。</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">如果某些特定于端口的数据必须从其他线程而不是调用驱动程序回调的线程中访问,则可以使用端口数据锁来同步数据的操作。目前,仿真器与端口数据锁相关联的唯一端口特定数据是驱动程序队列。</target>
        </trans-unit>
        <trans-unit id="cd4b4afe54513271fef096e7c304b9cfa2e00765" translate="yes" xml:space="preserve">
          <source>If command line option +MMscrpm (Reserve Physical Memory) is set to false, only virtual space is allocated for the super carrier from start. The super carrier then acts as an &quot;alternative mmap&quot; implementation without changing the consumption of physical memory pages. Physical pages will be reserved on demand when an allocation is done from the super carrier and be unreserved when the memory is released back to the super carrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">如果一个或多个套件的编译失败，则将编译错误打印到tty上，并向操作员询问是否要在没有缺少套件的情况下进行测试运行，或者中止测试​​。如果操作员选择继续，则会在HTML日志中记录缺少套件的测试。如果 &lt;code&gt;Common Test&lt;/code&gt; 在编译失败后无法提示用户（如果 &lt;code&gt;Common Test&lt;/code&gt; 不控制 &lt;code&gt;stdin&lt;/code&gt; ），则测试运行将自动继续，而不会缺少任何套件。但是，可以使用 &lt;code&gt;ct_run&lt;/code&gt; 标志 &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 选项 &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; 修改此行为。如果 &lt;code&gt;abort_if_missing_suites&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，如果某些套件无法编译，则测试运行会立即停止。</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">如果通过 &lt;code&gt;--enable-static-nifs&lt;/code&gt; 编译用于静态包含的NIF ，则必须在 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 声明之前定义 &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">如果通过 &lt;code&gt;--enable-static-drivers&lt;/code&gt; 编译用于静态包含的驱动程序，则必须在 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 声明之前定义 &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">如果要返回配置元素（键值元组）作为结果而不是值，请使用option &lt;code&gt;element&lt;/code&gt; 。然后，返回的元素采用 &lt;code&gt;{Required,Value}&lt;/code&gt; 的形式。</target>
        </trans-unit>
        <trans-unit id="9e21b434342c495e7cd41bb3f46d93a5eba516c9" translate="yes" xml:space="preserve">
          <source>If containing a &quot;supported_groups&quot; extension, it MUST also contain a &quot;key_share&quot; extension, and vice versa. An empty KeyShare.client_shares vector is permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">如果进行了交叉覆盖分析,并且有当前测试的累积覆盖结果,&quot;覆盖数据收集到所有测试 &quot;的链接将带您进入这些结果。</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">如果将数据以无法转换为指定编码的格式发送到 &lt;code&gt;io_device()&lt;/code&gt; ，或者如果数据返回的函数以无法处理数据字符范围的格式读取数据，则会发生错误，并且该文件已关闭。</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">如果定义，则禁用 &lt;code&gt;run_erl&lt;/code&gt; 打开的pty的输入和输出流控制。如果您想消除使用Ctrl-S（而不是Ctrl-D断开连接）意外阻塞流量控制的任何风险，这很有用，因为这可能会导致整个Beam过程的阻塞，甚至在以心脏为监督者的情况下将日志消息写入终端时，心脏进程会被阻塞，从而使心脏进程无法完成其工作。</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">如果需要区分空匹配和不存在的子模式，请使用 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 并转换为Erlang代码中的最终类型。</target>
        </trans-unit>
        <trans-unit id="49295520e0b6d8a184569401922957d15009d327" translate="yes" xml:space="preserve">
          <source>If doing encryption, the &lt;code&gt;final_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;final_fun()&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">如果为空,说明调度器正在做一些工作。如果不为空,则表示调度器处于睡眠状态,或者暂停。这个条目只存在于启用SMP的模拟器中。</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">如果启用且可用,则显示进程SASL日志条目。</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">如果启用,则会向每个调度程序发送一个信号来检查其响应性。系统检查发生在任何发送到端口程序的心跳之前。如果任何一个调度器的响应速度不够快,心脏程序就会收不到它的心跳,从而最终终止节点。</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">如果一切成功，则回调函数可以将可能的默认值或内部状态值添加到配置中，并在 &lt;code&gt;{ok,Config2}&lt;/code&gt; 中返回调整后的映射。</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">如果一切成功，则回调函数必须在 &lt;code&gt;{ok,Config3}&lt;/code&gt; 中返回可能已调整的配置。</target>
        </trans-unit>
        <trans-unit id="2fa1005e80fa8c58a4740b29710f28976ae1bc25" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">如果省略flag- &lt;code&gt;-loader&lt;/code&gt; ，则默认为 &lt;code&gt;efile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">如果指定了标志 &lt;code&gt;timestamp&lt;/code&gt; ， &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 或 &lt;code&gt;monotonic_timestamp&lt;/code&gt; ，则第一个元组元素为 &lt;code&gt;trace_ts&lt;/code&gt; ，并且时间戳作为消息元素中最后一个额外元素添加。如果传递了多个时间戳标志，则 &lt;code&gt;timestamp&lt;/code&gt; 优先于 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ，而后者又优先于 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 。所有时间戳标记都会被记住，因此如果传递两个时间戳标记，并且禁用优先级最高的一个标记，则另一个标记将变为活动状态。</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">如果标志 &lt;code&gt;-pa&lt;/code&gt; 或 &lt;code&gt;-pz&lt;/code&gt; 被中指定的 &lt;code&gt;Common Test&lt;/code&gt; 组选项（前述 &lt;code&gt;-erl_args&lt;/code&gt; ），相对目录被转换成绝对和重新插入到由代码路径 &lt;code&gt;Common Test&lt;/code&gt; 。这是为了避免在&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 在测试运行期间更改工作目录时加载用户模块时出现问题。然而， &lt;code&gt;Common Test&lt;/code&gt; 忽略标志 &lt;code&gt;-pa&lt;/code&gt; 和 &lt;code&gt;-pz&lt;/code&gt; 以下 &lt;code&gt;-erl_args&lt;/code&gt; 在命令行上。这些目录通常（以指定形式）添加到代码路径中。</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">如果megaco由于某种原因无法传递答复，则除非通过 &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; 调用回调函数 &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; ，否则将其原因传递给用户。</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">如果找到了,这个文件会在创建发行包时自动包含。</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">如果功能 &lt;code&gt;start_link/3,4,5&lt;/code&gt; 的使用量和处理崩溃它称为前 &lt;code&gt;init_ack/1,2&lt;/code&gt; ， &lt;code&gt;{error, Reason}&lt;/code&gt; 是如果主叫处理陷阱退出返回。</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">如果跟踪了函数调用，则必须通过单击&lt;strong&gt;添加跟踪模式&lt;/strong&gt;按钮来&lt;strong&gt;添加跟踪模式&lt;/strong&gt;。选择模块，功能和匹配规范。如果未选择任何功能，则将跟踪模块中的所有功能。</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">如果给定,设置连接的最小字节/秒值。</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">如果不包括头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，则不会翻译该趣味，这可能会导致&lt;strong&gt;运行时错误&lt;/strong&gt;（取决于该趣味在纯Erlang上下文中是否有效）。</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">如果心脏应该&lt;strong&gt;不&lt;/strong&gt;杀Erlang运行时系统，这可以通过使用环境变量来表示 &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; 。如果由心脏执行的命令对此负责（例如作为特定清除序列的一部分），这将很有用。如果未设置，或者未设置为 &lt;code&gt;TRUE&lt;/code&gt; ，则默认行为是如上所述进行杀死。</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">如果 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;ch3&lt;/code&gt; 属于同一应用程序，则 &lt;code&gt;.appup&lt;/code&gt; 文件可以如下所示：</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">如果相反， &lt;code&gt;s2&lt;/code&gt; 的封面规格如下所示：</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">如果改用以下模式,则会匹配 &quot;意识和责任 &quot;和其他两个字符串。</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">如果在执行 &lt;code&gt;end_per_testcase&lt;/code&gt; 期间确定将成功的测试用例的状态更改为失败，则 &lt;code&gt;end_per_testcase&lt;/code&gt; 可以返回元组 &lt;code&gt;{fail,Reason}&lt;/code&gt; （其中 &lt;code&gt;Reason&lt;/code&gt; 描述测试用例失败的原因）。</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">如果重要的是要获得与原始文档中相似的缩进和换行符，则必须在适当的位置添加带有空格和换行符值的#xmlText {}记录。可能还必须保留引用DTD的原始序言。如果是这样，可以将RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; 传递给 &lt;code&gt;export_simple/3&lt;/code&gt; 。以下示例代码修复了先前示例中的那些更改：</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">如果最大程度地减少更改代码时应用程序处于非活动状态的时间很重要，请使用 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;atomic_load/1&lt;/code&gt; 。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">如果必须在终止之前进行清理，则关闭策略必须是一个超时值，并且必须将 &lt;code&gt;gen_server&lt;/code&gt; 设置为在函数 &lt;code&gt;init&lt;/code&gt; 中捕获退出信号。当命令关闭时， &lt;code&gt;gen_server&lt;/code&gt; 然后调用回调函数Terminate &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">如果必须在终止前进行清理，则关闭策略必须是一个超时值，并且 &lt;code&gt;gen_statem&lt;/code&gt; 必须在 &lt;code&gt;init/1&lt;/code&gt; 函数中通过调用 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 将自身设置为捕获退出信号：</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">如果需要将一组 &lt;code&gt;ASN.1&lt;/code&gt; 模块编译为具有编码/解码功能的Erlang文件，请确保在配置文件中列出所有涉及的文件。此配置文件必须具有双扩展名 &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; （ &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 可以是 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; ）。在引号（&amp;ldquo;&amp;rdquo;）中列出输入文件名，在文件的每一行中列出一个。如果输入文件是 &lt;code&gt;File1.asn&lt;/code&gt; ， &lt;code&gt;File2.asn&lt;/code&gt; 和 &lt;code&gt;File3.asn&lt;/code&gt; ，则配置文件必须如下所示：</target>
        </trans-unit>
        <trans-unit id="ac7e64fc378f2a5b91895bad1f8c83d469b481c8" translate="yes" xml:space="preserve">
          <source>If it is not specified it will use a default list ([x25519, x448, secp256r1, secp384r1]) that is filtered based on the installed crypto library version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">如果有可能的经理创建或删除表中的行，必须有一个 &lt;code&gt;RowStatus&lt;/code&gt; 列 &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;undo&lt;/code&gt; 工作正常。</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">如果可以加载 &lt;code&gt;Module&lt;/code&gt; 并且 &lt;code&gt;Function/N&lt;/code&gt; 被导出，则会调用它。</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">如果要求Mnesia必须在插入该表的所有 &lt;code&gt;person&lt;/code&gt; 记录的属性 &lt;code&gt;address&lt;/code&gt; 上建立并维护一个额外的索引表，则会发出以下代码：</target>
        </trans-unit>
        <trans-unit id="d545f3dffae84feb539a9a4a2658199f48d1fd1a" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;auto&lt;/code&gt;, the client automatically handles received tickets and tries to use them when making new TLS connections (session resumption with pre-shared keys).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8576255de740a4f910003bb08212e24357ef1fd" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;stateful&lt;/code&gt; or &lt;code&gt;stateless&lt;/code&gt;, session resumption with pre-shared keys is enabled and the server will send stateful or stateless session tickets to the client after successful connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cea858b85f406ece423faeb209b445f4f52401b" translate="yes" xml:space="preserve">
          <source>If it takes two arguments, the first is the report, and the second is a map containing extra data that allows direct coversion to a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射中的任何现有键都不匹配，则会从键 &lt;code&gt;K&lt;/code&gt; 到值 &lt;code&gt;V&lt;/code&gt; 创建新的关联。</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射 &lt;code&gt;M&lt;/code&gt; 中的任何现有键都不匹配，则会在运行时触发类型 &lt;code&gt;badarg&lt;/code&gt; 的异常。如果在地图 &lt;code&gt;M&lt;/code&gt; 中存在匹配关键字 &lt;code&gt;K&lt;/code&gt; ，则其关联值将被新值 &lt;code&gt;V&lt;/code&gt; 替换，并且所评估的地图表达式将返回新地图。</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">如果键 &lt;code&gt;K&lt;/code&gt; 与映射 &lt;code&gt;M&lt;/code&gt; 中的现有键匹配，则其关联值将被新值 &lt;code&gt;V&lt;/code&gt; 代替。在这两种情况下，评估的地图表达式都会返回一个新地图。</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">如果以后的 &lt;code&gt;Pid&lt;/code&gt; 终止于 &lt;code&gt;Reason&lt;/code&gt; ，则主管网桥也终止于 &lt;code&gt;Reason&lt;/code&gt; 。如果稍后主管网桥由于其原因 &lt;code&gt;Reason&lt;/code&gt; 终止其主管，它将调用 &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">如果使用长节点节点名，则通过调用 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 来完成初始化：</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">如果多个进程修复了一张表,那么在所有进程释放(或终止)之前,该表一直保持固定状态。每个进程都有一个参考计数器,连续修复N次需要释放N次才能释放该表。</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">如果多个进程修复了一个表,那么在所有进程释放或终止之前,该表一直是固定的。每个进程都有一个参考计数器,连续修复N次需要释放N次才能释放该表。</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">如果地图 &lt;code&gt;map_in&lt;/code&gt; 包含 &lt;code&gt;key&lt;/code&gt; ，这个功能使得副本 &lt;code&gt;map_in&lt;/code&gt; 在 &lt;code&gt;*map_out&lt;/code&gt; 和删除 &lt;code&gt;key&lt;/code&gt; 以及相关的值。如果地图 &lt;code&gt;map_in&lt;/code&gt; 不包含 &lt;code&gt;key&lt;/code&gt; ，则 &lt;code&gt;*map_out&lt;/code&gt; 设置为 &lt;code&gt;map_in&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">如果模式为干扰模式,服务器被强行阻塞,所有正在进行的请求终止,并立即开始重新加载。如果模式为非干扰,则不接受新的连接,但允许正在进行的请求在重载完成之前完成。</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">如果使用内联编译模块，则可能会发出虚假警告。在&amp;ldquo; &lt;strong&gt;选项&amp;rdquo;&lt;/strong&gt;菜单中，您可以选择在分析字节码时忽略内联编译模块。从源代码开始时，这不是问题，因为Dialyzer已显式关闭了内联。该选项使Dialyzer禁止来自内联编译模块的所有警告，因为Dialyzer当前无法找到通过内联产生的代码的哪些部分。</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">如果需要更复杂的过滤，请使用 &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; 并根据RFC 5277中的&amp;ldquo;事件通知的XML架构&amp;rdquo;指定确切的过滤器。</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">如果在最近的 &lt;code&gt;MaxT&lt;/code&gt; 秒内发生的重启次数超过 &lt;code&gt;MaxR&lt;/code&gt; 次，则主管将终止所有子进程，然后终止其自身。在这种情况下，主管本身的终止原因将被 &lt;code&gt;shutdown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">如基础操作系统报告的那样，如果分配的可用系统内存超过一定数量 &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; 则会设置警报{system_memory_high_watermark，[]}。</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">如果一个模式中存在不止一个回溯动词,那么后面的不同动词(*COMMIT)可以先被触发,所以在匹配过程中仅仅传递(*COMMIT)并不总是保证匹配必须在这个起点。</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">如果一个模式中出现一个以上的回溯动词,则回溯到的那个动词先作用。例如,考虑以下模式,其中A、B等是复杂模式片段。</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">如果多个进程尝试使用相同的 &lt;code&gt;Path&lt;/code&gt; 加载已经加载的驱动程序，或者同一进程尝试多次加载该驱动程序，则该函数返回 &lt;code&gt;ok&lt;/code&gt; 。仿真器跟踪 &lt;code&gt;load/2&lt;/code&gt; 调用，以便在 &lt;code&gt;unload/2&lt;/code&gt; 驱动程序之前必须从同一进程执行相应数量的unload / 2调用。因此，对于应用程序来说，在需要时加载在进程或应用程序之间共享的驱动程序是安全的。可以安全地卸载它，而不会引起系统其他部分的麻烦。</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">如果启用了多调度，则模拟器将使用多个调度程序线程。可以用两种不同的方式来阻止多调度。要么所有调度程序都被阻止，要么所有&lt;strong&gt;正常&lt;/strong&gt;调度程序都被阻止。当仅阻止常规调度程序时，肮脏的调度程序可以自由继续调度进程。</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">如果指定了多个 &lt;code&gt;-eval&lt;/code&gt; 表达式，则将按指定的顺序对它们进行求值。 &lt;code&gt;-eval&lt;/code&gt; 表达式通过 &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-run&lt;/code&gt; 函数调用顺序进行求值（这也按指定的顺序进行）。与 &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-run&lt;/code&gt; 一样，不终止的评估会阻塞系统初始化过程。</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">如果传递了多个时间戳标志，则 &lt;code&gt;timestamp&lt;/code&gt; 优先于 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ，而后者又优先于 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 。所有时间戳标记都会被记住，因此，如果传递了两个时间戳标志，并且禁用了优先级最高的那个标志，则另一个将变为活动状态。</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">如果名称注册成功，则新的 &lt;code&gt;gen_server&lt;/code&gt; 进程将调用回调函数 &lt;code&gt;ch3:init([])&lt;/code&gt; 。预期 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 的内部状态。在这种情况下，状态为可用通道。</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">如果名称注册成功，则新的 &lt;code&gt;gen_statem&lt;/code&gt; 进程将调用回调函数 &lt;code&gt;code_lock:init(Code)&lt;/code&gt; 。该功能有望恢复 &lt;code&gt;{ok, State, Data}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是初始状态 &lt;code&gt;gen_statem&lt;/code&gt; ，在这种情况下 &lt;code&gt;locked&lt;/code&gt; ;假设开始时门是锁着的。 &lt;code&gt;Data&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 的内部服务器数据。在这里，服务器数据是一个 &lt;code&gt;map&lt;/code&gt; 其中的键 &lt;code&gt;code&lt;/code&gt; 存储正确的按钮顺序，键 &lt;code&gt;length&lt;/code&gt; 存储其长度，而键 &lt;code&gt;buttons&lt;/code&gt; 存储所收集的按钮，直到相同的长度。</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">如果 &lt;code&gt;-minimal&lt;/code&gt; 和 &lt;code&gt;-sasl&lt;/code&gt; 都不作为参数传递，则将提示您。</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">如果两个端点都不需要,你可以像这样测试并重新尝试。</target>
        </trans-unit>
        <trans-unit id="7ed5063391f45e25222dbefda8015e8ee48fbb82" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is given the node will be started using &lt;code&gt;-sname undefined&lt;/code&gt;. If &lt;code&gt;Node&lt;/code&gt; does not contain a hostname, one is automatically taken from &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">如果未指定 &lt;code&gt;ContextName&lt;/code&gt; ，则使用默认的 &lt;code&gt;&quot;&quot;&lt;/code&gt; 上下文。</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">如果未指定 &lt;code&gt;NotifyName&lt;/code&gt; （或者为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ），则通知将发送到所有管理目标（以下 &lt;code&gt;Addresses&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">如果未指定 &lt;code&gt;Type&lt;/code&gt; ，则列出所有报告。</target>
        </trans-unit>
        <trans-unit id="ac9629aacf5a541205c4ec779ff11edb1576409e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;context&lt;/code&gt; is specified, the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;, is used.</source>
          <target state="translated">如果没有 &lt;code&gt;context&lt;/code&gt; 指定，默认情况下， &lt;code&gt;&quot;&quot;&lt;/code&gt; ，被使用。</target>
        </trans-unit>
        <trans-unit id="ed97555002c32aa9440a97e73ca69137e2f1b0fe" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;epmd&lt;/code&gt; (TCP port mapper daemon) is used, also command-line option &lt;code&gt;-no_epmd&lt;/code&gt; is to be specified, which makes Erlang skip the &lt;code&gt;epmd&lt;/code&gt; startup, both as an OS process and as an Erlang ditto.</source>
          <target state="translated">如果未使用 &lt;code&gt;epmd&lt;/code&gt; （TCP端口映射器守护程序），则还将指定命令行选项 &lt;code&gt;-no_epmd&lt;/code&gt; ，这将使Erlang 既作为OS进程又作​​为Erlang同上，跳过 &lt;code&gt;epmd&lt;/code&gt; 启动。</target>
        </trans-unit>
        <trans-unit id="a8006619350a5226e5dc4b2683c9eea3a8bdbda4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;extended_info&lt;/code&gt; is present in the file and &lt;code&gt;{verify,true}&lt;/code&gt; is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was &lt;code&gt;public&lt;/code&gt; and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;, which extends the information in the file with the number of objects written.</source>
          <target state="translated">如果没有 &lt;code&gt;extended_info&lt;/code&gt; 是存在于文件中，并 &lt;code&gt;{verify,true}&lt;/code&gt; 指定，则转储启动时写对象的数量是比较原始表的大小。如果表是 &lt;code&gt;public&lt;/code&gt; ，并且在表转储到文件时添加或删除了对象，这会使验证失败。为避免此问题，请要么不验证同时更新时转储的文件，要么对 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 使用选项 &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; ，这会扩展文件中的信息并增加写入的对象数。</target>
        </trans-unit>
        <trans-unit id="8a45ca5e05cc70fae2783d55cbff20b1f8725403" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;name&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets.</source>
          <target state="translated">如果未指定 &lt;code&gt;name&lt;/code&gt; （或者为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ），则通知将发送到所有管理目标。</target>
        </trans-unit>
        <trans-unit id="32886c8cd8eda5943ea7814b65ec8cd639317821" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;tracer&lt;/code&gt; is specified, the calling process receives all the trace messages.</source>
          <target state="translated">如果未指定 &lt;code&gt;tracer&lt;/code&gt; ，则调用过程将接收所有跟踪消息。</target>
        </trans-unit>
        <trans-unit id="8acb8279a4661a4f996c3af79ec9be1db1d63648" translate="yes" xml:space="preserve">
          <source>If no BEAM file contains debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果没有BEAM文件包含调试信息,那么将返回一个元组列表。每个元组的第一个元素是以下之一:</target>
        </trans-unit>
        <trans-unit id="44e5f3c4af2c18aaf89a34918cf838e205862cec" translate="yes" xml:space="preserve">
          <source>If no BOM is found, the function returns &lt;code&gt;{latin1,0}&lt;/code&gt;.</source>
          <target state="translated">如果未找到BOM，则该函数返回 &lt;code&gt;{latin1,0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07f0cc9e55f8b5cf0585baaee7cd300085bb99c" translate="yes" xml:space="preserve">
          <source>If no CPU topology is available when flag &lt;code&gt;+sbt&lt;/code&gt; is processed and &lt;code&gt;BindType&lt;/code&gt; is any other type than &lt;code&gt;u&lt;/code&gt;, the runtime system fails to start. CPU topology can be defined using flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt;. Notice that flag &lt;code&gt;+sct&lt;/code&gt; can have to be passed before flag &lt;code&gt;+sbt&lt;/code&gt; on the command line (if no CPU topology has been automatically detected).</source>
          <target state="translated">如果在处理标志 &lt;code&gt;+sbt&lt;/code&gt; 且 &lt;code&gt;BindType&lt;/code&gt; 是 &lt;code&gt;u&lt;/code&gt; 以外的任何其他类型时没有CPU拓扑可用，则运行时系统将无法启动。可以使用标志 &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt; 定义CPU拓扑。请注意，必须在命令行上在 &lt;code&gt;+sbt&lt;/code&gt; 标志之前传递 &lt;code&gt;+sct&lt;/code&gt; 标志（如果未自动检测到CPU拓扑）。</target>
        </trans-unit>
        <trans-unit id="dccd7290f5c52ab540d1d1066d43a3aaf228c19a" translate="yes" xml:space="preserve">
          <source>If no argument is provided, Debugger starts in global mode.</source>
          <target state="translated">如果没有提供参数,Debugger在全局模式下启动。</target>
        </trans-unit>
        <trans-unit id="622b281cf52c77f356f35ba9cbbad1c260bbd03f" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt; Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe7b07f514dd69941a31088b490f38f80374e4c" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未指定启动脚本，则默认为 &lt;code&gt;ROOT/bin/start&lt;/code&gt; ，请参见 &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a8687c3d2fddc8ffec405bf127b2012f252abb2" translate="yes" xml:space="preserve">
          <source>If no carrier in &lt;code&gt;pooled_tree&lt;/code&gt; had a large enough free block, we search it again to find any carrier that may act as an entry point into the shared list of all pooled carriers. This in order to, if possible, avoid starting at the sentinel and thereby ease the &quot;bad clustering&quot; problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221abc0dca23710976162240a2b9fb59a1bb2e0e" translate="yes" xml:space="preserve">
          <source>If no clause could be definitely selected, the function returns &lt;code&gt;{false, NewClauses}&lt;/code&gt;, where &lt;code&gt;NewClauses&lt;/code&gt; is the list of entries in &lt;code&gt;Clauses&lt;/code&gt; that remain after eliminating unselectable clauses, preserving the relative order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11dd24d2508db0b969937d6f16c64e7e9a757da" translate="yes" xml:space="preserve">
          <source>If no command-line flag is entered, the &lt;code&gt;Mnesia&lt;/code&gt; directory becomes the current working directory on the node where the Erlang shell is started.</source>
          <target state="translated">如果未输入命令行标志，则 &lt;code&gt;Mnesia&lt;/code&gt; 目录将成为启动Erlang Shell的节点上的当前工作目录。</target>
        </trans-unit>
        <trans-unit id="19b61bf39702f61088362c4f3caf5fec39790a79" translate="yes" xml:space="preserve">
          <source>If no configuration exists for a server, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead, and specify all necessary options in the &lt;code&gt;Options&lt;/code&gt; parameter.</source>
          <target state="translated">如果服务器没有配置，请改用 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; ，然后在 &lt;code&gt;Options&lt;/code&gt; 参数中指定所有必需的选项。</target>
        </trans-unit>
        <trans-unit id="a0a2525519fce3b84f0628d21fec24d0d54a30b8" translate="yes" xml:space="preserve">
          <source>If no configuration file is specified with command &lt;code&gt;ct_run&lt;/code&gt;, a warning is displayed. If &lt;code&gt;Common Test&lt;/code&gt; has been run from the same directory earlier, the same configuration file(s) are used again. If &lt;code&gt;Common Test&lt;/code&gt; has not been run from this directory before, no configuration files are available.</source>
          <target state="translated">如果未使用 &lt;code&gt;ct_run&lt;/code&gt; 命令指定配置文件，则会显示警告。如果先前已从同一目录运行过 &lt;code&gt;Common Test&lt;/code&gt; ，则将再次使用相同的配置文件。如果以前从未从此目录运行过 &lt;code&gt;Common Test&lt;/code&gt; ，则没有配置文件可用。</target>
        </trans-unit>
        <trans-unit id="905acdf151b0fff2093942d03e8fda7ba4d6ef97" translate="yes" xml:space="preserve">
          <source>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned &lt;code&gt;pid&lt;/code&gt; for this process is to be used as input to all other API functions in this module.</source>
          <target state="translated">如果没有提供连接引用，则建立连接，并返回新的连接。启动SSH通道进程以处理与SFTP服务器的通信。此过程返回的 &lt;code&gt;pid&lt;/code&gt; 将用作此模块中所有其他API函数的输入。</target>
        </trans-unit>
        <trans-unit id="a012950e61dc5d03cdb78960de0564c38b5541f9" translate="yes" xml:space="preserve">
          <source>If no encoder module is given, the default is used (which is pretty).</source>
          <target state="translated">如果没有给出编码器模块,则使用默认值(很好看)。</target>
        </trans-unit>
        <trans-unit id="9348a769518853e44d89b99ac342c57ff1b5e15b" translate="yes" xml:space="preserve">
          <source>If no error occurs, the second phase is performed. This phase calls the user defined &lt;code&gt;set&lt;/code&gt; function for all variables.</source>
          <target state="translated">如果没有错误发生，则执行第二阶段。此阶段为所有变量调用用户定义的 &lt;code&gt;set&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3b135a2849366f4513f0e061b53465a7e3a779a4" translate="yes" xml:space="preserve">
          <source>If no exports are listed by an &lt;code&gt;export&lt;/code&gt; option (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details), then if &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under &lt;code&gt;merge/3&lt;/code&gt;.</source>
          <target state="translated">如果没有通过 &lt;code&gt;export&lt;/code&gt; 选项列出任何导出（有关详细信息，请参见 &lt;code&gt;merge_sources/3&lt;/code&gt; ），那么如果 &lt;code&gt;Name&lt;/code&gt; 也是输入模块之一的名称，则将导出该模块；否则，将导出该模块。否则，将导出第一个列出的模块。cf. 在 &lt;code&gt;merge/3&lt;/code&gt; 下的示例。</target>
        </trans-unit>
        <trans-unit id="186696412f510e31ad8ed3a38fb86c31cd6ca5ca" translate="yes" xml:space="preserve">
          <source>If no extra options are specified with flag/option &lt;code&gt;step&lt;/code&gt;, breakpoints are set automatically on the test cases that are to be executed by &lt;code&gt;Common Test&lt;/code&gt;, and those functions only. If step option &lt;code&gt;config&lt;/code&gt; is specified, breakpoints are also initially set on the configuration functions in the suite, that is, &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, &lt;code&gt;end_per_group/2&lt;/code&gt;, &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2&lt;/code&gt;.</source>
          <target state="translated">如果没有通过flag / option &lt;code&gt;step&lt;/code&gt; 指定额外的选项，则将在 &lt;code&gt;Common Test&lt;/code&gt; 和仅那些功能要执行的测试用例上自动设置断点。如果指定了step选项 &lt;code&gt;config&lt;/code&gt; ，则还会在套件的配置函数上初始设置断点，即 &lt;code&gt;init_per_suite/1&lt;/code&gt; ， &lt;code&gt;end_per_suite/1&lt;/code&gt; ， &lt;code&gt;init_per_group/2&lt;/code&gt; ， &lt;code&gt;end_per_group/2&lt;/code&gt; ， &lt;code&gt;init_per_testcase/2&lt;/code&gt; 和 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e1803a2624ccbd4e21f90db6095850fb9331a7" translate="yes" xml:space="preserve">
          <source>If no formatter information is specified for a handler, Logger uses &lt;code&gt;logger_formatter&lt;/code&gt; as default. See the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page for more information about this module.</source>
          <target state="translated">如果未为处理程序指定格式化程序信息，则Logger &lt;code&gt;logger_formatter&lt;/code&gt; 用作默认值。有关此模块的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="41b05b11e2a531a16c3ad32baf03f74559983750" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt; digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534f259af2115bebe106710668093e3ef6ffd155" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未指定图类型，则使用 &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; 创建有向图，否则将 &lt;code&gt;GraphType&lt;/code&gt; 参数作为第二个参数传递给 &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eb03e181763fc340f89dd2fee8a41ea21ee5c23" translate="yes" xml:space="preserve">
          <source>If no guard sequence is evaluated as true, an &lt;code&gt;if_clause&lt;/code&gt; run-time error occurs. If necessary, the guard expression &lt;code&gt;true&lt;/code&gt; can be used in the last branch, as that guard sequence is always true.</source>
          <target state="translated">如果没有任何保护序列被评估为true，则会发生 &lt;code&gt;if_clause&lt;/code&gt; 运行时错误。如有必要，可以在最后一个分支中使用保护表达式 &lt;code&gt;true&lt;/code&gt; ，因为该保护序列始终为true。</target>
        </trans-unit>
        <trans-unit id="b9f6b9adc1152f1b0fd0e1ed73ad8eec4e1f624e" translate="yes" xml:space="preserve">
          <source>If no log with the specified name exist on the specified node, &lt;code&gt;no_such_log&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定节点上不存在具有指定名称的日志，则返回 &lt;code&gt;no_such_log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f6ab79d1d5e9e2cd8b43d5f286fe816764eabff" translate="yes" xml:space="preserve">
          <source>If no match is found for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt; will be the empty string (&lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">如果找不到与 &lt;code&gt;Tag&lt;/code&gt; 匹配的 &lt;code&gt;Result&lt;/code&gt; ，则结果将为空字符串（ &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="668861363db131d12510c671297ba7af08f41273" translate="yes" xml:space="preserve">
          <source>If no more event handlers exist after the deletion, &lt;code&gt;error_logger&lt;/code&gt; is removed as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is stopped.</source>
          <target state="translated">如果删除后不存在任何事件处理程序，则将 &lt;code&gt;error_logger&lt;/code&gt; 删除为Logger处理程序，并停止 &lt;code&gt;error_logger&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="97bba64e22bb5e3d712c27f199cd41bb5ed00da4" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor bridge is not registered.</source>
          <target state="translated">如果没有提供名称,则没有注册主管桥。</target>
        </trans-unit>
        <trans-unit id="145b04378100b2af31635cfab7037e102fc50e14" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor is not registered.</source>
          <target state="translated">如果没有提供姓名,则没有登记监理。</target>
        </trans-unit>
        <trans-unit id="7209e6d7e59cd86554bad77c729bc91b2aac2993" translate="yes" xml:space="preserve">
          <source>If no new memory blocks are inserted into the list, it should eventually be emptied. All pointers to the list however expect to always point to something. This is solved by inserting an empty &quot;marker&quot; element, which only has to purpose of being there in the absense of other elements. That is when the list is empty it only contains this &quot;marker&quot; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962cccbaba0fe2900b8b208ab74fd43b13540b3f" translate="yes" xml:space="preserve">
          <source>If no object with key &lt;code&gt;Key&lt;/code&gt; exists, the function exits with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果不存在带有键 &lt;code&gt;Key&lt;/code&gt; 的对象，则函数以 &lt;code&gt;badarg&lt;/code&gt; 原因退出。</target>
        </trans-unit>
        <trans-unit id="f3ace922192dd1a66ce93d65f216be69e6bdcfa0" translate="yes" xml:space="preserve">
          <source>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and &lt;code&gt;select&lt;/code&gt; is used to traverse the table, that is:</source>
          <target state="translated">如果未指定选项，则将获取读取锁定，每个块中返回100个结果，并使用 &lt;code&gt;select&lt;/code&gt; 遍历表，即：</target>
        </trans-unit>
        <trans-unit id="be43c0999b074d475f47490047515316aff57a56" translate="yes" xml:space="preserve">
          <source>If no or an unknown version is given, the &lt;strong&gt;best&lt;/strong&gt; version is used (which is v3).</source>
          <target state="translated">如果没有给出或未知的版本，则使用&lt;strong&gt;最佳&lt;/strong&gt;版本（即v3）。</target>
        </trans-unit>
        <trans-unit id="bc0db3920bc02374e1ab1e1eb3ced79753b79531" translate="yes" xml:space="preserve">
          <source>If no output comes from the Erlang shell, but the Erlang machine still seems to be alive, an &quot;ALIVE&quot; message is written to the log; it is a time stamp and is written, by default, after 15 minutes of inactivity. Also, if output from Erlang is logged, but more than 5 minutes (default) has passed since last time we got anything from Erlang, a time stamp is written in the log. The &quot;ALIVE&quot; messages look as follows:</source>
          <target state="translated">如果Erlang shell没有任何输出,但是Erlang机器似乎还活着,那么 &quot;ALIVE &quot;消息会被写入日志;这是一个时间戳,默认情况下,在15分钟没有活动之后写入。另外,如果Erlang的输出被记录下来,但距离上次从Erlang得到任何东西已经超过5分钟(默认),那么日志中会写下一个时间戳。ALIVE &quot;消息的内容如下。</target>
        </trans-unit>
        <trans-unit id="e2dda439a8b57752f5158a6910e3f618737cb035" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt; set_process_metadata/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609daf9d4941227cdd07f7a145c9f4b97a9dd23d" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果不存在任何进程元数据，则该函数的行为为 &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bcf9e8cbdaa54440e55a1604d7759707d84c686" translate="yes" xml:space="preserve">
          <source>If no response is received before &lt;code&gt;WaitTime&lt;/code&gt; milliseconds, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by &lt;code&gt;erpc:check_response()&lt;/code&gt;, &lt;code&gt;erpc:receive_response()&lt;/code&gt;, or &lt;code&gt;erpc:wait_response()&lt;/code&gt;. If a response is received, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:wait_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected or if an invalid &lt;code&gt;WaitTime&lt;/code&gt; is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129f0fba3cda34f511f81ef498c5983a08b6fef4" translate="yes" xml:space="preserve">
          <source>If no service name is specified, a brief listing of all Erlang services is presented. If a service name is supplied, all options for that service are presented.</source>
          <target state="translated">如果没有指定服务名称,则会显示所有 Erlang 服务的简要列表。如果提供了服务名称,则会显示该服务的所有选项。</target>
        </trans-unit>
        <trans-unit id="f74a0bc86a24e556d294700bf2367dba448274f4" translate="yes" xml:space="preserve">
          <source>If no specific browser start command is specified, Firefox is the default browser on Unix platforms, and Internet Explorer on Windows. If &lt;code&gt;Common Test&lt;/code&gt; fails to start a browser automatically, or &lt;code&gt;none&lt;/code&gt; is specified as the value for &lt;code&gt;-browser&lt;/code&gt; (that is, &lt;code&gt;-browser none&lt;/code&gt;), start your favourite browser manually and type the URL that &lt;code&gt;Common Test&lt;/code&gt; displays in the shell.</source>
          <target state="translated">如果未指定特定的浏览器启动命令，则Firefox是Unix平台上的默认浏览器，而是Windows上的Internet Explorer。如果 &lt;code&gt;Common Test&lt;/code&gt; 无法自动启动浏览器，或者 &lt;code&gt;none&lt;/code&gt; 被指定为值 &lt;code&gt;-browser&lt;/code&gt; （即 &lt;code&gt;-browser none&lt;/code&gt; ），手动启动你喜欢的浏览器，键入URL是 &lt;code&gt;Common Test&lt;/code&gt; 显示在外壳。</target>
        </trans-unit>
        <trans-unit id="3bd56a176fb29e1e8248ad526f6f69316f9b58af" translate="yes" xml:space="preserve">
          <source>If no such fun is registered, &lt;code&gt;beam_lib&lt;/code&gt; instead searches for an &lt;code&gt;.erlang.crypt&lt;/code&gt; file, see the next section.</source>
          <target state="translated">如果未注册此类乐趣，则 &lt;code&gt;beam_lib&lt;/code&gt; 会搜索 &lt;code&gt;.erlang.crypt&lt;/code&gt; 文件，请参阅下一节。</target>
        </trans-unit>
        <trans-unit id="287f2765f0e3b66bca8a3294ba1f1a9c4a144428" translate="yes" xml:space="preserve">
          <source>If no support is found for any tool, this function returns &lt;code&gt;{skip, Explanation}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40469f7012f9c99e344b26a6dfa3a4f344430f04" translate="yes" xml:space="preserve">
          <source>If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative &lt;code&gt;Time = 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b73a3ec1f7134600f89a051364f83c286cb4411" translate="yes" xml:space="preserve">
          <source>If no transformation rule match, the loader will begin rewriting the first of generic instructions to a specific instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d762df86c391a1b492c91b19c8e6c06437bbda" translate="yes" xml:space="preserve">
          <source>If no user configuration file is specified and Erlang is started in non-distributed or short name distributed mode, Erlang uses default configuration settings and a native lookup method that works correctly under most circumstances. Erlang reads no information from system &lt;code&gt;inet&lt;/code&gt; configuration files (such as &lt;code&gt;/etc/host.conf&lt;/code&gt; and &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;) in these modes, except for &lt;code&gt;/etc/resolv.conf&lt;/code&gt; and &lt;code&gt;/etc/hosts&lt;/code&gt; that is read and monitored for changes on Unix platforms for the internal DNS client &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">如果未指定用户配置文件，并且以非分布式或短名称分布式模式启动Erlang，则Erlang使用默认配置设置和本机查找方法，该方法在大多数情况下都可以正常工作。在这些模式下，Erlang不会从系统 &lt;code&gt;inet&lt;/code&gt; 配置文件（例如 &lt;code&gt;/etc/host.conf&lt;/code&gt; 和 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ）中读取任何信息，除了 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 和 &lt;code&gt;/etc/hosts&lt;/code&gt; 会读取并监视其更改之外在Unix平台上用于内部DNS客户端 &lt;code&gt;inet_res(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13936c5aba4f403aada92256e268f1fefbc0b6d4" translate="yes" xml:space="preserve">
          <source>If no value for &lt;code&gt;Retries&lt;/code&gt; is specified, &lt;code&gt;infinity&lt;/code&gt; is used.</source>
          <target state="translated">如果未指定&amp;ldquo; &lt;code&gt;Retries&lt;/code&gt; 值，则使用 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="205ea9177e47ff562742443567460c481c26083e" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;delayed_write&lt;/code&gt; or &lt;code&gt;{delayed_write,Size,Delay}&lt;/code&gt; is found in the list, &lt;code&gt;delayed_write&lt;/code&gt; is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b55a7b8716a559ffcad32612bbf10761dc5678f" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;exclusive&lt;/code&gt; is found in the list, &lt;code&gt;append&lt;/code&gt; is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3223fb92528e085bdc89d88a03ccfd3c590d9" translate="yes" xml:space="preserve">
          <source>If none of the above are available for your architecture/compiler, you are recommended to build and install &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; before building Erlang/OTP. The &lt;code&gt;libatomic_ops&lt;/code&gt; library provides native atomic memory operations for a variety of architectures and compilers. When building Erlang/OTP you need to inform the build system of where the &lt;code&gt;libatomic_ops&lt;/code&gt; library is installed using the &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt;&lt;code&gt;configure&lt;/code&gt; switch.</source>
          <target state="translated">如果以上都不适用于您的体系结构/编译器，建议您在构建Erlang / OTP之前先构建并安装 &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;libatomic_ops&lt;/code&gt; 库提供原生原子存储器操作，适用于各种架构和编译器。在构建Erlang / OTP时，您需要使用 &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt; &lt;code&gt;configure&lt;/code&gt; 开关来通知构建系统 &lt;code&gt;libatomic_ops&lt;/code&gt; 库的安装位置。</target>
        </trans-unit>
        <trans-unit id="9440ff5a97925b9c13d62c177e03518391502a24" translate="yes" xml:space="preserve">
          <source>If none of the first three clauses match, the fourth clause match as a variable always matches.</source>
          <target state="translated">如果前三个子句都不匹配,第四个子句匹配作为一个变量总是匹配的。</target>
        </trans-unit>
        <trans-unit id="f62e5b4dade736a66aa048e49499435f1f4d7fdc" translate="yes" xml:space="preserve">
          <source>If none of the strings in &lt;code&gt;Pattern&lt;/code&gt; is found, the atom &lt;code&gt;nomatch&lt;/code&gt; is returned.</source>
          <target state="translated">如果在 &lt;code&gt;Pattern&lt;/code&gt; 中找不到任何字符串，则返回原子不 &lt;code&gt;nomatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeb11b61b9cc24cd2031d9dda015e2462ccc0499" translate="yes" xml:space="preserve">
          <source>If none of the strings in a pattern is found, an empty list is returned.</source>
          <target state="translated">如果在模式中没有找到任何字符串,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="c826d8a5c30fbaafd8ba535e4315b2bb2ea4206a" translate="yes" xml:space="preserve">
          <source>If not containing a &quot;pre_shared_key&quot; extension, it MUST contain both a &quot;signature_algorithms&quot; extension and a &quot;supported_groups&quot; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652472f45cf3561f5b3dd17763a17700dfcd88cc" translate="yes" xml:space="preserve">
          <source>If not empty, a scheduler internal auxiliary work is scheduled to be done.</source>
          <target state="translated">如果不为空,则安排做一个调度器内部辅助工作。</target>
        </trans-unit>
        <trans-unit id="9937b44a2ec57528d4de1534b4257202ba316ad9" translate="yes" xml:space="preserve">
          <source>If not implemented, the CTH acts as if this function returned a call to &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">如果未实现，则CTH就像该函数返回了对 &lt;code&gt;make_ref/0&lt;/code&gt; 的调用一样。</target>
        </trans-unit>
        <trans-unit id="c288cca9f0fb59e5fd99ac4b40424bd7ecc21978" translate="yes" xml:space="preserve">
          <source>If not present, audit trail logging is not used.</source>
          <target state="translated">如果不存在,则不使用审计线索记录。</target>
        </trans-unit>
        <trans-unit id="3dcb002efb7975058562ec638f68a0e701480231" translate="yes" xml:space="preserve">
          <source>If not set, &lt;code&gt;ei&lt;/code&gt; will implement the timeout using &lt;code&gt;select()&lt;/code&gt; in order to determine when to call the callbacks and when to time out. The &lt;code&gt;tmo&lt;/code&gt; arguments of the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks should be ignored. The callbacks may be called in non-blocking mode. The callbacks are not allowed to change between blocking and non-blocking mode. In order for this to work, &lt;code&gt;select()&lt;/code&gt; needs to interact with the socket primitives used the same way as it interacts with the ordinary socket primitives. If this is not the case, the callbacks &lt;strong&gt;need&lt;/strong&gt; to implement timeouts and this flag should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3b7ad4aa64090ecee7bb02c7f143402ada38cd" translate="yes" xml:space="preserve">
          <source>If not, the &lt;code&gt;&lt;a href=&quot;#type-reason&quot;&gt;reason()&lt;/a&gt;&lt;/code&gt; indicates what went wrong:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e29374c41854c469f97e992cbb29625d1d3ef4" translate="yes" xml:space="preserve">
          <source>If not, this is the atom &lt;code&gt;all&lt;/code&gt; which implies that the &lt;code&gt;UtilDesc&lt;/code&gt; contains information about all CPUs.</source>
          <target state="translated">如果不是，则这是原子的 &lt;code&gt;all&lt;/code&gt; ，这意味着 &lt;code&gt;UtilDesc&lt;/code&gt; 包含有关所有CPU的信息。</target>
        </trans-unit>
        <trans-unit id="f15293549ba601ce95a5307be4274cf3a235ee45" translate="yes" xml:space="preserve">
          <source>If not, this is the sum of the percentage shares of the CPU cycles spent in all states identified as busy.</source>
          <target state="translated">如果没有,则是在所有确定为繁忙的状态中所花费的CPU周期的百分比份额之和。</target>
        </trans-unit>
        <trans-unit id="a5425f5051ad47a7b173e5435c9b894080331b92" translate="yes" xml:space="preserve">
          <source>If nothing else is stated, it is presumed that the &lt;code&gt;otptest&lt;/code&gt; user has an entry in the &lt;strong&gt;authorized_keys&lt;/strong&gt; file of &lt;strong&gt;tarlop&lt;/strong&gt; (allowed to log in over &lt;code&gt;ssh&lt;/code&gt; without entering a password). Also, &lt;strong&gt;tarlop&lt;/strong&gt; is a known host in the &lt;code&gt;known_hosts&lt;/code&gt; file of the user &lt;code&gt;otptest&lt;/code&gt;. This means that host-verification can be done without user-interaction.</source>
          <target state="translated">如果没有其他说明，推测该 &lt;code&gt;otptest&lt;/code&gt; 用户在入口&lt;strong&gt;的authorized_keys&lt;/strong&gt;的文件&lt;strong&gt;tarlop&lt;/strong&gt;（允许登录过 &lt;code&gt;ssh&lt;/code&gt; 无需输入密码）。另外，&lt;strong&gt;tarlop&lt;/strong&gt;是用户 &lt;code&gt;otptest&lt;/code&gt; 的 &lt;code&gt;known_hosts&lt;/code&gt; 文件中的已知主机。这意味着无需用户交互即可完成主机验证。</target>
        </trans-unit>
        <trans-unit id="85b52863c7b73a113224224b8a0c4d01a407b7d9" translate="yes" xml:space="preserve">
          <source>If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.</source>
          <target state="translated">如果在表被固定的时候已经添加了对象,那么当表被释放时,哈希列表就会开始增长,这就会在一段时间内大大降低对表的访问速度。</target>
        </trans-unit>
        <trans-unit id="828acc15f06ea3d0ebf75bc3294946979fd85c6d" translate="yes" xml:space="preserve">
          <source>If on the other hand the Version argument is an integer, it means that this is the expected version of the message and the decoder for that version should be used.</source>
          <target state="translated">如果另一方面,Version参数是一个整数,这意味着这是消息的预期版本,应该使用该版本的解码器。</target>
        </trans-unit>
        <trans-unit id="7ee7ad00a53993074166a752357e3a491c2d6eb1" translate="yes" xml:space="preserve">
          <source>If one &lt;strong&gt;really&lt;/strong&gt; wants to monitor when the driver gets unloaded, this message distorts the picture, because no unloading was done. Option &lt;code&gt;unloaded_only&lt;/code&gt; creates a monitor similar to an &lt;code&gt;unloaded&lt;/code&gt; monitor, but never results in this message.</source>
          <target state="translated">如果&lt;strong&gt;确实&lt;/strong&gt;要监视何时卸载驱动程序，此消息会使图片失真，因为没有完成卸载。选项 &lt;code&gt;unloaded_only&lt;/code&gt; 创建类似于监控器 &lt;code&gt;unloaded&lt;/code&gt; 的显示器，但决不会导致此消息。</target>
        </trans-unit>
        <trans-unit id="c5ebea37f196f871b2a70d380f83941fc18ead49" translate="yes" xml:space="preserve">
          <source>If one UTF character is split over two consecutive binaries in the &lt;code&gt;Data&lt;/code&gt;, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring.</source>
          <target state="translated">如果将一个UTF字符分成两个连续的二进制 &lt;code&gt;Data&lt;/code&gt; ，则转换成功。这意味着只要将整个范围指定为输入而不会发生错误，就可以从一定范围的二进制文件中解码字符。</target>
        </trans-unit>
        <trans-unit id="90ed92af5805bd230adc121faf96993bce08b918" translate="yes" xml:space="preserve">
          <source>If one of the &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</source>
          <target state="translated">如果设置了 &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; 标志之一，并且运行时系统不支持脏调度程序，则运行时系统将拒绝加载NIF库。</target>
        </trans-unit>
        <trans-unit id="da2865f4d243741aece7d05e455898a782a870b4" translate="yes" xml:space="preserve">
          <source>If one of the nodes cannot process monitors, for example, C or Java nodes, and the &lt;code&gt;gen_server&lt;/code&gt; process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole &lt;code&gt;Timeout&lt;/code&gt;, which may be infinity.</source>
          <target state="translated">如果某个节点无法处理监视器（例如C或Java节点），并且 &lt;code&gt;gen_server&lt;/code&gt; 进程在发送请求时未启动，而是在2秒内启动，则此函数将等待整个 &lt;code&gt;Timeout&lt;/code&gt; ，这可能是无限的。</target>
        </trans-unit>
        <trans-unit id="2ff50154efe11e68e30a0801c8327e55b0714e5d" translate="yes" xml:space="preserve">
          <source>If one or more carriers could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">如果一个或多个载波无法在不损害系统响应能力的情况下进行完整扫描，则 &lt;code&gt;UnscannedSize&lt;/code&gt; 是必须跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="9b3b6b44750cd929fb5194f2e7f17a52f91bfeb2" translate="yes" xml:space="preserve">
          <source>If only one access file exists, setting this parameter to &lt;code&gt;none&lt;/code&gt; can ease the burden on the server as the server then stops looking for access files.</source>
          <target state="translated">如果只有一个访问文件，则将此参数设置为 &lt;code&gt;none&lt;/code&gt; 可以减轻服务器的负担，因为服务器随后将停止寻找访问文件。</target>
        </trans-unit>
        <trans-unit id="78efdbd37020ca2e2d25f04642dce2c0495aa809" translate="yes" xml:space="preserve">
          <source>If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:</source>
          <target state="translated">如果只有一个字母被指定为\p或\P,它包括所有以该字母开头的一般类别属性。在这种情况下,如果没有否定句,转义序列中的大括号是可选的。下面的两个例子具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="d1f740d3ae5b1c6572bd4172c4f16e8373ec6b45" translate="yes" xml:space="preserve">
          <source>If only one value is present, it is the current value. &lt;code&gt;fix_alloc&lt;/code&gt; memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</source>
          <target state="translated">如果仅存在一个值，则为当前值。 &lt;code&gt;fix_alloc&lt;/code&gt; 内存块类型由两个值表示。第一个值是内存池大小，第二个值是已用内存大小。</target>
        </trans-unit>
        <trans-unit id="c5da55d1092af23b098acf7d69c8679113b881cd" translate="yes" xml:space="preserve">
          <source>If only the module name (i.e. not the full name of the &lt;code&gt;.beam&lt;/code&gt; file) is given to this function, the &lt;code&gt;.beam&lt;/code&gt; file is found by calling &lt;code&gt;code:which(Module)&lt;/code&gt;. If no &lt;code&gt;.beam&lt;/code&gt; file is found, the error reason &lt;code&gt;non_existing&lt;/code&gt; is returned. If the module is already cover compiled with &lt;code&gt;compile_beam/1&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; file will be picked from the same location as the first time it was compiled. If the module is already cover compiled with &lt;code&gt;compile/1,2&lt;/code&gt;, there is no way to find the correct &lt;code&gt;.beam&lt;/code&gt; file, so the error reason &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; is returned.</source>
          <target state="translated">如果仅给该函数指定模块名称（即不是 &lt;code&gt;.beam&lt;/code&gt; 文件的全名），则可以通过调用 &lt;code&gt;code:which(Module)&lt;/code&gt; 找到 &lt;code&gt;.beam&lt;/code&gt; 文件。如果未找到 &lt;code&gt;.beam&lt;/code&gt; 文件，则返回错误原因 &lt;code&gt;non_existing&lt;/code&gt; 。如果模块已经覆盖编译 &lt;code&gt;compile_beam/1&lt;/code&gt; 时， &lt;code&gt;.beam&lt;/code&gt; 文件将作为第一次被编在同一位置进行挑选。如果模块已经被 &lt;code&gt;compile/1,2&lt;/code&gt; 编译，则无法找到正确的 &lt;code&gt;.beam&lt;/code&gt; 文件，因此返回错误原因 &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84bdcab65ed9e153d52722d8ccf698faa98c0614" translate="yes" xml:space="preserve">
          <source>If only undefined options are requested the resulting list can be empty.</source>
          <target state="translated">如果只要求未定义的选项,结果列表可以是空的。</target>
        </trans-unit>
        <trans-unit id="c3d6b0c4be9ac174bfcec9988c3498fdbe5d2f55" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">如果选项 &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; ，通过调试 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 被激活。</target>
        </trans-unit>
        <trans-unit id="0d1d165321c33bcdb22f8f6a5267e4f891a4d819" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {debug,Dbgs} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ab9ca1d15e67f3dd0537fe7133aa59008f55d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after,HibernateAfterTimeout} &lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3aa68b73e10a456d4b0d56c548ffefa2777a94" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {spawn_opt,SpawnOpts} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba326e78241846819e3473e15898cf1eb3e7fec" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {timeout,Time} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769611976869b84c5779bcf180081ddcd9ad1bfa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;c&lt;/code&gt; is used with &lt;code&gt;oldshell&lt;/code&gt; on Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; will restart the shell process rather than interrupt it.</source>
          <target state="translated">如果选项 &lt;code&gt;c&lt;/code&gt; 与Unix 上的 &lt;code&gt;oldshell&lt;/code&gt; 一起使用，则 &lt;code&gt;Ctrl-C&lt;/code&gt; 将重新启动shell进程而不是中断它。</target>
        </trans-unit>
        <trans-unit id="096a0eaa955fff41e809fc817940102bc82e3b7a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compact&lt;/code&gt; is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option &lt;code&gt;decimals&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;compact&lt;/code&gt; ，则列表末尾的结尾零将被截断。此选项仅与选项 &lt;code&gt;decimals&lt;/code&gt; 一起有意义。</target>
        </trans-unit>
        <trans-unit id="e006a20906cf19e410666b42e37a9c3e19a3e41a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compressed&lt;/code&gt; is provided, the external term format is compressed. The compressed format is automatically recognized by &lt;code&gt;binary_to_term/1&lt;/code&gt; as from Erlang/OTP R7B.</source>
          <target state="translated">如果提供了 &lt;code&gt;compressed&lt;/code&gt; 选项，则外部术语格式将被压缩。从Erlang / OTP R7B开始， &lt;code&gt;binary_to_term/1&lt;/code&gt; 会自动识别压缩格式。</target>
        </trans-unit>
        <trans-unit id="5de3ee850f4f14cadbc9c1e776ec192b168f5ad1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;decimals&lt;/code&gt; is specified, the returned value contains at most &lt;code&gt;Decimals&lt;/code&gt; number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果选择 &lt;code&gt;decimals&lt;/code&gt; 指定，返回值包含最多 &lt;code&gt;Decimals&lt;/code&gt; 的位数过去的小数点数。如果该数字不适合256个字节的内部静态缓冲区，则该函数将抛出 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d32ea21453f7c1a1069cac8907bb379c47719c1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;eof&lt;/code&gt; is specified also, the messages &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;exit_status&lt;/code&gt; appear in an unspecified order.</source>
          <target state="translated">如果还指定了选项 &lt;code&gt;eof&lt;/code&gt; ，则消息 &lt;code&gt;eof&lt;/code&gt; 和 &lt;code&gt;exit_status&lt;/code&gt; 将以未指定的顺序显示。</target>
        </trans-unit>
        <trans-unit id="32ae7856c177425822832835b7fef1768d20a52e" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;force&lt;/code&gt; has been passed, but the driver of the port does not allow forcing through a busy port.</source>
          <target state="translated">如果已通过选件 &lt;code&gt;force&lt;/code&gt; ，但端口的驱动程序不允许强制通过繁忙的端口。</target>
        </trans-unit>
        <trans-unit id="441c9bb025fc2889c41f42aea8b90d9817c38b34" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the formatting is automatically done when stopping &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">如果将选项 &lt;code&gt;format&lt;/code&gt; 指定为 &lt;code&gt;ttb:stop/1&lt;/code&gt; ，则在停止 &lt;code&gt;ttb&lt;/code&gt; 时会自动进行格式化。</target>
        </trans-unit>
        <trans-unit id="5d2376aceac49d07a344ae2362a017172221e3a6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the trace logs are automatically formatted after tracing is stopped.</source>
          <target state="translated">如果将选项 &lt;code&gt;format&lt;/code&gt; 指定为 &lt;code&gt;ttb:stop/1&lt;/code&gt; ，则在停止跟踪之后将自动格式化跟踪日志。</target>
        </trans-unit>
        <trans-unit id="06c4d5d9e31e528aa6774014ad6ec78d401b5e9f" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;info&lt;/code&gt; is combined with option &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is returned if a flush was needed, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;info&lt;/code&gt; 与选项 &lt;code&gt;flush&lt;/code&gt; 结合使用，则需要刷新时返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6534bbbe7210a2a4f9c6ad85ccdb4879fb04d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;kill_ports&lt;/code&gt; is used, monitor trigging is crucial, as the ports are not guaranteed to be killed until the driver is unloaded. Thus, a monitor must be triggered for at least the &lt;code&gt;pending_driver&lt;/code&gt; case.</source>
          <target state="translated">如果使用选项 &lt;code&gt;kill_ports&lt;/code&gt; ，则监视触发至关重要，因为在卸载驱动程序之前，不能保证杀死端口。因此，必须至少在 &lt;code&gt;pending_driver&lt;/code&gt; 情况下触发监视器。</target>
        </trans-unit>
        <trans-unit id="6aa1db8f0800b8eada993c86c8a59c1d17dfb52c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, all other options return &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt;, respectively.</source>
          <target state="translated">如果选项 &lt;code&gt;linked_in_driver&lt;/code&gt; 或 &lt;code&gt;permanent&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则所有其他选项分别返回 &lt;code&gt;linked_in_driver&lt;/code&gt; 或 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c57ff6b7c6782f60fe59ca940f65912e4d479346" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;monitor&lt;/code&gt; is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;monitor&lt;/code&gt; ，则将监视新创建的进程，并返回该监视器的pid和引用。</target>
        </trans-unit>
        <trans-unit id="04d4436e947c7fe2bfe4be7b9ccd10a7ac2337af" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;no_dot_erlang&lt;/code&gt; is specified, the instruction to load the &lt;code&gt;.erlang&lt;/code&gt; file during boot is &lt;strong&gt;not&lt;/strong&gt; included.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;no_dot_erlang&lt;/code&gt; ，&lt;strong&gt;则不&lt;/strong&gt;包括在引导过程中加载 &lt;code&gt;.erlang&lt;/code&gt; 文件的指令。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd0a5200f0c674efc5a1ca9a83309cd9b7fe26b6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;noexec&lt;/code&gt; is specified, the function returns the same values as for &lt;code&gt;silent&lt;/code&gt; but no &lt;code&gt;relup&lt;/code&gt; file is created.</source>
          <target state="translated">如果选项 &lt;code&gt;noexec&lt;/code&gt; 指定，则函数返回值相同的 &lt;code&gt;silent&lt;/code&gt; ，但没有 &lt;code&gt;relup&lt;/code&gt; 创建文件。</target>
        </trans-unit>
        <trans-unit id="3c2f80ddb4accdf1246a3219780f43c13b4e27f2" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;purge&lt;/code&gt; is specified, all old code that can be soft-purged is purged after all other checks are successfully completed. This can be useful to reduce the time needed by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;purge&lt;/code&gt; 选项，则在所有其他检查成功完成后，将清除所有可以软清除的旧代码。这对于减少 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt; 所需的时间很有用。</target>
        </trans-unit>
        <trans-unit id="f207e9cbf62b31891d035fb3346f08b4121c927b" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;restart_emulator&lt;/code&gt; is specified, a low-level instruction to restart the emulator is appended to the &lt;code&gt;relup&lt;/code&gt; file. This ensures that a complete reboot of the system is done when the system is upgraded or downgraded.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;restart_emulator&lt;/code&gt; ，则将重新启动仿真器的低级指令附加到 &lt;code&gt;relup&lt;/code&gt; 文件中。这样可以确保在升级或降级系统时，完全重启系统。</target>
        </trans-unit>
        <trans-unit id="ef31277dfcdd9b3fea33e70696e85cc6a58e6495" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;scientific&lt;/code&gt; is specified, the float is formatted using scientific notation with &lt;code&gt;Decimals&lt;/code&gt; digits of precision.</source>
          <target state="translated">如果指定了 &lt;code&gt;scientific&lt;/code&gt; 选项，则使用科学计数法将浮点数格式化为精度的 &lt;code&gt;Decimals&lt;/code&gt; 位数。</target>
        </trans-unit>
        <trans-unit id="68354b12f57b501c10eb39d65b11549593ad808d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;src_tests&lt;/code&gt; is specified, a warning is issued if the source code for a module is missing or is newer than the object code.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;src_tests&lt;/code&gt; ，则如果模块的源代码丢失或比目标代码新，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="3b698628086185a232f3b1c8c64f2b5821c29478" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;sync&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it ensures that the content of the file is written to the disk before &lt;code&gt;tab2file&lt;/code&gt; returns. Defaults to &lt;code&gt;{sync, false}&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;sync&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则确保在 &lt;code&gt;tab2file&lt;/code&gt; 返回之前将文件的内容写入磁盘。默认为 &lt;code&gt;{sync, false}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16c1274c0980810787faf4c8323f084b49c5a2fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;ungreedy&lt;/code&gt; is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior.</source>
          <target state="translated">如果设置了选项 &lt;code&gt;ungreedy&lt;/code&gt; （Perl中不提供该选项），则默认情况下，量词不是贪婪的，但是可以通过在问号后面加上问号来使各个量词成为贪婪的对象。也就是说，它会反转默认行为。</target>
        </trans-unit>
        <trans-unit id="6ebecfa9ef794349da407c48663db38e0205dfc1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;url_base&lt;/code&gt; is set, an extra attribute named &lt;code&gt;url&lt;/code&gt; is added to each &lt;code&gt;testsuite&lt;/code&gt; and &lt;code&gt;testcase&lt;/code&gt; XML element. The value is constructed from &lt;code&gt;url_base&lt;/code&gt; and a relative path to the test suite or test case log, respectively, for example:</source>
          <target state="translated">如果设置了选项 &lt;code&gt;url_base&lt;/code&gt; ，则将一个名为 &lt;code&gt;url&lt;/code&gt; 的额外属性添加到每个 &lt;code&gt;testsuite&lt;/code&gt; 和 &lt;code&gt;testcase&lt;/code&gt; XML元素。该值分别由 &lt;code&gt;url_base&lt;/code&gt; 和测试套件或测试用例日志的相对路径构造而成，例如：</target>
        </trans-unit>
        <trans-unit id="7a53503422cb0ac19329aceb31af878b5ec300e5" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;warnings_as_errors&lt;/code&gt; is specified, warnings are treated as errors.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;warnings_as_errors&lt;/code&gt; ，则将警告视为错误。</target>
        </trans-unit>
        <trans-unit id="41ac36f3b8b38269747bee1634966538895f2ee4" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{debug,Dbgs}&lt;/code&gt; is present, the corresponding &lt;code&gt;sys&lt;/code&gt; function is called for each item in &lt;code&gt;Dbgs&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果选项 &lt;code&gt;{debug,Dbgs}&lt;/code&gt; 存在，则相应的 &lt;code&gt;sys&lt;/code&gt; 函数被调用用于每个项目 &lt;code&gt;Dbgs&lt;/code&gt; ; 参见 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65c08f8f94d4db76f6cc364152658be9a80df8fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e804aab039286890448ffee48895432a1b352c17" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{handshake, hello}&lt;/code&gt; 则握手在收到客户端问候消息后暂停，并且成功响应为 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 而不是 &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。此后，通过调用 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 来继续或取消握手。</target>
        </trans-unit>
        <trans-unit id="9802b121f3f842baa16ccec18f6827e8efefe976" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_event&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; ，则 &lt;code&gt;gen_event&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80d6ad9348d486b54eb01008ea70fa22ab22a998" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1afccf80e87b972a02a03ba25b3fcfd4c6d492f1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. A directory in the path can be specified with a wildcard &lt;code&gt;*&lt;/code&gt;, this is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{path,[Dir]}&lt;/code&gt; ，则此路径将附加到当前路径。路径中的目录可以用通配符 &lt;code&gt;*&lt;/code&gt; 指定，该目录会扩展到所有匹配的目录。示例： &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="521a357383f837ccbed508cea165f5ba1a72a4ba" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories, for example, &lt;code&gt;lib/*/ebin&lt;/code&gt;.</source>
          <target state="translated">如果指定了选项 &lt;code&gt;{path,[Dir]}&lt;/code&gt; ，则此路径将附加到当前路径。通配符 &lt;code&gt;*&lt;/code&gt; 会扩展到所有匹配的目录，例如 &lt;code&gt;lib/*/ebin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a5e0fc842c3e7f86267427d3814bd82d53e295a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt; spawn_opt/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319e803f0c4dc5797ff076e88abf3ae72c4731f8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt;spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; ， &lt;code&gt;SOpts&lt;/code&gt; 作为选项列表传递给 &lt;code&gt;spawn_opt&lt;/code&gt; BIF，该BIF用于生成 &lt;code&gt;gen_server&lt;/code&gt; 进程；参见 &lt;code&gt;spawn_opt/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f134a5284d4d1605e5d535d5f02614e7f9564b83" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">如果选项 &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; ， &lt;code&gt;SpawnOpts&lt;/code&gt; 作为选项列表以传递 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; ，其用于产卵 &lt;code&gt;gen_statem&lt;/code&gt; 过程。</target>
        </trans-unit>
        <trans-unit id="c971670358afb5846db5d77c2b0b19aad5a3c579" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果选择 &lt;code&gt;{timeout,Time}&lt;/code&gt; 存在于 &lt;code&gt;Opts&lt;/code&gt; 的 &lt;code&gt;gen_statem&lt;/code&gt; 允许花 &lt;code&gt;Time&lt;/code&gt; 毫秒初始化或将终止，并开始函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="341a32ddba103c08ae86b78ec53524b7702998b8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it is terminated and the start function returns &lt;code&gt;{error,timeout}&lt;/code&gt;.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{timeout,Time}&lt;/code&gt; ，则允许 &lt;code&gt;gen_server&lt;/code&gt; 进程花费 &lt;code&gt;Time&lt;/code&gt; 毫秒初始化或终止它，并且start函数返回 &lt;code&gt;{error,timeout}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a928786d0e9ca7308ebc039e35ade6afdfb8bc1d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="translated">如果存在选项 &lt;code&gt;{tls, tls_options()}&lt;/code&gt; ，则FTP会话通过 &lt;code&gt;tls&lt;/code&gt; （ &lt;code&gt;ftps&lt;/code&gt; ，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt; ）进行传输。列表 &lt;code&gt;tls_options()&lt;/code&gt; 可以为空。函数 &lt;code&gt;ssl:connect/3&lt;/code&gt; 用于保护控制连接和数据会话。</target>
        </trans-unit>
        <trans-unit id="20a3a531905a20d30fd9f374cce827942989f5e9" translate="yes" xml:space="preserve">
          <source>If option&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果存在选项 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;gen_statem&lt;/code&gt; 进程将等待任何消息达 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 毫秒，如果未收到任何消息，则该进程将自动进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2fd0a104622064a3e02a4f4c3eca0f47d309b91b" translate="yes" xml:space="preserve">
          <source>If or when &lt;code&gt;monitor/2&lt;/code&gt; is extended, other possible values for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;Info&lt;/code&gt; in the monitor message will be introduced.</source>
          <target state="translated">如果或当 &lt;code&gt;monitor/2&lt;/code&gt; 扩展时，将在监视器消息中引入 &lt;code&gt;Tag&lt;/code&gt; ， &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Info&lt;/code&gt; 的其他可能值。</target>
        </trans-unit>
        <trans-unit id="a47b00202aed4c182ff58ce236e280bf55db7d71" translate="yes" xml:space="preserve">
          <source>If other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have the driver loaded, this option has no effect.</source>
          <target state="translated">如果其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 已加载驱动程序，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="597bab21aef8fd8fbc55474998e0dbac33663b0f" translate="yes" xml:space="preserve">
          <source>If padding is &lt;code&gt;{padding,none}&lt;/code&gt; or not specifed and the total data from all subsequent &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_updates&lt;/a&gt;&lt;/code&gt; does not fill the last block fully, that last data is lost. In case of &lt;code&gt;{padding,none}&lt;/code&gt; there will be an error in this case. If padding is not specified, the bytes of the unfilled block is silently discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1578eb3698cf666fa7f690b04c9f11cc163c2d2b" translate="yes" xml:space="preserve">
          <source>If padding was not enabled, the call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; may be excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b3ce2063e2924ca7e8faa87611f5b6c2819567" translate="yes" xml:space="preserve">
          <source>If parameter &lt;code&gt;Dates&lt;/code&gt; is specified, the reports are filtered according to the date when they occurred. If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateFrom, from}&lt;/code&gt;, reports that occurred after &lt;code&gt;DateFrom&lt;/code&gt; are displayed.</source>
          <target state="translated">如果指定参数&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; ，则根据报告的发生日期对报告进行过滤。如果&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; 的格式为 &lt;code&gt;{DateFrom, from}&lt;/code&gt; ，则显示在 &lt;code&gt;DateFrom&lt;/code&gt; 之后发生的报告。</target>
        </trans-unit>
        <trans-unit id="6511239690521e295477c51f44e7169510af0e54" translate="yes" xml:space="preserve">
          <source>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">如果可能的话,在对表进行迭代之前,避免在同一个事务中写入或删除记录。</target>
        </trans-unit>
        <trans-unit id="3eb1eeddf032eb186133fc7df8919fb2d11d384d" translate="yes" xml:space="preserve">
          <source>If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application.</source>
          <target state="translated">如果可能的话,客户端会根据配置和当前的情况,保持其连接的活力,并使用有或没有管道的持久连接。HTTP/1.1规范并没有为在持久连接上发送多少个理想的请求提供一个准则。这在很大程度上取决于应用程序。</target>
        </trans-unit>
        <trans-unit id="6eb80024b1f8a5a58791d40e0d60ce7a9e24c7b7" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</source>
          <target state="translated">如有可能,应将注释移到同一行的任何前面的分隔符之前。例如:</target>
        </trans-unit>
        <trans-unit id="11f459fa45ff86ea26d4123b486b2667eb195a88" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</source>
          <target state="translated">如果可能的话,应将注释移到同一行的任何分隔符之后,而不是将分隔符放在下一行。例如:</target>
        </trans-unit>
        <trans-unit id="0e22a764d95b33db30751234a49a657e83e7510e" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; module to extract the compiler options and the abstract code format from the Beam file and compile that instead.</source>
          <target state="translated">如果可能，请使用 &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; 模块从Beam文件中提取编译器选项和抽象代码格式，然后进行编译。</target>
        </trans-unit>
        <trans-unit id="aede57d6ae41eb953c1c470da89fb0e057e8b902" translate="yes" xml:space="preserve">
          <source>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</source>
          <target state="translated">如果优先级是客户端,则协商后的协议是客户端优先级列表中最先显示的协议,同时也是服务器广告列表中的协议。</target>
        </trans-unit>
        <trans-unit id="51ff54d9c737f36da2074bfa07dabdd6029e6f8a" translate="yes" xml:space="preserve">
          <source>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</source>
          <target state="translated">如果优先级是服务器,则协商后的协议是服务器广告列表中最先显示的协议,也就是客户端优先级列表中的协议。</target>
        </trans-unit>
        <trans-unit id="6739d735ae41522a99fdf3833670c2cb63d21a98" translate="yes" xml:space="preserve">
          <source>If present, this option specifies the options for the &lt;strong&gt;audit trail logging&lt;/strong&gt;. The &lt;code&gt;disk_log&lt;/code&gt; module is used to maintain a wrap log. If present, the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; options are mandatory.</source>
          <target state="translated">如果存在，则此选项指定&lt;strong&gt;审核跟踪日志记录&lt;/strong&gt;的选项。该 &lt;code&gt;disk_log&lt;/code&gt; 模块用于维护一个包的日志。如果存在，则必须使用 &lt;code&gt;dir&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="c374078c3ce837fa7c145904897f0747ce0fa052" translate="yes" xml:space="preserve">
          <source>If process metadata exists for the current process, this function behaves as if it was implemented as follows:</source>
          <target state="translated">如果当前进程存在进程元数据,这个函数的行为就像它的实现一样。</target>
        </trans-unit>
        <trans-unit id="6453efa6a699c594656266a7d0d5934c8aa65586" translate="yes" xml:space="preserve">
          <source>If pseudo function triggering the translation is &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single tuple. If the pseudo function is &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single list.</source>
          <target state="translated">如果触发转换的伪函数为 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; ，则fun的头必须包含单个变量或单个元组。如果伪函数是 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; ，则fun的头必须包含单个变量或单个列表。</target>
        </trans-unit>
        <trans-unit id="3bbf5cb920ce0732e8a77fc0ab511fa8e53d27bc" translate="yes" xml:space="preserve">
          <source>If quantifier is {0,n}, where n &amp;gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier.</source>
          <target state="translated">如果量词为{0，n}，其中n&amp;gt; 0，则将其视为{0,1}。在运行时，在有或没有断言的情况下尝试其余模式匹配，顺序取决于量词的贪婪程度。</target>
        </trans-unit>
        <trans-unit id="a4e6534fccad96b9c365841e907e49b7cde2c28d" translate="yes" xml:space="preserve">
          <source>If records are written and deleted during the traversal, use the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;write&lt;/code&gt; lock. Or the function &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; when using &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">如果在遍历期间写入和删除记录，请使用具有 &lt;code&gt;write&lt;/code&gt; 锁定功能的 &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 。或使用 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 时使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="169c4bd14dbb4d6e16657fce0c0a61cc8e3f8798" translate="yes" xml:space="preserve">
          <source>If reloading is not requested, it can still be useful to specify option &lt;code&gt;monitor&lt;/code&gt;, as forced unloads (driver option &lt;code&gt;kill_ports&lt;/code&gt; or option &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;) trigger a transient state where driver loading cannot be performed until all closing ports are closed. Thus, as &lt;code&gt;try_unload&lt;/code&gt; can, in almost all situations, return &lt;code&gt;{ok, pending_driver}&lt;/code&gt;, always specify at least &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; in production code (see the monitor discussion earlier).</source>
          <target state="translated">如果不要求重新加载，则指定option &lt;code&gt;monitor&lt;/code&gt; 仍然有用，因为强制卸载（驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 或option &lt;code&gt;kill_ports&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; ）会触发一个过渡状态，在该状态下，直到所有关闭端口都关闭后才能执行驱动程序加载。因此，由于 &lt;code&gt;try_unload&lt;/code&gt; 在几乎所有情况下都可以返回 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; ，所以请始终在生产代码中至少指定 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; （请参阅前面的监视器讨论）。</target>
        </trans-unit>
        <trans-unit id="55c076ea86b99a552c3ee63a0beaa5dfb25c1e33" translate="yes" xml:space="preserve">
          <source>If resolver option &lt;code&gt;inet6&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, an IPv6 address is looked up.</source>
          <target state="translated">如果resolver选项 &lt;code&gt;inet6&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则查找IPv6地址。</target>
        </trans-unit>
        <trans-unit id="71218f752e39cbf302806385e7e620598fcd4560" translate="yes" xml:space="preserve">
          <source>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</source>
          <target state="translated">如果在某个节点上启用了受限模式,连接到这个节点的远程shell也会以受限模式运行。</target>
        </trans-unit>
        <trans-unit id="81be79c2e31a4efcff85293a46775d5d0aa9c619" translate="yes" xml:space="preserve">
          <source>If run with option &lt;code&gt;caseless&lt;/code&gt;, this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop.</source>
          <target state="translated">如果使用option &lt;code&gt;caseless&lt;/code&gt; 运行，则此模式将匹配诸如&amp;ldquo;一个人，一个计划，一条运河：巴拿马！&amp;rdquo;之类的短语。它在PCRE和Perl中都可以很好地工作。注意使用所有格量词* +以避免回溯到非单词字符序列中。没有这个，PCRE需要更长的时间（10倍或更多）来匹配典型短语，而Perl花费的时间如此之长，以至于您认为它陷入了循环。</target>
        </trans-unit>
        <trans-unit id="56762a0f1f42178490b0db9862f2814f477e1842" translate="yes" xml:space="preserve">
          <source>If set before start, the &lt;code&gt;epmd&lt;/code&gt; daemon behaves as if option &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified at startup. Consequently, if this option is set before starting the Erlang virtual machine, the automatically started &lt;code&gt;epmd&lt;/code&gt; accepts the &lt;code&gt;-kill&lt;/code&gt; and &lt;code&gt;-stop&lt;/code&gt; commands without restrictions.</source>
          <target state="translated">如果在启动之前设置，则 &lt;code&gt;epmd&lt;/code&gt; 守护程序的行为就像在启动时指定了选项 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 一样。因此，如果在启动Erlang虚拟机之前设置了此选项，则自动启动的 &lt;code&gt;epmd&lt;/code&gt; 会不受限制地接受 &lt;code&gt;-kill&lt;/code&gt; 和 &lt;code&gt;-stop&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="9f59dad82faaa4c2914703b6f2eec0c0bd7bf03c" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置了hibernate &lt;code&gt;gen_statem&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt; 部分处理</target>
        </trans-unit>
        <trans-unit id="997d2e694bf42fce758c366fad9b952364db63dd" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60eef1c452cfc1dd1bd601c01baa121d5df8c903" translate="yes" xml:space="preserve">
          <source>If set in binary mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;{binary, true}&lt;/code&gt;), the I/O server sends binary data (encoded in UTF-8) as answers to the &lt;code&gt;get_line&lt;/code&gt;, &lt;code&gt;get_chars&lt;/code&gt;, and, if possible, &lt;code&gt;get_until&lt;/code&gt; requests (for details, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt;) in the User's Guide). The immediate effect is that &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; return UTF-8 binaries instead of lists of characters for the affected I/O device.</source>
          <target state="translated">如果设置为二进制模式（ &lt;code&gt;binary&lt;/code&gt; 或 &lt;code&gt;{binary, true}&lt;/code&gt; ），则I / O服务器发送二进制数据（以UTF-8编码）作为对 &lt;code&gt;get_line&lt;/code&gt; ， &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_until&lt;/code&gt; 请求的答复（有关详细信息，请参见部分 &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; ）的用户指南中）。即时效果是 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 返回UTF-8二进制文件，而不是受影响的I / O设备的字符列表。</target>
        </trans-unit>
        <trans-unit id="60e11f2d401fbb6a7bc13e95b2d0df9464865aea" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置为推迟当前事件，请参阅 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt; 部分</target>
        </trans-unit>
        <trans-unit id="cfee0bffb0c9371226233925794bed564e96b2bf" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2642f766dbab3720562602e51b82a07e9e8906" translate="yes" xml:space="preserve">
          <source>If set the scheduler id is to be included by the tracer.</source>
          <target state="translated">如果设置了调度器ID,那么追踪器就会被包括在内。</target>
        </trans-unit>
        <trans-unit id="913831f334573f274f7a4b77334d9d4e872f104b" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36ae2f0946222aa466ec9f357bec978063329ec" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果设置，跟踪点将包含有关跟踪事件的其他数据。附加数据是什么取决于已触发的 &lt;code&gt;TraceTag&lt;/code&gt; 。所述 &lt;code&gt;extra&lt;/code&gt; 迹线数据对应于在跟踪元组的第五元素中描述 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="537421ac5bc876e1157770197d20f5be1d7bdfa8" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include a time stamp.</source>
          <target state="translated">如果设置了,则跟踪器已被要求包含一个时间戳。</target>
        </trans-unit>
        <trans-unit id="ebb92b7f506965bd75353ec4f02388501a5389c5" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include the output of a match specification that was run.</source>
          <target state="translated">如果设置,追踪器已被要求包含运行的匹配规范的输出。</target>
        </trans-unit>
        <trans-unit id="655f54de5d5fcd636afc8c5192a0cd83bf1d3634" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, TLS/DTLS Alert reports are not displayed. Deprecated in OTP 22, use {log_level, &lt;code&gt;&lt;a href=&quot;#type-logging_level&quot;&gt;logging_level()&lt;/a&gt;&lt;/code&gt;} instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c658f8f2f205584d1fb8b1c5da7c1178ed36dd48" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, error reports are not displayed.</source>
          <target state="translated">如果设置为 &lt;code&gt;false&lt;/code&gt; ，则不显示错误报告。</target>
        </trans-unit>
        <trans-unit id="2c4759d1764534d362731027d076405776344611" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on_heap&lt;/code&gt;, the sending process will first attempt to allocate the space for the message directly on the young heap block of the receiving process. This is not always possible as it requires taking the &lt;strong&gt;main lock&lt;/strong&gt; of the receiving process. The main lock is also held when the process is executing. The possibility for a lock conflict is thus likely in an intensely collaborating system. If the sending process cannot acquire the main lock, a heap fragment is instead created for the message and the message payload is copied onto that. With the &lt;code&gt;off_heap&lt;/code&gt; option the sender process always creates heap fragments for messages sent to that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310d96f77be1e1791ce6fea41e63aca706ddcee9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; a header field is added to logger_formatter's part of &lt;code&gt;Metadata&lt;/code&gt;. The value of this field is a string similar to the header created by the old &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; event handlers. It can be included in the log event by adding the list &lt;code&gt;[logger_formatter,header]&lt;/code&gt; to the template. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则将头字段添加到logger_formatter的 &lt;code&gt;Metadata&lt;/code&gt; 部分。该字段的值是一个类似于旧的 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 事件处理程序创建的标头的字符串。通过将列表 &lt;code&gt;[logger_formatter,header]&lt;/code&gt; 添加到模板，可以将其包含在日志事件中。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 类型的描述。</target>
        </trans-unit>
        <trans-unit id="bd8fb908e24bb62be623e19143f8ea77156d0120" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TCLASS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; option &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; or &lt;code&gt;IPV6_2292RECVTCLASS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tclass,TCLASS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IPV6_TCLASS&lt;/code&gt; or an &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1327e3fb152f87bc84a12b83acd5ce3c1ed9810" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TOS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTOS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tos,TOS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TOS&lt;/code&gt; or an &lt;code&gt;IP_RECVTOS&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca95fc90cd615829fa6bcc45ce252e70ac9443" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TTL&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTTL&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{ttl,TTL}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TTL&lt;/code&gt; or an &lt;code&gt;IP_RECVTTL&lt;/code&gt; CMSG value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce4e9a3ec15985becd6d1fc4438e42ee9f02d87" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, all newlines in the message are replaced with &lt;code&gt;&quot;, &quot;&lt;/code&gt;, and white spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则消息中的所有换行符均被替换为 &lt;code&gt;&quot;, &quot;&lt;/code&gt; ，并且在换行符之后紧跟的空格被删除。请注意，不会替换由 &lt;code&gt;template&lt;/code&gt; 参数添加的换行符。</target>
        </trans-unit>
        <trans-unit id="bdbfcee3def687520000625ed9063759bcd7fdfe" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, each log event is printed as a single line. To achieve this, &lt;code&gt;logger_formatter&lt;/code&gt; sets the field width to &lt;code&gt;0&lt;/code&gt; for all &lt;code&gt;~p&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; control sequences in the format a string (see &lt;code&gt; io:format/2&lt;/code&gt;), and replaces all newlines in the message with &lt;code&gt;&quot;, &quot;&lt;/code&gt;. White spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bc2e449028a1b238287b1e7e1da57633ce0aa2" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;ct_master logs&lt;/code&gt; are written on a primitive HTML format, not using the &lt;code&gt;Common Test&lt;/code&gt; CSS style sheet.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;ct_master logs&lt;/code&gt; 以原始HTML格式编写，而不使用 &lt;code&gt;Common Test&lt;/code&gt; CSS样式表。</target>
        </trans-unit>
        <trans-unit id="c67db27336a237041f3f770706b8f2027a618516" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts &lt;code&gt;++&lt;/code&gt;-operators between string literals and macros where it looks like concatenation was intended. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，这会使 &lt;code&gt;epp_dodger&lt;/code&gt; 尝试在看起来合适的情况下修复源代码，在某些情况下，否则解析将失败。当前，它在看起来像串联的字符串文字和宏之间插入 &lt;code&gt;++&lt;/code&gt; -运算符。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553412c0540657c6dfbc0cf5ff30e8dae32d51db" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, use the server preference for cipher selection. If set to &lt;code&gt;false&lt;/code&gt; (the default), use the client preference.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则使用服务器首选项进行密码选择。如果设置为 &lt;code&gt;false&lt;/code&gt; （默认值），请使用客户端首选项。</target>
        </trans-unit>
        <trans-unit id="845d16e801c4d035d7da73e779db3b12f92e8193" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, workarounds for known server deviations from the HTTP-standard are enabled.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则启用针对服务器偏离HTTP标准的已知变通办法。</target>
        </trans-unit>
        <trans-unit id="4e5151c0c30a4e7bb11fe24669fcb768cff8dff0" translate="yes" xml:space="preserve">
          <source>If set to anything else than &lt;code&gt;0&lt;/code&gt;, it makes all times displayed by &lt;code&gt;run_erl&lt;/code&gt; to be in UTC (GMT, CET, MET, without Daylight Saving Time), rather than in local time. This does not affect data coming from Erlang, only the logs output directly by &lt;code&gt;run_erl&lt;/code&gt;. Application SASL can be modified accordingly by setting the Erlang application variable &lt;code&gt;utc_log&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;0&lt;/code&gt; 以外的任何值，它将使 &lt;code&gt;run_erl&lt;/code&gt; 显示的所有时间都以UTC（GMT，CET，MET，没有夏令时）显示，而不是本地时间。这不会影响来自Erlang的数据，只会影响 &lt;code&gt;run_erl&lt;/code&gt; 直接输出的日志。通过将Erlang应用程序变量 &lt;code&gt;utc_log&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,可以相应地修改应用程序SASL 。</target>
        </trans-unit>
        <trans-unit id="54ecba8897a2d3cf6ca4714afe4059ed1a0bc69c" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously.</source>
          <target state="translated">如果设置为false(默认值),则每次只处理一次登录。如果设置为 &quot;true&quot;,则允许同时进行无限次的登录尝试。</target>
        </trans-unit>
        <trans-unit id="d7a47f9a94c76c57c796417eab15c787a00acacf" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, the number of simultaneous login attempts are limited by the value of &lt;code&gt;&lt;a href=&quot;ssh#hardening_daemon_options--max_sessions&quot;&gt;max_sessions&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e5e755a8f0aa4316d9b9f5d9dcea02be971e72" translate="yes" xml:space="preserve">
          <source>If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file.</source>
          <target state="translated">如果将密码设置为 &quot;NoPassword &quot;以外的其他选项,则所有API调用都需要密码。密码设置为 &quot;DummyPassword &quot;的情况下,其他的API调用前必须更改密码。为了保证验证数据的安全,密码必须在Web服务器启动后更改。否则,它将以清晰的文本写在配置文件中。</target>
        </trans-unit>
        <trans-unit id="9508965c72b0132e5a02e474dd8d5307005afa10" translate="yes" xml:space="preserve">
          <source>If set, the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks implements timeouts. The timeout is passed in the &lt;code&gt;tmo&lt;/code&gt; argument and is given in milli seconds. Note that the &lt;code&gt;tmo&lt;/code&gt; argument to these callbacks differ from the timeout arguments in the &lt;code&gt;ei&lt;/code&gt; API. Zero means a zero timeout. That is, poll and timeout immediately unless the operation is successful. &lt;code&gt;EI_SCLBK_INF_TMO&lt;/code&gt; (max &lt;code&gt;unsigned&lt;/code&gt;) means infinite timeout. The file descriptor is in blocking mode when a callback is called, and it must be in blocking mode when the callback returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8baf201837b9902d99d9c6ceeaafc45b233fd" translate="yes" xml:space="preserve">
          <source>If several fields are to be assigned the same value, the following construction can be used:</source>
          <target state="translated">如果要给几个字段分配相同的值,可以使用以下结构。</target>
        </trans-unit>
        <trans-unit id="21ef3b935d35dcc97954564f91b02dc29963a181" translate="yes" xml:space="preserve">
          <source>If so, or if possibly needed in future versions, then you should consider using &lt;code&gt;gen_statem&lt;/code&gt; over &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">如果是这样，或者在将来的版本中可能需要，那么您应该考虑在 &lt;code&gt;gen_server&lt;/code&gt; 上使用 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f43fb2b2715e85b137bcfdf2730b0beccbdd0c4b" translate="yes" xml:space="preserve">
          <source>If so, the user is authorized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f2cb0ac87e42cdbdf8827c536efd85bb8b5ca2" translate="yes" xml:space="preserve">
          <source>If some of the found BEAM files contain &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then those modules are checked and a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果找到的某些BEAM文件包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则将检查这些模块并返回元组列表。每个元组的第一个元素是以下之一：</target>
        </trans-unit>
        <trans-unit id="6a5a8a25ced47d4519279df0ad60d300b9fdd3ac" translate="yes" xml:space="preserve">
          <source>If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.</source>
          <target state="translated">如果一些变量存在于配置中,但没有使用该函数加载,它们将和它们的别名一起从配置表中删除。</target>
        </trans-unit>
        <trans-unit id="908c252e088323e888f147ff16d100c7706161d0" translate="yes" xml:space="preserve">
          <source>If something goes wrong, the function can also return an error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">如果出现问题，该函数还可以返回一个错误元组 &lt;code&gt;{error,Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70476ad38abe74628a91e231b10da869d250c572" translate="yes" xml:space="preserve">
          <source>If specified by its filename, the filename can include a path and the &lt;code&gt;.erl&lt;/code&gt; extension can be omitted. The object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to it, and then in the current path.</source>
          <target state="translated">如果由其文件名指定，则文件名可以包含路径，并且可以省略 &lt;code&gt;.erl&lt;/code&gt; 扩展名。首先在与源代码相同的目录中搜索目标代码 &lt;code&gt;Module.beam&lt;/code&gt; ，然后在其旁边的 &lt;code&gt;ebin&lt;/code&gt; 目录中搜索，然后在当前路径中搜索。</target>
        </trans-unit>
        <trans-unit id="50b19f1c8b9a65cb742065615e51dec1da364a91" translate="yes" xml:space="preserve">
          <source>If specified by its module name, the object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path. The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in the same directory as the object code, then in an &lt;code&gt;src&lt;/code&gt; directory next to it.</source>
          <target state="translated">如果通过其模块名称指定，则在当前路径中搜索对象代码 &lt;code&gt;Module.beam&lt;/code&gt; 。首先在与目标代码相同的目录中搜索源代码 &lt;code&gt;Module.erl&lt;/code&gt; ，然后在其旁边的 &lt;code&gt;src&lt;/code&gt; 目录中进行搜索。</target>
        </trans-unit>
        <trans-unit id="a8d0b6cf013a5c0d8770719696ef065b65aefbe7" translate="yes" xml:space="preserve">
          <source>If starting the test with a general verbosity level of 50 (&lt;code&gt;?STD_VERBOSITY&lt;/code&gt;):</source>
          <target state="translated">如果以一般详细度级别50（ &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; ）开始测试：</target>
        </trans-unit>
        <trans-unit id="bff20119788e7f9fcb0386bb0ba5f7207f1771ed" translate="yes" xml:space="preserve">
          <source>If starting the test with:</source>
          <target state="translated">如果以下列方式开始测试:</target>
        </trans-unit>
        <trans-unit id="26a65a58a274c5e83de124292f3254f1ac090467" translate="yes" xml:space="preserve">
          <source>If status was &lt;code&gt;alive&lt;/code&gt;, node &lt;code&gt;A&lt;/code&gt; answers with another status message containing either &lt;code&gt;true&lt;/code&gt;, which means that the connection is to continue (the old connection from this node is broken), or &lt;code&gt;false&lt;/code&gt;, which means that the connection is to be closed (the connection attempt was a mistake.</source>
          <target state="translated">如果status处于 &lt;code&gt;alive&lt;/code&gt; 状态，则节点 &lt;code&gt;A&lt;/code&gt; 回答另一个状态消息，其中包含 &lt;code&gt;true&lt;/code&gt; 表示连接将继续（此节点的旧连接断开）或 &lt;code&gt;false&lt;/code&gt; 表示将关闭连接（连接尝试是错误的。</target>
        </trans-unit>
        <trans-unit id="7b9b70b7cbd405f4ef48bddbc33725b6c4cf3c30" translate="yes" xml:space="preserve">
          <source>If sticky locks are used, the code must first be changed as follows:</source>
          <target state="translated">如果使用粘性锁,必须先修改代码,如下。</target>
        </trans-unit>
        <trans-unit id="c7eb71447bfe22582a45b3625c21c45102fb30a5" translate="yes" xml:space="preserve">
          <source>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</source>
          <target state="translated">如果在正则表达式中指定了子表达式,那么在生成的列表中也会返回匹配的子表达式。例如</target>
        </trans-unit>
        <trans-unit id="0b8ddaa042ba6e6a6e6f3aa8c56ca060f0b33630" translate="yes" xml:space="preserve">
          <source>If successful</source>
          <target state="translated">如果成功</target>
        </trans-unit>
        <trans-unit id="211664819a4310bd77112b972f6e1afd6ef67b18" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state in an &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple.</source>
          <target state="translated">如果成功，该函数必须在 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 元组中返回更新的内部状态。</target>
        </trans-unit>
        <trans-unit id="4e8c6ee9fde6d55757690d169dc69ff0e99e718e" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state.</source>
          <target state="translated">如果成功,该函数必须返回更新的内部状态。</target>
        </trans-unit>
        <trans-unit id="932989b7c1361152a0b0809cc73761645d677b31" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; exists but the corresponding child process is running or is about to be restarted, the function returns &lt;code&gt;{error,running}&lt;/code&gt; or &lt;code&gt;{error,restarting}&lt;/code&gt;, respectively. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;ok&lt;/code&gt; 。如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范存在，但相应的子进程正在运行或将要重新启动，则该函数分别返回 &lt;code&gt;{error,running}&lt;/code&gt; 或 &lt;code&gt;{error,restarting}&lt;/code&gt; 。如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范不存在，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a7459c85147eae0af4289577e8d8cb1033070c0" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is no child specification with the specified &lt;code&gt;Id&lt;/code&gt;, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;ok&lt;/code&gt; 。如果没有带有指定 &lt;code&gt;Id&lt;/code&gt; 子规范，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c554336fd49d3d6148f3873055df50396396c91" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;{ok,State}&lt;/code&gt; or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial internal state of the event handler.</source>
          <target state="translated">如果成功，函数将返回 &lt;code&gt;{ok,State}&lt;/code&gt; 或 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是事件处理程序的初始内部状态。</target>
        </trans-unit>
        <trans-unit id="2203259483f235e1b092ade2119d4c07d6241b2e" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map or if it does not contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;map_in&lt;/code&gt; 不是地图或不包含 &lt;code&gt;key&lt;/code&gt; ,则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba18cbb490e9c8d2f3b6ef180516f04715f3defa" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;map_in&lt;/code&gt; 不是地图，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c57bdf287994755b6e44fdfc60facab5a9f11a53" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; there are any duplicate keys.</source>
          <target state="translated">如果成功，此函数将 &lt;code&gt;*map_out&lt;/code&gt; 设置为新地图并返回 &lt;code&gt;true&lt;/code&gt; 。返回 &lt;code&gt;false&lt;/code&gt; 有任何重复的键。</target>
        </trans-unit>
        <trans-unit id="235077c5f09d774b9f3db45cd19ec2e827847cd9" translate="yes" xml:space="preserve">
          <source>If such a clause cannot be found, a &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">如果找不到这样的子句，则会发生 &lt;code&gt;function_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="283f86d98b5d92d6ad1ce6bfc63055da78218576" translate="yes" xml:space="preserve">
          <source>If such a clause is found, the corresponding clause body is evaluated. That is, the expressions in the body are evaluated sequentially and the value of the last expression is returned.</source>
          <target state="translated">如果找到了这样的子句,就会对相应的子句体进行评估。也就是说,正文中的表达式依次被评估,最后一个表达式的值被返回。</target>
        </trans-unit>
        <trans-unit id="b28412a4d9f9549fe2f357ee3ab836136e195e5c" translate="yes" xml:space="preserve">
          <source>If support is found, the option &lt;code&gt;{property_test_tool,ToolModule}&lt;/code&gt; with the selected tool main module name (&lt;code&gt;eqc&lt;/code&gt;, &lt;code&gt;proper&lt;/code&gt; or &lt;code&gt;triq&lt;/code&gt;) is added to the list &lt;code&gt;Config&lt;/code&gt; which then is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fcf16676aca666b69b183aa34b448a75829f94" translate="yes" xml:space="preserve">
          <source>If synchronization is not possible, an error report is sent to the error logger (see also &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果无法同步，则​​会将错误报告发送到错误记录器（另请参见 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="36f347d7b778b3a4f6fb90496e2acb23c2a7a864" translate="yes" xml:space="preserve">
          <source>If syntax errors are discovered in these files they are reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; at start-up.</source>
          <target state="translated">如果在这些文件中发现语法错误，则会在启动时通过 &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; 的功能 &lt;code&gt;config_err/2&lt;/code&gt; 报告它们。</target>
        </trans-unit>
        <trans-unit id="e5db19b0c235be5b01f2325198c01dc60d89585f" translate="yes" xml:space="preserve">
          <source>If tagged allocations are not enabled on any of the specified allocator types, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">如果未在任何指定的分配器类型上启用标记的分配，则调用将失败，并显示 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="430e9485ed1c99e4dac7dca3da3dfa4aa8c39ab8" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; cannot be compiled (does not represent a valid match specification), a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果无法编译术语 &lt;code&gt;MatchSpec&lt;/code&gt; （不表示有效的匹配规范），则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="763ff93c3062ce44172fb309cebb5a06079fead9" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; does not represent a valid match specification, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34a1091c99e6fe485396a9633ee9cf35b5e6022" translate="yes" xml:space="preserve">
          <source>If test suites or help modules include header files stored in other locations than the test directory, these include directories can be specified by using flag &lt;code&gt;-include&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, or option &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. Also, an include path can be specified with an OS environment variable, &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt;.</source>
          <target state="translated">如果测试套件或帮助模块包括存储在与测试目录的其它位置的头文件，这些包括可通过使用标志来指定的目录 &lt;code&gt;-include&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; ，或选项 &lt;code&gt;include&lt;/code&gt; 与 &lt;code&gt;ct:run_test/1&lt;/code&gt; 。另外，可以使用OS环境变量 &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt; 指定包含路径。</target>
        </trans-unit>
        <trans-unit id="7e790d3acc547bf4dd4b0058bee91f205e4b15cf" translate="yes" xml:space="preserve">
          <source>If the &quot;certificate_authorities&quot; extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c1965cf3b85e5ae91bfc7f462d56b4e302c996" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that 'get-request'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece8268eb3bcace140f99c6e854d866eed3ef694" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that job ('get-request' or notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9279b9016abb718b19436b545788de84fa2134f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, BEAM files that contain no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">如果外部参照服务器的 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;functions&lt;/code&gt; ，则不包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; BEAM文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="c813a10d16024092b88cb717d0c880a3632b14a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, and the BEAM file contains no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, the error message &lt;code&gt;no_debug_info&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;no_debug_info&lt;/code&gt; 参照服务器的 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;functions&lt;/code&gt; ，并且BEAM文件不包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则返回错误消息no_debug_info。</target>
        </trans-unit>
        <trans-unit id="ef80d1f8c11747796d02d57345e648de2094089e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9197e338e3401c234d140df6601d7f0bd0de9f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;handle_event_function&lt;/code&gt; ，则状态可以为任何术语。状态更改后（ &lt;code&gt;NextState =/= State&lt;/code&gt; ），将重试所有延迟的事件。</target>
        </trans-unit>
        <trans-unit id="77912caa4ee948d9b6eee0f54f2cb39e15b274ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried. Note that the state &lt;code&gt;terminate&lt;/code&gt; is not possible to use since it would collide with the optional callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c7a5f40b37419e0dfdb9c000a09ebaefa7ede7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be of this type. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;state_functions&lt;/code&gt; ，则状态必须为这种类型。状态更改后（ &lt;code&gt;NextState =/= State&lt;/code&gt; ），将重试所有延迟的事件。</target>
        </trans-unit>
        <trans-unit id="693335b3ceb4c3438c26542cdb03f54e066d8540" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt; erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720d616c478f9b1d1e0e376e567468c7cbccb10c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">如果已在 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ，即使驱动器已表示忙，也可以通过 &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; 将数据强制进入驱动器。</target>
        </trans-unit>
        <trans-unit id="24fb3b31f2e1a1b36aa86e0260daf033dbd388cc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;snmp_config#manager_irb&quot;&gt;inform request behaviour&lt;/a&gt;&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436abcfe6ccf26003670b7e8f6ead1ae9566d2af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b8a260b0935e82c1c23c647ce2490c52e709f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_control/3&lt;/code&gt; is a binary, the driver will be passed a pointer to the contents of the binary and the binary will not be copied. If the &lt;code&gt;Data&lt;/code&gt; argument is an iolist (list of binaries and lists), all binaries in the iolist will be copied.</source>
          <target state="translated">如果 &lt;code&gt;port_control/3&lt;/code&gt; 的 &lt;code&gt;Data&lt;/code&gt; 参数是二进制文件，则将向驱动程序传递指向二进制文件内容的指针，并且不会复制二进制文件。如果 &lt;code&gt;Data&lt;/code&gt; 参数是iolist（二进制文件和列表的列表），则将复制iolist中的所有二进制文件。</target>
        </trans-unit>
        <trans-unit id="22cf2f621c573393bcc21b524ec1f8b2f0eb496f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;EI_SCLBK_FLG_FULL_IMPL&lt;/code&gt; flag has been set, &lt;code&gt;tmo&lt;/code&gt; contains timeout time in milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f73654015166f98aadbf7b3b123e17e68232e9b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HEART_COMMAND&lt;/code&gt; environment variable is to be set in the &lt;code&gt;start&lt;/code&gt; script in &lt;strong&gt;Starting Erlang&lt;/strong&gt;, and if the value is to be set to the path of the Solaris &lt;code&gt;reboot&lt;/code&gt; command, that is:</source>
          <target state="translated">如果要在&amp;ldquo; &lt;code&gt;start&lt;/code&gt; &lt;strong&gt;Erlang&amp;rdquo;&lt;/strong&gt;中的启动脚本中设置 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 环境变量，并且要将值设置为Solaris &lt;code&gt;reboot&lt;/code&gt; 命令的路径，即：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="944e73a76d9846f1844b61fadd1ef6be5fa46f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Item&lt;/code&gt; is a string &quot;&amp;lt;X.Y.Z&amp;gt;&quot; as returned from &lt;code&gt;pid_to_list/1&lt;/code&gt;, the process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">如果 &lt;code&gt;Item&lt;/code&gt; 是从 &lt;code&gt;pid_to_list/1&lt;/code&gt; 返回的字符串&amp;ldquo; &amp;lt;XYZ&amp;gt;&amp;rdquo; ，则将跟踪进程 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eca5d5aa872cbcbe9a56199f7268cf843102ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Mod&lt;/code&gt; argument is given, the result contains a &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for module &lt;code&gt;Mod&lt;/code&gt; only, otherwise the result contains one &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for all modules returned from &lt;code&gt;code:all_loaded()&lt;/code&gt; except &lt;code&gt;cprof&lt;/code&gt; itself.</source>
          <target state="translated">如果给出了 &lt;code&gt;Mod&lt;/code&gt; 参数，则结果仅包含模块 &lt;code&gt;Mod&lt;/code&gt; 的 &lt;code&gt;ModAnalysis&lt;/code&gt; 元组，否则结果包含从 &lt;code&gt;code:all_loaded()&lt;/code&gt; 返回的所有模块（ &lt;code&gt;cprof&lt;/code&gt; 本身除外）的一个 &lt;code&gt;ModAnalysis&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="692d7ddeb29364bd451d87d06edbd7eec80bea02" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has been set, a &lt;code&gt;NewAtomCacheRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">如果 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 下一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 已定，一个 &lt;code&gt;NewAtomCacheRef&lt;/code&gt; 以下格式如下：</target>
        </trans-unit>
        <trans-unit id="04c0254fa6d70d431ad5a486ddf123ee44618a15" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has not been set, a &lt;code&gt;CachedAtomRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">如果 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 为下一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 设置 &lt;code&gt;CachedAtomRef&lt;/code&gt; ，则遵循以下格式的CachedAtomRef：</target>
        </trans-unit>
        <trans-unit id="8c90300fd144cf66a22b387cf8df2ba0e1883646" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the &lt;code&gt;InData&lt;/code&gt; shall be &lt;code&gt;InData_ssh2_pubkey&lt;/code&gt;. Otherwise it shall be &lt;code&gt;OtherInData&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5892c57f59a62e642afcb7987d330a6a6bddcb6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the result will be &lt;code&gt;Decoded_ssh2_pubkey&lt;/code&gt;. Otherwise it will be &lt;code&gt;Decoded_OtherType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abbbca51e0d96970bfc6e932a6073fa6c1b8d91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WrapSize&lt;/code&gt; is specified as &lt;code&gt;{time, WrapTime}&lt;/code&gt;, the current file is closed when it has been open more than &lt;code&gt;WrapTime&lt;/code&gt; milliseconds, regardless of it being empty or not.</source>
          <target state="translated">如果 &lt;code&gt;WrapSize&lt;/code&gt; 指定为 &lt;code&gt;{time, WrapTime}&lt;/code&gt; ，则当前文件在打开超过 &lt;code&gt;WrapTime&lt;/code&gt; 毫秒后将关闭，无论它是否为空。</target>
        </trans-unit>
        <trans-unit id="3bce9200cd49c0302061751c509bff17706e1d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;collector_pid&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; a new &lt;code&gt;et_collector&lt;/code&gt; will be started with the following parameter settings: &lt;code&gt;parent_pid&lt;/code&gt;, &lt;code&gt;event_order&lt;/code&gt;, &lt;code&gt;trace_global&lt;/code&gt;, &lt;code&gt;trace_pattern&lt;/code&gt;, &lt;code&gt;trace_port&lt;/code&gt;, &lt;code&gt;trace_max_queue&lt;/code&gt;, &lt;code&gt;trace_client&lt;/code&gt;, &lt;code&gt;dict_insert&lt;/code&gt; and &lt;code&gt;dict_delete&lt;/code&gt;. The new &lt;code&gt;et_viewer&lt;/code&gt; will register itself as an &lt;code&gt;et_collector&lt;/code&gt; subscriber.</source>
          <target state="translated">如果 &lt;code&gt;collector_pid&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 新 &lt;code&gt;et_collector&lt;/code&gt; 将以下参数设置开始： &lt;code&gt;parent_pid&lt;/code&gt; ， &lt;code&gt;event_order&lt;/code&gt; ， &lt;code&gt;trace_global&lt;/code&gt; ， &lt;code&gt;trace_pattern&lt;/code&gt; ， &lt;code&gt;trace_port&lt;/code&gt; ， &lt;code&gt;trace_max_queue&lt;/code&gt; ， &lt;code&gt;trace_client&lt;/code&gt; ， &lt;code&gt;dict_insert&lt;/code&gt; 和 &lt;code&gt;dict_delete&lt;/code&gt; 。新的 &lt;code&gt;et_viewer&lt;/code&gt; 将自己注册为 &lt;code&gt;et_collector&lt;/code&gt; 订阅者。</target>
        </trans-unit>
        <trans-unit id="3ef49ec23c42d8c8e08d0e1a55605acb0e8d5ac7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;crypto_fun()&lt;/code&gt; reurns a &lt;code&gt;chunk_size()&lt;/code&gt;, that value is as block size for further blocks in calls to &lt;code&gt;crypto_fun()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1705267e03ee01724d59b40bc5f0214567319c46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; and/or &lt;code&gt;per_cpu&lt;/code&gt; option is given, this is the CPU number, or a list of the CPU numbers.</source>
          <target state="translated">如果 &lt;code&gt;detailed&lt;/code&gt; 和/或 &lt;code&gt;per_cpu&lt;/code&gt; 选项，则这是CPU数量或CPU号码列表。</target>
        </trans-unit>
        <trans-unit id="e77d603a3001a1e9c1762cdeaacfe7bfa22a3f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; option is given, this is a list of &lt;code&gt;{State, Share}&lt;/code&gt; tuples, where each tuple contains information about a processor state that has been identified as a busy processor state (see below). The atom &lt;code&gt;State&lt;/code&gt; is the name of the state, and the float &lt;code&gt;Share&lt;/code&gt; represents the percentage share of the CPU cycles spent in this state since the last call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;detailed&lt;/code&gt; 选项，则这是 &lt;code&gt;{State, Share}&lt;/code&gt; 元组的列表，其中每个元组都包含有关已被标识为繁忙处理器状态的处理器状态的信息（请参见下文）。 &lt;code&gt;State&lt;/code&gt; 原子是状态的名称，float &lt;code&gt;Share&lt;/code&gt; 代表自从上次调用 &lt;code&gt;util/0&lt;/code&gt; 或 &lt;code&gt;util/1&lt;/code&gt; 以来在此状态下花费的CPU周期所占的百分比。</target>
        </trans-unit>
        <trans-unit id="ceeca0dd799d0c2b30a43e745da4464b5bf6bdd0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e75076deae26fb176f6e6643de28792f0d16c28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62b99585baeb954cbb0731a4ba30894bb10a1da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a3a64fa23b1c369a1e49078a7eef230d3e65da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a too large wait time value, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f6b148b35fa3a772ed4cf02b8f14d1a3fb663b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;excl_lib&lt;/code&gt; option is set to &lt;code&gt;otp_root&lt;/code&gt; then reltool will not copy anything from the Erlang/OTP installation ($OTP_ROOT) into the target structure. The goal is to create a &quot;slim&quot; release which can be used together with an existing Erlang/OTP installation. The target structure will therefore only contain a &lt;code&gt;lib&lt;/code&gt; directory with the applications that were found outside of $OTP_ROOT (typically your own applications), and a &lt;code&gt;releases&lt;/code&gt; directory with the generated &lt;code&gt;.rel,&lt;/code&gt;&lt;code&gt;.script&lt;/code&gt; and &lt;code&gt;.boot&lt;/code&gt; files.</source>
          <target state="translated">如果将 &lt;code&gt;excl_lib&lt;/code&gt; 选项设置为 &lt;code&gt;otp_root&lt;/code&gt; ,则reltool不会将任何内容从Erlang / OTP安装（$ OTP_ROOT）复制到目标结构中。目标是创建一个&amp;ldquo;超薄&amp;rdquo;发行版，可与现有的Erlang / OTP安装一起使用。因此，目标结构将只包含一个 &lt;code&gt;lib&lt;/code&gt; 与所发现的$ OTP_ROOT（通常是您自己的应用程序）以外的应用程序目录，并且 &lt;code&gt;releases&lt;/code&gt; 与生成目录 &lt;code&gt;.rel,&lt;/code&gt; &lt;code&gt;.script&lt;/code&gt; 和 &lt;code&gt;.boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="be47c608e84207db441f123dc3b022c3bdfe3832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fprof&lt;/code&gt; server is not running, this function returns immediately with the same return value.</source>
          <target state="translated">如果 &lt;code&gt;fprof&lt;/code&gt; 服务器未运行，则此函数将立即以相同的返回值返回。</target>
        </trans-unit>
        <trans-unit id="4cfc64c80cf0754288971ed2f55082185d9efbaf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_event&lt;/code&gt; is to be able to receive other messages than events, the callback function &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_event&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">如果 &lt;code&gt;gen_event&lt;/code&gt; 能够接收事件以外的其他消息，则必须实现回调函数 &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; 来处理它们。其他消息的示例是退出消息，如果 &lt;code&gt;gen_event&lt;/code&gt; 链接到其他进程（而不是主管），并且捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="5aad944a4a47c5bc78a9273e949274df0e9ed557" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is not part of a supervision tree, a stop function can be useful, for example:</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 不属于监督树，则停止功能可能很有用，例如：</target>
        </trans-unit>
        <trans-unit id="4832a13c9684cb02c06fa828f9150cd6ab481d33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_server&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 是监视树的一部分，则不需要停止功能。该 &lt;code&gt;gen_server&lt;/code&gt; 由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="3b4cc7e563bc4ab43d392728008910f94dfb10ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is to be able to receive other messages than requests, the callback function &lt;code&gt;handle_info(Info, State)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_server&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 能够接收请求以外的其他消息，则必须实现回调函数 &lt;code&gt;handle_info(Info, State)&lt;/code&gt; 来处理它们。其他消息的示例是退出消息，如果 &lt;code&gt;gen_server&lt;/code&gt; 链接到其他进程（而不是主管），并且捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="2f9738619fd7812022c1fdbad1b01a2e041bfacc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason=shutdown&lt;/code&gt; if the following conditions apply:</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 过程监督树的一部分，由监管当局终止命令，这个函数被调用， &lt;code&gt;Reason=shutdown&lt;/code&gt; 如果满足下列条件：</target>
        </trans-unit>
        <trans-unit id="deb0cd9df07520473713789c264957ed22e0fd37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is successfully created and initialized, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the &lt;code&gt;gen_server&lt;/code&gt; process. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果成功创建并初始化了 &lt;code&gt;gen_server&lt;/code&gt; 进程，则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 进程的pid 。如果具有指定 &lt;code&gt;ServerName&lt;/code&gt; 的进程已经存在，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="7b56e5a9d7d5389ddf0dc35b8aa333d9d01bbefc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return &lt;code&gt;{continue,Continue}&lt;/code&gt; in place of the time-out or hibernation value, which will immediately invoke the &lt;code&gt;handle_continue/2&lt;/code&gt; callback.</source>
          <target state="translated">如果 &lt;code&gt;gen_server&lt;/code&gt; 进程需要在初始化后立即执行操作或将回调的执行分为多个步骤，则可以返回 &lt;code&gt;{continue,Continue}&lt;/code&gt; 来代替超时或休眠值，后者将立即调用 &lt;code&gt;handle_continue/2&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="490e75ed674d410c271a45a56872f3c49ab0b58b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is not part of a supervision tree, it can be stopped using &lt;code&gt;gen_statem:stop&lt;/code&gt;, preferably through an API function:</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 不是监视树的一部分，则可以使用 &lt;code&gt;gen_statem:stop&lt;/code&gt; 停止它，最好通过API函数停止：</target>
        </trans-unit>
        <trans-unit id="36f4edf0379e907c933af357c419f98ac2861c66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason = shutdown&lt;/code&gt; if both the following conditions apply:</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 是监视树的一部分，并且由其主管命令终止，则如果同时满足以下两个条件，则使用 &lt;code&gt;Reason = shutdown&lt;/code&gt; 调用此函数：</target>
        </trans-unit>
        <trans-unit id="ac199e9236c5ed4f285d3986ed2287bb9a4c55ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_statem&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 是监视树的一部分，则不需要停止功能。该 &lt;code&gt;gen_statem&lt;/code&gt; 由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="622dc023e6ca738739a4198b61e3fabf701c009b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is successfully created and initialized, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of that process.</source>
          <target state="translated">如果 &lt;code&gt;gen_statem&lt;/code&gt; 成功创建和初始化，这个函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; 中的 &lt;code&gt;gen_statem&lt;/code&gt; 。如果已经存在具有指定 &lt;code&gt;ServerName&lt;/code&gt; 的进程，则此函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的 &lt;code&gt;pid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6640f29cc42fa72e56c964d772278b2e50af15d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the &lt;strong&gt;state enter call&lt;/strong&gt; is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, other than that &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d4b7b9947ceb2e1f75b847cb2c2cefc610ce87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inform request behaviour&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">如果 &lt;code&gt;inform request behaviour&lt;/code&gt; 配置选项设置为 &lt;code&gt;user&lt;/code&gt; 或 &lt;code&gt;{user, integer()}&lt;/code&gt; ，则在此函数返回时将发送对此通知请求的响应（确认）。</target>
        </trans-unit>
        <trans-unit id="f12a4aa7db27654fb06f0356ee419770a3c5990d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;main/1&lt;/code&gt; function in the script returns successfully, the exit status for the script is &lt;code&gt;0&lt;/code&gt;. If an exception is generated during execution, a short message is printed and the script terminates with exit status &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">如果脚本中的 &lt;code&gt;main/1&lt;/code&gt; 函数成功返回，则脚本的退出状态为 &lt;code&gt;0&lt;/code&gt; 。如果在执行期间生成异常，则会打印一条短消息，并且脚本以退出状态 &lt;code&gt;127&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="6df86c1718762f44b04c0cb308484d1d6c310a34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;max_sessions&lt;/code&gt; option is set to &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;parallel_login&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the maximum number of simultaneous login attempts at any time is limited to &lt;code&gt;N-K&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; is the number of authenticated connections present at this daemon.</source>
          <target state="translated">如果将 &lt;code&gt;max_sessions&lt;/code&gt; 选项设置为 &lt;code&gt;N&lt;/code&gt; 并将 &lt;code&gt;parallel_login&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则在任何时候的最大同时登录尝试次数将限制为 &lt;code&gt;N-K&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 是此守护程序中已认证连接的数量。</target>
        </trans-unit>
        <trans-unit id="279c740df4997832935268858ff97ba56a5fb972" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;parse_transform&lt;/code&gt; is not applied to a module that calls this pseudo function, the call fails in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; module exports a function with this name, but it is never to be called except when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including header file &lt;code&gt;ms_transform.hrl&lt;/code&gt;, compiled code never calls the function, but the function call is replaced by a literal match specification.</source>
          <target state="translated">如果 &lt;code&gt;parse_transform&lt;/code&gt; 没有应用于调用此伪函数的模块，则调用将在运行时失败（带有 &lt;code&gt;badarg&lt;/code&gt; ）。在 &lt;code&gt;ets&lt;/code&gt; 模块导出的函数使用这个名称，但它永远不会被称为在外壳使用功能时除外。如果 &lt;code&gt;parse_transform&lt;/code&gt; 正确通过包含头文件应用 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，编译的代码永远不会调用的功能，但功能调用由字面匹配规范所取代。</target>
        </trans-unit>
        <trans-unit id="91c8b62af5511bc181fbe7c0815f7318805644f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;per_cpu&lt;/code&gt; is not given, the value(s) presented are the average of all CPUs.</source>
          <target state="translated">如果未给出 &lt;code&gt;per_cpu&lt;/code&gt; ，则显示的值是所有CPU的平均值。</target>
        </trans-unit>
        <trans-unit id="2c4b5f09b562c0e8df5ab61a0939a3cca6eab6e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;qlc&lt;/code&gt; module at compile time can determine that some constant is free of integers, it does not matter which one of &lt;code&gt;==/2&lt;/code&gt; or &lt;code&gt;=:=/2&lt;/code&gt; is used:</source>
          <target state="translated">如果 &lt;code&gt;qlc&lt;/code&gt; 模块在编译时可以确定某个常量没有整数，则使用 &lt;code&gt;==/2&lt;/code&gt; 或 &lt;code&gt;=:=/2&lt;/code&gt; 中的哪一个都没有关系：</target>
        </trans-unit>
        <trans-unit id="9ebaa062ac28936382e2d57abb7b4e12d177d78c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It is only to contain low-level instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345d6310f85895e6842a34eabfe92151229e6b95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It it only to contain low-level instructions.</source>
          <target state="translated">如果 &lt;code&gt;relup&lt;/code&gt; 文件相对简单，则可以手动创建。它仅包含低级指令。</target>
        </trans-unit>
        <trans-unit id="c30c579f26aae9f62a722f68b38557366dc19832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令在脚本中，发现 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。这是因为 &lt;code&gt;restart_new_emulator&lt;/code&gt; 要求在执行其余升级指令之前必须启动新版本的模拟器，并且只能通过 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="a3734548d24c8fafceb3c3b7a48423c44c0a982c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在脚本中找到 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令，则 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; 。这是因为 &lt;code&gt;restart_new_emulator&lt;/code&gt; 要求在执行其余升级指令之前必须启动新版本的模拟器，并且只能通过 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="52741bb5942e459f72dab152ca12b8b26eff70c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/3,4&lt;/code&gt; function is used, all management targets are selected, as defined in RFC2273. The &lt;code&gt;Receiver&lt;/code&gt; parameter defines where the agent should send information about the delivery of inform requests.</source>
          <target state="translated">如果使用 &lt;code&gt;send_notification/3,4&lt;/code&gt; 函数，则将选择所有管理目标，如RFC2273中所定义。所述 &lt;code&gt;Receiver&lt;/code&gt; 参数定义了代理应该发送有关传输的信息通知请求。</target>
        </trans-unit>
        <trans-unit id="4e603d462637bea7ebad3ed1b02ae3e6befcd5e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/5&lt;/code&gt; function is used, an &lt;code&gt;NotifyName&lt;/code&gt; must be provided. This parameter is used as an index in the &lt;code&gt;snmpNotifyTable&lt;/code&gt;, and the management targets defined by that single entry is used.</source>
          <target state="translated">如果使用 &lt;code&gt;send_notification/5&lt;/code&gt; 函数， &lt;code&gt;NotifyName&lt;/code&gt; 必须提供一个NotifyName。此参数用作 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 中的索引，并且使用由该单个条目定义的管理目标。</target>
        </trans-unit>
        <trans-unit id="dde37de921a26a59041af8e4c9013eabdc7311af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system_logger&lt;/code&gt; process dies, this flag will be reset to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bd2cdf7f65d1258410067e1dbfa02e06ec92b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">如果 &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; 未启用 &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt; ，启用它。</target>
        </trans-unit>
        <trans-unit id="d160ec14cdba130b3a52eed8160428fd608a596b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3/include/wx/msw/setup.h&lt;/code&gt;, enable it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99871da2f295c0790df21d324a78c1b82d11e8b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;{extra_files, ExtraFiles}&lt;/code&gt; option is given then the &lt;code&gt;ExtraFiles&lt;/code&gt; are added to the tarball after everything else to be included has been added. The &lt;code&gt;ExtraFiles&lt;/code&gt; list is a list of files or directories in the same format as the &lt;code&gt;add_type()&lt;/code&gt; tuple for &lt;code&gt;erl_tar:add/3,4&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275e62491f49fb1a70d7127de6210ff8d9a19127" translate="yes" xml:space="preserve">
          <source>If the ASN.1 module has been compiled with option &lt;code&gt;maps&lt;/code&gt;, the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; are represented as maps.</source>
          <target state="translated">如果ASN.1模块已使用选项 &lt;code&gt;maps&lt;/code&gt; 进行编译，则 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 类型将表示为映射。</target>
        </trans-unit>
        <trans-unit id="722c5c772253cfa0375f5705288b0321c521aa8d" translate="yes" xml:space="preserve">
          <source>If the AckStatus is ok, it is indicating that this is a true acknowledgement of the transaction reply.</source>
          <target state="translated">如果AckStatus是ok,说明这是一个真实的事务回复确认。</target>
        </trans-unit>
        <trans-unit id="d0f84b01e010783659e66100fe954814d18e563f" translate="yes" xml:space="preserve">
          <source>If the AckStatus is {error, Reason}, it is an indication that the acknowledgement or even the reply (for which this is an acknowledgement) was not delivered, but there is no point in waiting any longer for it to arrive. This happens when:</source>
          <target state="translated">如果AckStatus是{error,Reason},则表明确认甚至是回复(对其而言,这是一个确认)没有送达,但没有必要再等待它的到来。这种情况发生在:</target>
        </trans-unit>
        <trans-unit id="88faac2c33abe1fdc3fc1b10f5136c262bb64e7a" translate="yes" xml:space="preserve">
          <source>If the BEAM file contains &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果BEAM文件包含 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; ，则返回元组列表。每个元组的第一个元素是以下之一：</target>
        </trans-unit>
        <trans-unit id="52ebbcd03e14972b092b8f0cc1bbe4c3dd868b59" translate="yes" xml:space="preserve">
          <source>If the BEAM file does not contain debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">如果BEAM文件不包含调试信息,那么将返回一个元组列表。每个元组的第一个元素是以下之一:</target>
        </trans-unit>
        <trans-unit id="5e318cbbe5a1c0ec48c8b2b2021ac1f10131570e" translate="yes" xml:space="preserve">
          <source>If the C node acts as a server, it must first create a socket (call &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;) listening to a certain port number &lt;code&gt;port&lt;/code&gt;. It then publishes its name and port number with &lt;code&gt;epmd&lt;/code&gt;, the Erlang port mapper daemon. For details, see the &lt;code&gt;epmd&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">如果C节点充当服务器，则它必须首先创建一个侦听某个端口号 &lt;code&gt;port&lt;/code&gt; 的套接字（调用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;listen()&lt;/code&gt; ）。然后，它使用Erlang端口映射器守护程序 &lt;code&gt;epmd&lt;/code&gt; 发布其名称和端口号。有关详细信息，请参见ERTS中的 &lt;code&gt;epmd&lt;/code&gt; 手册页：</target>
        </trans-unit>
        <trans-unit id="82d38ec527a550307461604062c03b211a833f6c" translate="yes" xml:space="preserve">
          <source>If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).</source>
          <target state="translated">如果COND1模式匹配,则尝试FOO(如果FOO成功,则可能在该组结束后再尝试其他项目)。失败时,匹配器跳转到第二个选项,并尝试COND2,而不回溯到COND1。如果成功而BAR失败,则尝试COND3。如果BAZ再失败,就没有更多的备选方案了,所以要回溯到整个组之前的任何方案。如果(*THEN)不在一个交替范围内,它的作用就像(*PRUNE)。</target>
        </trans-unit>
        <trans-unit id="ac5eaef6ff1820888de0ffa5ad9b4186d0234433" translate="yes" xml:space="preserve">
          <source>If the CPU information has changed since the last time it was read, the atom &lt;code&gt;changed&lt;/code&gt; is returned, otherwise the atom &lt;code&gt;unchanged&lt;/code&gt;. If the CPU information has changed, you probably want to &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt;. You typically want to have as many schedulers online as &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果因为它读取的最后一次CPU的信息发生了变化，原子 &lt;code&gt;changed&lt;/code&gt; 返回，否则原子 &lt;code&gt;unchanged&lt;/code&gt; 。如果CPU的信息发生了变化，你可能要 &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt; 。您通常希望在线拥有尽可能多的调度程序与 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a41da23020d6b98e8307d0411d62373331fcee35" translate="yes" xml:space="preserve">
          <source>If the CertificateRequest message contained a non-empty &quot;oid_filters&quot; extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674a0c6bf29cc8c8f0b253946e997318f6046675" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the &lt;code&gt;auth_group_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">如果使用Dets存储方法，则组数据库由Dets维护，并且不能手工编辑。使用模块 &lt;code&gt;mod_auth&lt;/code&gt; 的API 创建/编辑组数据库。如果使用Mnesia存储方法，则忽略此伪指令。出于安全原因，请确保 &lt;code&gt;auth_group_file&lt;/code&gt; 存储在Web服务器的文档树之外。如果将其放置在受保护的目录中，则客户端可以下载它。</target>
        </trans-unit>
        <trans-unit id="2690e1607b444fbdfb4354a7fc5e69fab4fc5a65" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that &lt;code&gt;auth_user_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">如果使用Dets存储方法，则用户数据库由Dets维护，并且不能手工编辑。使用模块 &lt;code&gt;mod_auth&lt;/code&gt; 中的API函数来创建/编辑用户数据库。如果使用Mnesia存储方法，则忽略此伪指令。出于安全原因，请确保 &lt;code&gt;auth_user_file&lt;/code&gt; 存储在Web服务器的文档树之外。如果将其放置在受保护的目录中，则客户端可以下载它。</target>
        </trans-unit>
        <trans-unit id="5d6f0952016312ac237e99b15d9161adf55f700d" translate="yes" xml:space="preserve">
          <source>If the Erlang node was alive, that is, set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</source>
          <target state="translated">如果Erlang节点是活着的,也就是说,设置了与其他节点的通信,这部分列出了活跃的连接。可以存在以下字段。</target>
        </trans-unit>
        <trans-unit id="18daf2db870215dd47d6849bc420623f1e0d4030" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</source>
          <target state="translated">如果Erlang运行时系统是唯一一个将线程绑定到逻辑处理器的操作系统进程,这就会提高运行时系统的性能。但是,如果其他OS进程(例如,另一个Erlang运行时系统)也将线程绑定到逻辑处理器上,反而会出现性能惩罚。有时这种性能惩罚可能很严重。如果是这样,建议不要绑定调度器。</target>
        </trans-unit>
        <trans-unit id="3549c6b8d3c0426e098c164e7bd7160b6e4be362" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system. However, if other operating system processes (for example another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. This performance penalty can sometimes be severe. If so, you are advised not to bind the schedulers.</source>
          <target state="translated">如果Erlang运行时系统是唯一一个将线程绑定到逻辑处理器的操作系统进程,这就会提高运行时系统的性能。但是,如果其他操作系统进程(例如另一个Erlang运行时系统)也将线程绑定到逻辑处理器上,反而会出现性能惩罚。这种性能惩罚有时会很严重。如果是这样,建议你不要绑定调度器。</target>
        </trans-unit>
        <trans-unit id="78b8e3a5a6a0636736a794de9e5a1415d4c36fbf" translate="yes" xml:space="preserve">
          <source>If the Erlang shell buffer would be killed the command line history is saved to a file. The command line history is automatically retrieved when a new Erlang shell is started.</source>
          <target state="translated">如果Erlang shell缓冲区被杀死,命令行历史记录会被保存到一个文件中。当一个新的 Erlang shell 启动时,命令行历史记录会被自动检索。</target>
        </trans-unit>
        <trans-unit id="5ad331d93d63bf83b44ef888cb4e43e94ea364bb" translate="yes" xml:space="preserve">
          <source>If the INDEX column is of type INTEGER, or derived from INTEGER, the corresponding type should be &lt;code&gt;integer&lt;/code&gt;. If it is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING), the corresponding type should be &lt;code&gt;string&lt;/code&gt;. Finally, if the type is of variable length, but with a fixed size restriction (e.g. IpAddress), the corresponding type should be &lt;code&gt;fix_string&lt;/code&gt;.</source>
          <target state="translated">如果INDEX列的类型为INTEGER或从INTEGER派生，则对应的类型应为 &lt;code&gt;integer&lt;/code&gt; 。如果是可变长度类型（例如OBJECT IDENTIFIER，OCTET STRING），则对应的类型应该是 &lt;code&gt;string&lt;/code&gt; 。最后，如果类型具有可变长度，但是具有固定的大小限制（例如IpAddress），则对应的类型应该为 &lt;code&gt;fix_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27815f723f23d4e4cf3d912f3476eb64c838477e" translate="yes" xml:space="preserve">
          <source>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">如果MG不能提供MGC的MID,MG可以使用原子'priminary_mid'作为megaco:connect/4的RemoteMid参数,调用流程是这样的。</target>
        </trans-unit>
        <trans-unit id="291d17d4be116cb44759c41864d170474773407f" translate="yes" xml:space="preserve">
          <source>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">如果MG已经配置了MGC的MID,它可以作为megaco:connect/4的RemoteMid参数,呼叫流程如下。</target>
        </trans-unit>
        <trans-unit id="3d3ec8b1bad21c29a9fcf6552b6d84ffcf7600b8" translate="yes" xml:space="preserve">
          <source>If the Mnesia database is used, this function calls &lt;code&gt;mnesia:write&lt;/code&gt; to store the values. This means that this function must be called from within a transaction (&lt;code&gt;mnesia:transaction/1&lt;/code&gt; or &lt;code&gt;mnesia:dirty/1&lt;/code&gt;).</source>
          <target state="translated">如果使用Mnesia数据库，则此函数调用 &lt;code&gt;mnesia:write&lt;/code&gt; 来存储值。这意味着必须从事务（ &lt;code&gt;mnesia:transaction/1&lt;/code&gt; 或 &lt;code&gt;mnesia:dirty/1&lt;/code&gt; ）中调用此函数。</target>
        </trans-unit>
        <trans-unit id="40a56f15bd541bd82f926eed2c112eaac90f9e71" translate="yes" xml:space="preserve">
          <source>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</source>
          <target state="translated">如果NIF调用太长,必须用以下方式之一来处理,以避免响应能力下降、调度器负载平衡问题和其他奇怪的行为。</target>
        </trans-unit>
        <trans-unit id="436a83604c57a3e3475d1d2d6359ca37e137b110" translate="yes" xml:space="preserve">
          <source>If the OBJECT IDENTIFIER is longer than an OBJECT IDENTIFIER of an object type in the MIB, it refers to object instances. Because of this, it is possible to control whether or not particular rows in a table shall be visible.</source>
          <target state="translated">如果OBJECT IDENTIFIER比MIB中某一对象类型的OBJECT IDENTIFIER长,则是指对象实例。正因为如此,可以控制表中的特定行是否可见。</target>
        </trans-unit>
        <trans-unit id="b1b26d2a72fe7f32dcd9c24e2f00608157279f71" translate="yes" xml:space="preserve">
          <source>If the OS used does not support non-blocking &lt;code&gt;sendfile&lt;/code&gt;, an Erlang fallback using &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果使用不支持非阻塞的OS &lt;code&gt;sendfile&lt;/code&gt; ，一个Erlang使用回退 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; 被使用。</target>
        </trans-unit>
        <trans-unit id="b3598222fc1bb53b9989c1f5e6bfd02eed50487d" translate="yes" xml:space="preserve">
          <source>If the SNMP agent needs to interact with sub-agents constructed in another package, a special sub-agent should be used, which communicates through a protocol specified by the other package.</source>
          <target state="translated">如果SNMP代理需要与另一个包中构建的子代理进行交互,则应使用一个特殊的子代理,该子代理通过另一个包指定的协议进行通信。</target>
        </trans-unit>
        <trans-unit id="1c500f599c51107a79c77a136f03f46d05fafc58" translate="yes" xml:space="preserve">
          <source>If the SNMP table has more than one INDEX column, the corresponding Mnesia row is a tuple, where the first element is a tuple with the INDEX columns. Generally, if the SNMP table has &lt;strong&gt;N&lt;/strong&gt; INDEX columns and &lt;strong&gt;C&lt;/strong&gt; data columns, the Mnesia table is of arity &lt;strong&gt;(C-N)+1&lt;/strong&gt;, where the key is a tuple of arity &lt;strong&gt;N&lt;/strong&gt; if &lt;strong&gt;N &amp;gt; 1&lt;/strong&gt;, or a single term if &lt;strong&gt;N = 1&lt;/strong&gt;.</source>
          <target state="translated">如果SNMP表具有多个INDEX列，则对应的Mnesia行是一个元组，其中第一个元素是带有INDEX列的元组。通常，如果SNMP表具有&lt;strong&gt;&amp;Ntilde;&lt;/strong&gt; INDEX列和&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt;数据列，则Mnesia的表是元数的&lt;strong&gt;（CN）1&lt;/strong&gt;，其中关键是元数元组&lt;strong&gt;&amp;Ntilde;&lt;/strong&gt;如果&lt;strong&gt;N&amp;gt; 1&lt;/strong&gt;，或一个单一的术语，如果&lt;strong&gt;N = 1&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3c217a2396ebcee146469f461600abdf337e010c" translate="yes" xml:space="preserve">
          <source>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</source>
          <target state="translated">如果TFTP服务器收到来自同一个客户端的另一个请求(相同的主机和端口),而它已经与客户端建立了一个活动的连接,如果新的请求与第一个请求相同(相同的文件名和选项),那么它将忽略这个新的请求。这意味着(新的)客户端将由服务器端已经在进行的连接提供服务。通过不建立与正在进行的连接并行的另一个连接,服务器消耗的资源更少。</target>
        </trans-unit>
        <trans-unit id="89cbc4f7538c3f8a055eafb734ab8d43e17f7e9a" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF:</source>
          <target state="translated">如果Unicode转换修饰符（ &lt;code&gt;t&lt;/code&gt; ）有效，则integer参数可以是表示有效Unicode代码点的任何数字，否则应为小于或等于255的整数，否则将被16＃FF屏蔽：</target>
        </trans-unit>
        <trans-unit id="cc5c86359b9d2f999369876543233d4ea822c7b0" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used in the format string, all event handlers must ensure that the formatted output is correctly encoded for the I/O device.</source>
          <target state="translated">如果在格式字符串中使用了Unicode转换修饰符（ &lt;code&gt;t&lt;/code&gt; ），则所有事件处理程序都必须确保为I / O设备正确编码了格式化的输出。</target>
        </trans-unit>
        <trans-unit id="9a64305e88f74d03f63e30e4aff9344ad3928f49" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function clause:</source>
          <target state="translated">如果在子句级别进行分析，则结果以元组列表 &lt;code&gt;{Clause,Calls}&lt;/code&gt; 的形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是对每个函数子句的调用次数：</target>
        </trans-unit>
        <trans-unit id="7bb518d0fd97d3152a60a637270e37af04b13222" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt;, one for each function clause in the module. A clause is specified by its module name, function name, arity and position within the function definition:</source>
          <target state="translated">如果在子句级别进行分析，则结果以元组 &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt; 的列表的形式给出，该列表用于模块中的每个函数子句。子句由其模块名称，函数名称，函数和在函数定义中的位置指定：</target>
        </trans-unit>
        <trans-unit id="2478a8c8617596c655cc3da82b5c379b47e51b09" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function:</source>
          <target state="translated">如果在函数级别进行分析，则结果以元组 &lt;code&gt;{Function,Calls}&lt;/code&gt; 的列表形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是每个函数的调用次数：</target>
        </trans-unit>
        <trans-unit id="55b7df1c13246cf49b1f19e127c65003b3a10d37" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt;, one for each function in the module. A function is specified by its module name, function name and arity:</source>
          <target state="translated">如果在功能级别进行分析，则结果以元组 &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt; 的列表的形式给出，每个元组用于模块中的每个功能。函数由其模块名称，函数名称和属性指定：</target>
        </trans-unit>
        <trans-unit id="77e592dc92d7ea0f9403bfb4d1e1860bc8a3fe5a" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given as a tuple &lt;code&gt;{Module,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the total number of calls to functions in the module:</source>
          <target state="translated">如果在模块级别进行分析，则结果以元组 &lt;code&gt;{Module,Calls}&lt;/code&gt; 的形式给出。这里的 &lt;code&gt;Calls&lt;/code&gt; 是模块中对函数的调用总数：</target>
        </trans-unit>
        <trans-unit id="5cba27c146502c3ec8e1044a59eca78a126f8832" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given for the entire module as a tuple &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt;:</source>
          <target state="translated">如果在模块级别进行分析，则将整个模块的结果作为元组 &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt; 给出：</target>
        </trans-unit>
        <trans-unit id="b39d0ccaa857b9f0a8f4a5ffffbdf43a68463d85" translate="yes" xml:space="preserve">
          <source>If the application SSH &lt;strong&gt;is&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delvers the list of algorithms after application of level 0 and level 1 configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53045943992891c562424981e5024fb26dfffc6" translate="yes" xml:space="preserve">
          <source>If the application SSH is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delivers the list of default (hardcoded) algorithms with respect to the support in the current cryptolib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde9769f09668ea79529ce6edefab85a0899d6da" translate="yes" xml:space="preserve">
          <source>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. &lt;code&gt;MasterNodes&lt;/code&gt; can only contain nodes where the table has a replica. If the &lt;code&gt;MasterNodes&lt;/code&gt; list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</source>
          <target state="translated">如果应用程序检测到可能导致数据库不一致的通信故障（在潜在的分区网络中），则可以使用函数 &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; 定义从哪个节点加载每个表。在启动时，无论Mnesia何时以及是否在其他节点上终止，Mnesia普通表加载算法都会被绕过，并从为该表定义的主节点之一加载表。 &lt;code&gt;MasterNodes&lt;/code&gt; 只能包含表具有副本的节点。如果 &lt;code&gt;MasterNodes&lt;/code&gt; 列表为空，则将重置特定表的主节点恢复机制，并在下次重新启动时使用常规加载机制。</target>
        </trans-unit>
        <trans-unit id="130ab90516f90ac945b3ebb327eb04a5eb66e021" translate="yes" xml:space="preserve">
          <source>If the application detects that there has been a communication failure that can have caused an inconsistent database, it can use the function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; to pinpoint from which nodes each table can be loaded.</source>
          <target state="translated">如果应用程序检测到可能导致数据库不一致的通信故障，则可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; 来确定可以从中加载每个表的节点。</target>
        </trans-unit>
        <trans-unit id="afc60992fdf5138ada7ac0487b61ff57acf63af0" translate="yes" xml:space="preserve">
          <source>If the application is distributed, setting the permission to &lt;code&gt;false&lt;/code&gt; means that the application will be started at, or moved to, another node according to how its distribution is configured (see &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果应用程序是分布式的，则将权限设置为 &lt;code&gt;false&lt;/code&gt; 意味着该应用程序将根据其分发的配置方式在另一个节点上启动或移动到另一个节点（请参阅 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff80acb30d9dab81e0a46a50c51388e4dd17f7a3" translate="yes" xml:space="preserve">
          <source>If the application is not already loaded, the application controller first loads it using &lt;code&gt;application:load/1&lt;/code&gt;. It checks the value of the &lt;code&gt;applications&lt;/code&gt; key, to ensure that all applications that are to be started before this application are running.</source>
          <target state="translated">如果尚未加载应用程序，则应用程序控制器首先使用 &lt;code&gt;application:load/1&lt;/code&gt; 加载它。它检查 &lt;code&gt;applications&lt;/code&gt; 密钥的值，以确保该应用程序运行之前要启动的所有应用程序。</target>
        </trans-unit>
        <trans-unit id="04b974d958e0b100d3e2e5b38644fd0a6abff6f9" translate="yes" xml:space="preserve">
          <source>If the application needs to include a generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e7f4b69d5dbe87fef4344be83c638457c7eec7" translate="yes" xml:space="preserve">
          <source>If the application needs to include the generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">如果应用程序需要包括生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件，则对Erlang编译器使用 &lt;code&gt;-include_lib&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="683ef606c81dc1c47b5d3b9c095a4243030bc6f8" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;Func&lt;/code&gt;, the timetrap is triggered when this function returns. &lt;code&gt;Func&lt;/code&gt; can also return a new &lt;code&gt;Time&lt;/code&gt; value, which in that case is the value for the new timetrap.</source>
          <target state="translated">如果参数为 &lt;code&gt;Func&lt;/code&gt; ，则此函数返回时将触发时间陷阱。 &lt;code&gt;Func&lt;/code&gt; 还可以返回一个新的 &lt;code&gt;Time&lt;/code&gt; 值，在这种情况下，该值是新timetrap的值。</target>
        </trans-unit>
        <trans-unit id="0044e9d649274cc90388ee08844dd19dea89fffe" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt;, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</source>
          <target state="translated">如果该参数为 &lt;code&gt;false&lt;/code&gt; ，则针对此调用和所有后续调用，将当前进程的调用跟踪消息模式设置为正常（非静默）。</target>
        </trans-unit>
        <trans-unit id="580f4ef0ac5467ad7d400143bdf178fbf747f519" translate="yes" xml:space="preserve">
          <source>If the argument is invalid</source>
          <target state="translated">如果参数无效</target>
        </trans-unit>
        <trans-unit id="c3def1ea3a84c13010f731140dbb829f22745007" translate="yes" xml:space="preserve">
          <source>If the argument is not &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the call trace message mode is unaffected.</source>
          <target state="translated">如果参数不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，那么呼叫跟踪消息模式将不受影响。</target>
        </trans-unit>
        <trans-unit id="259c1b3a1fe7d6190505c0293c344282223212ec" translate="yes" xml:space="preserve">
          <source>If the arguments or options are malformed, the function throws a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">如果参数或选项格式错误，则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="6b60aa2a26e0a24944e43c25dc549ab30b52857b" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, and &lt;code&gt;I&lt;/code&gt; is greater than &lt;code&gt;size(Array)-1&lt;/code&gt;, the array grows to size &lt;code&gt;I+1&lt;/code&gt;.</source>
          <target state="translated">如果数组没有固定大小，并且 &lt;code&gt;I&lt;/code&gt; 大于 &lt;code&gt;size(Array)-1&lt;/code&gt; ，则数组将增长为大小 &lt;code&gt;I+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e97eb155a25d26096ef78fc2b67cf5447071cfc9" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, the default value for any index &lt;code&gt;I&lt;/code&gt; greater than &lt;code&gt;size(Array)-1&lt;/code&gt; is returned.</source>
          <target state="translated">如果数组的大小不固定，则返回任何大于 &lt;code&gt;size(Array)-1&lt;/code&gt; 的索引 &lt;code&gt;I&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="5552e65bff8e7b19a94e0b983a0ae9846e97b32b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;len&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">如果原子已经存在，则此函数将术语存储在 &lt;code&gt;*atom&lt;/code&gt; 中,并返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;len&lt;/code&gt; 超过一个原子所允许的最大长度（255个字符），则还返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d657f088165dffa1fac0e9bbe37e81e0983227b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if the length of &lt;code&gt;name&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">如果原子已经存在，则此函数将术语存储在 &lt;code&gt;*atom&lt;/code&gt; 中,并返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 的长度超过一个原子允许的最大长度（255个字符），则还返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4fe1851aab21eaf10695f8609bb67b63980301" translate="yes" xml:space="preserve">
          <source>If the atomic compare and swap described above failed, the last pointer didn't point to the last element. In this case we need to insert the new element somewhere between the element that the last pointer pointed to and the actual last element. If we do it this way the last pointer will eventually end up at the last element when threads stop adding new elements. When trying to insert somewhere near the end and failing to do so, the inserting thread sometimes moves to the next element and sometimes tries with the same element again. This in order to spread the inserted elements during heavy contention. That is, we try to spread the modifications of memory to different locations instead of letting all threads continue to try to modify the same location in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8e0e10b7bf47bd128f48e3648baa81fc6271d" translate="yes" xml:space="preserve">
          <source>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">如果截断日志的尝试失败，则磁盘日志进程将以EXIT消息 &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt; 终止。 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 请求排队的其他进程收到消息{disk_log，Node，{error，disk_log_stopped}}。</target>
        </trans-unit>
        <trans-unit id="88a48f973bcaa36e009e8c2234922f730ca71334" translate="yes" xml:space="preserve">
          <source>If the binder is not seen, the binder is validated. If the binder is valid, the server proceeds with the 0-RTT handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ec818fc01c7aa387cc6cab61ea5c97ff0c8f49" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt; systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7576e0423d861bfb48c83bfa3b5b0c281c96ce4" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt;systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">如果引导脚本包含 &lt;code&gt;$ROOT&lt;/code&gt; 以外的路径变量 &lt;code&gt;Var&lt;/code&gt; ，则此变量将扩展为 &lt;code&gt;Dir&lt;/code&gt; 。当应用程序安装在 &lt;code&gt;$ROOT/lib&lt;/code&gt; 以外的其他目录中时使用。请参阅SASL中的 &lt;code&gt;systools:make_script/1,2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc4746e92bb60b88599fe7a3e474a68b05603534" translate="yes" xml:space="preserve">
          <source>If the call times out, a &lt;code&gt;timeout&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果呼叫 &lt;code&gt;timeout&lt;/code&gt; 则会引发超时异常。</target>
        </trans-unit>
        <trans-unit id="55cc2b4bba08ca73afe9b3ccf29541b97304c864" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;erlang:load_nif/2&lt;/code&gt; fails, the module is unloaded and a warning report is sent to the error loader.</source>
          <target state="translated">如果对 &lt;code&gt;erlang:load_nif/2&lt;/code&gt; 的调用失败，则卸载模块，并向错误加载器发送警告报告。</target>
        </trans-unit>
        <trans-unit id="4b48d532db57aebd987ac6820de7ad7436dd64ed" translate="yes" xml:space="preserve">
          <source>If the callback module cannot be loaded, an error tuple is returned. The &lt;code&gt;Reason&lt;/code&gt; in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</source>
          <target state="translated">如果无法加载回调模块，则返回错误元组。错误元组中的 &lt;code&gt;Reason&lt;/code&gt; 是代码加载器在尝试加载回调模块的代码时返回的原因。</target>
        </trans-unit>
        <trans-unit id="8bf050fe2cb79b5d36a88eaed63edd7eed898889" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_get_state/1&lt;/code&gt; function, &lt;code&gt;get_state/1,2&lt;/code&gt; assumes that the &lt;code&gt;Misc&lt;/code&gt; value is the state of the callback module and returns it directly instead.</source>
          <target state="translated">如果回调模块未导出 &lt;code&gt;system_get_state/1&lt;/code&gt; 函数，则 &lt;code&gt;get_state/1,2&lt;/code&gt; 假定 &lt;code&gt;Misc&lt;/code&gt; 值是回调模块的状态，而是直接返回它。</target>
        </trans-unit>
        <trans-unit id="883a1351f7fb38c93f27abac246b139ddf314ded" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_replace_state/2&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; assumes that &lt;code&gt;Misc&lt;/code&gt; is the state of the callback module, passes it to &lt;code&gt;StateFun&lt;/code&gt; and uses the return value as both the new state and as the new value of &lt;code&gt;Misc&lt;/code&gt;.</source>
          <target state="translated">如果回调模块未导出 &lt;code&gt;system_replace_state/2&lt;/code&gt; 函数，则 &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; 假定 &lt;code&gt;Misc&lt;/code&gt; 是回调模块的状态，将其传递给 &lt;code&gt;StateFun&lt;/code&gt; 并将返回值用作新状态和 &lt;code&gt;Misc&lt;/code&gt; 的新值。</target>
        </trans-unit>
        <trans-unit id="79079b06e33e739dcb437556ed9482e9eedc90a9" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt; system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0469d22f2398ad4902a9f0274d691cde96d200" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">如果回调模块导出 &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; 函数，则在目标进程 &lt;code&gt;StateFun&lt;/code&gt; 其调用以使用StateFun替换其状态。它的两个参数是 &lt;code&gt;StateFun&lt;/code&gt; 和 &lt;code&gt;Misc&lt;/code&gt; ，其中 &lt;code&gt;Misc&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;Misc&lt;/code&gt; 值相同。甲 &lt;code&gt;system_replace_state/2&lt;/code&gt; 功能预计返回 &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; ，其中 &lt;code&gt;NewState&lt;/code&gt; 是回调模块，通过调用获得的新状态 &lt;code&gt;StateFun&lt;/code&gt; ，和 &lt;code&gt;NewMisc&lt;/code&gt; 是用来取代原来的一个可能的新值 &lt;code&gt;Misc&lt;/code&gt; （需要作为 &lt;code&gt;Misc&lt;/code&gt; 通常在其中包含回调模块的状态。</target>
        </trans-unit>
        <trans-unit id="cdcc08df51274710d006dbff0355880927f9ffef" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt; Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c3eecf9345190c4251d4199b67e06fe9f176a1" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">如果回调模块导出函数 &lt;code&gt;system_get_state/1&lt;/code&gt; ，则在目标进程中调用它以获取其状态。它的参数与 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;Misc&lt;/code&gt; 值相同，并且函数 &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; 应该从中提取回调模块的状态。函数 &lt;code&gt;system_get_state/1&lt;/code&gt; 必须返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是回调模块的状态。</target>
        </trans-unit>
        <trans-unit id="01c2d9fbdbf4902fbd9ed598640b451a617bf5cc" translate="yes" xml:space="preserve">
          <source>If the callback module's &lt;code&gt;system_get_state/1&lt;/code&gt; function crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception.</source>
          <target state="translated">如果回调模块的 &lt;code&gt;system_get_state/1&lt;/code&gt; 函数崩溃或引发异常，则调用者退出，错误为 &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt; ，其中 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Reason&lt;/code&gt; 指示详细信息例外。</target>
        </trans-unit>
        <trans-unit id="7986fc8d38f019b96fd636349aa5cfd63d9efc6a" translate="yes" xml:space="preserve">
          <source>If the callback module's function &lt;code&gt;system_replace_state/2&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception. If the callback module does not provide a &lt;code&gt;system_replace_state/2&lt;/code&gt; function and &lt;code&gt;StateFun&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt;.</source>
          <target state="translated">如果回调模块的函数 &lt;code&gt;system_replace_state/2&lt;/code&gt; 崩溃或引发异常，则调用者退出，错误为 &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt; ，其中 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Reason&lt;/code&gt; 指示详细信息例外。如果回调模块不提供 &lt;code&gt;system_replace_state/2&lt;/code&gt; 函数，并且 &lt;code&gt;StateFun&lt;/code&gt; 崩溃或引发异常，则调用方退出，错误为 &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20f590333f587ce4f158c6bd3d9e3042df378fe" translate="yes" xml:space="preserve">
          <source>If the caller of the function wants to know whether or not acknowledgments are received for a certain notification (provided it is sent as an inform), the &lt;code&gt;Receiver&lt;/code&gt; parameter can be specified as &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (refer to the Reference Manual, section snmp, module &lt;code&gt;snmp&lt;/code&gt; for more details). In this case, the agent send a message &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; or &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; for each management target.</source>
          <target state="translated">如果函数的调用者想知道是否收到了针对某个通知的确认（假设它是作为通知发送的），则可以将 &lt;code&gt;Receiver&lt;/code&gt; 参数指定为 &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; （请参见参考手册的snmp部分） ，请参阅模块 &lt;code&gt;snmp&lt;/code&gt; 以获得更多详细信息）。在这种情况下，代理会为每个管理目标发送一条消息 &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; 或 &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b596624aa0902d380836d0a8912ab2326ff5b443" translate="yes" xml:space="preserve">
          <source>If the calling process holds on to the value of the persistent term and the persistent term is deleted in the future, the term will be copied to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d99e3904aef3995d136af596a2f043101aa1f9" translate="yes" xml:space="preserve">
          <source>If the calling process is not trapping exits, and checking &lt;code&gt;PidOrPort&lt;/code&gt; is cheap (that is, if &lt;code&gt;PidOrPort&lt;/code&gt; is local), &lt;code&gt;link/1&lt;/code&gt; fails with reason &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">如果调用过程未捕获陷阱，并且检查 &lt;code&gt;PidOrPort&lt;/code&gt; 是否便宜（也就是说，如果 &lt;code&gt;PidOrPort&lt;/code&gt; 是本地的），则 &lt;code&gt;link/1&lt;/code&gt; 失败，原因为 &lt;code&gt;noproc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51149d8666bb19147118b83bb274dae83a5f60ca" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a8b4f21577fe3cc5ca8d0fd53bd3ee9424f7f7" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">如果调用过程以后因 &lt;code&gt;Reason&lt;/code&gt; 终止，则事件管理器通过使用 &lt;code&gt;{stop,Reason}&lt;/code&gt; 作为参数调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 来删除事件处理程序。</target>
        </trans-unit>
        <trans-unit id="f41eb527b8f8f2ec9a45659469012def9325921e" translate="yes" xml:space="preserve">
          <source>If the capture options describe that no substring capturing is to be done (&lt;code&gt;{capture, none}&lt;/code&gt;), the function returns the single atom &lt;code&gt;match&lt;/code&gt; upon successful matching, otherwise the tuple &lt;code&gt;{match, ValueList}&lt;/code&gt;. Disabling capturing can be done either by specifying &lt;code&gt;none&lt;/code&gt; or an empty list as &lt;code&gt;ValueSpec&lt;/code&gt;.</source>
          <target state="translated">如果捕获选项描述无子捕获是必须要做的（ &lt;code&gt;{capture, none}&lt;/code&gt; ），该函数返回的单原子 &lt;code&gt;match&lt;/code&gt; 在成功匹配，否则该元组 &lt;code&gt;{match, ValueList}&lt;/code&gt; 。可以通过不指定 &lt;code&gt;none&lt;/code&gt; 或将空白列表指定为 &lt;code&gt;ValueSpec&lt;/code&gt; 来禁用捕获。</target>
        </trans-unit>
        <trans-unit id="8dfe9740232e522c9dccf1bcdb49e9bacfa76b87" translate="yes" xml:space="preserve">
          <source>If the carrier could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">如果在不损害系统响应能力的情况下无法完全扫描载体，则 &lt;code&gt;UnscannedSize&lt;/code&gt; 是必须跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="b3d882b62bc462be24a22c4ebd1a0b80e4bbf23e" translate="yes" xml:space="preserve">
          <source>If the character escaping feature needs to be disabled (typically for backwards compatibility reasons), use the &lt;code&gt;ct_run&lt;/code&gt; start flag &lt;code&gt;-no_esc_chars&lt;/code&gt;, or the &lt;code&gt;ct:run_test/1&lt;/code&gt; start option &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (this start option is also supported in test specifications).</source>
          <target state="translated">如果需要禁用字符转义功能（通常是出于向后兼容的原因），请使用 &lt;code&gt;ct_run&lt;/code&gt; 开始标志 &lt;code&gt;-no_esc_chars&lt;/code&gt; 或 &lt;code&gt;ct:run_test/1&lt;/code&gt; 开始选项 &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; （测试规范中也支持此开始选项） 。</target>
        </trans-unit>
        <trans-unit id="93733502359d2306f277753fcf5f39262e0db10b" translate="yes" xml:space="preserve">
          <source>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning and &lt;code&gt;restart_child/2&lt;/code&gt; cannot be used for these children.</source>
          <target state="translated">如果子级是临时的，则该子级规范将在过程终止后立即删除。这意味着 &lt;code&gt;delete_child/2&lt;/code&gt; 没有意义，并且 &lt;code&gt;restart_child/2&lt;/code&gt; 不能用于这些子级。</target>
        </trans-unit>
        <trans-unit id="43bb63cf5661d4a237a06093eced5cd149d67b35" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">如果子进程是另一个主管，则应将其设置为 &lt;code&gt;infinity&lt;/code&gt; ,以使子树有足够的时间关闭。如果子进程是工作进程，也可以将其设置为 &lt;code&gt;infinity&lt;/code&gt; 。请参阅以下警告：</target>
        </trans-unit>
        <trans-unit id="d5e42700559025ed548daef3157e2a83d1175a5d" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ca616fb018a5f7ed9b1457ccf717eb545a0d6c" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">如果子进程是另一个主管，则将关闭时间设置为 &lt;code&gt;infinity&lt;/code&gt; ,以使子树有足够的时间关闭。如果子进程是工作进程，也可以将其设置为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65acda7f63f750f753fdf6f71ac3163eb7c73a09" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c8d2313d1867bff7ceabb992796a9dc2cb660e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the child specification is added to the supervisor (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, see below), the pid is set to &lt;code&gt;undefined&lt;/code&gt;, and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则将子规范添加到主管（除非该主管是 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管，请参见下文），将pid设置为 &lt;code&gt;undefined&lt;/code&gt; ，并且该函数返回 &lt;code&gt;{ok,undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ef5502f7b080e1244d616694cf24b3ea2478505" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则pid保持设置为 &lt;code&gt;undefined&lt;/code&gt; ，该函数返回 &lt;code&gt;{ok,undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7a47396e2013d77055f46cf69011c8dbc710aa" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the child specification and pid are added to the supervisor and the function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，则将子规范和pid添加到主管中，并且该函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="48c5d696f2b0fd45c1b44f5e625a2accf1b0ea21" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the pid is added to the supervisor and the function returns the same value.</source>
          <target state="translated">如果子进程启动函数返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，则将pid添加到主管中，并且该函数返回相同的值。</target>
        </trans-unit>
        <trans-unit id="6d773deb857a328ed14a9080339dfab940c8161a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则子规范被丢弃，函数返回 &lt;code&gt;{error,Error}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是一个包含有关错误和子规范的信息的术语。</target>
        </trans-unit>
        <trans-unit id="1b122e474c03f3cefc84e42bbf3408fd35e5bb5e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error.</source>
          <target state="translated">如果子进程启动函数返回错误元组或错误值，或者失败，则该函数返回 &lt;code&gt;{error,Error}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是包含有关错误信息的术语。</target>
        </trans-unit>
        <trans-unit id="4b1288099957500451c193cb8d9ad26569f30036" translate="yes" xml:space="preserve">
          <source>If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification exists but the corresponding process is already running, the function returns &lt;code&gt;{error,running}&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;Id&lt;/code&gt; 标识的子规范不存在，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。如果子规范存在但相应的进程已在运行，则该函数返回 &lt;code&gt;{error,running}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdb0f0cbc98dc7d94d6b59162ff7e5e589d60364" translate="yes" xml:space="preserve">
          <source>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</source>
          <target state="translated">如果客户端不支持任何服务器公布的协议,或者服务器没有公布任何协议,客户端将返回到其列表中的第一个协议或默认协议(如果提供了默认协议)。如果服务器不支持下一个协议协商,如果没有提供默认协议,连接就会终止。</target>
        </trans-unit>
        <trans-unit id="1eacb16ee64844ecf9771b5e95710813db228ddf" translate="yes" xml:space="preserve">
          <source>If the client earlier has acquired a lock through &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt;, this operation releases the associated lock. To access another target than &lt;code&gt;running&lt;/code&gt;, the server must support &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">如果客户端之前已通过 &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt; 获得了锁，则此操作将释放关联的锁。要访问 &lt;code&gt;running&lt;/code&gt; 以外的其他目标，服务器必须支持 &lt;code&gt;:candidate&lt;/code&gt; 和/或 &lt;code&gt;:startup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35cb61822f1edfb65ab7f8cb515f968decf80d92" translate="yes" xml:space="preserve">
          <source>If the client fails to send the first ssh message after a tcp connection setup within this time (in milliseconds), the connection is closed. The default value is 30 seconds. This is actualy a generous time, so it can lowered to make the daemon less prone to DoS attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1ef493c0d6b60856faddf62e5c3f0669465abe" translate="yes" xml:space="preserve">
          <source>If the code cannot be structured as in the &lt;code&gt;multiple_setelement/1&lt;/code&gt; example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</source>
          <target state="translated">如果代码不能像 &lt;code&gt;multiple_setelement/1&lt;/code&gt; 示例中那样构造，则修改大型元组中的多个元素的最佳方法是将元组转换为列表，修改列表，然后将其转换回元组。</target>
        </trans-unit>
        <trans-unit id="929332aa79f38c1ef62558eac8beb42b63e4173b" translate="yes" xml:space="preserve">
          <source>If the common &lt;strong&gt;state callback&lt;/strong&gt; needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b7ca0808d04f400f34111028c04d20133e9b2d" translate="yes" xml:space="preserve">
          <source>If the common event handler needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">如果公共事件处理程序需要了解当前状态，则可以使用 &lt;code&gt;handle_common/4&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ff5b1741be466acda153b10a36fc7487f2ca70d6" translate="yes" xml:space="preserve">
          <source>If the compiler is to warn for missing callback functions, as it does for the OTP behaviours, add &lt;code&gt;-callback&lt;/code&gt; attributes in the behaviour module to describe the expected callbacks:</source>
          <target state="translated">如果编译器像OTP行为一样警告缺少的回调函数，请在行为模块中添加 &lt;code&gt;-callback&lt;/code&gt; 属性以描述预期的回调：</target>
        </trans-unit>
        <trans-unit id="523bb4f391597ed38f62115f28e3a49961855867" translate="yes" xml:space="preserve">
          <source>If the complete history is to be stored in the configuration file, &lt;code&gt;Config&lt;/code&gt; must be &lt;code&gt;all&lt;/code&gt;. If only a selected number of entries from the history are to be stored, &lt;code&gt;Config&lt;/code&gt; must be a list of integers pointing out the entries to be stored.</source>
          <target state="translated">如果要将完整的历史记录存储在配置文件中，则 &lt;code&gt;Config&lt;/code&gt; 必须为 &lt;code&gt;all&lt;/code&gt; 。如果仅要存储历史记录中选定数量的条目，则 &lt;code&gt;Config&lt;/code&gt; 必须是一个整数列表，指出要存储的条目。</target>
        </trans-unit>
        <trans-unit id="21e0716b03f7aa9ffd13782b0d420ef9a664a3d2" translate="yes" xml:space="preserve">
          <source>If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:</source>
          <target state="translated">如果条件不是上述任何一种格式,它必须是一个断言。这可以是一个正面或负面的lookahead或lookbehind断言。考虑下面的模式,包含非显著的空白,并且在第二行有两个选项。</target>
        </trans-unit>
        <trans-unit id="8a2fdb8b039278dbbab74f5b7bfb97af967770cd" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:</source>
          <target state="translated">如果满足条件,则使用 &quot;是 &quot;模式,否则使用 &quot;否 &quot;模式(如果存在)。如果子模式中存在两个以上的备选方案,就会出现编译时错误。两个备选方案中的每个方案本身都可以包含任何形式的嵌套子模式,包括条件子模式;对两个备选方案的限制只适用于条件的层次。下面的模式片段是一个替代品很复杂的例子。</target>
        </trans-unit>
        <trans-unit id="fa304219623acf477a2744ed1bbab72da379738b" translate="yes" xml:space="preserve">
          <source>If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</source>
          <target state="translated">如果条件是字符串(DEFINE),并且没有名称为DEFINE的子模式,那么条件总是false。在这种情况下,子模式中只能有一个选择。如果控制到模式中的这一点,则总是跳过。DEFINE的想法是,它可以用来定义 &quot;子程序&quot;,这些子程序可以从其他地方引用。(子程序的使用将在下面描述。)例如,一个匹配IPv4地址的模式,如 &quot;192.168.23.245&quot;,可以这样写(忽略空格和换行符)。</target>
        </trans-unit>
        <trans-unit id="8e3f4e65a85b857108a35b24009e6fe7e2ac2084" translate="yes" xml:space="preserve">
          <source>If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:</source>
          <target state="translated">如果条件是字符串(R),并且没有名称为R的子模式,那么如果对整个模式或任何子模式进行了递归调用,则条件为真。如果数字或名称前面有安培符,例如字母R后面有数字或名称。</target>
        </trans-unit>
        <trans-unit id="95c431a360008991bb1b7759c9f06391d6e75043" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, or if the initiation fails, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果配置错误或启动失败，则回调函数必须返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18a294113eb6042d9ad2a36514917a6dc077c344" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果配置错误，则回调函数必须返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a82e12e149afd95e3ddf1bb75d52a9982f828ca" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the same arguments as when &lt;code&gt;enable/2&lt;/code&gt; was called.</source>
          <target state="translated">如果配置参数 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;os_sup&lt;/code&gt; 会使用与调用 &lt;code&gt;enable/2&lt;/code&gt; 时相同的参数来自动调用此函数。</target>
        </trans-unit>
        <trans-unit id="aedee7601f2ce3a18dc9a8c63054f54ca3093e3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the values of &lt;code&gt;os_sup_own&lt;/code&gt; and &lt;code&gt;os_sup_syslogconf&lt;/code&gt; as arguments.</source>
          <target state="translated">如果配置参数 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;os_sup&lt;/code&gt; 会使用 &lt;code&gt;os_sup_own&lt;/code&gt; 和 &lt;code&gt;os_sup_syslogconf&lt;/code&gt; 的值作为参数来自动调用此函数。</target>
        </trans-unit>
        <trans-unit id="b2ffcf1c22e3ce76143a4b07b440007a5df05ea7" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;relocatable&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt; there is no need to install the target system with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be started. In that case the file tree containing the target system can be moved without re-installation.</source>
          <target state="translated">如果配置参数 &lt;code&gt;relocatable&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 没有必要与安装在目标系统 &lt;code&gt;reltool:install/2&lt;/code&gt; 就可以开始了。在这种情况下，可以移动包含目标系统的文件树，而无需重新安装。</target>
        </trans-unit>
        <trans-unit id="f9be9f192141862f112332246e5a8f6499cf62cb" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9759af159af887f4fafa82c8992b674a1e93e4" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created. If it has been created, it will be delivered an exit signal with an exit reason of &lt;code&gt;noconnection&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f42cb19285f317fb015c9fad2016cce36110ed" translate="yes" xml:space="preserve">
          <source>If the connection timeout option &lt;code&gt;connect_timeout&lt;/code&gt; is set, that value is used also for the negotiation timeout and this option (&lt;code&gt;timeout&lt;/code&gt;) is ignored.</source>
          <target state="translated">如果设置了连接超时选项 &lt;code&gt;connect_timeout&lt;/code&gt; ，则该值也将用于协商超时，并且该选项（ &lt;code&gt;timeout&lt;/code&gt; ）将被忽略。</target>
        </trans-unit>
        <trans-unit id="860a4598c1d1ec6a83570120e591b858d6e8f890" translate="yes" xml:space="preserve">
          <source>If the connection to a remote node goes down, the main node will mark it as lost. If the node comes back it will be added again. If the remote node was alive during the disconnected periode, cover data from before and during this periode will be included in the analysis.</source>
          <target state="translated">如果与远程节点的连接中断,主节点会将其标记为丢失。如果该节点恢复,则会再次添加。如果远程节点在断开的周期内还活着,那么在这个周期之前和期间的覆盖数据将包括在分析中。</target>
        </trans-unit>
        <trans-unit id="a99ee1cb6fcf81c8bae71874c193979ebe43ebab" translate="yes" xml:space="preserve">
          <source>If the constraints described so far is not enough, additional constraints can be written in C in &lt;code&gt;beam_load.c&lt;/code&gt; and be called as a guard function on the left side of the transformation. If the guard function returns a non-zero value, the matching of the rule will continue, otherwise the match will fail. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b7535bf38d5e1053e0dcfad4dfa786c040f2e7" translate="yes" xml:space="preserve">
          <source>If the contents of &lt;code&gt;.erlang&lt;/code&gt; are changed and a private version of &lt;code&gt;user_default&lt;/code&gt; is defined, the Erlang/OTP environment can be customized. More powerful changes can be made by supplying command-line arguments in the startup script &lt;code&gt;erl&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果更改 &lt;code&gt;.erlang&lt;/code&gt; 的内容并定义了 &lt;code&gt;user_default&lt;/code&gt; 的私有版本，则可以自定义Erlang / OTP环境。通过在启动脚本 &lt;code&gt;erl&lt;/code&gt; 中提供命令行参数，可以进行更强大的更改。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6279554b0d57c5f26b8ffa794daeaf8c67036750" translate="yes" xml:space="preserve">
          <source>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the &lt;code&gt;909&lt;/code&gt;-prefix and lift/glob markers) ends in a &lt;code&gt;9&lt;/code&gt;, the integer will become an Erlang-level variable prefixed with &lt;code&gt;Q&lt;/code&gt;, and if it ends with &lt;code&gt;99&lt;/code&gt; it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</source>
          <target state="translated">如果上下文需要整数而不是变量，原子或字符串，则不能使用大写约定来标记自动元变量。相反，如果整数（不带 &lt;code&gt;909&lt;/code&gt; 前缀和lift / glob标记）以 &lt;code&gt;9&lt;/code&gt; 结尾，则该整数将成为Erlang级变量的前缀 &lt;code&gt;Q&lt;/code&gt; ，如果以 &lt;code&gt;99&lt;/code&gt; 结尾，则该整数也将自动抽象。例如，以下将增加导出函数f的arity：</target>
        </trans-unit>
        <trans-unit id="e14244783ffadbf99f1d872c65ba8477af77375e" translate="yes" xml:space="preserve">
          <source>If the converse of a function F is a function F', then F' is called the &lt;strong id=&quot;inverse&quot;&gt;inverse&lt;/strong&gt; of F.</source>
          <target state="translated">如果函数F的逆是函数F'，则F'被称为F的&lt;strong id=&quot;inverse&quot;&gt;逆&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="04e1722c7eed1557956908ac595866c524c53815" translate="yes" xml:space="preserve">
          <source>If the cross compilation tools are prefixed by &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; you probably do not need to set these variables (where &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; is what has been passed as &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt;).</source>
          <target state="translated">如果交叉编译工具的前缀为 &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; 您可能不需要设置这些变量（其中 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 是通过 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 参数传递的 &lt;code&gt;configure&lt;/code&gt; 变量）。</target>
        </trans-unit>
        <trans-unit id="97604b617615c0b88c829c8abf48415d16d68d04" translate="yes" xml:space="preserve">
          <source>If the current working directory for &lt;code&gt;erlc&lt;/code&gt; is different from the working directory active when the compile server was started, &lt;strong&gt;and&lt;/strong&gt; if the compile server has active jobs, it will be restarted as soon as those jobs have finished. (Build systems that build files randomly across multiple directories in parallel will probably not benefit from the compile server.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693638c468a0a688aceae31ef9d5b589f67e3d3d" translate="yes" xml:space="preserve">
          <source>If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag &lt;code&gt;error&lt;/code&gt;, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;.</source>
          <target state="translated">如果由于列表中的非法Unicode / ISO Latin-1字符或任何二进制文件中的UTF编码无效而导致数据无法转换，则返回错误元组。错误元组包含标签 &lt;code&gt;error&lt;/code&gt; ，一个代表在错误发生之前可以转换的字符的列表以及一个包括和在令人讨厌的整数/字节之后的字符的表示形式。最后一部分主要用于调试，因为它仍然构成了可能很深的列表或混合列表，或两者兼有，不一定与原始数据具有相同的深度。在遍历列表时发生错误，并且剩下要解码的内容按&amp;ldquo;原样&amp;rdquo;返回。</target>
        </trans-unit>
        <trans-unit id="830c19e2812b5ad638344d6692b4a5d1c14189d2" translate="yes" xml:space="preserve">
          <source>If the data in the table is to be accessed so that the order of the keys in the table is significant, the table type &lt;code&gt;ordered_set&lt;/code&gt; can be used instead of the more usual &lt;code&gt;set&lt;/code&gt; table type. An &lt;code&gt;ordered_set&lt;/code&gt; is always traversed in Erlang term order regarding the key field so that the return values from functions such as &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;match_object&lt;/code&gt;, and &lt;code&gt;foldl&lt;/code&gt; are ordered by the key values. Traversing an &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; operations also returns the keys ordered.</source>
          <target state="translated">如果要访问表中的数据，以便表中键的顺序很重要，则可以使用表类型 &lt;code&gt;ordered_set&lt;/code&gt; 代替更常用的 &lt;code&gt;set&lt;/code&gt; 表类型。一个 &lt;code&gt;ordered_set&lt;/code&gt; 始终贯穿在Erlang项顺序有关的关键领域，以便从功能，如返回值 &lt;code&gt;select&lt;/code&gt; ， &lt;code&gt;match_object&lt;/code&gt; ，并 &lt;code&gt;foldl&lt;/code&gt; 由键值进行排序。使用第 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 操作遍历 &lt;code&gt;ordered_set&lt;/code&gt; 还返回有序的键。</target>
        </trans-unit>
        <trans-unit id="c7cef7dde804ec38da41a38a959068e58669e710" translate="yes" xml:space="preserve">
          <source>If the data is to be sent from the driver to the port owner process, it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要将数据从驱动程序发送到端口所有者进程，则使用 &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="d69f0718531a0dc4b5192097fe34a9a400874115" translate="yes" xml:space="preserve">
          <source>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</source>
          <target state="translated">如果数据库很大,不一定能在线恢复。在这种情况下,通过安装后备程序恢复旧数据库,然后重新启动。</target>
        </trans-unit>
        <trans-unit id="1a465de33f0929289f4ba867f52979d6f1b60be6" translate="yes" xml:space="preserve">
          <source>If the decoded message happens to be received before the connection is established, a new &quot;virtual&quot; connection is established. This is typically the case for the Media Gateway Controller (MGC) upon the first Service Change. When this occurs the following callback function will be invoked:</source>
          <target state="translated">如果在建立连接之前恰好收到了解码信息,则会建立一个新的 &quot;虚拟 &quot;连接。媒体网关控制器(MGC)在第一次服务变更时通常会出现这种情况。当这种情况发生时,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="fbdce8830ddb42e0e285519e4fb52411ce2090fe" translate="yes" xml:space="preserve">
          <source>If the decoded message instead of transactions contains a message error, the following callback function will be invoked:</source>
          <target state="translated">如果解码后的消息而不是事务包含消息错误,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="6be7e8b5958c0936e75a2ab6e68f6fdfd8645d72" translate="yes" xml:space="preserve">
          <source>If the default value is not suitable, the type letter can be followed by &lt;code&gt;=&lt;/code&gt; and a value. Most types take an integer value. The value for an atom is written the same way as in the C source code. For example, the atom &lt;code&gt;false&lt;/code&gt; is written as &lt;code&gt;am_false&lt;/code&gt;. The atom must be listed in &lt;code&gt;atom.names&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05877711912cb7abc7753f9ce969b4440e6bb55" translate="yes" xml:space="preserve">
          <source>If the definitions are identical, the output module keeps only one definition with the original name.</source>
          <target state="translated">如果定义相同,输出模块只保留一个原名的定义。</target>
        </trans-unit>
        <trans-unit id="709eb064721592f0145e0c9870df4b79e36f2fb2" translate="yes" xml:space="preserve">
          <source>If the definitions have the same name and differs in the definition, they are renamed. The new names are the definition name and the original module name concatenated.</source>
          <target state="translated">如果定义的名称相同而定义不同,则重新命名。新的名称是定义名称和原模块名称的组合。</target>
        </trans-unit>
        <trans-unit id="c3055c07c7bca6e36c452534d5a6de3daec9136a" translate="yes" xml:space="preserve">
          <source>If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.</source>
          <target state="translated">如果被删除的条目是一个注册的订阅者,它将意味着订阅者进程得到的是未注册的订阅者,以及它得到它的最终消息。</target>
        </trans-unit>
        <trans-unit id="b7794972861adba2b5114706df92a0c8a22b1b7d" translate="yes" xml:space="preserve">
          <source>If the deleted term (or any part of it) is still used by a process, that process will do a major (fullsweep) garbage collection and copy the term into the process. However, at most two processes at a time will be scheduled to do that kind of garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818e5bafa76101bf732fc51de14593ea48da629f" translate="yes" xml:space="preserve">
          <source>If the destination node would have to be auto-connected to do the send, &lt;code&gt;noconnect&lt;/code&gt; is returned instead.</source>
          <target state="translated">如果必须自动连接目标节点以进行发送， &lt;code&gt;noconnect&lt;/code&gt; 返回noconnect。</target>
        </trans-unit>
        <trans-unit id="fa49b96a6e23a80a21210ac903528ecee8169a93" translate="yes" xml:space="preserve">
          <source>If the directory for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is &lt;code&gt;/etc&lt;/code&gt;, the line in &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is as follows:</source>
          <target state="translated">如果文件 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 的目录是 &lt;code&gt;/etc&lt;/code&gt; ，则 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 中的行如下：</target>
        </trans-unit>
        <trans-unit id="1cfa13bd96270a398f97e146ebd653c8f1622e36" translate="yes" xml:space="preserve">
          <source>If the directory is not found</source>
          <target state="translated">如果没有找到该目录</target>
        </trans-unit>
        <trans-unit id="ee9c7c20028055c752f1006405fb6ac3dd62c654" translate="yes" xml:space="preserve">
          <source>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; is in the path, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</source>
          <target state="translated">如果目录引用存档中的目录，则在返回路径之前，将删除存档名称。例如，如果目录 &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; 在路径中，则 &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; 返回。这意味着应用程序的库目录是相同的，而不管应用程序是否驻留在归档中。</target>
        </trans-unit>
        <trans-unit id="f85643a441c622fdd2576beffc4873deda4e4256" translate="yes" xml:space="preserve">
          <source>If the dirty NIF is expected to be CPU-bound, its &lt;code&gt;flags&lt;/code&gt; field is to be set to &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt;.</source>
          <target state="translated">如果脏NIF预计将与CPU绑定，则将其 &lt;code&gt;flags&lt;/code&gt; 字段设置为 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; 或 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23d292909c9d32167cfb8c2e96fc30eeaf637bf8" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt; stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2ddfd812a9a461d82c50bcdf565e3ca018a4da" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">如果驱动程序出于某种原因希望将驱动程序二进制文件保留在例如静态变量中，则将增加引用计数，并且稍后可以使用 &lt;code&gt;driver_free_binary&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 回调中释放该二进制文件。</target>
        </trans-unit>
        <trans-unit id="a12df4e4fa0309d2f4f4f74b51f81225f4bdeeaf" translate="yes" xml:space="preserve">
          <source>If the driver has option &lt;code&gt;kill_ports&lt;/code&gt; set, or if &lt;code&gt;kill_ports&lt;/code&gt; is specified as an option to this function, all pending ports using this driver are killed when unloading is done by the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. If no port-killing is involved and there are open ports, the unloading is delayed until no more open ports use the driver. If, in this case, another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (or even this user) loads the driver again before the driver is unloaded, the unloading never takes place.</source>
          <target state="translated">如果驱动程序设置了选项 &lt;code&gt;kill_ports&lt;/code&gt; 或将此功能选项指定为 &lt;code&gt;kill_ports&lt;/code&gt; ，则最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 完成卸载时，将杀死使用该驱动程序的所有挂起端口。如果不涉及杀死端口并且有开放端口，则卸载将延迟，直到不再有开放端口使用驱动程序为止。在这种情况下，如果另一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; （甚至该用户）在卸载驱动程序之前再次加载了该驱动程序，则永远不会进行卸载。</target>
        </trans-unit>
        <trans-unit id="fcf785a336b2c213c45577e83eb09e396c7e3eab" translate="yes" xml:space="preserve">
          <source>If the driver is unloaded (not present in the system), error code &lt;code&gt;not_loaded&lt;/code&gt; is returned. Option &lt;code&gt;reload&lt;/code&gt; is intended for when the user has already loaded the driver in advance.</source>
          <target state="translated">如果驱动程序已卸载（系统中不存在），则返回错误代码 &lt;code&gt;not_loaded&lt;/code&gt; 。选项 &lt;code&gt;reload&lt;/code&gt; 适用于用户已预先加载驱动程序的情况。</target>
        </trans-unit>
        <trans-unit id="4d39f81561d0eb5e9555b68509516e98553687c4" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt; erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3e2b2e4d5d486f038ae4047d709485c51ebafd" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果驱动程序要返回数据，则在 &lt;code&gt;rbuf&lt;/code&gt; 中返回它。当 &lt;code&gt;control&lt;/code&gt; 被调用时， &lt;code&gt;*rbuf&lt;/code&gt; 点的默认缓冲 &lt;code&gt;rlen&lt;/code&gt; 字节，其可用于返回数据。根据端口控制标志（使用 &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; 设置的那些标志），返回的数据有所不同。</target>
        </trans-unit>
        <trans-unit id="f299a698f91b18144d2db6873d22e3355371e343" translate="yes" xml:space="preserve">
          <source>If the driver was previously unloaded, but is still present because of open ports to it, a call to &lt;code&gt;load/2&lt;/code&gt; stops the unloading and keeps the driver (as long as &lt;code&gt;Path&lt;/code&gt; is the same), and &lt;code&gt;ok&lt;/code&gt; is returned. If you really want the object code to be reloaded, use &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; or the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead. See also the description of &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; for loading/unloading in the introduction.</source>
          <target state="translated">如果驱动程序以前已卸载，但是由于打开了端口而仍然存在，则对 &lt;code&gt;load/2&lt;/code&gt; 的调用将停止卸载并保留驱动程序（只要 &lt;code&gt;Path&lt;/code&gt; 相同），然后返回 &lt;code&gt;ok&lt;/code&gt; 。如果您确实希望重新加载目标代码，请改用 &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; 或低级接口 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。另请参见引言 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; 有关加载/卸载的不同方案的描述。</target>
        </trans-unit>
        <trans-unit id="73cd90e7e567fcfaa60abf0aba49564831915adf" translate="yes" xml:space="preserve">
          <source>If the edge would create a cycle in an &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; is returned. If &lt;code&gt;G&lt;/code&gt; already has an edge with value &lt;code&gt;E&lt;/code&gt; connecting a different pair of vertices, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; is returned. If either of &lt;code&gt;V1&lt;/code&gt; or &lt;code&gt;V2&lt;/code&gt; is not a vertex of digraph &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt;V&lt;code&gt;}}&lt;/code&gt; is returned, V = &lt;code&gt;V1&lt;/code&gt; or V = &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">如果边缘将在创建周期 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; 返回。如果 &lt;code&gt;G&lt;/code&gt; 已经具有连接另一对顶点的，具有值 &lt;code&gt;E&lt;/code&gt; 的边，则返回 &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; 。如果任一的 &lt;code&gt;V1&lt;/code&gt; 或 &lt;code&gt;V2&lt;/code&gt; 不是有向图的顶点 &lt;code&gt;G&lt;/code&gt; ， &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt; V &lt;code&gt;}}&lt;/code&gt; 被返回，V = &lt;code&gt;V1&lt;/code&gt; 或V = &lt;code&gt;V2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88548b0769c08599153c91bedffecba4076939a2" translate="yes" xml:space="preserve">
          <source>If the emulator detects an internal error (or runs out of memory), it, by default, generates both a crash dump and a core dump. The core dump is, however, not very useful as the content of process heaps is destroyed by the crash dump generation.</source>
          <target state="translated">如果仿真器检测到内部错误(或内存耗尽),默认情况下,它会生成一个崩溃转储和一个核心转储。然而,核心转储并不是很有用,因为进程堆的内容会被崩溃转储的生成所破坏。</target>
        </trans-unit>
        <trans-unit id="1c268e0a4f924dc7fcacea261eaf98d33a0b39dd" translate="yes" xml:space="preserve">
          <source>If the emulator needs to be restarted after upgrading or downgrading, that is, if the ERTS version differs between &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">如果在升级或降级后需要重新启动仿真器，即， &lt;code&gt;Name.rel&lt;/code&gt; 和 &lt;code&gt;Name2.rel&lt;/code&gt; 之间的ERTS版本不同</target>
        </trans-unit>
        <trans-unit id="0e5cf3cf162417b51e0a5af24e5040b612349b1b" translate="yes" xml:space="preserve">
          <source>If the emulator needs to write a crash dump, the value of this variable is the filename of the crash dump file. If the variable is not set, the name of the crash dump file is &lt;code&gt;erl_crash.dump&lt;/code&gt; in the current directory.</source>
          <target state="translated">如果仿真器需要编写故障转储，则此变量的值是故障转储文件的文件名。如果未设置该变量，则故障转储文件的 &lt;code&gt;erl_crash.dump&lt;/code&gt; 在当前目录中为erl_crash.dump。</target>
        </trans-unit>
        <trans-unit id="2eec4c147205e5216572281566e1e6a996fb672c" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt; dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c61683ad15fa177c304fbdf476f8b2479cdc64" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">如果模拟器是在支持 &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt; 程序的情况下构建的，则在线更改调度程序的数量也可以在线更改脏CPU调度程序的数量。例如，如果12个调度程序和6个脏CPU调度程序处于联机状态，并且使用 &lt;code&gt;system_flag/2&lt;/code&gt; 将联机的调度程序数设置为6，则联机的脏CPU调度程序数也会自动减少一半，降至3。同样，联机的肮脏CPU调度程序的数量与联机调度程序的数量成比例地增加。</target>
        </trans-unit>
        <trans-unit id="53196a3c7142e79d1e176b567fb18778d22d10f3" translate="yes" xml:space="preserve">
          <source>If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9353bd702a35793ac18305b8482171f21007231" translate="yes" xml:space="preserve">
          <source>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</source>
          <target state="translated">如果到达模式的终点,则匹配成功,可以检索变量的内容。</target>
        </trans-unit>
        <trans-unit id="ec86b8e10359d9eb0c69eab5270c60f057cce319" translate="yes" xml:space="preserve">
          <source>If the engine is located in the OpenSSL/LibreSSL installation &lt;code&gt;engines&lt;/code&gt; directory.</source>
          <target state="translated">如果引擎位于OpenSSL / LibreSSL安装 &lt;code&gt;engines&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="46c40e2b5cd9693ace2f62de74c9f71bc27ab4c5" translate="yes" xml:space="preserve">
          <source>If the entire log is successfully converted, the function will return &lt;code&gt;ok&lt;/code&gt;. If one of more entries fail to convert, the function will instead return &lt;code&gt;{ok, {NumOK, NumERR}}&lt;/code&gt;, where the counters indicate how many valid and erroneous entries where found. If instead &lt;code&gt;{error, Reason}&lt;/code&gt; is returned, the conversion encountered a fatal error and where either never done of aborted midway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17edef4a35e3cca0ca8935fe0f2de48f9e5dfe47" translate="yes" xml:space="preserve">
          <source>If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.</source>
          <target state="translated">如果该条目是一个新的订阅者,它将意味着新的订阅者进程首先将为每一个已经存储的字典条目获得一条消息,然后它和所有老的订阅者将获得这个特定的条目。收集器进程链接到订阅者进程,然后监督订阅者进程。如果订阅者进程死亡,它将意味着它将像普通的dict_delete/2那样被取消注册。</target>
        </trans-unit>
        <trans-unit id="4d245a9827d109c394220e412fd90299a8b7ff0f" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs instead of a &lt;code&gt;case_clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a094e54489c949e55e10b1bfd099675a9945d8d2" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果对 &lt;code&gt;Exprs&lt;/code&gt; 的评估毫无例外地成功进行，则将模式 &lt;code&gt;Pattern&lt;/code&gt; 与结果按顺序进行匹配（与 &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; 表达式相同），不同的是，如果匹配失败，则会发生 &lt;code&gt;try_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="1729265d2a1b2d02d46f2b13db7a6628cfce7401" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt; add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631031b9e342940aba31e2236569e617b51e7128" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">如果由于调用 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt; 而添加了事件处理程序，则 &lt;code&gt;InitArgs&lt;/code&gt; 是这些函数的 &lt;code&gt;Args&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="72f67e0f506eeca69ed3305947843432edc7a69d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3160cb662d43645579ff66ccf206017473a57cb3" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">如果事件处理程序是由于调用 &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 而被删除的，则 &lt;code&gt;Arg&lt;/code&gt; 是此函数调用的 &lt;code&gt;Args&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="89ab1aecc97fe6f0f9ffea8f0aa54544b441d79d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted later, the event manager sends a message &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; to the calling process. &lt;code&gt;Reason&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果以后删除事件处理程序，则事件管理器将消息 &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; 发送到调用进程。 &lt;code&gt;Reason&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="b5a39103796e2c04d1e2ceb8b092ca0d507d8cca" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a4d7864917b404d52d14fae5596ac8786e5389" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果事件处理程序是由于调用 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 或由于其他回调函数之一的 &lt;code&gt;swap&lt;/code&gt; 返回元组而替换了另一个事件处理程序，则 &lt;code&gt;InitArgs&lt;/code&gt; 是一个元组 &lt;code&gt;{Args,Term}&lt;/code&gt; ，其中 &lt;code&gt;Args&lt;/code&gt; 是函数调用/返回元组和 &lt;code&gt;Term&lt;/code&gt; 中提供的参数是终止旧事件处理程序的结果，请参见 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ce21bfa638e6a6dac050034a055b97270608155" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. However, it detects this state and loses no records that are not overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74a922c6e5b981bbc80b4da38fda2c75c0b1ea" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. It however detects this state and loses no records that are not overwritten.</source>
          <target state="translated">如果将事件日志配置为自动回绕，则丢失到日志并在 &lt;code&gt;nteventlog&lt;/code&gt; 不运行时被覆盖的记录将丢失。但是，它会检测到此状态，并且不会丢失未覆盖的记录。</target>
        </trans-unit>
        <trans-unit id="1781a9137364e9b0633c2b37fb076419c90678b9" translate="yes" xml:space="preserve">
          <source>If the event manager is part of a supervision tree, no stop function is needed. The event manager is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">如果事件管理器是监视树的一部分，则不需要停止功能。事件管理器由其主管自动终止。确切的操作方式由主管中设置的 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="23a26a698f7576e3a5781ee1ace5ea565efded8a" translate="yes" xml:space="preserve">
          <source>If the event manager is successfully created, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the event manager. If a process with the specified &lt;code&gt;EventMgrName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果成功创建了事件管理器，则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是事件管理器的pid。如果具有指定 &lt;code&gt;EventMgrName&lt;/code&gt; 的进程已经存在，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="85c7349696150a1895889e8faf7c4713894d022f" translate="yes" xml:space="preserve">
          <source>If the exclusive decode function has, for example, the name &lt;code&gt;decode_exclusive&lt;/code&gt; and an ASN.1 encoded message &lt;code&gt;Bin&lt;/code&gt; is to be exclusive decoded, the call is as follows:</source>
          <target state="translated">例如，如果排他解码功能具有名称 &lt;code&gt;decode_exclusive&lt;/code&gt; ,并且要对ASN.1编码消息 &lt;code&gt;Bin&lt;/code&gt; 进行排他解码，则调用如下：</target>
        </trans-unit>
        <trans-unit id="03f0f3b2eabafa60c9e9c721aa1cad9fcc5b78a3" translate="yes" xml:space="preserve">
          <source>If the failed test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">如果失败的测试用例属于测试用例组，则第一个参数是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="ae5596ad95475cf2f268aa093acd0a50a12f5551" translate="yes" xml:space="preserve">
          <source>If the file contains source code (as in the example above), it is processed by the &lt;code&gt;epp&lt;/code&gt; preprocessor. This means that you, for example, can use predefined macros (such as &lt;code&gt;?MODULE&lt;/code&gt;) and include directives like the &lt;code&gt;-include_lib&lt;/code&gt; directive. For example, use</source>
          <target state="translated">如果文件包含源代码（如上例所示），则由 &lt;code&gt;epp&lt;/code&gt; 预处理程序对其进行处理。例如，这意味着您可以使用预定义的宏（例如 &lt;code&gt;?MODULE&lt;/code&gt; ）并包含 &lt;code&gt;-include_lib&lt;/code&gt; 指令之类的指令。例如使用</target>
        </trans-unit>
        <trans-unit id="09f7b5f0081b8333cb37ae76ae1513548332cd8c" translate="yes" xml:space="preserve">
          <source>If the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</source>
          <target state="translated">如果文件以二进制模式打开,读取的字节以二进制形式返回,否则以列表形式返回。</target>
        </trans-unit>
        <trans-unit id="d43d376c036cd6704fab6602e0a821d2fca0f536" translate="yes" xml:space="preserve">
          <source>If the file is opened with &lt;code&gt;encoding&lt;/code&gt; set to something else than &lt;code&gt;latin1&lt;/code&gt;, each byte written can result in many bytes being written to the file, as the byte range 0..255 can represent anything between one and four bytes depending on value and UTF encoding type.</source>
          <target state="translated">如果打开的文件的 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 以外的其他值，则写入的每个字节都可能导致将许多字节写入文件，因为字节范围0..255可以表示一到四个字节之间的任意值，具体取决于值和UTF编码类型。</target>
        </trans-unit>
        <trans-unit id="3ff2942f4038fb71563badd19ea96ee04bc36590" translate="yes" xml:space="preserve">
          <source>If the file is read past &lt;code&gt;eof&lt;/code&gt;, only the remaining bytes are read and returned. If no bytes are read, &lt;code&gt;eof&lt;/code&gt; is returned.</source>
          <target state="translated">如果通过 &lt;code&gt;eof&lt;/code&gt; 读取了文件，则仅读取并返回剩余的字节。如果未读取任何字节，则返回 &lt;code&gt;eof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0301143503899c06f595e73d4da8e12a605f082d" translate="yes" xml:space="preserve">
          <source>If the file is specified as an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, no file is read or monitored in the future. This emulates the old behavior of not configuring the DNS client when the node is started in short name distributed mode.</source>
          <target state="translated">如果文件指定为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，则以后不会读取或监视文件。这模仿了以短名称分布式模式启动节点时不配置DNS客户端的旧行为。</target>
        </trans-unit>
        <trans-unit id="f524572ea2342154f69f71b644500e15cc9901dc" translate="yes" xml:space="preserve">
          <source>If the file server of this node is not a slave, the file was opened by the file server of this node (this implies that &lt;code&gt;Pid&lt;/code&gt; must be a local pid) and the file is not closed. &lt;code&gt;Filename&lt;/code&gt; is the filename in flat string format.</source>
          <target state="translated">如果此节点的文件服务器不是从服务器，则该节点的文件服务器已打开文件（这意味着 &lt;code&gt;Pid&lt;/code&gt; 必须是本地pid），并且文件未关闭。 &lt;code&gt;Filename&lt;/code&gt; 是平面字符串格式的文件名。</target>
        </trans-unit>
        <trans-unit id="19dad8b9ff6393c913546c9bff544a5e8d858493" translate="yes" xml:space="preserve">
          <source>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary is shorter than the number of bytes requested if end of file was reached.</source>
          <target state="translated">如果文件以二进制模式打开,读取的字节以二进制形式返回,否则以列表形式返回。列表或二进制比文件结束时要求的字节数要短。</target>
        </trans-unit>
        <trans-unit id="ead416d9e5e17b9f14938d13eb799b54c7ee7032" translate="yes" xml:space="preserve">
          <source>If the file write fails (for example, &lt;code&gt;enospc&lt;/code&gt;), the command is aborted and &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; is returned. However, the file is &lt;strong&gt;not&lt;/strong&gt; removed.</source>
          <target state="translated">如果文件写入失败（例如 &lt;code&gt;enospc&lt;/code&gt; ），该命令将中止，并返回 &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; 。但是，&lt;strong&gt;不会&lt;/strong&gt;删除该文件。</target>
        </trans-unit>
        <trans-unit id="3f0c09a69dc8ebf1e91578b9796f029369abc850" translate="yes" xml:space="preserve">
          <source>If the filename &lt;code&gt;File&lt;/code&gt; is absolute (possibly after variable substitution), the include file with that name is included. Otherwise, the specified file is searched for in the following directories, and in this order:</source>
          <target state="translated">如果文件名 &lt;code&gt;File&lt;/code&gt; 是绝对文件名（可能在变量替换之后），则包含具有该名称的包含文件。否则，将按照以下顺序在以下目录中搜索指定的文件：</target>
        </trans-unit>
        <trans-unit id="f6fdb5791718e9cf14d2a9c0a809646872e636fd" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, decide if the event is allowed or not.</source>
          <target state="translated">如果过滤器不匹配，则返回 &lt;code&gt;ignore&lt;/code&gt; ，这意味着其他过滤器或配置参数 &lt;code&gt;filter_default&lt;/code&gt; 的值决定是否允许该事件。</target>
        </trans-unit>
        <trans-unit id="298fc01aae2302d31a30ab2828690b737a94df8b" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, will decide if the event is allowed or not.</source>
          <target state="translated">如果过滤器不匹配，则返回 &lt;code&gt;ignore&lt;/code&gt; ，这意味着其他过滤器或配置参数 &lt;code&gt;filter_default&lt;/code&gt; 的值将决定是否允许该事件。</target>
        </trans-unit>
        <trans-unit id="3e713bc836d6d924cbd200c2e55ce5f9136754b5" translate="yes" xml:space="preserve">
          <source>If the filter function returns &lt;code&gt;ignore&lt;/code&gt;, it means that it did not recognize the log event, and thus leaves to other filters to decide the event's destiny.</source>
          <target state="translated">如果过滤器函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则意味着它无法识别日志事件，因此留给其他过滤器来决定事件的命运。</target>
        </trans-unit>
        <trans-unit id="957041343c23aa2d4654805ac48c48dc4fb915f8" translate="yes" xml:space="preserve">
          <source>If the filter has the form &lt;code&gt;{Key, RegExp, re}&lt;/code&gt;, the report must contain an element with key equal to &lt;code&gt;Key&lt;/code&gt; and the value must match the regular expression &lt;code&gt;RegExp&lt;/code&gt;.</source>
          <target state="translated">如果过滤器的格式为 &lt;code&gt;{Key, RegExp, re}&lt;/code&gt; ，则报告必须包含一个键值等于 &lt;code&gt;Key&lt;/code&gt; 的元素，并且该值必须与正则表达式 &lt;code&gt;RegExp&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6e1184361ce4e087a6b4dd8211b45d80ed4f9e48" translate="yes" xml:space="preserve">
          <source>If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the log event is allowed. If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the log event is stopped.</source>
          <target state="translated">如果过滤器匹配且 &lt;code&gt;Action&lt;/code&gt; 为 &lt;code&gt;log&lt;/code&gt; ，则允许日志事件。如果过滤器匹配且 &lt;code&gt;Action&lt;/code&gt; 为 &lt;code&gt;stop&lt;/code&gt; ，则日志事件停止。</target>
        </trans-unit>
        <trans-unit id="32e9da768719e8b90b1faba156fc380cf35dffea" translate="yes" xml:space="preserve">
          <source>If the final string is too long, it is truncated according to the value of configuration parameter &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果最后一个字符串太长，则会根据配置参数 &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; 的值将其截断。</target>
        </trans-unit>
        <trans-unit id="42b76af1133577086d028a4fb0a1a30d07e3d9f8" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt; erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ebf0a745164970b389f3300cbccd27f4b3b5d3" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">如果该标志设置为 &lt;code&gt;0&lt;/code&gt; ，则数据以整数列表形式返回。使用默认缓冲区或设置 &lt;code&gt;*rbuf&lt;/code&gt; 指向使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; 分配的更大缓冲区。 &lt;code&gt;control&lt;/code&gt; 返回后，缓冲区将自动释放。</target>
        </trans-unit>
        <trans-unit id="8c08f7138ffb7c0800eaee0ee64686780f8678ed" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt; erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt; erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt; erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdf06cbeca702cf9635bd5a2282dbe52c9f9489" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">如果该标志设置为 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; ，则返回一个二进制文件。通过将原始数据写入默认缓冲区，可以返回小型二进制文件。还可以通过将 &lt;code&gt;*rbuf&lt;/code&gt; 设置为指向 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 分配的二进制文件来返回二进制文件。 &lt;code&gt;control&lt;/code&gt; 返回后，此二进制文件将自动释放。驱动程序可以使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 保留二进制文件以进行&lt;strong&gt;只读&lt;/strong&gt;访问，稍后再使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; 释放该二进制文件。 &lt;code&gt;control&lt;/code&gt; 返回后，绝对不允许更改二进制文件。如果 &lt;code&gt;*rbuf&lt;/code&gt; 设置为 &lt;code&gt;NULL&lt;/code&gt; ，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="ba4d8831063581aeb6c792a1b032f97e23a799b0" translate="yes" xml:space="preserve">
          <source>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</source>
          <target state="translated">如果将以下模式应用于非以 &quot;a &quot;或 &quot;b &quot;开头的字符串,它通常会匹配主题开头的空字符串。</target>
        </trans-unit>
        <trans-unit id="f145ecc5627d0896817e500b5d377db659310775" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt; check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2009a1faa40085a7c2fd996ec540bc12d65d8f07" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">如果格式化程序模块导出了可选的回调函数 &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt; ，则在设置或修改格式化程序信息时，Logger会调用此函数，以验证格式化程序配置的有效性。</target>
        </trans-unit>
        <trans-unit id="05f7a6a810b002e4a0681949501258c2a927f78c" translate="yes" xml:space="preserve">
          <source>If the fragment option is &lt;code&gt;true&lt;/code&gt;, the URI fragment is returned as part of the parsing result, otherwise it is ignored.</source>
          <target state="translated">如果fragment选项为 &lt;code&gt;true&lt;/code&gt; ，则将URI片段作为解析结果的一部分返回，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="a9f39219b3544f3ad6a57e7c4b45e2e83b08a49c" translate="yes" xml:space="preserve">
          <source>If the fully connected network is not set up properly, try first to increase the value of &lt;code&gt;net_setuptime&lt;/code&gt;.</source>
          <target state="translated">如果未正确设置完全连接的网络，请首先尝试增加 &lt;code&gt;net_setuptime&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e9be0c3ab255377067e7c9ca15639a8fa64c8dbb" translate="yes" xml:space="preserve">
          <source>If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">如果使用fun/3,则在实际认证发生时被调用,因此可能返回动态数据,如时间、远程ip等。</target>
        </trans-unit>
        <trans-unit id="1a6e0071d7a3ba398410b3a04cc87132cfab9e23" translate="yes" xml:space="preserve">
          <source>If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10d9917bf561ed6546055b4ad6ae668ede9a486" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;mnesia:table_info/2&lt;/code&gt; is started in the activity context of module &lt;code&gt;mnesia_frag&lt;/code&gt;, information of several new items can be obtained:</source>
          <target state="translated">如果在模块 &lt;code&gt;mnesia_frag&lt;/code&gt; 的活动上下文中启动功能 &lt;code&gt;mnesia:table_info/2&lt;/code&gt; ,则可以获得以下几个新项的信息：</target>
        </trans-unit>
        <trans-unit id="b7b2e6d233f123be817d60a836703d289792c0af" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;print_name/1&lt;/code&gt;, and so on, had been interface functions, the situation would have been different, as you do not want the user of the interface to know about the internal data representation.</source>
          <target state="translated">如果函数 &lt;code&gt;print_name/1&lt;/code&gt; 等是接口函数，则情况将有所不同，因为您不希望接口的用户知道内部数据表示形式。</target>
        </trans-unit>
        <trans-unit id="ac91618962c7d06d3c9f00caac895bd89a410ca3" translate="yes" xml:space="preserve">
          <source>If the function is called, it will be called again with &lt;code&gt;undo&lt;/code&gt;, or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">如果调用了该函数，则将使用 &lt;code&gt;undo&lt;/code&gt; 或以 &lt;code&gt;set&lt;/code&gt; 作为第一个参数再次调用它。</target>
        </trans-unit>
        <trans-unit id="40c262c2c2a844d0cf26a7433449f15feea3fd0e" translate="yes" xml:space="preserve">
          <source>If the function is found, the function clauses are scanned sequentially until a clause is found that fulfills both of the following two conditions:</source>
          <target state="translated">如果找到函数,则依次扫描函数子句,直到找到满足以下两个条件的子句。</target>
        </trans-unit>
        <trans-unit id="c5c83cab902e2b61262a72c526eeaa77228c4460" translate="yes" xml:space="preserve">
          <source>If the function is rewritten as follows, the compiler is free to rearrange the clauses:</source>
          <target state="translated">如果将函数重写如下,编译器可以自由地重新排列子句。</target>
        </trans-unit>
        <trans-unit id="b63119293c0f8660be248a19b2479210b58e3c5a" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;ignore&lt;/code&gt;, then it is assumed that either:</source>
          <target state="translated">如果该函数返回 &lt;code&gt;ignore&lt;/code&gt; ，则假定：</target>
        </trans-unit>
        <trans-unit id="d3d840a1e8e533a047b65414d5bcef0d60c4bcbd" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{cancel, Reason}&lt;/code&gt;, this means the transport module decided not to send the message. This is &lt;strong&gt;not&lt;/strong&gt; an error. No error messages will be issued and no error counters incremented. What actions this will result in depends on what kind of message was sent.</source>
          <target state="translated">如果函数返回 &lt;code&gt;{cancel, Reason}&lt;/code&gt; ，则意味着传输模块决定不发送消息。这&lt;strong&gt;不是&lt;/strong&gt;错误。将不会发出错误消息，并且不会增加错误计数器。这将导致什么动作取决于所发送的消息类型。</target>
        </trans-unit>
        <trans-unit id="7fa5ac3ae4df99fa5b9b2dd8db96506aecf3fefc" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release.</source>
          <target state="translated">如果函数返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ，则正在进行的升级将失败并回滚到旧版本。</target>
        </trans-unit>
        <trans-unit id="cace8ed5fbcae8411e61d141c38b3af395942b38" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; can not be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">如果该函数返回失败 &lt;code&gt;Reason&lt;/code&gt; ，则正在进行的升级将失败并回滚到旧版本。请注意， &lt;code&gt;Reason&lt;/code&gt; 不能是 &lt;code&gt;{ok,_,_}&lt;/code&gt; 元组，因为它将被视为 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 元组，并且与 &lt;code&gt;{ok,_}&lt;/code&gt; 匹配的元组也是无效的 &lt;code&gt;Reason&lt;/code&gt; 原因。建议将原子用作&amp;ldquo; &lt;code&gt;Reason&lt;/code&gt; 因为它将被包裹在 &lt;code&gt;{error,Reason}&lt;/code&gt; 元组中。</target>
        </trans-unit>
        <trans-unit id="c37aef2f6cca5a5ce8aa9a711a7c69aab7ee274a" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; cannot be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b279a0456aa090aac1cc8d9973e0efdd61b891" translate="yes" xml:space="preserve">
          <source>If the function returns anything else, the test case is considered successful. The return value always gets printed in the test case log file.</source>
          <target state="translated">如果函数返回任何其他值,则认为测试用例成功。返回值总是被打印在测试用例的日志文件中。</target>
        </trans-unit>
        <trans-unit id="f7a01fb7804d1dc8b9d59f7e2487cb33130c4689" translate="yes" xml:space="preserve">
          <source>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</source>
          <target state="translated">如果一个长期运行的NIF的功能可以拆分,使其工作可以通过一系列较短的NIF调用来实现,那么应用程序有两种选择。</target>
        </trans-unit>
        <trans-unit id="ba5aec2652bfb4fd0698f0092b5faec8c5e7749c" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;ebin&lt;/code&gt;, modules (BEAM files) are searched for in that directory, otherwise modules are searched for in the given directory.</source>
          <target state="translated">如果给定目录具有名为 &lt;code&gt;ebin&lt;/code&gt; 的子目录，则在该目录中搜索模块（BEAM文件），否则在给定目录中搜​​索模块。</target>
        </trans-unit>
        <trans-unit id="206b9b6e0e97d510493a5ac088ad8e22427aae29" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;lib&lt;/code&gt;, the directories in that directory are assumed to be application directories, otherwise all subdirectories of the given directory are assumed to be application directories. If there are several versions of some application, the one with the highest version is chosen.</source>
          <target state="translated">如果给定目录具有名为 &lt;code&gt;lib&lt;/code&gt; 的子目录，则假定该目录中的目录为应用程序目录，否则，假定给定目录的所有子目录均为应用程序目录。如果某个应用程序有多个版本，则选择具有最高版本的应用程序。</target>
        </trans-unit>
        <trans-unit id="33fb4bc732c4bac52e2f3ecc8dc02b6458e5f64a" translate="yes" xml:space="preserve">
          <source>If the global name server fails to connect nodes (&lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; in the Erlang shell), but it indicates a network problem.</source>
          <target state="translated">如果全局名称服务器无法连接节点（在示例中为 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N3&lt;/code&gt; ），则会将警告事件发送到错误记录器。此类事件的存在并不排除以后要连接的节点（例如，您可以在Erlang Shell中尝试命令 &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; ），但它指示网络问题。</target>
        </trans-unit>
        <trans-unit id="90420c92850a1634589e73fa3152ae2df519947e" translate="yes" xml:space="preserve">
          <source>If the guard test &lt;code&gt;is_integer(Int)&lt;/code&gt; succeeds, the fourth clause is executed.</source>
          <target state="translated">如果防护测试 &lt;code&gt;is_integer(Int)&lt;/code&gt; 成功，则执行第四个子句。</target>
        </trans-unit>
        <trans-unit id="51156ed0f0b60bdec0db2a3c5c342e77e9337761" translate="yes" xml:space="preserve">
          <source>If the guard test fails, the input value is compared to &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, and the appropriate clause is selected. (There is a &lt;code&gt;function_clause&lt;/code&gt; exception if none of the values matched.)</source>
          <target state="translated">如果保护测试失败，则输入值与 &lt;code&gt;four&lt;/code&gt; ， &lt;code&gt;five&lt;/code&gt; ，和 &lt;code&gt;six&lt;/code&gt; ，并且选择适当的子句。（如果两个值都不匹配，则存在 &lt;code&gt;function_clause&lt;/code&gt; 异常。）</target>
        </trans-unit>
        <trans-unit id="042ae23e884f62c0355d18895948d09799091a5c" translate="yes" xml:space="preserve">
          <source>If the handler is meant to replace the default handler, the Kernel's default handler have to be disabled before the new handler is added. A &lt;code&gt;sys.config&lt;/code&gt; file that disables the Kernel handler and adds a custom handler could look like this:</source>
          <target state="translated">如果要使用处理程序替换默认处理程序，则必须在添加新处理程序之前禁用内核的默认处理程序。禁用内核处理程序并添加自定义处理程序的 &lt;code&gt;sys.config&lt;/code&gt; 文件可能如下所示：</target>
        </trans-unit>
        <trans-unit id="65f1827df55837b13a3b7ed59d4d8ea4a1983d32" translate="yes" xml:space="preserve">
          <source>If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value &lt;code&gt;infinity&lt;/code&gt; prevents restarts.</source>
          <target state="translated">如果处理程序终止，则它会在指定的延迟（以毫秒为单位）后自动重新启动。值 &lt;code&gt;infinity&lt;/code&gt; 可防止重新启动。</target>
        </trans-unit>
        <trans-unit id="b7ef0ec4d5b98a48302f9d89b544d31dce7e98f5" translate="yes" xml:space="preserve">
          <source>If the handler process is terminated because of overload, it prints information about it in the log. It also prints information about when a restart has taken place, and the handler is back in action.</source>
          <target state="translated">如果处理程序因为过载而终止,它就在日志中打印相关信息。它还会打印关于何时重新启动和处理程序恢复运行的信息。</target>
        </trans-unit>
        <trans-unit id="71ca4e1b2a57423c539bf11275ee92c1598c8e04" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to listen on.</source>
          <target state="translated">如果主机有很多网络接口,这个选项可以指定监听哪一个。</target>
        </trans-unit>
        <trans-unit id="5938c2bcb45adfa6db096780d07c1f69ca15570f" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to use.</source>
          <target state="translated">如果主机有很多网络接口,这个选项可以指定使用哪一个。</target>
        </trans-unit>
        <trans-unit id="7a3654ae9fae9da43a3b1501da91842a28524e6b" translate="yes" xml:space="preserve">
          <source>If the included application itself contains included applications, instead the &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; option must be included.</source>
          <target state="translated">如果包含的应用程序本身包含包含的应用程序，则必须包含 &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="93280124390abf78f821c80eb86f0bf50631ec9d" translate="yes" xml:space="preserve">
          <source>If the initial call is to one of the system-defined behaviors such as &lt;code&gt;gen_server&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;, it is translated to more useful information. If a &lt;code&gt;gen_server&lt;/code&gt; is spawned, the returned &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Function&lt;/code&gt; is &lt;code&gt;init&lt;/code&gt; (the function that initiates the new server).</source>
          <target state="translated">如果初始调用是针对系统定义的行为之一，例如 &lt;code&gt;gen_server&lt;/code&gt; 或 &lt;code&gt;gen_event&lt;/code&gt; ，它将被转换为更多有用的信息。如果生成了 &lt;code&gt;gen_server&lt;/code&gt; ，则返回的 &lt;code&gt;Module&lt;/code&gt; 是回调模块的名称， &lt;code&gt;Function&lt;/code&gt; 是 &lt;code&gt;init&lt;/code&gt; （启动新服务器的函数）。</target>
        </trans-unit>
        <trans-unit id="e36a8cae40a2ccda598cbf83afe268a5c720aa0e" translate="yes" xml:space="preserve">
          <source>If the initial encode of the outgoing request fails, then the request process fails and &lt;code&gt;{error,encode}&lt;/code&gt; is returned.</source>
          <target state="translated">如果传出请求的初始编码失败，则请求过程失败，并返回 &lt;code&gt;{error,encode}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512a1cbc51d5459f85caaea2fd4bfade04f37668" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">如果初始化失败，则函数将返回 &lt;code&gt;{error,Error}&lt;/code&gt; （其中 &lt;code&gt;Error&lt;/code&gt; 是任何术语）或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4efffcc1b527bd1b225e810cb600a2ae77401619" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{stop,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">如果初始化失败，则函数将返回 &lt;code&gt;{stop,Reason}&lt;/code&gt; （其中 &lt;code&gt;Reason&lt;/code&gt; 是任何术语）或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9346621e797dd1360944a672ab82ead28612c984" translate="yes" xml:space="preserve">
          <source>If the initialization is successful, the function is to return &lt;code&gt;{ok,State}&lt;/code&gt;, &lt;code&gt;{ok,State,Timeout}&lt;/code&gt;, or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">如果初始化成功，则函数将返回 &lt;code&gt;{ok,State}&lt;/code&gt; ， &lt;code&gt;{ok,State,Timeout}&lt;/code&gt; 或 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 进程的内部状态。</target>
        </trans-unit>
        <trans-unit id="fc28d6116f22c2a3f33906970ce46ac4053da35d" translate="yes" xml:space="preserve">
          <source>If the input encoding is not UTF-8, an error tuple is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddc615bd88d8608ab31b9841323633dc12870aa" translate="yes" xml:space="preserve">
          <source>If the installation fails, the system can be rebooted. The old release version is then automatically used.</source>
          <target state="translated">如果安装失败,可以重新启动系统。然后自动使用旧版本。</target>
        </trans-unit>
        <trans-unit id="c0e9d4940ae270a2841d572606f563a099b85e09" translate="yes" xml:space="preserve">
          <source>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</source>
          <target state="translated">如果安装成功,新的版本将成为默认版本,如果系统重启,将使用该版本。</target>
        </trans-unit>
        <trans-unit id="08dbb0e86d47275a0a4e636be8892780b15448e3" translate="yes" xml:space="preserve">
          <source>If the instruction appears after instruction &lt;code&gt;point_of_no_return&lt;/code&gt; and the function call fails, the system is restarted.</source>
          <target state="translated">如果指令在 &lt;code&gt;point_of_no_return&lt;/code&gt; 指令之后出现并且函数调用失败，则系统将重新启动。</target>
        </trans-unit>
        <trans-unit id="efab2c6cbaff99e6149cda9413164011c49b633d" translate="yes" xml:space="preserve">
          <source>If the instruction appears before instruction &lt;code&gt;point_of_no_return&lt;/code&gt;, a failure is caught. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; then returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt;, unless &lt;code&gt;{error,Error}&lt;/code&gt; is thrown or returned. Then it returns &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">如果该指令出现在指令 &lt;code&gt;point_of_no_return&lt;/code&gt; 之前，则会捕获失败。 &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; 然后返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; ，除非抛出或返回了 &lt;code&gt;{error,Error}&lt;/code&gt; 。然后返回 &lt;code&gt;{error,Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6accd78db997b4f0cc8c3eb17cc0cfe9969dd581" translate="yes" xml:space="preserve">
          <source>If the instrumentation functions communicate with UNIX processes, it might be a good idea to use a special sub-agent. This sub-agent sends the SNMP request to the other process in one packet in order to minimize context switches. For example, if a whole MIB is implemented on the C level in UNIX, but you still want to use the Erlang SNMP tool, then you may have one special sub-agent, which sends the variables in the request as a single operation down to C.</source>
          <target state="translated">如果仪器仪表功能与 UNIX 进程通信,那么使用一个特殊的子代理可能是个好主意。这个子代理在一个数据包中向另一个进程发送SNMP请求,以减少上下文切换。例如,如果整个MIB是在UNIX的C层上实现的,但你仍然想使用Erlang SNMP工具,那么你可以有一个特殊的子代理,它将请求中的变量作为一个单一的操作下发到C层。</target>
        </trans-unit>
        <trans-unit id="6073ddc2f6ff51455fef10943643ff33d4a41b31" translate="yes" xml:space="preserve">
          <source>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as &lt;code&gt;'_'&lt;/code&gt; or &lt;code&gt;'$1'&lt;/code&gt;, the whole &lt;code&gt;employee&lt;/code&gt; table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt;) if the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果将key属性绑定到模式中，则匹配操作将非常有效。但是，如果将模式中的键属性指定为 &lt;code&gt;'_'&lt;/code&gt; 或 &lt;code&gt;'$1'&lt;/code&gt; ，则必须在整个 &lt;code&gt;employee&lt;/code&gt; 表中搜索匹配的记录。因此，如果表很大，这可能会成为一项耗时的操作，但是如果使用了函数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; ，则可以使用索引（请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt; ）进行补救。</target>
        </trans-unit>
        <trans-unit id="702da889833ee1dc6797c2ff9a6559f2d21f93ff" translate="yes" xml:space="preserve">
          <source>If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large.</source>
          <target state="translated">如果在模式中指定了键,则匹配的效率很高。如果没有指定键,也就是说,如果它是一个变量或下划线,则必须搜索整个表。如果表非常大,搜索时间会非常长。</target>
        </trans-unit>
        <trans-unit id="006f97d543b8ad5e428fa64fac1606142a9e3339" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 绑定，匹配规范应用到使用正确的密钥（或多个）表中的所有对象。如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 是未结合的，匹配规范应用于表中的所有对象， &lt;code&gt;N&lt;/code&gt; 对象的时间，直到达到至少一个对象匹配时，或表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有对象始终都在同一时间处理，这意味着匹配规范可以应用于N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="5b16233e004fe373963364905dc9a2ad762556f0" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 绑定，匹配规范应用于具有仅正确的密钥（或多个）对象。</target>
        </trans-unit>
        <trans-unit id="f90ff4fedc7cf136ced2894c42e307fbd5a5c73b" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">如果的keypos'th元件 &lt;code&gt;MatchSpec&lt;/code&gt; 是未结合的，匹配规范应用于表中的所有对象。如果绑定了第keypos个元素，则将匹配规范仅应用于具有正确密钥的对象。</target>
        </trans-unit>
        <trans-unit id="c802fc2a3fde97f62fdbabfc7b66189e18b5dfc7" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则所有表对象都匹配。如果keypos的元素未绑定，则所有表对象都匹配，一次 &lt;code&gt;N&lt;/code&gt; 个对象，直到至少一个对象匹配或到达表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有匹配对象总是在同一回复中返回，这意味着有时可以返回N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="ee8399b71f2614d1c169eead97f1d70700fb4b6e" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则所有表对象都将匹配。如果keypos的元素未绑定，则所有表对象都匹配，一次 &lt;code&gt;N&lt;/code&gt; 个对象，直到至少一个对象匹配或到达表的末尾。默认值，通过给指示 &lt;code&gt;N&lt;/code&gt; 的值 &lt;code&gt;default&lt;/code&gt; ，就是让对象的数目取决于所述对象的大小。具有相同键的所有对象总是同时匹配，这意味着有时可以匹配N个以上的对象。</target>
        </trans-unit>
        <trans-unit id="81cd44a63c897e4a4fbbf303d633ae129d55b04f" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则仅匹配具有正确键的对象。</target>
        </trans-unit>
        <trans-unit id="519fdb3cbbeb8df2c304203d27f11912d501b21d" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is unbound, all table objects are matched. If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">如果 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素未绑定，则所有表对象都将匹配。如果绑定了 &lt;code&gt;Pattern&lt;/code&gt; 的keypos'th元素，则仅匹配具有正确键的对象。</target>
        </trans-unit>
        <trans-unit id="56e84a693998be360a017f2de3532689d94a7f87" translate="yes" xml:space="preserve">
          <source>If the last expression of a function body is a function call, a &lt;strong&gt;tail recursive&lt;/strong&gt; call is done. This is to ensure that no system resources, for example, call stack, are consumed. This means that an infinite loop can be done if it uses tail-recursive calls.</source>
          <target state="translated">如果函数主体的最后一个表达式是函数调用，则执行&lt;strong&gt;尾递归&lt;/strong&gt;调用。这是为了确保不消耗系统资源，例如调用堆栈。这意味着，如果使用尾递归调用，则可以完成无限循环。</target>
        </trans-unit>
        <trans-unit id="9ae06ba70f228c8b154f39f0df23503609bcb3bd" translate="yes" xml:space="preserve">
          <source>If the length of the message queue grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the messages in the message queue by receiving them in a loop without logging. Client processes waiting for a response from a synchronous log request receive a reply from the handler indicating that the request is dropped. The handler process increases its priority during the flush loop to make sure that no new events are received during the operation. Notice that after the flush operation is performed, the handler prints information in the log about how many events have been deleted.</source>
          <target state="translated">如果消息队列的长度大于这个阈值,就会发生刷新(删除)操作。为了刷新事件,处理程序通过在循环中接收消息队列中的消息而不进行日志记录,从而丢弃这些消息。等待同步日志请求响应的客户端进程会收到处理程序的回复,表示请求被丢弃。处理程序进程在刷新循环中增加其优先级,以确保在操作过程中没有收到新的事件。注意,在执行完刷新操作后,处理程序会在日志中打印出有多少事件被删除的信息。</target>
        </trans-unit>
        <trans-unit id="d10dfdc12d1915667ccceb0a8869e7352174a1a5" translate="yes" xml:space="preserve">
          <source>If the level for &lt;code&gt;mymodule&lt;/code&gt; is now set to &lt;code&gt;debug&lt;/code&gt;, then debug events from this module will be logged by the handler &lt;code&gt;h2&lt;/code&gt;, but not by handler &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;mymodule&lt;/code&gt; 的级别现在设置为 &lt;code&gt;debug&lt;/code&gt; ，则来自该模块的调试事件将由处理程序 &lt;code&gt;h2&lt;/code&gt; 记录，而不由处理程序 &lt;code&gt;h1&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="57aa00c976a435bf8bda5a05ad6230ef4e15342c" translate="yes" xml:space="preserve">
          <source>If the library path is set to &lt;code&gt;code_path&lt;/code&gt;, the set of library modules is not determined, and the &lt;code&gt;info&lt;/code&gt; functions will return empty lists of library modules.</source>
          <target state="translated">如果库路径设置为 &lt;code&gt;code_path&lt;/code&gt; ，则不确定库模块的集合，并且 &lt;code&gt;info&lt;/code&gt; 函数将返回库模块的空列表。</target>
        </trans-unit>
        <trans-unit id="5a12290de86cdc8197c1cbb41227356d8ad7a7f4" translate="yes" xml:space="preserve">
          <source>If the list contains more than one object with &lt;strong&gt;matching&lt;/strong&gt; keys and the table type is &lt;code&gt;set&lt;/code&gt;, one is inserted, which one is not defined. The same holds for table type &lt;code&gt;ordered_set&lt;/code&gt; if the keys &lt;strong&gt;compare equal&lt;/strong&gt;.</source>
          <target state="translated">如果列表包含多个具有&lt;strong&gt;匹配&lt;/strong&gt;键的对象，并且 &lt;code&gt;set&lt;/code&gt; 了表类型，则插入一个，但未定义。如果键&lt;strong&gt;比较相等&lt;/strong&gt;，则表类型 &lt;code&gt;ordered_set&lt;/code&gt; 的情况&lt;strong&gt;相同&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="306fdef74e5ed0763cd6967950f14b6cd849bc3e" translate="yes" xml:space="preserve">
          <source>If the list of applications contains core applications, i.e &lt;code&gt;erts&lt;/code&gt;, &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt; or &lt;code&gt;sasl&lt;/code&gt;, the &lt;code&gt;Install&lt;/code&gt; script in the patched Erlang/OTP installation must be rerun.</source>
          <target state="translated">如果应用程序列表包含核心应用程序，即 &lt;code&gt;erts&lt;/code&gt; ， &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 或 &lt;code&gt;sasl&lt;/code&gt; ，则必须重新运行修补的Erlang / OTP安装中的 &lt;code&gt;Install&lt;/code&gt; 脚本。</target>
        </trans-unit>
        <trans-unit id="e5dc7d4fb91d3eb052a864414f12051609f1bc34" translate="yes" xml:space="preserve">
          <source>If the local implementation of Erlang defines &lt;code&gt;char()&lt;/code&gt; as a subset of &lt;code&gt;integer()&lt;/code&gt;, then &lt;code&gt;is_c_int(Node)&lt;/code&gt; will also yield &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acd485e36998d865f417532aa218ed4f2b0d80e" translate="yes" xml:space="preserve">
          <source>If the local node is part of a global group, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;synced&lt;/code&gt;. If no global groups are defined, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;no_conf&lt;/code&gt;.</source>
          <target state="translated">如果本地节点是全局组的一部分，则 &lt;code&gt;State&lt;/code&gt; 等于 &lt;code&gt;synced&lt;/code&gt; 。如果未定义全局组，则 &lt;code&gt;State&lt;/code&gt; 等于 &lt;code&gt;no_conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3dc78cf933189665aca88d0f65ce3644c34d9ac" translate="yes" xml:space="preserve">
          <source>If the log event is returned, the next filter function is called with the returned value as the first argument. That is, if a filter function modifies the log event, the next filter function receives the modified event. The value returned from the last filter function is the value that the handler callback receives.</source>
          <target state="translated">如果日志事件被返回,下一个过滤函数就会以返回的值作为第一个参数被调用。也就是说,如果一个过滤函数修改了日志事件,下一个过滤函数就会接收修改后的事件。上一个过滤函数返回的值就是处理程序回调接收的值。</target>
        </trans-unit>
        <trans-unit id="d41baef54ef4b512298e69bbec24ae875c8c68a0" translate="yes" xml:space="preserve">
          <source>If the log is blocked by the closing process, the log is also unblocked.</source>
          <target state="translated">如果日志被关闭过程阻塞,日志也会被解封。</target>
        </trans-unit>
        <trans-unit id="8605585ed728deb58354312d2da402db9d75ef1c" translate="yes" xml:space="preserve">
          <source>If the log is local on the current node, &lt;code&gt;Dist&lt;/code&gt; has the value &lt;code&gt;local&lt;/code&gt;, otherwise all nodes where the log is distributed are returned as a list.</source>
          <target state="translated">如果日志在当前节点上是本地的，则 &lt;code&gt;Dist&lt;/code&gt; 的值为 &lt;code&gt;local&lt;/code&gt; ，否则将分发日志的所有节点作为列表返回。</target>
        </trans-unit>
        <trans-unit id="b9bd861272d3ff7a5522d24a3e8060f05d2cf0e7" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments, or directly to a string. See the type definition of &lt;code&gt;&lt;a href=&quot;#type-report_cb&quot;&gt;report_cb()&lt;/a&gt;&lt;/code&gt;, and section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafa7b7f2609edae55f58fdb8dad531885491f7e" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">如果将日志消息指定为 &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;report_cb&lt;/code&gt; 键可以与将报告转换为格式字符串和参数的fun（报告回调）关联。有关报告回调的更多信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="de16ab6d2dd843eaf98a56613e46e210c0e2c90f" translate="yes" xml:space="preserve">
          <source>If the log size is decreased, for example, to save space, function &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; can be used to force the log to wrap.</source>
          <target state="translated">例如，如果减小了日志大小以节省空间，则可以使用函数 &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; 强制对日志进行换行。</target>
        </trans-unit>
        <trans-unit id="720cb0ae706744e4ee9df32b00d37adc564581fe" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined before the &lt;code&gt;merl.hrl&lt;/code&gt; header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions &lt;code&gt;?Q(...) = ...&lt;/code&gt;, case switches using &lt;code&gt;?Q(...)&lt;/code&gt; patterns, and automatic metavariables like &lt;code&gt;_@Tuple&lt;/code&gt; cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the &lt;code&gt;?Q(Text, Map)&lt;/code&gt; macro, e.g.:</source>
          <target state="translated">如果宏 &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; 的之前定义 &lt;code&gt;merl.hrl&lt;/code&gt; 包括头文件，解析变换使用MERL将被禁用，并且在这种情况下，匹配表达式 &lt;code&gt;?Q(...) = ...&lt;/code&gt; ，情况切换使用 &lt;code&gt;?Q(...)&lt;/code&gt; 模式和 &lt;code&gt;_@Tuple&lt;/code&gt; 类的自动元变量无法在您的代码中使用，但是Merl宏和函数仍然有效。要进行元变量替换，您需要使用 &lt;code&gt;?Q(Text, Map)&lt;/code&gt; 宏，例如：</target>
        </trans-unit>
        <trans-unit id="2f7a0ebf63b23efbe71cc89202b72b358a0f129b" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NOASSERT&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果在包含EUnit头文件之前定义了 &lt;code&gt;NOASSERT&lt;/code&gt; 宏，则在禁用测试的情况下，这些宏也无效。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146cb0ce4e92421175ea3746cf274e2455137df9" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NODEBUG&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果在包含EUnit头文件之前定义了宏 &lt;code&gt;NODEBUG&lt;/code&gt; ，则这些宏无效；否则，这些宏将无效。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b5a901ceceb4e69c701bf0dc03c50b6bae11f7b" translate="yes" xml:space="preserve">
          <source>If the manager is not configured to use any particular transport domain, the behaviour &lt;code&gt;handle_agent/4&lt;/code&gt; will for backwards copmpatibility reasons be called with the old &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments</source>
          <target state="translated">如果未将管理器配置为使用任何特定的传输域，则出于向后兼容性的原因，将使用旧的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数调用行为 &lt;code&gt;handle_agent/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6efb33521a71965325da2bbd03e23ab8ae58659" translate="yes" xml:space="preserve">
          <source>If the manager tries to set the same variable many times in the same PDU, the agent is free to improvise. There is no definition which determines if the instrumentation will be called once or twice. If called once only, there is no definition that determines which of the new values is going to be supplied.</source>
          <target state="translated">如果管理者在同一个PDU中多次尝试设置同一个变量,代理人可以自由地随机应变。没有任何定义来决定这个工具是被调用一次还是两次。如果只调用一次,则没有定义决定哪一个新的值将被提供。</target>
        </trans-unit>
        <trans-unit id="74415b1346dd0ddc93d29cb9c0389734be028243" translate="yes" xml:space="preserve">
          <source>If the master node fails, the entire pool exits.</source>
          <target state="translated">如果主节点失效,整个池子就会退出。</target>
        </trans-unit>
        <trans-unit id="ada210019d5db3434b3a98372ed4ed0f124b6d6b" translate="yes" xml:space="preserve">
          <source>If the match specification contains errors, tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">如果匹配规范包含错误，则返回元组 &lt;code&gt;{error, Errors}&lt;/code&gt; ，其中 &lt;code&gt;Errors&lt;/code&gt; 是匹配规范存在问题的自然语言描述的列表。</target>
        </trans-unit>
        <trans-unit id="73520de0bbd30344138b28e89ae6e3ad45ab6a3d" translate="yes" xml:space="preserve">
          <source>If the match specification is executed when selecting objects from an ETS table:</source>
          <target state="translated">如果从ETS表中选择对象时执行匹配规范。</target>
        </trans-unit>
        <trans-unit id="c4b956c127ba515516d186daa8a6509787e44051" translate="yes" xml:space="preserve">
          <source>If the match specification is executing when tracing:</source>
          <target state="translated">如果追踪时匹配规范正在执行。</target>
        </trans-unit>
        <trans-unit id="8673441fb53d8c53d833ea8413d411b45f3c363b" translate="yes" xml:space="preserve">
          <source>If the match specification is syntactically correct, the function either returns &lt;code&gt;{ok,Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">如果匹配规范在语法上是正确的，则该函数将返回 &lt;code&gt;{ok,Result}&lt;/code&gt; ，其中 &lt;code&gt;Result&lt;/code&gt; 是实际 &lt;code&gt;select/2&lt;/code&gt; 调用中的结果，否则返回 &lt;code&gt;false&lt;/code&gt; ,如果匹配规范与对象 &lt;code&gt;Tuple&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="760d740968a06c49ac007f36a245af2196bd1b34" translate="yes" xml:space="preserve">
          <source>If the matching conditions are not met, the match fails, either with:</source>
          <target state="translated">如果不满足匹配条件,则匹配失败,要么用。</target>
        </trans-unit>
        <trans-unit id="1935f33d435bd33bb34072fa05214583d09d6dc0" translate="yes" xml:space="preserve">
          <source>If the matching fails, a &lt;code&gt;badmatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果匹配失败， &lt;code&gt;badmatch&lt;/code&gt; 发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="5e6c9dcffff87aa8aa658e5eae30b4366a1b2bb3" translate="yes" xml:space="preserve">
          <source>If the matching subpart of &lt;code&gt;Subject&lt;/code&gt; giving raise to the replacement is to be inserted in the result, option &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; inserts the matching part into &lt;code&gt;Replacement&lt;/code&gt; at the specified position (or positions) before inserting &lt;code&gt;Replacement&lt;/code&gt; into &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">如果要在结果中插入提供替换的 &lt;code&gt;Subject&lt;/code&gt; 的匹配子部分，则选项 &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; 将匹配的部分插入到 &lt;code&gt;Replacement&lt;/code&gt; 中指定位置（或多个指定位置），然后再将 &lt;code&gt;Replacement&lt;/code&gt; 插入 &lt;code&gt;Subject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdd041679c28a1dfb5c5129e21e191da62b2500c" translate="yes" xml:space="preserve">
          <source>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of &lt;code&gt;Expr2&lt;/code&gt; is returned.</source>
          <target state="translated">如果匹配成功，则模式中任何未绑定的变量都将被绑定，并返回 &lt;code&gt;Expr2&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5059fa619d98d60a3d0f2e7f4484d57de08a27f3" translate="yes" xml:space="preserve">
          <source>If the maximum depth is reached, it cannot be read in the resultant output. Also, the &lt;code&gt;,...&lt;/code&gt; form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</source>
          <target state="translated">如果达到最大深度，则无法在结果输出中读取该深度。此外，元组中的 &lt;code&gt;,...&lt;/code&gt; 表示元组中还有更多元素，但这些元素低于打印深度。</target>
        </trans-unit>
        <trans-unit id="6c939753050268aea10f52760cad514608911137" translate="yes" xml:space="preserve">
          <source>If the message cannot be decoded the following callback function will be invoked:</source>
          <target state="translated">如果消息不能被解码,将调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="fa13ca2255dfd047e4217a3af88a01b044ce4d8d" translate="yes" xml:space="preserve">
          <source>If the message is on report form, it is converted to &lt;code&gt;{Format,Args}&lt;/code&gt; by calling the report callback. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information about report callbacks and valid forms of log messages.</source>
          <target state="translated">如果该消息位于报告表单上，则通过调用报告回调将其转换为 &lt;code&gt;{Format,Args}&lt;/code&gt; 。见 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 内核用户指南中有关报告回调和日志信息的有效形式的更多信息。</target>
        </trans-unit>
        <trans-unit id="c5713a5c2133c11304f85627e2ccde367a7ac635" translate="yes" xml:space="preserve">
          <source>If the minimum repetition is &amp;gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching.</source>
          <target state="translated">如果最小重复次数&amp;gt; 0，则忽略量词。在匹配过程中遇到断言时，仅遵守一次。</target>
        </trans-unit>
        <trans-unit id="5f724a3bd58fe6f9ce42fc406728de7f89ce0ad1" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;m1&lt;/code&gt; is introduced in version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt;, it must also be loaded when upgrading and deleted when downgrading:</source>
          <target state="translated">如果模块 &lt;code&gt;m1&lt;/code&gt; 在 &lt;code&gt;ch_app&lt;/code&gt; 的版本&amp;ldquo; 2&amp;rdquo;中引入，则还必须在升级时加载它，而在降级时删除它：</target>
        </trans-unit>
        <trans-unit id="7aff411ea6299d7bca7ad227ec0e1bc26a882a00" translate="yes" xml:space="preserve">
          <source>If the module cannot be found, &lt;code&gt;non_existing&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到模块，则返回 &lt;code&gt;non_existing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5745afeece7b41ec1bfc061d3b5f18d8e8d1dfba" translate="yes" xml:space="preserve">
          <source>If the module is Cover-compiled, &lt;code&gt;cover_compiled&lt;/code&gt; is returned.</source>
          <target state="translated">如果模块是Cover-compiled，则返回 &lt;code&gt;cover_compiled&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52f516f712d9242bfd152b08a6fd0f4a2793c3fd" translate="yes" xml:space="preserve">
          <source>If the module is loaded, it returns the name of the file containing the loaded object code.</source>
          <target state="translated">如果模块被加载,则返回包含加载对象代码的文件名。</target>
        </trans-unit>
        <trans-unit id="46dba590f6c1f6f800702e68508881918dc97bf9" translate="yes" xml:space="preserve">
          <source>If the module is not loaded, this function searches the code path for the first file containing object code for &lt;code&gt;Module&lt;/code&gt; and returns the absolute filename.</source>
          <target state="translated">如果未加载模块，则此函数在代码路径中搜索包含 &lt;code&gt;Module&lt;/code&gt; 目标代码的第一个文件，并返回绝对文件名。</target>
        </trans-unit>
        <trans-unit id="229acd9737c1671ac97dd505de45081f475b5a4e" translate="yes" xml:space="preserve">
          <source>If the module is preloaded, &lt;code&gt;preloaded&lt;/code&gt; is returned.</source>
          <target state="translated">如果模块已预加载，则返回预 &lt;code&gt;preloaded&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea6cb550bcdaadfe5116319b2dd6e7b241b066a1" translate="yes" xml:space="preserve">
          <source>If the module is successfully Cover compiled, the function returns &lt;code&gt;{ok,Module}&lt;/code&gt;. Otherwise the function returns &lt;code&gt;{error,File}&lt;/code&gt;. Errors and warnings are printed as they occur.</source>
          <target state="translated">如果模块成功Cover编译，则函数返回 &lt;code&gt;{ok,Module}&lt;/code&gt; 。否则，该函数返回 &lt;code&gt;{error,File}&lt;/code&gt; 。错误和警告会在发生时立即打印出来。</target>
        </trans-unit>
        <trans-unit id="1e0a91a6b9e2e2cfbc8f28ae6d3d48928ca8ba21" translate="yes" xml:space="preserve">
          <source>If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; processes. The message is &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt;. The reply to this message is &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt;, where &lt;code&gt;Modules&lt;/code&gt; is a list of the currently active modules in the process.</source>
          <target state="translated">如果用于实现流程的模块在运行时动态更改，则该流程必须再了解一条消息。一个示例是 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 进程。消息是 &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt; 。对此消息的回复是 &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt; ，其中 &lt;code&gt;Modules&lt;/code&gt; 是进程中当前活动模块的列表。</target>
        </trans-unit>
        <trans-unit id="df61dd8b4c6d4d214b129a5077aaee5f7910b304" translate="yes" xml:space="preserve">
          <source>If the name after the prefix and any lift and glob markers is &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, the variable is treated as an anonymous catch-all pattern in matches. For example, &lt;code&gt;_@_&lt;/code&gt;, &lt;code&gt;_@@_&lt;/code&gt;, &lt;code&gt;_@__&lt;/code&gt;, or even &lt;code&gt;_@__@_&lt;/code&gt;.</source>
          <target state="translated">如果前缀后面的名称以及任何提升标记和glob标记之后的名称是 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ，则该变量将被视为匹配项中的匿名全包模式。例如 &lt;code&gt;_@_&lt;/code&gt; ， &lt;code&gt;_@@_&lt;/code&gt; ， &lt;code&gt;_@__&lt;/code&gt; ，甚至 &lt;code&gt;_@__@_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c34344ea584c9364120e1acb56d82e908a1af1b" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_server&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the &lt;code&gt;gen_server&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果省略名称，则不注册 &lt;code&gt;gen_server&lt;/code&gt; 。而是必须使用其pid。名称也可以指定为 &lt;code&gt;{global, Name}&lt;/code&gt; ，在这种情况下， &lt;code&gt;gen_server&lt;/code&gt; 是使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册的。</target>
        </trans-unit>
        <trans-unit id="5f90545e460868142094a7469ef7c519e7a99526" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_statem&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be specified as &lt;code&gt;{global,Name}&lt;/code&gt;, then the &lt;code&gt;gen_statem&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt; in Kernel.</source>
          <target state="translated">如果省略该名称，则不会注册 &lt;code&gt;gen_statem&lt;/code&gt; 。而是必须使用其pid。该名称也可以指定为 &lt;code&gt;{global,Name}&lt;/code&gt; ，然后在内核中使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bce770e9e17197a693d6f9ec8afdca775fdac582" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the event manager is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the event manager is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果省略名称，则不会注册事件管理器。而是必须使用其pid。名称也可以指定为 &lt;code&gt;{global, Name}&lt;/code&gt; ，在这种情况下，将使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 注册事件管理器。</target>
        </trans-unit>
        <trans-unit id="980ec5f2e4cbb3a6bcddf606d02e3f399d751b31" translate="yes" xml:space="preserve">
          <source>If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.</source>
          <target state="translated">如果这类条件中使用的名称是重复的,那么测试就会应用于所有相同名称的子模式,如果其中任何一个子模式已经匹配,那么测试就为真。</target>
        </trans-unit>
        <trans-unit id="15ab8218177de1094fcd225608c4c1ed9bb318cc" translate="yes" xml:space="preserve">
          <source>If the node identified by &lt;code&gt;Node&lt;/code&gt; does not support distributed &lt;code&gt;spawn_monitor()&lt;/code&gt;, the call will fail with a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bffa909b81c50ee39e3329bfdea53c42d35846" translate="yes" xml:space="preserve">
          <source>If the node is distributed, all referenced nodes are visible. Column &lt;strong&gt;Connection type&lt;/strong&gt; shows if the node is visible, hidden, or not connected. Visible nodes are alive nodes with a living connection to the originating node. Hidden nodes are the same as visible nodes, except they are started with flag &lt;code&gt;-hidden&lt;/code&gt;. Not connected nodes are nodes that are not connected to the originating node anymore, but references (that is, process or port identifiers) exist.</source>
          <target state="translated">如果该节点是分布式的，则所有引用的节点都是可见的。列&lt;strong&gt;连接类型&lt;/strong&gt;显示节点是否可见，隐藏或未连接。可见节点是活动节点，与原始节点之间存在活动连接。隐藏节点与可见节点相同，除了它们以flag &lt;code&gt;-hidden&lt;/code&gt; 开头。未连接的节点是不再与原始节点连接的节点，但是存在引用（即，进程或端口标识符）。</target>
        </trans-unit>
        <trans-unit id="9c56f0553bb17f48448269d8c3f6b6f7e5b7e66d" translate="yes" xml:space="preserve">
          <source>If the node is started with command-line flag &lt;code&gt;-sname&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the short name of the host (not the fully qualified domain name). If started with flag &lt;code&gt;-name&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified domain name. For more information, see &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">如果该节点以命令行标志 &lt;code&gt;-sname&lt;/code&gt; 开头，则节点名称为 &lt;code&gt;foobar@Host&lt;/code&gt; ，其中 &lt;code&gt;Host&lt;/code&gt; 是主机的简称（不是完全限定的域名）。如果以flag &lt;code&gt;-name&lt;/code&gt; 开头，则节点名称为 &lt;code&gt;foobar@Host&lt;/code&gt; ，其中 &lt;code&gt;Host&lt;/code&gt; 是标准域名。有关更多信息，请参见 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95b56bcd18c923019bf4643e2b58f9471a6acfb9" translate="yes" xml:space="preserve">
          <source>If the node was not distributed.</source>
          <target state="translated">如果节点没有分布。</target>
        </trans-unit>
        <trans-unit id="aedd11aac41ef6bf71a8b2c8d09b6e7316fb0ef3" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, &lt;code&gt;0&lt;/code&gt; is returned, otherwise &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">如果该节点已成功从EPMD注销，则返回 &lt;code&gt;0&lt;/code&gt; ，否则返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9460cf94d8c06eac24b50547fafb0d6e9b4fd6e1" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, the function returns &lt;code&gt;0&lt;/code&gt;. Otherwise, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">如果已成功从EPMD注销该节点，则该函数返回 &lt;code&gt;0&lt;/code&gt; 。否则，返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d5ac939fb10f304c0c8f3c91721403a64646c5e" translate="yes" xml:space="preserve">
          <source>If the node where the application is running goes down, the application is restarted (after the specified time-out) at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. This is called a &lt;strong&gt;failover&lt;/strong&gt;.</source>
          <target state="translated">如果运行应用程序的节点发生故障，则将在 &lt;code&gt;distributed&lt;/code&gt; 配置参数的节点列表中列出的第一个可操作节点处重新启动应用程序（在指定的超时后）。这称为&lt;strong&gt;故障转移&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d2b0ad4edfef4bb3e88a7ddeeff16d1de18813" translate="yes" xml:space="preserve">
          <source>If the number of arguments are known at compile time, the call is better written as &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt;.</source>
          <target state="translated">如果在编译时知道参数的数量，则最好将调用编写为 &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37c7a476d1b0b827d6493e10ef324cd201488a29" translate="yes" xml:space="preserve">
          <source>If the number of elements in the arguments are known at compile time, the call is better written as &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt;.</source>
          <target state="translated">如果在编译时知道参数中元素的数量，则调用最好写成 &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed56e6304627b8d6f8ad0ab5b8d27fa5330578a8" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt; logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1678d016c144fe15d956c065fed8204d1f4e8c" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">如果首选旧行为，则可以将内核配置参数 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。的 &lt;code&gt;SASL configuration parameters&lt;/code&gt; 然后可被用作前，如果SASL应用程序正在运行的SASL报告只会被打印，通过命名第二日志处理程序 &lt;code&gt;sasl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5231cf8edc57a7fbd05d3b31ba66fb76e90acd0" translate="yes" xml:space="preserve">
          <source>If the operation fails, a bad match error occurs that terminates the test case.</source>
          <target state="translated">如果操作失败,就会发生坏匹配错误,终止测试用例。</target>
        </trans-unit>
        <trans-unit id="279228e8ee1eea55ae3919811a086bb57153efdc" translate="yes" xml:space="preserve">
          <source>If the operation is aborted for whatever reason (e.g. if the socket is closed &quot;by someone else&quot;). The &lt;code&gt;Info&lt;/code&gt; part contains the abort reason (in this case that the socket has been closed &lt;code&gt;Info = {SelectRef, closed}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c8fb74e6d95469ef49c5c6891c58f75c46dd19" translate="yes" xml:space="preserve">
          <source>If the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb00786bd693115a31f9e1bae9c1bd9187b7cb1" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;active&lt;/code&gt; is set to &lt;code&gt;once&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or an integer value, the process owning the sslsocket will receive messages of type &lt;code&gt;&lt;a href=&quot;#type-active_msgs&quot;&gt; active_msgs() &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660ac0936f3ad9df7f0818b651fbd055b3e48bf8" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;anti_replay&lt;/code&gt; is defined in the server, a pair of Bloom filters (&lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;) are used to record incoming ClientHello messages (it is the unique binder value that is actually stored). The &lt;strong&gt;current&lt;/strong&gt; Bloom filter is used for &lt;code&gt;WindowSize&lt;/code&gt; seconds to store new elements. At the end of the time window the Bloom filters are rotated (the &lt;strong&gt;current&lt;/strong&gt; Bloom filter becomes the &lt;strong&gt;old&lt;/strong&gt; and an empty Bloom filter is set as &lt;strong&gt;current&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b40d04fea8544035ae2adb0a45bfab2ddc16f" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned.</source>
          <target state="translated">如果设置了 &lt;code&gt;raw&lt;/code&gt; 选项，则不会调用文件服务器，并且仅返回有关本地文件的信息。</target>
        </trans-unit>
        <trans-unit id="4e75c5ca6851d3d1260e2334b0fd3550965b29e5" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f856775e657213352223a21e03401b4aa2a209" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e127046f0102151c6ef18467d6c0abf9dd2f077" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果设置了 &lt;code&gt;raw&lt;/code&gt; 选项，则不会调用文件服务器，并且仅返回有关本地文件的信息。请注意，这将破坏该模块的原子性保证，因为它可以与并发调用 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt; 竞争</target>
        </trans-unit>
        <trans-unit id="400845971be3dd0decd026d5b02cf869e6e7945b" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;user_dir_fun&lt;/code&gt; is defined, that fun is called and the returned directory is used,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d027da67948b3928fcb8c40cf4bee29a349c9ad" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is proably not what you want.</source>
          <target state="translated">如果选项 &lt;code&gt;verify&lt;/code&gt; 设置为 &lt;code&gt;verify_peer&lt;/code&gt; ，则还应指定选项 &lt;code&gt;server_name_indication&lt;/code&gt; ，如果不是，则不发送服务器名称指示扩展名，并且将使用连接的IP地址作为 &lt;code&gt;ReferenceID&lt;/code&gt; 调用 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; ，可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="8ee4266e447f2d44213209bd3f7598d7638964ff" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is probably not what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f682b6a405b33cd20dc6b87dfbd76f644b7558" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a18e0b35e87dbcf1a9dcdd4db312f82e11bde7" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;{handshake, hello}&lt;/code&gt; 则在收到服务器问候消息后握手将暂停，并且成功响应为 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 而不是 &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 。此后，通过调用 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 来继续或取消握手。</target>
        </trans-unit>
        <trans-unit id="a077df380f70545e70cd306e5e5521ae67d9f379" translate="yes" xml:space="preserve">
          <source>If the option is enabled, and no &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; is present, the user name must present in the &lt;code&gt;&lt;a href=&quot;#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; for the check to succeed but the value of the password is not checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948c45ffdeba267366402b1a519f264bb85a2b52" translate="yes" xml:space="preserve">
          <source>If the option is intended only for a server or for a client, it may be set in this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f7f3873edec45c49aeb8ad204a603fa73eff84" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;allow deny&lt;/code&gt;, the users network address is first controlled to be in the allow subset. If the user network address is not in the allowed subset, the user is denied to get the asset. If the network address is in the allowed subset, a second control is performed. That is, the user network address is not in the subset of network addresses to be denied as specified by parameter &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">如果顺序设置为 &lt;code&gt;allow deny&lt;/code&gt; ，则首先将用户网络地址控制为允许子集。如果用户网络地址不在允许的子集中，则拒绝用户获取资产。如果网络地址在允许的子集中，则执行第二个控制。也就是说，用户网络地址不在参数 &lt;code&gt;deny&lt;/code&gt; 指定的要拒绝的网络地址子集中。</target>
        </trans-unit>
        <trans-unit id="48d8a47c543c2d39d92d2c1d202bacab80c1642d" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;deny allow&lt;/code&gt;, only users from networks specified to be in the allowed subset succeeds to request assets in the limited area.</source>
          <target state="translated">如果将顺序设置为 &lt;code&gt;deny allow&lt;/code&gt; ，则只有指定为允许子集中的网络中的用户才能成功请求限制区域内的资产。</target>
        </trans-unit>
        <trans-unit id="5413791d17ed0b4814f8fb694ad1efb815f76c05" translate="yes" xml:space="preserve">
          <source>If the order of the answers is not important, there is an alternative to the &lt;code&gt;unique&lt;/code&gt; option, namely to sort the answers uniquely:</source>
          <target state="translated">如果答案的顺序不重要，则可以使用 &lt;code&gt;unique&lt;/code&gt; 选项替代方法，即对答案进行唯一排序：</target>
        </trans-unit>
        <trans-unit id="b054305581b7663ed91514b307669add31ca5b5b" translate="yes" xml:space="preserve">
          <source>If the packet does not conform to the protocol format, &lt;code&gt;{error,Reason}&lt;/code&gt; is returned.</source>
          <target state="translated">如果数据包不符合协议格式，则返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2c9f15b9a918cfc529cc22dc69ae62a00c732a6" translate="yes" xml:space="preserve">
          <source>If the page is empty, it means either of the following:</source>
          <target state="translated">如果页面是空的,说明有以下情况之一。</target>
        </trans-unit>
        <trans-unit id="f52fa558245396ce59f0c16eb282e09760e84891" translate="yes" xml:space="preserve">
          <source>If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The module &lt;code&gt;dbg&lt;/code&gt; actually exports a function with this name, but it should never really be called except for when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including the &lt;code&gt;ms_transform.hrl&lt;/code&gt; header file, compiled code will never call the function, but the function call is replaced by a literal match_spec.</source>
          <target state="translated">如果parse_transform不应用于调用此伪函数的模块，则该调用将在运行时失败（带有 &lt;code&gt;badarg&lt;/code&gt; ）。实际上，模块 &lt;code&gt;dbg&lt;/code&gt; 会导出具有该名称的函数，但是除非在shell中使用该函数，否则绝对不要真正调用它。如果 &lt;code&gt;parse_transform&lt;/code&gt; 正确通过包括应用 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 头文件，编译的代码永远不会调用函数，但函数调用由字面match_spec取代。</target>
        </trans-unit>
        <trans-unit id="7c4c35e1fed61f85f87d7154c2244f967d2936c6" translate="yes" xml:space="preserve">
          <source>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</source>
          <target state="translated">如果图案没有锚定,那么就会发生正常的 &quot;bumpalong &quot;前进到下一个起始字符。在到达(*PRUNE)的左边,或者在到达(*PRUNE)之前,或者在匹配到(*PRUNE)的右边时,可以像往常一样发生回溯,但如果右边没有匹配,回溯就不能跨越(*PRUNE)。在简单的情况下,(*PRUNE)的使用只是原子组或占有式量词的替代物,但(*PRUNE)的一些使用是不能用其他方式表达的。在锚定模式中,(*PRUNE)与(*COMMIT)具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="caf53e7076db6e332a206c64cff8afbb0ab34c47" translate="yes" xml:space="preserve">
          <source>If the permission of a loaded, but not started, application is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; but the application is not started until the permission is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果将已加载但未启动的应用程序的许可权设置为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;start&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; ,但直到许可权设置为 &lt;code&gt;true&lt;/code&gt; ，应用程序才启动。</target>
        </trans-unit>
        <trans-unit id="fb5424927d13c1c2f8655ecb9fa4aea52eaa565c" translate="yes" xml:space="preserve">
          <source>If the permission of a running application is set to &lt;code&gt;false&lt;/code&gt;, the application is stopped. If the permission later is set to &lt;code&gt;true&lt;/code&gt;, it is restarted.</source>
          <target state="translated">如果正在运行的应用程序的权限设置为 &lt;code&gt;false&lt;/code&gt; ，则该应用程序将停止。如果稍后将权限设置为 &lt;code&gt;true&lt;/code&gt; ，那么它将重新启动。</target>
        </trans-unit>
        <trans-unit id="1f18562fd499738cfc53fedde95228c6abb3a3c9" translate="yes" xml:space="preserve">
          <source>If the platform implements the IPv4 option &lt;code&gt;IP_PKTOPTIONS&lt;/code&gt;, or the IPv6 option &lt;code&gt;IPV6_PKTOPTIONS&lt;/code&gt; or &lt;code&gt;IPV6_2292PKTOPTIONS&lt;/code&gt; for the socket this value is returned from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; when called with the option name &lt;code&gt;&lt;a href=&quot;#type-option_name&quot;&gt;pktoptions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果port命令中止，则返回 &lt;code&gt;false&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">如果端口驱动程序不支持同步控制操作。</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">如果端口驱动程序出于某种原因而做出决定（可能是 &lt;code&gt;Operation&lt;/code&gt; 或 &lt;code&gt;Data&lt;/code&gt; 出了点问题）。</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">如果端口因某种原因而终止。</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果端口标识的 &lt;code&gt;Port&lt;/code&gt; 未打开，则返回 &lt;code&gt;undefined&lt;/code&gt; 。如果端口是关闭的，并且调用过程先前已链接到该端口，则可以保证在 &lt;code&gt;port_info/2&lt;/code&gt; 返回 &lt;code&gt;undefined&lt;/code&gt; 之前传递该端口的退出信号。</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">如果端口繁忙,则暂停呼叫过程,直到端口不再繁忙。</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">如果端口繁忙,则暂停呼叫过程,直到端口不再繁忙。</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">如果端口程序没有退出就关闭其 &lt;code&gt;stdout&lt;/code&gt; ，则选项 &lt;code&gt;exit_status&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">如果要更新端口程序，则可以使用 &lt;code&gt;code_change&lt;/code&gt; 函数扩展 &lt;code&gt;gen_server&lt;/code&gt; 的代码，该函数将关闭旧端口并打开新端口。（如果需要， &lt;code&gt;gen_server&lt;/code&gt; 可以首先请求必须从端口程序中保存的数据，并将该数据传递到新端口）：</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">如果调用 &lt;code&gt;erlang:resume_process/1&lt;/code&gt; 的进程先前未增加 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程的挂起计数。</target>
        </trans-unit>
        <trans-unit id="9584990023c5a96bcc22ea4479bca2d11aee6db9" translate="yes" xml:space="preserve">
          <source>If the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;Ret = {error, Reason}&lt;/code&gt; will be returned if the calling process traps exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果该进程不存在，则会引发 &lt;code&gt;noproc&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">如果进程在它的消息队列中有任何消息,那么进程就会被立即唤醒,方法和前面描述的一样。</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">如果由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程具有注册名称，则还将包含一个带有 &lt;code&gt;registered_name&lt;/code&gt; 项的 &lt;code&gt;InfoTuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 标识的进程不是现有的本地进程。</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">如果被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程被调用过程挂起的次数多于当前使用的内部数据结构所表示的时间。系统限制是&amp;gt; 2,000,000,000挂起，并且永远不会更低。</target>
        </trans-unit>
        <trans-unit id="036dbfabe540cf1c1a2eb6e8693ac0992c59c911" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is greater than 2,000,000,000 suspends and will never be lower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">如果被 &lt;code&gt;Suspendee&lt;/code&gt; 确定的过程尚未生效。</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程与调用 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的进程相同。</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程是否位于另一个节点上。</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">如果该进程处于活动状态并且指定了单个 &lt;code&gt;Item&lt;/code&gt; ，则返回的值是对应的 &lt;code&gt;InfoTuple&lt;/code&gt; ，除非 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 且该进程没有注册名称。在这种情况下，返回 &lt;code&gt;[]&lt;/code&gt; 。这种奇怪的行为是由于历史原因造成的，并且为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">如果该过程是使用有趣的 &lt;code&gt;StateFun&lt;/code&gt; 替换其状态，则 &lt;code&gt;handle_system_msg&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">如果进程要返回其状态，则 &lt;code&gt;handle_system_msg&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">如果进程或端口已经被注册 (已经有了名字)。</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">如果该进程可能在其队列中获取许多消息，建议您将标志设置为 &lt;code&gt;off_heap&lt;/code&gt; 。这是因为在堆上放置许多消息的垃圾回收可能变得非常昂贵，并且该过程会消耗大量内存。但是，当不使用标志 &lt;code&gt;off_heap&lt;/code&gt; 时，实际消息传递的性能通常会更好。</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">如果该进程由于 &lt;code&gt;normal&lt;/code&gt; 或 &lt;code&gt;shutdown&lt;/code&gt; 以外的其他原因终止，则会生成崩溃报告。有关崩溃报告的更多信息，请参见《 SASL用户指南》。</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">如果使用fun生成了该过程，则 &lt;code&gt;initial_call/1&lt;/code&gt; 不再返回fun，而是实现该fun的本地函数的模块，函数以及arity，例如 &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; （意味着乐趣是在 &lt;code&gt;some_module:work/3&lt;/code&gt; 函数中创建的）。原因是保持乐趣会阻止模块的代码升级，并且可能浪费大量内存。</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">如果程序太大而无法通过 &lt;code&gt;fprof&lt;/code&gt; 或 &lt;code&gt;eprof&lt;/code&gt; 进行概要分析， &lt;code&gt;cprof&lt;/code&gt; 可以使用cprof来定位要使用 &lt;code&gt;fprof&lt;/code&gt; 或 &lt;code&gt;eprof&lt;/code&gt; 进行概要分析的代码部分。</target>
        </trans-unit>
        <trans-unit id="5c014cbf0073f75ddbbd2b83b405b67fe36da992" translate="yes" xml:space="preserve">
          <source>If the provided public key is not found, the authentication fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">如果纯粹的编码/解码性能真的是一个严重的问题,可以使用我们的 erl_dist 编码器,因为 erlang 分发格式的编码/解码速度比所有其他选择快得多。它的主要缺点是还没有被批准为有效的Megaco/H.248信息编码。</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">如果量化符为{0},则在匹配过程中从不服从该断言。但是,它可以包含通过子程序机制从其他地方调用的内部捕获小括号组。</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">如果正则表达式包含捕捉子模式,比如在。</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">如果正则表达式之前已被编译,则选项列表只能包含以下选项。</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">如果正则表达式以前是使用 &lt;code&gt;unicode&lt;/code&gt; 选项编译的，则 &lt;code&gt;Subject&lt;/code&gt; 将作为有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; 提供，否则任何 &lt;code&gt;iodata()&lt;/code&gt; 都可以。如果涉及编译并且指定了 &lt;code&gt;unicode&lt;/code&gt; 选项，则必须将 &lt;code&gt;Subject&lt;/code&gt; 和正则表达式都指定为有效的Unicode &lt;code&gt;charlists()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">如果要升级版本,还必须包括SASL应用。</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">如果发行版软件包包含一个新的Erlang运行时系统，则将指定的运行时系统 &lt;code&gt;{erts,Dir}&lt;/code&gt; 的 &lt;code&gt;bin&lt;/code&gt; 目录复制到 &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="363cb8688a551cced7d3018ac246f3d6efe48af3" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;. Some erts executables are not copied by default, if you want to include all executables you can give the &lt;code&gt;erts_all&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">如果答复在呼叫超时后到达，则没有消息污染呼叫者的消息队列，因为此函数产生一个中间人进程，以充当此类孤立答复的（无效）目的地。此功能还使此功能比呼叫者端的 &lt;code&gt;call/4&lt;/code&gt; 更为昂贵。</target>
        </trans-unit>
        <trans-unit id="97bf926e93bf111383afef246646bb072493b10d" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">如果报表浏览器是脱机使用的，则可以将报表复制到启动浏览器时指定的另一个目录。如果未指定此类目录，则浏览器将从SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; 中读取报告。</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">如果对SFTP通道的请求功能返回 &lt;code&gt;{error, timeout}&lt;/code&gt; ，则在预期时间内未收到来自服务器的答复。</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">如果请求是HTTP / 1.1请求，则URI可以采用绝对URI格式。在这种情况下， &lt;code&gt;httpd&lt;/code&gt; 会将绝对URI保存在此字段中。绝对URI的示例是 &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">如果请求已成功编码和发送，但应答超时，则将发生 &lt;code&gt;handle_error/4&lt;/code&gt; 回调，且 &lt;code&gt;Reason = timeout&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
