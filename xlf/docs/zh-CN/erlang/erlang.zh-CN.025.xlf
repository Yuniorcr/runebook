<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="b159af3f46722bc08fb303932f585dbf455dbca5" translate="yes" xml:space="preserve">
          <source>Handle to a connection to a NETCONF server as returned by &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, or to a session as returned by &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 返回的与NETCONF服务器的连接，或 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt; 返回的会话的连接。</target>
        </trans-unit>
        <trans-unit id="87b5cbd72ade701ab78a0c66eea3cc365bc59eac" translate="yes" xml:space="preserve">
          <source>Handle to the &lt;code&gt;epp&lt;/code&gt; server.</source>
          <target state="translated">处理到 &lt;code&gt;epp&lt;/code&gt; 服务器。</target>
        </trans-unit>
        <trans-unit id="e52aaa094b5e8a1137aac218cd0a979749732ffd" translate="yes" xml:space="preserve">
          <source>Handler Callback Functions</source>
          <target state="translated">处理程序回调函数</target>
        </trans-unit>
        <trans-unit id="200f27a9fd62c17ba568575a28f8cc78a29e0aa9" translate="yes" xml:space="preserve">
          <source>Handler configuration data for Logger. The following default values apply:</source>
          <target state="translated">记录仪的处理程序配置数据。适用以下默认值。</target>
        </trans-unit>
        <trans-unit id="e767bf13ab13407d576b285180deba35039b9c4c" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理程序过滤器通过 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 添加，并通过 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 除去。当使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 添加处理程序时，也可以在配置中直接指定它们，也可以通过内核配置参数 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 来指定它们。</target>
        </trans-unit>
        <trans-unit id="0e4e5ac3ff721d07867e9b05c8337ed55ee393d3" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理程序过滤器通过 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 添加，并通过 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 除去。在使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 添加处理程序时，也可以在配置中直接指定它们，也可以通过内核配置参数 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 来指定它们。</target>
        </trans-unit>
        <trans-unit id="a19df29c14bb59d2df47c78d5601e95477f6e53a" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">在添加处理程序时指定了处理程序过滤器，或者在运行时分别使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 添加或删除了处理程序过滤器。</target>
        </trans-unit>
        <trans-unit id="bfa2c83d2d8b95dd0f46137f7539ec6164e318e2" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">在添加处理程序时指定了处理程序过滤器，或者在运行时分别使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 添加或删除了处理程序过滤器。</target>
        </trans-unit>
        <trans-unit id="f0065b00d67594d8a62cb8fb9796876e1d8da5ac" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">处理程序特定的配置数据由处理程序回调本身插入在与名为 &lt;code&gt;config&lt;/code&gt; 的字段关联的子结构中。</target>
        </trans-unit>
        <trans-unit id="17e94ab879668328c0d7f838700deffb10d37fcd" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages for information about the specifc configuration for these handlers.</source>
          <target state="translated">处理程序特定的配置数据由处理程序回调本身插入在与名为 &lt;code&gt;config&lt;/code&gt; 的字段关联的子结构中。有关这些处理程序的特定配置的信息，请参见 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="e9a11f027cd6db3a106cb106c781e7e6546c3308" translate="yes" xml:space="preserve">
          <source>Handler specific configuration, that is, configuration data related to a specific handler implementation.</source>
          <target state="translated">处理机的具体配置,即与具体处理机实现相关的配置数据。</target>
        </trans-unit>
        <trans-unit id="8dd3565abe30287cdd82dbf04dfe72c3a01322cc" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理可能需要特定服务注意的SSH连接协议消息。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="351ea12c7488865cb104522ed06fb519daaf6841" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理可能需要特定服务注意的SSH连接协议消息。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88c94d64476ed5597f8322dfbff2cf130463d724" translate="yes" xml:space="preserve">
          <source>Handles messages from Erlang. The messages can either be plain data to be sent or more subtle instructions to the driver. This function is here mostly for data pumping.</source>
          <target state="translated">处理来自Erlang的消息。这些消息可以是要发送的纯数据,也可以是给驱动的更细微的指令。这个函数在这里主要用于数据泵送。</target>
        </trans-unit>
        <trans-unit id="921a347faf64cd8a16325d957876e1c04d6d75e2" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">处理通过调用 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 发送的消息</target>
        </trans-unit>
        <trans-unit id="f1b9f0ea31717ef2e1c8cb50a77717454cf70a8b" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;cast/2&lt;/code&gt;.</source>
          <target state="translated">处理通过调用 &lt;code&gt;cast/2&lt;/code&gt; 发送的消息。</target>
        </trans-unit>
        <trans-unit id="26b904f520d22bb388f5046965390b894bfa3594" translate="yes" xml:space="preserve">
          <source>Handles other messages than SSH Connection Protocol, call, or cast messages sent to the channel.</source>
          <target state="translated">处理除SSH连接协议、呼叫或投递消息以外的其他消息,发送至通道。</target>
        </trans-unit>
        <trans-unit id="2fd2edfd14e358bb3197eb296e3226354fa0bcbd" translate="yes" xml:space="preserve">
          <source>Handles storing of scanner information when parsing.</source>
          <target state="translated">在解析时处理扫描仪信息的存储。</target>
        </trans-unit>
        <trans-unit id="9787eca8b55e04c46475fed50a4b8ca6fa155b36" translate="yes" xml:space="preserve">
          <source>Handles the OTP-MIB</source>
          <target state="translated">处理OTP-MIB</target>
        </trans-unit>
        <trans-unit id="a6c4fd9a67f6ff85d671fb367281d35a7948d754" translate="yes" xml:space="preserve">
          <source>Handling any other memory management</source>
          <target state="translated">处理任何其他内存管理</target>
        </trans-unit>
        <trans-unit id="8aef8f3753bae4ea18f0ce0e73cebcd5d20ccb5d" translate="yes" xml:space="preserve">
          <source>Handling instruction with variable number of operands</source>
          <target state="translated">处理操作数可变的指令</target>
        </trans-unit>
        <trans-unit id="b341e45d0db6d71ec15e4a0de6c3934aeec4ccd4" translate="yes" xml:space="preserve">
          <source>Handling of binary data (binaries / bit syntax).</source>
          <target state="translated">二进制数据的处理(二进制/位语法)。</target>
        </trans-unit>
        <trans-unit id="a2823aadf112ce5f5e68f202feabf8215b84b288" translate="yes" xml:space="preserve">
          <source>Handling of configuration files specifying data related to the System Under Test (SUT) (and any other variable data)</source>
          <target state="translated">处理指定与被测系统(SUT)相关数据的配置文件(以及其他变量数据)。</target>
        </trans-unit>
        <trans-unit id="33fefddaf63d1b186bf16cc5d6c16046d15037f4" translate="yes" xml:space="preserve">
          <source>Handshake, interchange node name, and authenticate (2)</source>
          <target state="translated">握手,互换节点名称,并进行身份验证(2</target>
        </trans-unit>
        <trans-unit id="c51f6db8fb76d17c47c7e717ca4c6c5f2b5b4133" translate="yes" xml:space="preserve">
          <source>Handy shortcuts for common tracing settings.</source>
          <target state="translated">常用追踪设置的便捷快捷方式。</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="de7ed76e4bc7658794475e0cb1788bf730fb9c21" translate="yes" xml:space="preserve">
          <source>Hard links are not supported on this platform.</source>
          <target state="translated">本平台不支持硬链接。</target>
        </trans-unit>
        <trans-unit id="e7bcf0ff0ecf672bee67708eac571eebae762e22" translate="yes" xml:space="preserve">
          <source>Hard real-time systems.</source>
          <target state="translated">硬实时系统。</target>
        </trans-unit>
        <trans-unit id="df63d1ff1b01b407251d0ded52b5cebe7b3b5ed8" translate="yes" xml:space="preserve">
          <source>Hardware Watchdog</source>
          <target state="translated">硬件看门狗</target>
        </trans-unit>
        <trans-unit id="65bebc8f73cff6923a62cf86dbdad6dcd9f3de59" translate="yes" xml:space="preserve">
          <source>Hardware memory barriers or memory fences are instructions that can be used to enforce order between memory accesses. Different hardware architectures provide different memory barriers. Lock free algorithms need to use memory barriers in order to ensure that memory accesses are not reordered in such ways that the algorithm breaks down. Memory barriers are also expensive instructions, so you typically want to minimize the use of these instructions.</source>
          <target state="translated">硬件内存屏障或内存栅栏是可以用来强制执行内存访问之间的顺序的指令。不同的硬件架构提供不同的内存壁垒。无锁算法需要使用内存壁垒,以确保内存访问不会被重新排序,以至于算法崩溃。内存屏障也是昂贵的指令,所以你通常要尽量减少这些指令的使用。</target>
        </trans-unit>
        <trans-unit id="f66d0faec5f252a3b8add8ab78a2b77dfef38ca3" translate="yes" xml:space="preserve">
          <source>Hash algorithm to be used for signing the certificate together with the key option. Defaults to sha that is sha1.</source>
          <target state="translated">用来签署证书的哈希算法和密钥选项。默认为 sha,即 sha1。</target>
        </trans-unit>
        <trans-unit id="c1abd7377d4f44f416003defcad46c11c4076434" translate="yes" xml:space="preserve">
          <source>Hash functions - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">哈希函数- &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36646a9df5be6ffe4361209dc14cd9eabb8a54c1" translate="yes" xml:space="preserve">
          <source>Hash tables for Erlang terms (ETS).</source>
          <target state="translated">Erlang术语的哈希表(ETS)。</target>
        </trans-unit>
        <trans-unit id="66d9fc0e303c1db9ac127804366374bdb8ad808d" translate="yes" xml:space="preserve">
          <source>Hashes &lt;code&gt;term&lt;/code&gt; according to the specified &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt;&lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">根据指定的 &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; 哈希 &lt;code&gt;term&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93e30adaf0176847ba666855ceca8fa26f1db0ad" translate="yes" xml:space="preserve">
          <source>Having the source code in UTF-8 also allows you to write string literals, function names, and atoms containing Unicode characters with code points &amp;gt; 255. Module names, application names, and node names are still restricted to the ISO Latin-1 range. Binary literals, where you use type &lt;code&gt;/utf8&lt;/code&gt;, can also be expressed using Unicode characters &amp;gt; 255. Having module names or application names using characters other than 7-bit ASCII can cause trouble on operating systems with inconsistent file naming schemes, and can hurt portability, so it is not recommended.</source>
          <target state="translated">将源代码包含在UTF-8中还可以使您编写字符串文字，函数名称以及包含Unicode字符且代码点大于255的原子。模块名称，应用程序名称和节点名称仍限于ISO Latin-1范围。使用类型 &lt;code&gt;/utf8&lt;/code&gt; 的二进制文字也可以使用&amp;gt; 255的Unicode字符表示。使用非7位ASCII字符的模块名称或应用程序名称可能会在文件命名方案不一致的操作系统上造成麻烦，并可能损害可移植性，因此不建议使用。</target>
        </trans-unit>
        <trans-unit id="9f670bf76875dd0a7bbc3b0854cf6973e8fd4fce" translate="yes" xml:space="preserve">
          <source>Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">必须为少量数字生成额外的随机比特会降低性能。此功能比常规的 &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; 慢约20％</target>
        </trans-unit>
        <trans-unit id="c4449e9b5eb52175eb4e08b8a7330653b852def9" translate="yes" xml:space="preserve">
          <source>Header elements: Module, Author - These commands insert lines on the form &lt;code&gt;-module(&lt;/code&gt;xxx&lt;code&gt;).&lt;/code&gt; and &lt;code&gt;-author('my@home').&lt;/code&gt;. They can be used directly, but are also used as part of the full headers described below.</source>
          <target state="translated">标头元素：模块，作者-这些命令以 &lt;code&gt;-module(&lt;/code&gt; xxx &lt;code&gt;).&lt;/code&gt; 形式插入行。和 &lt;code&gt;-author('my@home').&lt;/code&gt; 。它们可以直接使用，但也可以用作下面描述的完整标题的一部分。</target>
        </trans-unit>
        <trans-unit id="a6fe09edcf76c414cb39902b06a907d362c636fc" translate="yes" xml:space="preserve">
          <source>Header file for configuration data</source>
          <target state="translated">配置数据的头文件</target>
        </trans-unit>
        <trans-unit id="a12c4113e1bb8f1f4886664bda35d4aa27d7be74" translate="yes" xml:space="preserve">
          <source>Heading for a hidden node. A hidden node is the same as a visible node, except that it is started with the &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; flag. States the channel number for the node.</source>
          <target state="translated">前往隐藏节点。隐藏节点与可见节点相同，只是它以 &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; 标志开始。指出节点的通道号。</target>
        </trans-unit>
        <trans-unit id="fed55dc039cca5dcc6f8b46a4f4ace2200d528da" translate="yes" xml:space="preserve">
          <source>Heading for a node that was connected to the crashed node earlier. References (that is, process or port identifiers) to the not connected node existed at the time of the crash. States the channel number for the node.</source>
          <target state="translated">前往之前连接到崩溃节点的节点。崩溃时存在对未连接节点的引用(即进程或端口标识符)。说明该节点的通道号。</target>
        </trans-unit>
        <trans-unit id="952129998156402241d678235a6162ddb355874b" translate="yes" xml:space="preserve">
          <source>Heading for a visible node, that is, an alive node with a connection to the node that crashed. States the channel number for the node.</source>
          <target state="translated">为一个可见的节点,也就是一个活着的节点,与崩溃的节点有连接。说明该节点的通道号。</target>
        </trans-unit>
        <trans-unit id="c243e47447e24ffdd605f179f0a2cab8a40d6b7a" translate="yes" xml:space="preserve">
          <source>Heading.</source>
          <target state="translated">Heading.</target>
        </trans-unit>
        <trans-unit id="4fa5946d7c0314c7ba622549aa822d84deddf1a7" translate="yes" xml:space="preserve">
          <source>Heading. States the module name.</source>
          <target state="translated">标题。说明模块名称。</target>
        </trans-unit>
        <trans-unit id="150c7cf2786a06b4ea8a7aed067ae6ad9d638983" translate="yes" xml:space="preserve">
          <source>Heading. States the process identifier.</source>
          <target state="translated">标题。说明流程标识符。</target>
        </trans-unit>
        <trans-unit id="7145dfcf409c4e094b7363fa76ac09665f29cbd7" translate="yes" xml:space="preserve">
          <source>Heading. States the scheduler identifier.</source>
          <target state="translated">标题。说明调度器的标识。</target>
        </trans-unit>
        <trans-unit id="05a03b6ce3444cc92f49fde9b3239e70eade9242" translate="yes" xml:space="preserve">
          <source>Heading. States the table owner (a process identifier).</source>
          <target state="translated">标题。说明表所有人(流程标识符)。</target>
        </trans-unit>
        <trans-unit id="410899dc76f34f1fabf6ebe98f9e99757d1588a0" translate="yes" xml:space="preserve">
          <source>Heading. States the timer owner (a process identifier), that is, the process to receive the message when the timer expires.</source>
          <target state="translated">标题:说明定时器所有者(进程标识符),即在定时器到期时接收信息的进程。说明定时器的所有者(一个进程标识符),即定时器到期时要接收消息的进程。</target>
        </trans-unit>
        <trans-unit id="c2d66ec52324213cab485604b51c2b78378fa0a7" translate="yes" xml:space="preserve">
          <source>Heap binaries are small binaries, up to 64 bytes, and are stored directly on the process heap. They are copied when the process is garbage-collected and when they are sent as a message. They do not require any special handling by the garbage collector.</source>
          <target state="translated">堆二进制文件是小的二进制文件,最多64字节,直接存储在进程堆上。它们在进程被垃圾回收和作为消息发送时被复制。它们不需要垃圾收集器的任何特殊处理。</target>
        </trans-unit>
        <trans-unit id="21e21ed9381d58c024ca753fbeee40b36f3a6b32" translate="yes" xml:space="preserve">
          <source>Heartbeat interval, in milliseconds</source>
          <target state="translated">心跳间隔,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="4106d21c7ff6614f8b1f5e63e9c6e5e9cdc9e04e" translate="yes" xml:space="preserve">
          <source>Heartbeat monitoring of an Erlang runtime system.</source>
          <target state="translated">Erlang运行时系统的心跳监测。</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="c933a30976c11ef549273b016b878d75f830e3f9" translate="yes" xml:space="preserve">
          <source>HelloRetryRequest</source>
          <target state="translated">HelloRetryRequest</target>
        </trans-unit>
        <trans-unit id="268bfdeda15e6e6a18f731bf9369b4adf0706327" translate="yes" xml:space="preserve">
          <source>Help Menu</source>
          <target state="translated">帮助菜单</target>
        </trans-unit>
        <trans-unit id="d62999fd30064fd05e82c60b2a94d7ce3e73892c" translate="yes" xml:space="preserve">
          <source>Hence, 1996 is a leap year, 1900 is not, but 2000 is.</source>
          <target state="translated">因此,1996年是闰年,1900年不是,但2000年是。</target>
        </trans-unit>
        <trans-unit id="e085c6d848b4c5dcb06ae3d79bc98bb5ed8aaaab" translate="yes" xml:space="preserve">
          <source>Hence, the argument entered as input is doubled as follows:</source>
          <target state="translated">因此,作为输入的参数被加倍,如下所示。</target>
        </trans-unit>
        <trans-unit id="42595144f616321737f8b5e7f141df36f0ea93d3" translate="yes" xml:space="preserve">
          <source>Hence, the previous list comprehension demonstrates the formation of the list &lt;code&gt;E#employee.name&lt;/code&gt; such that &lt;code&gt;E&lt;/code&gt; is taken from the table of employees, and attribute &lt;code&gt;sex&lt;/code&gt; of each record is equal to the atom &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">因此，先前的列表理解说明了列表 &lt;code&gt;E#employee.name&lt;/code&gt; 的形成，这样 &lt;code&gt;E&lt;/code&gt; 是从雇员表中提取的，每个记录的属性 &lt;code&gt;sex&lt;/code&gt; 等于原子 &lt;code&gt;female&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0305883084fd7655771a803404eb6b396bb82e43" translate="yes" xml:space="preserve">
          <source>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt;. Without this configuration parameter set, &lt;code&gt;Mnesia&lt;/code&gt; starts as a single node system. Also, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; can be used to assign a value to &lt;code&gt;extra_db_nodes&lt;/code&gt; and force a connection after &lt;code&gt;Mnesia&lt;/code&gt; has been started, that is, &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt;.</source>
          <target state="translated">因此，当 &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt; 节点需要从网络上的远程节点查找模式定义时，此信息必须通过应用程序参数-mnesia extra_db_nodes NodeList提供。如果没有设置此配置参数， &lt;code&gt;Mnesia&lt;/code&gt; 将作为单节点系统启动。同样，函数 &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; 可以用于将值分配给 &lt;code&gt;extra_db_nodes&lt;/code&gt; 并在 &lt;code&gt;Mnesia&lt;/code&gt; 启动后强制连接，即 &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f9a6ade28837bafcd59b3b5f9e9096aa0c39c5a" translate="yes" xml:space="preserve">
          <source>Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call.</source>
          <target state="translated">这里(?(R)是条件子模式的开始,有递归和非递归两种不同的选择。项(?R)是实际的递归调用。</target>
        </trans-unit>
        <trans-unit id="95eada3e2f0063def4189cbe7e1ac07f33e51ad4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; is the base release and &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; is the release to upgrade to.</source>
          <target state="translated">这里的 &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; 是基本发行版， &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; 是要升级到的发行版。</target>
        </trans-unit>
        <trans-unit id="c3ae7fc887a9fc509a0c94f1f548abf5e88538b2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;+W w&lt;/code&gt; and &lt;code&gt;+R 9&lt;/code&gt; are emulator flags. &lt;code&gt;-s my_init&lt;/code&gt; is an init flag, interpreted by &lt;code&gt;init&lt;/code&gt;. &lt;code&gt;-sname arnie&lt;/code&gt; is a user flag, stored by &lt;code&gt;init&lt;/code&gt;. It is read by Kernel and causes the Erlang runtime system to become distributed. Finally, everything after &lt;code&gt;-extra&lt;/code&gt; (that is, &lt;code&gt;+bertie&lt;/code&gt;) is considered as plain arguments.</source>
          <target state="translated">这里 &lt;code&gt;+W w&lt;/code&gt; 和 &lt;code&gt;+R 9&lt;/code&gt; 是仿真器标志。 &lt;code&gt;-s my_init&lt;/code&gt; 是一个初始化标志，由 &lt;code&gt;init&lt;/code&gt; 解释。 &lt;code&gt;-sname arnie&lt;/code&gt; 是用户标志，由 &lt;code&gt;init&lt;/code&gt; 存储。它由内核读取，并使Erlang运行时系统变得分布式。最后，在一切 &lt;code&gt;-extra&lt;/code&gt; （即 &lt;code&gt;+bertie&lt;/code&gt; ）被认为是普通的参数。</target>
        </trans-unit>
        <trans-unit id="18878a7a47d8170e6d38bdbab2ec1dd97fe93f48" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Binary&lt;/code&gt; is an Erlang binary that contains the encoded data. (If option &lt;code&gt;legacy_erlang_types&lt;/code&gt; has been given, only the binary is returned.)</source>
          <target state="translated">这里的 &lt;code&gt;Binary&lt;/code&gt; 是包含编码数据的Erlang二进制。（如果给出了 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 选项，则仅返回二进制文件。）</target>
        </trans-unit>
        <trans-unit id="37df4c092f43bb499bc403c1f4e4f375ce537f8f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;BytesForOpenType&lt;/code&gt; is a list of bytes constituting the encoding of the &quot;unknown&quot; &lt;code&gt;CHOICE&lt;/code&gt; alternative.</source>
          <target state="translated">此处 &lt;code&gt;BytesForOpenType&lt;/code&gt; 是构成&amp;ldquo;未知&amp;rdquo; &lt;code&gt;CHOICE&lt;/code&gt; 替代编码的字节列表。</target>
        </trans-unit>
        <trans-unit id="46f5f684a77da256af5aa4d76e5b9497068275f5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Fd&lt;/code&gt; was specified to function &lt;code&gt;init/3&lt;/code&gt; as:</source>
          <target state="translated">在这里， &lt;code&gt;Fd&lt;/code&gt; 被指定为函数 &lt;code&gt;init/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="54d075fd5d42e82f879a36d53b74d7b98bbbfc33" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M0&lt;/code&gt; is any map. It follows that &lt;code&gt;M1 .. M4&lt;/code&gt; are maps as well.</source>
          <target state="translated">这里 &lt;code&gt;M0&lt;/code&gt; 是任何地图。因此， &lt;code&gt;M1 .. M4&lt;/code&gt; 也是地图。</target>
        </trans-unit>
        <trans-unit id="5980443888fa1217e79c3bb79e1e66f80464dd29" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map and &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are any expression.</source>
          <target state="translated">这里 &lt;code&gt;M&lt;/code&gt; 是类型映射项，而 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是任何表达式。</target>
        </trans-unit>
        <trans-unit id="b1f20246edf736a721e4d108cf1124970da81a07" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map, &lt;code&gt;V&lt;/code&gt; is an expression and &lt;code&gt;K&lt;/code&gt; is an expression that evaluates to an existing key in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;M&lt;/code&gt; 是类型映射的术语， &lt;code&gt;V&lt;/code&gt; 是表达式，而 &lt;code&gt;K&lt;/code&gt; 是计算结果为 &lt;code&gt;M&lt;/code&gt; 中现有键的表达式。</target>
        </trans-unit>
        <trans-unit id="0698d19c4d4c3905620eb9ca2f7560cc47809caa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt;, with all variables already bound. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">这里 &lt;code&gt;M&lt;/code&gt; 是任何地图。密钥 &lt;code&gt;K&lt;/code&gt; 必须是 &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt; ，并且所有变量都已绑定。 &lt;code&gt;V&lt;/code&gt; 可以是具有绑定变量或未绑定变量的任何模式。</target>
        </trans-unit>
        <trans-unit id="b6105a70c4b87b25ae269fb373351faa4cb7f203" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be an expression with bound variables or literals. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">这里 &lt;code&gt;M&lt;/code&gt; 是任何地图。键 &lt;code&gt;K&lt;/code&gt; 必须是带有绑定变量或文字的表达式。 &lt;code&gt;V&lt;/code&gt; 可以是具有绑定变量或未绑定变量的任何模式。</target>
        </trans-unit>
        <trans-unit id="cfa51aff5e200195c56f9fac50cfa48993ce7499" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the old node.</source>
          <target state="translated">这里的 &lt;code&gt;Node&lt;/code&gt; 是旧节点。</target>
        </trans-unit>
        <trans-unit id="40663b6a0bc17a6c5bb5be7fc0a8ec85eb9e5df4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the terminated node.</source>
          <target state="translated">这里的 &lt;code&gt;Node&lt;/code&gt; 是终止的节点。</target>
        </trans-unit>
        <trans-unit id="3f0cf7c1aa3a9460f5702ed6ce4797a96c09937c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is bound to the value in the first byte of the binary. &lt;code&gt;Sz&lt;/code&gt; is then used at the number of bytes to match out as a binary.</source>
          <target state="translated">在此， &lt;code&gt;Sz&lt;/code&gt; 绑定到二进制文件的第一个字节中的值。然后以字节数使用 &lt;code&gt;Sz&lt;/code&gt; 来匹配二进制数。</target>
        </trans-unit>
        <trans-unit id="3f5a7de11b2a0f9a883784c833a5e64495abf297" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is the combined size of the header and the payload, so we will need to subtract one byte to get the size of the payload.</source>
          <target state="translated">这里 &lt;code&gt;Sz&lt;/code&gt; 是报头和有效负载的总大小，因此我们将需要减去一个字节来获得有效负载的大小。</target>
        </trans-unit>
        <trans-unit id="2aa26917569777b811a459c8edac3b1f6928d1a9" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; gets the value &lt;code&gt;paris&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;&lt;code&gt;{f,28}&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;X&lt;/code&gt; 获得值 &lt;code&gt;paris&lt;/code&gt; ,而 &lt;code&gt;Y&lt;/code&gt; 获得值 &lt;code&gt;{f,28}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0491a2d3210236bc79073f011f175603cf95e651" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;bin&lt;/code&gt; is a driver binary of length at least 50 and &lt;code&gt;drvport&lt;/code&gt; is a port handle. Notice that &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; comes after the elements of the list, likewise &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;bin&lt;/code&gt; 为至少50长度的驱动程序的二进制和 &lt;code&gt;drvport&lt;/code&gt; 是端口句柄。请注意， &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 也位于列表的元素之后， &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03614fcdf5fd8628354c2dc566e6863e0b8468ca" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;format_temps/1&lt;/code&gt; calls &lt;code&gt;convert_list_to_c/1&lt;/code&gt;. &lt;code&gt;convert_list_to_c/1&lt;/code&gt; takes off the head of the &lt;code&gt;List_of_cities&lt;/code&gt;, converts it to Celsius if needed. The | operator is used to add the (maybe) converted to the converted rest of the list:</source>
          <target state="translated">在这里 &lt;code&gt;format_temps/1&lt;/code&gt; 调用 &lt;code&gt;convert_list_to_c/1&lt;/code&gt; 。 &lt;code&gt;convert_list_to_c/1&lt;/code&gt; 离开 &lt;code&gt;List_of_cities&lt;/code&gt; 的头，如果需要，将其转换为摄氏温度。| 运算符用于将转换后的（也许）添加到列表的转换后的其余部分：</target>
        </trans-unit>
        <trans-unit id="0d41f0b5f278025a79f179eb50cbcf1d17def2de" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;kb.example.org&lt;/code&gt; serves any protocol while &lt;code&gt;www.example.org&lt;/code&gt; presents a secure web server.</source>
          <target state="translated">这里 &lt;code&gt;kb.example.org&lt;/code&gt; 提供任何协议，而 &lt;code&gt;www.example.org&lt;/code&gt; 提出了一个安全的Web服务器。</target>
        </trans-unit>
        <trans-unit id="f36f1eb025a53a1dc6cfb7f8014034366d975093" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;pipe_name&lt;/code&gt; defaults to &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt;.</source>
          <target state="translated">此处 &lt;code&gt;pipe_name&lt;/code&gt; 默认为 &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445ee2128dde70c3cdab895146aba251b7587bf5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; the corresponding &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; list passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;watchdog&lt;/code&gt; entry shows the state of a connection's RFC 3539 watchdog state machine. The &lt;code&gt;peer&lt;/code&gt; entry identifies the &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; for which there will have been &lt;code&gt;peer_up/3&lt;/code&gt; callbacks for the Diameter applications identified by the &lt;code&gt;apps&lt;/code&gt; entry, &lt;code&gt;common&lt;/code&gt; being the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;caps&lt;/code&gt; entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The &lt;code&gt;port&lt;/code&gt; entry displays socket-level information about the transport connection. The &lt;code&gt;statistics&lt;/code&gt; entry presents Diameter-level counters, an entry like &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; saying that the client has received 2 DWR messages: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;ref&lt;/code&gt; 是 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; ,并 &lt;code&gt;options&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 的相应的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 列表。该 &lt;code&gt;watchdog&lt;/code&gt; 条目显示连接的RFC 3539看门狗状态机的状态。对 &lt;code&gt;peer&lt;/code&gt; 标识的 &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; 将有由 &lt;code&gt;apps&lt;/code&gt; 项标识的Diameter应用程序的 &lt;code&gt;peer_up/3&lt;/code&gt; 回调， &lt;code&gt;common&lt;/code&gt; 是 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 。该 &lt;code&gt;caps&lt;/code&gt; 该条目标识在能力交换期间由本地节点发送并从对等方接收的能力。该 &lt;code&gt;port&lt;/code&gt; 进入显示套接字级别有关传输连接信息。的 &lt;code&gt;statistics&lt;/code&gt; 条目呈现直径级计数器，像一个条目 &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; 说，客户端已接收DWR 2个信息： &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff06bab188b6989420caf73f4bedde0091d8f752" translate="yes" xml:space="preserve">
          <source>Here a &lt;code&gt;TestDir&lt;/code&gt; can be used to point out the path to a &lt;code&gt;Suite&lt;/code&gt;. Option &lt;code&gt;testcase&lt;/code&gt; corresponds to option &lt;code&gt;-case&lt;/code&gt; in program &lt;code&gt;ct_run&lt;/code&gt;. Configuration files specified in &lt;code&gt;Opts&lt;/code&gt; are installed automatically at startup.</source>
          <target state="translated">在这里，可以使用 &lt;code&gt;TestDir&lt;/code&gt; 指出指向 &lt;code&gt;Suite&lt;/code&gt; 的路径。选择 &lt;code&gt;testcase&lt;/code&gt; 对应选项 &lt;code&gt;-case&lt;/code&gt; 程序 &lt;code&gt;ct_run&lt;/code&gt; 。 &lt;code&gt;Opts&lt;/code&gt; 中指定的配置文件在启动时自动安装。</target>
        </trans-unit>
        <trans-unit id="1d215e0a4d1f50aa10db8d5770d81f093532091e" translate="yes" xml:space="preserve">
          <source>Here a system configuration with an MG and MGC residing in one Erlang node each is outlined:</source>
          <target state="translated">这里概述了一个MG和MGC各驻扎在一个Erlang节点上的系统配置。</target>
        </trans-unit>
        <trans-unit id="98f9cd42bd3f2f651c624dd6456d93b42bb7d908" translate="yes" xml:space="preserve">
          <source>Here also the path to the &lt;code&gt;pea-1.0&lt;/code&gt; ebin directory is provided.</source>
          <target state="translated">这里也提供了 &lt;code&gt;pea-1.0&lt;/code&gt; ebin目录的路径。</target>
        </trans-unit>
        <trans-unit id="37285c244117c11d8428f0cbdceb6d27dd880c01" translate="yes" xml:space="preserve">
          <source>Here are a few suggestions for how to avoid deadlock:</source>
          <target state="translated">以下是关于如何避免僵局的几点建议。</target>
        </trans-unit>
        <trans-unit id="922875c8c4eca4e656e135b3c76a4d89fd7a3552" translate="yes" xml:space="preserve">
          <source>Here are all type letters that are allowed on the left side of a transformation rule.</source>
          <target state="translated">这里是允许在转换规则左侧的所有类型字母。</target>
        </trans-unit>
        <trans-unit id="64246a03dadd5871d19e3c38c5d243139b6de281" translate="yes" xml:space="preserve">
          <source>Here d is any number of decimal digits. However, the value of the setting must be less than the value set by the caller of &lt;code&gt;run/3&lt;/code&gt; for it to have any effect. That is, the pattern writer can lower the limit set by the programmer, but not raise it. If there is more than one setting of one of these limits, the lower value is used.</source>
          <target state="translated">d是任意数量的十进制数字。但是，该设置的值必须小于 &lt;code&gt;run/3&lt;/code&gt; 的调用者设置的值，该设置才会生效。也就是说，模式编写器可以降低程序员设置的限制，但不能提高。如果这些限制之一有多个设置，则使用较低的值。</target>
        </trans-unit>
        <trans-unit id="50c6e27284216f0fe5f85c8a2e068c1f3dc4d9db" translate="yes" xml:space="preserve">
          <source>Here each &lt;code&gt;ValueI&lt;/code&gt; is the default value for &lt;code&gt;FieldI&lt;/code&gt;.</source>
          <target state="translated">这里，每个 &lt;code&gt;ValueI&lt;/code&gt; 是默认值 &lt;code&gt;FieldI&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42052c3c2c41c15b35977cf7cbb047bcba82e64f" translate="yes" xml:space="preserve">
          <source>Here follows a client side example, divide into several steps for readability.</source>
          <target state="translated">下面以客户端为例,分为几个步骤,以便于阅读。</target>
        </trans-unit>
        <trans-unit id="9cbca54b367e1a4f6983365c6ace0c9e807f6a44" translate="yes" xml:space="preserve">
          <source>Here follows a description of the variables that are defined.</source>
          <target state="translated">以下是对所定义的变量的说明。</target>
        </trans-unit>
        <trans-unit id="4292ce9c08f629230d2ca9c9a4b58e4451d521bd" translate="yes" xml:space="preserve">
          <source>Here follows a series of examples ranging from simple to more complex.</source>
          <target state="translated">下面是一系列从简单到复杂的例子。</target>
        </trans-unit>
        <trans-unit id="7de541520f50013aebeb6484b87ccc69628a3a4f" translate="yes" xml:space="preserve">
          <source>Here follows a simple example of turning a gen_fsm into a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt;. The example comes from the previous Users Guide for &lt;code&gt;gen_fsm&lt;/code&gt;</source>
          <target state="translated">以下是将gen_fsm转换为 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 的简单示例。该示例来自先前的 &lt;code&gt;gen_fsm&lt;/code&gt; 用户指南</target>
        </trans-unit>
        <trans-unit id="056d3b9258e32cd2a4368560fe9287c17631f021" translate="yes" xml:space="preserve">
          <source>Here follows a simple test specification example:</source>
          <target state="translated">下面是一个简单的测试规范示例。</target>
        </trans-unit>
        <trans-unit id="d1a5f798f4fca1457852fb5ded06b31390f422db" translate="yes" xml:space="preserve">
          <source>Here follows a summary of the settings affecting Unicode:</source>
          <target state="translated">以下是影响Unicode的设置摘要。</target>
        </trans-unit>
        <trans-unit id="e3b0266f7e1ec5f16aeffe2f3cad390ea2d7f486" translate="yes" xml:space="preserve">
          <source>Here follows all types that are allowed to be used in operands for instructions being constructed on the right side of a transformation rule.</source>
          <target state="translated">下面是允许在操作数中使用的所有类型,这些类型被构造在转换规则的右侧。</target>
        </trans-unit>
        <trans-unit id="36f3b865fe0de9bfe34af31066b4e1fd4775070c" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty printed, well indented version with long keywords:</source>
          <target state="translated">下面以一条短信为例,让大家感受一下短信的漂亮版和精简版的区别。首先是打印的漂亮版,缩进得很好,关键词很长。</target>
        </trans-unit>
        <trans-unit id="7f638f5d7f0c6d062a7666cb5822d5e70a90f9fb" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty, well indented version with long keywords:</source>
          <target state="translated">下面以一条短信为例,让大家感受一下短信的漂亮版和紧凑版的区别。首先是漂亮的,缩进得很好的版本,关键词很长。</target>
        </trans-unit>
        <trans-unit id="63d190124d61370d24019073f53f96c2b39b3a1c" translate="yes" xml:space="preserve">
          <source>Here follows some questions that you might have after reading this section with corresponding tips and links to the answers:</source>
          <target state="translated">下面是你在阅读本节后可能会有的一些问题,并附上相应的提示和答案链接。</target>
        </trans-unit>
        <trans-unit id="bbd3c491062bf2c5eaa657373046fe305f85357c" translate="yes" xml:space="preserve">
          <source>Here follows the details of what exactly is returned.</source>
          <target state="translated">以下是具体返回的内容。</target>
        </trans-unit>
        <trans-unit id="df5e0247c5bebffe1acdce6f9b2820393133d959" translate="yes" xml:space="preserve">
          <source>Here follows the function of the old API. These functions only work on a list of Latin-1 characters.</source>
          <target state="translated">这里遵循旧API的功能。这些函数只适用于Latin-1字符的列表。</target>
        </trans-unit>
        <trans-unit id="1e03b2fb11709d9ee5694c2236ecb3d219a8b412" translate="yes" xml:space="preserve">
          <source>Here follows the general configuration terms that are allowed in a cover specification file:</source>
          <target state="translated">下面是封面规范文件中允许的一般配置术语。</target>
        </trans-unit>
        <trans-unit id="e7402642ba6204e4b5e86065a76f140fdda43cbe" translate="yes" xml:space="preserve">
          <source>Here follows the type letters that more or less directly corresponds to the types for generic instructions.</source>
          <target state="translated">以下是与通用指令的类型大致直接对应的类型字母。</target>
        </trans-unit>
        <trans-unit id="ce3bb36613c3cfade2e1099d8162ab6ab7c75926" translate="yes" xml:space="preserve">
          <source>Here follows type definitions that are used by more than one function in the ODBC API.</source>
          <target state="translated">下面是ODBC API中多个函数使用的类型定义。</target>
        </trans-unit>
        <trans-unit id="4cdd0b6622fc9da41960fdfdea1968c18c462ed7" translate="yes" xml:space="preserve">
          <source>Here is a bit more complex calculation:</source>
          <target state="translated">下面是一个比较复杂的计算。</target>
        </trans-unit>
        <trans-unit id="f4538b53d8767dd2d98b8e1093b19420fc4852f6" translate="yes" xml:space="preserve">
          <source>Here is a complete example. The &lt;code&gt;new_map&lt;/code&gt; instruction is defined like this:</source>
          <target state="translated">这是一个完整的例子。该 &lt;code&gt;new_map&lt;/code&gt; 指令的定义如下：</target>
        </trans-unit>
        <trans-unit id="d349cc2e55bbdec82aca8231149986fa8cec97cd" translate="yes" xml:space="preserve">
          <source>Here is a function call as &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; as the argument to the function &lt;code&gt;print_temp&lt;/code&gt;. When function calls are &lt;strong&gt;nested&lt;/strong&gt; like this, they execute (evaluate) from the inside out. That is, first &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; is evaluated, which gives the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; as the temperature is already in Celsius. Then &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; is evaluated. The function &lt;code&gt;convert_to_celsius&lt;/code&gt; works in a similar way to the &lt;code&gt;convert_length&lt;/code&gt; function in the previous example.</source>
          <target state="translated">这是一个作为 &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; 的函数调用，作为函数 &lt;code&gt;print_temp&lt;/code&gt; 的参数。当函数调用像这样&lt;strong&gt;嵌套时&lt;/strong&gt;，它们将由内而外执行（评估）。也就是说，首先对 &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; 求值 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 因为温度已经在摄氏温度下，因此给出值{moscow，{c，-10}}。然后 &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; 。函数 &lt;code&gt;convert_to_celsius&lt;/code&gt; 的工作方式与前面示例中的 &lt;code&gt;convert_length&lt;/code&gt; 函数类似。</target>
        </trans-unit>
        <trans-unit id="7b73ef99e7403f3927ff26a039c6e2a2236690f9" translate="yes" xml:space="preserve">
          <source>Here is a list of some of the MIBs defined in the OTP system:</source>
          <target state="translated">下面是OTP系统中定义的一些MIB的列表。</target>
        </trans-unit>
        <trans-unit id="22821c0d8cd96a6861d0a1d65f8c0f8148458395" translate="yes" xml:space="preserve">
          <source>Here is a more complete sequence that contains both adding, updating and removing breakpoints.</source>
          <target state="translated">这里是一个更完整的序列,包含添加、更新和删除断点。</target>
        </trans-unit>
        <trans-unit id="f72c798b29ccb529841e5627093d7a56fd4814a8" translate="yes" xml:space="preserve">
          <source>Here is an example how the reserved virtual address space for literals can be raised to 2 GB (2048 MB):</source>
          <target state="translated">下面是一个例子,说明如何将为字元保留的虚拟地址空间提高到2 GB(2048 MB)。</target>
        </trans-unit>
        <trans-unit id="ba858455c144cf3056c405c091e7501e673c5076" translate="yes" xml:space="preserve">
          <source>Here is an example of a suitable expression sequence:</source>
          <target state="translated">下面是一个合适的表达序列的例子。</target>
        </trans-unit>
        <trans-unit id="00e38b026becd87996568d41fcc3b8f1d79752be" translate="yes" xml:space="preserve">
          <source>Here is an example of this option:</source>
          <target state="translated">下面是这个选项的一个例子。</target>
        </trans-unit>
        <trans-unit id="3f74118ff53b9ac72b1f1d3c138c82f074dbcd87" translate="yes" xml:space="preserve">
          <source>Here is an example showing how values can be specified:</source>
          <target state="translated">下面是一个例子,说明如何指定值。</target>
        </trans-unit>
        <trans-unit id="b09da04e514cbcbfa274d3aa81a9da1bf964eb8e" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to count how many times each instruction is executed:</source>
          <target state="translated">下面是一个例子,说明如何计算每条指令的执行次数。</target>
        </trans-unit>
        <trans-unit id="e17a454a258af8149a5983e38860d0dd63592107" translate="yes" xml:space="preserve">
          <source>Here is an example. The config-file has the following contents:</source>
          <target state="translated">下面是一个例子。配置文件的内容如下。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="82a08ca8184b592a01eaaa55a20f8527f4cca1b8" translate="yes" xml:space="preserve">
          <source>Here is an overview what has been done so far:</source>
          <target state="translated">以下是迄今为止所做的概述。</target>
        </trans-unit>
        <trans-unit id="368746ba7f8d7397bdc8b79dac1f30fb770a5d1c" translate="yes" xml:space="preserve">
          <source>Here is defined a function that doubles the value of a number and assigned this function to a variable. Thus &lt;code&gt;Xf(5)&lt;/code&gt; returns value 10. Two useful functions when working with lists are &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;, which are defined as follows:</source>
          <target state="translated">在此定义了一个将数字的值加倍的函数，并将该函数分配给变量。因此 &lt;code&gt;Xf(5)&lt;/code&gt; 返回值10。使用列表时，两个有用的函数是 &lt;code&gt;foreach&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; ，它们的定义如下：</target>
        </trans-unit>
        <trans-unit id="7ce731a790a4205763d05d03b9cf196ef4e9261e" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using a generic time-out named for example &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="translated">这是通过使用名为 &lt;code&gt;open&lt;/code&gt; 的通用超时来完成上一个示例中的状态超时的方法：</target>
        </trans-unit>
        <trans-unit id="a0d2cc3be9345b9bae90d4c70bae158e4ffa9f78" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using an Erlang Timer:</source>
          <target state="translated">下面是如何通过改用Erlang Timer来完成前面例子中的状态超时。</target>
        </trans-unit>
        <trans-unit id="eaf5ed4c0dabc7f41cc89c5f4a3aa5a863561e75" translate="yes" xml:space="preserve">
          <source>Here is only considered the case when Erlang/OTP is running on a UNIX system.</source>
          <target state="translated">这里只考虑Erlang/OTP在UNIX系统上运行时的情况。</target>
        </trans-unit>
        <trans-unit id="5522fd885b43a2eff23d532ec8cfc36c8effcd85" translate="yes" xml:space="preserve">
          <source>Here is the definition of &lt;code&gt;deallocate_return/1&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;deallocate_return/1&lt;/code&gt; 的定义：</target>
        </trans-unit>
        <trans-unit id="5f17fc708829cfc6fb00458e5b09fdb85b5ef940" translate="yes" xml:space="preserve">
          <source>Here is the ping pong example modified to run on two separate nodes:</source>
          <target state="translated">下面是修改后在两个独立节点上运行的乒乓实例。</target>
        </trans-unit>
        <trans-unit id="36bfcb0b8532e087fad81f46e3b585565729333b" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all key expressions evalute successfully and all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">在这里，键 &lt;code&gt;K1 .. Kn&lt;/code&gt; 是具有文字或绑定变量的任何表达式。如果所有键表达式都成功求值，并且所有键都存在于映射 &lt;code&gt;M&lt;/code&gt; 中，则 &lt;code&gt;V1 .. Vn&lt;/code&gt; 所有变量都将与它们各自键的关联值匹配。</target>
        </trans-unit>
        <trans-unit id="274b953d352c36df895d0e17f80b41429f1a2865" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">在这里，键 &lt;code&gt;K1 .. Kn&lt;/code&gt; 是具有文字或绑定变量的任何表达式。如果所有键都存在于映射 &lt;code&gt;M&lt;/code&gt; 中，则 &lt;code&gt;V1 .. Vn&lt;/code&gt; 所有变量都将与它们各自键的关联值匹配。</target>
        </trans-unit>
        <trans-unit id="69f329541992e8d01a4e5a912d3401c2919e27cf" translate="yes" xml:space="preserve">
          <source>Here more than one list is built. In each iteration step a new list is created that is one element longer than the new previous list.</source>
          <target state="translated">这里建立了多个列表。在每个迭代步骤中,都会创建一个新的列表,该列表比新的前一个列表长一个元素。</target>
        </trans-unit>
        <trans-unit id="4207694f60edbd73e98081488a51ba1699a0f859" translate="yes" xml:space="preserve">
          <source>Here only the Kernel and STDLIB applications are started, that is, the system is started as an ordinary development system. Only two files are needed for all this to work:</source>
          <target state="translated">这里只启动了Kernel和STDLIB应用程序,也就是说,系统是作为一个普通的开发系统来启动的。这一切只需要两个文件就可以了。</target>
        </trans-unit>
        <trans-unit id="1a01cbab019a5244984e7111de8ade2f66f53c2f" translate="yes" xml:space="preserve">
          <source>Here some initialization is done, &lt;code&gt;start&lt;/code&gt; is called from &lt;code&gt;open_port&lt;/code&gt;. The data will be passed to &lt;code&gt;control&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">这里是一些初始化完成后， &lt;code&gt;start&lt;/code&gt; 从所谓的 &lt;code&gt;open_port&lt;/code&gt; 。数据将传递到 &lt;code&gt;control&lt;/code&gt; 并 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dd38392b306d639490f3bfdab336a2923914d6c" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;is_eq_exact&lt;/code&gt; instruction is replaced with a specialized instruction that only compares literals, but only if the first operand is a register and the second operand is a literal.</source>
          <target state="translated">在这里， &lt;code&gt;is_eq_exact&lt;/code&gt; 指令被替换为仅比较文字的专用指令，但前提是第一个操作数是寄存器，第二个操作数是文字。</target>
        </trans-unit>
        <trans-unit id="8285a3adddfb3c22982d47841765517ced8bef67" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;start/0&lt;/code&gt; function,</source>
          <target state="translated">这里的 &lt;code&gt;start/0&lt;/code&gt; 功能，</target>
        </trans-unit>
        <trans-unit id="6d1513bbb3276cbd3a38ec95089202ddef094a3d" translate="yes" xml:space="preserve">
          <source>Here the Ti's are atoms (the name of the type) and the Ai's are their arguments</source>
          <target state="translated">这里的Ti是原子(类型的名称),Ai是它们的参数</target>
        </trans-unit>
        <trans-unit id="9acec98c2e5c443462282bed38bd34c514085f2c" translate="yes" xml:space="preserve">
          <source>Here the call to the GC BIF &lt;code&gt;'+'/2&lt;/code&gt; will be replaced with the instruction &lt;code&gt;gen_plus/5&lt;/code&gt;. Note that the same name as used in the C source code must be used for the BIF, which in this case is &lt;code&gt;splus&lt;/code&gt;. It is defined like this in &lt;code&gt;bit.tab&lt;/code&gt;:</source>
          <target state="translated">在这里，对GC BIF &lt;code&gt;'+'/2&lt;/code&gt; 的调用将替换为 &lt;code&gt;gen_plus/5&lt;/code&gt; 指令。请注意，BIF必须使用与C源代码中使用的名称相同的名称，在本例中为 &lt;code&gt;splus&lt;/code&gt; 。在 &lt;code&gt;bit.tab&lt;/code&gt; 中定义如下：</target>
        </trans-unit>
        <trans-unit id="8b79b4c75297735efc429805d3857e3fd989ff1f" translate="yes" xml:space="preserve">
          <source>Here the concept of an &lt;strong&gt;anonymous variable&lt;/strong&gt; &quot;_&quot; is introduced. This is simply shorthand for a variable that gets a value, but the value is ignored. This can be used anywhere suitable, not just in funs. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Temp1&lt;/code&gt; is less than &lt;code&gt;Temp2&lt;/code&gt;.</source>
          <target state="translated">这里介绍了&lt;strong&gt;匿名变量&lt;/strong&gt; &amp;ldquo; _&amp;rdquo; 的概念。这只是获取值的变量的简写形式，但该值将被忽略。可以在任何合适的地方使用它，而不仅仅是在娱乐中使用。如果 &lt;code&gt;Temp1&lt;/code&gt; 小于 &lt;code&gt;Temp2&lt;/code&gt; ,则 &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af3c6eb665702670ccab0184a2424627dfa000a9" translate="yes" xml:space="preserve">
          <source>Here the empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;) represents the unassigned subpattern. In the &lt;code&gt;binary&lt;/code&gt; case, some information about the matching is therefore lost, as &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can also be an empty string captured.</source>
          <target state="translated">在此，空二进制（ &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ）代表未分配的子模式。在 &lt;code&gt;binary&lt;/code&gt; 情况下，因此会丢失一些有关匹配的信息，因为 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 也可以是捕获的空字符串。</target>
        </trans-unit>
        <trans-unit id="1abd874c2e02ed54ed46fd6eb351fd6b4434ff43" translate="yes" xml:space="preserve">
          <source>Here the file I/O server returns all available options for a file, which are the expected ones, &lt;code&gt;encoding&lt;/code&gt; and &lt;code&gt;binary&lt;/code&gt;. However, the standard shell has some more options:</source>
          <target state="translated">在这里，文件I / O服务器返回文件的所有可用选项，即期望的选项， &lt;code&gt;encoding&lt;/code&gt; 和 &lt;code&gt;binary&lt;/code&gt; 。但是，标准外壳还有更多选择：</target>
        </trans-unit>
        <trans-unit id="e6b28a4e54bbbd54cef63a1e3115ada96bc39316" translate="yes" xml:space="preserve">
          <source>Here the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; in module &lt;code&gt;tut1&lt;/code&gt; is called with argument &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">在这里，使用参数 &lt;code&gt;4&lt;/code&gt; 调用模块 &lt;code&gt;tut1&lt;/code&gt; 中的函数 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d195818a01c51c6fa746b1e3cba1a090681218" translate="yes" xml:space="preserve">
          <source>Here the key to be retrieved is constructed from an expression:</source>
          <target state="translated">这里要检索的密钥是由一个表达式构造的。</target>
        </trans-unit>
        <trans-unit id="76e0ad7418ef3374cc17d038856a722ae97d8a0c" translate="yes" xml:space="preserve">
          <source>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</source>
          <target state="translated">在这里,正则表达式首先匹配 &quot;l&quot;,使得 &quot;Er &quot;成为结果中的第一部分。当正则表达式匹配时,(唯一的)子表达式被绑定到 &quot;l &quot;上,所以 &quot;l &quot;和 &quot;Er &quot;一起被插入组中。下一个匹配的是 &quot;n&quot;,使得 &quot;a &quot;成为下一个要返回的部分。在这种情况下,由于子表达式与子串 &quot;n &quot;绑定,所以 &quot;n &quot;被插入到这个组中。最后一组由剩余的字符串组成,因为没有找到更多的匹配项。</target>
        </trans-unit>
        <trans-unit id="1da2c5952d714e65a29c19457fda0a08e5b2194a" translate="yes" xml:space="preserve">
          <source>Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</source>
          <target state="translated">这里的返回值相应地指出了所有的字符串,从索引0开始,它的长度是10个字符。</target>
        </trans-unit>
        <trans-unit id="8a03dce83b236db4e1a3d7678c31aea14b2cf2d3" translate="yes" xml:space="preserve">
          <source>Here the second operand of &lt;code&gt;move&lt;/code&gt; is constrained to be X register 1.</source>
          <target state="translated">此处，第二个 &lt;code&gt;move&lt;/code&gt; 操作数被限制为X寄存器1。</target>
        </trans-unit>
        <trans-unit id="8588926d91ef055e0e752b5cc02d17b611653864" translate="yes" xml:space="preserve">
          <source>Here the shell detects lists containing printable characters or binaries containing printable characters in bytewise or UTF-8 encoding. But what is a printable character? One view is that anything the Unicode standard thinks is printable, is also printable according to the heuristic detection. The result is then that almost any list of integers are deemed a string, and all sorts of characters are printed, maybe also characters that your terminal lacks in its font set (resulting in some unappreciated generic output). Another way is to keep it backward compatible so that only the ISO Latin-1 character set is used to detect a string. A third way is to let the user decide exactly what Unicode ranges that are to be viewed as characters.</source>
          <target state="translated">在这里,shell会检测包含可打印字符的列表或包含可打印字符的二进制文件,采用字节式或UTF-8编码。但什么是可打印字符呢?有一种观点认为,Unicode标准认为是可打印的任何东西,根据启发式检测也是可打印的。那么结果就是,几乎所有的整数列表都被认为是一个字符串,各种字符都会被打印出来,也许还包括你的终端在其字体集中缺少的字符(导致一些不被重视的通用输出)。另一种方法是保持向后兼容,这样只用ISO拉丁-1字符集来检测字符串。第三种方法是让用户确切地决定哪些Unicode范围要被视为字符。</target>
        </trans-unit>
        <trans-unit id="74160bc743886e5a3198a381b4d2136a5e539152" translate="yes" xml:space="preserve">
          <source>Here the signature and message in the last example is verifyed using the public key. The public key is stored in an engine, only to exemplify that it is possible. The public key could of course be handled openly as usual.</source>
          <target state="translated">在这里,最后一个例子中的签名和信息是用公钥来验证的。公钥被存储在一个引擎中,只是为了说明它是可能的。当然,公钥也可以像平常一样公开处理。</target>
        </trans-unit>
        <trans-unit id="d2d4f1fdcedde1498c2f363b018c87e4697de1db" translate="yes" xml:space="preserve">
          <source>Here the user flag &lt;code&gt;-myflag 1&lt;/code&gt; is passed to and stored by the &lt;code&gt;init&lt;/code&gt; process. It is a user-defined flag, presumably used by some user-defined application.</source>
          <target state="translated">此处，用户标志 &lt;code&gt;-myflag 1&lt;/code&gt; 传递给 &lt;code&gt;init&lt;/code&gt; 进程并由init进程存储。它是一个用户定义的标志，可能由某些用户定义的应用程序使用。</target>
        </trans-unit>
        <trans-unit id="402b80a6663c605b1c8ebefde4ea19bbe39ddf28" translate="yes" xml:space="preserve">
          <source>Here we also handle the mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;) that can be set by request &lt;code&gt;setopts&lt;/code&gt;. By default, all OTP I/O servers send data back to the client as lists, but switching mode to &lt;code&gt;binary&lt;/code&gt; can increase efficiency if the I/O server handles it in an appropriate way. The implementation of &lt;code&gt;get_until&lt;/code&gt; is difficult to get efficient, as the supplied function is defined to take lists as arguments, but &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; can be optimized for binary mode. However, this example does not optimize anything.</source>
          <target state="translated">在这里，我们还处理可以通过请求 &lt;code&gt;setopts&lt;/code&gt; 设置的模式（ &lt;code&gt;binary&lt;/code&gt; 或 &lt;code&gt;list&lt;/code&gt; ）。默认情况下，所有OTP I / O服务器都将数据作为列表发送回客户端，但是如果I / O服务器以适当的方式处理数据，则将模式切换为 &lt;code&gt;binary&lt;/code&gt; 可以提高效率。实施 &lt;code&gt;get_until&lt;/code&gt; 是很难得到有效的，因为提供的函数定义采取列表作为参数，但 &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_line&lt;/code&gt; 可以为二进制模式进行优化。但是，此示例没有任何优化。</target>
        </trans-unit>
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">在这里，我们检查来自postgres的结果。如果是数据，我们将其编码为带有列数据的列表列表。postgres中的所有内容都是C字符串，因此我们使用 &lt;code&gt;ei_x_encode_string&lt;/code&gt; 将结果作为字符串发送到Erlang。（列表的开头包含列名。）</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">在这里,我们创建了一个包含Erlang代码和Beam代码的归档脚本,然后我们对归档中的所有文件进行迭代,并收集它们的内容和一些相关信息。</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">在这里，我们创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件，并将其放置在目录 &lt;code&gt;../projectdir&lt;/code&gt; 中。该文件包含有关这三个文件的功能，记录和宏定义的信息。</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">在这里，我们或多或少地仅实现了 &lt;code&gt;get_until&lt;/code&gt; 并使用内部助手来实现 &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_line&lt;/code&gt; 。在生产代码中，这可能效率低下，但这取决于不同请求的频率。在开始实现功能 &lt;code&gt;put_chars/2&lt;/code&gt; 和 &lt;code&gt;get_until/5&lt;/code&gt; 之前，我们检查了一些剩余的请求：</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">在这里我们看到,没有一个函数有很大的区别,这是很正常的。</target>
        </trans-unit>
        <trans-unit id="465ac4aff2d9132b9905c273ca86662ca9c4c44b" translate="yes" xml:space="preserve">
          <source>Here we will show how &lt;code&gt;i_increment&lt;/code&gt; can be implemented as a combined instruction. We will show each individual fragment first, and then show how to connect them together. First we will need a variable that we can store the value fetched from the register in:</source>
          <target state="translated">在这里，我们将展示如何将 &lt;code&gt;i_increment&lt;/code&gt; 实现为组合指令。我们将首先展示每个单独的片段，然后展示如何将它们连接在一起。首先，我们需要一个变量，该变量可以存储从寄存器中获取的值：</target>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">在这里，您可以看到 &lt;code&gt;|&lt;/code&gt; 的使用。从列表中获取前两个元素。如果尝试从列表中获取的元素多于列表中的元素，则会返回错误。还要注意没有元素[]的列表的特殊情况：</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">这里还有一个例子。</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">在此， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是任何表达式， &lt;code&gt;M0&lt;/code&gt; 至 &lt;code&gt;M4&lt;/code&gt; 是结果映射项。</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">在这里，&amp;ldquo; &lt;code&gt;Arguments&lt;/code&gt; 是零个或多个参数的列表。该 &lt;code&gt;-callback&lt;/code&gt; 属性是首选，因为额外的类型信息，可以通过工具来产生的文档或找到差异。</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">在这里， &lt;code&gt;Bin&lt;/code&gt; 是绑定的，元素是绑定或未绑定的，就像在任何匹配中一样。</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">在这里， &lt;code&gt;Expr&lt;/code&gt; 是一个任意表达式，每个 &lt;code&gt;Qualifier&lt;/code&gt; 都是生成器或过滤器。</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">在这里， &lt;code&gt;Fd&lt;/code&gt; 是目标文件或原子 &lt;code&gt;standard_io&lt;/code&gt; 的文件描述符。 &lt;code&gt;_TraceInfo&lt;/code&gt; 包含来自跟踪信息文件的信息（请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;State&lt;/code&gt; 是格式处理程序fun的状态变量。变量 &lt;code&gt;State&lt;/code&gt; 的初始值由处理程序选项指定，例如：</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">在这里， &lt;code&gt;File&lt;/code&gt; 被用作新的变量，而不是 &lt;code&gt;X&lt;/code&gt; 。这不是那么明智，因为乐趣主体中的代码无法引用在乐趣之外定义的变量 &lt;code&gt;File&lt;/code&gt; 。编译此示例将给出以下诊断：</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">在此， &lt;code&gt;S1LogDir&lt;/code&gt; 和 &lt;code&gt;S2LogDir&lt;/code&gt; 分别是每个测试的名为 &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; 的目录。</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">在这里， &lt;code&gt;conn_types&lt;/code&gt; 指定SSH，Telnet，FTP，RPC和/或SNMP。</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;demo()&lt;/code&gt; 评估为 &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">在这里， &lt;code&gt;init&lt;/code&gt; 不需要任何输入数据，并且会忽略其参数。对于 &lt;code&gt;terminal_logger&lt;/code&gt; ，不使用内部状态。对于 &lt;code&gt;file_logger&lt;/code&gt; ，内部状态用于保存打开的文件描述符。</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">这里， &lt;code&gt;tuplep&lt;/code&gt; 指向一个 &lt;code&gt;ETERM&lt;/code&gt; 表示与两个元素的元组结构; 函数名称（atom）和参数（整数）。使用函数 &lt;code&gt;erl_element()&lt;/code&gt; 从 &lt;code&gt;erl_eterm&lt;/code&gt; ，这些元件可被提取，但它们也必须被声明为指针的 &lt;code&gt;ETERM&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">在这里，与C的通信隐藏在 &lt;code&gt;complex.erl&lt;/code&gt; 的实现中。在以下各节中，显示了如何使用不同的互操作性机制来实现此模块。</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">在这里，数据类型 &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; 表示为以下Erlang记录：</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">在这里，指令 &lt;code&gt;on_load&lt;/code&gt; 用于获取函数 &lt;code&gt;init&lt;/code&gt; ，以便在模块加载时自动调用该函数。如果 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; 以外的任何内容，例如在此示例中NIF库的加载失败时，则模块将被卸载，并且对其中的函数的调用将失败。</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">在此，处理程序还提供了动态重载配置变量的功能。如果从测试用例函数中调用了 &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; ,则使用 &lt;code&gt;config_driver:read_config/1&lt;/code&gt; 加载的所有变量都将使用其最新值进行更新，并返回变量 &lt;code&gt;localtime&lt;/code&gt; 的新值。</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">在此，执行（和可能重复）与前面示例相同的测试运行。但是，如果发生超时，则在1小时后，&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; &amp;rdquo;会在停止之前完成整个测试运行（即 &lt;code&gt;to1&lt;/code&gt; 和 &lt;code&gt;to2&lt;/code&gt; 始终在同一测试运行中执行）。</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">在这里，运行与示例1相同的测试，但是将标志 &lt;code&gt;force_stop&lt;/code&gt; 设置为 &lt;code&gt;skip_rest&lt;/code&gt; 。如果在目录 &lt;code&gt;to1&lt;/code&gt; 中执行测试时发生超时，则会跳过 &lt;code&gt;to1&lt;/code&gt; 中其余的测试用例，并且中止测试，而无需再次运行 &lt;code&gt;to2&lt;/code&gt; 中的测试。如果在目录 &lt;code&gt;to2&lt;/code&gt; 中执行测试时发生超时，则跳过 &lt;code&gt;to2&lt;/code&gt; 中其余的测试用例，并终止测试。</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">在这里，与 &lt;code&gt;Opts&lt;/code&gt; 变量相对应的段具有&lt;strong&gt;类型修饰符&lt;/strong&gt;，指定 &lt;code&gt;Opts&lt;/code&gt; 将绑定到二进制文件。所有其他变量的默认类型等于无符号整数。</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">在此，在一次测试运行中执行测试目录 &lt;code&gt;to1&lt;/code&gt; 中的套件，然后是 &lt;code&gt;to2&lt;/code&gt; 中的套件。10分钟后发生超时事件。只要还有时间， &lt;code&gt;Common Test&lt;/code&gt; 就会重复测试运行（即从test &lt;code&gt;to1&lt;/code&gt; 重新开始）。超时后，当完成当前作业时， &lt;code&gt;Common Test&lt;/code&gt; 停止（由于标志 &lt;code&gt;force_stop&lt;/code&gt; ）。结果，可以在测试 &lt;code&gt;to1&lt;/code&gt; 之后和测试 &lt;code&gt;to2&lt;/code&gt; 之前中止指定的测试运行。</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">在此，将包括 &lt;code&gt;to1&lt;/code&gt; 和 &lt;code&gt;to2&lt;/code&gt; 测试在内的测试运行重复五次。</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">在这里,先运行 &quot;ts1 &quot;指定的测试,然后运行 &quot;ts2 &quot;指定的测试,最后运行 &quot;ts3 &quot;和 &quot;ts4 &quot;指定的测试。</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">在这里，在乐趣开头定义的变量 &lt;code&gt;X&lt;/code&gt; 是一个新变量。乐趣中使用的变量 &lt;code&gt;Stream&lt;/code&gt; 从 &lt;code&gt;file:open&lt;/code&gt; 行获取其值。</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">此处， &lt;code&gt;div.error&lt;/code&gt; 打印输出使用白色文本代替默认黑色（并且不影响 &lt;code&gt;pre&lt;/code&gt; 的其他属性设置）。</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">在这里， &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 具有以下参数：</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="ad89343a3d3c4ba891ac4b0730bfade95df05420" translate="yes" xml:space="preserve">
          <source>Heuristic Identification of UTF-8</source>
          <target state="translated">UTF-8的启发式识别</target>
        </trans-unit>
        <trans-unit id="6d3b73d033962cbf0bbbb6396f3106e5fadd47c5" translate="yes" xml:space="preserve">
          <source>Heuristic String Detection</source>
          <target state="translated">启发式字符串检测</target>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">十六进制数字</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">以下系统会自动启用HiPE。</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">HiPE支持以下系统配置。</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">隐藏菜单。</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">高容错率</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">高层指示</target>
        </trans-unit>
        <trans-unit id="e5a92cb9a3146c86050022c2169e16055f62bf41" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前操作系统单调时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; （以每秒为单位）。如果无法从OS检索到分辨率信息， &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 与分辨率一致。但是，您确实知道精度并不比 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="d7116b5f034f81df6881fb6c021d526c89a62a5d" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前OS系统时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; （以每秒为单位）。如果无法从OS检索到分辨率信息，则 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 做到对齐决议。但是，您确实知道精度并不比 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前操作系统单调时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; ，以每秒为单位。如果无法从OS检索到分辨率信息，则 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 与分辨率一致。但是，您确实知道精度并不比 &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">当前OS系统时间源的最高可能 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; （以每秒为单位）。如果无法从OS检索到分辨率信息，则 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 设置为 &lt;code&gt;Function&lt;/code&gt; 返回值的时间单位的分辨率。也就是说，实际分辨率可以低于 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 。请注意，该决议并没有说明任何的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 或是否 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 做到对齐决议。但是，您确实知道精度并不比 &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Hmac功能- &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">挂钩选项 &lt;code&gt;log_type&lt;/code&gt; 可用于更改 &lt;code&gt;cth_conn_log&lt;/code&gt; 行为。此选项的默认值为 &lt;code&gt;raw&lt;/code&gt; ，这将导致上述行为。如果该值设置为 &lt;code&gt;html&lt;/code&gt; ，则所有Telnet通信都将打印到测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">钩子选项 &lt;code&gt;log_type&lt;/code&gt; 指定日志记录的类型：</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">在配置文件中指定的钩子选项覆盖了测试套件中任何硬编码的钩子选项。</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">配置文件中指定的钩子选项覆盖了测试套件中的硬编码钩子选项。</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">在发送出站请求时,按直径设置逐跳和端到端标识符。</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">水平片 (HT)</target>
        </trans-unit>
        <trans-unit id="de7f8e30d370dbed377d6f3ec1e0f3638d8f7cd7" translate="yes" xml:space="preserve">
          <source>Host :: string(),</source>
          <target state="translated">主机:字符串();</target>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">主机= &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">找不到主机,找不到FTP服务器,或者连接被FTP服务器拒绝。</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">主机密钥算法。</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">主机钥匙</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">主机公钥</target>
        </trans-unit>
        <trans-unit id="8dea1bfa3d5f782d439b94a2dc9e26fd4b92b4b3" translate="yes" xml:space="preserve">
          <source>Host,</source>
          <target state="translated">Host,</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">主机-IP-地址AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">主机名提取</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">Hostname是在调用这个funcion的Erlang节点中调用net_adm:localhost()的结果。</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">节点的 &lt;code&gt;host&lt;/code&gt; 名，主机</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">主机名和主机地址</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">&amp;ldquo;如何将类别映射到CSS标记&amp;rdquo; 在&amp;ldquo;运行测试和分析结果&amp;rdquo; 部分的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">代码如何编译和加载不是语言问题,而是取决于系统。本节介绍了Erlang/OTP中的编译和代码加载,并引用了文档中的相关部分。</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">在输出带有时间戳之前，Erlang需要停用多长时间。默认为 &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; ，最小值为1。</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">在将 &quot;ALIVE &quot;消息写入日志之前等待输出的时间(分钟)。默认值为15,最小值为1。</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">从套接字读取（接收到）多少个字节，以与 &lt;code&gt;sent&lt;/code&gt; 相似的方式使用。</target>
        </trans-unit>
        <trans-unit id="2063d1711356aa5cf80622e43bafe411dc016ccf" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">通过套接字发送了多少字节。这可以进行包装，但这对于发行版来说不是问题，因为Erlang发行版仅在此值已更改的情况下才感兴趣。（Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 器通过调用驱动程序来获取此值来使用该值，这是通过 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 例程完成的。）</target>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">通过套接字发送了多少字节。这可以进行包装，但这对于发行版来说不是问题，因为Erlang发行版仅在此值已更改时才感兴趣。（Erlang &lt;code&gt;net_kernel&lt;/code&gt; &lt;code&gt;ticker&lt;/code&gt; 通过调用驱动程序来获取它来使用此值，这是通过 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 例程完成的。）</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">如何绑定调度器很重要。例如,在运行进程少于在线调度器的情况下,运行时系统会尝试将进程迁移到调度器标识较低的调度器上。在这种情况下,调度器在硬件上的分布越多,运行时系统的资源就越多。</target>
        </trans-unit>
        <trans-unit id="22fb0d06b90905c411643c4b8d63177262432872" translate="yes" xml:space="preserve">
          <source>How the different levels of configuration &quot;interfer&quot; with this, see the section &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; in the chapter &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不同级别的配置如何对此产生&amp;ldquo;干扰&amp;rdquo;，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt; 中的配置&amp;rdquo;一章中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">如何构建一个启用调试的Erlang RunTime系统?</target>
        </trans-unit>
        <trans-unit id="d0e7345d074a8ac083420a87f267a9efe5441d6f" translate="yes" xml:space="preserve">
          <source>How to Work with the New API</source>
          <target state="translated">如何使用新的API</target>
        </trans-unit>
        <trans-unit id="1c9e65c5426cc2af60f611bbcd0bef6a2d2545ba" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt; Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">如何与外界和使用其他语言（端口）编写的软件进行通信； &lt;code&gt; Interoperability Tutorial&lt;/code&gt; 对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">如何与外界和其他语言（端口）编写的软件进行通信； &lt;code&gt;Interoperability Tutorial&lt;/code&gt; 对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何处理传入消息中&amp;ldquo;直径标题&amp;rdquo;的&amp;ldquo;消息长度&amp;rdquo;字段中的错误。在这种情况下的错误是，该长度不是至少20个字节（标头的长度），不是4的倍数（有效长度），或者不是通过传输接收到的相关消息的长度接口记录在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">如何在目标环境中安装发行版,在第2节系统原理中关于目标系统的部分有介绍。</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何应用程序中描述 &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如何计划版本中描述 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">本节介绍如何通过从主代理发送 &lt;code&gt;fTrap&lt;/code&gt; 来发送陷阱。主代理已加载MIB &lt;code&gt;EX1-MIB&lt;/code&gt; ，并在其中定义了陷阱。该陷阱指定应与陷阱一起发送两个变量 &lt;code&gt;myName&lt;/code&gt; 和 &lt;code&gt;fIndex&lt;/code&gt; 。 &lt;code&gt;fIndex&lt;/code&gt; 是一个表列，因此我们必须在调用 &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; 时提供其值和该行的索引。在下面的示例中，我们假设所讨论的行的索引为2（ &lt;code&gt;fIndex&lt;/code&gt; 为 2 的行）。</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">如何启动和停止应用程序的代码,也就是监督树,由两个回调函数描述。</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">可以从书籍和Internet上的许多页面中学习如何编写 &lt;code&gt;d&lt;/code&gt; 程序或 &lt;code&gt;systemtap&lt;/code&gt; 脚本。本手册页不包含有关使用相应平台的动态跟踪工具的任何文档。但是， &lt;code&gt;runtime_tools&lt;/code&gt; 应用程序的 &lt;code&gt;examples&lt;/code&gt; 目录包含 &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;systemtap&lt;/code&gt; 程序的综合示例，可帮助您入门。另一个信息来源是《运行时工具用户指南》中的 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; 章节。</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">但是，NTP不是故障安全的。 NTP服务器可能不可用， &lt;code&gt;ntp.conf&lt;/code&gt; 可能配置错误，或者您的计算机有时可能与Internet断开连接。此外，您可能有一个用户（甚至系统管理员）认为处理夏时制的正确方法是一年两次调整时钟一次（这是不正确的方法）。更复杂的是，该用户从Internet上获取了您的软件，但并未考虑计算机认为正确的时间。用户并不关心使挂钟与正确的时间保持同步。用户希望您的程序对时间有无限的了解。</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">然而,以这种方式启动的节点拒绝与其他节点对话,因为没有提供TLS参数(见下一节)。</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">但是,不允许使用非完整字节的位串,所以UTF字符必须沿8位边界分割才能被解码。</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">但是，还可以使用 &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; 解码证书，该证书可以自定义和递归解码证书的标准部分：</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">但是,转义其他非字母数字字符并无大碍。</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">但是，对于 &lt;code&gt;SET OF&lt;/code&gt; 类型的值，DER编码格式要求元素以其编码的升序发送，这意味着运行时的排序过程很昂贵。因此 &lt;code&gt;SET OF&lt;/code&gt; 如果可能 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 建议使用SEQUENCE OF代替SET OF。</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">然而,在这里你可以找到一些如何使用xmerl的例子,以及使用xmerl的目的。用户界面的详细描述可以在参考手册中找到。</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">然而，如果 &lt;code&gt;cp1&lt;/code&gt; 也重新启动，则该函数 &lt;code&gt;application:takeover/2&lt;/code&gt; 移动 &lt;code&gt;myapp&lt;/code&gt; 到 &lt;code&gt;cp1&lt;/code&gt; ，如 &lt;code&gt;cp1&lt;/code&gt; 具有比较高的优先级 &lt;code&gt;cp3&lt;/code&gt; 这种应用。在这种情况下， &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; 在被执行 &lt;code&gt;cp1&lt;/code&gt; 以启动应用程序。</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">但是,如果一个量化符后面加一个问号,它就不再贪婪,而是尽可能地减少匹配次数,所以下面的模式用C注释做了正确的事情。</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">但是，如果另一个进程已加载驱动程序，调用 &lt;code&gt;reload_driver&lt;/code&gt; 返回错误代码 &lt;code&gt;pending_process&lt;/code&gt; 。如前所述，建议的设计是不允许&amp;ldquo;驱动程序重新加载器&amp;rdquo;以外的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 要求加载相关驱动程序。</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">但是，如果反斜杠后面的十进制数字&amp;lt;10，则始终将其用作反向参考，并且仅在整个模式中没有太多捕获左括号的情况下才会引起错误。也就是说，对于数字&amp;lt;10，引用的括号不必位于引用的左侧。当涉及重复并且右侧的子模式已参与到重复操作中时，这种类型的&amp;ldquo;正向引用&amp;rdquo;可能很有意义。较早的迭代。</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">但是,如果第一个模式不匹配,则测试第二个模式。如果匹配,则从队列中删除消息,并执行与第二个模式对应的操作。如果第二个模式不匹配,则尝试第三个模式,以此类推,直到没有更多的模式可供测试。如果没有更多的模式可供测试,第一条消息将被保留在队列中,并尝试第二条消息。如果这与任何模式相匹配,则执行适当的操作,并将第二条消息从队列中移除(保留队列中的第一条消息和任何其他消息)。如果第二条消息不匹配,则尝试第三条消息,以此类推,直到到达队列的末端。如果到达队列的末端,进程就会阻塞(停止执行)并等待,直到收到新的消息,然后重复这个过程。</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">但是，如果输入 &lt;code&gt;Data&lt;/code&gt; 是纯二进制，则错误元组的第三部分也保证是二进制。</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">然而,如果创建表时使用显式记录名作为参数,如下面的示例所示,则无论表名如何,订阅者记录都可以存储在两个表中。</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">但是，如果这样做并生成了 &lt;code&gt;relup&lt;/code&gt; 文件，则它不仅将包含用于重启（即删除和添加） &lt;code&gt;prim_app&lt;/code&gt; 的指令，还将包含用于启动 &lt;code&gt;ch_app&lt;/code&gt; （并在降级的情况下将其停止）的指令。。这是因为 &lt;code&gt;ch_app&lt;/code&gt; 包含在新的 &lt;code&gt;.rel&lt;/code&gt; 文件中，而不包含在旧的.rel文件中。</target>
        </trans-unit>
        <trans-unit id="88d142963f00e274bf0e73a5e3da8dd76b986238" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line do not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">但是，如果按以下方式调用 &lt;code&gt;escript&lt;/code&gt; ，则第一行的内容无关紧要，但是它不能包含Erlang代码，因为它将被忽略：</target>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">但是，如果按以下方式调用 &lt;code&gt;escript&lt;/code&gt; ，则第一行的内容无关紧要，但是它不能包含Erlang代码，因为它将被忽略：</target>
        </trans-unit>
        <trans-unit id="7c6cbfad60b53ec8d8298796a95d996bcb875534" translate="yes" xml:space="preserve">
          <source>However, if you just want to change it for the current session you can also do that.</source>
          <target state="translated">但是,如果你只是想在当前会话中改变它,你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">但是，在解 &lt;code&gt;sys.config&lt;/code&gt; 之后但在运行发行版之前，在目标上的sys.config中替换变量也很方便。如果您有 &lt;code&gt;sys.config.src&lt;/code&gt; ，它将包含在内，并且不需要像 &lt;code&gt;sys.config&lt;/code&gt; 这样的有效Erlang术语文件。在运行发行版之前，您必须在同一目录中具有有效的 &lt;code&gt;sys.config&lt;/code&gt; ，因此，使用 &lt;code&gt;sys.config.src&lt;/code&gt; 需要具有一些工具来填充所需内容，并在启动发行版之前将 &lt;code&gt;sys.config&lt;/code&gt; 写入磁盘。</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">但是,如果改写成使用两个顶级分支,PCRE是可以接受的。</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">不过,是否考虑这些额外的信息,要由处理规格的工具来选择。</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">但是，可能存在更多的点分隔部分。点分隔的部分由非负整数组成。如果所有小于 &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; 的不重要部分都等于 &lt;code&gt;0&lt;/code&gt; ，则将其省略。三个 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 部分&amp;lt;Major&amp;gt;。&amp;lt;Minor&amp;gt;。&amp;lt;Patch&amp;gt;更改如下：</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">但是，由于 &lt;code&gt;{foo, false}&lt;/code&gt; 遮盖了 &lt;code&gt;foo&lt;/code&gt; ，因此在下面的调用中未进行任何扩展：</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">但是,请注意,如果使用脏操作来更新数据库,就有可能使数据库处于不一致的状态。只有在绝对必要的情况下,出于性能考虑才会使用脏操作。</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">然而,这种简单的行为可以通过多种方式进行修改。例如,Net if进程可以对字节应用某种加密/解密方案,或者充当代理过滤器,将一些数据包发送到代理代理代理,将一些数据包发送到主代理。</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">然而,这种简单的行为可以通过多种方式进行修改。例如,Net if进程可以对字节应用某种加密/解密方案。</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">但是,在某些情况下,不能使用这种优化。当.*位于捕获括号内,而括号又是模式中其他地方的反向引用的主题时,开始时的匹配可能会失败,而后来的匹配则会成功。例如,可以考虑</target>
        </trans-unit>
        <trans-unit id="fa09d853f290abccb9c6e1093393c3c7791a824e" translate="yes" xml:space="preserve">
          <source>However, there is an exception. Within a macro definition, a line that starts with whitespace followed by &lt;code&gt;//|&lt;/code&gt; is treated specially. The rest of the line is assumed to contain directives to control code generation.</source>
          <target state="translated">但是，有一个例外。在宏定义内，一行以空格开头，后跟 &lt;code&gt;//|&lt;/code&gt; 被特殊对待。该行的其余部分假定包含用于控制代码生成的指令。</target>
        </trans-unit>
        <trans-unit id="c4528e70959d30b530219f34dfc215c6d0cefc18" translate="yes" xml:space="preserve">
          <source>However, this feature of delaying thread progress from unmanaged threads should preferably be used as little as possible, since heavy use of it will cause contention on the reference counter cache lines. The functionality is however very useful in code which normally only executes in managed threads, but which may under some infrequent circumstances be executed in other threads.</source>
          <target state="translated">但是,这种从非受管线程中延迟线程进度的功能最好尽量少用,因为大量使用该功能会造成引用计数器缓存行的争用。然而,该功能在通常只在受管线程中执行的代码中非常有用,但在一些不常见的情况下,这些代码可能会在其他线程中执行。</target>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">但是，此过程可能很耗时，快捷功能 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 以更快的速度从磁盘加载所有表。无论网络情况如何，该功能都会强制从光盘加载表。</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">然而,为了避免旧的(R14之前的)代码在用OTP版本R14A或更高版本编译时改变其行为,以下限制适用。如果你覆盖了一个在R14A之前的OTP版本(ERTS 5.8版本)中自动导入的BIF的名称,并且在你的代码中对该函数有一个隐式限定的调用,你需要使用编译器指令显式地删除自动导入,或者用一个完全限定的函数调用替换该调用。否则你会得到一个编译错误。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="0d770aae36addee1e6eb41cd37aaf79237dbd85a" translate="yes" xml:space="preserve">
          <source>However, what reservation of physical memory actually means highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behaviour.</source>
          <target state="translated">然而,保留物理内存的实际意义很大程度上取决于操作系统,以及它是如何配置的。例如,在Linux上不同的内存超占设置会极大地改变行为。</target>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">但是，例如在使用IA5String（与ASCII非常相似）时，字节65（以十进制表示）&lt;strong&gt;表示&lt;/strong&gt;字符'A'。</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">Http客户端服务启动/停止</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Http数据类型</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">连字符(只有在它可以被解释为指定范围的情况下)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">SMIv2中允许使用连字符(一种务实的方法)。原因是根据SMIv2,从SMIv1转换而来的对象允许使用连字符,但其他对象不允许。这对于编译器来说是无法检查的。</target>
        </trans-unit>
        <trans-unit id="c5bc42a4cab12cb2ea8fc597fa696281af9382e3" translate="yes" xml:space="preserve">
          <source>I will only present the most important functions in the API here.</source>
          <target state="translated">我在这里只介绍API中最重要的功能。</target>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">I/O错误。</target>
        </trans-unit>
        <trans-unit id="629b47de797063a0b6b561c862c608954c3da6aa" translate="yes" xml:space="preserve">
          <source>I/O from a function called in an Erlang ssh daemon</source>
          <target state="translated">在Erlang ssh守护进程中调用的函数的I/O。</target>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">I/O是目前Unicode最棘手的领域。文件是一个存储字节的实体,而编程的传说是把字符和字节当作可以互换的。对于Unicode字符,当你想在文件中存储数据时,你必须决定一个编码。在Erlang中,你可以打开一个带有编码选项的文本文件,这样你就可以从文件中读取字符而不是字节,但你也可以打开一个文件进行字节式I/O。</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">I/O库功能。</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">I / O服务器的行为略有不同。无论使用哪种编码选项，连接到终端（或 &lt;code&gt;stdout&lt;/code&gt; ）的I / O服务器通常都可以处理Unicode数据。当人们期望使用现代环境，而又不想在写入古老的终端或管道时崩溃时，这很方便。</target>
        </trans-unit>
        <trans-unit id="2b536593017ca7fbb86fdac576736ff840ff5f41" translate="yes" xml:space="preserve">
          <source>I/O signals may however be aborted. This could be solved by letting the port specific scheduling lock also protect the private task data structure, but then the port very frequently would have to fight with others enqueueing new tasks. In order to handle this while keeping the private task data structure lock free, we use a similar &quot;non aggressive&quot; approach as we use when handling processes that gets suspended while in the run queue. Instead of removing the aborted port task, we just mark it as aborted using an atomic memory operation. When a task is selected for execution, we first verify that it has not been aborted. If aborted we, just drop the task.</source>
          <target state="translated">然而I/O信号可能会被中止。这可以通过让 port 特定的调度锁保护私有任务数据结构来解决,但这样一来,port 将不得不频繁地与其它 enqueue 新任务进行斗争。为了在保持私有任务数据结构锁自由的同时处理这个问题,我们使用了类似于处理在运行队列中被暂停的进程时使用的 &quot;非激进 &quot;方法。我们没有删除中止的 port 任务,而是使用原子内存操作将其标记为中止。当一个任务被选中执行时,我们首先验证它是否被中止。如果中止了我们,就直接放弃这个任务。</target>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">整个系统中的I / O服务器可以处理Unicode数据，并具有用于在设备输出或输入时转换数据的选项。如前所述， &lt;code&gt;shell&lt;/code&gt; 模块支持Unicode终端， &lt;code&gt;file&lt;/code&gt; 模块允许与磁盘上的各种Unicode格式进行相互转换。</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">IANA的考虑因素</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC(Erlang IDL Compiler)是一个接口生成器,给定一个IDL接口规范,它可以自动生成Erlang、C或Java的存根代码。请参阅《IC用户指南》和《IC参考手册》。</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">IC文件。它运行IDL编译器。</target>
        </trans-unit>
        <trans-unit id="881271d3bb93e752931432a69d275e6c5c697b27" translate="yes" xml:space="preserve">
          <source>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them.</source>
          <target state="translated">IDEA密码套件不被支持,因为它们已经被TLS 1.2规范所废弃,所以它没有动力去实现它们。</target>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF--该协议称为Megaco。</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG(Interface Generator)自动生成Erlang程序和C程序之间的端口或套接字通信代码,给定一个带有某些关键字的C头文件。</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-从Erlang/OTP R6B中删除。</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP(CORBA)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">INTEGER,INT,SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">IP地址， &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4e4f4977f53cb13c9e71db88ccd9dabd0d8c68" translate="yes" xml:space="preserve">
          <source>IP v4 address and nodename.</source>
          <target state="translated">IP v4地址和nodename。</target>
        </trans-unit>
        <trans-unit id="a762fd412e63e6cdda70621754e625a105c877a8" translate="yes" xml:space="preserve">
          <source>IP v4 address.</source>
          <target state="translated">IP v4地址。</target>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">将主机地址指定为 &lt;code&gt;any&lt;/code&gt; IP地址时使用的IP版本。</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">IPsec对直径是透明的。</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1（0-255，每个字节一个字符）。在此，将案例参数 &lt;code&gt;InEncoding&lt;/code&gt; 指定为 &lt;code&gt;latin1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">国际电联--该组织将该协议称为H.248。</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;ssh&lt;/code&gt; 通道的ID 。</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">理想情况下,你的代码只包含第一种类型的高效代码。如果发现太慢,可以对应用程序进行剖析,找出性能瓶颈所在,只优化瓶颈。让其他代码尽可能的保持干净。</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">所标识的处理器状态在不同的操作系统上可能有所不同，并且可能在同一操作系统的不同版本的 &lt;code&gt;cpu_sup&lt;/code&gt; 之间更改。但是，在所有繁忙和所有非繁忙处理器状态下所花费的CPU周期百分比份额的总和将始终总计为100％。</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="c4b828ddf628f41cc4d390c6deaa0302ac12c3dd" translate="yes" xml:space="preserve">
          <source>Identifies a TLS session.</source>
          <target state="translated">识别一个TLS会话。</target>
        </trans-unit>
        <trans-unit id="75bb32d0a7ac84997a35ee28f73ca250b15a818d" translate="yes" xml:space="preserve">
          <source>Identifies a counter array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标识从 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 返回的计数器数组。</target>
        </trans-unit>
        <trans-unit id="99d9be73f1ae427426eb7dad6ec17364635870b5" translate="yes" xml:space="preserve">
          <source>Identifies an atomic array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标识从 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 返回的原子数组。</target>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">标识并返回在缓冲区中编码的Erlang术语的类型。它跳过尾随的&lt;strong&gt;魔术&lt;/strong&gt;标识符。</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">标明文件所在的文件系统。在Windows中,数字表示一个驱动器,如下所示。0表示A:,1表示B:,以此类推。</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">标识要使用的密钥。格式取决于加载的引擎。它被传递到libcrypto中的 &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">确定要按什么信息排序。</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">通过数字来识别捕捉小括号是很简单的,但在复杂的正则表达式中很难跟踪数字。另外,如果修改了表达式,数字也会发生变化。为了帮助解决这个困难,PCRE支持子模式的命名。这个功能直到5.10版本才被添加到Perl中。Python更早有这个功能,PCRE在4.0版本时就引入了这个功能,使用的是Python语法。现在PCRE同时支持Perl和Python语法。Perl允许相同编号的子模式有不同的名字,但PCRE不允许。</target>
        </trans-unit>
        <trans-unit id="86dd18440c1a33a5adeeb3446934c0824c7a25f8" translate="yes" xml:space="preserve">
          <source>Identity of connection or session configuration in a configuration file.</source>
          <target state="translated">配置文件中连接或会话配置的标识。</target>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">意识形态空间</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">如果(*ACCEPT)在捕获括号内,则捕获到目前为止的数据。例如,下面匹配 &quot;AB&quot;、&quot;AAD &quot;或 &quot;ACD&quot;。当符合 &quot;AB &quot;时,&quot;B &quot;被外括号捕获。</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">如果（* COMMIT）是唯一遇到的回溯动词，则在传递完后， &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 会在当前起始点或根本不寻找匹配项，例如：</target>
        </trans-unit>
        <trans-unit id="4f0f3a8fd87c3eaeb73231280dec7eb243d5903c" translate="yes" xml:space="preserve">
          <source>If +MMscrpm is set to true, which is default, the initial allocation will reserve physical memory for the entire super carrier. This can be used by users that want to ensure a certain &lt;strong&gt;minimum&lt;/strong&gt; amount of physical memory for the VM.</source>
          <target state="translated">如果默认将+ MMscrpm设置为true，则初始分配将为整个超级载波保留物理内存。想要确保VM的&lt;strong&gt;最小&lt;/strong&gt;物理内存量的用户可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="40ba26284bd6bedd0128033397652d534ba6ab6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">如果 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;latin1&lt;/code&gt; ，则不翻译路径名。</target>
        </trans-unit>
        <trans-unit id="66bd65b9d1cb2983119740d6067afd32e3a7d58b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">如果 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;utf8&lt;/code&gt; ，则在创建tar文件时将路径名编码为UTF-8，而在提取tar文件时将假定路径名以UTF-8进行编码。</target>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Kernel&lt;/code&gt; 中的 &lt;code&gt;global&lt;/code&gt; 模块已知 &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; ，则将返回一个Erlang pid，可用于将消息发送到计划服务。同样，将 &lt;code&gt;node&lt;/code&gt; 初始化为包含注册服务的节点的名称，以便您可以通过简单地将变量传递给 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 来与其建立连接。</target>
        </trans-unit>
        <trans-unit id="1dd779b7143c0739432543164284fa524cccd2f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is written to the_pid. This pid that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Kernel&lt;/code&gt; 中的 &lt;code&gt;global&lt;/code&gt; 模块已知 &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; ，则将Erlang pid写入the_pid。该pid可用于将消息发送到计划服务。另外，将 &lt;code&gt;node&lt;/code&gt; 初始化为包含注册服务的节点的名称，以便您可以通过简单地将变量传递给 &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; 来建立与该节点的连接。</target>
        </trans-unit>
        <trans-unit id="9e26772d0fb234e217566d6d19fae8939ae23412" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; ，则所有事件都在 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 中处理，我们可以（但不必）使用以事件为中心的方法，在该方法中，我们首先根据事件进行分支，然后根据状态进行分支： &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">如果使用了 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; ，则所有事件都在 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 中处理，我们可以（但不必）使用以事件为中心的方法，在该方法中，我们首先根据事件进行分支，然后根据状态进行分支：</target>
        </trans-unit>
        <trans-unit id="bebc3f9361919a37bdadad08140e7c6cde4d32d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no &lt;strong&gt;state enter calls&lt;/strong&gt; are done.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 没有返回这样的列表，则没有&lt;strong&gt;状态回车&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 没有返回这样的列表，则没有状态回叫完成。</target>
        </trans-unit>
        <trans-unit id="f1ede23ffb5bebc5707015ac6f688b4dfda3fb06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every &lt;strong&gt;state change&lt;/strong&gt;, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; or &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt;, depending on the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. This may look like an event but is really a call performed after the previous &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returned and before any event is delivered to the new &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; tuple from the &lt;strong&gt;state callback&lt;/strong&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 返回一个包含 &lt;code&gt;state_enter&lt;/code&gt; 的列表，则 &lt;code&gt;gen_statem&lt;/code&gt; 引擎将在每次&lt;strong&gt;状态更改时&lt;/strong&gt;使用参数 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; 或 &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，具体取决于 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 。这可能看起来像一个事件，但实际上是在先前的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 返回之后，任何事件传递到新的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 之前执行的&lt;strong&gt;调用&lt;/strong&gt;。参见 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 。可以通过返回 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; 来重复进行这样的调用&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;或来自&lt;strong&gt;状态回调的&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; 元组。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 返回包含 &lt;code&gt;state_enter&lt;/code&gt; 的列表，则 &lt;code&gt;gen_statem&lt;/code&gt; 引擎将在每次状态更改时使用参数 &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。这可能看起来像一个事件，但实际上是在先前的状态回调返回之后，任何事件传递到新的状态回调之前执行的调用。参见 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 。可以通过从状态回调返回 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 元组来重复此调用。</target>
        </trans-unit>
        <trans-unit id="c28ef58b982d1f354c9c1bb974e90b1d95e0f6b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a &lt;strong&gt;state change&lt;/strong&gt;, which will not cause a &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 应该转换状态，则将其视为状态重命名而不是&lt;strong&gt;状态更改&lt;/strong&gt;，这不会导致&lt;strong&gt;状态回车&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; 应该转换状态，则将其视为状态重命名而不是状态更改，这不会引起状态回车。</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则当前事件被推迟。</target>
        </trans-unit>
        <trans-unit id="af5f4ef54abaee17eded82e21fef9696e20a28ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and either it is the initial state or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; is used the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the current state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; ，并且它是初始状态，或者是回调结果之一 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; ,则 &lt;code&gt;gen_statem&lt;/code&gt; 引擎会使用参数 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; （取决于 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ），并在返回时再次从此序列的顶部开始。 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd474c164e6c98dd34c39ad22b25553a62777256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and the state changes the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; ，并且状态更改，则 &lt;code&gt;gen_statem&lt;/code&gt; 引擎使用参数 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; （取决于 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ）调用新的状态回调，并在返回时重新开始从此序列的顶部开始。 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，并且是：状态更改，它是初始状态，或者使用回调结果 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; 中的一个；在 &lt;code&gt;gen_statem&lt;/code&gt; 调用带有参数的新状态回调 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; ，则只使用一个系统配置文件，而该文件称为 &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51507c4f6a07b6ee28c5c354867983982dadbd0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; for details.</source>
          <target state="translated">如果 &lt;code&gt;Abs&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则启动一个绝对计时器，如果为 &lt;code&gt;false&lt;/code&gt; ，则为一个相对值，这是默认值。有关详细信息，请参见 &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">如果 &lt;code&gt;Abs&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则启动一个绝对计时器，如果为 &lt;code&gt;false&lt;/code&gt; ，则为一个相对值，这是默认值。有关详细信息，请参见 &lt;code&gt;erlang:start_timer/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">如果 &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; ，则 &lt;code&gt;Suspendee&lt;/code&gt; 者当前处于挂起状态。</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Alg&lt;/code&gt; 是 &lt;code&gt;crypto&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; 则此函数的行为与rand_seed_s / 0完全相同。</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">如果 &lt;code&gt;Alg&lt;/code&gt; 是 &lt;code&gt;crypto_cache&lt;/code&gt; ,则此函数使用OpenSSL的 &lt;code&gt;RAND_bytes&lt;/code&gt; 获取随机数据，并使用56位内部字长将其高速缓存，这使得在64位计算机上的计算速度更快。</target>
        </trans-unit>
        <trans-unit id="81e735d9039bbf6127ac283e19b140ef66799a72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1Type&lt;/code&gt; is &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt; must be either an &lt;code&gt;rsa_public_key()&lt;/code&gt;, &lt;code&gt;dsa_public_key()&lt;/code&gt; or an &lt;code&gt;ec_public_key()&lt;/code&gt; and this function creates the appropriate &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; entry.</source>
          <target state="translated">如果 &lt;code&gt;Asn1Type&lt;/code&gt; 为 &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ，则 &lt;code&gt;Entity&lt;/code&gt; 必须为 &lt;code&gt;rsa_public_key()&lt;/code&gt; ， &lt;code&gt;dsa_public_key()&lt;/code&gt; 或 &lt;code&gt;ec_public_key()&lt;/code&gt; ,并且此函数将创建适当的 &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">如果 &lt;code&gt;Asn1module&lt;/code&gt; 是不带扩展名的文件名，则首先假定为 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; ，然后为 &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; ，最后为 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; （与旧的ASN.1编译器兼容）。 &lt;code&gt;Asn1module&lt;/code&gt; 可以是完整路径名（相对或绝对），包括带（或不带）扩展名的文件名。</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">如果 &lt;code&gt;Bin&lt;/code&gt; 不包含整个数据包，则返回 &lt;code&gt;{more,Length}&lt;/code&gt; 。 &lt;code&gt;Length&lt;/code&gt; 是预期的数据包&lt;strong&gt;总大小&lt;/strong&gt;，如果预期的数据包大小未知，则为 &lt;code&gt;undefined&lt;/code&gt; 。然后可以在添加更多数据的情况下再次调用 &lt;code&gt;decode_packet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">如果省略 &lt;code&gt;BinRel1&lt;/code&gt; ,则改为使用 R [i]范围（范围R [1]&amp;times;...&amp;times;范围R [n]）的 &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; 元素之间的相等关系（直觉上，什么都不是&amp;ldquo;丢失&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;Binaries&lt;/code&gt; 不是二进制的固定列表，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">如果 &lt;code&gt;Binary&lt;/code&gt; 包含模块 &lt;code&gt;Module&lt;/code&gt; 的目标代码，则此BIF加载该目标代码。如果模块 &lt;code&gt;Module&lt;/code&gt; 的代码已经存在，则将替换所有导出引用，以便它们指向新加载的代码。先前加载的代码将作为旧代码保留在系统中，因为仍然会有执行该代码的进程。</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">如果 &lt;code&gt;BlockState =:= block&lt;/code&gt; ，则会阻止多调度。也就是说，将执行一个并且只有一个调度程序线程。如果 &lt;code&gt;BlockState =:= unblock&lt;/code&gt; 并且没有其他人阻止多重调度，并且此过程仅被阻止一次，则多重调度将被解除阻止。</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">如果 &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; ，则会阻止常规多调度。也就是说，将仅执行一个正常的调度程序线程，但可以执行多个脏调度程序。如果 &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; 并且没有其他人阻止正常的多调度，并且此过程仅阻塞了一次，则正常的多调度将被取消阻塞。</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">如果返回 &lt;code&gt;Body&lt;/code&gt; 并等于 &lt;code&gt;{Fun,Arg}&lt;/code&gt; ，则Web服务器将以 &lt;code&gt;Arg&lt;/code&gt; 作为参数尝试对 &lt;code&gt;Fun&lt;/code&gt; &lt;code&gt;apply/2&lt;/code&gt; 。 web服务器期望的乐趣或者返回一个列表 &lt;code&gt;(Body)&lt;/code&gt; ，其为HTTP repsonse，或原子 &lt;code&gt;sent&lt;/code&gt; 如果HTTP响应被发送回客户端。如果从乐趣中返回了 &lt;code&gt;close&lt;/code&gt; ，则出了点问题，服务器通过关闭连接向客户端发出信号。</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">如果 &lt;code&gt;Bool&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则 &lt;code&gt;rb&lt;/code&gt; 对于遇到的每个错误报告，都会向 &lt;code&gt;stdout&lt;/code&gt; 打印一条错误消息，但是日志记录过程永远不会结束。所有可打印的报告均已写入。如果启用了记录到文件的功能，则 &lt;code&gt;rb&lt;/code&gt; 在日志文件中不可打印报告的位置打印 &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">如果 &lt;code&gt;Bool&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，如果遇到格式错误的报告，则 &lt;code&gt;rb&lt;/code&gt; 停止日志记录（并向 &lt;code&gt;stdout&lt;/code&gt; 输出错误消息）。如果启用了记录到文件的功能，则错误消息也会附加到日志文件中。</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">如果 &lt;code&gt;Boolean == true&lt;/code&gt; ，则为套接字打开选项 &lt;code&gt;TCP_NODELAY&lt;/code&gt; ，这意味着也会立即发送少量数据。</target>
        </trans-unit>
        <trans-unit id="694f121851d48acf6a07239b2f70a6b720fe0aa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, the corresponding option is turned on for the socket, which means that small amounts of data are accumulated until a full MSS-worth of data is available or this option is turned off.</source>
          <target state="translated">如果 &lt;code&gt;Boolean == true&lt;/code&gt; ，则为套接字打开相应的选项，这意味着将累积少量数据，直到可获得完整的MSS数据为止或关闭此选项。</target>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Button&lt;/code&gt; 是顶级类型，并且需要从解码中排除组件 &lt;code&gt;number&lt;/code&gt; ，则配置文件中指令中的 &lt;code&gt;Type_List&lt;/code&gt; 为 &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; 。如果您调用解码函数 &lt;code&gt;decode_Button_exclusive&lt;/code&gt; ，则 &lt;code&gt;Decode_Instruction&lt;/code&gt; 为 &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; }。</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">如果 &lt;code&gt;Common Test&lt;/code&gt; Master最初未能连接到测试规范或 &lt;code&gt;InclNodes&lt;/code&gt; 列表中指定的任何测试节点，则会提示操作员选择重新开始（手动检查相关节点的状态之后）的选项，在没有丢失节点的情况下运行，或者中止该操作。</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">如果 &lt;code&gt;CurrentIndentation&lt;/code&gt; 为负，则不存在换行符，仅将空格用作分隔符。</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">如果 &lt;code&gt;Data&lt;/code&gt; 是无效的I / O列表。</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Dates&lt;/code&gt; 的格式为 &lt;code&gt;{DateTo, to}&lt;/code&gt; ，则显示在 &lt;code&gt;DateTo&lt;/code&gt; 之前发生的报告。</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; ，则它必须是在当前运行时系统实例上创建的进程的 &lt;code&gt;pid()&lt;/code&gt; 。此过程已终止或未终止。如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;atom()&lt;/code&gt; ，则将其解释为本地注册进程的名称。在计时器到期时会查询名称所指的过程。如果名称不引用进程，则不会返回任何错误。</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;pid()&lt;/code&gt; ，则如果 &lt;code&gt;pid()&lt;/code&gt; 所引用的进程未激活或退出，计时器将自动取消。ERTS 5.4.11中引入了此功能。请注意，当 &lt;code&gt;Dest&lt;/code&gt; 是 &lt;code&gt;atom()&lt;/code&gt; 时，计时器不会自动取消。</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Destination&lt;/code&gt; 引用文件名，则在复制之前将其以 &lt;code&gt;write&lt;/code&gt; 模式添加到模式列表之前打开，并在完成后关闭。</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">如果 &lt;code&gt;Dir&lt;/code&gt; 不存在</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;Distributed == default&lt;/code&gt; ，则使用内核配置参数 &lt;code&gt;distributed&lt;/code&gt; 中的应用程序值。</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">如果 &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; ，则该应用程序变为分布式。该参数会覆盖&amp;ldquo; &lt;code&gt;distributed&lt;/code&gt; &amp;rdquo;内核配置参数中应用程序的值。 &lt;code&gt;Application&lt;/code&gt; 必须是应用程序名称（与第一个参数相同）。如果节点崩溃并指定了 &lt;code&gt;Time&lt;/code&gt; ，则应用程序控制器将等待 &lt;code&gt;Time&lt;/code&gt; 毫秒，然后再尝试在另一个节点上重新启动应用程序。如果未指定 &lt;code&gt;Time&lt;/code&gt; ，则默认为 &lt;code&gt;0&lt;/code&gt; ，应用程序将立即重新启动。</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Encoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则在可能时将整数列表 &lt;code&gt;0..255&lt;/code&gt; 或包含纯字节的二进制文件发送回客户端。如果 &lt;code&gt;Encoding&lt;/code&gt; 是 &lt;code&gt;unicode&lt;/code&gt; ，则将具有整个Unicode范围内的整数的列表或以UTF-8编码的二进制文件发送到客户端。用户提供的函数始终会看到整数列表，而不会看到二进制列表，但是如果 &lt;code&gt;Encoding&lt;/code&gt; 为 &lt;code&gt;unicode&lt;/code&gt; ，则该列表可以包含大于255的数字。</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">如果 &lt;code&gt;End == close&lt;/code&gt; ，则当服务器关闭通道时，数据将返回给调用方。如果在此之前发生 &lt;code&gt;{timeout,Data}&lt;/code&gt; ，该函数将返回{timeout，Data}（其中， &lt;code&gt;Data&lt;/code&gt; 是到目前为止接收到的数据）。</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">如果 &lt;code&gt;End == timeout&lt;/code&gt; ，则期望超时，并且在超时的情况下和通道关闭时都返回 &lt;code&gt;{ok,Data}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">如果 &lt;code&gt;End&lt;/code&gt; 是一个有趣的事情，则使用一个参数调用此有趣的事情，即接收到的 &lt;code&gt;ssh_cm&lt;/code&gt; 消息中的数据值（请参阅 &lt;code&gt;ssh_connection(3)&lt;/code&gt; 。有趣的是返回 &lt;code&gt;true&lt;/code&gt; 结束接收操作（并返回到目前为止收集的数据） ）或 &lt;code&gt;false&lt;/code&gt; 以等待来自服务器的更多数据。即使提供了乐趣，如果服务器关闭通道，该函数也会立即返回。</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">如果ASN.1规范中不存在 &lt;code&gt;EnumTypeName&lt;/code&gt; ，则编译将以错误代码停止。</target>
        </trans-unit>
        <trans-unit id="bd759ced4b466f7b939196360d08509e4b762583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt; global:register_name/2&lt;/code&gt; 将事件管理器全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则未注册事件管理器。</target>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将事件管理器全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则未注册事件管理器。</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将事件管理器注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; ，则事件管理器将使用 &lt;code&gt;Module&lt;/code&gt; 表示的注册表进行注册。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出的功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现为在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="9ad87f8334c21e8f203f8f813c8a18649ff573f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;EventType&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; ，则呼叫者等待答复。通过在 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 中使用 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 返回，在 &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 中或通过调用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; ，可以从此 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 或任何其他&lt;strong&gt;状态回调中&lt;/strong&gt;发送答复。</target>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;EventType&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; ，则呼叫者等待答复。通过在 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 中使用 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 返回，在 &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; 中或通过调用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; ，可以从此 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 或任何其他状态回调中发送答复。</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果 &lt;code&gt;Expr1&lt;/code&gt; 计算为一个名称，但未注册该名称，则会发生 &lt;code&gt;badarg&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">如果 &lt;code&gt;ExprF&lt;/code&gt; 是一个原子，则称该函数是通过使用&lt;strong&gt;隐式限定函数名称&lt;/strong&gt;调用的。如果函数 &lt;code&gt;ExprF&lt;/code&gt; 是本地定义的，则将调用它。或者，如果从 &lt;code&gt;M&lt;/code&gt; 模块显式导入 &lt;code&gt;ExprF&lt;/code&gt; ，则调用 &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; 。如果 &lt;code&gt;ExprF&lt;/code&gt; 既未在本地声明，也未明确导入，则 &lt;code&gt;ExprF&lt;/code&gt; 必须是自动导入的BIF的名称。</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;log&lt;/code&gt; ，则允许匹配事件。如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;stop&lt;/code&gt; ，则匹配事件将停止。</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">如果 &lt;code&gt;Extra&lt;/code&gt; 是 &lt;code&gt;log&lt;/code&gt; ，则允许进度报告。如果 &lt;code&gt;Extra&lt;/code&gt; 的 &lt;code&gt;stop&lt;/code&gt; ，进度报告被停止。</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">如果 &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;P&lt;/code&gt; 或 &lt;code&gt;Pad&lt;/code&gt; 是 &lt;code&gt;*&lt;/code&gt; 字符，则 &lt;code&gt;Data&lt;/code&gt; 中的下一个参数用作值。例如：</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">如果 &lt;code&gt;FIPS_mode_set&lt;/code&gt; 返回 &lt;code&gt;no&lt;/code&gt; OpenSSL库不是FIPS启用，密码将不支持FIPS模式两种。</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family3&lt;/code&gt; 是家庭，使得索引集合等于索引集合的 &lt;code&gt;Family1&lt;/code&gt; ，和 &lt;code&gt;Family3&lt;/code&gt; [i]是之间的差 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; 如果[I] &lt;code&gt;Family2&lt;/code&gt; 映射I，否则 &lt;code&gt;Family1[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family3&lt;/code&gt; 是家庭，使得索引集合是的交集 &lt;code&gt;Family1&lt;/code&gt; ：S和 &lt;code&gt;Family2&lt;/code&gt; ：S指数集，和 &lt;code&gt;Family3&lt;/code&gt; [i]是的交点 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; [i]中。</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 和 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; ，那么 &lt;code&gt;Family3&lt;/code&gt; 是家庭使得指标集为联盟 &lt;code&gt;Family1&lt;/code&gt; ：S和 &lt;code&gt;Family2&lt;/code&gt; ：■索引集，以及 &lt;code&gt;Family3&lt;/code&gt; [i]是联盟 &lt;code&gt;Family1&lt;/code&gt; [i]和 &lt;code&gt;Family2&lt;/code&gt; [I]如果两者都映射i，否则映射 &lt;code&gt;Family1&lt;/code&gt; [i]或 &lt;code&gt;Family2&lt;/code&gt; [i]。</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I] 。</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集的二元关系 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I] 。</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对于每个i在索引集合的集合的集合 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]是所述 &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I ]。</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Family1&lt;/code&gt; [i]是对每个i的索引集合的集合的集合 &lt;code&gt;Family1&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]为所述 &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I ]。</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;Family2&lt;/code&gt; 是 &lt;code&gt;Family1&lt;/code&gt; 对索引集i上那些元素的 &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; ，这些元素对 &lt;code&gt;Fun&lt;/code&gt; 应用于 &lt;code&gt;Family1&lt;/code&gt; [i]返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;Fun&lt;/code&gt; 是一个元组 &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; ，然后 &lt;code&gt;Fun2&lt;/code&gt; 被施加到 &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Family1&lt;/code&gt; [I]，否则 &lt;code&gt;Fun&lt;/code&gt; 被施加到 &lt;code&gt;Family1&lt;/code&gt; [i]中。</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，然后 &lt;code&gt;Family2&lt;/code&gt; 是家庭用相同的索引集合为 &lt;code&gt;Family1&lt;/code&gt; 使得 &lt;code&gt;Family2&lt;/code&gt; [i]是调用的结果而 &lt;code&gt;SetFun&lt;/code&gt; 与 &lt;code&gt;Family1&lt;/code&gt; [I]作为参数。</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">如果 &lt;code&gt;Family1&lt;/code&gt; [i]是某个i的空集，则该过程将退出并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">如果 &lt;code&gt;Family&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;BinRel&lt;/code&gt; 是包含所有对（i，x）的二进制关系，使得i属于 &lt;code&gt;Family&lt;/code&gt; 的索引集，而x属于 &lt;code&gt;Family&lt;/code&gt; [i]。</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">如果 &lt;code&gt;File&lt;/code&gt; 没有指定，打开一个文件对话框，在故障转储可以选择。</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">如果无法运行 &lt;code&gt;FileName&lt;/code&gt; ，则会引发错误异常，并以POSIX错误代码为原因。操作系统之间的错误原因可能有所不同。通常，尝试运行未找到的程序时会引发错误 &lt;code&gt;enoent&lt;/code&gt; ，而当指定的文件不可执行时会引发 &lt;code&gt;eacces&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;FileName&lt;/code&gt; 的后缀表示目标文件（ &lt;code&gt;.beam&lt;/code&gt; ），则EUnit将尝试从指定的文件重新加载模块并进行测试。否则，假定该文件是包含测试规范的文本文件，将使用标准库函数 &lt;code&gt;file:path_consult/2&lt;/code&gt; 读取该文件。</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">如果 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 是 &lt;code&gt;string()&lt;/code&gt; ， &lt;code&gt;make_config/1&lt;/code&gt; 将使用 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 作为文件名。创建一个名为 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 的文件，并将配置写入该文件。如果 &lt;code&gt;FileNameOrIODev&lt;/code&gt; 是 &lt;code&gt;io_device()&lt;/code&gt; （请参阅模块 &lt;code&gt;io&lt;/code&gt; 的文档），则配置将被写入io设备。</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Filename&lt;/code&gt; 不是符号链接，则此函数返回与 &lt;code&gt;read_file_info/1&lt;/code&gt; 完全相同的结果。在不支持符号链接的平台上，此功能始终等效于 &lt;code&gt;read_file_info/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">如果 &lt;code&gt;Fix&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则调用过程将表 &lt;code&gt;Name&lt;/code&gt; 固定（一次以上），否则表将被释放。当固定过程终止时，该表也会被释放。</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;get&lt;/code&gt; ，则返回所有已记录事件的列表。</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 是 &lt;code&gt;print&lt;/code&gt; ，记录的事件被打印到 &lt;code&gt;standard_io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则开始新的订阅。如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则将停止所有使用相同 &lt;code&gt;Options&lt;/code&gt; 启动的先前订阅。如果两个选项列表包含相同的选项集，则认为它们是相同的。</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">如果 &lt;code&gt;Flags = all&lt;/code&gt; ，则设置所有可能的标志。</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;finish&lt;/code&gt; ，则处理暂挂输入，刷新暂挂输出，然后 &lt;code&gt;deflate/3&lt;/code&gt; 返回。之后，流上唯一可能的操作是 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">如果 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;full&lt;/code&gt; ，则与 &lt;code&gt;sync&lt;/code&gt; 一样刷新所有输出，并且重置压缩状态，以便如果先前的压缩数据已损坏或需要随机访问，则可以从此处重新开始解压缩。太频繁使用 &lt;code&gt;full&lt;/code&gt; 会严重降低压缩率。</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">如果将 &lt;code&gt;Flush&lt;/code&gt; 设置为 &lt;code&gt;sync&lt;/code&gt; ，则所有未决的输出都将刷新到输出缓冲区，并且输出在字节边界上对齐，以便解压缩器可以获取到目前为止可用的所有输入数据。刷新会降低某些压缩算法的压缩率。因此，仅在必要时使用它。</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">如果 &lt;code&gt;Force = true&lt;/code&gt; 那么即使无法加载先前的mib，代理也会继续尝试加载每个mib。小心使用。</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">如果 &lt;code&gt;Force = true&lt;/code&gt; 那么即使无法卸载先前的mib，代理也会继续尝试卸载每个mib。小心使用。</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; ， &lt;code&gt;et_viewer&lt;/code&gt; 应用程序ET中的et_viewer用于以图形方式显示跟踪日志。 &lt;code&gt;ttb&lt;/code&gt; 提供了一些不同的过滤器，可以从 &lt;code&gt;et_viewer&lt;/code&gt; 中的&lt;strong&gt;过滤器和缩放&lt;/strong&gt;菜单中选择。</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">如果 &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; ，则为每个跟踪消息调用 &lt;code&gt;Function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">如果未指定 &lt;code&gt;FormatHandler&lt;/code&gt; ，则使用默认处理程序将每个跟踪消息显示为文本行。</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">如果 &lt;code&gt;Forms&lt;/code&gt; 是 &lt;code&gt;form_list&lt;/code&gt; 以外的其他类型的语法树，则将使用 &lt;code&gt;recomment_tree/2&lt;/code&gt; 直接插入注释，并将该过程中剩下的任何注释作为后注释添加到结果中。</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">如果 &lt;code&gt;Fun(Item)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则将 &lt;code&gt;Item&lt;/code&gt; 复制到结果队列。如果返回 &lt;code&gt;false&lt;/code&gt; ，则不会复制 &lt;code&gt;Item&lt;/code&gt; 。如果返回列表，则在结果队列中插入列表元素而不是 &lt;code&gt;Item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是当地的乐趣， &lt;code&gt;Module&lt;/code&gt; 是其中的乐趣定义模块。</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是本地乐趣，则 &lt;code&gt;Name&lt;/code&gt; 是实现该乐趣的本地函数的名称。（此名称是由编译器生成的，仅供参考。由于它是本地函数，因此不能直接调用。）如果当前没有为乐趣而加载代码，则返回 &lt;code&gt;[]&lt;/code&gt; 而不是原子。</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是外部的乐趣， &lt;code&gt;Module&lt;/code&gt; 是乐趣指模块。</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是外部乐趣，则 &lt;code&gt;Name&lt;/code&gt; 是该乐趣所引用的导出函数的名称。</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">如果 &lt;code&gt;Function&lt;/code&gt; 将对象插入表中，或者另一个进程将对象插入表中，则这些对象&lt;strong&gt;可以&lt;/strong&gt;（取决于键顺序）包括在遍历中。</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">如果 &lt;code&gt;HandlerId&lt;/code&gt; 为 &lt;code&gt;default&lt;/code&gt; ，则此条目将修改默认处理程序，等效于调用</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;How == read&lt;/code&gt; 或 &lt;code&gt;Socket&lt;/code&gt; 端口没有缓冲传出数据，则套接字将立即关闭，并且 &lt;code&gt;Reason&lt;/code&gt; 中将返回遇到的任何错误。</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">如果不是 &lt;code&gt;How&lt;/code&gt; ,则没有记载的替代方法之一。</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;I&lt;/code&gt; 不是一个非负整数，或者如果数组具有固定的大小并且 &lt;code&gt;I&lt;/code&gt; 大于最大索引，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; ；比较 &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b40958d947f1e3e1dfb64d8ec37bb529fd8c2ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, no IV is used. This is intended for ciphers without an IV (nounce). See &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ，则不使用IV。该密码适用于无IV（无）的密码。参见 &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17757dd0369fed1b521cdc06c576ee0641e25d48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = undefined&lt;/code&gt;, the IV must be added by calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;IV = undefined&lt;/code&gt; ，则必须通过调用 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; 来添加IV 。这适用于需要为每种加密和解密更改IV（通知）的情况。参见 &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="192de0c6fdc2dc6ed90c9948b113d350638c9ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">如果 &lt;code&gt;IgnoreCase&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则该函数会在相等性测试之前即时进行 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">如果 &lt;code&gt;IgnoreCase&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则该函数会在相等性测试之前即时进行 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则只要在列表中找到大于255的整数，就会发生错误。</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则二进制文件只要包含整个字节，就始终有效，因为每个字节都属于有效的ISO Latin-1范围。</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 为 &lt;code&gt;latin1&lt;/code&gt; ，则参数 &lt;code&gt;Data&lt;/code&gt; 对应于 &lt;code&gt;iodata()&lt;/code&gt; 类型，但对于 &lt;code&gt;unicode&lt;/code&gt; ，参数 &lt;code&gt;Data&lt;/code&gt; 可以包含大于255的整数（超出ISO Latin-1范围的Unicode字符），使其作为 &lt;code&gt;iodata()&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 是Unicode类型，则无论何时发现以下任一情况，都会发生错误：</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">如果 &lt;code&gt;InEncoding&lt;/code&gt; 是UTF类型之一，则任何二进制文件中的字节必须在该编码中有效。</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Incr =:= 0&lt;/code&gt; 并且 &lt;code&gt;From =/= To&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">如果省略 &lt;code&gt;IpPort&lt;/code&gt; ,则使用 &lt;code&gt;162&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;IsDst == true&lt;/code&gt; ，则 &lt;code&gt;Localtime&lt;/code&gt; 时间位于夏令时，如果 &lt;code&gt;IsDst == false&lt;/code&gt; ，则不是。如果 &lt;code&gt;IsDst == undefined&lt;/code&gt; ，则底层操作系统可以猜测，这与调用 &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">如果 &lt;code&gt;Item&lt;/code&gt; 是无效的项目。</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;ItemList&lt;/code&gt; ，则结果为 &lt;code&gt;InfoTupleList&lt;/code&gt; 。所述 &lt;code&gt;InfoTuple&lt;/code&gt; S IN &lt;code&gt;InfoTupleList&lt;/code&gt; 包含与对应的 &lt;code&gt;Item&lt;/code&gt; 以相同的顺序作为S &lt;code&gt;Item&lt;/code&gt; 小号被列入 &lt;code&gt;ItemList&lt;/code&gt; 。有效 &lt;code&gt;Item&lt;/code&gt; 可以多次包含在 &lt;code&gt;ItemList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">如果 &lt;code&gt;Key&lt;/code&gt; 不存在，则创建一个新记录，如果该记录大于0，则该值 &lt;code&gt;Incr&lt;/code&gt; ，否则将其设置为0。</target>
        </trans-unit>
        <trans-unit id="c41410c8bc0b6250bb7c2a4f58129afe15bfcff0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; does not exist, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">如果 &lt;code&gt;Key&lt;/code&gt; 不存在，一个新的记录与价值创造 &lt;code&gt;Incr&lt;/code&gt; ，如果它是大于0，否则设置为0。</target>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">如果 &lt;code&gt;Map1&lt;/code&gt; 中存在 &lt;code&gt;Key&lt;/code&gt; ，则将旧的关联值替换为 &lt;code&gt;Value&lt;/code&gt; 。该函数返回包含新的关联值的新地图 &lt;code&gt;Map2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">如果 &lt;code&gt;KeyOrName&lt;/code&gt; 是与此ID关联的已配置 &lt;code&gt;server_id()&lt;/code&gt; 或 &lt;code&gt;target_name()&lt;/code&gt; ，则将从配置文件中获取此服务器的选项。</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">如果 &lt;code&gt;LinkTo&lt;/code&gt; 是一个pid，它将成为日志的所有者。如果 &lt;code&gt;LinkTo&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; ，则日志将通过增加 &lt;code&gt;users&lt;/code&gt; 计数器来记录该进程已匿名使用它。默认情况下，调用 &lt;code&gt;open/1&lt;/code&gt; 的进程拥有该日志。</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ListOfBinRels&lt;/code&gt; 是一个非空列表[R [1]，...，R [n]的]二元关系和 &lt;code&gt;BinRel1&lt;/code&gt; 是一个二元关系，然后 &lt;code&gt;BinRel2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; 的有序集合（R [I]的。 ..，R [n]）和 &lt;code&gt;BinRel1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">如果还有其他 &lt;code&gt;Loader&lt;/code&gt; ，则将启动用户提供的 &lt;code&gt;Loader&lt;/code&gt; 端口程序。</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是二进制文件， &lt;code&gt;tftp_binary&lt;/code&gt; 用作回调模块。将二进制文件逐块传输，并在 &lt;code&gt;LastCallbackState&lt;/code&gt; 中返回传输的字节数。</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且没有注册的回调模块， &lt;code&gt;tftp_file&lt;/code&gt; 用作回调模块。它逐块读取名为 &lt;code&gt;LocalFilename&lt;/code&gt; 的文件，并返回 &lt;code&gt;LastCallbackState&lt;/code&gt; 中传输的字节数。</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且没有注册的回调模块， &lt;code&gt;tftp_file&lt;/code&gt; 用作回调模块。它将每个传输的块写入名为 &lt;code&gt;LocalFilename&lt;/code&gt; 的文件，并返回 &lt;code&gt;LastCallbackState&lt;/code&gt; 中传输的字节数。</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是字符串，并且有已注册的回调模块，则针对这些模块的正则表达式测试 &lt;code&gt;LocalFilename&lt;/code&gt; ，并使用与第一个匹配项对应的回调模块，如果找不到匹配的regexp，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;LocalFilename&lt;/code&gt; 是 &lt;code&gt;tftp_binary&lt;/code&gt; &lt;code&gt;binary&lt;/code&gt; ，则将tftp_binary用作回调模块。它连接所有传输的块，并在 &lt;code&gt;LastCallbackState&lt;/code&gt; 中将它们作为一个二进制文件返回。</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;M&lt;/code&gt; 不是map类型，则抛出 &lt;code&gt;badmap&lt;/code&gt; 类型的异常。</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">如果在密钥交换中 &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; ，它将失败并断开连接。</target>
        </trans-unit>
        <trans-unit id="7c02225a551052905fddcfce82626e17b4c75202" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Message&lt;/code&gt; does not correspond to the response, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. If &lt;code&gt;Message&lt;/code&gt; corresponds to the response, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:check_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected.</source>
          <target state="translated">如果 &lt;code&gt;Message&lt;/code&gt; 与响应不对应，则返回原子 &lt;code&gt;no_response&lt;/code&gt; 。如果 &lt;code&gt;Message&lt;/code&gt; 对应于响应，则 &lt;code&gt;call&lt;/code&gt; 操作完成，并且结果作为 &lt;code&gt;{response, Result}&lt;/code&gt; 返回，其中 &lt;code&gt;Result&lt;/code&gt; 对应于从应用函数返回的值，或者引发异常。可以引发的异常与 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt; 可以引发的异常相同。也就是说，不会 &lt;code&gt;{erpc, timeout}&lt;/code&gt; 任何{erpc，timeout} &lt;code&gt;error&lt;/code&gt; 异常。如果/无效，则 &lt;code&gt;erpc:check_response()&lt;/code&gt; 将失败，并返回 &lt;code&gt;{erpc, badarg}&lt;/code&gt; 异常 &lt;code&gt;RequestId&lt;/code&gt; 检测到RequestId。</target>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">如果将 &lt;code&gt;Minutes&lt;/code&gt; 设置为 &lt;code&gt;infinity&lt;/code&gt; ，则由于经过了最大时间，因此不会发生重新键入密钥。将 &lt;code&gt;Bytes&lt;/code&gt; 设置为 &lt;code&gt;infinity&lt;/code&gt; 大将禁止在传输一定数量的数据后重新键入密钥。如果选项值设置为 &lt;code&gt;{infinity, infinity}&lt;/code&gt; ，则不会启动密钥更新。请注意，仍将执行由对等方发起的重新生成密钥。</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 检测到不一致的交易决策，则会生成 &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; 系统事件，以使应用程序有机会安装后备或其他适当的措施来解决不一致问题。 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序的默认行为与数据库由于分区网络而变得不一致时的行为相同（如前所述）。</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 在启动时检测到本地节点和另一个节点都相互接收 &lt;code&gt;mnesia_down&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 会生成 &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; 系统事件，并按照上一项所述操作。</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 可能由于电源故障而检测到文件未正确关闭，它将尝试以类似方式修复损坏的文件。数据可能会丢失，但是即使数据不一致， &lt;code&gt;Mnesia&lt;/code&gt; 也可以重新启动。配置参数 &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; 可用于控制启动时 &lt;code&gt;Mnesia&lt;/code&gt; 的行为。如果 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 尝试修复该文件。如果 &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 的值为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 如果检测到可疑文件，则不会重新启动。此配置参数影响日志文件 &lt;code&gt;DAT&lt;/code&gt; 的修复行为 文件和默认备份媒体。</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 尚未在事务中涉及的某些节点上启动，&lt;strong&gt;并且&lt;/strong&gt;本地节点或任何已经运行的节点都不知道事务的结果，则 &lt;code&gt;Mnesia&lt;/code&gt; 默认情况下等待一个。在最坏的情况下，所有其他涉及的节点必须先启动，然后 &lt;code&gt;Mnesia&lt;/code&gt; 才能对事务做出正确的决定并完成其启动。</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">如果 &lt;code&gt;Mnesia&lt;/code&gt; 发生故障，系统信息将转储到文件 &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; 。此文件中包含的系统信息的类型也可以使用函数 &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; 生成。如果 &lt;code&gt;Mnesia&lt;/code&gt; 系统的行为异常，建议在错误报告中包含 &lt;code&gt;Mnesia&lt;/code&gt; 核心转储文件。</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module2:init/1&lt;/code&gt; 返回正确的值，则此函数返回 &lt;code&gt;ok&lt;/code&gt; 。如果 &lt;code&gt;Module2:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回意外值 &lt;code&gt;Term&lt;/code&gt; ，则此函数分别返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 或 &lt;code&gt;{error,Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 失败或返回错误的元组或错误的值，则此函数返回 &lt;code&gt;{error,Errorr}&lt;/code&gt; ，其中 &lt;code&gt;Error&lt;/code&gt; 是带有有关错误的信息的术语，主管网桥以 &lt;code&gt;Error&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 失败或返回错误值，则此函数返回 &lt;code&gt;{error,Term}&lt;/code&gt; ，其中 &lt;code&gt;Term&lt;/code&gt; 是包含有关错误信息的术语，而主管则以 &lt;code&gt;Term&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 由于 &lt;code&gt;Reason&lt;/code&gt; 失败，则该函数返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;{stop,Reason}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; ，则进程终止，函数分别返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败，则此函数返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; ，则进程终止，此函数分别返回 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;ignore&lt;/code&gt; ，则此函数也返回 &lt;code&gt;ignore&lt;/code&gt; ，并且supervisor网桥终止，原因为 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回 &lt;code&gt;ignore&lt;/code&gt; ，此函数返回 &lt;code&gt;ignore&lt;/code&gt; 为好，并用原因主管终止 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;Module:init/1&lt;/code&gt; 返回指示成功完成的正确值，则事件管理器添加事件处理程序，并且此函数返回 &lt;code&gt;ok&lt;/code&gt; 。如果 &lt;code&gt;Module:init/1&lt;/code&gt; 因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回 &lt;code&gt;{error,Reason}&lt;/code&gt; ，则事件处理程序将被忽略，并且此函数分别返回 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; ，则common_test将尝试调用 &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; ，则common_test将尝试调用 &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">如果未导出 &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; ，则common_test将尝试改为调用 &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; 。这是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 是原子，而不是源文件的路径，则将搜索代码路径以找到该模块的目标文件，并提取其原始编译器选项和源路径。如果在原始位置找不到源文件，则使用 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 相对于目标文件的目录进行搜索。</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">如果解释了 &lt;code&gt;Module&lt;/code&gt; ，则调用解释器，并返回解释后的 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 调用的返回值。</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 已加载并且目标文件存在并且包含相同的代码。</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 已加载但没有本机代码</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">如果已加载 &lt;code&gt;Module&lt;/code&gt; ，但是在代码路径中找不到相应的目标文件。</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">如果已加载 &lt;code&gt;Module&lt;/code&gt; ，但是目标文件包含具有不同MD5校验和的代码。</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">如果未对 &lt;code&gt;Module&lt;/code&gt; 进行Cover Cover编译，则该函数返回 &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 不是原子。</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">如果当前未加载 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">如果未提供 &lt;code&gt;Module&lt;/code&gt; ，则将导出所有Cover编译或较早导入的模块的数据。</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">如果未加载 &lt;code&gt;Module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">如果 &lt;code&gt;Module&lt;/code&gt; 是已加载本机代码的已加载模块的名称</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 是原子（一个模块），则返回为 &lt;code&gt;Answer&lt;/code&gt; ，否则返回为列表 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 是原子（一个模块），则返回将为 &lt;code&gt;OneResult&lt;/code&gt; ，否则返回为 &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">如果 &lt;code&gt;Modules&lt;/code&gt; 没有给定，即在覆盖数据表中的数据的所有模块，进行了分析。请注意，这包括封面编译模块和导入模块。</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">如果 &lt;code&gt;Modules=dynamic&lt;/code&gt; ，这是事件管理器的情况，则事件管理器进程将当前已安装的事件处理程序列表（ &lt;code&gt;gen_event&lt;/code&gt; ）通知发布处理程序，并检查模块名称是否在此列表中。</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">如果 &lt;code&gt;MonitorPid&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;MonitorPid&lt;/code&gt; 不是本地进程。</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">如果 &lt;code&gt;MonitorRef&lt;/code&gt; 是通过调用 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 获得的调用过程的引用，则将关闭此监视。如果监视已关闭，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; ，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; = 0，则该过程的呼叫保存功能被禁用，这是默认设置。只要设置了呼叫保存列表的大小，便会重置其内容。</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">如果使用 &lt;code&gt;Name&lt;/code&gt; （ &lt;code&gt;Key&lt;/code&gt; 的别名）来标识连接，则该名称可用作后续调用的连接参考。与 &lt;code&gt;Name&lt;/code&gt; 关联的一次只能建立一个打开的连接。如果使用 &lt;code&gt;Key&lt;/code&gt; ，则返回的句柄必须用于后续调用（可以使用 &lt;code&gt;Key&lt;/code&gt; 指定的配置数据打开多个连接）。</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 也是输入模块之一的名称，则来自该模块的代码将出现在结果代码的顶部，并且不会添加任何额外的&amp;ldquo;标题&amp;rdquo;注释。换句话说，将保留该模块的外观。</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 是 &lt;code&gt;ip_address()&lt;/code&gt; ，则将要查询的域名生成为标准反向 &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; IPv4地址的名称，或 &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; IPv6地址的名称。在这种情况下，您很可能希望使用 &lt;code&gt;Class = in&lt;/code&gt; 和 &lt;code&gt;Type = ptr&lt;/code&gt; ，但这不是自动完成的。</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;Name&lt;/code&gt; ，则将消息 &lt;code&gt;Msg&lt;/code&gt; 发送到相应的pid。pid也是函数的返回值。如果未找到名称，则该函数返回 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果找到 &lt;code&gt;Name&lt;/code&gt; ，则返回相应的pid。如果未找到名称，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 不是全局注册的名称，则调用函数将退出，原因为 &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 不是符号链接，则此函数返回与 &lt;code&gt;read_file_info/1&lt;/code&gt; 相同的结果。在不支持符号链接的平台上，此功能始终等效于 &lt;code&gt;read_file_info/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">如果找不到 &lt;code&gt;Name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83d7d8a185c6a27fcabc1c06a33f11f825598937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is set to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt; the node will be started in a special mode optimized to be the temporary client of another node. When enabled the node will request a &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; from the first node it connects to. In addition these distribution settings will be set:</source>
          <target state="translated">如果将 &lt;code&gt;Name&lt;/code&gt; 设置为&lt;strong&gt; &lt;code&gt;undefined&lt;/code&gt; ,则&lt;/strong&gt;该节点将以一种特殊模式启动，该模式已优化为另一个节点的临时客户端。启用后，该节点将从其连接到的第一个节点请求一个 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; 。此外，将设置以下分发设置：</target>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">如果 &lt;code&gt;Name&lt;/code&gt; 或 &lt;code&gt;Dir&lt;/code&gt; 无效</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">如果 &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; ，则 &lt;code&gt;net_ticktime&lt;/code&gt; 更改在过渡期结束时完成；否则在开始时。在过渡期间， &lt;code&gt;net_kernel&lt;/code&gt; 确保至少每 &lt;code&gt;MTTI&lt;/code&gt; 毫秒在所有连接上都有传出流量。</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;{update_paths,true}&lt;/code&gt; 安装了 &lt;code&gt;NewVsn&lt;/code&gt; ，则 &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; 返回 &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">如果 &lt;code&gt;NextState =/= State&lt;/code&gt; 则状态机将更改为新状态。一个 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; 如果允许执行，所有 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; 的重试。</target>
        </trans-unit>
        <trans-unit id="985454129fa65531f94519e19f8ec9b0b8e0bac3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; this is a &lt;strong&gt;state change&lt;/strong&gt; so the extra things &lt;code&gt;gen_statem&lt;/code&gt; does are: the event queue is restarted from the oldest &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt;, any current &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; is cancelled, and a &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed, if enabled.</source>
          <target state="translated">如果 &lt;code&gt;NextState =/= State&lt;/code&gt; 这是一个&lt;strong&gt;状态更改，&lt;/strong&gt;那么 &lt;code&gt;gen_statem&lt;/code&gt; 要做的&lt;strong&gt;其他&lt;/strong&gt;事情是：从最早的 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt; 重新开始事件队列，取消任何当前 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; ，并执行 &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; （如果启用）。</target>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 发生故障或不存在，则消息 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 将传递到该进程。如果某个进程对 &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 进行了两次调用并且 &lt;code&gt;Node&lt;/code&gt; 终止， &lt;code&gt;nodedown&lt;/code&gt; 两个nodedown消息传递给该进程。如果没有与 &lt;code&gt;Node&lt;/code&gt; 的连接，则尝试创建一个。如果失败，则传递 &lt;code&gt;nodedown&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 是 &lt;code&gt;new&lt;/code&gt; 则 &lt;code&gt;Options&lt;/code&gt; 也将添加到内核配置参数 &lt;code&gt;inet_dist_listen_options&lt;/code&gt; 和 &lt;code&gt;inet_dist_connect_options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 是连接的节点，则返回值与 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; 中的返回值相同，其中 &lt;code&gt;Sock&lt;/code&gt; 是 &lt;code&gt;Node&lt;/code&gt; 的分发套接字。</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">如果 &lt;code&gt;NodeRefs&lt;/code&gt; 的值为 &lt;code&gt;all_nodes&lt;/code&gt; ，则在所有指定的测试节点上执行操作或测试。（声明不带 &lt;code&gt;NodeRefs&lt;/code&gt; 元素的术语具有相同的效果）。如果 &lt;code&gt;NodeRefs&lt;/code&gt; 的值为 &lt;code&gt;master&lt;/code&gt; ，则该操作仅在 &lt;code&gt;Common Test&lt;/code&gt; Master节点上执行（即设置日志目录或安装事件处理程序）。</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;Nodename&lt;/code&gt; 是本地节点，则返回错误原因 &lt;code&gt;cant_add_local_node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88f13b4b4a78ad3eb8641157bd00453fceefb7e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Norm&lt;/code&gt; 不 &lt;code&gt;none&lt;/code&gt; 功能应用上的平等测试前飞正常化。有四种可用的规范化形式： &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Norm&lt;/code&gt; 不 &lt;code&gt;none&lt;/code&gt; 功能应用上的平等测试前飞正常化。有四种可用的规范化形式： &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 是一个列表，则该函数会在插入任何内容之前检查&lt;strong&gt;每个&lt;/strong&gt;键。除非表中没有列表中的&lt;strong&gt;所有&lt;/strong&gt;键，否则不会插入任何内容。像 &lt;code&gt;insert/2&lt;/code&gt; 一样，保证整个操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">如果 &lt;code&gt;Operation&lt;/code&gt; 不适合32位整数。</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">如果 &lt;code&gt;Operation&lt;/code&gt; 不适合32位整数。</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Opt&lt;/code&gt; 是任何原子，则除非原子字符串以 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 开头，否则它将解释为 &lt;code&gt;{Opt,true}&lt;/code&gt; ，使解释为 &lt;code&gt;{Opt,false}&lt;/code&gt; 。例如， &lt;code&gt;usevc&lt;/code&gt; 是 &lt;code&gt;{usevc,true}&lt;/code&gt; 的别名， &lt;code&gt;nousevc&lt;/code&gt; 是 &lt;code&gt;{usevc,false}&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">如果 &lt;code&gt;OptList&lt;/code&gt; 不是有效 &lt;code&gt;Opt&lt;/code&gt; 的正确列表。</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">如果未提供 &lt;code&gt;OptParams&lt;/code&gt; ，则使用默认值 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">如果 &lt;code&gt;Option&lt;/code&gt; 是无效的选项。</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 是无效的选项列表。</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 是无效的选项列表。</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">如果 &lt;code&gt;OptionList&lt;/code&gt; 不是列表。</target>
        </trans-unit>
        <trans-unit id="47de326f53be67167a635f5060809e5db271ba9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Options&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，则该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Options&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，则该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Options&lt;/code&gt; 是列表，则等效于 &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; ；否则，它等效于 &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; 。但是，直接使用此功能效率更高。</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">如果 &lt;code&gt;Options&lt;/code&gt; 不是 &lt;code&gt;[]&lt;/code&gt; ，则格式如下：</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">如果未指定 &lt;code&gt;Opts&lt;/code&gt; 或为 &lt;code&gt;[]&lt;/code&gt; ，则将删除 &lt;code&gt;ConfigFile&lt;/code&gt; 并创建一个新文件。如果 &lt;code&gt;Opts = [append]&lt;/code&gt; ，则不会删除 &lt;code&gt;ConfigFile&lt;/code&gt; 。新信息将附加在文件末尾。</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">如果指定了 &lt;code&gt;Out&lt;/code&gt; ，则 &lt;code&gt;FormatHandler&lt;/code&gt; 将文件描述符获取为 &lt;code&gt;Out&lt;/code&gt; 作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; ，则已使用 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的选项 &lt;code&gt;asynchronous&lt;/code&gt; ，并且 &lt;code&gt;Pid&lt;/code&gt; 尚未暂停被暂停的对象。</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Path&lt;/code&gt; 是目录 &lt;code&gt;default_index/2&lt;/code&gt; ，则它将开始搜索配置指令 &lt;code&gt;DirectoryIndex&lt;/code&gt; 中指定的资源或文件。如果找到合适的资源或文件，则将其附加到 &lt;code&gt;Path&lt;/code&gt; 的末尾，然后返回。 &lt;code&gt;Path&lt;/code&gt; 如果没有找到正确的档案返回不变，否则，如果 &lt;code&gt;Path&lt;/code&gt; 是不是一个目录。 &lt;code&gt;config_db()&lt;/code&gt; 是ETS表格式的服务器配置文件，如 &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">如果 &lt;code&gt;Pattern1&lt;/code&gt; 和 &lt;code&gt;Pattern2&lt;/code&gt; 是有效模式，则以下也是有效模式：</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;Pattern&lt;/code&gt; 不是二进制文件， &lt;code&gt;badarg&lt;/code&gt; 是长度大于0的二进制适当的平面列表，则会引发badarg异常。</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid2&lt;/code&gt; 不存在，则会立即发送'DOWN'消息，并将 &lt;code&gt;Reason&lt;/code&gt; 设置为 &lt;code&gt;noproc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;Pid2&lt;/code&gt; 因退出原因 &lt;code&gt;Reason&lt;/code&gt; 终止，则会向 &lt;code&gt;Pid1&lt;/code&gt; 发送&amp;ldquo; DOWN&amp;rdquo;消息：</target>
        </trans-unit>
        <trans-unit id="c802432eb292a24b574add89af76bf12c415ea21" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 等于 &lt;code&gt;self()&lt;/code&gt; ，并且未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则立即执行垃圾回收，即与调用 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt; 相同。否则，将垃圾收集请求发送到 &lt;code&gt;Pid&lt;/code&gt; 标识的进程，并将在适当的时候进行处理。如果未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则调用程序将阻塞，直到 &lt;code&gt;GCResult&lt;/code&gt; 可用并可以返回为止。</target>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 等于 &lt;code&gt;self()&lt;/code&gt; ，并且未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则立即执行垃圾回收，即与调用 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 相同。否则，将垃圾收集请求发送到 &lt;code&gt;Pid&lt;/code&gt; 标识的进程，并将在适当的时候进行处理。如果未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则调用程序将阻塞，直到 &lt;code&gt;GCResult&lt;/code&gt; 可用并可以返回为止。</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 等于 &lt;code&gt;self()&lt;/code&gt; ，并且未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则立即执行该操作。否则，将操作请求发送到 &lt;code&gt;Pid&lt;/code&gt; 标识的进程，并在适当时进行处理。如果未传递任何 &lt;code&gt;async&lt;/code&gt; 选项，则调用方将阻塞，直到 &lt;code&gt;CheckResult&lt;/code&gt; 可用并可以返回为止。</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 是I / O设备，即从 &lt;code&gt;open/2&lt;/code&gt; 返回的pid ，则此函数返回文件名，或者更确切地说：</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 不是本地进程。</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 不是节点本地进程标识符。</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 没有捕获退出，则 &lt;code&gt;Pid&lt;/code&gt; 本身会退出，原因是退出 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Pid&lt;/code&gt; 正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 并传递到 &lt;code&gt;Pid&lt;/code&gt; 的消息队列。</target>
        </trans-unit>
        <trans-unit id="946409162988d6dc1aff5bb11d67c23349fa4844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist and checking it is cheap, a &lt;code&gt;noproc&lt;/code&gt; error is raised. Currently, checking is cheap if the &lt;code&gt;PidOrPort&lt;/code&gt; is local and the caller does not trap exits (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果不存在 &lt;code&gt;PidOrPort&lt;/code&gt; 并检查它是否便宜，则会引发 &lt;code&gt;noproc&lt;/code&gt; 错误。当前，如果 &lt;code&gt;PidOrPort&lt;/code&gt; 是本地的并且调用方不捕获出口，则检查很便宜（请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">如果 &lt;code&gt;PidOrPort&lt;/code&gt; 不存在，则BIF的行为取决于调用进程是否正在捕获退出（请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">如果 &lt;code&gt;PidOrPort&lt;/code&gt; 不是现有的本地进程或端口。</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">如果 &lt;code&gt;Port == 0&lt;/code&gt; ，则底层操作系统分配一个空闲的UDP端口，请使用 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">如果 &lt;code&gt;Port == 0&lt;/code&gt; ，则底层OS分配可用的端口号，请使用 &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">如果 &lt;code&gt;Port&lt;/code&gt; 不是开放端口的标识符，也不是开放端口的注册名称。如果调用进程先前已链接到由 &lt;code&gt;Port&lt;/code&gt; 标识的已关闭端口，则可以保证在此 &lt;code&gt;badarg&lt;/code&gt; 异常发生之前，已发出来自该端口的退出信号。</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">如果 &lt;code&gt;Port&lt;/code&gt; 不是开放端口或开放端口的注册名称。</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;PosLen&lt;/code&gt; 以任何方式引用了二进制文件之外的内容，则会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Prefix&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; 的前缀，则将其删除并返回 &lt;code&gt;String&lt;/code&gt; 的其余部分，否则返回 &lt;code&gt;nomatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">如果 &lt;code&gt;QH2&lt;/code&gt; 是对 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 函数的调用（如 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 节中所定义），则 &lt;code&gt;gb_table:table/1&lt;/code&gt; 会为每个 &lt;code&gt;QH1&lt;/code&gt; 答案启动gb-tree的迭代器。然后，一一返回gb-tree的对象。在这种情况下，这可能是遍历表的最有效方法，因为它花费了最小的计算能力才能获得以下对象。但是，如果 &lt;code&gt;QH2&lt;/code&gt; 不是一个表，而是一个更复杂的QLC，则使用一些RAM内存来收集高速缓存中的答案会更加有效，特别是在答案很少的情况下。然后必须假设评估 &lt;code&gt;QH2&lt;/code&gt; 没有副作用，因此，如果仅对 &lt;code&gt;QH2&lt;/code&gt; 进行一次评估，查询的含义就不会改变。缓存答案的一种方法是首先评估 &lt;code&gt;QH2&lt;/code&gt; ，然后在查询中用答案列表替换 &lt;code&gt;QH2&lt;/code&gt; 。另一种方法是使用选项 &lt;code&gt;cache&lt;/code&gt; 。它表示为：</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Reason&lt;/code&gt; 是原子 &lt;code&gt;kill&lt;/code&gt; ，即，如果 &lt;code&gt;exit(Pid, kill)&lt;/code&gt; 被调用时，一个untrappable出口信号被发送到 &lt;code&gt;Pid&lt;/code&gt; ，其与退出原因无条件退出 &lt;code&gt;killed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">如果 &lt;code&gt;Reason&lt;/code&gt; 是原子 &lt;code&gt;normal&lt;/code&gt; ，则 &lt;code&gt;Pid&lt;/code&gt; 不会退出。如果正在捕获出口，则出口信号将转换为消息 &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; 并传递到其消息队列。</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;Receiver&lt;/code&gt; 的值为 &lt;code&gt;{Tag, Recv}&lt;/code&gt; ，则根据 &lt;code&gt;Recv&lt;/code&gt; 完成传递：</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">如果 &lt;code&gt;Receiver&lt;/code&gt; 是 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 记录，则将根据 &lt;code&gt;notification_delivery_info()&lt;/code&gt; 记录的内容，通过 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 行为定义的回调函数将有关通知传递的信息传递给 &lt;code&gt;receiver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">如果 &lt;code&gt;RegName&lt;/code&gt; 已经被使用。</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;RegName&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 的原子。</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">如果 &lt;code&gt;Repair&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则根据需要修复当前日志文件。启动恢复时，错误日志上将输出一条消息。如果指定为 &lt;code&gt;false&lt;/code&gt; ，则不尝试自动修复。相反，如果尝试打开损坏的日志文件，则返回元组 &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; 。如果指定了 &lt;code&gt;truncate&lt;/code&gt; ，则日志文件将被截断，从而创建一个空日志。默认为 &lt;code&gt;true&lt;/code&gt; ，对以只读模式打开的日志没有影响。</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">如果 &lt;code&gt;Report&lt;/code&gt; 是地图，则在格式化之前将其转换为键值列表。</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">如果 &lt;code&gt;ReqId&lt;/code&gt; 小于0，则表示该信息对管理者不可用（该信息在丢弃消息之前从未检索过）。</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0，则数据包仅由 &lt;code&gt;[119, Result]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则找不到与 &lt;code&gt;TimerRef&lt;/code&gt; 对应的计时器。这是因为计时器已到期或被取消，或者因为 &lt;code&gt;TimerRef&lt;/code&gt; 从未对应于计时器。即使计时器已过期，它也不会告诉您超时消息是否已到达其目的地。</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则找不到与 &lt;code&gt;TimerRef&lt;/code&gt; 对应的计时器。这可能是因为计时器已到期，已被取消，或者是因为 &lt;code&gt;TimerRef&lt;/code&gt; 从未对应于计时器。即使计时器已过期，它也不会告诉您超时消息是否已到达其目的地。</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 是一个整数，则它表示直到取消的计时器到期之前还剩下的毫秒数。</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">如果 &lt;code&gt;Result&lt;/code&gt; 是一个整数，则它表示直到计时器到期为止的剩余时间（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Rules&lt;/code&gt; 被忽略或为空列表，则使用默认系统规则。另请参阅内核应用程序参数 &lt;code&gt;source_search_rules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">如果将 &lt;code&gt;Schedulers&lt;/code&gt; 或 &lt;code&gt;SchedulersOnline&lt;/code&gt; 指定为负数，则分别从已配置的逻辑处理器或可用逻辑处理器的默认数量中减去该值。</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">如果操作 &lt;code&gt;Scope&lt;/code&gt; 是 &lt;code&gt;local&lt;/code&gt; ，则后备仅安装在本地节点上。</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;self()&lt;/code&gt; ，则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; 一样创建一个匿名服务器。如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; ,则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; 一样创建一个命名服务器。但是，在调用此函数&lt;strong&gt;之前，&lt;/strong&gt;必须已相应注册了 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 名称。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c6410f6c768335757d34c90fcb80d9e00d2828e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;self()&lt;/code&gt; ，则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt; 一样，将创建一个匿名服务器。如果 &lt;code&gt;Server&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; ,则就像使用 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt; 一样，将创建一个命名服务器。但是，必须&lt;strong&gt;在&lt;/strong&gt;调用此函数&lt;strong&gt;之前&lt;/strong&gt;相应地注册 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 名称。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e26e129826cd4fdc57a94f1e90b9b33f3e22dc0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt; global:register_name/2&lt;/code&gt; 将 &lt;code&gt;gen_server&lt;/code&gt; 进程ID全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则不注册 &lt;code&gt;gen_server&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将 &lt;code&gt;gen_server&lt;/code&gt; 进程ID全局注册为 &lt;code&gt;GlobalName&lt;/code&gt; 。如果未提供名称，则不注册 &lt;code&gt;gen_server&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将 &lt;code&gt;gen_server&lt;/code&gt; 进程注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程向 &lt;code&gt;Module&lt;/code&gt; 表示的注册表注册。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出的功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">如果 &lt;code&gt;Server_or_Actions&lt;/code&gt; 是 &lt;code&gt;list()&lt;/code&gt; ，则与 &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 相同，除了不必注册任何 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 且 &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; 。这将创建一个匿名服务器。</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">如果 &lt;code&gt;SetFun&lt;/code&gt; 是编号i&amp;gt; = 1，并且 &lt;code&gt;Set1&lt;/code&gt; 是一个关系，则返回的集合是 &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Set1&lt;/code&gt; 到坐标我。</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是普通的 &lt;code&gt;socket()&lt;/code&gt; ：将 &lt;code&gt;gen_tcp&lt;/code&gt; 或等效套接字升级到SSL套接字，即执行SSL / TLS服务器端握手并返回TLS套接字。</target>
        </trans-unit>
        <trans-unit id="3a8532805c883f6bbdef2dbf1ab5fafde57ede65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是普通的 &lt;code&gt;socket()&lt;/code&gt; ：将 &lt;code&gt;gen_tcp&lt;/code&gt; 或等效套接字升级到SSL套接字，即执行TLS服务器端握手并返回TLS套接字。</target>
        </trans-unit>
        <trans-unit id="f51cfa021b587914b8d535a367aab8a9c4e3a8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt;: provides extra TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt; ：向 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 中指定的选项提供额外的TLS / DTLS选项，然后执行TLS / DTLS握手。如果握手成功，则返回新的TLS / DTLS套接字。</target>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">如果 &lt;code&gt;Socket&lt;/code&gt; 是 &lt;code&gt;sslsocket()&lt;/code&gt; ：为 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 中指定的选项提供额外的SSL / TLS / DTLS选项，然后执行SSL / TLS / DTLS握手。如果握手成功，则返回新的TLS / DTLS套接字。</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">如果 &lt;code&gt;Source&lt;/code&gt; 引用文件名，则它将以复制之前的模式列表之前的 &lt;code&gt;read&lt;/code&gt; 模式打开，并在完成时关闭。</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">如果 &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; ，则将为每个规范创建单独的测试。如果 &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; ，则所有规格将合并为一个测试。</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Streams&lt;/code&gt; 为空列表，则通过发送以下过滤器来请求&lt;strong&gt;所有&lt;/strong&gt;流：</target>
        </trans-unit>
        <trans-unit id="5a57f3a703460decb9f940e7b918e0ac60764ffe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt; global:register_name/2&lt;/code&gt; 将主管桥全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将主管桥全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; ，则使用 &lt;code&gt;register/2&lt;/code&gt; 在本地将主管网桥注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; ，则使用由Module表示的注册表将主管网桥注册为 &lt;code&gt;Name&lt;/code&gt; 。所述 &lt;code&gt;Module&lt;/code&gt; 的回调是导出功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，其是表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="e6570ba727a9a3893fd9a3d0b799b833bf1451e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt; global:register_name/2&lt;/code&gt; 将主管全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupName={global,Name}&lt;/code&gt; ，则使用 &lt;code&gt;global:register_name/2&lt;/code&gt; 将主管全局注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;SupName={local,Name}&lt;/code&gt; ，则主管使用 &lt;code&gt;register/2&lt;/code&gt; 在本地注册为 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">如果 &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; ，则使用 &lt;code&gt;Module&lt;/code&gt; 表示的注册表将主管注册为 &lt;code&gt;Name&lt;/code&gt; 。所述 &lt;code&gt;Module&lt;/code&gt; 的回调必须导出功能 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ，和 &lt;code&gt;send/2&lt;/code&gt; ，它必须表现得像在相应的功能 &lt;code&gt;global&lt;/code&gt; 。因此， &lt;code&gt;{via,global,Name}&lt;/code&gt; 是有效的引用。</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">如果 &lt;code&gt;Suspendee&lt;/code&gt; 不是进程标识符。</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">如果 &lt;code&gt;Term&lt;/code&gt; 和 &lt;code&gt;Pattern&lt;/code&gt; 可以匹配，则该函数返回一个非零值，并绑定 &lt;code&gt;Pattern&lt;/code&gt; 中所有未绑定的变量。如果 &lt;code&gt;Term&lt;/code&gt; 和 &lt;code&gt;Pattern&lt;/code&gt; 不匹配，则返回 &lt;code&gt;0&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 为 &lt;code&gt;infinity&lt;/code&gt; ，则不会启动任何计时器，因为它永远不会过期。</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 是相对的且 &lt;code&gt;0&lt;/code&gt; ,则实际上不启动任何计时器，而是将timeout事件排队，以确保在尚未接收到任何外部事件之前但在已排队的事件之后对其进行处理。</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">如果 &lt;code&gt;Time&lt;/code&gt; 是相对的且 &lt;code&gt;0&lt;/code&gt; ,则实际上没有启动任何计时器，而是将timeout事件排队，以确保在尚未收到任何外部事件之前对其进行处理。</target>
        </trans-unit>
        <trans-unit id="576d56f7b80afa9316129970fc76da4c8c90a6b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; will be returned, and the process is killed.</source>
          <target state="translated">如果将 &lt;code&gt;Time&lt;/code&gt; 指定为整数，则此函数将等待 &lt;code&gt;Time&lt;/code&gt; 毫秒，以便新进程调用 &lt;code&gt;init_ack&lt;/code&gt; ，否则将返回 &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; ，并且该进程将被终止。</target>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">如果将 &lt;code&gt;Time&lt;/code&gt; 指定为整数，则此函数将等待 &lt;code&gt;Time&lt;/code&gt; 毫秒以等待新进程调用 &lt;code&gt;init_ack&lt;/code&gt; ，否则将返回 &lt;code&gt;{error, timeout}&lt;/code&gt; ，并且该进程将被终止。</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">如果将 &lt;code&gt;Timeout&lt;/code&gt; 设置为以毫秒为单位的整数值，则Mnesia会强制完成&amp;ldquo;重量级交易&amp;rdquo;，即使目前尚不清楚交易的结果。后 &lt;code&gt;Timeout&lt;/code&gt; 毫秒，Mnesia的提交或终止交易，并启动继续。这可能导致事务在某些节点上提交而在其他节点上终止的情况。如果事务是架构事务，则不一致可能是致命的。</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; 并且 &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; 和 &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;TupleOfBinRels&lt;/code&gt; 为{R，... - [R [n]的[1]，}二元关系的一个非空的元组和 &lt;code&gt;BinRel1&lt;/code&gt; 是一个二元关系，然后 &lt;code&gt;BinRel2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; 的有序集合的（R [I]， ...，R [n]）和 &lt;code&gt;BinRel1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">如果 &lt;code&gt;Type = load&lt;/code&gt; ，则仅加载应用程序。</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">如果 &lt;code&gt;Type = none&lt;/code&gt; ，则尽管已加载其模块的代码，但该应用程序不会加载也不会启动。</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; ，以相应的方式加载和启动 &lt;code&gt;application(3)&lt;/code&gt; ，请参见application（3）。</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;file&lt;/code&gt; ，则客户端读取存储在名为 &lt;code&gt;Filename&lt;/code&gt; 的文件中或由 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 指定的所有跟踪消息（必须与创建跟踪时使用的跟踪消息相同，请参阅trace_port / 2），让我们使用默认处理程序函数在控制台上格式化消息。这是文件跟踪端口驱动程序解释存储在文件中的数据的一种方法。</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;follow_file&lt;/code&gt; ，则客户端的行为与 &lt;code&gt;file&lt;/code&gt; 情况相同，但会继续尝试从文件读取（并处理）更多数据，直到被 &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; 停止为止。 &lt;code&gt;WrapFilesSpec&lt;/code&gt; 不允许用作此 &lt;code&gt;Type&lt;/code&gt; 的第二个参数。</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;ip&lt;/code&gt; ，则客户端连接到主机 &lt;code&gt;Hostname&lt;/code&gt; 上的TCP / IP端口 &lt;code&gt;PortNumber&lt;/code&gt; ，从该主机读取跟踪消息，直到TCP / IP连接关闭。如果未指定 &lt;code&gt;Hostname&lt;/code&gt; ，则使用本地主机。</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;port&lt;/code&gt; ，则第二个参数应该是一个&lt;strong&gt;有趣的&lt;/strong&gt;函数，它不带任何参数，并且在调用时返回一个新打开的跟踪端口。最好通过调用 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 来产生这种&lt;strong&gt;乐趣&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;process&lt;/code&gt; ，则可以指定消息处理程序函数（ &lt;code&gt;HandlerSpec&lt;/code&gt; ）。对于每个跟踪消息，将调用处理程序函数，该函数应带有两个参数，这将是一个 &lt;code&gt;fun&lt;/code&gt; ，其中第一个参数按原样包含消息，第二个参数包含上次调用该乐趣时的返回值。第二个参数的初始值在 &lt;code&gt;HandlerSpec&lt;/code&gt; 的 &lt;code&gt;InitialData&lt;/code&gt; 部分中指定。该 &lt;code&gt;HandlerFun&lt;/code&gt; 可以选择任何适当的行动调用时采取，并且可以通过返回其保存为下次调用的状态。</target>
        </trans-unit>
        <trans-unit id="a4b1b3641b22ef8f8d51a93d3b2d1b2337213cb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;public_key&lt;/code&gt; the binary can be either an RFC4716 public key or an OpenSSH public key.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;public_key&lt;/code&gt; ,则二进制文件可以是RFC4716公共密钥或OpenSSH公共密钥。</target>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;table&lt;/code&gt; ，则要匹配的对象将是一个元组。然后 &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; 该函数返回{ok，Result，[]，Warnings}，其中 &lt;code&gt;Result&lt;/code&gt; 是真正的 &lt;code&gt;ets:select/2&lt;/code&gt; 调用中的结果，如果匹配说明与对象元组不匹配，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 为 &lt;code&gt;trace&lt;/code&gt; ，则要匹配的对象将是一个列表。该函数返回 &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; ，其中 &lt;code&gt;Result&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; 的描述中列出的内存类型之一。</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">如果返回 &lt;code&gt;[]&lt;/code&gt; ，则没有OS单调时间可用。该列表包含两个元组，其中 &lt;code&gt;Key&lt;/code&gt; 为第一个元素， &lt;code&gt;Value&lt;/code&gt; 为第二个元素。这些元组的顺序是不确定的。以下元组可以是列表的一部分，但将来可以引入更多的元组：</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">如果 &lt;code&gt;[node()]&lt;/code&gt; ,则如果在任何指定节点上已经存在另一个连接，则拒绝连接。类型 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;node&lt;/code&gt; ， &lt;code&gt;nodes&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 分别等效于 &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;[node()]&lt;/code&gt; ， &lt;code&gt;[node()|nodes()]&lt;/code&gt; 和求值，每当要建立新连接时，都会对每个表达式进行求值成立。请注意， &lt;code&gt;false&lt;/code&gt; 允许与同一对等方建立无限数量的连接。</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">如果将 &lt;code&gt;active&lt;/code&gt; 指定为-32768到32767（包括）之间的整数 &lt;code&gt;N&lt;/code&gt; ，则将该数字添加到套接字的要传递给控制过程的数据消息的计数中。如果相加结果为负，则将计数设置为 &lt;code&gt;0&lt;/code&gt; 。一旦计数达到 &lt;code&gt;0&lt;/code&gt; （通过传递消息或通过使用 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 显式设置），套接字模式将自动重置为被动（ &lt;code&gt;{active, false}&lt;/code&gt; ）。当处于此主动模式的套接字转换为被动模式时，将消息 &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; 发送到控制进程，以通知它如果要从套接字接收更多数据消息，则必须调用 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 将套接字重新设置为活动模式。</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">如果 &lt;code&gt;alloc&lt;/code&gt; 成功，则也会执行 &lt;code&gt;dealloc&lt;/code&gt; 。但是，如果 &lt;code&gt;alloc&lt;/code&gt; 失败，则不会执行 &lt;code&gt;dealloc&lt;/code&gt; ,而是在HTML日志中将其标记为 &lt;code&gt;SKIPPED&lt;/code&gt; 。无论 &lt;code&gt;alloc_and_dealloc&lt;/code&gt; 情况如何， &lt;code&gt;get_resource_status&lt;/code&gt; 都会运行。</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">如果为 &lt;code&gt;answer_3xxx&lt;/code&gt; ,则无需处理 &lt;code&gt;handle_request/3&lt;/code&gt; 回调即可应答请求。如果 &lt;code&gt;answer&lt;/code&gt; 则即使没有应答也可以回答5xxx错误，除非所讨论的连接配置了RFC 3588通用字典，如下所述。如果是 &lt;code&gt;callback&lt;/code&gt; 则始终执行 &lt;code&gt;handle_request/3&lt;/code&gt; 回调，并且其返回值确定发送给对等方的答案（如果有）。</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">如果 &lt;code&gt;audit_trail_log&lt;/code&gt; 指定应进行日志记录，则&lt;strong&gt;必须&lt;/strong&gt;定义此参数。</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;auto_ack&lt;/code&gt; 为true，则如果 &lt;code&gt;trans_ack&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则会立即发送ack。如果 &lt;code&gt;trans_ack&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则将ack发送到事务发送方进程进行累积并随后发送（请参见 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxsize&lt;/code&gt; ， &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 和 &lt;code&gt;trans_timer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">如果是 &lt;code&gt;callback&lt;/code&gt; 则错误 &lt;code&gt;handle_answer/4&lt;/code&gt; 与 &lt;code&gt;handle_request/3&lt;/code&gt; 相同的方式导致handle_answer / 4回调，并在传递给回调的 &lt;code&gt;#diameter_packet{}&lt;/code&gt; 的 &lt;code&gt;errors&lt;/code&gt; 字段中传达错误。如果 &lt;code&gt;report&lt;/code&gt; 则包含错误的答案将被丢弃，而不会进行回调，并且将警告报告写入日志。如果 &lt;code&gt;discard&lt;/code&gt; 则包含错误的答案将被静默丢弃，而不会进行回调。在 &lt;code&gt;report&lt;/code&gt; 和 &lt;code&gt;discard&lt;/code&gt; 情况下，所涉及的 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 调用的返回值都好像发生了回调并返回了 &lt;code&gt;{error, failure}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">如果 &lt;code&gt;ch4&lt;/code&gt; 是应用程序 &lt;code&gt;sp_app&lt;/code&gt; 的一部分，并且从该应用程序的版本&amp;ldquo; 1&amp;rdquo;升级到&amp;ldquo; 2&amp;rdquo;时要加载模块的新版本，则 &lt;code&gt;sp_app.appup&lt;/code&gt; 可以如下所示：</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;cp1&lt;/code&gt; 发生故障，系统将检查其他节点 &lt;code&gt;cp2&lt;/code&gt; 或 &lt;code&gt;cp3&lt;/code&gt; 中哪个节点具有最少数量的正在运行的应用程序，但要等待5秒钟才能重新启动 &lt;code&gt;cp1&lt;/code&gt; 。如果 &lt;code&gt;cp1&lt;/code&gt; 不重新启动和 &lt;code&gt;cp2&lt;/code&gt; 的运行速度比更少的应用程序 &lt;code&gt;cp3&lt;/code&gt; ， &lt;code&gt;myapp&lt;/code&gt; 被重启 &lt;code&gt;cp2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">如果使用选项 &lt;code&gt;-help&lt;/code&gt; 调用 &lt;code&gt;ct_run&lt;/code&gt; ，它将所有有效的开始标志 &lt;code&gt;stdout&lt;/code&gt; 到stdout。</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">如果 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 设置为与 &lt;code&gt;flush_qlen&lt;/code&gt; 相同的值，则丢弃模式将被禁用，并且永远不会发生。</target>
        </trans-unit>
        <trans-unit id="c399745e103b947fe1a2d216d913038686b47941" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; called then a connected emulator will send bit strings and export funs correctly encoded. The functions &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; has to be used to decode such terms. Calling &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs.</source>
          <target state="translated">如果&lt;strong&gt;未&lt;/strong&gt;调用 &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; ,则连接的仿真器将发送位字符串并导出正确编码的趣味。必须使用函数 &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; 来解码此类术语。调用 &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; 仅应作为一种解决方法，以保持旧的实现有效，该实现预期会收到未记录的元组格式以获取位字符串和/或导出乐趣。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_call/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_ports/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_procs/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_receive/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_running_ports/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_running_procs/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;enabled_send/3&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">如果将 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 之外的其他值，则如果数据包含的字符大于255 ，则 &lt;code&gt;read_line/1&lt;/code&gt; 调用将失败，为什么在读取此类文件时首选模块 &lt;code&gt;io(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">如果将 &lt;code&gt;epmd&lt;/code&gt; 用于节点发现，通常需要使用（不幸的是，未记录） &lt;code&gt;erl_epmd&lt;/code&gt; 模块（ &lt;code&gt;kernel&lt;/code&gt; 应用程序的一部分），以便向 &lt;code&gt;epmd&lt;/code&gt; 注册侦听端口并检索要使用的 &lt;code&gt;Creation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c86ec487c7e02fab4d117367477d9817cdcbd441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">如果将 &lt;code&gt;epmd&lt;/code&gt; 用于节点发现，通常需要使用 &lt;code&gt;erl_epmd&lt;/code&gt; 模块（ &lt;code&gt;kernel&lt;/code&gt; 应用程序的一部分），以便向 &lt;code&gt;epmd&lt;/code&gt; 注册侦听端口并检索要使用的 &lt;code&gt;Creation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;erl_script_nocache&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则服务器将添加HTTP标头字段，以防止代理缓存页面。对于动态内容，这通常是一个好主意，因为内容在每个请求之间经常有所不同。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">如果 &lt;code&gt;erl_script_timeout&lt;/code&gt; 设置了以秒为单位的时间，则服务器在要通过 &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; 传递的每个数据块之间等待。默认值为 &lt;code&gt;15&lt;/code&gt; 。这仅与使用erl方案的脚本有关。</target>
        </trans-unit>
        <trans-unit id="642c708a719a284794b6696e0acb8a429739f8e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;error_logger&lt;/code&gt; ，则使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。可以通过选项 &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;error_logger&lt;/code&gt; ，则使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。可以通过选项 &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">如果 &lt;code&gt;ev&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，则返回所有类型为 &lt;code&gt;-1&lt;/code&gt; &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 为ErlDrvSizeT的值。</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">如果 &lt;code&gt;exit&lt;/code&gt; 则所讨论的运输过程退出。如果为 &lt;code&gt;handle&lt;/code&gt; ,则照常处理该消息，生成的 &lt;code&gt;handle_request/3&lt;/code&gt; 或 &lt;code&gt;handle_answer/4&lt;/code&gt; 回调（如果发生）表示 &lt;code&gt;5015&lt;/code&gt; 错误（DIAMETER_INVALID_MESSAGE_LENGTH）。如果 &lt;code&gt;discard&lt;/code&gt; 则该消息将被静默丢弃。</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;Options&lt;/code&gt; 中指定了 &lt;code&gt;extra&lt;/code&gt; ，则返回值为 &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; 而不是 &lt;code&gt;{ok, Epp}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;Options&lt;/code&gt; 中指定了 &lt;code&gt;extra&lt;/code&gt; ，则返回值为 &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; 而不是 &lt;code&gt;{ok, [Form]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; （被动模式，默认设置），则调用者必须执行显式 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 调用以从套接字检索可用数据。</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不共享对等体。如果 &lt;code&gt;[node()]&lt;/code&gt; ,则与指定的节点列表共享对等体。如果使用 &lt;code&gt;eval()&lt;/code&gt; ,则与指定函数返回的节点共享对等点，并在对等连接可用或远程服务请求有关本地连接的信息时进行评估。值 &lt;code&gt;true&lt;/code&gt; 等效于 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 。列表中的值 &lt;code&gt;node()&lt;/code&gt; 会被忽略，因此可以将服务集合全部配置为与同一节点列表共享。</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不使用远程对等体。如果 &lt;code&gt;[node()]&lt;/code&gt; ,则仅使用指定节点列表中的对等体。如果使用 &lt;code&gt;eval()&lt;/code&gt; ,则仅使用由指定函数返回的对等体，只要远程服务传达有关可用对等体连接的信息，就进行评估。值 &lt;code&gt;true&lt;/code&gt; 等效于 &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; 。列表中的值 &lt;code&gt;node()&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则在需要任何用户交互时（例如接受要添加到 &lt;code&gt;known_hosts&lt;/code&gt; 文件中的服务器或提供密码），禁止客户端连接到服务器。</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则不会保存密钥，并且在同一主机的下一次访问中，密钥仍然是未知的。</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">如果 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;latin1&lt;/code&gt; ，则不翻译路径名。</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">如果 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回 &lt;code&gt;utf8&lt;/code&gt; ，则在创建tar文件时将路径名编码为UTF-8，而在提取tar文件时将假定路径名以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果返回 &lt;code&gt;final&lt;/code&gt; ，则时间偏移已处于final状态。这是因为另一个 &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; 调用，或者因为 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则备份仅包括自上次备份或还原以来创建，修改或删除的那些对象（即增量备份）。备份后，所有标记为脏的对象现在都是干净的，并且所有标记为删除的对象都将被删除。</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 是 &lt;code&gt;EI_BIN&lt;/code&gt; ，则需要第五个参数 &lt;code&gt;int *size&lt;/code&gt; ，以便可以返回对象的大小。</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;EI_BIN&lt;/code&gt; ，则需要第五个参数 &lt;code&gt;size&lt;/code&gt; ，以指示 &lt;code&gt;v&lt;/code&gt; 指向的对象的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="ef97c9cebbac0fa5b4a15003e98bfbe9b002c14c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;hibernate&lt;/code&gt; 模式而不是超时值，则在等待下一条消息到达时（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），进程将进入休眠模式。</target>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;hibernate&lt;/code&gt; 模式而不是超时值，则在等待下一条消息到达时（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），进程将进入休眠模式。</target>
        </trans-unit>
        <trans-unit id="4370781db47a41ab4e7732b376aa87b3dd2e229d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indent_opt&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default), line breaks are inserted in types, contracts, and Erlang code to improve readability.</source>
          <target state="translated">如果将 &lt;code&gt;indent_opt&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; （默认值），则会在类型，协定和Erlang代码中插入换行符以提高可读性。</target>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果跳过 &lt;code&gt;init_per_group&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">如果存在 &lt;code&gt;init_per_suite&lt;/code&gt; ，则在执行测试用例之前首先调用它。它通常包含该套件中所有测试用例通用的初始化，只能执行一次。建议使用 &lt;code&gt;init_per_suite&lt;/code&gt; 在被测系统（SUT）或&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 主机节点或两者上设置和验证状态和环境，以便套件中的测试用例能够正确执行。以下是初始配置操作的示例：</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;init_per_suite&lt;/code&gt; 失败，则会自动跳过测试套件中的所有测试用例（所谓的&lt;strong&gt;auto skipped&lt;/strong&gt;），包括 &lt;code&gt;end_per_suite&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;init_per_suite&lt;/code&gt; 失败，则在 &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用此函数。</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 崩溃（称为&lt;strong&gt;自动跳过&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 崩溃，或者返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 或 &lt;code&gt;{fail,Reason}&lt;/code&gt; ，则不调用函数 &lt;code&gt;end_per_testcase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">如果存在 &lt;code&gt;init_per_testcase&lt;/code&gt; ，则会在套件中的每个测试用例之前调用它。它通常包含必须针对每个测试用例进行的初始化（该套件的 &lt;code&gt;init_per_suite&lt;/code&gt; 模拟）。</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">如果 &lt;code&gt;init_per_testcase&lt;/code&gt; 返回一个元组 &lt;code&gt;{skip,Reason}&lt;/code&gt; （称为&lt;strong&gt;用户skipped&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;ip_access&lt;/code&gt; 和 &lt;code&gt;name_access&lt;/code&gt; 的实现类似，我们可以使用 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; 编写 &lt;code&gt;generic_access&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">如果 &lt;code&gt;keysearch&lt;/code&gt; 返回原子 &lt;code&gt;false&lt;/code&gt; ，则发生了一些错误，服务器发回了消息：</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">如果 &lt;code&gt;keysearch&lt;/code&gt; 返回：</target>
        </trans-unit>
        <trans-unit id="1a3183f931de40dbb6f7631f18d3f43161a10688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;kill&lt;/code&gt; ，则将使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。它可以通过选项改变 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果未在映射中定义 &lt;code&gt;kill&lt;/code&gt; ，则将使用系统默认值。默认系统默认值为 &lt;code&gt;true&lt;/code&gt; 。它可以通过选项改变 &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">如果将 &lt;code&gt;local&lt;/code&gt; 指定为参数，则Debugger仅在当前节点解释代码。如果将 &lt;code&gt;global&lt;/code&gt; 指定为参数，则Debugger会在所有已知节点上解释代码，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">如果使用负数作为参数调用 &lt;code&gt;m:fact/1&lt;/code&gt; ，则没有子句头匹配。一个 &lt;code&gt;function_clause&lt;/code&gt; 出现运行错误。</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">如果为 &lt;code&gt;master&lt;/code&gt; ，则启动一个主代理。否则，不会启动任何代理。</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">如果 &lt;code&gt;maximum&lt;/code&gt; 的为通过 &lt;code&gt;Type&lt;/code&gt; 和仿真器是不是在仪表模式下运行。</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">如果 &lt;code&gt;mon&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则成功调用将监视器的身份存储在 &lt;code&gt;mon&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 结构中。此标识符用于引用监视器，以供以后通过 &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; 除去或与 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 比较。触发监视器或释放资源时，监视器会自动删除。</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">如果 &lt;code&gt;msg_env&lt;/code&gt; 设置为 &lt;code&gt;NULL&lt;/code&gt; ，则将复制 &lt;code&gt;msg&lt;/code&gt; 术语，并且在调用后原始术语及其环境仍然有效。</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">如果 &lt;code&gt;myapp&lt;/code&gt; 在 &lt;code&gt;cp3&lt;/code&gt; 上运行，并且现在 &lt;code&gt;cp2&lt;/code&gt; 重新启动，则它不会重新启动 &lt;code&gt;myapp&lt;/code&gt; ，因为 &lt;code&gt;cp2&lt;/code&gt; 和 &lt;code&gt;cp3&lt;/code&gt; 节点之间的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">如果 &lt;code&gt;nc&lt;/code&gt; 是由分配器管理多嵌段载波（排除主多嵌段载波）的当前数量，下一个的大小 &lt;code&gt;mseg_alloc&lt;/code&gt; 由该分配器分配多嵌段载体是大致 &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; 当 &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; 和 &lt;code&gt;lmbcs&lt;/code&gt; 当 &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; 。如果参数的值 &lt;code&gt;sbct&lt;/code&gt; 比参数的值越大 &lt;code&gt;lmbcs&lt;/code&gt; ，分配器可能必须创建多块载体是比参数的值越大 &lt;code&gt;lmbcs&lt;/code&gt; ，虽然。通过 &lt;code&gt;mseg_alloc&lt;/code&gt; 分配的单块载波大小调整为整个页面。</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">如果将 &lt;code&gt;no_repeat&lt;/code&gt; 设置为值，则重复文件同步操作将被禁用，并且操作系统设置决定了将数据写入磁盘的速度。用户还可以调用 &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 函数来执行文件同步。</target>
        </trans-unit>
        <trans-unit id="cf5fe50553f5c7b137deba5f80790419102c9acc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">如果将 &lt;code&gt;no_repeat&lt;/code&gt; 设置为值，则禁用重复同步操作。用户还可以调用filesync &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; 函数来执行disk_log同步。</target>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">如果将 &lt;code&gt;no_repeat&lt;/code&gt; 设置为值，则禁用重复同步操作。用户还可以调用filesync &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; 函数来执行disk_log同步。</target>
        </trans-unit>
        <trans-unit id="a26d7bcc04c3b56013d1be0c1072c79ecbf5d9d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;ei_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;node&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则它是指向缓冲区的指针，函数可以在该缓冲区中填充找到名称的节点的 &lt;code&gt;name&lt;/code&gt; 。如有必要，可以将 &lt;code&gt;node&lt;/code&gt; 直接传递给 &lt;code&gt;ei_connect()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;node&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则它是指向缓冲区的指针，该函数可以在其中填充找到名称的节点的 &lt;code&gt;name&lt;/code&gt; 。如有必要，可以将 &lt;code&gt;node&lt;/code&gt; 直接传递到 &lt;code&gt;erl_connect()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">如果为 &lt;code&gt;once&lt;/code&gt; ，则仅自动将一条消息放入消息队列，然后此模式自动重置为被动模式。这提供了流控制，并为接收器提供了侦听与其他进程间消息交织的传入SCTP数据的可能性。</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则必须在停止OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; &lt;strong&gt;之后&lt;/strong&gt;调用此函数。 &lt;code&gt;Dir&lt;/code&gt; 定义了目录，该目录包含备份副本和 &lt;code&gt;syslogd&lt;/code&gt; 的Erlang特定配置文件，以及一个命名管道，用于接收来自 &lt;code&gt;syslogd&lt;/code&gt; 的消息。默认为 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 。 &lt;code&gt;Conf&lt;/code&gt; 定义 &lt;code&gt;syslogd&lt;/code&gt; 的配置文件的全名。默认值为 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_sup_enable&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则必须在启动OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;调用此函数。 &lt;code&gt;Dir&lt;/code&gt; 定义了目录，该目录包含备份副本和 &lt;code&gt;syslogd&lt;/code&gt; 的Erlang特定配置文件，以及一个命名管道，用于接收来自 &lt;code&gt;syslogd&lt;/code&gt; 的消息。默认为 &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; 。 &lt;code&gt;Conf&lt;/code&gt; 定义 &lt;code&gt;syslogd&lt;/code&gt; 的配置文件的全名。默认值为 &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">如果 &lt;code&gt;preliminary&lt;/code&gt; 返回，进行定稿和时间偏移现在是最后的。</target>
        </trans-unit>
        <trans-unit id="68ca185ba5a790749853b97ac87472bb69e0f79b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;raw&lt;/code&gt; is not found in the list, it is added.</source>
          <target state="translated">如果未在列表中找到 &lt;code&gt;raw&lt;/code&gt; ，则将其添加。</target>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">如果 &lt;code&gt;read/2&lt;/code&gt; 调用的大小不明显小于或什至大于 &lt;code&gt;Size&lt;/code&gt; 字节，则无法期望获得性能提升。</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">如果指定 &lt;code&gt;read&lt;/code&gt; ，则仅记录获取请求。</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">如果指定为 &lt;code&gt;read&lt;/code&gt; ，则仅记录收到的消息。</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">如果为表启用了 &lt;code&gt;read_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">如果为 &lt;code&gt;read_write&lt;/code&gt; ，则记录所有请求。</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">如果为 &lt;code&gt;read_write&lt;/code&gt; ，则记录传出消息和传入消息。</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;registered_name&lt;/code&gt; 是 &lt;code&gt;ItemList&lt;/code&gt; 的一部分，并且进程未注册任何名称，则 &lt;code&gt;{registered_name, []}&lt;/code&gt; &lt;code&gt;InfoTuple&lt;/code&gt; ，[]}，InfoTuple &lt;strong&gt;将&lt;/strong&gt;包含在结果 &lt;code&gt;InfoTupleList&lt;/code&gt; 中。当指定单个 &lt;code&gt;Item =:= registered_name&lt;/code&gt; 时，以及使用 &lt;code&gt;process_info/1&lt;/code&gt; 时，此行为是不同的。</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;remove_handler&lt;/code&gt; ，则通过调用 &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; 删除事件处理程序。</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;script_nocache&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则默认情况下，HTTP服务器会添加必要的头字段，以防止代理缓存页面。通常，这是优选的。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">如果在加载应用程序之前调用 &lt;code&gt;set_env/4&lt;/code&gt; ，则文件 &lt;code&gt;Application.app&lt;/code&gt; 中指定的应用程序环境值将覆盖先前设置的值。对于应用程序重新加载也是如此。</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则将头部的大小放置在此处。</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">如果返回 &lt;code&gt;stop&lt;/code&gt; ，则立即丢弃日志事件。如果过滤器是主过滤器，则不会调用任何处理程序过滤器或回调。如果它是处理程序过滤器，则不会调用相应的处理程序回调，但是会将日志事件转发到附加到下一个处理程序的过滤器（如果有）。</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">如果 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; ，则将同步处理所有日志事件。即，禁用了异步日志记录。</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">如果将 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 设置为与 &lt;code&gt;drop_mode_qlen&lt;/code&gt; 相同的值，那么将禁用同步模式。也就是说，处理程序始终以异步模式运行，除非调用删除或刷新。</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 标识节点本地端口，则此函数从中初始化端口变量 &lt;code&gt;*port_id&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。不检查端口是否还活着。</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是一个元组，则此函数将 &lt;code&gt;*array&lt;/code&gt; 设置为指向包含该元组元素的数组，并将 &lt;code&gt;*arity&lt;/code&gt; 设置为元素数。注意，数组是只读的， &lt;code&gt;(*array)[N-1]&lt;/code&gt; 是元组的第N个元素。如果元组的Arity为零，则未定义 &lt;code&gt;*array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">如果 &lt;code&gt;term&lt;/code&gt; 是节点本地进程的pid，则此函数从中初始化pid变量 &lt;code&gt;*pid&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。否则返回 &lt;code&gt;false&lt;/code&gt; 。不检查该进程是否仍在运行。</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果未在catch中评估 &lt;code&gt;throw/1&lt;/code&gt; ，则将发生 &lt;code&gt;nocatch&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="2871fa0784bdb523b8ad094e354b3376cbc7c2d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">如果未设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; ，则使用由 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt; ）指定的默认值。</target>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">如果未设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; ，则使用由 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; ）指定的默认值。</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">如果未针对特定测试用例专门设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 或两者，则使用由功能 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 指定的默认值。</target>
        </trans-unit>
        <trans-unit id="f5b1ebc718d9766e9f004a96387fa62f22f383b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">如果未针对特定测试用例专门设置 &lt;code&gt;timetrap&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 或两者，则使用由函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 指定的默认值。</target>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_call/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_ports/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_procs/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_receive/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_running_ports/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_running_procs/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">如果未定义 &lt;code&gt;trace_send/5&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">如果 &lt;code&gt;trans_req&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则将立即发送请求（在其自身的消息中）。</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将请求发送到事务发送方进程进行累积，然后再发送（请参见 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxcount&lt;/code&gt; ， &lt;code&gt;trans_req_maxsize&lt;/code&gt; ， &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 和 &lt;code&gt;trans_timer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="287b344c66382cf8b1edce4da0960025c7e9b57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (default), the server sends a cookie extension in its HelloRetryRequest messages.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; （默认），则服务器在其HelloRetryRequest消息中发送cookie扩展名。</target>
        </trans-unit>
        <trans-unit id="e70881a85aca398937951a4668c24337f4bc60ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode) there is no flow control.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; （完全活动模式），则没有流量控制。</target>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; （完全活动模式），则未决数据或事件将发送到拥有进程。</target>
        </trans-unit>
        <trans-unit id="25420436cf7ea356d88467267bb54e499c6238b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;extended&lt;/code&gt;), the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; （或 &lt;code&gt;extended&lt;/code&gt; ），则该代理是多线程的，每个get请求都有一个线程。</target>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在启动期间重新读取配置文件，并且忽略配置数据库的内容。因此，如果为 &lt;code&gt;true&lt;/code&gt; ，则在代理重新启动后，对配置数据库的更改将丢失。</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">如果 &lt;code&gt;true&lt;/code&gt; ，休眠的 &lt;code&gt;gen_statem&lt;/code&gt; 通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 才能进入 &lt;code&gt;receive&lt;/code&gt; 等待新的外部事件。</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在尝试发送大于当前PMTU大小的消息时会引发错误（这将需要分段/重新组装）。注意，消息碎片不会影响其传递的逻辑原子性。仅出于性能原因提供此选项。</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则net_if绑定到IP地址。如果为 &lt;code&gt;false&lt;/code&gt; ，则net_if侦听运行它的主机上的任何IP地址。</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则net_if不指定IP和端口地址应可重用。如果为 &lt;code&gt;false&lt;/code&gt; ，则地址设置为可重用。</target>
        </trans-unit>
        <trans-unit id="f8ccef0dc480afe24c0ff21ece83c8c3800b5e39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it after a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则推迟当前事件并在&lt;strong&gt;状态更改&lt;/strong&gt;（ &lt;code&gt;NextState =/= State&lt;/code&gt; ）后重试。</target>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则推迟当前事件并在状态更改时重试（ &lt;code&gt;NextState =/= State&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则代理是多线程的，每个get请求都有一个线程。</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则客户端不会在授权时打印任何内容。</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则客户端将保存一个接受的主机密钥，以避免下次连接同一主机时出现接受问题。如果不存在选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; ，则该密钥将保存在文件&amp;ldquo; known_hosts&amp;rdquo;中。请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 以获取该文件的位置。</target>
        </trans-unit>
        <trans-unit id="95c8aecfc16da9f44601b813f0d7e51d5bf0f4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则客户端将保存一个接受的主机密钥，以避免下次连接同一主机时出现接受问题。如果不存在选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; ，则该密钥将保存在文件&amp;ldquo; known_hosts&amp;rdquo;中。有关该文件的位置，请参见选项 &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则将累积执行时间和缩减量。</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在发生某些日志事件时会通知日志所有者。默认为 &lt;code&gt;false&lt;/code&gt; 。事件发生时，将向所有者发送以下消息之一：</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，这将使 &lt;code&gt;epp_dodger&lt;/code&gt; 替换任何无法用 &lt;code&gt;text&lt;/code&gt; 类型的节点解析的程序形式（请参阅 &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; ），表示该形式的原始令牌序列，而不是报告解析错误。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05b7850adc53f90dafb4ed1b3efc538359d746ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true|once|N&lt;/code&gt; (active modes) received data or events are sent to the owning process. See &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; for the message format.</source>
          <target state="translated">如果为 &lt;code&gt;true|once|N&lt;/code&gt; （活动模式），则将接收到的数据或事件发送到拥有过程。有关消息格式，请参见 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d40234d0ab231968f3d6203cda0f55c4df8e790c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">如果将 &lt;code&gt;u&lt;/code&gt; 用作子系统标识符（即 &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ），则所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 的分配器都会生效。如果将 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 用作子系统标识符，则仅实现特定的分配器标识符。</target>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">如果将 &lt;code&gt;u&lt;/code&gt; 用作子系统标识符（即 &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ），则所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 的分配器都会生效。如果将 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 用作子系统标识符，则仅实现特定的分配器标识符。</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果返回了 &lt;code&gt;volatile&lt;/code&gt; ，则由于使用了 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 因此无法最终确定时间偏移。</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">如果指定了 &lt;code&gt;write&lt;/code&gt; ，则仅记录已发送的消息。</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">如果指定了 &lt;code&gt;write&lt;/code&gt; ，则仅记录设置请求。</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">如果为表启用了 &lt;code&gt;write_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">如果返回 &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; ，则在执行升级指令之前重新启动模拟器。如果仿真器或任何应用程序内核，STDLIB或SASL被更新，则会发生这种情况。新的仿真器版本和这些核心应用程序在重启后执行。对于所有其他应用程序，将启动旧版本，并通过执行升级说明按常规执行升级。</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;{eof, Endline}&lt;/code&gt; 立即返回，则对 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 的调用返回 &lt;code&gt;{ok, eof}&lt;/code&gt; 。如果在解析器期望输入结束之前返回 &lt;code&gt;{eof, Endline}&lt;/code&gt; ，则 &lt;code&gt;parse_and_scan/1&lt;/code&gt; 当然会返回错误消息（请参见上文）。否则 &lt;code&gt;{ok, Result}&lt;/code&gt; 返回{ok，Result}。</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">如果在源规范中设置了 &lt;code&gt;{merge_tests,true}&lt;/code&gt; （这是默认设置），则合并规范中的术语将与源规范中的术语合并（根据之前的 &lt;code&gt;merge_tests&lt;/code&gt; 的描述）。</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;{noreply,NewState}&lt;/code&gt; ， &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; 或 &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 进程将继续使用 &lt;code&gt;NewState&lt;/code&gt; 执行。必须使用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 明确指定对 &lt;code&gt;From&lt;/code&gt; 的任何答复。</target>
        </trans-unit>
        <trans-unit id="e61ed5c3d675fd060bf7a5ba0b7669c540660308" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; ，事件管理器也会进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），等待下一个事件发生。事件处理程序之一返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 就足以使整个事件管理器进程休眠。</target>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; ，则事件管理器也会进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），等待下一个事件发生。事件处理程序之一返回 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; 就足以使整个事件管理器进程休眠。</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,NewState}&lt;/code&gt; 或 &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; ，则事件处理程序将保留在事件管理器中，并带有可能更新的内部状态 &lt;code&gt;NewState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">如果返回 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; ，则事件管理器进入休眠状态（通过调用 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ），等待下一个事件发生。</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; 返回， &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; 或 &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; ， &lt;code&gt;Reply&lt;/code&gt; 返还给 &lt;code&gt;From&lt;/code&gt; 为的返回值 &lt;code&gt;call/2,3&lt;/code&gt; 或纳入 &lt;code&gt;multi_call/2,3,4&lt;/code&gt; 的返回值。然后 &lt;code&gt;gen_server&lt;/code&gt; 进程以可能更新的内部状态 &lt;code&gt;NewState&lt;/code&gt; 继续执行。</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">如果为该过程设置了 &lt;code&gt;{save_calls,N}&lt;/code&gt; ,则不会将任何函数调用保存到调用保存列表中。（不会清除呼叫保存列表。此外，发送，接收和超时事件仍会添加到列表中。）</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 在选项中指定，使得 &lt;code&gt;Start&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ， &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0或 &lt;code&gt;Start + Length&lt;/code&gt; 是&amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ，一个 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; 在选项中指定，使得 &lt;code&gt;Start&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ， &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt;0或 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt;的大小 &lt;code&gt;Subject&lt;/code&gt; ，一个 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="22f0dd2e07f51ba0bec6f71cc1bb3b006093d94a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip, Reason}&lt;/code&gt; ，则跳过该组中的所有测试用例，并在该组的概述日志中打印 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9167afbdea5d3a67e5f541cf0e5e6e2773017130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip, Reason}&lt;/code&gt; ，则跳过模块中的所有测试用例，并在HTML结果页上打印 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e478cc8acb7bdb77b1dae6158305c98359cc9ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip, Reason}&lt;/code&gt; ，则套件中的所有测试用例都将被跳过， &lt;code&gt;Reason&lt;/code&gt; 将打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="3e08b34f61f1a4d3777b205be5de380bc841d230" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip, Reason}&lt;/code&gt; ，则跳过测试用例，并在套件的概述日志中打印 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过该组中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在该组的概述日志中。</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过模块中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在HTML结果页上。</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则将跳过套件中的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; ，则跳过该测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在该套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">如果返回 &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; ,则必须使用 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 显式指定对 &lt;code&gt;From&lt;/code&gt; 的任何答复。然后 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; 并终止。</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; 返回， &lt;code&gt;Reply&lt;/code&gt; 返还给 &lt;code&gt;From&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果返回了 &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; ，则首先通过 &lt;code&gt;Handler2&lt;/code&gt; 调用 &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; 和 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 来将事件处理程序替换为Handler2，其中 &lt;code&gt;Term&lt;/code&gt; 是返回值 &lt;code&gt;Module:terminate/2&lt;/code&gt; 。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">如果&lt;strong&gt;任何&lt;/strong&gt;的&lt;strong&gt;其他的&lt;/strong&gt;回调函数崩溃（退出，或者抛出一个普通的崩溃）或返回无效的结果（如果已指定一个有效的回报），这个函数被调用。目的是允许用户处理此错误（例如发出错误报告）。</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;false&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; 函数发送megaco消息。</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;false&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 函数发送megaco消息。</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如果为&lt;strong&gt;true&lt;/strong&gt;，则使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; 函数&lt;strong&gt;重新发送&lt;/strong&gt;megaco消息。仍然使用 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 函数完成初始消息发送。</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">如果A和B进行了匹配,但在C中出现了失败,则匹配不会回溯到A中,而是移动到下一个备选方案,也就是D中。然而,如果给含有(*THEN)的子模式提供了一个备选方案,它的表现就不同了。</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">如果A是X的子集，则A在R下的&lt;strong id=&quot;image&quot;&gt;图像&lt;/strong&gt;是集合{y：x R y对于A中的某些x}。如果B是Y的子集，则B 的&lt;strong id=&quot;inverse_image&quot;&gt;逆像是&lt;/strong&gt;集合{x：x R y对于B中的某些y}。</target>
        </trans-unit>
        <trans-unit id="f6a630d6f8d7caebea5102271394fdcd67b18c9d" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K := V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K := V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75688e538d64827729b81c8f7409b54e266cd7bd" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，则Rep（A）= &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f2fa0920ecae328194e2e5f0d6947b2fdf2b8f" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K := V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K := V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd7d66e8b109f42cf2b8b90dae2cc67fe469adfa" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">如果A是关联类型 &lt;code&gt;K =&amp;gt; V&lt;/code&gt; ，其中 &lt;code&gt;K&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 是类型，则Rep（A）= &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">如果A匹配但B失败,回溯到(*COMMIT)会导致整个匹配失败。然而,如果 A 和 B 匹配,但 C 失败,则回溯到 (*THEN)会导致下一个选择 (ABD)被尝试。这种行为是一致的,但并不总是与Perl中的行为相同。它的意思是,如果连续出现两个或更多的回溯动词,其中最后一个动词没有效果。考虑下面的例子。</target>
        </trans-unit>
        <trans-unit id="5ec09bef075c491da05310ae82ca09d506f563c0" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是case子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是case子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a5aa4f9266e04e273102dd79f1886cfeae24057" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的案例子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的案例子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d659eda70c2e50509c30fcc418400a9aab3ac03" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; ，即具有显式异常类 &lt;code&gt;throw&lt;/code&gt; 且具有或不具有显式stacktrace变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与没有显式异常类和显式stacktrace变量的catch子句区分开。</target>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; ，即，带有显式异常类 &lt;code&gt;throw&lt;/code&gt; 且带有或不带有显式stacktrace变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与没有显式异常类且没有显式stacktrace变量的catch子句区分开。</target>
        </trans-unit>
        <trans-unit id="c311eaf58fab876bdc94780ac91685854b17771c" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即具有显式异常类 &lt;code&gt;throw&lt;/code&gt; 并且带有或不具有显式堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句，不能与没有显式异常类的catch子句区别开来，并且没有显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句P，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即具有显式异常类 &lt;code&gt;throw&lt;/code&gt; 且带有或不具有显式堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与没有显式异常类的catch子句区别开来，并且没有显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="8afa8db8880cd11a80b4f7cecb8f0640f10dde11" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式，而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; ，即具有显式异常类和显式stacktrace变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与具有显式异常类且没有显式异常类的catch子句区分开一个显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式，而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; ，即具有显式异常类和显式堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与具有显式异常类且没有显式异常类的catch子句区分开一个显式的stacktrace变量。</target>
        </trans-unit>
        <trans-unit id="43cc8aa87c6f7cf6d65593b565e96a75d05633ea" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;S&lt;/code&gt; 是变量，并且 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是catch子句 &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;S&lt;/code&gt; 是变量，并且 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a262d7341faa65ccb5ac93e7079518e8857e84b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P：S，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;S&lt;/code&gt; 是变量，而 &lt;code&gt;B&lt;/code&gt; 是主体，然后Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P：S，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或变量模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;S&lt;/code&gt; 是变量， &lt;code&gt;B&lt;/code&gt; 是主体，然后Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0e601c916b6ea0d1855c5d5324b1a12d0303cb8" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列，而 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即，带有明确的异常类和明确的堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与一个带有显式异常类而没有显式stacktrace变量的catch子句。</target>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">如果C是 &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; 的catch子句X：P，其中 &lt;code&gt;X&lt;/code&gt; 是原子文字或可变模式， &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;Gs&lt;/code&gt; 是保护序列，并且 &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; ，即，带有明确的异常类和明确的堆栈跟踪变量 &lt;code&gt;_&lt;/code&gt; 的catch子句无法与一个带有显式异常类且没有显式stacktrace变量的catch子句。</target>
        </trans-unit>
        <trans-unit id="4016717fdd4d5433989581c68c30070bb76884da" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">如果C是约束 &lt;code&gt;V :: T&lt;/code&gt; ，其中 &lt;code&gt;V&lt;/code&gt; 是类型变量， &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（C）= &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">如果C是约束 &lt;code&gt;V :: T&lt;/code&gt; ，其中 &lt;code&gt;V&lt;/code&gt; 是类型变量， &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（C）= &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8d2da59f190a64375cc2ab954899e9cace4a77f" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是函数子句 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是函数子句 &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbc0eacd6cf64ab7e1b6a5aa346f15af4ee37ac3" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是 &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; 的函数子句（Ps），其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; C是函数子句（Ps），其中 &lt;code&gt;Ps&lt;/code&gt; 是模式序列， &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b2834d93e535442b365d66608e72b7dd5d9a7b0" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是if子句 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果C是if子句 &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; ，其中 &lt;code&gt;Gs&lt;/code&gt; 是保护序列， &lt;code&gt;B&lt;/code&gt; 是主体，则Rep（C）= &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">如果CPU拓扑信息不可用。</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">如果D是一个由形式 &lt;code&gt;F_1&lt;/code&gt; ，...， &lt;code&gt;F_k&lt;/code&gt; 组成的模块声明，则Rep（D）= &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a30963b62350996a8d59e8d3d4f4343c158ae7a4" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是位串理解 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是位串理解 &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="a215b35bfabec03f705356b11df781d76fe9bda6" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果E是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个类型特定的列表，则Rep（E）= &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果E是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个类型特定的列表，则Rep（E）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="def0fd07bd4ff6d50e1223eca9053d3fa095d182" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个块表达式，则 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;begin B end&lt;/code&gt; ，其中B是主体，则Rep（E）= &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个块表达式，则 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;begin B end&lt;/code&gt; ，其中B是主体，则Rep（E）= &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d8af3f74254d265168f6c22c16d0838a1ea340" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; 的case表达式case E_0；...; Cc_k end，其中 &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，然后Rep（E）= &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; 的case表达式case E_0；...; Cc_k end，其中 &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，然后Rep（E）= &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="096069597c0301e2331f3c9eeb4ba8c6fe89359b" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是catch表达式 &lt;code&gt;catch E_0&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是catch表达式 &lt;code&gt;catch E_0&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b58d732e6eb44c8650ef6ea1ab56a5738fed639" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个缺点骨架 &lt;code&gt;[E_h | E_t]&lt;/code&gt; ，然后Rep（E）= &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个缺点骨架 &lt;code&gt;[E_h | E_t]&lt;/code&gt; ，然后Rep（E）= &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd154a4579d9aa67e94aa4c762704930a595e132" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达，则 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是一个功能子句，则Rep（E）= &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式，则 &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是一个功能子句，则Rep（E）= &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b930f9fc614875b26b77fcef08cb18fabcffa755" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 。（在Erlang / OTP R15之前：Rep（E）= &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; 。（在Erlang / OTP R15之前：Rep（E）= &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="21dea75946b388b1e954dab71b395d65115fda11" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式， &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; ，其中 &lt;code&gt;Name&lt;/code&gt; 是变量，每个 &lt;code&gt;Fc_i&lt;/code&gt; 是函数子句，然后Rep（E）= &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式， &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; ，其中 &lt;code&gt;Name&lt;/code&gt; 是变量，每个 &lt;code&gt;Fc_i&lt;/code&gt; 是函数子句，然后Rep（E）= &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c48f719d2f5c29bf4ca1a282cd70942bcc783e8f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个有趣的表达式 &lt;code&gt;fun Name/Arity&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a222846ccb959514cd088c00700755704ce4b70c" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b051c7315ab5f877f6f8d1a3fcb5d7352c32d165" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是函数调用 &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad4dbd16a1df7767e8ca6eb37d1f31ac1e007d69" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是列表 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">如果E是列表 &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; ，其中每个 &lt;code&gt;Q_i&lt;/code&gt; 是一个限定词，则Rep（E）= &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; 。对于Rep（Q），请参见下文。</target>
        </trans-unit>
        <trans-unit id="e8512e6de961ae7de3dc6cd02be5dfd7477d76f7" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="237f2587bea6e744a08e9b787c8ee8a08e4fc754" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图更新 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 或 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果E是地图更新 &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; 或 &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="4f62176ee9725e6dd7a1d357a9791afa6d505171" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个匹配运算符表达式 &lt;code&gt;P = E_0&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是一个模式，则Rep（E）= &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是匹配运算符表达式 &lt;code&gt;P = E_0&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式，则Rep（E）= &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">如果E是带括号的表达式 &lt;code&gt;( E_0 )&lt;/code&gt; ，则Rep（E）= &lt;code&gt;Rep(E_0)&lt;/code&gt; ，即，不能将带括号的表达式与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="eb97a9c72be1a3ec039d3b19e59af460c1f9597f" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句， &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，而 &lt;code&gt;B_t&lt;/code&gt; 是一个主体，则Rep（E）= &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句， &lt;code&gt;E_0&lt;/code&gt; 是一个表达式，而 &lt;code&gt;B_t&lt;/code&gt; 是一个主体，则Rep（E）= &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62607bd086692a7a4e73a9a4340bedc98933a8ce" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，则Rep（E）= &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个接收表达式，则 &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，则Rep（E）= &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8db402d6b9bfaaf27c4221b6ecb8f7a3438ef10d" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录创建 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录创建 &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; （其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; )，则Rep（E）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b95681bf643b3e4b28c35faa965a19ee4fda5ac" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个记录字段，则访问 &lt;code&gt;E_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是一个原子，则Rep（E）= &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录字段访问 &lt;code&gt;E_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（E）= &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd0016f76592cf4abfa2e2b7e0edf19c3c161d6e" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（E）= &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（E）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0e1680739b87d61cf8de240ccb43c2b9ea6736a" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录更新 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; （其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子），则Rep（E）= &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果E是记录更新 &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; （其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子），则Rep（E）= &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1790d1e53e6feb25e42b2594447e491760461bcd" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;try B after A end&lt;/code&gt; 的try表达式，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，则Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是 &lt;code&gt;try B after A end&lt;/code&gt; 的try表达式，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66db70f66ec2e1c9cfff251e52d9d4fb44005444" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，然后Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="527f66fe559f2313ab4c9f07440149b4724a0e36" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，则Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是try表达式，请 &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Tc_i&lt;/code&gt; 是catch子句，然后Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c97756483607f476bd044cc105daba38c615ff16" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，则Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed9f5ca2ce8dc840d927013fd593a6e43685c6fc" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是一个主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是一个catch子句，则Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是一个主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是一个case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是一个catch子句，则Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87716dd0d35ab489a52485d5fff86ee7a86034f5" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是catch子句，则Rep（E）= &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个try表达式，请 &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; ，其中 &lt;code&gt;B&lt;/code&gt; 是主体，每个 &lt;code&gt;Cc_i&lt;/code&gt; 是case子句，每个 &lt;code&gt;Tc_j&lt;/code&gt; 是catch子句，然后Rep（E）= &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a7a0dff10ecd15daa7bf8f1e4f2c478633f53be" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个元组骨架 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是一个元组骨架 &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d73c4b24d215a5b14fa705cf6b8fc7f04eaa159" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果E是变量 &lt;code&gt;V&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{var,ANNO,A}&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果E是变量 &lt;code&gt;V&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">如果E是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（E）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="704415f6ec0f5288d1cf6770b2ca8548cffab4c3" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是if表达式， &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Ic_i&lt;/code&gt; 是一个if子句，则Rep（E）= &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果E是if表达式， &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; ，其中每个 &lt;code&gt;Ic_i&lt;/code&gt; 是一个if子句，则Rep（E）= &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a540b17ecf127991c06127bf562cd9b622f73fd8" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;E_1 Op E_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（E）= &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;E_1 Op E_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（E）= &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ae3a7a50482463c878cd3a4535e569c8a10c045" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;Op E_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符，则Rep（E）= &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">如果E是运算符表达式 &lt;code&gt;Op E_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符，则Rep（E）= &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dd90da6de4013d8fcdf427618cebc1de03b8894" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">如果E为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{nil,ANNO}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果E为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（E）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">如果以长名称分布式模式启动Erlang，则需要从某个位置获取域名并读取系统 &lt;code&gt;inet&lt;/code&gt; 配置文件以获取此信息。找到的所有主机和解析器信息也会被记录，但只要为本地查询配置了Erlang，就不会使用它们。如果将查找方法更改为 &lt;code&gt;'file'&lt;/code&gt; 或 &lt;code&gt;'dns'&lt;/code&gt; ，则该信息将很有用，请参见下文。</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">例如，如果Erlang将列表 &lt;code&gt;[$a,$b,$c]&lt;/code&gt; 发送到端口，则 &lt;code&gt;bufflen&lt;/code&gt; 变量为 &lt;code&gt;3&lt;/code&gt; ， &lt;code&gt;buff&lt;/code&gt; 变量包含 &lt;code&gt;{'a','b','c'}&lt;/code&gt; （无 &lt;code&gt;NULL&lt;/code&gt; 终止） ）。通常，第一个字节用作操作码，在该驱动程序中也是如此（至少在端口处于 &lt;code&gt;command&lt;/code&gt; 模式时）。操作码定义如下：</target>
        </trans-unit>
        <trans-unit id="d4fecac2cf10df2e039ce3e4f4d5fa9aa6b7bf2b" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数声明 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是具有相同长度 &lt;code&gt;Arity&lt;/code&gt; 的模式序列的函数子句，然后Rep（F）= &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数声明 &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; ，其中每个 &lt;code&gt;Fc_i&lt;/code&gt; 是具有相同长度 &lt;code&gt;Arity&lt;/code&gt; 的模式序列的函数子句，然后Rep（F）= &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92b2fdf009166615e68068377c093d1265169847" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中 &lt;code&gt;Spec&lt;/code&gt; 是原子 &lt;code&gt;spec&lt;/code&gt; 或原子 &lt;code&gt;callback&lt;/code&gt; ，并且每个 &lt;code&gt;Ft_i&lt;/code&gt; 是可能受约束的函数类型，其参数序列的长度相同 &lt;code&gt;Arity&lt;/code&gt; ，然后Rep（F）= &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中 &lt;code&gt;Spec&lt;/code&gt; 是原子 &lt;code&gt;spec&lt;/code&gt; 或原子 &lt;code&gt;callback&lt;/code&gt; ，并且每个 &lt;code&gt;Ft_i&lt;/code&gt; 是一个受约束的函数类型，其参数序列的长度为 &lt;code&gt;Arity&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7b133a685e1078d511adc4d4a4c0155cfdea6af" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中每个 &lt;code&gt;Ft_i&lt;/code&gt; 都是可能受约束的函数类型，其参数序列具有相同的长度 &lt;code&gt;Arity&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是函数规范 &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; ，其中每个 &lt;code&gt;Ft_i&lt;/code&gt; 是一个可能受约束的函数类型，其参数序列具有相同的长度 &lt;code&gt;Arity&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fa68f807198b22105fc44214b7d3c63162ade67" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">如果F是记录声明 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; ，其中每个 &lt;code&gt;V_i&lt;/code&gt; 是一个记录字段，则Rep（F）= &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。对于Rep（V），请参见下文。</target>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">如果F是记录声明 &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; ，其中每个 &lt;code&gt;V_i&lt;/code&gt; 是一个记录字段，则Rep（F）= &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。对于Rep（V），请参见下文。</target>
        </trans-unit>
        <trans-unit id="25adb05f207dd769bbafb0f578b65f641a0a7794" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是记录字段类型 &lt;code&gt;Name :: Type&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是类型，则Rep（F）= &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">如果F是记录字段类型 &lt;code&gt;Name :: Type&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是类型，则Rep（F）= &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6239a9176ea881407034a190550ff59286863ce7" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a type variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是类型声明 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是原子 &lt;code&gt;type&lt;/code&gt; 或原子 &lt;code&gt;opaque&lt;/code&gt; ，则每个 &lt;code&gt;V_i&lt;/code&gt; 是类型变量，而 &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（ F）= &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是类型声明 &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是原子 &lt;code&gt;type&lt;/code&gt; 或原子 &lt;code&gt;opaque&lt;/code&gt; ，则每个 &lt;code&gt;V_i&lt;/code&gt; 是变量，而 &lt;code&gt;T&lt;/code&gt; 是类型，则Rep（F ）= &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18b64b9b51dd41ff649ef5c26db0f7f069a7d35d" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt;.</source>
          <target state="translated">如果F是通配属性 &lt;code&gt;-A(T)&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">如果F是通配属性 &lt;code&gt;-A(T)&lt;/code&gt; ，则Rep（F）= &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1d2d6dc97c9b7259053b20eb74732ea1141eebd" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; 则Rep（F）= {attribute，ANNO，export，[{Fun_1，A_1}，...，{Fun_k， A_k}]}。</target>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; 则Rep（F）= {attribute，LINE，export，[{Fun_1，A_1}，...，{Fun_k， A_k}]}。</target>
        </trans-unit>
        <trans-unit id="c034270eafab2ed7bcecacf02af15e5097193b1d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-file(File,Line)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-file(File,Line)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc2d15becf26ad2d7caf42380a72b2c27da43c41" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 则Rep（F）= {attribute，ANNO，import，{Mod，[{Fun_1，A_1}，.. 。，{Fun_k，A_k}]}}。</target>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; 则Rep（F）= {attribute，LINE，import，{Mod，[{Fun_1，A_1}，.. 。，{Fun_k，A_k}]}}。</target>
        </trans-unit>
        <trans-unit id="eb3ea6219e1cb69bee47ba7d3c0d07637a4dae6e" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-module(Mod)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">如果F是 &lt;code&gt;-module(Mod)&lt;/code&gt; 属性，则Rep（F）= &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc8b8c5e56eae2112a18d51dd6a9fcb8af749ac2" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">如果 &lt;code&gt;Ft_1 when Fc&lt;/code&gt; Ft是约束函数类型Ft_1，其中 &lt;code&gt;Ft_1&lt;/code&gt; 是函数类型，而 &lt;code&gt;Fc&lt;/code&gt; 是函数约束，则Rep（T）= &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 。对于Rep（Fc），请参见下文。</target>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">如果 &lt;code&gt;Ft_1 when Fc&lt;/code&gt; Ft是约束函数类型Ft_1，其中 &lt;code&gt;Ft_1&lt;/code&gt; 是函数类型，而 &lt;code&gt;Fc&lt;/code&gt; 是函数约束，则Rep（T）= &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; 。对于Rep（Fc），请参见下文。</target>
        </trans-unit>
        <trans-unit id="addf4ad1342821174bcf34191602826b5ec30735" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果Ft是函数类型 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; ，其中每个 &lt;code&gt;T_i&lt;/code&gt; 是一种类型，则Rep（Ft）= &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果Ft是函数类型 &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; ，其中每个 &lt;code&gt;T_i&lt;/code&gt; 是一种类型，则Rep（Ft）= &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">如果G是有向图，则认为G的顶点和边缘与 &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; 的顶点和边缘相同。</target>
        </trans-unit>
        <trans-unit id="02f41904356cb27048a5f981f0ab30233861e22f" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果Gt是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个保护测试，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个特定于类型的列表，则Rep（Gt）= &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见上文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果Gt是位串构造函数 &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是一个保护测试，每个 &lt;code&gt;TSL_i&lt;/code&gt; 是一个类型特定列表，则Rep（Gt）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见上文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="cd4e2d2654420d08ff75e569801e0f82ea1d8e67" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个缺点骨架 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; ，然后Rep（Gt）= &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个缺点骨架 &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; ，然后Rep（Gt）= &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67aa27e3b255c0b23af7ede9fa213ab9884fe39f" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个函数调用 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，则Rep（Gt）= &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个函数调用 &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是一个原子，则Rep（Gt）= &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b6a664574ec6785fbcee63137675fde7e8ef5d" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是调用 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; 的函数，其中 &lt;code&gt;A_m&lt;/code&gt; 是原子 &lt;code&gt;erlang&lt;/code&gt; ,而 &lt;code&gt;A&lt;/code&gt; 是原子或运算符，则Rep（Gt）= &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是一个函数调用 &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; ，其中 &lt;code&gt;A_m&lt;/code&gt; 是原子 &lt;code&gt;erlang&lt;/code&gt; ,而 &lt;code&gt;A&lt;/code&gt; 是原子或运算符，则Rep（Gt）= &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8aef2cea48fdeba80e26c88e7eef4d4b0dc0be26" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图创建 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="9d73cdb5044edf8f644c77dc585bc5cd5213ffd6" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图更新 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 或 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">如果Gt是地图更新 &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; （其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; 或 &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见上文。</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">如果Gt是带括号的防护测试 &lt;code&gt;( Gt_0 )&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;Rep(Gt_0)&lt;/code&gt; ，即，不能将带括号的防护测试与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="5515e293f7cbca6cd1b4d86301ecc8fcc5ad59f4" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录创建 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录创建 &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d8c3bdf875936951f6be38abd9a234defb4a787" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段，则访问 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段，则访问 &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddc523ac11939b47b6ea5667d89b0cf0cbb87da" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是记录字段索引 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（Gt）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91b1ff08bce1f7be5c86e93bf7b896dcee2bcdda" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是元组骨架 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是元组骨架 &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86ba6ce0ad44989a3f9fca3540904be2d98eb9da" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果Gt是可变模式 &lt;code&gt;V&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{var,ANNO,A}&lt;/code&gt; ，其中A是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果Gt是可变模式 &lt;code&gt;V&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中A是一个原子，其打印名称与 &lt;code&gt;V&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">如果Gt是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（Gt）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="30bbb65a3435cb7a0b644ba508d8ad7e2aebd344" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是运算符防护测试 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（Gt）= &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是运算符防护测试 &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是除match operator &lt;code&gt;=&lt;/code&gt; 之外的二进制运算符，则Rep（Gt）= &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1590398d554a502b9031594d26d2e7f3c303dfca" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是操作员防护测试 &lt;code&gt;Op Gt_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元操作符，则Rep（Gt）= &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">如果Gt是操作员防护测试 &lt;code&gt;Op Gt_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元操作符，则Rep（Gt）= &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bba2b902d7d011a3e4c35fe4e116ae49fd9a8a3" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">如果Gt为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{nil,ANNO}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果Gt为nil &lt;code&gt;[]&lt;/code&gt; ，则Rep（Gt）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb631647ead2cb8b76c4ec1b07f1f0c70bf1b1d6" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是字符文字，则Rep（L）= &lt;code&gt;{char,ANNO,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是字符文字，则Rep（L）= &lt;code&gt;{char,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="893eb2ba60965c09a51b1e49cb8017e58a360073" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是浮点文字，则Rep（L）= &lt;code&gt;{float,ANNO,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是浮点文字，则Rep（L）= &lt;code&gt;{float,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b31cf2c573d35c24a7c01f8fb6b6ee646806df21" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">如果L是由字符 &lt;code&gt;C_1&lt;/code&gt; ，...， &lt;code&gt;C_k&lt;/code&gt; 组成的字符串文字，则Rep（L）= &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">如果L是由字符 &lt;code&gt;C_1&lt;/code&gt; ，...， &lt;code&gt;C_k&lt;/code&gt; 组成的字符串文字，则Rep（L）= &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46dc6ddf19639701de194e194ca59776f621ce0b" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是原子文字，则Rep（L）= &lt;code&gt;{atom,ANNO,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是原子文字，则Rep（L）= &lt;code&gt;{atom,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9daa1db636bdb57e06f2782f31b76d4535249681" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,ANNO,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是整数文字，则Rep（L）= &lt;code&gt;{integer,ANNO,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">如果L是整数文字，则Rep（L）= &lt;code&gt;{integer,LINE,L}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">如果Mnesia在本地节点上处于关闭状态，则该函数返回当前可运行的其他 &lt;code&gt;db_nodes&lt;/code&gt; 和 &lt;code&gt;extra_db_nodes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">如果启动了Mnesia，则该函数返回本地节点上的Mnesia完全连接到的那些节点。只有Mnesia与之交换了架构信息的那些节点 &lt;code&gt;running_db_nodes&lt;/code&gt; 包含为running_db_nodes。合并架构后，本地Mnesia系统将完全可操作，并且应用程序可以执行对远程副本的访问。在架构合并之前，Mnesia仅在本地运行。有时， &lt;code&gt;running_db_nodes&lt;/code&gt; 列表中包含的节点比所有 &lt;code&gt;db_nodes&lt;/code&gt; 和 &lt;code&gt;extra_db_nodes&lt;/code&gt; 都多。</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">如果将Mnesia用作存储方法，则必须在HTTP服务器之前启动Mnesia。首次启动Mnesia时，必须在启动Mnesia之前创建架构和表。这里提供了一个简单的示例，其中包含创建和启动Mnesia的两个功能的模块。首次使用功能 &lt;code&gt;first_start/0&lt;/code&gt; 。它创建架构和表。 &lt;code&gt;start/0&lt;/code&gt; 将在连续的启动中使用。 &lt;code&gt;start/0&lt;/code&gt; 启动Mnesia，并等待表初始化。仅在已创建模式和表时才可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="a0ff6de34e690fd37142329b3d2414f3154795bb" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果P是位串模式 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是可以计算为整数的表达式，并且每个 &lt;code&gt;TSL_i&lt;/code&gt; 是类型特定的列表，则Rep（P）= &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果P是位串模式 &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; ，其中每个 &lt;code&gt;Size_i&lt;/code&gt; 是可以计算为整数的表达式，并且每个 &lt;code&gt;TSL_i&lt;/code&gt; 是类型特定的列表，则Rep（P）= &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; 。对于Rep（TSL），请参见下文。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;Size_i&lt;/code&gt; 表示。 &lt;code&gt;default&lt;/code&gt; 省略的 &lt;code&gt;TSL_i&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="d37994ece6f75def5d9f7facc328a7886d4a88b5" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是复合模式 &lt;code&gt;P_1 = P_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是复合模式 &lt;code&gt;P_1 = P_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c6ccb3b7440efc69c50224b64f913af2ed5a932" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">如果P是一个缺点模式 &lt;code&gt;[P_h | P_t]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">如果P是一个缺点模式 &lt;code&gt;[P_h | P_t]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc2c7ec165d91dd1b0c944a7cacc79a36a649770" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果P是映射模式 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">如果P是地图模式 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; ，其中每个 &lt;code&gt;A_i&lt;/code&gt; 是关联 &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; 。对于Rep（A），请参见下文。</target>
        </trans-unit>
        <trans-unit id="19737da2fe03d867999d377974efb452c080feda" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="translated">如果P是nil模式 &lt;code&gt;[]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{nil,ANNO}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">如果P是nil模式 &lt;code&gt;[]&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{nil,LINE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">如果P是带括号的模式 &lt;code&gt;( P_0 )&lt;/code&gt; ，则Rep（P）= &lt;code&gt;Rep(P_0)&lt;/code&gt; ，即，不能将带括号的模式与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="dfc926eeb885550b2057f5eaa3e598f075f5fb9c" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录字段索引模式 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（P）= &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录字段索引模式 &lt;code&gt;#Name.Field&lt;/code&gt; ，其中 &lt;code&gt;Field&lt;/code&gt; 是原子，则Rep（P）= &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6a33479e55d6adf6c5f304da26c896bfab008d" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(P_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录模式 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(P_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">如果P是记录模式 &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; ，其中每个 &lt;code&gt;Field_i&lt;/code&gt; 是原子或 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75542af568a4e6fd74ec30069d26212ef35f7d03" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,ANNO,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果P是元组模式 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{tuple,ANNO,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">如果P是元组模式 &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2f93073cfd79739d9e631820436bac79686fc83" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,'_'}&lt;/code&gt;.</source>
          <target state="translated">如果P是通用模式 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,ANNO,'_'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">如果P是通用模式 &lt;code&gt;_&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3149c3832edd80b313902a9d154c6d727e573468" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果P是可变模式 &lt;code&gt;V&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,ANNO,A}&lt;/code&gt; ，其中A是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果P是可变图案 &lt;code&gt;V&lt;/code&gt; ，则Rep（P）= &lt;code&gt;{var,LINE,A}&lt;/code&gt; ，其中A是一个原子，其打印名称由与 &lt;code&gt;V&lt;/code&gt; 相同的字符组成。</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">如果P是原子文字 &lt;code&gt;L&lt;/code&gt; ，则Rep（P）= Rep（L）。</target>
        </trans-unit>
        <trans-unit id="faca9ab114984c50875ddef7ab3151e741e59fdd" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;Op P_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符（这是一个表达式的出现，可以在编译时将其评估为数字），则Rep（P）= &lt;code&gt;{op,ANNO,Op,Rep(P_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;Op P_0&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是一元运算符（这是一个表达式的出现，可以在编译时将其评估为数字），则Rep（P）= &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e5c0b3f1ae8df31dec63b9c72633bdc64593894" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,ANNO,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;P_1 Op P_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是二进制运算符（这是应用于文字字符串或字符列表的 &lt;code&gt;++&lt;/code&gt; 的出现，或者是在编译时可被评估为数字的表达式的出现），然后Rep（P）= &lt;code&gt;{op,ANNO,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">如果P是运算符模式 &lt;code&gt;P_1 Op P_2&lt;/code&gt; ，其中 &lt;code&gt;Op&lt;/code&gt; 是二进制运算符（这是应用于文字字符串或字符列表的 &lt;code&gt;++&lt;/code&gt; 的出现，或者是在编译时可以求值为数字的表达式的出现），然后Rep（P）= &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">如果想要PER编码。</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">如果Ps是模式 &lt;code&gt;P_1, ..., P_k&lt;/code&gt; 的序列，则Rep（Ps）= &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; 。这样的序列作为函数或fun的参数列表出现。</target>
        </trans-unit>
        <trans-unit id="ad13e93659ed632a16cc4f4903f37ddc1132e280" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是位串生成器 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{b_generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是位串生成器 &lt;code&gt;P &amp;lt;= E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">如果Q是过滤器 &lt;code&gt;E&lt;/code&gt; （其中 &lt;code&gt;E&lt;/code&gt; 是表达式），则Rep（Q）= &lt;code&gt;Rep(E)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="809f12ef8c3064b918954c279d0a931407f3434e" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是生成器 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{generate,ANNO,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">如果Q是生成器 &lt;code&gt;P &amp;lt;- E&lt;/code&gt; ，其中 &lt;code&gt;P&lt;/code&gt; 是模式， &lt;code&gt;E&lt;/code&gt; 是表达式，则Rep（Q）= &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">如果R是从X到Y的关系，而S是从Y到Z的关系，则R和S 的&lt;strong id=&quot;relative_product&quot;&gt;相对乘积&lt;/strong&gt;是从X到Z的关系T定义为x T z当且仅当存在元素y时在Y中使得x R y和y S z为。</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">如果R是X中的一个关系，并且如果S被定义为x S y如果x R y而不是x = y，则S是对应于R 的&lt;strong id=&quot;strict_relation&quot;&gt;严格&lt;/strong&gt;关系。反之，如果S是X中的关系，并且定义R使得如果x S y或x = y时x R y，则R是对应于S 的&lt;strong id=&quot;weak_relation&quot;&gt;弱&lt;/strong&gt;关系。</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">如果R是X中的等价关系，并且x是X的元素，则相对于R的x 的&lt;strong id=&quot;equivalence_class&quot;&gt;等价类&lt;/strong&gt;是X的所有元素y的集合。等价类构成X的一个分区。相反，如果C是X的一个分区，则如果X的任何两个元素属于相同的等价类，则对X的任意两个元素成立的关系是由分区C引起的等价关系。</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">如果R是X中的等价关系，则&lt;strong id=&quot;canonical_map&quot;&gt;规范映射&lt;/strong&gt;是将X的每个元素映射到其等价类的函数。</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">如果S是R对A的限制，则R是S对X 的&lt;strong id=&quot;extension&quot;&gt;扩展&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">如果S是Set的元素（T，X），则T是X 的&lt;strong id=&quot;valid_type&quot;&gt;有效类型&lt;/strong&gt;，T是S的类型，并且X是S的外部集合 &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; 从类型和Erlang创建一个集合术语变成了外部集合。</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;.rel&lt;/code&gt; 文件中未将SASL作为应用程序包括在内，则会发出警告，因为这样的发行版不能在升级中使用。要关闭此警告，请添加选项 &lt;code&gt;no_warn_sasl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">如果使用SNMPv3,则默认加载这些MIB。</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">如果将SetFun指定为fun,则将fun应用于给定集合的每个元素,并假定返回值是一个集合。</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">如果将SetFun指定为元组 &lt;code&gt;{external, Fun}&lt;/code&gt; ，则将Fun应用于给定集合的每个元素的外部集合，并假定返回值为外部集合。在本实施方式中，选择无序集合的元素作为外部集合并从外部集合的列表中组装新的无序集合比将每个元素修改为集合更有效。但是，仅当无序集的元素是原子集或有序集时才可以使用此优化。还必须是元素的类型与Fun的某个子句匹配的情况（创建的集合的类型是将Fun应用于给定集合的类型的结果），并且Fun除了选择​​，复制或重新排列元素的一部分。</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">如果T为 &lt;code&gt;( T_0 )&lt;/code&gt; ，则Rep（T）= &lt;code&gt;Rep(T_0)&lt;/code&gt; ，即，不能将括号类型与它们的主体区分开。</target>
        </trans-unit>
        <trans-unit id="3fe813c684b65a78f678a4bec68aa5f263202a79" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是位串类型 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 是单例整数类型，则Rep（T）= &lt;code&gt;{type,ANNO,binary,[Rep(M),Rep(N)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是位串类型 &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 是单例整数类型，则Rep（T）= &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f85dadf01e8f30907411f8ced0faf82947f6804" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,any},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a390f10fcd8d8a36def467725d4dda00982dd986" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,ANNO,'fun',[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun()&lt;/code&gt; ，则Rep（T）= &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">如果T是一个有趣的类型 &lt;code&gt;fun(Ft)&lt;/code&gt; ，其中 &lt;code&gt;Ft&lt;/code&gt; 是一个函数类型，则Rep（T）= &lt;code&gt;Rep(Ft)&lt;/code&gt; 。对于Rep（Ft），请参见下文。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
