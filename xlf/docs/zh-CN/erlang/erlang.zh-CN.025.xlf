<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">注意:改变这个值(并将产生的上下文传递给一个延续函数)不会影响正常的格式化,但可能会影响钩子函数中用户定义的行为。</target>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">注意：如果 &lt;code&gt;Node&lt;/code&gt; 表示&amp;ldquo; &lt;code&gt;M:F(...)&lt;/code&gt; &amp;rdquo;，则结果是表示&amp;ldquo; &lt;code&gt;M:F&lt;/code&gt; &amp;rdquo; 的子树。</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">注意：如果 &lt;code&gt;Node&lt;/code&gt; 表示&amp;ldquo; &lt;code&gt;fun N/A&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;fun M:N/A&lt;/code&gt; &amp;rdquo;，则结果是分别表示&amp;ldquo; &lt;code&gt;N/A&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;M:N/A&lt;/code&gt; &amp;rdquo; 的子树。</target>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">注意：在 &lt;code&gt;list(Elements, none)&lt;/code&gt; ，&amp;ldquo; nil&amp;rdquo;列表终止符是隐式的并且没有关联信息（请参阅 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; ），而在看似等效的 &lt;code&gt;list(Elements, Tail)&lt;/code&gt; 当 &lt;code&gt;Tail&lt;/code&gt; 的类型为 &lt;code&gt;nil&lt;/code&gt; 时，列表终止符子树 &lt;code&gt;Tail&lt;/code&gt; 可能具有附加的属性，例如位置，注释和注释，这些属性将保留在结果中。</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">注意:没有检查字符序列是否代表一个正确的变量名,即它的第一个字符是否是大写的Erlang字符,或者它是否不包含控制字符、空格等。</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">注意:并不是所有的符都是叶子节点,反之亦然。例如,非零数的元组和非空列表可能是字元,但不是叶子节点。另一方面,变量是叶子结点,但不是字元。</target>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">注意：与特定字符值相对应的文字不是唯一定义的。例如，字符&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;可以写为&amp;ldquo; &lt;code&gt;$a&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;$\141&lt;/code&gt; &amp;rdquo;，Tab字符可以写为&amp;ldquo; &lt;code&gt;$\11&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;$\011&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;$\t&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">注意：对于相同的 &lt;code&gt;ShortName&lt;/code&gt; ，结果列表可以包含多个元组 &lt;code&gt;{ShortName, Name}&lt;/code&gt; ，根据给定的列表， &lt;code&gt;Name&lt;/code&gt; 的值可能不同。</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">注意：与该模块中的其他函数不同，返回值是 &lt;code&gt;ok&lt;/code&gt; 而不是 &lt;code&gt;success&lt;/code&gt; 。这是很久以前就引入的错误，任何更改都会破坏大量现有软件。</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">注意:格式化函数返回的文本将在每个换行处自动分割成独立的注释行。不需要额外的工作。</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">注意:如果编译时启用了测试功能,这些宏会引入对EUnit库代码的运行时依赖。</target>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;length(list_elements(Node))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:这只是为了向后兼容现有的解析器和工具而保留的。</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">注意:这只是一种将源代码形式分组为单一语法树的方式,通常是为了形成一个Erlang模块定义。</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:这只支持与现有的解析器和工具向后兼容。</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">注。浮动文件似乎很好用,但目前的通用性不如你所希望的那么强,当嵌入到某些环境中时,就会失去效果。可以嵌套浮动操作符(即使优先级不同),但效果可能难以预测。在任何情况下,请注意,算法重新排序浮动文档的方式相当于 &quot;bubblesort&quot;,所以不要指望它能够快速排序大序列的浮动文档。</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">注释。如果一个文件中包含的宏定义或使用过于异国情调,那么在没有预处理的情况下将无法读取该文件。此外,Igor 目前并不尝试整理同一文件的多个包含物,或同一宏名的重新定义。因此,当预处理被关闭时,可能需要编辑生成的源代码,删除这些重新包含和重新定义的内容。</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">注意：如果&amp;ldquo; &lt;code&gt;Arguments&lt;/code&gt; 为空列表，则结果将表示&amp;ldquo; &lt;code&gt;?Name()&lt;/code&gt; &amp;rdquo;，其中包括一对匹配的括号。</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不会从队列中删除任何内容，而必须使用 &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不会从队列中删除任何内容，而必须使用 &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还请注意，&amp;ldquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;被解释为&amp;ldquo; &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;，这是一种语法错误。正确的方法是在'='之后写一个空格：&amp;ldquo; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">还请注意,面向字节的数据使用ISO Latin-1编码发送最为简单。</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">还要注意，瞬态类型几乎没有实际用途，因为当监视树终止时，原因被设置为 &lt;code&gt;shutdown&lt;/code&gt; ，不是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">还请注意,当从shell测试程序时,由于行太长,输入的内容被分散在两行中。</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">还要注意，在 &lt;code&gt;io:format&lt;/code&gt; 中使用〜p代替〜w。引用该手册：&amp;ldquo;〜p以与〜w相同的方式使用标准语法写入数据，但是将打印表示形式长于一行的术语分成多行，并在每行缩进。还尝试检测可打印列表。字符并将其输出为字符串&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">请注意&quot;!&quot;这个操作符是如何用来发送消息的。&quot;!&quot;的语法是:</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">注意如何编写 &lt;code&gt;server&lt;/code&gt; 函数，以便它通过 &lt;code&gt;server(User_List)&lt;/code&gt; 调用自身，从而创建一个循环。 Erlang编译器是&amp;ldquo;聪明的&amp;rdquo;并且优化代码，因此这实际上是一种循环，而不是正确的函数调用。但这仅在调用后没有代码的情况下有效。否则，编译器希望该调用返回并进行适当的函数调用。这将导致每个循环的过程越来越大。</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">注意，在第二个示例中，重复名称在返回的列表中仅出现一次，并且该列表按字母顺序排列，无论名称在正则表达式中的位置如何。如果将 &lt;code&gt;{capture, all_names}&lt;/code&gt; 指定为 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的选项，则名称的顺序与捕获的子表达式的顺序相同。因此，您可以像这样从 &lt;code&gt;run/3&lt;/code&gt; 的结果创建名称到值的映射：</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">请注意，在第16行，将5英寸转换为厘米，然后再次返回并放心地恢复到原始值。也就是说，一个函数的参数可以是另一个函数的结果。考虑第16行（以上）的工作方式。给函数 &lt;code&gt;{inch,5}&lt;/code&gt; 的参数首先与 &lt;code&gt;convert_length&lt;/code&gt; 的第一个head子句匹配，即 &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; 。可以看出 &lt;code&gt;{centimeter,X}&lt;/code&gt; 与 &lt;code&gt;{inch,5}&lt;/code&gt; 不匹配（头部是&amp;ldquo;-&amp;gt;&amp;rdquo;之前的位）。失败了，让我们尝试下一个子句的头，即 &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; 。这匹配，并且 &lt;code&gt;Y&lt;/code&gt; 获得值5。</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，&amp;ldquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;将被解释为&amp;ldquo; &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;，这是一种语法错误。编写表达式的正确方法是： &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">请注意,模式开始时的(*COMMIT)和锚是不一样的,除非PCRE的匹配开始优化被关闭,如下例所示。</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">请注意,(*SKIP:NAME)只搜索由(*MARK:NAME)设置的名称,它忽略了由(*PRUNE:NAME)或(*THEN:NAME)设置的名称。它忽略(*PRUNE:NAME)或(*THEN:NAME)设置的名称。</target>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">请注意，在启动守护程序时指定了 &lt;code&gt;-relaxed_command_check&lt;/code&gt; ，该守护程序在注册了活动节点时接受终止。交互式运行 &lt;code&gt;epmd&lt;/code&gt; 时， &lt;code&gt;-relaxed_command_check&lt;/code&gt; 不起作用。如果启动了没有轻松进行命令检查的守护程序，则必须使用信号或其他特定于OS的方法（如果已注册活动客户端）将其终止。</target>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ActiveSuspendCount&lt;/code&gt; 和 &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; 并不是 &lt;code&gt;Suspendee&lt;/code&gt; 的总暂停数，而是 &lt;code&gt;Pid&lt;/code&gt; 贡献的部分。</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ErlNifBinary&lt;/code&gt; 是半透明类型，只允许您读取字段 &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">请注意， &lt;code&gt;Filename&lt;/code&gt; 可以是列表或二进制文件。</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">请注意， &lt;code&gt;Tracee&lt;/code&gt; 必须引用与 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 的调用者所在的节点相同或当前存在的进程。特殊的 &lt;code&gt;Tracee&lt;/code&gt; 原子 &lt;code&gt;all&lt;/code&gt; 表示当前在节点中跟踪的所有进程。</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">请注意，根据Unicode标准， &lt;code&gt;[$\r,$\n]&lt;/code&gt; 是一个字素簇。</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">请注意， &lt;code&gt;[$\r,$\n]&lt;/code&gt; 是一个字素簇。</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;bind_address&lt;/code&gt; 必须是函数 &lt;code&gt;info&lt;/code&gt; 报告的IP地址，并且不能是放入 &lt;code&gt;bind_address&lt;/code&gt; 时允许的主机名。</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">请注意， &lt;code&gt;catch&lt;/code&gt; 的优先级较低，并且catch子表达式通常需要用块表达式或括号括起来：</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意，只允许在两个回调 &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; 中调用 &lt;code&gt;enif_open_resource_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">请注意， &lt;code&gt;erlsrv&lt;/code&gt; 不是Windows的常规服务实用程序，而是为嵌入式Erlang系统设计的。</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">请注意，如果链接指向无效的文件名，则 &lt;code&gt;file:read_link/1&lt;/code&gt; 总是返回错误。</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">请注意，在将日志事件转发到每个处理程序之前，Logger本身会遵守 &lt;code&gt;level&lt;/code&gt; 和 &lt;code&gt;filters&lt;/code&gt; ，而 &lt;code&gt;formatter&lt;/code&gt; 和所有处理程序特定的选项则留给处理程序实现。</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">请注意， &lt;code&gt;n3&lt;/code&gt; 和 &lt;code&gt;creation&lt;/code&gt; 的精度受到限制，因此仅使用这些数字的低18位和2位。</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">请注意， &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;creation&lt;/code&gt; 的精度受到限制，因此仅使用这些数字的低18位和2位。</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">请注意， &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; 与 &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; ；一个元素的列表未与该元素本身一起标识。</target>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">请注意， &lt;code&gt;stdin&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 用于缓冲的输入/输出，&lt;strong&gt;不能&lt;/strong&gt;用于与Erlang的通信。</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">请注意， &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; 不会导致任何条件成功。这会导致运行时错误 &lt;code&gt;if_clause&lt;/code&gt; ，在此由shell很好地格式化。有关许多可用保护测试的详细信息，请参见 &lt;code&gt;Guard Sequences&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">请注意， &lt;code&gt;{active, true}&lt;/code&gt; 模式不提供流量控制。快速的发送者可以轻松地使接收者的接收消息溢出。对于 &lt;code&gt;{active, N}&lt;/code&gt; 模式，消息数大于零时也是如此。</target>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">注意，Mnesia可以连接到除 &lt;code&gt;ReturnValue&lt;/code&gt; 中返回的节点以外的其他节点。</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">注意,SNMPv3配置时需要USM用户,不要与用户混淆。</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">注意，对于从128到255的代码点，UTF-8 与字节表示形式&lt;strong&gt;不&lt;/strong&gt;兼容，因此ISO Latin-1字节表示形式通常与UTF-8不兼容。</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">请注意，\ g {...}（Perl语法）和\ g &amp;lt;...&amp;gt;（Oniguruma语法）&lt;strong&gt;不是&lt;/strong&gt;同义词。前者是回溯参考；后者是子例程调用。</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">请注意， &lt;code&gt;gen_server&lt;/code&gt; 进程不会自动捕获退出信号，必须在回调模块中显式启动该退出信号。</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;gen_statem&lt;/code&gt; 不会自动捕获退出信号，必须在回调模块中显式启动（通过调用 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">请注意,一个条件子模式并不被认为有两个选择,因为只有一个被使用。也就是说,条件子模式中的|字符有不同的含义。忽略空格,考虑一下。</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">请注意，驱动程序二进制文件具有内部参考计数器。这意味着调用 &lt;code&gt;driver_free_binary&lt;/code&gt; ，实际上可能不会处理它。如果将其发送到仿真器，则可以在其中引用它。</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">注意,一个伪造的CPU拓扑结构如果不能反映真实CPU拓扑结构的样子,很可能会降低运行时系统的性能。</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">注意,占有式定语可以和整个群体一起使用,例如。</target>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">注意，使用共享读取器组的运行时系统受益于 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; ，因为读取器组在调度程序之间的分配更好。</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">请注意,即使操作系统已经排定了调度线程,调度器也可能是繁忙的。</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">注意,所有使用标准OTP行为模块实现的子进程都会自动遵守关闭协议。</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">请注意，所有八个等级同时出现在标题中，不仅 &lt;code&gt;ERROR&lt;/code&gt; ， &lt;code&gt;WARNING&lt;/code&gt; 或 &lt;code&gt;INFO&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 产生。并且在时间戳记末尾添加了微秒。</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">请注意,最后一个片段中的所有记录都必须移动到另一个片段中,因为整个片段都被删除了。</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">请注意,所有的输出都是在gollum上接收的。这是因为I/O系统发现了进程从哪里产生,并将所有的输出发送到那里。</target>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，尽管用户已请求绑定调度程序，但他们可以默默地失败绑定。要检查调度程序绑定，请调用 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">请注意，虽然关键字 &lt;code&gt;catch&lt;/code&gt; 在使用 &lt;code&gt;try&lt;/code&gt; 表达，没有一个 &lt;code&gt;catch&lt;/code&gt; 的范围内表达 &lt;code&gt;try&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">请注意，始终可以通过调用 &lt;code&gt;stop/1&lt;/code&gt; 显式停止应用程序。无论应用程序的类型如何，都不会影响其他应用程序。</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">请注意，事件管理器&lt;strong&gt;会&lt;/strong&gt;自动捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">请注意,有一个出口端口存在,但没有打开。</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">请注意，存在一个正在退出的进程，但该进程没有生命。也就是说， &lt;code&gt;is_process_alive/1&lt;/code&gt; 对于退出的进程返回 &lt;code&gt;false&lt;/code&gt; ，但是其进程标识符是从processs &lt;code&gt;processes/0&lt;/code&gt; 返回的结果的一部分。</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">请注意，在 &lt;code&gt;mnesia:select/4&lt;/code&gt; 和 &lt;code&gt;mnesia:select/1&lt;/code&gt; 调用之间完成的任何修改操作，即 &lt;code&gt;mnesia:write&lt;/code&gt; 或 &lt;code&gt;mnesia:delete&lt;/code&gt; ，在结果中都不可见。</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">请注意，任何进程都可以使用 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 关闭端口！{PortOwner，close}好像它本身是端口所有者一样，但是答复总是转到端口所有者。</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">请注意，任何进程都可以使用 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 发送到端口！{PortOwner，{command，Data}}，就好像它本身是端口所有者一样。</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">注意，任何过程都可以使用 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 设置端口所有者！{PortOwner，{connect，Pid}}就像它本身是端口所有者一样，但是答复总是转到端口所有者。</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">请注意，存储在表中的任何元组必须至少具有 &lt;code&gt;Pos&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">请注意,作为驱动程序二进制是由驱动程序和仿真器共享的。从仿真器接收到的二进制文件或发送到仿真器的二进制文件不能被驱动程序改变。</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">请注意，由于这是 &lt;code&gt;server_transfer/5&lt;/code&gt; ，所以它与先前的功能 &lt;code&gt;server_transfer/4&lt;/code&gt; 不同。在 &lt;code&gt;keysearch&lt;/code&gt; 上完成另一个关键字 &lt;code&gt;User_List&lt;/code&gt; 以查找与fred对应的客户端的pid：</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">注意,位串模式不能嵌套。</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">请注意，通过传递 &lt;code&gt;positive&lt;/code&gt; 修饰符，您将更快地为堆分配整数（bignums）。</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">注意，在事务上下文中调用（嵌套） &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; 会继承事务语义。</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">注意，在事务上下文中调用（嵌套） &lt;code&gt;mnesia:ets&lt;/code&gt; 会继承事务语义。</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">注意，调用 &lt;code&gt;complex2:foo/1&lt;/code&gt; 和 &lt;code&gt;complex2:bar/1&lt;/code&gt; 会导致元组 &lt;code&gt;{foo,X}&lt;/code&gt; 或 &lt;code&gt;{bar,Y}&lt;/code&gt; 被发送到 &lt;code&gt;complex&lt;/code&gt; 进程，该进程将它们编码为二进制文件并将其发送到端口。这意味着C程序必须能够处理这两个元组。</target>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">请注意,在低内存条件下监督很多孩子时,调用此函数会导致内存不足异常。</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">请注意，分块编码可以添加标头，以便 &lt;code&gt;stream_end&lt;/code&gt; 消息中的标头比 &lt;code&gt;stream_start&lt;/code&gt; 中的标头多。当流传输到文件并且请求是异步的时，将发送消息 &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">请注意， &lt;code&gt;disc_only_copies&lt;/code&gt; 表当前不支持 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;disc_only_copies&lt;/code&gt; 不支持当前 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">请注意，由于内部原因，无法更改默认选项 &lt;code&gt;{active, true}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">请注意，分发套接字禁用了 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 和 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 的使用。相反，他们使用 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; ，这是一个类似的功能。</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">请注意，分发套接字禁用了 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 和 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 的使用。而是使用 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; ，这是类似的功能。</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">注意，每个断言都独立地应用于主题字符串中的同一点。首先检查前三个字符是否都是数字，然后检查相同的三个字符是否不是&amp;ldquo; 999&amp;rdquo;。此模式与以六个字符开头的&amp;ldquo; foo&amp;rdquo; &lt;strong&gt;不&lt;/strong&gt;匹配，前六个字符是数字，后三个字符不是&amp;ldquo; 999&amp;rdquo;。例如，它与&amp;ldquo; 123abcfoo&amp;rdquo;不匹配。一种实现方式如下：</target>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">请注意，清空调用堆栈意味着删除所有周围的 &lt;code&gt;catch&lt;/code&gt; ，并且在休眠后必须重新插入。这样的效果是，使用 &lt;code&gt;proc_lib&lt;/code&gt; 启动的进程（也间接地，例如 &lt;code&gt;gen_server&lt;/code&gt; 进程）将使用 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 来确保异常处理程序在唤醒时继续工作。</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">注意,代码中省略了错误处理。</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">请注意,每一个守备测试都有与某个表达式相同的源形式,并以与对应表达式相同的方式表示。</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">请注意,每个模式的源形式都与某个表达式相同,并与相应的表达式以相同的方式表示。</target>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">请注意，对于SCTP套接字，此函数仅返回套接字地址之一。函数 &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; 返回全部。</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">请注意，对于SCTP套接字，此函数仅返回套接字的对等地址之一。函数 &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; 返回全部。</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">请注意，由于任何其它原因比 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或者 &lt;code&gt;{shutdown,Term}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 假定进程终止，因为一个错误和错误报告使用发出 &lt;code&gt;logger(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">请注意，由于任何其它原因比 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或者 &lt;code&gt;{shutdown,Term}&lt;/code&gt; ，所述 &lt;code&gt;gen_statem&lt;/code&gt; 假定终止，因为一个错误和错误报告使用发出 &lt;code&gt;logger(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">请注意，为了获得最佳性能，在同一事务中对该表执行任何修改操作之前，将使用 &lt;code&gt;select&lt;/code&gt; 。也就是说，不要在 &lt;code&gt;mnesia:select&lt;/code&gt; 之前使用 &lt;code&gt;mnesia:write&lt;/code&gt; 或 &lt;code&gt;mnesia:delete&lt;/code&gt; 。为了提高效率， &lt;code&gt;NObjects&lt;/code&gt; 仅作为建议，结果可以包含从空列表到所有可用结果的任何内容。</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">请注意，为了获得最佳性能，在同一事务中对该表执行任何修改操作之前，将使用 &lt;code&gt;select&lt;/code&gt; 。也就是说，在 &lt;code&gt;select&lt;/code&gt; 之前不要使用 &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">请注意，对于表类型 &lt;code&gt;ordered_set&lt;/code&gt; 来说，不需要 &lt;code&gt;safe_fixtable/2&lt;/code&gt; ，因为对 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 的调用始终会成功。</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">注意,对于临时子代,当子代终止时,子代规范会被自动删除;因此,无法重新启动此类子代。</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">请注意，在转换要测试相等性的字符串时，应使用函数 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 可以用作帮助，如下所示：</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">注意，函数 &lt;code&gt;chunk/2,3&lt;/code&gt; ， &lt;code&gt;bchunk/2,3&lt;/code&gt; 和 &lt;code&gt;chunk_step/3&lt;/code&gt; 不会影响 &lt;code&gt;info/1&lt;/code&gt; 返回的任何值。</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果 &lt;code&gt;init_per_suite&lt;/code&gt; 不存在init_per_suite和 &lt;code&gt;end_per_suite&lt;/code&gt; ，则 &lt;code&gt;Common Test&lt;/code&gt; 会调用伪函数（具有相同的名称），以便将钩子函数生成的输出保存到这些虚拟变量的日志文件中。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">请注意，如果 &lt;code&gt;parallel_login&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，一次只能有一个客户端处于身份验证阶段。</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">请注意，如果跟踪到&amp;ldquo;技术上内置的函数&amp;rdquo;（即，不是用Erlang编写的函数），则 &lt;code&gt;caller&lt;/code&gt; 函数有时会返回原子 &lt;code&gt;undefined&lt;/code&gt; 。在此类调用期间，调用Erlang函数不可用。</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">请注意，如果在运行时更改处理程序的配置，则不得修改 &lt;code&gt;type&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果在打开文件时使用了选项 &lt;code&gt;delayed_write&lt;/code&gt; ，则 &lt;code&gt;close/1&lt;/code&gt; 会返回旧的写入错误，甚至不会尝试关闭文件。参见 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">请注意，如果文件 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 不在目录 &lt;code&gt;/etc&lt;/code&gt; 中，则必须修改第二个和第三个命令中的文件路径。</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">请注意，如果原始属性项在扩展时要保留在结果中，则必须将其包括在扩展列表中。插入的术语不会递归扩展。如果 &lt;code&gt;Expansions&lt;/code&gt; 包含多个具有相同键的属性，则仅使用第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">请注意，如果还原到非空注册表，则表中的对象将使用相同的键覆盖注册表中的对象。此外，还原后，注册表的&lt;strong&gt;全部&lt;/strong&gt;内容都标记为未修改，包括还原操作未覆盖的所有已修改对象。这可能不是您的意图。</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">请注意，如果您存储依赖于上下文的二进制对象（例如，包含指针或打开的文件描述符），则将它们备份到 &lt;code&gt;Mnesia&lt;/code&gt; 表并随后在其他上下文中还原时，它们将失去含义。</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">注意，忽略此函数的返回值将导致&lt;strong&gt;不可靠的&lt;/strong&gt;消息传递，这与Erlang编程模型相矛盾。如果此函数返回 &lt;code&gt;false&lt;/code&gt; ,&lt;strong&gt;则不&lt;/strong&gt;发送该消息。</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">注意，在 &lt;code&gt;ordered_set&lt;/code&gt; 表中，记录按片段排序，并且在 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;match_object&lt;/code&gt; 以及 &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;prev&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 返回的结果中未定义顺序。</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">请注意，在某些情况下，与从OS命令外壳直接调用时的命令标准输出相比，从另一个程序调用时命令的标准输出（例如， &lt;code&gt;os:cmd/1&lt;/code&gt; ）可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">请注意,在这个未锚定的例子中,标记从主题中的字母 &quot;X &quot;开始的匹配尝试中被保留。随后的匹配尝试从 &quot;P &quot;开始,然后是一个空字符串,并没有到达(*MARK)项,但不会重置它。</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">请注意，它没有写过3次&amp;ldquo; hello&amp;rdquo;，然后写了3次&amp;ldquo;再见&amp;rdquo;。相反，第一个过程写了一个&amp;ldquo;你好&amp;rdquo;，第二个过程写了&amp;ldquo;再见&amp;rdquo;，第一个过程写了一个&amp;ldquo;你好&amp;rdquo;，依此类推。但是&amp;lt;0.63.0&amp;gt;从何而来？函数的返回值是函数中最后一个&amp;ldquo;事物&amp;rdquo;的返回值。函数 &lt;code&gt;start&lt;/code&gt; 的最后一件事是</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">请注意，它也需要扩大 &lt;code&gt;-export&lt;/code&gt; 用，还有另一种功能信息线路 &lt;code&gt;mult&lt;/code&gt; 用两个参数。</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">请注意，与其他规范结合使用时，始终是源规范中的 &lt;code&gt;merge_tests&lt;/code&gt; 设置。例如，假设具有测试TA1和TA2的源规范A 设置了 &lt;code&gt;{merge_tests,false}&lt;/code&gt; ，并且它包括了另一个具有测试TB1和TB2的规范B，其中设置了 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 。结果是执行了测试序列 &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; 。相反的 &lt;code&gt;merge_tests&lt;/code&gt; 设置将导致测试系列 &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">注意,脏读记录的效率是事务内的十倍以上。</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">请注意,在谈论 &quot;BIF &quot;时,通常指的是一组自动导入的BIF。</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">注意，由运行时系统确定是否以及如何使用此信息。在某些平台上的实现可以使用其他方式来确定消耗的CPU时间。无论如何，冗长的 &lt;code&gt;enif_consume_timeslice&lt;/code&gt; 都应经常调用enif_consume_timeslice以确定是否允许其继续执行。</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">注意,是否使用和如何使用这些信息由运行时系统决定。一些平台上的实现可以使用其他方式来确定时间片的消耗分数。冗长的驱动回调应该不管这些,经常调用这个函数来确定是否允许继续执行。</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">请注意，如果列表完全由0..255范围内的整数组成，则将它们编码为字符串。此函数不会解码此类字符串，请改用 &lt;code&gt;ei_decode_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">请注意，消息 &lt;code&gt;trace_delivered&lt;/code&gt; 并&lt;strong&gt;没有&lt;/strong&gt;暗示跟踪消息已经交付。相反，它意味着所有&lt;strong&gt;要传递的&lt;/strong&gt;跟踪消息均已传递。如果没有 &lt;code&gt;Tracee&lt;/code&gt; ，也没有被任何人跟踪，这不是错误，但是，在这种情况下，当 &lt;code&gt;trace_delivered&lt;/code&gt; 消息到达时，&lt;strong&gt;没有任何&lt;/strong&gt;跟踪消息已经传递。</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">请注意，大多数类型测试BIF具有较旧的等效项，而没有 &lt;code&gt;is_&lt;/code&gt; 前缀。保留这些旧的BIF只是为了向后兼容，不能在新代码中使用。也只允许在最高级别使用它们。例如，在警卫队的布尔表达式中不允许使用它们。</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">请注意,允许使用多个 &quot;*&quot;字符(如Unix通配符,但与Windows/DOS通配符不同)。</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">请注意,负整数和浮点数不会出现这样的情况;它们被解析为单子否定运算符的应用。</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">注意，缓冲区上没有边界检查。调用者有责任确保缓冲区足够大以容纳编码的术语。您可以使用足够大的静态缓冲区来容纳程序中期望的术语，也可以使用 &lt;code&gt;erl_term_len()&lt;/code&gt; 确定给定术语的确切要求。</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">注意,在固定表被释放之前,不会从固定表中删除对象。如果一个进程固定了一个表,但从未释放它,那么被删除对象所使用的内存就永远不会被释放。对表的操作性能也会大大降低。</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">请注意,当程序执行对这些副本的写操作时,不会执行磁盘操作。但是,如果需要永久的RAM副本,则可采用以下替代方案。</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">请注意，并非所有实现都支持所有这些 &lt;code&gt;Item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">请注意，使用此语法指定的八进制值&amp;gt; = 100不能由前导零引入，因为最多只能读取三个八进制数字。</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">请注意，偏移量以字节为单位，而不是以字符为单位。如果使用 &lt;code&gt;latin1&lt;/code&gt; 以外的其他 &lt;code&gt;encoding&lt;/code&gt; 打开文件，则一个字节不对应一个字符。在此类文件中的定位只能在已知字符边界进行。也就是说，要通过获取当前位置来更早地获取位置，到文件的开头/结尾或通过其他某种方式（通常超出文件中的字节顺序标记）到&lt;strong&gt;已知&lt;/strong&gt;在正确字符边界上的某个其他位置，具有已知的字节大小）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">请注意，在Windows上，此标志仅适用于 &lt;code&gt;werl&lt;/code&gt; ，而不适用于 &lt;code&gt;erl&lt;/code&gt; （ &lt;code&gt;oldshell&lt;/code&gt; ）。还要注意，在Windows上使用 &lt;code&gt;Ctrl-Break&lt;/code&gt; 代替 &lt;code&gt;Ctrl-C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">请注意，在某些系统（例如VxWorks）上，此机制未检测到故障节点，因为操作系统不会自动关闭当节点故障时保持打开状态的描述符。如果节点以这种方式发生故障，则 &lt;code&gt;epmd&lt;/code&gt; 会阻止您使用旧名称注册新节点，因为它认为旧名称仍在使用中。在这种情况下，必须显式注销该名称：</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">请注意，一旦 &lt;code&gt;enif_make_resource&lt;/code&gt; 创建了返回Erlang的术语，代码就可以选择保留其自身的本机指针，以指向所分配的结构并在以后释放它，或者立即释放它，并且仅依赖于垃圾收集器最终在以下情况下释放资源对象：它收集术语。</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">请注意， &lt;code&gt;DiscNodes&lt;/code&gt; 中仅包含具有disc的节点。无盘节点，即包括模式的所有表仅驻留在RAM中的节点，不得包含在内。</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">请注意,每个驱动程序实例上只存在一个定时器;设置一个新的定时器会替换一个旧的定时器。</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">注意,只有在线的调度器才能绑定到逻辑处理器。</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">请注意，只能还原某些格式的表，即已创建并通过 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 备份的表。如果在操作之前注册表不为空，则将表的内容添加到注册表的内容中。如果表包含的对象具有与注册表中已经存在的键相同的键，则注册表对象将被新值覆盖。如果注册表包含表中未包含的对象，则此操作将使它们保持不变。</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">注意,只有通道被关闭。连接还在,可以处理其他通道。</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">注意,Mnesia中只实现了词法SNMP排序,而不是实际的SNMP监控。</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">请注意，参数 &lt;code&gt;Assoc&lt;/code&gt; 是由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义的，对于一对一样式的套接字将被忽略。对于一对多样式的套接字，将特殊值 &lt;code&gt;0&lt;/code&gt; 定义为意味着返回的地址必须没有任何特定的关联。不同的SCTP实现方式对此的解释有些不同。</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">请注意，参数 &lt;code&gt;Assoc&lt;/code&gt; 是由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义的，对于一对一样式的套接字将被忽略。不幸的是，特殊值 &lt;code&gt;0&lt;/code&gt; 表示什么，因此它对于一对多样式套接字的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">请注意，将按钮从 &lt;code&gt;open&lt;/code&gt; 状态推迟到 &lt;code&gt;locked&lt;/code&gt; 状态对于代码锁定来说感觉很奇怪，但这至少说明了事件推迟。</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">请注意，清除代码意味着保留在模块旧代码中的所有进程都会被杀死，而不会发出警告。有关更多信息，请参见 &lt;code&gt;code/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">请注意，必须为联系的 &lt;code&gt;epmd&lt;/code&gt; 守护程序启用宽松的命令检查。交互式运行 &lt;code&gt;epmd&lt;/code&gt; 时， &lt;code&gt;-relaxed_command_check&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">注意,请求一个文件的多个部分向日志文件报告的大小为零。</target>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">注意,Erlang/OTP R16B01或更高版本保存的设置不能被Erlang/OTP R16B或更早版本读取。</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">请注意,由于以下划线开头的变量不是匿名的,所以这符合。</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">注意，一些系统内部事件也可以被接收。因此，必须在事件处理程序回调函数 &lt;code&gt;Module:handle_event/2&lt;/code&gt; 的定义中使用一个包罗万象的子句。这也适用于 &lt;code&gt;Module:handle_info/2&lt;/code&gt; ，因为事件处理程序还必须处理一些系统内部消息。</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">注意， &lt;code&gt;bin_opt_info&lt;/code&gt; 并不是要添加到 &lt;code&gt;Makefile&lt;/code&gt; 的永久选项，因为它生成的所有消息都无法消除。因此，在大多数情况下，将选项传递给环境是最实用的方法。</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;get_until&lt;/code&gt; 请求允许一个函数，其中指定的数据始终为列表。同样，来自该函数的返回值数据可以是任何类型（确实是 &lt;code&gt;io:fread/2,3&lt;/code&gt; 请求发送到I / O服务器时的情况）。客户端必须准备好以各种形式接收作为对这些请求的答复的数据。但是，I / O服务器将在可能的情况下（即，提供给 &lt;code&gt;get_until&lt;/code&gt; 的函数返回列表时）将结果转换为二进制文件。这在&amp;ldquo;带 &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; 部分的示例中完成。</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">请注意，元组 &lt;code&gt;io_reply&lt;/code&gt; 中未明确存在I / O服务器的 &lt;code&gt;pid()&lt;/code&gt; 。可以从任何进程发送答复，而不必是实际的I / O服务器。</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">请注意，不同行为模块的 &lt;code&gt;start_link&lt;/code&gt; 函数满足上述要求。</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">请注意， &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 消息可以是链接的结果，但也可以是 &lt;code&gt;Id&lt;/code&gt; 调用 &lt;code&gt;exit/2&lt;/code&gt; 的结果。因此，它&lt;strong&gt;可以&lt;/strong&gt;是适当的调用后捕获退出时清理消息队列 &lt;code&gt;unlink(Id)&lt;/code&gt; ，如下：</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">请注意，很少使用UTF-8的BOM，它实际上不是&lt;strong&gt;字节顺序&lt;/strong&gt;标记。UTF-8显然没有字节顺序问题，因此BOM仅用于区分UTF-8编码和其他UTF格式。</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">请注意，C程序处于 &lt;code&gt;while&lt;/code&gt; 循环中，正在检查 &lt;code&gt;read_cmd/1&lt;/code&gt; 的返回值。这是因为C程序必须检测端口何时关闭和终止。</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">请注意，内核变量 &lt;code&gt;inetrc&lt;/code&gt; 会覆盖此环境变量。</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">请注意,上述处理程序没有任何过载保护,所有的日志事件都是直接从客户端进程中打印出来的。</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">请注意,上述规范并没有以任何方式限制输入和输出类型。这些类型可以通过类似卫士的子类型约束,并提供有界量化。</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">请注意,明显相似的模式</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">请注意,应用程序版本指定了一个源代码版本。还有一个间接的要求是,所安装的指定版本的二进制应用程序要与系统的其他部分兼容。</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">请注意，该参数是一个仅包含一个，两个或三个参数的列表。 &lt;code&gt;NameType&lt;/code&gt; 默认为 &lt;code&gt;longnames&lt;/code&gt; 和 &lt;code&gt;Ticktime&lt;/code&gt; 至 &lt;code&gt;15000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，SCTP一对多样式套接字的此功能的行为未由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">请注意，编译器不会为参数化类型生成编码/解码函数，仅为参数化类型的实例生成。因此，如果文件如前面的示例中包含类型 &lt;code&gt;General{}&lt;/code&gt; ， &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; ，则仅为 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 生成编码/解码功能。</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">请注意,当前的密钥存储在驱动程序中,并且可能是无效的(例如,如果密钥已被删除)。</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">请注意,TCP/IP套接字的默认选项可以通过本手册页面开头提到的内核配置参数来改变。</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">请注意，类型 &lt;code&gt;SET OF&lt;/code&gt; 的定义意味着未定义组件的顺序，但实际上 &lt;code&gt;SET OF&lt;/code&gt; 和 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 之间没有区别。用于Erlang的ASN.1编译器在编码之前不会随机化 &lt;code&gt;SET OF&lt;/code&gt; 组件的顺序。</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">注意，这种类型的注释的结尾是模式中的文字换行符序列；碰巧代表换行符的转义序列不计算在内。例如，在设置 &lt;code&gt;extended&lt;/code&gt; 时考虑以下模式，并且默认的换行约定生效：</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">请注意，打开文件时指定的文件编码选项与文件名编码约定无关。您可以很好地打开包含以UTF-8编码的数据，但文件名以字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码或相反的文件。</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">注意，包含虚拟机可执行文件（文件系统 &lt;code&gt;beam.smp&lt;/code&gt; 中的例子）必须是本地的，安装而不标志 &lt;code&gt;nosetuid&lt;/code&gt; 的，支持扩展属性和内核必须支持文件的能力。至少在Ubuntu 12.04 LTS上，所有这些都是开箱即用的，除了SCTP套接字似乎不支持网络名称空间。</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">注意，作为表创建过程的一部分，对于其他每个片段（编号1除外），函数 &lt;code&gt;add_frag/2&lt;/code&gt; 都会启动一次。</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">注意，对于模块实际上标记为粘性的或驻留在标记为粘性的目录中的模块而言，该函数可以返回 &lt;code&gt;true&lt;/code&gt; 。原因是直到解释程序尝试加载模块后才发现此问题。</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">请注意,下面的函数使用调用者提供的打开的文件描述符来执行RPC。在全局操作过程中,这个文件描述符不能用于其他流量,因为这样的话,函数可能会收到意外的数据而失败。</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">请注意，最后跟踪的历史记录始终在文件 &lt;code&gt;ttb_last_config&lt;/code&gt; 中可用。</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">请注意,返回的信息是高度依赖于实现的,可以在任何时候改变或删除,而无需事先通知。它最初的目的是作为开发新分配器的工具,但由于它可能会引起其他人的兴趣,因此简要地记录了它。</target>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，整数值仅在Logger中内部使用。在API中，您必须始终使用原子。要比较两个日志级别的严重性，请使用 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">请注意,最后创建的原子是先显示的。</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">请注意，调用该函数时， &lt;code&gt;Request&lt;/code&gt; 元组（ &lt;code&gt;[$\n]&lt;/code&gt; ）中的最后一个元素会附加到参数列表中。该功能将由I / O服务器像 &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">请注意，最后一部分是&amp;ldquo; ang&amp;rdquo;，而不是&amp;ldquo; an&amp;rdquo;，因为将分割指定为两部分，并且在给出足够的部分时分割停止，这就是为什么结果与 &lt;code&gt;trim&lt;/code&gt; 的结果不同的原因。</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">请注意，遍历整个二进制文件后，将放弃 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 中的match上下文。如果迭代在到达二进制末尾之前停止，会发生什么情况？优化是否仍然有效？</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">请注意,返回的对象的顺序是不明确的。特别是,对象插入的顺序没有反映出来。</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">请注意，该程序位于仿真器的 &lt;code&gt;bin&lt;/code&gt; 目录中，而不是直接位于Erlang根目录下的 &lt;code&gt;bin&lt;/code&gt; 目录中。这样做的原因是在运行中的系统上升级仿真器的细微问题，在该系统上，新版本的运行时系统不需要覆盖现有的（并且可能使用过的）可执行文件。</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">注意,如果数据位于远程节点上,程序的运行速度会比较慢。</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">请注意，范围 &lt;code&gt;0..Range-1&lt;/code&gt; 与 &lt;code&gt;phash/2&lt;/code&gt; 的范围不同，后者是 &lt;code&gt;1..Range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">请注意，即使 &lt;code&gt;record_name&lt;/code&gt; 具有其他设置，记录名称也是表名称。</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">请注意，正则表达式必须与完整的版本字符串匹配，因此此示例适用于例如 &lt;code&gt;2.1.1&lt;/code&gt; ，但不适用于 &lt;code&gt;2.1.1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，同样的警告适用于 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">请注意，序列\ A，\ Z和\ z可用于在两种模式下匹配对象的开始和结束。如果模式的所有分支均以\ A开头，则无论是否设置了 &lt;code&gt;multiline&lt;/code&gt; ，它总是固定的。</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">请注意， &lt;code&gt;list()&lt;/code&gt; 的简写形式，即未知类型的元素列表，是 &lt;code&gt;[_]&lt;/code&gt; （或 &lt;code&gt;[any()]&lt;/code&gt; ），而不是 &lt;code&gt;[]&lt;/code&gt; 。符号 &lt;code&gt;[]&lt;/code&gt; 指定空列表的单例类型。</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">注意,保存在RAM中的空间管理数据结构,好友系统,也会被写入磁盘。如果表是碎片化的,这可能需要一些时间。</target>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些值的总和&lt;strong&gt;不是&lt;/strong&gt;模拟器分配的内存总量。一些值是其他值的一部分，而某些存储区不是结果的一部分。有关模拟器分配的内存总量的信息，请参见 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">请注意， &lt;code&gt;map()&lt;/code&gt; 的语法表示形式是 &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; （或 &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; ），而不是 &lt;code&gt;#{}&lt;/code&gt; 。标记 &lt;code&gt;#{}&lt;/code&gt; 指定空映射的单例类型。</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">请注意，此处的模板与 &lt;code&gt;single_line=false&lt;/code&gt; 的模板相同，但是生成的日志条目的不同之处在于标题之后仅一行：</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">请注意,对象插入的时间顺序是保留的;以指定键插入的第一个对象是结果列表中的第一个,以此类推。</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">注意，早期的Erlang / OTP版本支持 &lt;code&gt;.inetrc&lt;/code&gt; 文件的使用，现在已过时。</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">注意,输入到选择解码函数中的值必须是二进制。</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">注意没有&amp;ldquo;;&amp;rdquo; 在 &lt;code&gt;end&lt;/code&gt; 之前。条件与保护措施相同，即测试成功或失败。Erlang从顶部开始进行测试，直到找到成功的条件。然后，它评估（执行）条件之后的动作，并忽略 &lt;code&gt;end&lt;/code&gt; 之前的所有其他条件和动作。如果没有条件匹配，则会发生运行时故障。永远成功的条件是原子 &lt;code&gt;true&lt;/code&gt; 。如果所有其他条件均失败，则通常在 &lt;code&gt;if&lt;/code&gt; 的最后使用它，意思是按照 &lt;code&gt;true&lt;/code&gt; 执行操作。</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">请注意，Erlang驱动程序线程API中没有&amp;ldquo;条件变量等待超时&amp;rdquo;。这是由于 &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; 的问题。当系统时钟突然更改时，不能总是保证您会按预期从呼叫中唤醒。 Erlang运行时系统必须能够应对系统时钟的突然更改。因此，我们从Erlang驱动程序线程API中省略了它。在Erlang驱动程序的情况下，可以并且应该通过Erlang驱动程序API的计时器功能来处理超时。</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，没有针对表的自动垃圾收集。即使没有任何进程对表的引用，除非所有者进程终止，否则不会自动销毁该表。要显式销毁表，请使用函数 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; 。默认所有者是创建表的过程。要在进程终止时转移表所有权，请使用选项 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 或调用 &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">请注意,这些结果是高度特定于实现的,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">请注意,这些值并不能保证是在每个状态下花费的准确时间。这是因为为了保持尽可能小的开销而做的各种优化。</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">注意,这可能会导致消息队列溢出,因为在这种情况下没有办法节制发送者(没有流量控制)。</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">请注意，此代码从不使用 &lt;code&gt;ets:match/2&lt;/code&gt; ，而是使用 &lt;code&gt;ets:lookup/2&lt;/code&gt; 调用。的 &lt;code&gt;lists:map/2&lt;/code&gt; 呼叫仅用于遍历 &lt;code&gt;idno&lt;/code&gt; S IN表匹配名称&amp;ldquo;布赖恩&amp;rdquo;; 因此，主表中的查找次数得以最小化。</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">请注意，这丝毫没有说明如何将字符放置在I / O设备上或由I / O服务器处理。不同的I / O服务器可以根据需要处理字符，这只能告诉I / O服务器期望数据采用哪种格式。在&amp;ldquo; &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; 情况下，&amp;ldquo; &lt;code&gt;Encoding&lt;/code&gt; 告诉指定函数生成哪种格式。</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">请注意，此功能也可以作为代码升级过程的一部分来调用。因此，该功能不应有任何副作用。有关管理程序代码升级的更多信息，请参见《OTP设计原则》中的&amp;ldquo; &lt;code&gt;Changing a Supervisor&lt;/code&gt; 管理程序&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">请注意，此功能不会影响表的选项 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 。例如，表所有者可以将 &lt;code&gt;heir&lt;/code&gt; 设置为自己，将表赠与他人，然后在接收方终止时将其取回。</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">请注意,这个函数并不直接操作日志记录器配置,这意味着如果默认的日志记录器处理程序已经记录到一个文件,这个函数可能会导致记录到第二个文件。</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">请注意，即使使用支持SMP的仿真器，此功能&lt;strong&gt;也不&lt;/strong&gt;是线程安全的。</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">请注意，此函数位于 &lt;code&gt;Erl_Interface&lt;/code&gt; 库中。</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">请注意,该函数只能用于连接到新启动的RAM节点(N.D.R.S.N.),且模式为空。例如,如果在网络被分区后使用这个函数,可能会导致表不一致。</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">请注意,这个标识符有时被称为 &quot;name&quot;。现在尽可能地使用 &quot;标识符 &quot;或 &quot;id&quot;,但为了保持向后的兼容性,仍然可以找到 &quot;name &quot;的出现,例如在错误信息中。</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">请注意，这&lt;strong&gt;不&lt;/strong&gt;等同于反转 &lt;code&gt;select/3&lt;/code&gt; 调用的结果列表，因为结果列表不仅被反转，而且还包含表中的最后一个 &lt;code&gt;Limit&lt;/code&gt; 匹配对象，而不是第一个。</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">请注意，对于2.11.4之前的内核版本，&lt;strong&gt;无法&lt;/strong&gt;保证。</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">请注意，对于2.13之前的内核版本，&lt;strong&gt;不能&lt;/strong&gt;保证这样做。</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">请注意，这是开始生成故障转储时条目的确切快照。因此，它们很可能与&lt;strong&gt;= proc&lt;/strong&gt;部分中相同进程的条目不同（并且更具说服力）。如果当前没有正在运行的进程，则仅显示&amp;ldquo; &lt;strong&gt;当前进程&amp;rdquo;&lt;/strong&gt;条目。</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">请注意,这个列表太长了,以至于在一行上放不下。这并不重要,Erlang允许在所有 &quot;合理的地方 &quot;进行换行,但不允许在原子、整数等中间换行。</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">请注意，这仅影响输出中列表和二进制文件的&lt;strong&gt;启发式&lt;/strong&gt;解释。例如， &lt;code&gt;~ts&lt;/code&gt; 格式序列始终输出有效的字符列表，而不管 &lt;code&gt;+pc&lt;/code&gt; 设置如何，因为程序员已明确请求输出字符串。</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">请注意，此选项不会更改有关 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; 任何保证。对许多对象做出此类承诺的函数（例如 &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; ）从此选项中获得的收益较少（或没有收益）。</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">请注意,这部分以&quot;.&quot;结尾,表示这个函数没有其他部分了。</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">注意，该部分以分号&amp;ldquo;;&amp;rdquo;结尾。表示还有更多功能 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 即将到来。</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">注意，此状态图未指定在 &lt;code&gt;open&lt;/code&gt; 状态下如何处理按钮事件。因此，您需要在此处阅读一些附注，即：未指定的事件将被推迟（在以后的状态中处理）。同样，状态图并未显示必须在每种状态下都必须处理 &lt;code&gt;code_length/0&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">请注意， &lt;code&gt;ordered_set&lt;/code&gt; 尚未提供Ets中的ordered_set类型，也没有对并发更新的有限支持，这使得可以在固定ETS表上安全地使用一系列 &lt;code&gt;first&lt;/code&gt; 调用和 &lt;code&gt;next&lt;/code&gt; 调用。Dets可能会在Erlang / OTP的将来版本中提供这两个功能。在此之前，必须使用Mnesia应用程序（或某些用户实现的锁定方法）来实现安全并发​​。当前，没有Erlang / OTP库支持基于磁盘的有序术语存储。</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">请注意，如果此处出现错误，我们仅返回数据（使用 &lt;code&gt;driver_output&lt;/code&gt; ），否则我们将等待连接完成，在这种情况下，将调用 &lt;code&gt;ready_io&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在调用局部函数时，使用隐式或完全限定的函数名是有区别的。后者总是指模块的最新版本。请参见 &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">请注意，在运行时中更改处理程序的配置时，不得修改disk_log选项（ &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;max_no_files&lt;/code&gt; ， &lt;code&gt;max_no_bytes&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">请注意，在操作PLT时，不会发出警告。要在（重新）分析PLT期间打开警告，请使用 &lt;code&gt;--get_warnings&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">注意，当调用多个事件处理程序时，一个事件处理程序返回一个 &lt;code&gt;hibernate&lt;/code&gt; 请求就足以使整个事件管理器进入休眠状态。</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，当重新启动策略为 &lt;code&gt;simple_one_for_one&lt;/code&gt; 时，子规范的列表必须是仅包含一个子规范的列表。（忽略子规范标识符。）然后在初始化阶段不启动任何子进程，但是假定所有子进程都使用 &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; 动态启动。</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">请注意，您不必担心在创建记录时为记录的各个部分分配值的顺序。使用记录的好处是，通过将其定义放在头文件中，您可以方便地定义易于更改的接口。例如，如果要向记录添加新字段，则只需更改使用新字段的代码，而不必在引用记录的每个位置都进行更改。如果在创建记录时遗漏了某个字段，那么它将获得原子 &lt;code&gt;undefined&lt;/code&gt; 的值。（*手册*）</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">请注意，如本例所示， &lt;code&gt;String&lt;/code&gt; 中两个或多个相邻的分隔符被视为一个。也就是说，结果标记列表中没有空字符串。</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">请注意，如本示例所示， &lt;code&gt;String&lt;/code&gt; 中两个或多个相邻的分隔符字素簇被视为一个。即，结果词素列表中没有空字符串。另请参见 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; ，它返回空字符串。</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注意，例如，在 &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; 使用字符串文字是&amp;lt;&amp;lt; $ a，$ b，$ c &amp;gt;&amp;gt;的语法糖。</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">注意，使用Erlang中的二进制语法，驱动程序可以直接从二进制文件中匹配标头，因此可以将标头放入二进制文件中，并将 &lt;code&gt;hlen&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">注意第二种情况中的 &lt;code&gt;--&lt;/code&gt; 分隔符。</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">注意到小数(浮点数)的引入,没有任何解释。希望你能应付一下。</target>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">请注意，&lt;strong&gt;匹配&lt;/strong&gt;和&lt;strong&gt;比较equal&lt;/strong&gt;之间有细微的差别，表类型 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;ordered_set&lt;/code&gt; 证明了这一点：</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">请注意标签 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; ，它们在封面规格文件和 &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; 的调用中使用。这些的目的仅是将Cover规范中指定的模块映射到对analytics函数的调用中指定的日志目录。标记名称没有其他含义。</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">请注意，与普通算术一样，请使用方括号，乘法运算符&amp;ldquo; *&amp;rdquo;和除法运算符&amp;ldquo; /&amp;rdquo;（请参见 &lt;code&gt;Expressions&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">注意没有&amp;ldquo;;&amp;rdquo; 在 &lt;code&gt;end&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">然而,请注意,PCRE对\G的解释是当前匹配的开始,与Perl的解释有细微的不同,Perl将其定义为前一次匹配的结束。在Perl中,当之前匹配的字符串是空的时候,这两者可能是不同的。由于PCRE一次只进行一次匹配,所以它不能重现这种行为。</target>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">在SMIv1中,通知的定义是在MIB的定义中使用TRAP-TYPE宏(见RFC1215)。SMIv2中对应的宏是NOTIFICATION-TYPE。当应用程序决定发送通知时,它调用以下函数之一。</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">代理商的通知/陷阱会传递给进行注册的用户。</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">通知何时重新加载驱动程序（如果正在加载，则加载驱动程序）。仅监视正在加载或重新加载过程中的驱动程序才有意义。无法监视将来用于加载的驱动程序名称。这只会导致立即发送 &lt;code&gt;DOWN&lt;/code&gt; 消息。因此，在由 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 函数触发时，监视加载是最有用的，&lt;strong&gt;因为&lt;/strong&gt;驱动程序处于挂起状态，因此创建了监视器。</target>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">现在， &lt;code&gt;A&lt;/code&gt; 产生了摘要和它自己的挑战。这些一起打包发送到 &lt;code&gt;B&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">现在可以实现 &lt;code&gt;complex1:foo/1&lt;/code&gt; 和 &lt;code&gt;complex1:bar/1&lt;/code&gt; 。两者都向 &lt;code&gt;complex&lt;/code&gt; 过程发送一条消息，并收到以下答复：</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">现在可以实现 &lt;code&gt;complex5:foo/1&lt;/code&gt; 和 &lt;code&gt;complex5:bar/1&lt;/code&gt; 。两者都向 &lt;code&gt;complex&lt;/code&gt; 过程发送消息并收到以下答复：</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">现在，将使用列表的其余部分作为参数调用 &lt;code&gt;format_temps(Rest)&lt;/code&gt; 。这种处理方式类似于其他语言中的循环构造。 （是的，这是递归，但是不要让您担心。）因此，再次调用了相同的 &lt;code&gt;format_temps&lt;/code&gt; 函数，这次 &lt;code&gt;City&lt;/code&gt; 获得了值 &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; ,并且重复了相同的过程。完成此操作，直到列表变为空，即[]，从而使第一子句 &lt;code&gt;format_temps([])&lt;/code&gt; 匹配。这只是返回（导致）原子 &lt;code&gt;ok&lt;/code&gt; ，因此程序结束。</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">现在彼得用c1@bilbo登录。</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">现在彼得给弗雷德发了一条信息。</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">现在必须添加一个函数来寻找最高和最低温度的城市。下面的程序不是最有效的方法,因为你要把城市列表走四遍。但还是先追求清晰和正确,只有在需要的情况下,才会让程序高效。</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">现在一个 &lt;code&gt;ETERM&lt;/code&gt; 可以使用函数来构造表示所述整数结果结构 &lt;code&gt;erl_mk_int()&lt;/code&gt; 从 &lt;code&gt;erl_eterm&lt;/code&gt; 。也可以使用模块 &lt;code&gt;erl_format&lt;/code&gt; 中的函数 &lt;code&gt;erl_format()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">现在以乒乓为例,用链接来终止 &quot;乒乓&quot;。</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">现在举个例子,在处理列表时--颠倒列表的顺序。</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">现在假设对 &lt;code&gt;Expression&lt;/code&gt; 的解释是一组调用。如果命名类型比表达式类型更通用（分别说 &lt;code&gt;Mod&lt;/code&gt; 和 &lt;code&gt;Fun&lt;/code&gt; )，则强制转换表达式的解释是调用集（M1，M2），这样表达式的解释包含来自M1某些函数的调用M2的某些功能。如果命名类型比表达式类型更特殊，例如 &lt;code&gt;Fun&lt;/code&gt; 和 &lt;code&gt;Mod&lt;/code&gt; ，则解释是所有函数调用（F1，F2）的集合，这样表达式的解释包含一个调用（M1，M2），而F1是M1和F2的功能是M2的功能（在 &lt;code&gt;modules&lt;/code&gt; 模式下，没有函数调用，因此强制转换为 &lt;code&gt;Fun&lt;/code&gt; 总是产生一个空集）。同样，与应用程序和发行版之间的转换也是如此。</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">现在回到乒乓球的例子。</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">现在将目录更改为基本目录，并设置 &lt;code&gt;$ERL_TOP&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">现在举一个较大的例子来巩固到目前为止所学的知识。假设你有一份来自世界上许多城市的温度读数列表,其中有些是摄氏度,有些是华氏度(如前面的列表)。其中有些是以摄氏度为单位,有些是以华氏度为单位(如前面的列表)。首先让我们把它们全部转换为摄氏度,然后让我们整齐地打印数据。</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">现在举个大一点的例子,用一个简单的 &quot;信使&quot;。这个 &quot;信使 &quot;是一个允许用户在不同的节点上登录并互相发送简单消息的程序。</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">现在举个更复杂的例子,一个数字的阶乘。例如,4的阶乘是4*3*2*1,等于24。</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">现在让我们回到城市和温度的问题上,但这次要采取更有条理的方法。首先,让我们将整个列表转换为摄氏度,如下所示。</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">现在让我们回到代码的前两行。Erlang程序以文件形式编写。每个文件都包含一个Erlang &lt;strong&gt;模块&lt;/strong&gt;。模块中的第一行代码是模块名称（请参阅 &lt;code&gt;Modules&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">现在让我们看看 &quot;ping &quot;这个过程。回顾一下,它是通过执行以下命令启动的。</target>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">现在运行程序。</target>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">现在开始对咕噜进行 &quot;庞 &quot;的处理。</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">现在可以生成 &lt;code&gt;relup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">现在， &lt;code&gt;tut2&lt;/code&gt; 程序几乎不是好的编程风格。考虑：</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">现在可以启动C节点。如果使用短节点名，则通过调用 &lt;code&gt;erl_connect_init()&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">现在C节点服务器可以接受来自Erlang节点的连接。</target>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">现在我们来谈谈更有趣的事情。</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">现在，我们有了可以以各种方式启动的目标系统。我们通过调用以下命令将其作为&lt;strong&gt;基本目标系统&lt;/strong&gt;启动：</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">现在，我们来看另一个有趣的伪函数， &lt;code&gt;garbage_collect&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">现在我们要从表中读取数据。函数 &lt;code&gt;get_until/5&lt;/code&gt; 读取数据并应用该函数，直到它说完成为止。结果发送回客户端：</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">现在当列表转换后,增加了一个打印的功能。</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">现在你已经为一些Unicode输入和输出做好了准备。最简单的做法是在shell中输入一个字符串。</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">现在，您可以通过在外壳中编写 &lt;code&gt;type erlc&lt;/code&gt; 来检查您拥有哪个erlc 。它应位于 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 或 &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">现在，在 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; 中将有一个名为 &lt;code&gt;otp_win32_21.exe&lt;/code&gt; 或 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 的文件，即 &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">现在， &lt;code&gt;fact(0)&lt;/code&gt; 被调用，并且函数子句再次被顺序扫描。首先，将模式 &lt;code&gt;N&lt;/code&gt; 与0匹配。匹配成功，但是防护（ &lt;code&gt;N&amp;gt;0&lt;/code&gt; ）为false。其次，将模式0与0进行匹配。匹配成功并且对主体进行了评估：</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">现在,回到例子中,我们想让输出更有安排。有了模板。</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">现在，假设 &lt;code&gt;m1&lt;/code&gt; 是一个库模块，那么系统 &lt;code&gt;s2&lt;/code&gt; 也经常使用它。测试运行 &lt;code&gt;s2&lt;/code&gt; 并没有专门测试 &lt;code&gt;m1&lt;/code&gt; ，但是查看 &lt;code&gt;s2&lt;/code&gt; 测试涵盖了 &lt;code&gt;m1&lt;/code&gt; 的哪些部分仍然很有趣。为此， &lt;code&gt;m1&lt;/code&gt; 也可以包含在 &lt;code&gt;s2&lt;/code&gt; 的封面规范中，如下所示：</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">现在，这样的 &lt;code&gt;monitor&lt;/code&gt; 调用将成功，并创建一个监视器。但是监控器只会监督连接。也就是说， &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; 是唯一可以接收的消息，因为原始节点无法报告所监视进程的状态。</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">现在,折叠和地图可以同时进行。</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">现在的编译器把列表理解改写成普通的递归函数。使用尾部有反转的递归函数还是会更快。或者说会吗?这就导致了尾递归函数比体递归函数快的神话。</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">上次读取表后，将一次调用 &lt;code&gt;PostFun&lt;/code&gt; 回调函数PostFun。捕获的返回值将被忽略。如果 &lt;code&gt;PreFun&lt;/code&gt; 已经呼吁建立一个表， &lt;code&gt;PostFun&lt;/code&gt; 可以保证被称为该表，即使查询的评估由于某种原因失败。</target>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Nullsoft NSIS安装系统。你需要这个来构建自安装包。这是一个免费的开源安装程序,比商业的Wise和Install shield安装程序好用得多。这也是我们用于商业版本的安装程序。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">Number ::=-与非负的 Erlang 整数相同--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</target>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">这把锁的收购数量。</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">一个函数或函数的参数数</target>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">套接字收到的字节数。</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">从套接字发送的字节数。</target>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">从导出的函数中调用的次数。</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">当一个线程试图获取这个锁时的碰撞次数。这时,trylock是ebusy,读持有rw_lock时的写尝试,写持有rw_lock时的读尝试,线程尝试锁定一个已经锁定的锁。内部状态监督)。</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">待收到的数据块数量</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">入站流的数量</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">要显示的行数(进程)。</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">文件的链接数(对于没有链接概念的文件系统,这个数字总是1)。</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">如果对等体不关闭连接,在传入DPR后终止传输连接的毫秒数。</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">如果没有收到DPA,在发出DPR后终止传输连接的毫秒数。</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">如果未从对等方接收到预期的功能交换消息（CER或CEA），则具有建立的传输连接的传输过程将终止的毫秒数。对于连接传输，连接尝试的时间由 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 到期时间控制。对于侦听传输，对等方确定时间。</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">请求超时的毫秒数。默认值为5000。</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果尚未收到DPA，则终止传输过程的毫秒数。默认为 &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">距离信息发出的时间还剩多少毫秒。</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">出境流的数量</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">套接字收到的数据包数量。</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">从套接字发送的数据包数量。</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">要启动的传输过程数。对于侦听传输，确定接受传输过程的池的大小，其中较大的数目对于处理多个并发的对等连接尝试是理想的。用于连接传输，确定将试图被establshed所讨论的连接的对等体的数量：所述 &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;restrict_connections&lt;/code&gt; 也应该对有问题的服务被配置成允许到同一对等体的多个连接。</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">未acked数据块的数量</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs/2+1 | 0</target>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBC数据类型</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">OS X(达尔文)</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x/Snow Leopard、OS X 10.7.x/Lion 以及可能的更新版本。</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X/Darwin。32位模式下的Darwin 9.8.0应该可以使用。</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">操作系统消息格式为元组 &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作系统系统时间也可以通过 &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; 恢复。</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">当用户最终确定时间偏移时,操作系统系统时间必须正确。</target>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP还支持更改行为流程的内部状态，请参阅 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">检察官办公室和(因此)Mnesia数据库。</target>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">特定版本的OTP是特定版本的一组应用程序。OTP版本标识的应用程序版本对应于爱立信AB的Erlang / OTP团队一起测试过的应用程序版本。但是，可以将OTP系统与来自不同OTP版本的应用程序放在一起。应用程序版本的这种组合未经Erlang / OTP团队的测试。因此，&lt;strong&gt;始终首选使用来自单个OTP版本的OTP应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">Unix的OTP启动脚本示例。</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTP支持在创建 &lt;code&gt;.appup&lt;/code&gt; 文件时使用的一组&lt;strong&gt;发行处理说明&lt;/strong&gt;。发布处理程序了解这些&lt;strong&gt;低级&lt;/strong&gt;指令的子集。为了使用户更容易使用，还有许多&lt;strong&gt;高级&lt;/strong&gt;指令，这些指令由 &lt;code&gt;systools:make_relup&lt;/code&gt; 转换为低级指令。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">因此，除 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; 外，OTP不支持更改居住模块。</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP /加密要求用户提供有关密钥的两三项信息。用户使用的应用程序通常处于较高级别，例如 &lt;code&gt;SSL&lt;/code&gt; 。如果直接使用加密应用程序，则要求：</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">对象标识符，由 &lt;code&gt;ASN.1&lt;/code&gt; 编译器生成的整数元组。</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 的基于对象的编程</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">对象通过set和get函数进行存储和检索。下面的例子展示了如何存储整数、浮点数、字符串和任意二进制对象。</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">可以从注册表中删除对象。</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">观察E2可以给E不同，举例来说如果有中定义的默认值 &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">请注意 &quot;TerminationId &quot;记录在内部表格中没有使用。它已经被一个megaco_term_id记录取代了(定义在 &quot;megaco/include/megaco.rl &quot;中)。</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">观察白色空间:标记之间的每个空格、制表符或换行都会导致xmlText记录。</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">观察者是一个观察Erlang系统特性的图形化工具,它可以显示系统信息、应用监督树、进程信息、ETS表、Mnesia表,并包含了Erlang追踪的前端。观察者可以显示系统信息、应用监督树、进程信息、ETS表、Mnesia表,并包含Erlang追踪的前端。</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Observer是用于观察Erlang系统特征的图形工具。Observer工具显示系统信息，应用程序主管树，过程信息，ETS表，Mnesia表，并包含用于模块 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 的 Erlang跟踪的前端。</target>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">没有任何影响的过时标志，并且 &lt;code&gt;-setcookie&lt;/code&gt; 常见拼写错误。请改用 &lt;code&gt;-setcookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">显然,PCRE不能支持Perl代码的插值。相反,它支持整个模式的递归,以及单个子模式的递归的特殊语法。这种递归在PCRE和Python中引入后,后来在5.10版本中被引入Perl中。</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">很明显,如果列表的原始顺序很重要的话,这段代码就不起作用了。如果必须保留清单的顺序,请按以下方式操作。</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">在ECDSA密钥中,通常只有RSA、DSA或ECDSA公钥,但可以添加其他公钥的处理。</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">关:正常的黑白显示。</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">离线支持- 用于生成脚本和构建发行包的 &lt;code&gt;systools&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">与当前位置的偏移。</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">从文件末尾开始偏移。</target>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">奥汉姆空间标记</target>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">必须更新旧驱动程序（与ERTS 5.9之前的 &lt;code&gt;erl_driver.h&lt;/code&gt; 一起编译），并且必须使用扩展接口（带有 &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">省略 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 返回的列表中的 &lt;code&gt;options&lt;/code&gt; 和 &lt;code&gt;source&lt;/code&gt; 元组。此选项将使实现可复制的构建更加容易。</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">省略行号信息,以产生一个稍小的输出文件。</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">然后，省略的字段将获得评估 &lt;code&gt;ExprL&lt;/code&gt; 的值，而不是其默认值。此功能主要用于为ETS和Mnesia匹配功能创建模式。</target>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">在32位架构上：-134217729 &amp;lt;i &amp;lt;134217728（28位）。</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">在32位架构上。4个字:</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">在32位架构上。从当前本地节点引用5个字+从另一个节点引用7个字。</target>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">在64位体系结构上：-576460752303423489 &amp;lt;i &amp;lt;576460752303423488（60位）。</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">在64位架构上。3个字:</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">在64位架构上。当前本地节点的引用为4个字+另一节点的引用为6个字。</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">在C节点上， &lt;code&gt;erl_interface&lt;/code&gt; 支持注册表表。这些表位于C节点的RAM中，但也可以转储到Mnesia表中。默认情况下，通过 &lt;code&gt;erl_interface&lt;/code&gt; 转储注册表表会导致在必要时使用 &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; 创建相应的Mnesia表。</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">关于达尔文。</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">在Linux或UNIX上，您可以放心地忽略它，只需在执行命令 &lt;code&gt;cd&lt;/code&gt; 之后不带任何参数的情况下， &lt;code&gt;.erlang.cookie&lt;/code&gt; 在目录中创建一个名为.erlang.cookie的文件。</target>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; os环境变量XDG_CACHE_HOME。</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">在Linux上：遵守os环境变量 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上：遵守os环境变量 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; os环境变量XDG_DATA_DIRS。</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; os环境变量XDG_DATA_HOME。</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">在UNIX上，发布处理程序告诉 &lt;code&gt;heart&lt;/code&gt; 程序使用哪个命令来重新引导系统。在这种情况下， &lt;code&gt;heart&lt;/code&gt; 程序通常使用的环境变量 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 被忽略。该命令默认改为 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 。可以使用SASL配置参数 &lt;code&gt;start_prg&lt;/code&gt; 设置另一个命令，请参见 &lt;code&gt;sasl(6)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">在Ubuntu上，可以通过 &lt;code&gt;aptitude&lt;/code&gt; 安装：</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">在Unix平台上,可以设置上述以外的其他位。</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">在Unix平台上,如果Unicode文件名翻译生效,环境设置使用UTF-8编码。在Windows平台上,环境的设置使用宽字符接口。</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">在Unix系统上,Erlang运行时将解释两种类型的信号。</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">在Unix上， &lt;code&gt;event&lt;/code&gt; 是管道或套接字句柄（或 &lt;code&gt;select&lt;/code&gt; 系统调用可以理解的事件）。</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">在Unix上， &lt;code&gt;Osname&lt;/code&gt; 具有与 &lt;code&gt;uname -s&lt;/code&gt; 返回相同的值，但小写。例如，在Solaris 1和2上，它是 &lt;code&gt;sunos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">在Unix上,为这个字段指定的任何值都会被忽略(文件的 &quot;ctime &quot;被设置为当前时间)。在Windows上,该字段是为文件设置的新创建时间。</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">在类似Unix的操作系统上,如果启用了Unicode文件名,参数应该是UTF-8,不需要翻译。</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">在类似Unix的操作系统上，终端应能够处理输入和输出的UTF-8（例如，通过现代版本的XTerm，KDE Konsole和Gnome终端来完成），并且您的语言环境设置必须为正确。例如，可以如下设置 &lt;code&gt;LANG&lt;/code&gt; 环境变量：</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">在Windows XP中，选择&lt;strong&gt;控制面板&lt;/strong&gt; &amp;gt; &lt;strong&gt;区域和语言选项&lt;/strong&gt;，选择标签&lt;strong&gt;语言&lt;/strong&gt;，并单击按钮&lt;strong&gt;详细...&lt;/strong&gt;在广场命名为&lt;strong&gt;文字服务和输入语言&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">在Windows平台上,当以长名分布式模式启动时,Erlang会搜索系统注册表而不是寻找配置文件。</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">在Windows系统中,主目录是由环境变量$HOME指出的目录--你可能需要设置它。</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">在Windows上， &lt;code&gt;event&lt;/code&gt; 是 &lt;code&gt;Event&lt;/code&gt; 或 &lt;code&gt;Semaphore&lt;/code&gt; （或 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API函数可以理解的事件）。（仿真器中的一些欺骗手段允许使用超过64个 &lt;code&gt;Events&lt;/code&gt; 的内置限制。）</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">在Windows上，默认值设置为 &lt;code&gt;8196&lt;/code&gt; ,因为将正常的操作系统限制设置为高于大多数计算机可以处理的范围。</target>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">在Windows上， &lt;code&gt;Osname&lt;/code&gt; 是 &lt;code&gt;nt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">在Windows上，正确的操作要求安装并选择适当的字体供Erlang应用程序使用。如果系统上没有合适的字体，请尝试安装免费的 &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; ，然后在Erlang Shell应用程序中选择该字体。</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">在Windows上，数据是从不同的OS API函数获取的，因此可以像一些 &lt;code&gt;Flag&lt;/code&gt; 值一样计算 &lt;code&gt;Netmask&lt;/code&gt; 和 &lt;code&gt;Broadaddr&lt;/code&gt; 值。报告恶意错误。</target>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">在Windows上,启动Erlang系统进行交互使用的首选方法如下。</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">在Windows上,使用分号作为分隔符。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">在Windows上。</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">在Unix系统中,你可以通过命令行查看手册页面,使用的是</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">在类似Unix的系统上，可以将 &lt;code&gt;ERL_LIBS&lt;/code&gt; 设置为以下内容</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">从概念上讲，使用Erlang ODBC API启动数据库连接是一个基本的客户端服务器应用程序。客户端进程使用API​​来启动管理连接的服务器进程并与之通信。 Erlang ODBC应用程序的策略是，应用程序本身的编程错误将导致连接过程异常终止。（当过程异常终止时，其主管将记录相关的错误报告。）在连接终止期间或之后调用API函数进程，将返回 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 。另一方面，上下文错误不会终止连接，只会将 &lt;code&gt;{error, Reason}&lt;/code&gt; 返回给客户端，其中 &lt;code&gt;Reason&lt;/code&gt; 可能是任何erlang术语。</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">在一个文件中,术语由一个头和一个二进制表示。两个选项定义了文件中术语的格式。</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">在一个单核系统上,或者如果它是一个非重入式扫描器,则会创建一个端口。在多核系统中,如果是重入式扫描器,则会创建多个端口(每个调度器一个)。</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">在使用释放处理的系统上，始终将其设置为 &lt;code&gt;ignore&lt;/code&gt; 。如果失败，请使用 &lt;code&gt;heart&lt;/code&gt; 重新启动服务。</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">在一个没有操作系统单调时间的系统上,Erlang单调时间保证了单调性,但不能给出其他保证。对Erlang单调时间的频率调整取决于所使用的时间扭曲模式。</target>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">在嵌入式系统上，系统关闭时通常没有电源，甚至没有电池。当系统启动时，此类系统上的系统时钟通常会偏离。如果 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; ，并且在更正OS系统时间之前启动了Erlang运行时系统，则Erlang系统时间可能会长时间，数百年甚至更长的时间是错误的。</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">在嵌入式系统上， &lt;code&gt;erlsrv&lt;/code&gt; 模块将用于将Erlang进程作为Windows系统服务安装。Windows NT启动后，可以启动此服务。</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在应用程序（ &lt;code&gt;app&lt;/code&gt; ）级别，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在应用程序（ &lt;code&gt;escript&lt;/code&gt; ）级别，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">在没有 &lt;code&gt;crypto&lt;/code&gt; ， &lt;code&gt;ssl&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; 的构建中，未定义函数的测试用例失败。验证失败的测试用例日志仅显示对跳过的应用程序的调用。</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">在每个Erlang节点上，可以将一个进程设置为&lt;strong&gt;系统跟踪器&lt;/strong&gt;。每当发送或接收带有跟踪令牌的消息时（如果设置了跟踪令牌标志 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; ），此过程将接收跟踪消息。然后，系统跟踪程序可以打印每个跟踪事件，将其写入文件或任何合适的文件。</target>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">在编码时,OctetString()IPv4地址以通常的x.x.x.x格式进行解析,而IPv6地址则以RFC 2373的2.2节 &quot;地址的文本表示 &quot;指定的任何格式进行解析。一个IPv4元组()的长度为4,包含的值类型为0...255。一个IPv6元组()的长度为8,包含类型为0...65535的值。在解码时使用元组表示法。</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">在编码时，可以将OctetString（）指定为iolist（），过大的浮点数（绝对值）等效于 &lt;code&gt;infinity&lt;/code&gt; 或 &lt;code&gt;'-infinity'&lt;/code&gt; 并且过大的整数会导致编码失败。分组的AVP记录如上一节所述。</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">在编码时,端口、传输和协议字段分别默认为3868、sctp和diameter。OctetString值的DiameterURI()的语法是RFC 6733的4.3节中规定的。解码时使用记录表示。</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">在编码时,可以使用 dictionary 的 hrl 文件中定义的宏来指定值。</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">遇到字符＃时， &lt;code&gt;pcre_compile()&lt;/code&gt; 会跳过，在模式中寻找换行符。在此阶段，序列\ n仍为原义，因此不会终止注释。只有代码值为0x0a的字符（默认换行符）才这样做。</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">失败时，即找不到此类环境变量，则返回值&amp;lt; &lt;code&gt;0&lt;/code&gt; 。如果 &lt;code&gt;value&lt;/code&gt; 缓冲区的大小太小，则返回值&amp;gt; &lt;code&gt;0&lt;/code&gt; ，并且已将 &lt;code&gt;*value_size&lt;/code&gt; 设置为所需的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">On gollum:</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">在kosken(Linux/UNIX系统上)。</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">在1-10行中，包含了驱动程序所需的OS标头。由于此驱动程序是为Solaris编写的，因此我们知道头文件 &lt;code&gt;uio.h&lt;/code&gt; 存在。因此，预处理器变量 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 可以之前定义 &lt;code&gt;erl_driver.h&lt;/code&gt; 被包括在线路12的定义 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 将使Erlang的驱动程序队列用于对应于操作系统同上，这是很方便的I / O的载体。</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">在第16-23行声明了不同的回调函数(&quot;正向声明&quot;)。</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">在第4-8行处理端口处于 &lt;code&gt;data&lt;/code&gt; 模式或 &lt;code&gt;intermediate&lt;/code&gt; 模式且其余例程处理不同命令的情况。该例程使用 &lt;code&gt;driver_failure_posix()&lt;/code&gt; 例程报告错误（例如，参见第15行）。请注意，故障例程对 &lt;code&gt;uds_stop&lt;/code&gt; 例程进行了调用，该例程将删除内部端口数据。因此，在 &lt;code&gt;driver_failure&lt;/code&gt; 调用之后，该句柄（以及强制转换的句柄 &lt;code&gt;ud&lt;/code&gt; ）是&lt;strong&gt;无效的指针&lt;/strong&gt;，我们应该&lt;strong&gt;立即返回&lt;/strong&gt;。运行时系统将向所有链接的进程发送退出信号。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">在Linux上，除了 &lt;code&gt;free_memory&lt;/code&gt; 之外，模拟器可用的内存是 &lt;code&gt;cached_memory&lt;/code&gt; 和 &lt;code&gt;buffered_memory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">在许多平台上,操作系统只支持状态码0-255。过大的状态码会通过清除高位截断。</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在模块（ &lt;code&gt;mod&lt;/code&gt; ）级别上，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">在大多数平台上，必须先在套接字上设置此选项，然后才能将其与地址关联。因此，仅在创建套接字时指定它，而在调用包含此描述的函数（ &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; ）时不使用它是合理的。</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">在两个节点中的一个。</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">在具有强制性Unicode文件名的操作系统上，这意味着您可以更轻松地遵循其他（非Erlang）应用程序的文件名。您还可以处理至少在Windows上无法访问的文件名（因为具有无法在ISO Latin-1中表示的名称）。另外，避免在MacOS X上创建难以理解的文件名，因为操作系统的 &lt;code&gt;vfs&lt;/code&gt; 层会接受所有文件名，因为UTF-8不会重写它们。</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">在具有透明命名的操作系统（例如，除MacOS X之外的所有Unix系统）上，如果终端支持UTF-8，则默认值为 &lt;code&gt;utf8&lt;/code&gt; ，否则为 &lt;code&gt;latin1&lt;/code&gt; 。启动 &lt;code&gt;erl&lt;/code&gt; 时，可以使用 &lt;code&gt;+fnl&lt;/code&gt; （强制为 &lt;code&gt;latin1&lt;/code&gt; 模式）或 &lt;code&gt;+fnu&lt;/code&gt; （强制为 &lt;code&gt;utf8&lt;/code&gt; 模式）覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">在具有透明命名的操作系统上，文件的名称可能不一致，例如，某些文件以UTF-8编码，而其他文件则以ISO Latin-1编码。引入了&lt;strong&gt;原始文件名&lt;/strong&gt;的概念，以处理在 &lt;code&gt;utf8&lt;/code&gt; 模式下运行时名称不一致的文件系统。</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">在其他受支持的系统上，请参阅 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; 以了解如何启用HiPE。</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">在支持它的平台上，启用POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 同步I / O标志或它的依赖于平台的等效标志（例如Windows上的 &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; ），以便写入文件块，直到将数据物理写入磁盘为止。但是，请注意，该标志的确切语义因平台而异。例如，Linux或Windows都不保证在调用返回之前也写入所有文件元数据。有关精确的语义，请检查平台文档的详细信息。在不支持POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 或等效版本的平台上，使用 &lt;code&gt;sync&lt;/code&gt; 标志会导致 &lt;code&gt;open&lt;/code&gt; 返回 &lt;code&gt;{error, enotsup}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">在某些操作系统上，当 &lt;code&gt;epmd&lt;/code&gt; 作为守护程序运行时，将使用&lt;strong&gt;syslog&lt;/strong&gt;进行错误报告。要启用错误日志记录，必须编辑/etc/syslog.conf文件并添加一个条目：</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">在某些平台上,如果设置了特定的locales,Perl可能会有奇怪的表现。如果你在编译时出现错误,请尝试设置LANG变量。</target>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">在某些平台上，此选项唯一允许的值为 &lt;code&gt;true&lt;/code&gt; ，例如OpenBSD和Windows。在这种情况下，尝试在创建套接字时将此选项设置为 &lt;code&gt;false&lt;/code&gt; 会失败。</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">在某些平台上,这个功能可能没有效果。</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">在某些系统上，可能有必要链接更多的库（例如，在Solaris上为 &lt;code&gt;libnsl.a&lt;/code&gt; 和 &lt;code&gt;libsocket.a&lt;/code&gt; ，在Windows上为 &lt;code&gt;wsock32.lib&lt;/code&gt; ）以使用 &lt;code&gt;Erl_Interface&lt;/code&gt; 的通信功能。</target>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功时，将返回 &lt;code&gt;0&lt;/code&gt; ，并初始化 &lt;code&gt;obuf&lt;/code&gt; 以包含表统计信息，否则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">上的成功， &lt;code&gt;0&lt;/code&gt; 则返回，环境变量的值已经被写入到 &lt;code&gt;value&lt;/code&gt; 缓冲器，和 &lt;code&gt;*value_size&lt;/code&gt; 包含字符串的长度（不包括终止 &lt;code&gt;NULL&lt;/code&gt; 写入的值的字符） &lt;code&gt;value&lt;/code&gt; 缓冲液中。</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功后，用连接客户端的地址和节点名称填充 &lt;code&gt;conp&lt;/code&gt; ，并返回文件描述符。如果失败， &lt;code&gt;ERL_ERROR&lt;/code&gt; 返回和 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">成功时， &lt;code&gt;v&lt;/code&gt; （和 &lt;code&gt;size&lt;/code&gt; 如果对象是二进制）被初始化与相关联的值 &lt;code&gt;key&lt;/code&gt; ，并且该函数返回 &lt;code&gt;EI_INT&lt;/code&gt; ， &lt;code&gt;EI_FLT&lt;/code&gt; ， &lt;code&gt;EI_STR&lt;/code&gt; ，或 &lt;code&gt;EI_BIN&lt;/code&gt; ，指示对象的类型。失败时，返回 &lt;code&gt;-1&lt;/code&gt; ，并且不更新参数。</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">成功后，返回将调用过程连接到EPMD的描述符。失败时，将返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为：</target>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">成功时，设置 &lt;code&gt;*key&lt;/code&gt; 和 &lt;code&gt;*value&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。如果迭代器位于头（在第一个条目之前）或尾（在最后一个条目之后），则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功时，将 &lt;code&gt;*pid&lt;/code&gt; 设置为使用 &lt;code&gt;name&lt;/code&gt; 注册的本地进程，并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 不是注册过程或不是原子，则返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;*pid&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功后，将 &lt;code&gt;*port&lt;/code&gt; 设置为使用 &lt;code&gt;name&lt;/code&gt; 注册的端口，并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 不是注册的端口或不是原子，则返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;*port&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">成功后，将结果项存储在 &lt;code&gt;*term&lt;/code&gt; 并返回读取的字节数。如果解码失败或 &lt;code&gt;opts&lt;/code&gt; 无效，则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功后，该函数将返回 &lt;code&gt;ERL_MSG&lt;/code&gt; ,并且如上所述将 &lt;code&gt;Emsg&lt;/code&gt; 结构或 &lt;code&gt;ERL_TICK&lt;/code&gt; 初始化，在这种情况下，不会返回任何消息。如果失败，该函数返回 &lt;code&gt;ERL_ERROR&lt;/code&gt; 和套 &lt;code&gt;erl_errno&lt;/code&gt; 到之一：</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功时，函数返回 &lt;code&gt;ok&lt;/code&gt; 。失败时，该函数将返回一个不透明的错误，但前面所述的 &lt;code&gt;pending_process&lt;/code&gt; 错误除外。不透明错误将通过 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 函数转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功时，函数返回 &lt;code&gt;ok&lt;/code&gt; 。失败时，返回值为 &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; ，其中 &lt;code&gt;ErrorDesc&lt;/code&gt; 是一个不透明的术语，可以通过 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 函数转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功后，函数将返回一个描述符，该描述符将调用过程连接到EPMD。失败时，返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">成功后，该函数将返回一个指向资源类型的指针，并将 &lt;code&gt;*tried&lt;/code&gt; 设置为 &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; 或 &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; 来指示已完成操作。失败时，返回 &lt;code&gt;NULL&lt;/code&gt; 并将 &lt;code&gt;*tried&lt;/code&gt; 设置为 &lt;code&gt;flags&lt;/code&gt; 。它允许设置 &lt;code&gt;tried&lt;/code&gt; 以 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">成功后，该函数将返回一个包含指定名称地址的Erlang pid，并将该节点初始化为找到 &lt;code&gt;name&lt;/code&gt; 的节点名称。失败时，将返回 &lt;code&gt;NULL&lt;/code&gt; ，并且不会修改 &lt;code&gt;node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">成功后，该函数将返回一个字符串数组，每个字符串包含一个注册的名称，并将 &lt;code&gt;count&lt;/code&gt; 设置为找到的名称数。该数组由单个 &lt;code&gt;NULL&lt;/code&gt; 指针终止。失败时，该函数返回 &lt;code&gt;NULL&lt;/code&gt; ,并且 &lt;code&gt;count&lt;/code&gt; 未修改。</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值，并以 &lt;code&gt;size&lt;/code&gt; 指示其长度。如果找不到该对象或它不是二进制对象，则返回 &lt;code&gt;NULL&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;NULL&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象，或者它不是浮点对象，则返回 &lt;code&gt;-1.0&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;-1.0&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象或它不是字符串，则返回 &lt;code&gt;NULL&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;NULL&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象或它不是整数对象，则返回 &lt;code&gt;-1&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;-1&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">成功后，函数将返回 &lt;code&gt;ERL_MSG&lt;/code&gt; 并初始化 &lt;code&gt;msg&lt;/code&gt; 结构。 &lt;code&gt;erlang_msg&lt;/code&gt; 的定义如下：</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">成功后，将消息放置在指定的缓冲区中，该函数返回实际读取的字节数。如果失败，该函数返回 &lt;code&gt;ERL_ERROR&lt;/code&gt; 并设置 &lt;code&gt;erl_errno&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功后，将消息放置在指定的缓冲区中，该函数返回实际读取的字节数。失败时，该函数将返回负值，并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为以下值之一：</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功后，将调整注册表大小，重新整理所有内容，并返回 &lt;code&gt;0&lt;/code&gt; 。失败时，注册表保持不变，并返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">在支持OS信号的系统上，也可以通过发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 信号来停止运行时系统并生成故障转储。</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;内部表&lt;/strong&gt;标签上，您可以从左侧菜单中选择&lt;strong&gt;哈希表&lt;/strong&gt;，&lt;strong&gt;索引表&lt;/strong&gt;或&lt;strong&gt;内部ETS表&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;Code&lt;/code&gt; 页面上，将显示Erlang源代码。可以向前和向后搜索模块中的文本。在&amp;ldquo; &lt;code&gt;Find&lt;/code&gt; 字段中输入正则表达式，然后按Enter。也可以转到模块中的特定行。&amp;ldquo; &lt;code&gt;Back&lt;/code&gt; 按钮可用于返回到上一个位置。</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">在 &lt;code&gt;erl&lt;/code&gt; 命令行上，您可以指定创建套接字时SSL / TLS分发添加的选项。</target>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">在C端，有必要编写函数，用于从/到Erlang接收和发送带有2个字节长的指示器的数据。默认情况下，C程序将从标准输入（文件描述符0）读取并写入标准输出（文件描述符1）。以下是 &lt;code&gt;read_cmd/1&lt;/code&gt; 和 &lt;code&gt;write_cmd/2&lt;/code&gt; 这样的函数的示例：</target>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">在客户端，函数 &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; 产生一个临时客户端进程，该进程与TFTP守护程序建立联系并执行文件传输。</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">在客户端，回调交互是相同的，但是它的开始和结束有所不同。它从对 &lt;code&gt;prepare/5&lt;/code&gt; 的调用开始，并使用与 &lt;code&gt;open/5&lt;/code&gt; 相同的参数。 &lt;code&gt;prepare/5&lt;/code&gt; 有望验证用户建议的TFTP选项并返回其接受的子集。然后将选项发送到服务器，服务器执行相同的TFTP选项协商过程。服务器接受的选项将转发给客户端的功能 &lt;code&gt;open/5&lt;/code&gt; 。在客户端，函数 &lt;code&gt;open/5&lt;/code&gt; 必须按原样接受所有选项或拒绝传输。然后，回调交互遵循与服务器端相同的模式。当遇到最后一个块时 &lt;code&gt;read/1&lt;/code&gt; 或 &lt;code&gt;write/2&lt;/code&gt; ，将返回的状态转发给用户，并从 &lt;code&gt;read_file&lt;/code&gt; / 3或 &lt;code&gt;write_file/3&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">在客户端，在 &lt;code&gt;open/5&lt;/code&gt; 调用之前要调用 &lt;code&gt;prepare/5&lt;/code&gt; ，所有选项都必须接受或拒绝。</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">在目的端,传输服务等待消息。每条信息通过megaco:receive_message/4回调函数转发给Megaco应用程序。传输服务可以提供或不提供阻断和解除阻断接收传入信息的方法。</target>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">在库页面上,可以控制工具将使用哪些资源。该页面被组织成一棵树,可以通过点击可扩展/可折叠行开头的小符号进行扩展和折叠。</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">在节点 &lt;code&gt;a@gin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">在节点 &lt;code&gt;b@skeppet&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">在节点 &lt;code&gt;stack&lt;/code&gt; 有一个Erlang节点 &lt;code&gt;ant@stack&lt;/code&gt; ，在外壳中，键入以下内容：</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">在应用程序启动的节点上,有一个事务协调者进程。如果事务是分布式的,那么在需要进行提交工作的所有其他节点上,也有一个事务参与者进程。</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">另一方面值得一提的是,至少所有依赖于非验证算法的密码套件在FIPS模式下会被自动禁用。</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">另一方面:</target>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">在接收端,传输模块接收消息并将其转发给协议引擎,协议引擎对消息进行解码,并为每个事务调用用户回调函数。当用户处理完其动作请求后,只需返回一个动作回复列表(或消息错误),协议引擎使用编码模块和传输模块组成消息并转发给发起用户。</target>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">在服务器端，回调交互以具有已注册初始回调状态的 &lt;code&gt;open/5&lt;/code&gt; 调用开始。 &lt;code&gt;open/5&lt;/code&gt; 有望打开（虚拟）文件。然后，每个 &lt;code&gt;read/1&lt;/code&gt; 块重复调用一次read / 1或 &lt;code&gt;write/2&lt;/code&gt; 函数。在每次函数调用时，都将从上一次调用返回的状态获得。遇到最后一个块时，应该使用函数 &lt;code&gt;read/1&lt;/code&gt; 或 &lt;code&gt;write/2&lt;/code&gt; 关闭（虚拟）文件并返回其最后状态。功能 &lt;code&gt;abort/3&lt;/code&gt; 仅在错误情况下使用。在服务器端未使用功能 &lt;code&gt;prepare/5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">在服务器端，没有之前的 &lt;code&gt;prepare/5&lt;/code&gt; 调用，不能添加任何新选项，但是， &lt;code&gt;SuggestedOptions&lt;/code&gt; 中存在的那些选项可以省略，也可以用 &lt;code&gt;AcceptedOptions&lt;/code&gt; 中的新值替换。</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">在系统设置页面上，可以控制一些全局设置，这些设置用作所有应用程序的默认设置。设置 &lt;code&gt;Application inclusion policy&lt;/code&gt; 以 &lt;code&gt;include&lt;/code&gt; 所有未明确排除的应用程序。见 &lt;code&gt;incl_cond&lt;/code&gt; （应用包含）和 &lt;code&gt;mod_cond&lt;/code&gt; （模块包含）在该模块的参考手册 &lt;code&gt;reltool&lt;/code&gt; 获取更多信息。</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">在第三行(或第二行,取决于Emacs指令的存在),可以向仿真器指定参数,例如。</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">超时后，当前测试作业完成后，测试运行将中止。如果提供了 &lt;code&gt;skip_rest&lt;/code&gt; ，则将跳过当前测试作业中的其余测试用例（稍后描述）。</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">在unix上,你可以在emacs中查看手册页面。为了找到手册页面,变量 &quot;erlang-root-dir &quot;应该与包含Erlang安装的目录名绑定。这个名字不应该包括最后的斜杠。实际上,你应该在你的 ~/.emacs 文件中添加一行如下的内容。</target>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">一旦返回了 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; ，就可以确保以后不会由于监视程序而将 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 消息放置在呼叫者消息队列中。但是，可以在呼叫之前将 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 消息放置在呼叫者消息队列中。因此，通常建议在停止监视之后从消息队列中删除此类 &lt;code&gt;'DOWN'&lt;/code&gt; 消息。 &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; 可以使用demonitor（MonitorRef，[flush]）代替 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">一旦 &lt;code&gt;unlink(Id)&lt;/code&gt; 返回，就可以确保调用者与 &lt;code&gt;Id&lt;/code&gt; 引用的实体之间的链接将来不会对调用者产生任何影响（除非再次设置链接）。如果呼叫者正在捕获出口，则可以在呼叫之前将链接中的 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 消息放置在呼叫者的消息队列中。</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">创建端口数据锁后，必须在对 &lt;code&gt;port&lt;/code&gt; 的驱动程序队列进行所有操作期间将其锁定。</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">NIF库一旦加载,就会持久存在。它不会被卸载,直到它所属的模块代码版本被清除。</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">读取后,这个文件会产生与下面文本文件相同的配置变量。</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">一旦将CTH安装到某个测试运行中，它将一直保留在那里，直到其作用范围到期为止。CTH的范围取决于安装时间，请参阅下表。功能 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 被称为在范围和函数的开始 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; 被称为范围结束时。</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">解释了适当的模块后，可以在源代码中的相关位置设置断点。断点是基于行指定的。当进程到达断点时，它将停止并等待用户的命令（&lt;strong&gt;Step&lt;/strong&gt;，&lt;strong&gt;Skip&lt;/strong&gt;，&lt;strong&gt;Continue&lt;/strong&gt; ...）。</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">一旦数据被收集到服务器上,它就可以以许多不同的方式进行过滤、分类和打印。</target>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">一旦创建了端口数据锁，就必须在锁定端口数据锁的同时进行对与端口数据锁关联的数据的每次访问。端口数据锁分别由 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; 锁定和解锁。</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">构建系统后，您可能需要更改它。在一个不错的目录中进行测试发布可能会很有用，但您也可以从源代码树中运行Erlang。目标 &lt;code&gt;local_setup&lt;/code&gt; 使得程序 &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; 可用，并且还使用源树中的所有OTP库。</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">一旦启用了锁计数功能的VM，就可以使用模块 &lt;code&gt;lcnt&lt;/code&gt; 。该模块旨在从当前运行的节点外壳中使用。要访问远程节点，请使用 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 和 &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">选择要分析的模块或目录后，单击&amp;ldquo; &lt;strong&gt;运行&amp;rdquo;&lt;/strong&gt;按钮以开始分析。如果出于某种原因要在运行分析时停止分析，请单击&amp;ldquo; &lt;strong&gt;停止&amp;rdquo;&lt;/strong&gt;按钮。</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">一个MIB可以和很多应用进行通信。</target>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">可以通过调用 &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; 来获得 &lt;code&gt;native&lt;/code&gt; 时间单位的近似值。结果等于每秒的完整 &lt;code&gt;native&lt;/code&gt; 时间单位数。如果每秒的 &lt;code&gt;native&lt;/code&gt; 时间单位总数不等于整数，则结果将向下舍入。</target>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">每个分配器一个条目。请参阅ERTS中&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;部分中的 &lt;code&gt;Allocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">这方面的一个例子是对传入的数据进行预处理,例如解密分块或收集字符直至换行。</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">一种例外是二进制文件的模式匹配。编译器不会重新排列与二进制文件匹配的子句。将匹配空子句的子句放在&lt;strong&gt;最后&lt;/strong&gt;通常比将其放在&lt;strong&gt;最前面&lt;/strong&gt;要快一些。</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">一个用于有限状态机（类似于 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; ），它要求状态是一个原子，并使用该状态作为当前回调函数的名称</target>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 忽略的一组直接传递给仿真器（ &lt;code&gt;-erl_args&lt;/code&gt; 的仿真器）。</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 将要处理的一组（ &lt;code&gt;-erl_args&lt;/code&gt; 之前的一组）。</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">从文件中返回一行,包括尾部的LF,但用一个LF代替CRLF序列(见上文)。</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">一个日志文件 &lt;code&gt;run_erl.log&lt;/code&gt; ，它记录来自 &lt;code&gt;run_erl&lt;/code&gt; 程序本身的进度和警告。</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">也可以将任意数据转换为XML。所以,比如说它很容易让人读懂。在这种情况下,你首先从你的数据中创建xmerl数据结构,然后将其转换为XML。</target>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">一个网络RPC(两个消息)来获取写入锁。</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_pattern&lt;/code&gt; 的一个好处是，它允许您显式控制跟踪的详细程度，从而提供了一种非常简单的方法来最大程度地减少生成的跟踪数据。如您所见， &lt;code&gt;et_viewer&lt;/code&gt; 有一个名为 &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; 的滑块，它使您可以控制 &lt;code&gt;Viewer&lt;/code&gt; 中显示的跟踪 &lt;code&gt;Events&lt;/code&gt; 的细节级别。另一方面，如果在 &lt;code&gt;trace_pattern&lt;/code&gt; 中设置较低的详细信息级别，则将永远不会生成许多跟踪数据，因此不会通过套接字将其发送到跟踪客户端，也不会存储在 &lt;code&gt;Collector&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">其中一个 &lt;code&gt;&quot;Error&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; ，或者在一个目前尚不清楚Windows NT版本的情况下 &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_event&lt;/code&gt; 状态。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为 &lt;code&gt;normal&lt;/code&gt; 原子。</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_server&lt;/code&gt; 状态。 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_statem&lt;/code&gt; 状态。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为 &lt;code&gt;normal&lt;/code&gt; 原子。</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">UTF编码之一，指定为参数 &lt;code&gt;InEncoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">内核进程之一无法启动。这可能是由于错误的参数（例如 &lt;code&gt;-config&lt;/code&gt; 参数中的错误）或错误的配置文件。检查所有文件都在正确的位置，并且配置文件（如果有）是否损坏。通常，消息还会被写入控制终端和/或错误日志，以说明错误所在。</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">使用Erlang代替其他功能语言的主要原因之一是Erlang能够处理并发和分布式编程。并发是指可以同时处理多个执行线程的程序。例如，现代操作系统允许您使用同时运行的文字处理器，电子表格，邮件客户端和打印作业。系统中的每个处理器（CPU）可能一次只能处理一个线程（或作业），但是它在作业之间进行交换的速度给人一种使它们同时运行的幻觉。在Erlang程序中创建并行执行线程很容易，并允许这些线程相互通信。在Erlang中，每个执行线程都称为一个&lt;strong&gt;process&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">您可以指定的一件事是应该在哪里安装Erlang / OTP。默认情况下，Erlang / OTP将安装在 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 中。要保持相同的结构但将其安装在不同的位置，请使用 &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; 这样的 &lt;code&gt;--prefix&lt;/code&gt; 参数： &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">元组之一是 &lt;code&gt;{timeout, GcTime}&lt;/code&gt; ，其中 &lt;code&gt;GcTime&lt;/code&gt; 是垃圾收集的时间，以毫秒为单位。其他元组被标记为 &lt;code&gt;heap_size&lt;/code&gt; ， &lt;code&gt;heap_block_size&lt;/code&gt; ， &lt;code&gt;stack_size&lt;/code&gt; ， &lt;code&gt;mbuf_size&lt;/code&gt; ， &lt;code&gt;old_heap_size&lt;/code&gt; 和 &lt;code&gt;old_heap_block_size&lt;/code&gt; 。在跟踪消息 &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; 的描述中解释了这些元组（请参阅 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; ）。可以添加新的元组，并且&amp;ldquo; &lt;code&gt;Info&lt;/code&gt; 列表中的元组的顺序可以随时更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">这些MIB中总有一个被加载。如果只使用SNMPv1,则加载STANDARD-MIB,否则加载SNMPv2-MIB。</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">有一种选择。</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">一个或多个记录可能已被删除。表 &lt;code&gt;Tab&lt;/code&gt; 具有键&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 所有记录均已删除。</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">可以在配置文件中描述一个或多个选择性解码功能。使用以下符号。</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">这个函数的一个可能的用途是计算一个文档的固定布局,然后可以将其作为一个更大的文档的一部分。例如:</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">一个进程可以多次阻塞多调度和普通多调度。如果一个进程已经阻塞了多次,它必须在它阻塞的次数完全相同的情况下才会解除对多调度的阻塞。如果一个已阻塞多调度或正常多调度的进程退出,它就会自动解除对多调度和正常多调度的阻塞。</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">使用此功能的一个原因是，当您拥有一个状态项时，该状态项在更改后应取消 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; ，或者与延迟事件结合使用而影响事件处理。我们将采用后者，并通过引入可配置的锁定按钮（这是所讨论的状态项）使前一个示例复杂化，该按钮在 &lt;code&gt;open&lt;/code&gt; 状态下会立即锁定门，并提供API函数 &lt;code&gt;set_lock_button/1&lt;/code&gt; 来设置锁定按钮。</target>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">一个微小的区别是，如果 &lt;code&gt;L&lt;/code&gt; 是不正确的列表，则 &lt;code&gt;length(L)&lt;/code&gt; 失败，而第二个代码片段中的模式接受不正确的列表。</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">解决此问题的一种方法是使snmp应用程序成为分布式Erlang应用程序，这意味着可以将代理配置为在多个节点之一上运行。如果运行该节点的节点出现故障，则另一个节点将重新启动代理。这称为&lt;strong&gt;故障转移&lt;/strong&gt;。当节点再次启动时，它可以&lt;strong&gt;接管&lt;/strong&gt;应用程序。该问题的解决方案增加了另一个问题。通常，新节点的IP地址不同于第一个IP地址，这可能会导致SNMP管理器与代理之间的通信出现问题。</target>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">这个函数的一个用途是返回紧凑的替代状态表示,以避免在日志文件中打印大的状态项。另一个用途是隐藏敏感数据,避免被写入错误日志。</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">这个函数的一个用途是返回紧凑的替代状态表示,以避免大的状态项被打印在日志文件中。</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">存在一个有效的事件 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">一个不限制状态数据类型,对所有状态使用一个回调函数。</target>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">在线支持 &lt;code&gt;release_handler&lt;/code&gt; 用于解包和安装发行包</target>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">在运行时只能更改所有 &lt;code&gt;erts_alloc&lt;/code&gt; 标志的子集。该子集当前仅是标志 &lt;code&gt;sbct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">上面只展示了函数子句的一个子集。输入参数的全部有效组合如下。</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">只返回除默认值以外的实际参数,例如不返回为配置参数指定其他来源的指令,也不返回清除参数的指令。</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">仅在 &lt;code&gt;if&lt;/code&gt; 或另一个 &lt;code&gt;elif&lt;/code&gt; 指令之后才允许。如果前面的 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;elif&lt;/code&gt; 指令的求值不为true，而 &lt;code&gt;Condition&lt;/code&gt; 的求值为true，则代之以计算 &lt;code&gt;elif&lt;/code&gt; 之后的行。</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">仅在 &lt;code&gt;ifdef&lt;/code&gt; 或 &lt;code&gt;ifndef&lt;/code&gt; 指令之后才允许。如果该条件为假，则将评估 &lt;code&gt;else&lt;/code&gt; 后面的行。</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">只允许用于面向连接的插座。</target>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">默认情况下，仅标记由NIF和驱动程序生成的二进制文件和分配，但是可以使用 &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; 仿真器选项在每个分配器的基础上进行配置。</target>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">只使用明确的连接设置。</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">只有正好是这些扩展名的文件才会被压缩。</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">仅当执行Shell脚本或 &lt;code&gt;.bat&lt;/code&gt; 文件时，才隐式调用相应的命令解释器，但仍然没有命令参数扩展或隐式 &lt;code&gt;PATH&lt;/code&gt; 搜索。</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">仅当字符串的代码点&amp;lt;256以下时，才可以使用 &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; 将其直接转换为二进制，或者可以直接将其发送到端口。如果字符串包含大于255的Unicode字符，则必须确定编码，然后使用 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 将字符串转换为首选编码形式的二进制。字符串通常不是字节列表，就像在Erlang / OTP R13之前一样，它们是字符列表。字符通常不是字节，它们是Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">只有当服务器处于确认提交阶段时,才会将配置恢复到进入确认提交阶段前的状态。否则,不会进行配置回滚。</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">仅当类型为 &lt;code&gt;integer&lt;/code&gt; 时才匹配。默认值为 &lt;code&gt;unsigned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">只有使用选项 &lt;code&gt;debug_info&lt;/code&gt; 设置编译的模块才能解释。不可解释的模块显示在&amp;ldquo;解释模块&amp;rdquo;窗口的括号内。</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">仅在64位半字模拟器上。尽管系统可以拥有更多的内存，但在不足4 GB的低内存区域中分配的内存总量。</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">只能指定一个 &lt;code&gt;MonitorOption&lt;/code&gt; 。它是以下之一：</target>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">这种类型的条目只允许一个。</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 只能加载一个表。由于已提交的事务可能导致多个表中的更新，因此，由于强制负载，这些表可能会变得不一致。</target>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">此处仅提供了一些默认值。有关当前使用的设置和分配器的当前状态的信息，请参见 &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; 和 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">仅当ERTS使用zlib&amp;gt; = 1.2.8编译时才受支持。</target>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">只有DEFLATE(zlib压缩)和STORE(未压缩数据)zip方法被支持。</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">只有打开该文件的Erlang进程才能使用它。</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">只有当前连接的作业才能与shell &quot;对话&quot;。</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">只有第一个捕获的子模式,它总是主体的完整匹配部分。所有明确捕获的子模式都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">在字符类中只识别以下元字符。</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">只有所有者进程才能对表进行读写。</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">除非已使用 &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; 注册了备用输入处理程序进程，否则仅允许注册为 &lt;code&gt;DHandle&lt;/code&gt; 标识的分发通道的分发控制器的进程调用此函数。如果已经注册了备用输入处理程序，则仅允许已注册的输入处理程序进程调用此函数。</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">仅注册为 &lt;code&gt;DHandle&lt;/code&gt; 标识的分发通道的分发控制器的进程才能调用此函数。</target>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">仅搜索指定的部分。返回值相对于 &lt;code&gt;Subject&lt;/code&gt; 的开始还有偏移量。如本手册的&amp;ldquo;数据类型&amp;rdquo;部分所述，允许为负的 &lt;code&gt;Length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">仅识别这些确切的字符序列。诸如[a [：&amp;lt;：] b]之类的序列会为无法识别的POSIX类名引发错误。此支持与Perl不兼容。提供它是为了帮助从其他环境迁移，最好不要在任何新模式中使用。请注意，\ b在单词的开头和结尾匹配（请参见上面的&amp;ldquo;简单断言&amp;rdquo;），并且在Perl样式的模式中，前一个或后一个字符通常会显示所需的字符，而无需使用所使用的断言为了准确给出POSIX行为。</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">只有总数</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">仅跟踪来自特定进程 &lt;code&gt;Pid&lt;/code&gt; 的消息：</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">只跟踪其他节点的消息。</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">仅跟踪与 &lt;code&gt;{reply, _}&lt;/code&gt; 相匹配的消息：</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">只跟踪发送到其他节点的消息。</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">只跟踪发送到发送者本身的消息。</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">仅将消息跟踪到特定进程 &lt;code&gt;Pid&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">只有两个参数，其中一个必须为 &lt;code&gt;true&lt;/code&gt; ，另一个为 &lt;code&gt;false&lt;/code&gt; 以返回 &lt;code&gt;true&lt;/code&gt; ；否则， &lt;code&gt;'xor'&lt;/code&gt; 返回false。</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">只有在确定自己在做什么的情况下才能使用这些标志。不合适的设置会导致严重的性能下降,甚至在操作过程中随时出现系统崩溃。</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">只在握手阶段使用。</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。它允许生成的（Unix）进程的标准输入和输出（文件描述符0和1）与Erlang通信。</target>
        </trans-unit>
        <trans-unit id="18c2212e127b0c910798dbbf1d59d9d69e12fd4b" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The external program starts using &lt;code&gt;Dir&lt;/code&gt; as its working directory. &lt;code&gt;Dir&lt;/code&gt; must be a string.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。外部程序开始使用 &lt;code&gt;Dir&lt;/code&gt; 作为其工作目录。 &lt;code&gt;Dir&lt;/code&gt; 必须是字符串。</target>
        </trans-unit>
        <trans-unit id="65484a01cf9bd6e1a83ae6b606310e1c69ff32cf" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The environment of the started process is extended using the environment specifications in &lt;code&gt;Env&lt;/code&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。使用 &lt;code&gt;Env&lt;/code&gt; 中的环境规范扩展了启动过程的环境。</target>
        </trans-unit>
        <trans-unit id="bfc9b2e1dea6a04ba983a9e94d3b648b00ca026f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, where &lt;code&gt;Command&lt;/code&gt; refers to an external program, and for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，在此 &lt;code&gt;Command&lt;/code&gt; 指的是外部程序。</target>
        </trans-unit>
        <trans-unit id="ec0538decd2a683ac3d4fc85b7551d506a0ba696" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，并在运行可执行文件时显式指定程序名称参数。在某些操作系统上，这在某些情况下可能是理想的。程序对此的响应方式高度依赖于系统，并且无法保证特定的效果。</target>
        </trans-unit>
        <trans-unit id="94d77dba770e4fddcd3e5b235704abc55a41a06f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，并指定可执行文件的参数。每个参数都指定为单独的字符串，并且（在Unix上）最终以参数向量中的每个元素结尾。在其他平台上，类似的行为被模仿。</target>
        </trans-unit>
        <trans-unit id="0a16a27763d86648c52acb4eb9a028a14f39f822" translate="yes" xml:space="preserve">
          <source>Only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">仅对Unix上的字符设备有效。在所有其他情况下,该字段为零。</target>
        </trans-unit>
        <trans-unit id="ecb3f031c9ac0eb9d790e14595d3fd9dd2d8d7c2" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="58a550d32afdec41a5ce24c62d98873272eb328a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="296b6181394c8bc2ef4aa069b7cdea56b08954fb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="2dfa868a6d8928ac7bb58be05cada3f714825ced" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="403f4b382799774e589923264bc2680b24377bd7" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="0fd3a4cc67ebb2e2dcfc37bc089269155adc35e9" translate="yes" xml:space="preserve">
          <source>Opaque data type containing a compiled regular expression. &lt;code&gt;mp()&lt;/code&gt; is guaranteed to be a tuple() having the atom &lt;code&gt;re_pattern&lt;/code&gt; as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.</source>
          <target state="translated">包含已编译正则表达式的不透明数据类型。保证 &lt;code&gt;mp()&lt;/code&gt; 是具有原子 &lt;code&gt;re_pattern&lt;/code&gt; 作为其第一个元素的tuple（），以允许在防护中进行匹配。元组的大小或其他字段的内容可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="23206d19a217e18d8ba3621938088efa39a69154" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a channel inside a connection.</source>
          <target state="translated">代表连接内通道的不透明数据类型。</target>
        </trans-unit>
        <trans-unit id="10ef7cb1f64bbdc10f27d8dc1ce5e8006717e4e1" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a compiled search pattern. Guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">表示已编译搜索模式的不透明数据类型。保证是 &lt;code&gt;tuple()&lt;/code&gt; ,以使程序可以将其与非预编译的搜索模式区分开。</target>
        </trans-unit>
        <trans-unit id="11a89fac909edd47d58426bf26b171a05bcc5425" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a connection between a client and a server (daemon).</source>
          <target state="translated">不透明的数据类型,代表客户端和服务器(守护进程)之间的连接。</target>
        </trans-unit>
        <trans-unit id="620b0b7f87aa05da3ff0439d717021eb8fe8e602" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a daemon.</source>
          <target state="translated">代表守护进程的不透明数据类型。</target>
        </trans-unit>
        <trans-unit id="3857ec812333e693713ca05fedf452c8c2760e48" translate="yes" xml:space="preserve">
          <source>Opaque reference for a connection to a NETCONF server or a NETCONF session.</source>
          <target state="translated">连接到NETCONF服务器或NETCONF会话的不透明参考。</target>
        </trans-unit>
        <trans-unit id="1ad02c5216bfba2278b495045671c8cc585c4d19" translate="yes" xml:space="preserve">
          <source>Opaque send handle whose contents is internal for the send module. May be any term.</source>
          <target state="translated">不透明的发送句柄,其内容是发送模块的内部内容。可以是任何术语。</target>
        </trans-unit>
        <trans-unit id="107ba6e41ccc6092a0776c13b1c83f0f2e14171a" translate="yes" xml:space="preserve">
          <source>Opaque types that define experimental options that are not to be used in products.</source>
          <target state="translated">不透明类型,定义了不在产品中使用的实验选项。</target>
        </trans-unit>
        <trans-unit id="3550457d3cea02f68e91830d6b92589beceb0ac2" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) is a Microsoft standard for accessing relational databases that has become widely used. The ODBC standard provides a c-level application programming interface (API) for database access. It uses Structured Query Language (SQL) as its database access language.</source>
          <target state="translated">开放式数据库连接(ODBC)是微软公司的一个访问关系型数据库的标准,已经被广泛使用。ODBC标准提供了一个用于数据库访问的c级应用程序接口(API),它使用结构化查询语言(SQL)作为数据库访问语言。它使用结构化查询语言(SQL)作为其数据库访问语言。</target>
        </trans-unit>
        <trans-unit id="8082c8186bf5acfdb929e31ffd3d59546e0c666b" translate="yes" xml:space="preserve">
          <source>Open an SSH connection to a named NETCONF server.</source>
          <target state="translated">打开一个与命名的NETCONF服务器的SSH连接。</target>
        </trans-unit>
        <trans-unit id="ee2771cae64f2d66b96c7d0fdeb3a995d3b00a84" translate="yes" xml:space="preserve">
          <source>Open files and sockets</source>
          <target state="translated">打开文件和插座</target>
        </trans-unit>
        <trans-unit id="c2f3ad251a3411a0d3096b7d62ceb15282d3c92b" translate="yes" xml:space="preserve">
          <source>Open ports</source>
          <target state="translated">开放端口</target>
        </trans-unit>
        <trans-unit id="d5d9049df9a69941f4ebda406f0f9058d7b67428" translate="yes" xml:space="preserve">
          <source>Open punctuation</source>
          <target state="translated">开放式标点符号</target>
        </trans-unit>
        <trans-unit id="0f83435c5ff89a01a4392cfcdc0fce03d20e7bcf" translate="yes" xml:space="preserve">
          <source>OpenSSH public-key format looks as follows:</source>
          <target state="translated">OpenSSH公钥格式如下。</target>
        </trans-unit>
        <trans-unit id="78a8e32789179af6e9a1ec19eccc362f6f09476e" translate="yes" xml:space="preserve">
          <source>OpenSSL -- The opensource toolkit for Secure Socket Layer and Transport Layer Security. Required for building the application &lt;code&gt;crypto&lt;/code&gt;. Further, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; require a working crypto application and will also be skipped if OpenSSL is missing. The &lt;code&gt;public_key&lt;/code&gt; application is available without &lt;code&gt;crypto&lt;/code&gt;, but the functionality will be very limited.</source>
          <target state="translated">OpenSSL-用于安全套接字层和传输层安全性的开源工具包 构建应用程序 &lt;code&gt;crypto&lt;/code&gt; 需要。此外， &lt;code&gt;ssl&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; 需要有效的加密应用程序，如果缺少OpenSSL，也会被跳过。无需 &lt;code&gt;crypto&lt;/code&gt; 即可使用 &lt;code&gt;public_key&lt;/code&gt; 应用程序，但功能将非常有限。</target>
        </trans-unit>
        <trans-unit id="f9ba88f6151c1d4c39311034d5740f6813c1bb3d" translate="yes" xml:space="preserve">
          <source>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</source>
          <target state="translated">OpenSSL可以被构建为提供FIPS 140-2验证的加密服务。经过验证的不是OpenSSL应用程序,而是一个特殊的软件组件,称为OpenSSL FIPS对象模块。然而应用程序并不直接使用这个对象模块,而是通过OpenSSL库的常规API来使用。</target>
        </trans-unit>
        <trans-unit id="ec75c958bae528f688b7acd8013d185972516f61" translate="yes" xml:space="preserve">
          <source>OpenSSL exposes an Engine API, which makes it possible to plug in alternative implementations for some or all of the cryptographic operations implemented by OpenSSL. When configured appropriately, OpenSSL calls the engine's implementation of these operations instead of its own.</source>
          <target state="translated">OpenSSL公开了一个引擎API,这使得它可以为OpenSSL实现的部分或全部加密操作插入替代实现。当配置得当时,OpenSSL会调用引擎对这些操作的实现,而不是它自己的实现。</target>
        </trans-unit>
        <trans-unit id="23dcb6e17a0724721b52791ead27b1179856c026" translate="yes" xml:space="preserve">
          <source>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</source>
          <target state="translated">OpenSSL在FIPS模式下可以处理这些角落的情况,但是Erlang的加密和ssl应用并没有为这些情况做好准备,因此你只能在FIPS模式下使用TLS 1.2。</target>
        </trans-unit>
        <trans-unit id="3a24b8124364457504f3d77d3e37c9aa2f092c8b" translate="yes" xml:space="preserve">
          <source>OpenSSL. This is if you want the SSL and crypto applications to compile (and run). There are prebuilt binaries, which you can just download and install, available here:</source>
          <target state="translated">OpenSSL。如果你想让SSL和加密应用程序编译(和运行),就需要这样做。这里有预制的二进制文件,你可以直接下载并安装。</target>
        </trans-unit>
        <trans-unit id="fc37c058118702102358b15e5a9279ede7fb88f0" translate="yes" xml:space="preserve">
          <source>OpenSource users can ask questions and share experiences on the &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt; Erlang questions mailing list&lt;/a&gt;.</source>
          <target state="translated">OpenSource用户可以在&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;Erlang问题邮件列表中&lt;/a&gt;提出问题并分享经验。</target>
        </trans-unit>
        <trans-unit id="9f59aad599af06a50017bc066f13ce93de0675e4" translate="yes" xml:space="preserve">
          <source>Opening a connection to the SUT</source>
          <target state="translated">打开与SUT的连接</target>
        </trans-unit>
        <trans-unit id="16d19c8e7f51506cd01c5e4f542d05b716cdf852" translate="yes" xml:space="preserve">
          <source>Opening files with option &lt;code&gt;encoding&lt;/code&gt; is convenient when writing or reading text files in a known encoding.</source>
          <target state="translated">使用已知编码写入或读取文本文件时，使用选项 &lt;code&gt;encoding&lt;/code&gt; 打开文件很方便。</target>
        </trans-unit>
        <trans-unit id="67011158e86d9fe5da95333d965bcbbe99127074" translate="yes" xml:space="preserve">
          <source>Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</source>
          <target state="translated">开头的小括号从左到右(从1开始)数,得到捕捉子模式的编号。例如,如果将字符串 &quot;红王 &quot;与下面的模式进行匹配,则捕获的子串分别为 &quot;红王&quot;、&quot;红&quot;、&quot;王&quot;,并分别编号为1、2、3。</target>
        </trans-unit>
        <trans-unit id="75588bb57f0a2ad5ebe6ca42cc40d8c3b6d3dc26" translate="yes" xml:space="preserve">
          <source>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</source>
          <target state="translated">开头的方括号(只有当它可以被解释为引入一个Posix类名时,或者是为了一个特殊的兼容性功能,见下两节)</target>
        </trans-unit>
        <trans-unit id="0a4914a57f284d13929c087c4e60d213c9577e76" translate="yes" xml:space="preserve">
          <source>Opens (creates) a registry, which initially is empty. To close the registry later, use &lt;code&gt;ei_reg_close()&lt;/code&gt;.</source>
          <target state="translated">打开（创建）注册表，该注册表最初为空。要稍后关闭注册表，请使用 &lt;code&gt;ei_reg_close()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b46d26782974b469a2ae782f58aa207429f253c" translate="yes" xml:space="preserve">
          <source>Opens a &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;, displaying the contents of the selected module.</source>
          <target state="translated">打开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; ，显示所选模块的内容。</target>
        </trans-unit>
        <trans-unit id="22a4c7bdc761516d54977e6e3c2f08e31666a769" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">打开NETCONF会话并交换 &lt;code&gt;hello&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="fc2106dbbf5f859efe242b4f2863fc622702b3ed" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session as a channel on the given SSH connection, and exchanges hello messages with the server.</source>
          <target state="translated">在给定的SSH连接上以通道的形式打开一个NETCONF会话,并与服务器交换hello消息。</target>
        </trans-unit>
        <trans-unit id="01cccde2b149248e69a585d60c61c3d13087127c" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">打开NETCONF会话，但不发送 &lt;code&gt;hello&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0e8afe49dad7508484506ff701e53d0d8fc26e0" translate="yes" xml:space="preserve">
          <source>Opens a Telnet connection to the specified target host.</source>
          <target state="translated">打开与指定目标主机的Telnet连接。</target>
        </trans-unit>
        <trans-unit id="863e973e6a31c9261a3ac1a5ee27b4c5d6dfcd10" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session.</source>
          <target state="translated">打开一个SSH会话的通道。</target>
        </trans-unit>
        <trans-unit id="f4b954e8567f661fe6c4ddf769bdcc65e25fa9df" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session. The channel id returned from this function is the id used as input to the other functions in this module.</source>
          <target state="translated">为一个SSH会话打开一个通道.该函数返回的通道ID是本模块中其他函数的输入ID.本函数返回的通道ID是本模块中其他函数的输入ID。</target>
        </trans-unit>
        <trans-unit id="84e8a4380a15d0e1019641a8397c044a4caf2ec5" translate="yes" xml:space="preserve">
          <source>Opens a connection to the database. The connection is associated with the process that created it and can only be accessed through it. This function may spawn new processes to handle the connection. These processes will terminate if the process that created the connection dies or if you call disconnect/1.</source>
          <target state="translated">打开与数据库的连接。该连接与创建该连接的进程相关联,只能通过该进程访问。该函数可能会产生新的进程来处理该连接,如果创建连接的进程死亡或调用disconnect/1,这些进程将终止。如果创建连接的进程死亡或调用disconnect/1,这些进程将终止。</target>
        </trans-unit>
        <trans-unit id="8a2ca3ab2e6a54c904b5fe348aa46db48f2f0c68" translate="yes" xml:space="preserve">
          <source>Opens a detailed information window on the selected process, including the following:</source>
          <target state="translated">打开所选流程的详细信息窗口,包括以下内容。</target>
        </trans-unit>
        <trans-unit id="f750e93585a93a3a78ed2d040624e4bedee5783b" translate="yes" xml:space="preserve">
          <source>Opens a file for preprocessing.</source>
          <target state="translated">打开文件进行预处理。</target>
        </trans-unit>
        <trans-unit id="0dae8080316d196c81e5e5bd698fc2b46c3bd578" translate="yes" xml:space="preserve">
          <source>Opens a file for read or write access.</source>
          <target state="translated">打开文件进行读写访问。</target>
        </trans-unit>
        <trans-unit id="05853d805e8d0a64be6bd32197c1efe7fc8affff" translate="yes" xml:space="preserve">
          <source>Opens a file on the server and returns a handle, which can be used for reading or writing.</source>
          <target state="translated">在服务器上打开一个文件,并返回一个句柄,可用于读写。</target>
        </trans-unit>
        <trans-unit id="c8cba523b51510605036808e563faed86bad7a34" translate="yes" xml:space="preserve">
          <source>Opens a handle to a directory on the server. The handle can be used for reading directory contents.</source>
          <target state="translated">打开服务器上一个目录的句柄。该句柄可用于读取目录内容。</target>
        </trans-unit>
        <trans-unit id="582c61865473eb0cf103ce22b094eb7d48793963" translate="yes" xml:space="preserve">
          <source>Opens a handle to a tar file on the server, associated with &lt;code&gt;ChannelPid&lt;/code&gt;. The handle can be used for remote tar creation and extraction, as defined by the &lt;code&gt;erl_tar:init/3&lt;/code&gt; function.</source>
          <target state="translated">打开服务器上与 &lt;code&gt;ChannelPid&lt;/code&gt; 关联的tar文件的句柄。该句柄可用于 &lt;code&gt;erl_tar:init/3&lt;/code&gt; 函数定义的远程tar创建和提取。</target>
        </trans-unit>
        <trans-unit id="38a016da939f8a64a311d0439e65d9ca62d7e550" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">打开一个命名的NETCONF会话并交换 &lt;code&gt;hello&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="6c86f8db1e9c8781949e8303c056c061130288be" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">打开一个命名的NETCONF会话，但不发送 &lt;code&gt;hello&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae78d453fdc1ed67800d13633ccdbf6892076735" translate="yes" xml:space="preserve">
          <source>Opens a table. An empty Dets table is created if no file exists.</source>
          <target state="translated">打开一个表。如果没有文件存在,则创建一个空的Dets表。</target>
        </trans-unit>
        <trans-unit id="5b10027bd172d07f8eae36a418eb12d0559fcafd" translate="yes" xml:space="preserve">
          <source>Opens a trace port on each node to be traced. By default, trace messages are written to binary files on remote nodes (the binary trace log).</source>
          <target state="translated">在每个要跟踪的节点上打开一个跟踪端口。默认情况下,跟踪信息会被写入远程节点的二进制文件(二进制跟踪日志)。</target>
        </trans-unit>
        <trans-unit id="6a5ff76be69758b5b422a1d897ebb9c5f931b8de" translate="yes" xml:space="preserve">
          <source>Opens a zip archive, and reads and saves its directory. This means that later reading files from the archive is faster than unzipping files one at a time with &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打开一个zip存档，并读取并保存其目录。这意味着以后从存档中读取文件比使用 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt; 一次解压缩文件要快。</target>
        </trans-unit>
        <trans-unit id="cfb9d8cc25812a80fcde10dfb14baff5e93d3d89" translate="yes" xml:space="preserve">
          <source>Opens a zlib stream.</source>
          <target state="translated">打开一个zlib流。</target>
        </trans-unit>
        <trans-unit id="cf71532877f9185120e6ff70251b83955022ad68" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and fetches a file from the remote host.</source>
          <target state="translated">打开FTP连接,从远程主机获取文件。</target>
        </trans-unit>
        <trans-unit id="0edbf2d8cf836a0928dd1ee04359d15b3360a7a1" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and sends a file to the remote host.</source>
          <target state="translated">打开FTP连接并向远程主机发送文件。</target>
        </trans-unit>
        <trans-unit id="34a1d5c3e19d27c4c884a326dd68b7ad28a75ae7" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection to the specified node.</source>
          <target state="translated">打开与指定节点的FTP连接。</target>
        </trans-unit>
        <trans-unit id="375e952b3e4358b9086c82fb4e035f4c2d220eed" translate="yes" xml:space="preserve">
          <source>Opens an SSH connection to a NETCONF server.</source>
          <target state="translated">打开与NETCONF服务器的SSH连接。</target>
        </trans-unit>
        <trans-unit id="a16d2119745f4d905dfff9790116b88f38df60dd" translate="yes" xml:space="preserve">
          <source>Opens an SSH or SFTP connection using the information associated with &lt;code&gt;KeyOrName&lt;/code&gt;.</source>
          <target state="translated">使用与 &lt;code&gt;KeyOrName&lt;/code&gt; 关联的信息打开SSH或SFTP连接。</target>
        </trans-unit>
        <trans-unit id="39bf3429a9eb17df337807274369a2a1485631e4" translate="yes" xml:space="preserve">
          <source>Opens an TLS/DTLS connection to &lt;code&gt;Host&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">打开与 &lt;code&gt;Host&lt;/code&gt; ， &lt;code&gt;Port&lt;/code&gt; 的TLS / DTLS连接。</target>
        </trans-unit>
        <trans-unit id="62effb5551d902e97d0967400f135108af21c88b" translate="yes" xml:space="preserve">
          <source>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor &lt;code&gt;dtor&lt;/code&gt; is called both for existing instances and new instances not yet created by the calling NIF library.</source>
          <target state="translated">打开现有资源类型并接管所有实例的所有权。对于调用NIF库尚未创建的现有实例和新实例，都会调用提供的析构函数 &lt;code&gt;dtor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f30c59ec922ffa7f6658907dc759edc40afdb39" translate="yes" xml:space="preserve">
          <source>Opens an existing table. If the table is not properly closed, it is repaired. The returned reference is to be used as the table name. This function is most useful for debugging purposes.</source>
          <target state="translated">打开现有表格。如果表没有正确关闭,则会被修复。返回的引用将被用作表名。这个函数对于调试来说是最有用的。</target>
        </trans-unit>
        <trans-unit id="6191fa62fa9a2d5758147014b1cebb180f7936ed" translate="yes" xml:space="preserve">
          <source>Opens an interactive Windows console window for the Erlang shell of the service. Automatically disables the &lt;code&gt;StopAction&lt;/code&gt;. A service started with an interactive console window does not survive logouts. &lt;code&gt;OnFail&lt;/code&gt; actions do not work with debug consoles either.</source>
          <target state="translated">打开服务的Erlang Shell的交互式Windows控制台窗口。自动禁用 &lt;code&gt;StopAction&lt;/code&gt; 。以交互式控制台窗口启动的服务无法退出注销。 &lt;code&gt;OnFail&lt;/code&gt; 操作也不适用于调试控制台。</target>
        </trans-unit>
        <trans-unit id="6b42e9b24605e4d337c32c2f54025481d238a9f0" translate="yes" xml:space="preserve">
          <source>Opens file &lt;code&gt;File&lt;/code&gt; in the mode determined by &lt;code&gt;Modes&lt;/code&gt;, which can contain one or more of the following options:</source>
          <target state="translated">以 &lt;code&gt;Modes&lt;/code&gt; 确定的模式打开文件 &lt;code&gt;File&lt;/code&gt; ，该模式可以包含以下一个或多个选项：</target>
        </trans-unit>
        <trans-unit id="f1f250fc2e30dcf740ba52a6778d1bf170664542" translate="yes" xml:space="preserve">
          <source>Opens log file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; if logging to file is already enabled, or an error tuple if another error occurred (for example, if &lt;code&gt;Filename&lt;/code&gt; cannot be opened). The file is opened with encoding UTF-8.</source>
          <target state="translated">打开日志文件 &lt;code&gt;Filename&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; ;如果已启用对文件的日志记录，则返回 &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; 如果发生另一个错误，则返回一个错误元组（例如，如果无法打开 &lt;code&gt;Filename&lt;/code&gt; ）。该文件以UTF-8编码打开。</target>
        </trans-unit>
        <trans-unit id="515b021c218ccf64dc87cfd2e6aafb2c71875e7c" translate="yes" xml:space="preserve">
          <source>Opens the &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt;, where new modules to be interpreted can be specified.</source>
          <target state="translated">打开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; ，可以在其中指定要解释的新模块。</target>
        </trans-unit>
        <trans-unit id="9b4d52c05a1dfa015184d5b6d02092d14d75b8e3" translate="yes" xml:space="preserve">
          <source>Opens the registry for reading or writing. The current key is the root (&lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt;). Flag &lt;code&gt;read&lt;/code&gt; in the mode list can be omitted.</source>
          <target state="translated">打开注册表进行读取或写入。当前密钥是根（ &lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt; ）。模式列表中 &lt;code&gt;read&lt;/code&gt; 的标志可以省略。</target>
        </trans-unit>
        <trans-unit id="3844a6955eb1488c222cb350aad910d634debf0b" translate="yes" xml:space="preserve">
          <source>Operating system interface</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="6ba10933377bd765bd39421a74f86a9f5033cd62" translate="yes" xml:space="preserve">
          <source>Operating system-specific functions.</source>
          <target state="translated">操作系统特有的功能。</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="3c9639c2c52d47e5befdf848b84975f48bd5f879" translate="yes" xml:space="preserve">
          <source>Operation &lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; can be used to force the release of a lock owned by another NETCONF session. How this is achieved by the server side is implementation-specific.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; 操作来强制释放另一个NETCONF会话所拥有的锁。服务器端如何实现这是特定于实现的。</target>
        </trans-unit>
        <trans-unit id="2fd85be02fe70099570593767a6ed02c554cee82" translate="yes" xml:space="preserve">
          <source>Operations on finite sets and relations represented as sets</source>
          <target state="translated">对有限集和表示为集的关系的运算。</target>
        </trans-unit>
        <trans-unit id="d721e6bae341c96a244ef5325ee7783da8aa05da" translate="yes" xml:space="preserve">
          <source>Operator precedence in falling priority:</source>
          <target state="translated">运营商优先于下降的优先级。</target>
        </trans-unit>
        <trans-unit id="9ac3210fbaf7aa51089439b718a4799d5b27c2af" translate="yes" xml:space="preserve">
          <source>Option (&lt;code&gt;option()&lt;/code&gt;) details:</source>
          <target state="translated">Option（ &lt;code&gt;option()&lt;/code&gt; ）详细信息：</target>
        </trans-unit>
        <trans-unit id="7bc4e2bf65691f392e0c6aef8849b96e3503d3f9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;+d&lt;/code&gt; instructs the emulator to produce only a core dump and no crash dump if an internal error is detected.</source>
          <target state="translated">选项 &lt;code&gt;+d&lt;/code&gt; 指示仿真器仅在检测到内部错误时才生成核心转储，而不会生成崩溃转储。</target>
        </trans-unit>
        <trans-unit id="617924dbd7f61aaccfafefec23e2e5c27276a861" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Encoding&lt;/code&gt; is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt;. Value &lt;code&gt;none&lt;/code&gt; means that no integer lists are considered as strings. &lt;code&gt;encoding_func()&lt;/code&gt; is called with one integer of a list at a time; if it returns &lt;code&gt;true&lt;/code&gt; for every integer, the list is considered a string.</source>
          <target state="translated">选项 &lt;code&gt;Encoding&lt;/code&gt; 用于选择将哪些整数列表视为字符串。默认值是使用功能 &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt; 返回的编码。值 &lt;code&gt;none&lt;/code&gt; 表示没有整数列表被视为字符串。一次用一个列表的一个整数调用 &lt;code&gt;encoding_func()&lt;/code&gt; ；如果每个整数返回 &lt;code&gt;true&lt;/code&gt; ，则该列表被视为字符串。</target>
        </trans-unit>
        <trans-unit id="03b58ec642c1d6975a7cca9e9e0680f47eecc590" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Format&lt;/code&gt; determines the function that is applied to binaries to create the terms to be sorted. Defaults to &lt;code&gt;binary_term&lt;/code&gt;, which is equivalent to &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt;. Value &lt;code&gt;binary&lt;/code&gt; is equivalent to &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt;, which means that the binaries are sorted as they are. This is the fastest format. If &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, &lt;code&gt;io:read/2&lt;/code&gt; is called to read terms. In that case, only the default value of option &lt;code&gt;header&lt;/code&gt; is allowed.</source>
          <target state="translated">选项 &lt;code&gt;Format&lt;/code&gt; 确定应用于二进制文件以创建要排序的术语的函数。默认为 &lt;code&gt;binary_term&lt;/code&gt; ，等效于 &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt; 。值 &lt;code&gt;binary&lt;/code&gt; 等同于 &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt; ，这意味着它们在二进制文件进行排序。这是最快的格式。如果 &lt;code&gt;Format&lt;/code&gt; 为 &lt;code&gt;term&lt;/code&gt; ，则调用 &lt;code&gt;io:read/2&lt;/code&gt; 读取术语。在这种情况下，仅允许选项 &lt;code&gt;header&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="515640376a1e84c5e88279e98275326333b1e883" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Line&lt;/code&gt; is the line to be assigned to each node of &lt;code&gt;AbsTerm&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;Line&lt;/code&gt; 是要分配给 &lt;code&gt;AbsTerm&lt;/code&gt; 的每个节点的行。</target>
        </trans-unit>
        <trans-unit id="ba8fe57baa6137f1e318cb3833968d8989a57f43" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the association to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">选项 &lt;code&gt;accept&lt;/code&gt; 为侦听传输指定远程地址，而对于连接传输无效。如果指定，与指定地址之一不匹配的远程地址将导致关联中止。可以指定多个 &lt;code&gt;accept&lt;/code&gt; 选项。不解析为地址的字符串值 &lt;code&gt;Match&lt;/code&gt; 将被解释为正则表达式。</target>
        </trans-unit>
        <trans-unit id="37bd8dc1b650be1a6635cb23b4502d2226d11576" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the connection to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">选项 &lt;code&gt;accept&lt;/code&gt; 为侦听传输指定远程地址，而对于连接传输无效。如果指定，与指定地址之一不匹配的远程地址将导致连接中止。可以指定多个 &lt;code&gt;accept&lt;/code&gt; 选项。不解析为地址的字符串值 &lt;code&gt;Match&lt;/code&gt; 将被解释为正则表达式。</target>
        </trans-unit>
        <trans-unit id="1f55894395584bb9a3e02eafbec27ef2e407d6b9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;allow_passive_connect&lt;/code&gt; is used internally and is seldom needed in applications where the network topology and the Kernel options in effect are known in advance.</source>
          <target state="translated">选项 &lt;code&gt;allow_passive_connect&lt;/code&gt; 在内部使用，在预先知道有效的网络拓扑和内核选项的应用中很少使用。</target>
        </trans-unit>
        <trans-unit id="1a76c912018b3dd2b854bd85ee5b0c4b94ebb022" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;c&lt;/code&gt; makes &lt;code&gt;Ctrl-C&lt;/code&gt; interrupt the current shell instead of invoking the emulator break handler. Option &lt;code&gt;d&lt;/code&gt; (same as specifying &lt;code&gt;+B&lt;/code&gt; without an extra option) disables the break handler. Option &lt;code&gt;i&lt;/code&gt; makes the emulator ignore any break signal.</source>
          <target state="translated">选项 &lt;code&gt;c&lt;/code&gt; 使 &lt;code&gt;Ctrl-C&lt;/code&gt; 中断当前shell，而不是调用仿真器中断处理程序。选项 &lt;code&gt;d&lt;/code&gt; （与在不带附加选项的情况下指定 &lt;code&gt;+B&lt;/code&gt; 相同）禁用中断处理程序。选项 &lt;code&gt;i&lt;/code&gt; 使仿真器忽略任何中断信号。</target>
        </trans-unit>
        <trans-unit id="326d67c6dd06e800f8ccc7205a53b4bad41af409" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache&lt;/code&gt; has no effect if it is known that the QLC is to be evaluated at most once. This is always true for the top-most QLC and also for the list expression of the first generator in a list of qualifiers. Notice that in the presence of side effects in filters or callback functions, the answers to QLCs can be affected by option &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="translated">如果知道最多要对QLC进行一次评估，则选项 &lt;code&gt;cache&lt;/code&gt; 不起作用。对于最顶层的QLC以及在限定词列表中的第一个生成器的列表表达式，总是如此。请注意，在过滤器或回调函数中存在副作用的情况下，选项 &lt;code&gt;cache&lt;/code&gt; 可能会影响QLC的答案。</target>
        </trans-unit>
        <trans-unit id="c7d8de2a211bf879bd6b340617eed0c81c43b5ad" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache_all&lt;/code&gt; can be set to &lt;code&gt;ets&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt; when evaluating a query. It adds a &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; option to every list expression except QLC tables and lists on all levels of the query. This can be used for testing if caching would improve efficiency at all. If the answer is yes, further testing is needed to pinpoint the generators that are to be cached.</source>
          <target state="translated">评估查询时，可以将选项 &lt;code&gt;cache_all&lt;/code&gt; 设置为 &lt;code&gt;ets&lt;/code&gt; 或 &lt;code&gt;list&lt;/code&gt; 。它为除QLC表和查询所有级别上的列表之外的每个列表表达式添加一个 &lt;code&gt;cache&lt;/code&gt; 或 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 选项。这可以用于测试缓存是否会完全提高效率。如果答案是肯定的，则需要进一步测试以查明要缓存的生成器。</target>
        </trans-unit>
        <trans-unit id="8f4c8cddaf80a90f873230e5b6a5e7a3ad8af338" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;compile_source&lt;/code&gt; only affects the result if the escript contains &lt;code&gt;source&lt;/code&gt; code. In this case the Erlang code is automatically compiled and &lt;code&gt;{source, BeamCode}&lt;/code&gt; is returned instead of &lt;code&gt;{source, SourceCode}&lt;/code&gt;.</source>
          <target state="translated">如果电子脚本包含 &lt;code&gt;source&lt;/code&gt; 代码，则选项 &lt;code&gt;compile_source&lt;/code&gt; 仅影响结果。在这种情况下，将自动编译Erlang代码 &lt;code&gt;{source, BeamCode}&lt;/code&gt; 并返回{source，BeamCode}而不是 &lt;code&gt;{source, SourceCode}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ac2c8d2a46b7ed6d2b62afd37f0558c267adb74" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the Compiler (see &lt;code&gt;compile(3)&lt;/code&gt;) to have debug information, such as &lt;code&gt;Erlang Abstract Format&lt;/code&gt;, stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. Tools such as Debugger and Xref require the debug information to be included.</source>
          <target state="translated">可以将选项 &lt;code&gt;debug_info&lt;/code&gt; 指定给编译器（请参阅 &lt;code&gt;compile(3)&lt;/code&gt; ），以将调试信息（例如 &lt;code&gt;Erlang Abstract Format&lt;/code&gt; ）存储在 &lt;code&gt;debug_info&lt;/code&gt; 块中。诸如Debugger和Xref之类的工具需要包含调试信息。</target>
        </trans-unit>
        <trans-unit id="bceef863ec9665aec5cef62d9d27d0ce6ab12ecb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; causes &lt;strong&gt;debug information&lt;/strong&gt; or &lt;strong&gt;abstract code&lt;/strong&gt; to be added to the &lt;code&gt;.beam&lt;/code&gt; file. This increases the file size and makes it possible to reconstruct the source code. It is therefore recommended not to include debug information in code aimed for target systems.</source>
          <target state="translated">选项 &lt;code&gt;debug_info&lt;/code&gt; 导致将&lt;strong&gt;调试信息&lt;/strong&gt;或&lt;strong&gt;抽象代码&lt;/strong&gt;添加到 &lt;code&gt;.beam&lt;/code&gt; 文件。这样可以增加文件大小，并可以重构源代码。因此，建议不要在针对目标系统的代码中包含调试信息。</target>
        </trans-unit>
        <trans-unit id="769f8dc6e95ee290900e92345b3ad7fa81275ab3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;extended_info&lt;/code&gt; specifies what extra information is written to the table dump:</source>
          <target state="translated">选项 &lt;code&gt;extended_info&lt;/code&gt; 指定将哪些其他信息写入表转储：</target>
        </trans-unit>
        <trans-unit id="7392a715b1ab5247b835edd88a64118c85b3ed71" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;format&lt;/code&gt; also determines what is written to the sorted output file: if &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, then &lt;code&gt;io:format/3&lt;/code&gt; is called to write each term, otherwise the binary prefixed by a header is written. Notice that the binary written is the same binary that was read; the results of applying function &lt;code&gt;Format&lt;/code&gt; are thrown away when the terms have been sorted. Reading and writing terms using the &lt;code&gt;io&lt;/code&gt; module is much slower than reading and writing binaries.</source>
          <target state="translated">选项 &lt;code&gt;format&lt;/code&gt; 还确定将什么内容写入已排序的输出文件：如果 &lt;code&gt;Format&lt;/code&gt; 为 &lt;code&gt;term&lt;/code&gt; ，则将调用 &lt;code&gt;io:format/3&lt;/code&gt; 来写入每个术语，否则将写入以标头为前缀的二进制文件。注意，写入的二进制文件与读取的二进制文件相同；对术语进行排序后，应用函数 &lt;code&gt;Format&lt;/code&gt; 的结果将被丢弃。使用 &lt;code&gt;io&lt;/code&gt; 模块读取和写入术语比读取和写入二进制文件要慢得多。</target>
        </trans-unit>
        <trans-unit id="c6b86819a94a42b6a35f9a5c83dd920e56cafa28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fragment_timer&lt;/code&gt; specifies the timeout, in milliseconds, of a timer used to flush messages from the incoming byte stream even if the number of bytes indicated in the Message Length field of its Diameter Header have not yet been accumulated: such a message is received over the transport interface after two successive timeouts without the reception of additional bytes. Defaults to 1000.</source>
          <target state="translated">选项 &lt;code&gt;fragment_timer&lt;/code&gt; 指定了计时器（以毫秒为单位）的超时，该计时器用于从传入的字节流中刷新消息，即使尚未累积其Diameter Header的Message Length字段中指示的字节数：连续两个超时后的传输接口，没有接收其他字节。预设为1000。</target>
        </trans-unit>
        <trans-unit id="ed047187b33ff5a36de976c2d7f174208794b18a" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fullsweep_after&lt;/code&gt; makes it possible to specify the maximum number of generational collections before forcing a fullsweep, even if there is room on the old heap. Setting the number to zero disables the general collection algorithm, that is, all live data is copied at every garbage collection.</source>
          <target state="translated">使用选项 &lt;code&gt;fullsweep_after&lt;/code&gt; ，即使在旧堆上有空间，也可以在强制进行全扫描之前指定最大代收集数。将数字设置为零将禁用常规收集算法，即，所有实时数据都会在每次垃圾收集时复制。</target>
        </trans-unit>
        <trans-unit id="ecaf25cf5459dfb31ebf85a2facfaa8a1ab4324e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;hosts&lt;/code&gt; has no effect if &lt;code&gt;log_type&lt;/code&gt; is set to &lt;code&gt;html&lt;/code&gt; or &lt;code&gt;silent&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;log_type&lt;/code&gt; 设置为 &lt;code&gt;html&lt;/code&gt; 或 &lt;code&gt;silent&lt;/code&gt; ,则选项 &lt;code&gt;hosts&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="64143a1b2e482aa0e161fd7b97567d3f14883e09" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;in_comment_only&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default, which is correct for Erlang source files. If set to &lt;code&gt;false&lt;/code&gt;, the encoding string does not necessarily have to occur in a comment.</source>
          <target state="translated">默认情况下，选项 &lt;code&gt;in_comment_only&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，这对于Erlang源文件是正确的。如果设置为 &lt;code&gt;false&lt;/code&gt; ，则编码字符串不一定必须出现在注释中。</target>
        </trans-unit>
        <trans-unit id="ebc5aecdab80e23de01ab20e75171559f54d5713" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;inet6&lt;/code&gt; has no effect on this function. You probably want to use &lt;code&gt;Type = a | aaaa&lt;/code&gt; instead.</source>
          <target state="translated">选项 &lt;code&gt;inet6&lt;/code&gt; 对此功能无效。您可能要使用 &lt;code&gt;Type = a | aaaa&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="8ca5f10fb139927f4989778fe340ba3f7bdbce64" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; deals with how to parse IPv6 addresses. For details, see argument &lt;code&gt;Options&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; 处理如何解析IPv6地址。有关详细信息，请参阅参数 &lt;code&gt;Options&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e3299985763e8c1fce58b82fc31709b15fd60b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; can be used to force the &lt;code&gt;qlc&lt;/code&gt; module to use a certain join method. For the rest of this section it is assumed that the excessively slow join method called &quot;nested loop&quot; has been chosen:</source>
          <target state="translated">选项 &lt;code&gt;join&lt;/code&gt; 可以用来迫使 &lt;code&gt;qlc&lt;/code&gt; 模块使用特定连接方法。对于本节的其余部分，假定已选择了称为&amp;ldquo;嵌套循环&amp;rdquo;的过慢的联接方法：</target>
        </trans-unit>
        <trans-unit id="895c90440d351c3b981bbc05eca735daa09f36b0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; does not imply that the test terms are merged, only that all tests are executed in one single test run.</source>
          <target state="translated">Option &lt;code&gt;join&lt;/code&gt; 并不暗示测试术语已合并，而仅意味着所有测试均在一次测试运行中执行。</target>
        </trans-unit>
        <trans-unit id="176adb220c5fcd1ac1d87552301af2b1ded87f73" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;line_length&lt;/code&gt; also applies to &lt;code&gt;http*&lt;/code&gt; packet types as an alias for option &lt;code&gt;packet_size&lt;/code&gt; if &lt;code&gt;packet_size&lt;/code&gt; itself is not set. This use is only intended for backward compatibility.</source>
          <target state="translated">如果未设置 &lt;code&gt;packet_size&lt;/code&gt; 本身，则选项 &lt;code&gt;line_length&lt;/code&gt; 也适用于 &lt;code&gt;http*&lt;/code&gt; 数据包类型，作为选项 &lt;code&gt;packet_size&lt;/code&gt; 的别名。此用途仅用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="9ab41e9f6eb5eab4065b30a808546e5a4a2b51e9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;message_cb&lt;/code&gt; specifies a callback that is invoked on incoming and outgoing messages, that can be used to implement flow control. It is applied to two arguments: an atom indicating the reason for the callback (&lt;code&gt;send&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;ack&lt;/code&gt; after a completed send), and the message in question (binary() on &lt;code&gt;recv&lt;/code&gt;, binary() or diameter_packet record on &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;ack&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt; on &lt;code&gt;ack&lt;/code&gt; when an incoming request has been discarded). It should return a list of actions and a new callback as tail; eg. &lt;code&gt;[fun cb/3, State]&lt;/code&gt;. Valid actions are the atoms &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, to cause a following message-valued action to be sent/received, a message to send/receive (binary() or diameter_packet record), or a boolean() to enable/disable reading on the socket. More than one &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt;/message sequence can be returned from the same callback, and an initial &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt; can be omitted if the same as the value passed as the callback's first argument. Reading is initially enabled, and returning &lt;code&gt;false&lt;/code&gt; does not imply there cannot be subsequent &lt;code&gt;recv&lt;/code&gt; callbacks since messages may already have been read. An empty tail is equivalent to the prevailing callback. Defaults to a callback equivalent to &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;message_cb&lt;/code&gt; 指定在传入和传出消息上调用的回调，该回调可用于实现流控制。它适用于两个参数：一个原子，指示回调的原因（ &lt;code&gt;send&lt;/code&gt; 完成后发送send， &lt;code&gt;recv&lt;/code&gt; 或 &lt;code&gt;ack&lt;/code&gt; ），以及相关消息（在 &lt;code&gt;recv&lt;/code&gt; 上为 binary（），在 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;ack&lt;/code&gt; 上为binary（）或diameter_packet记录），如果收到的请求已被丢弃，则返回 &lt;code&gt;ack&lt;/code&gt; ( &lt;code&gt;false&lt;/code&gt; ）。它应该返回一个动作列表和一个新的回调作为尾部；例如。 &lt;code&gt;[fun cb/3, State]&lt;/code&gt; 。有效动作是原子 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;recv&lt;/code&gt; ，以导致发送/接收以下消息值操作，发送/接收消息（binary（）或diameter_packet记录）或boolean（）以启用/禁用套接字读取。可以从同一个回调中返回多个 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; / message序列，并且如果与作为回调的第一个参数传递的值相同，则可以省略初始 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; 。最初启用了读取功能，并且返回 &lt;code&gt;false&lt;/code&gt; 并不意味着不能再进行后续的 &lt;code&gt;recv&lt;/code&gt; 回调，因为可能已经读取了消息。空尾等同于流行的回调。默认为等效于 &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt; 的回调； （_，Msg）-&amp;gt; [Msg] end。</target>
        </trans-unit>
        <trans-unit id="b8d5b9882df46cf953f258565ab460a21016ddc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;monitor&lt;/code&gt; is not supported by &lt;code&gt;spawn_opt/5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn_opt/5&lt;/code&gt; 不支持选项 &lt;code&gt;monitor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="058fcf7970e7469cb0bc642aad1ff0a1a179cc45" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;multicast_ttl&lt;/code&gt; changes the time-to-live (TTL) for outgoing multicast datagrams to control the scope of the multicasts.</source>
          <target state="translated">选项 &lt;code&gt;multicast_ttl&lt;/code&gt; 更改传出多播数据报的生存时间（TTL），以控制多播的范围。</target>
        </trans-unit>
        <trans-unit id="369ac162beffd61017f1f26b4498fc999c7935c0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;packet&lt;/code&gt; determines how/if an incoming message is packaged into a diameter_packet record. If &lt;code&gt;false&lt;/code&gt; then messages are received as binary(). If &lt;code&gt;true&lt;/code&gt; then as a record with the binary() message in the &lt;code&gt;bin&lt;/code&gt; field and a &lt;code&gt;{stream, Id}&lt;/code&gt; tuple in the &lt;code&gt;transport_data&lt;/code&gt; field, where &lt;code&gt;Id&lt;/code&gt; is the identifier of the inbound stream the message was received on. If &lt;code&gt;raw&lt;/code&gt; then as a record with the received ancillary sctp_sndrcvinfo record in the &lt;code&gt;transport_data&lt;/code&gt; field. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;packet&lt;/code&gt; 确定如何/是否将传入消息打包到直径记录包记录中。如果为 &lt;code&gt;false&lt;/code&gt; ,则将消息作为binary（）接收。如果为 &lt;code&gt;true&lt;/code&gt; ,则作为一条记录，在 &lt;code&gt;bin&lt;/code&gt; 字段中包含binary（）消息，在 &lt;code&gt;transport_data&lt;/code&gt; 字段中包含 &lt;code&gt;{stream, Id}&lt;/code&gt; 元组，其中， &lt;code&gt;Id&lt;/code&gt; 是接收消息的入站流的标识符。如果是 &lt;code&gt;raw&lt;/code&gt; 则将其作为记录，在 &lt;code&gt;transport_data&lt;/code&gt; 字段中包含接收到的辅助sctp_sndrcvinfo记录。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0baa94c523937f7abe156cc0676d6a21aa0601f3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;pending_driver&lt;/code&gt; is of little use, but is present for completeness, as it is well defined which reload options that can give rise to which delays. However, it can be a good idea to use the same &lt;code&gt;MonitorOption&lt;/code&gt; as the &lt;code&gt;ReloadOption&lt;/code&gt;, if present.</source>
          <target state="translated">选项 &lt;code&gt;pending_driver&lt;/code&gt; 没什么用，但是出于完整性考虑而存在，因为它已定义好，哪些重新加载选项会引起哪些延迟。但是，最好使用与 &lt;code&gt;ReloadOption&lt;/code&gt; 相同的 &lt;code&gt;MonitorOption&lt;/code&gt; （如果存在）。</target>
        </trans-unit>
        <trans-unit id="f5cff995931880f38d32793bedddc8696fd39abc" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;persistent&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt; to guarantee that parameters set with &lt;code&gt;set_env/4&lt;/code&gt; are not overridden by those defined in the application resource file on load. This means that persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">可以将选项 &lt;code&gt;persistent&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,以确保使用 &lt;code&gt;set_env/4&lt;/code&gt; 设置的参数在加载时不会被应用程序资源文件中定义的参数覆盖。这意味着持久值将在应用程序加载后以及重新加载应用程序时保留。</target>
        </trans-unit>
        <trans-unit id="9c0c34736e937a0d6bddb3baef2d644165d26b6e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;progress&lt;/code&gt; is intended to be used by applications that want to create some type of progress report, such as a progress bar in a GUI. Default for the progress option is &lt;code&gt;ignore&lt;/code&gt;, that is, the option is not used. When the progress option is specified, the following happens when &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; or &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; are called:</source>
          <target state="translated">想要创建某些类型的进度报告（例如GUI中的进度条）的应用程序将使用选件 &lt;code&gt;progress&lt;/code&gt; 。进度选项的默认值为 &lt;code&gt;ignore&lt;/code&gt; ，即不使用该选项。当指定progress选项时，在调用 &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; 或 &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; 时发生以下情况：</target>
        </trans-unit>
        <trans-unit id="121fc2ac086a7c8d8d3e29d994b8f84bb924c24b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;read_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common.</source>
          <target state="translated">选项 &lt;code&gt;read_concurrency&lt;/code&gt; 可以与选项 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt; 结合使用。当大并发读取突发和大并发写入突发很常见时，您通常希望将它们组合在一起。</target>
        </trans-unit>
        <trans-unit id="ce25f3241dc3da9e62005bbb6632271b6187acc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;repair&lt;/code&gt; is ignored if the table is already open.</source>
          <target state="translated">如果表已经打开，则忽略选项 &lt;code&gt;repair&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cebc9a26a2692e09f8edba6efb06adb14bf3202b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;report_errors&lt;/code&gt; adds the possibility that an error tuple is returned. The tuple either indicates a matching error (&lt;code&gt;match_limit&lt;/code&gt; or &lt;code&gt;match_limit_recursion&lt;/code&gt;), or a compilation error, where the error tuple has the format &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt;. Notice that if option &lt;code&gt;report_errors&lt;/code&gt; is not specified, the function never returns error tuples, but reports compilation errors as a &lt;code&gt;badarg&lt;/code&gt; exception and failed matches because of exceeded match limits simply as &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;report_errors&lt;/code&gt; 增加了返回错误元组的可能性。元组要么指示匹配错误（ &lt;code&gt;match_limit&lt;/code&gt; 或 &lt;code&gt;match_limit_recursion&lt;/code&gt; ），要么指示编译错误，其中错误元组的格式为 &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt; 。请注意，如果未指定option &lt;code&gt;report_errors&lt;/code&gt; ，则该函数从不返回错误元组，而是将编译错误报告为 &lt;code&gt;badarg&lt;/code&gt; 异常，并且由于超出匹配限制而导致匹配失败，仅报告为 &lt;code&gt;nomatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc492ec1e8bbd2f982156bf23c1f5fcad8e8282" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;sender&lt;/code&gt; specifies whether or not to use a dedicated process for sending outgoing messages, which avoids the possibility of send blocking reception. Defaults to &lt;code&gt;false&lt;/code&gt;. If set to &lt;code&gt;true&lt;/code&gt; then a &lt;code&gt;message_cb&lt;/code&gt; that avoids the possibility of messages being queued in the sender process without bound should be configured.</source>
          <target state="translated">选项 &lt;code&gt;sender&lt;/code&gt; 指定是否使用专用的过程来发送传出消息，这避免了发送阻塞接收的可能性。默认为 &lt;code&gt;false&lt;/code&gt; 。如果设置为 &lt;code&gt;true&lt;/code&gt; ,则应该配置 &lt;code&gt;message_cb&lt;/code&gt; ，以避免消息在发送方进程中无限制地排队。</target>
        </trans-unit>
        <trans-unit id="50b59aee750b8ace41d580c775edcd5cf8326a92" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ssl_options&lt;/code&gt; must be specified for a transport that should support TLS: a value of &lt;code&gt;true&lt;/code&gt; results in a TLS handshake immediately upon connection establishment while &lt;code&gt;list()&lt;/code&gt; specifies options to be passed to &lt;code&gt;ssl:connect/2&lt;/code&gt; or &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; after capabilities exchange if TLS is negotiated.</source>
          <target state="translated">必须为应该支持TLS的传输指定选项 &lt;code&gt;ssl_options&lt;/code&gt; ：值 &lt;code&gt;true&lt;/code&gt; 会在建立连接后立即进行TLS握手，而 &lt;code&gt;list()&lt;/code&gt; 指定在功能交换后传递给 &lt;code&gt;ssl:connect/2&lt;/code&gt; 或 &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; 的选项如果协商TLS。</target>
        </trans-unit>
        <trans-unit id="eb0b2c00845747ebfd6a57dac944c8489e34fe1d" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection and when waiting for the &lt;code&gt;hello&lt;/code&gt; message from the server. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">设置SSH连接时以及等待来自服务器的 &lt;code&gt;hello&lt;/code&gt; 消息时，将使用选项 &lt;code&gt;timeout&lt;/code&gt; （毫秒）。在连接的生存期内，它不用于任何其他目的。</target>
        </trans-unit>
        <trans-unit id="afc7cede7fbac62c14c694ddc0b6eec6bf4a0ae3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">设置SSH连接时使用选项 &lt;code&gt;timeout&lt;/code&gt; （毫秒）。在连接的生存期内，它不用于任何其他目的。</target>
        </trans-unit>
        <trans-unit id="33648c8e4866da798d09c425a4d8d5d74a5e0058" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; specifies how long the client must wait for prompt. If the time expires, the function returns &lt;code&gt;{error,timeout}&lt;/code&gt;. For information about the default value for the command timeout, see the &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">选项 &lt;code&gt;timeout&lt;/code&gt; 指定客户端必须等待多长时间提示。如果时间到了，该函数将返回 &lt;code&gt;{error,timeout}&lt;/code&gt; 。有关命令超时的默认值的信息，请参阅本模块开头的 &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c0719ab2fd2367d9658fdeb70a32aaa618f2e49" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unicode&lt;/code&gt; is an alias for &lt;code&gt;utf8&lt;/code&gt;, as this is the preferred encoding for Unicode characters in binaries. &lt;code&gt;utf16&lt;/code&gt; is an alias for &lt;code&gt;{utf16,big}&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; is an alias for &lt;code&gt;{utf32,big}&lt;/code&gt;. The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">选项 &lt;code&gt;unicode&lt;/code&gt; 是 &lt;code&gt;utf8&lt;/code&gt; 的别名，因为这是二进制文件中Unicode字符的首选编码。 &lt;code&gt;utf16&lt;/code&gt; 是 &lt;code&gt;{utf16,big}&lt;/code&gt; 的别名，而 &lt;code&gt;utf32&lt;/code&gt; 是 &lt;code&gt;{utf32,big}&lt;/code&gt; 的别名。 &lt;code&gt;big&lt;/code&gt; 和 &lt;code&gt;little&lt;/code&gt; 原子表示大尾数编码。</target>
        </trans-unit>
        <trans-unit id="dd54ba2652e6caa2fdc53e186c7711e64ef49755" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unordered&lt;/code&gt; specifies whether or not to use unordered delivery, integer &lt;code&gt;N&lt;/code&gt; being equivalent to &lt;code&gt;N =&amp;lt; OS&lt;/code&gt;, where &lt;code&gt;OS&lt;/code&gt; is the number of outbound streams negotiated on the association in question. Regardless of configuration, sending is ordered on stream 0 until reception of a second incoming message, to ensure that a peer receives capabilities exchange messages before any other. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;unordered&lt;/code&gt; 指定是否使用无序传递，整数 &lt;code&gt;N&lt;/code&gt; 等于 &lt;code&gt;N =&amp;lt; OS&lt;/code&gt; ，其中 &lt;code&gt;OS&lt;/code&gt; 是在所讨论的关联上协商的出站流的数量。不管配置如何，都将在流0上对发送进行排序，直到接收到第二条传入消息为止，以确保对等方在接收能力之前先交换消息。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9437b2aaf317ba6723d7637ccb49bca377c204e5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;$ROOT/lib&lt;/code&gt; for some of the applications. If a variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in a directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application gets the path &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; in the boot script. If an application is found in a directory &lt;code&gt;Prefix/Rest&lt;/code&gt;, the path is &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt;. When starting Erlang, all variables &lt;code&gt;VarName&lt;/code&gt; are given values using command-line flag &lt;code&gt;boot_var&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;variables&lt;/code&gt; 可用于为某些应用程序指定 &lt;code&gt;$ROOT/lib&lt;/code&gt; 以外的安装目录。如果指定了变量 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; ，并且在目录 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; 找到了一个应用程序，则该应用程序将在启动脚本中获取路径 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 。如果在目录 &lt;code&gt;Prefix/Rest&lt;/code&gt; 中找到了应用程序，则路径为 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 。启动Erlang时，使用命令行标志 &lt;code&gt;boot_var&lt;/code&gt; 为所有变量 &lt;code&gt;VarName&lt;/code&gt; 赋值。</target>
        </trans-unit>
        <trans-unit id="3fe4cb46f323a7c472497777738ff73ebf76a2c2" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;lib&lt;/code&gt; for some of the applications. If variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application is packed into a separate &lt;code&gt;VarName.tar.gz&lt;/code&gt; file as &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;variables&lt;/code&gt; 可用于为某些应用程序指定 &lt;code&gt;lib&lt;/code&gt; 以外的安装目录。如果指定了变量 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; ，并且在目录 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; 找到了一个应用程序，则该应用程序将作为 &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt; 打包到一个单独的 &lt;code&gt;VarName.tar.gz&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="a5d38b5eca75c6ce7a8a86d89951c54beea09b28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; (or rather &lt;code&gt;{verbose,true}&lt;/code&gt;) causes diagnostics printout through &lt;code&gt;io:format/2&lt;/code&gt; of queries, replies retransmissions, and so on, similar to from utilities, such as &lt;code&gt;dig&lt;/code&gt; and &lt;code&gt;nslookup&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;verbose&lt;/code&gt; （或更确切地说， &lt;code&gt;{verbose,true}&lt;/code&gt; ）通过查询的 &lt;code&gt;io:format/2&lt;/code&gt; 导致诊断打印输出，回复重传等，类似于 &lt;code&gt;dig&lt;/code&gt; 和 &lt;code&gt;nslookup&lt;/code&gt; 之类的实用程序。</target>
        </trans-unit>
        <trans-unit id="3a9444c4853f083de328fc1ee9ccc9ae214b7bd7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; can be added to get information about the generated files:</source>
          <target state="translated">可以添加选项 &lt;code&gt;verbose&lt;/code&gt; 以获取有关生成的文件的信息：</target>
        </trans-unit>
        <trans-unit id="72dc8b34cd621366e301671b30bbc40e7b1100a0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;write_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;write_concurrency&lt;/code&gt; 可以与选项 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; 结合使用。当大的并发读取突发和大的并发写入突发很常见时，通常需要将它们组合在一起。有关更多信息，请参见选项 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a9faea62aad9078a0a76ca4af9ddb6c33c84d32" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; can be used to cache the answers to a QLC. The answers are stored in one ETS table for each cached QLC. When a cached QLC is evaluated again, answers are fetched from the table without any further computations. Therefore, when all answers to a cached QLC have been found, the ETS tables used for caching answers to the qualifiers of the QLC can be emptied. Option &lt;code&gt;cache&lt;/code&gt; is equivalent to &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 可用于将答案缓存到QLC。对于每个缓存的QLC，答案都存储在一个ETS表中。再次评估缓存的QLC时，无需进一步计算即可从表中获取答案。因此，当找到了对缓存的QLC的所有答案时，可以将用于缓存对QLC的限定词的答案的ETS表清空。选项 &lt;code&gt;cache&lt;/code&gt; 等效于 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0b3ecf3fceaf01bc2ca34bef8c3c517c967e629" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; can be used to cache the answers to a QLC like &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;. The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory, a temporary file is used for storing the answers. Option &lt;code&gt;max_list_size&lt;/code&gt; sets the limit in bytes and the temporary file is put on the directory set by option &lt;code&gt;tmpdir&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 可以用于缓存QLC的答案，例如 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 。区别在于答案保存在列表中（在进程堆上）。如果答案将占用超过一定数量的RAM内存，则将使用一个临时文件来存储答案。选项 &lt;code&gt;max_list_size&lt;/code&gt; 设置限制（以字节为单位），并将临时文件放入选项 &lt;code&gt;tmpdir&lt;/code&gt; 设置的目录中。</target>
        </trans-unit>
        <trans-unit id="c363b0b99cf0b9f17d626eea478292453b3a04e0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; offers the possibility to store the answers in a list on the process heap. This has the potential of being faster than ETS tables, as there is no need to copy answers from the table. However, it can often result in slower evaluation because of more garbage collections of the process heap and increased RAM memory consumption because of larger heaps. Another drawback with cache lists is that if the list size exceeds a limit, a temporary file is used. Reading the answers from a file is much slower than copying them from an ETS table. But if the available RAM memory is scarce, setting the &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; to some low value is an alternative.</source>
          <target state="translated">选项 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 提供了将答案存储在进程堆上的列表中的可能性。这有可能比ETS表更快，因为不需要从表中复制答案。但是，由于进程堆的更多垃圾回收，并且由于堆大而导致的RAM内存消耗增加，通常会导致评估速度变慢。缓存列表的另一个缺点是，如果列表大小超出限制，则会使用一个临时文件。从文件中读取答案比从ETS表中复制答案要慢得多。但是，如果可用的RAM内存不足，则可以将 &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; 设置为较低的值。</target>
        </trans-unit>
        <trans-unit id="78277a7753947f4b67c1f00cd1efea245ef61134" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful if the peer has done a shutdown on the write side.</source>
          <target state="translated">如果对等方在写端执行了关闭操作，则选项 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="06b017310b210415f4e3f5ffc5d41bfadc6c3b12" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; can be used to ensure that a certain join method is used:</source>
          <target state="translated">选项 &lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; 可用于确保使用特定的join方法：</target>
        </trans-unit>
        <trans-unit id="30fedae2cf205df5ff8623315cf8962b5f1bff95" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; can be used to ensure that the &lt;code&gt;qlc&lt;/code&gt; module looks up constants in some QLC table. If there are more than one QLC table among the list expressions of the generators, constants must be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful when it would be unacceptable to traverse all objects in some table. Setting option &lt;code&gt;lookup&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; ensures that no constants are looked up (&lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; has the same effect). Defaults to &lt;code&gt;any&lt;/code&gt;, which means that constants are looked up whenever possible.</source>
          <target state="translated">选项 &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; 可用于确保 &lt;code&gt;qlc&lt;/code&gt; 模块在某些QLC表中查找常量。如果生成器的列表表达式中有多个QLC表，则必须在至少一个表中查找常量。如果没有要查找的常量，则查询评估失败。当遍历某个表中的所有对象时，此选项很有用。将选项 &lt;code&gt;lookup&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 可确保不查找任何常量（ &lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; 具有相同的效果）。默认为 &lt;code&gt;any&lt;/code&gt; ，这意味着将尽可能查找常量。</target>
        </trans-unit>
        <trans-unit id="e9c6fcc69606cfd5e227d68821d1d1d7a8fea3e4" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; can be used to control some encoding details. This option was introduced in Erlang/OTP R11B-4. The valid values for &lt;code&gt;Version&lt;/code&gt; are:</source>
          <target state="translated">选项 &lt;code&gt;{minor_version, Version}&lt;/code&gt; 可以用来控制一些编码细节。此选项是在Erlang / OTP R11B-4中引入的。对于有效值 &lt;code&gt;Version&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="fe3131626c8fb97f4a37a0360d9d266a8a597be3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; specifies how floats are encoded. For a detailed description, see &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;{minor_version, Version}&lt;/code&gt; 指定浮点数的编码方式。有关详细说明，请参见 &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="524c17823f60e5f4fb7f4313f11efaa80a725ce7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{shell, ShellType}&lt;/code&gt; allows making &lt;code&gt;ttb&lt;/code&gt; operation similar to &lt;code&gt;dbg&lt;/code&gt;. Using &lt;code&gt;{shell, true}&lt;/code&gt; displays all trace messages in the shell before storing them. &lt;code&gt;{shell, only}&lt;/code&gt; additionally disables message storage (making the tool to behave exactly like &lt;code&gt;dbg&lt;/code&gt;). This is allowed only with IP trace ports (&lt;code&gt;{trace, {local, File}}&lt;/code&gt;).</source>
          <target state="translated">选项 &lt;code&gt;{shell, ShellType}&lt;/code&gt; 允许进行类似于 &lt;code&gt;dbg&lt;/code&gt; 的 &lt;code&gt;ttb&lt;/code&gt; 操作。使用 &lt;code&gt;{shell, true}&lt;/code&gt; 可以在存储所有跟踪消息之前在外壳中显示它们。 &lt;code&gt;{shell, only}&lt;/code&gt; 另外禁用消息存储（使该工具的行为与 &lt;code&gt;dbg&lt;/code&gt; 完全相同）。仅IP跟踪端口（ &lt;code&gt;{trace, {local, File}}&lt;/code&gt; ）才允许这样做。</target>
        </trans-unit>
        <trans-unit id="ef42e9a1232f5a9ba117da4d9479739de508ecd1" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; can be used to remove duplicate answers to a QLC. The unique answers are stored in one ETS table for each QLC. The table is emptied every time it is known that there are no more answers to the QLC. Option &lt;code&gt;unique&lt;/code&gt; is equivalent to &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;, two ETS tables are used, but the full answers are stored in one table only. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt;, the answers are sorted twice using &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt;; once to remove duplicates and once to restore the order.</source>
          <target state="translated">选项 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 可用于删除QLC的重复答案。唯一答案存储在每个QLC的一个ETS表中。每当知道QLC不再有答案时，便会清空该表。选项 &lt;code&gt;unique&lt;/code&gt; 等效于 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 。如果选项 &lt;code&gt;unique&lt;/code&gt; 与选项 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 组合使用，则使用两个ETS表，但是完整答案仅存储在一个表中。如果选项 &lt;code&gt;unique&lt;/code&gt; 与选项 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 组合在一起，则答案将使用 &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt; 进行两次排序；一次删除重复项，一次恢复订单。</target>
        </trans-unit>
        <trans-unit id="d03fe843ff69bab217c2db04a4de76a5997a0834" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{var_tar,VarTar}&lt;/code&gt; can be used to specify if and where a separate package is to be stored. In this option &lt;code&gt;VarTar&lt;/code&gt; is one of the following:</source>
          <target state="translated">选项 &lt;code&gt;{var_tar,VarTar}&lt;/code&gt; 可用于指定是否以及在何处存储单独的程序包。在此选项中， &lt;code&gt;VarTar&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="035817bcba72e336831559d60aeb6facccf9b64f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Close&lt;/strong&gt; executes &lt;code&gt;erlang:port_close/1&lt;/code&gt; on the port under the mouse pointer.</source>
          <target state="translated">选项&lt;strong&gt;Close&lt;/strong&gt;在鼠标指针下方的端口上执行 &lt;code&gt;erlang:port_close/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35e926c6fbc3d99b909d12d014b384bd4c783eb2" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Kill process&lt;/strong&gt; brutally kills the processes under the mouse pointer by sending an exit signal with reason &lt;code&gt;kill&lt;/code&gt;.</source>
          <target state="translated">选项&lt;strong&gt;Kill进程&lt;/strong&gt;通过发送带有 &lt;code&gt;kill&lt;/code&gt; 理由的退出信号来残酷地杀死鼠标指针下的进程。</target>
        </trans-unit>
        <trans-unit id="70321865963caf3c8ea1efe0081cc07fb0b639e6" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Port info&lt;/strong&gt; opens a detailed information window for the port under the mouse pointer. In addition to the information above, it also shows links and monitors.</source>
          <target state="translated">选件&lt;strong&gt;端口信息&lt;/strong&gt;将在鼠标指针下方打开该端口的详细信息窗口。除了上面的信息之外，它还显示链接和监视器。</target>
        </trans-unit>
        <trans-unit id="7d65b0f04dbfd40d29f90c9cb3594f974e725b28" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Process info&lt;/strong&gt; opens a detailed information window on the process under the mouse pointer, including the following:</source>
          <target state="translated">Option &lt;strong&gt;Process info&lt;/strong&gt;选项将在鼠标指针下方打开有关该进程的详细信息窗口，包括以下内容：</target>
        </trans-unit>
        <trans-unit id="99160977b4d7a39a2a6e97003b66bdad996bc6ed" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports by name&lt;/strong&gt; adds the registered name of the port to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;. This can be useful when tracing is done on many nodes, as ports with that name are then traced on all traced nodes.</source>
          <target state="translated">选项&amp;ldquo; &lt;strong&gt;按名称跟踪选定的端口&amp;rdquo;&lt;/strong&gt;会将&lt;strong&gt;端口&lt;/strong&gt;的注册&lt;strong&gt;名称&lt;/strong&gt;添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡中。当在许多节点上进行跟踪时，这很有用，因为在所有被跟踪的节点上都将跟踪具有该名称的端口。</target>
        </trans-unit>
        <trans-unit id="2b6c236e8cdc6b5cda5c55b97f093a7e3cd6785f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports&lt;/strong&gt; adds the selected port identifiers, and the nodes that the ports reside on, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">&amp;ldquo;选项&lt;strong&gt;跟踪选定的端口&amp;rdquo;&lt;/strong&gt;选项会将选定的端口标识符以及端口所在的节点添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡中。</target>
        </trans-unit>
        <trans-unit id="ac9ff1921b3900c17896467fd0d99ce466117b8b" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes by name&lt;/strong&gt; adds the registered name of the processes. This can be useful when tracing is done on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">选项&lt;strong&gt;按名称跟踪选定的进程&lt;/strong&gt;将添加&lt;strong&gt;进程&lt;/strong&gt;的注册名称。在许多节点上进行跟踪时，这将很有用，因为随后会在所有跟踪的节点上跟踪具有该名称的进程。</target>
        </trans-unit>
        <trans-unit id="5f5a98945509d3374dcec511a2237bb11d72c5e8" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes&lt;/strong&gt; adds the selected process identifiers to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the processes reside on.</source>
          <target state="translated">&amp;ldquo;选项&lt;strong&gt;跟踪选定的进程&amp;rdquo;&lt;/strong&gt;会将选定的进程标识符添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡以及进程所在的节点。</target>
        </trans-unit>
        <trans-unit id="bbcdc0d51603836feb28f7c0f6ebeff6083e909a" translate="yes" xml:space="preserve">
          <source>Option can be an empty list. Otherwise, see possible &lt;strong&gt;POSIX&lt;/strong&gt; names in Section 8 in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">选项可以为空列表。否则，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt; 中第8节中可能的&lt;strong&gt;POSIX&lt;/strong&gt;名称。</target>
        </trans-unit>
        <trans-unit id="ed343dc73ff17a12eae43c4c8abcaf085a15af89" translate="yes" xml:space="preserve">
          <source>Option description:</source>
          <target state="translated">描述选项:</target>
        </trans-unit>
        <trans-unit id="842a1436ee68919d09edec512df7b86300e0f790" translate="yes" xml:space="preserve">
          <source>Option for the request to be synchronous or asynchronous.</source>
          <target state="translated">请求是同步还是异步的选项。</target>
        </trans-unit>
        <trans-unit id="1293048f15d31bf84b0b730a9b1782f9b01e778a" translate="yes" xml:space="preserve">
          <source>Option list, required but not used.</source>
          <target state="translated">选项列表,需要但不使用。</target>
        </trans-unit>
        <trans-unit id="462548ed78075584c1554197ff33d7cd930b932f" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. Has one of the following types.</source>
          <target state="translated">选项传递给 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 。具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="23707ebafb992d8dfae9b58a9ba61d8c8fd2c70a" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. Can be any &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; as well as the following.</source>
          <target state="translated">选项传递给 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 。可以是任何 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 以及以下内容。</target>
        </trans-unit>
        <trans-unit id="0c6c4102d4dfec3b1aa41117e0e344046c58a151" translate="yes" xml:space="preserve">
          <source>Optional</source>
          <target state="translated">Optional</target>
        </trans-unit>
        <trans-unit id="4d4b2106cdcb3604717e69731f6481a51f9daa36" translate="yes" xml:space="preserve">
          <source>Optional Header Elements</source>
          <target state="translated">可选标题元素</target>
        </trans-unit>
        <trans-unit id="dfbb34787505eab01012f74ede55769d7b2752c8" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt;, shown in the functions described in this module, defines a function that is called when an unknown form occurs where there is to be a valid expression. If &lt;code&gt;HookFunction&lt;/code&gt; is equal to &lt;code&gt;none&lt;/code&gt;, there is no hook function.</source>
          <target state="translated">可选参数 &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt; （在此模块中描述的函数中显示）定义了一个函数，当出现未知形式并需要一个有效表达式时，将调用该函数。如果 &lt;code&gt;HookFunction&lt;/code&gt; 等于 &lt;code&gt;none&lt;/code&gt; ，则没有钩子函数。</target>
        </trans-unit>
        <trans-unit id="276de84647d247405111dca217abe17bdd0364d3" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;NumberOfAnswers&lt;/code&gt; determines the maximum number of answers returned. Defaults to &lt;code&gt;10&lt;/code&gt;. If less than the requested number of answers is returned, subsequent calls to &lt;code&gt;next_answers&lt;/code&gt; return &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;code&gt;NumberOfAnswers&lt;/code&gt; 确定返回的最大答案数。默认为 &lt;code&gt;10&lt;/code&gt; 。如果返回的请求数量少于请求的数量，则对 &lt;code&gt;next_answers&lt;/code&gt; 的后续调用将返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e155301399a6f11bab8a0f03e661dc264bf4113" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out in milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;code&gt;Timeout&lt;/code&gt; 以毫秒为单位指定超时。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc160da129ae196cb0bc016f6e6b2dc9018a93f1" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on disc or in RAM. If the schema is found on disc, Mnesia starts as a disc-based node and the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;. If no schema is found on disc, Mnesia starts as a disc-less node and the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;. Default value for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">可选光盘。该模式可以驻留在磁盘上或RAM中。如果在磁盘上找到了架构，则Mnesia将从基于磁盘的节点开始，架构表的存储类型为 &lt;code&gt;disc_copies&lt;/code&gt; 。如果在磁盘上未找到任何模式，则Mnesia将从 &lt;code&gt;ram_copies&lt;/code&gt; 节点开始，并且模式表的存储类型为ram_copies。应用程序参数的默认值为 &lt;code&gt;opt_disc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08766916e383f04d3e4dd8436f435e4ff78d676e" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on either disc or RAM. If the schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-full node (the storage type of the schema table is disc_copies). If no schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node (the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;). The default for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">可选光盘。该模式可以驻留在磁盘或RAM上。如果在磁盘上找到了架构，则 &lt;code&gt;Mnesia&lt;/code&gt; 将从光盘已满的节点开始（架构表的存储类型为disc_copies）。如果在磁盘上未找到任何模式，则 &lt;code&gt;Mnesia&lt;/code&gt; 将从 &lt;code&gt;ram_copies&lt;/code&gt; 节点开始（模式表的存储类型为ram_copies）。应用程序参数的默认值为 &lt;code&gt;opt_disc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85dd2f62ecb3fc58781f23223662bb5750bb8b07" translate="yes" xml:space="preserve">
          <source>Optional fields are to be omitted from the map if they have no value:</source>
          <target state="translated">可选字段如果没有价值,则在地图中省略。</target>
        </trans-unit>
        <trans-unit id="f7ff2e1b639664116012253b69978817d7cb9d18" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent.</source>
          <target state="translated">可选参数,表示感兴趣的事件流。如果没有,则发送默认的NETCONF流的事件。</target>
        </trans-unit>
        <trans-unit id="9f20bc591a797de16d0e389435598756b6d01a90" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent.</source>
          <target state="translated">可选参数,表示所有可能的事件中哪个子集值得关注。该参数的格式与NETCONF协议操作中的过滤器参数的格式相同。如果没有这个参数,则发送所有未被其他参数排除的事件。</target>
        </trans-unit>
        <trans-unit id="91c8bbcc154e216bf161a4cea2cf2921f55e3375" translate="yes" xml:space="preserve">
          <source>Optional parameter used to trigger the replay feature and indicate that the replay is to start at the time specified. If &lt;code&gt;StartTime&lt;/code&gt; is not present, this is not a replay subscription.</source>
          <target state="translated">可选参数，用于触发重播功能，并指示重播将在指定的时间开始。如果不存在 &lt;code&gt;StartTime&lt;/code&gt; ，则这不是重播订阅。</target>
        </trans-unit>
        <trans-unit id="3b62c08c67213d147aac035093ce60b242c49707" translate="yes" xml:space="preserve">
          <source>Optional parameter used with the optional replay feature to indicate the newest notifications of interest. If &lt;code&gt;StopTime&lt;/code&gt; is not present, the notifications continues until the subscription is terminated.</source>
          <target state="translated">与可选的重播功能一起使用的可选参数，指示最新的关注通知。如果不存在 &lt;code&gt;StopTime&lt;/code&gt; ，则通知将继续直到订阅终止。</target>
        </trans-unit>
        <trans-unit id="a4149a55fc8e55fc8490190fca6fd327f9a538b3" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Optional.</target>
        </trans-unit>
        <trans-unit id="e8af255ca8f0d30288a7d242bda54e97c39eddd8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e770d9ae3be1592b6bb4e71a2a0b4d02b632c8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f444f3a32fb5864a64535a82d40b191fe3d8f92a" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d86ff1cf1753eeb2712d25027e36b3bfeeb878b3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a5be38a4ec672fa5fc505b1d3938e2c4805690c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;4000&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;4000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d818395035fabb022c90708c6cc84ee8b4b5af1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;484&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;484&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb016daeda5d1c2dc4395fae5d7f67d4983388a1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;5000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a91274ea47ca456c7c73bd65eabdba098688b45e" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;[v2]&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;[v2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9145bb534991daf57f7701301bbf91899e9dd502" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1862eeb7c8ff53d3ad48a0810e5755cdc2bd4c3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;localhost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56e30788f63a5934b2591e0b2064ad81f73c70ba" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">可选的。默认为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50d0a6ed5f07cbf3535d40a94c01a427fc76812c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;trap&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;trap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81e97dcaaa41ca3300b210af9cb347aabd6782bc" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">可选的。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a5e868b1b2f32a86b5bd642dcb3afd6a406ab2" translate="yes" xml:space="preserve">
          <source>Optional. SNMPv3 only.</source>
          <target state="translated">可选。仅SNMPv3。</target>
        </trans-unit>
        <trans-unit id="e29d2e9b1f6270c8f759be9d98bdcc632686ece6" translate="yes" xml:space="preserve">
          <source>Optional. Specifies a file name relative to the release directory (that is, the subdirectory of &amp;lt;release root&amp;gt; where the &lt;code&gt;.boot&lt;/code&gt; file and others are located). The contents of this file is appended to the command line when Erlang is started. This makes it easy to start the emulator with different options for different releases.</source>
          <target state="translated">可选的。指定相对于发布目录的文件名（即 &lt;code&gt;.boot&lt;/code&gt; 文件和其他文件所在的&amp;lt;release root&amp;gt;的子目录）。启动Erlang时，此文件的内容将附加到命令行。这使得使用不同版本的不同选项轻松启动仿真器。</target>
        </trans-unit>
        <trans-unit id="2b0c96e71650acccc82db9e27a628d2721580904" translate="yes" xml:space="preserve">
          <source>Optional. Specifies another data file than &lt;code&gt;start_erl.data&lt;/code&gt; in the &amp;lt;release root&amp;gt;. It is specified relative to the &amp;lt;release root&amp;gt; or absolute (including drive letter, and so on). This option is used by the release handler during upgrade and is not to be used during normal operation. Normally the release data file is not to be named differently.</source>
          <target state="translated">可选的。指定&amp;lt;release root&amp;gt;中除 &lt;code&gt;start_erl.data&lt;/code&gt; 之外的另一个数据文件。它是相对于&amp;lt;release root&amp;gt;或绝对值（包括驱动器号，等等）指定的。此选项在升级过程中由发行处理程序使用，在正常操作期间不使用。通常，发布数据文件的名称不应不同。</target>
        </trans-unit>
        <trans-unit id="6e896a68b07b1ca3cf93595378b5e6e78183b5ae" translate="yes" xml:space="preserve">
          <source>Optional. Specifies what &lt;code&gt;start_erl.data&lt;/code&gt; file to use.</source>
          <target state="translated">可选的。指定要使用的 &lt;code&gt;start_erl.data&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="8dfb648c156e19ccfde0a8a75080225f82a66290" translate="yes" xml:space="preserve">
          <source>Optional: a list of</source>
          <target state="translated">可选:一个清单</target>
        </trans-unit>
        <trans-unit id="40298ed5ccf236464308dd175b962b82475a2522" translate="yes" xml:space="preserve">
          <source>Optional: one or more</source>
          <target state="translated">可选:一个或多个</target>
        </trans-unit>
        <trans-unit id="c38ca1d794e5db4040d672952825698f938f1b2b" translate="yes" xml:space="preserve">
          <source>Optionally an associated condition. A condition is a tuple &lt;code&gt;{Module,Name}&lt;/code&gt;. When the breakpoint is reached, &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; is called. If it evaluates to &lt;code&gt;true&lt;/code&gt;, execution stops. If it evaluates to &lt;code&gt;false&lt;/code&gt;, the breakpoint is ignored. &lt;code&gt;Bindings&lt;/code&gt; contains the current variable bindings. To retrieve the value for a specified variable, use &lt;code&gt;get_binding&lt;/code&gt;.</source>
          <target state="translated">（可选）相关条件。条件是元组 &lt;code&gt;{Module,Name}&lt;/code&gt; 。到达断点时，将调用 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 。如果计算结果为 &lt;code&gt;true&lt;/code&gt; ，则执行停止。如果计算结果为 &lt;code&gt;false&lt;/code&gt; ，则断点将被忽略。 &lt;code&gt;Bindings&lt;/code&gt; 包含当前的变量绑定。要获取指定变量的值，请使用 &lt;code&gt;get_binding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a4282aaa4b303055b863e5204685bc1397a847f" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a time consuming transaction request</source>
          <target state="translated">对于耗时的交易请求,可选择调用。</target>
        </trans-unit>
        <trans-unit id="c6c8e1e5181e25bac7195f77b91e7ea903739f23" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction acknowledgement</source>
          <target state="translated">可选择调用,用于交易确认。</target>
        </trans-unit>
        <trans-unit id="a5f2278c7ee5f9556ced2e826a1b917355402ad3" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction reply</source>
          <target state="translated">可选择调用,用于交易回复</target>
        </trans-unit>
        <trans-unit id="da6a3730bb2085f8ebf92b6273cda1787e65e75e" translate="yes" xml:space="preserve">
          <source>Optionally specifies how captured substrings are to be returned. If omitted, the default of &lt;code&gt;index&lt;/code&gt; is used.</source>
          <target state="translated">（可选）指定如何返回捕获的子字符串。如果省略，则使用默认 &lt;code&gt;index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9749013cefa7f03d17b664b15412b1588b737407" translate="yes" xml:space="preserve">
          <source>Options (&lt;code&gt;Opt&lt;/code&gt;s):</source>
          <target state="translated">选项（ &lt;code&gt;Opt&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="2a71724fb98cff6a19705fe029e03eebb720115b" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;-P&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, and &lt;code&gt;-S&lt;/code&gt; are equivalent to &lt;code&gt;+'P'&lt;/code&gt;, &lt;code&gt;+'E'&lt;/code&gt;, and &lt;code&gt;+'S'&lt;/code&gt;, except that it is not necessary to include the single quotes to protect them from the shell.</source>
          <target state="translated">选项 &lt;code&gt;-P&lt;/code&gt; ， &lt;code&gt;-E&lt;/code&gt; 和 &lt;code&gt;-S&lt;/code&gt; 等效于 &lt;code&gt;+'P'&lt;/code&gt; ， &lt;code&gt;+'E'&lt;/code&gt; 和 &lt;code&gt;+'S'&lt;/code&gt; ，不同之处在于不必包括单引号来保护它们免受shell攻击。</target>
        </trans-unit>
        <trans-unit id="e0366a9ebac5c17541c6d26640b461361c80a4a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt; are used to log on to the remote host &lt;code&gt;Host&lt;/code&gt;. &lt;code&gt;Username&lt;/code&gt;, if omitted, defaults to the current username. &lt;code&gt;Password&lt;/code&gt; is empty by default.</source>
          <target state="translated">选项 &lt;code&gt;Username&lt;/code&gt; 和 &lt;code&gt;Password&lt;/code&gt; 用于登录远程主机 &lt;code&gt;Host&lt;/code&gt; 。 &lt;code&gt;Username&lt;/code&gt; ，如果省略，则默认为当前用户名。 &lt;code&gt;Password&lt;/code&gt; 默认为空。</target>
        </trans-unit>
        <trans-unit id="9dcd58b0792b2c9e9c3b6819e8f16b982914d604" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt; are common for all I/O servers in OTP, while &lt;code&gt;echo&lt;/code&gt; and &lt;code&gt;expand&lt;/code&gt; are valid only for this I/O server. Option &lt;code&gt;unicode&lt;/code&gt; notifies how characters are put on the physical I/O device, that is, if the terminal itself is Unicode-aware. It does not affect how characters are sent in the I/O protocol, where each request contains encoding information for the provided or returned data.</source>
          <target state="translated">选项 &lt;code&gt;binary&lt;/code&gt; 和 &lt;code&gt;encoding&lt;/code&gt; 对于OTP中的所有I / O服务器都是通用的，而 &lt;code&gt;echo&lt;/code&gt; 和 &lt;code&gt;expand&lt;/code&gt; 仅对该I / O服务器有效。选项 &lt;code&gt;unicode&lt;/code&gt; 通知如何在物理I / O设备上放置字符，即终端本身是否支持Unicode。它不影响字符在I / O协议中的发送方式，其中每个请求均包含所提供或返回的数据的编码信息。</target>
        </trans-unit>
        <trans-unit id="8ff02c5f14ce17a7d5799eee0ac8c1ea2bf12c76" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; apply not only to the QLC itself but also to the results of looking up constants, running match specifications, and joining handles.</source>
          <target state="translated">选项 &lt;code&gt;cache&lt;/code&gt; 和 &lt;code&gt;unique&lt;/code&gt; 不仅适用于QLC本身，而且还适用于查找常量，运行匹配规范和联接句柄的结果。</target>
        </trans-unit>
        <trans-unit id="9580f262070eeecb51ff008fdc6585d927dbc1f8" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;{scope, part()}&lt;/code&gt; work as for &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;. The return type is always a &lt;code&gt;binary()&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;global&lt;/code&gt; 和 &lt;code&gt;{scope, part()}&lt;/code&gt; 作用与 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 相同。返回类型始终是 &lt;code&gt;binary()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51c09aef080d57e48a07185acafc8ce6ebec94f6" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;message_cb&lt;/code&gt; and &lt;code&gt;sender&lt;/code&gt; have semantics identical to those documented in &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt;, but with the message argument to a &lt;code&gt;recv&lt;/code&gt; callback being as directed by the &lt;code&gt;packet&lt;/code&gt; option.</source>
          <target state="translated">选项 &lt;code&gt;message_cb&lt;/code&gt; 和 &lt;code&gt;sender&lt;/code&gt; 的语义与 &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 记录的语义相同，但是 &lt;code&gt;recv&lt;/code&gt; 回调的message参数由 &lt;code&gt;packet&lt;/code&gt; 选项指示。</target>
        </trans-unit>
        <trans-unit id="e61d32b3cca20de20d192710649075d0fa3c950e" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and are not valid for a listening transport.</source>
          <target state="translated">选项 &lt;code&gt;raddr&lt;/code&gt; 和 &lt;code&gt;rport&lt;/code&gt; 指定用于连接传输的远程地址和端口，对于侦听传输无效。</target>
        </trans-unit>
        <trans-unit id="d9f19d6b068a72ffa150ad3783e561ce5a572f10" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and not valid for a listening transport: the former is required while latter defaults to 3868 if unspecified. Multiple &lt;code&gt;raddr&lt;/code&gt; options can be specified, in which case the connecting transport in question attempts each in sequence until an association is established.</source>
          <target state="translated">选项 &lt;code&gt;raddr&lt;/code&gt; 和 &lt;code&gt;rport&lt;/code&gt; 指定用于连接传输的远程地址和端口，并且对于侦听传输无效：前者是必需的，而后者如果未指定，则默认为3868。可以指定多个 &lt;code&gt;raddr&lt;/code&gt; 选项，在这种情况下，所讨论的连接传输会依次尝试每个，直到建立关联为止。</target>
        </trans-unit>
        <trans-unit id="ffb596bacd291beb9c0f85faa25b79b4527311a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; can be combined to match a sequence multiple times.</source>
          <target state="translated">选项 &lt;code&gt;repeat&lt;/code&gt; 和 &lt;code&gt;sequence&lt;/code&gt; 可以组合以多次匹配序列。</target>
        </trans-unit>
        <trans-unit id="e81a184b61cbd5436906125ea2fd1369abbf5985" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the scanner. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">选项允许自定义扫描仪的行为。另请参阅有关自定义功能的 &lt;code&gt;tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1df937b910b748dfde76ee563a39943f8c8982a" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the validation.</source>
          <target state="translated">选项允许自定义验证的行为。</target>
        </trans-unit>
        <trans-unit id="2d2339a2a5eabae774a416fb2e29a52c85a83319" translate="yes" xml:space="preserve">
          <source>Options allows to customize the behaviour of the XPath scanner.</source>
          <target state="translated">选项允许自定义XPath扫描器的行为。</target>
        </trans-unit>
        <trans-unit id="5ffa2c48bad8b2b21cb7fd3c0cdc61a21bc9b14c" translate="yes" xml:space="preserve">
          <source>Options are processed in the order they occur in the list, that is, later options have higher precedence.</source>
          <target state="translated">选项按其在列表中出现的顺序进行处理,也就是说,后面的选项具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="5257320eb8c67ae70e398e048755a4a432e71e80" translate="yes" xml:space="preserve">
          <source>Options available to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending an outgoing Diameter request. Has one of the following types.</source>
          <target state="translated">发送传出的直径请求时，可以 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 选项。具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="43baa3cfdab8fbfb50fe057ed27dea4648766c66" translate="yes" xml:space="preserve">
          <source>Options can be set to make the release package include source code and the ERTS binary as well.</source>
          <target state="translated">可以设置选项,使发布包包括源代码和ERTS二进制。</target>
        </trans-unit>
        <trans-unit id="19f6806cc859d20b910b98cdb91856f7d205c282" translate="yes" xml:space="preserve">
          <source>Options defining a Diameter application. Has one of the following types.</source>
          <target state="translated">定义Diameter应用程序的选项。具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="85fa7bc47c34fb7d169b6cba28b8680c98650d6d" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; 的选项</target>
        </trans-unit>
        <trans-unit id="c747f7830167fa762f894dbecb9703a094daa7ee" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">对于选择 &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt; 。下面或通过超链接进一步说明了各个选项。</target>
        </trans-unit>
        <trans-unit id="7a1ffff775190d7efc280e2ad290e1f4ea5665b9" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt; 选项。下面或通过超链接进一步说明了各个选项。</target>
        </trans-unit>
        <trans-unit id="eb4d9d68b8a4bdc7b530015f01b070a24bbaaaae" translate="yes" xml:space="preserve">
          <source>Options for ROOT, Intermediate and Peer certs</source>
          <target state="translated">ROOT、中级和同行证书的选择。</target>
        </trans-unit>
        <trans-unit id="271cee05e17a96561b06a7392bd67ac3d4ab26c5" translate="yes" xml:space="preserve">
          <source>Options in the environment variable EUNIT are also included last in the option list, i.e., have lower precedence than those in &lt;code&gt;Options&lt;/code&gt;.</source>
          <target state="translated">环境变量EUNIT中的选项也包含在选项列表的最后，即，其优先级低于 &lt;code&gt;Options&lt;/code&gt; 中的优先级。</target>
        </trans-unit>
        <trans-unit id="2d595c0adb932691342148a1f5ccb473e844d862" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; when spawning a process for an incoming Diameter request. Options &lt;code&gt;monitor&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; are ignored.</source>
          <target state="translated">在为传入的Diameter请求生成进程时，将选项传递给 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; 。选项 &lt;code&gt;monitor&lt;/code&gt; 和 &lt;code&gt;link&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="fb6adb442fc6700a7d845b5b6f08d580352873cb" translate="yes" xml:space="preserve">
          <source>Options preceding &lt;code&gt;-erl_args&lt;/code&gt; that &lt;code&gt;Common Test&lt;/code&gt; does not recognize are also passed on to the emulator untouched. By &lt;code&gt;-erl_args&lt;/code&gt; the user can specify flags with the same name, but with different destinations, on the &lt;code&gt;ct_run&lt;/code&gt; command line.</source>
          <target state="translated">上述选项 &lt;code&gt;-erl_args&lt;/code&gt; 是 &lt;code&gt;Common Test&lt;/code&gt; 不承认也传递到模拟器不变。通过 &lt;code&gt;-erl_args&lt;/code&gt; ，用户可以在 &lt;code&gt;ct_run&lt;/code&gt; 命令行上指定具有相同名称但具有不同目标的标志。</target>
        </trans-unit>
        <trans-unit id="ff1becd31ec7dd72ea26d9a9fd1b56a0ae87b96b" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt; 提供的选项。</target>
        </trans-unit>
        <trans-unit id="be2f1fd15114f1dab339629da4d391e98859a026" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供给 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 的选项。</target>
        </trans-unit>
        <trans-unit id="34209f6f492a2966caf548e5cb61a33749ede09a" translate="yes" xml:space="preserve">
          <source>Options that can be given to the &lt;code&gt;cth_conn_log&lt;/code&gt; hook, which is used for logging of NETCONF and Telnet connections. See &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; for description and examples of how to use this hook.</source>
          <target state="translated">可以赋予 &lt;code&gt;cth_conn_log&lt;/code&gt; 挂钩的选项，该挂钩用于记录NETCONF和Telnet连接。有关如何使用此挂钩的描述和示例，请参见 &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="228dffd69b4e3c0e126c643a9f0b0e320c2b02c8" translate="yes" xml:space="preserve">
          <source>Options that can be used when starting a &lt;code&gt;gen_statem&lt;/code&gt; server through, for example, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过例如 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 启动 &lt;code&gt;gen_statem&lt;/code&gt; 服务器时可以使用的选项。</target>
        </trans-unit>
        <trans-unit id="d6e5101586b632aaf8a368594dc5123cd9322755" translate="yes" xml:space="preserve">
          <source>Options to configure a &lt;code&gt;ErlNifIOQueue&lt;/code&gt;.</source>
          <target state="translated">配置 &lt;code&gt;ErlNifIOQueue&lt;/code&gt; 的选项。</target>
        </trans-unit>
        <trans-unit id="23d20f728be4aacef3be89090ba5883ef7e28da2" translate="yes" xml:space="preserve">
          <source>Options used for setting up an SSH connection to a NETCONF server.</source>
          <target state="translated">用于设置与NETCONF服务器的SSH连接的选项。</target>
        </trans-unit>
        <trans-unit id="910207f354e542f3e522ad9da85b70501659257e" translate="yes" xml:space="preserve">
          <source>Options used to customize the behaviour of the parser. Possible options are:</source>
          <target state="translated">用于自定义解析器行为的选项。可能的选项有:</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="6d118f8e941d56db78406a33fb3a53aed05d43fb" translate="yes" xml:space="preserve">
          <source>Options: see &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt;. Note however that for &lt;code&gt;quick_parse_file/2&lt;/code&gt;, the option &lt;code&gt;no_fail&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">选项：请参阅 &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt; 。但是请注意，对于 &lt;code&gt;quick_parse_file/2&lt;/code&gt; ，默认情况下，选项 &lt;code&gt;no_fail&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b12501090de711d45f4f134407e2f3085fb7dedb" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt;],</source>
          <target state="translated">选项:: [ &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt; ]，</target>
        </trans-unit>
        <trans-unit id="9ef1aeb0b64bab0b8696b0aebb6c7bffc58deff9" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt;]) -&amp;gt;</source>
          <target state="translated">选项:: [ &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt; ]）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ddc3f14766efb56c4d34a9542fe728065e02b6b" translate="yes" xml:space="preserve">
          <source>Or - if building a 64bit version:</source>
          <target state="translated">或者--如果构建一个64位版本。</target>
        </trans-unit>
        <trans-unit id="5326c62b422be5d15a751d74a2dc4fcf60deb938" translate="yes" xml:space="preserve">
          <source>Or calls the following if the process is to terminate:</source>
          <target state="translated">或者在进程要终止的情况下调用下面的函数。</target>
        </trans-unit>
        <trans-unit id="ba69cd0427a638368d97eab4ad9466aab5343d29" translate="yes" xml:space="preserve">
          <source>Or perhaps in combination with constants:</source>
          <target state="translated">也可能与常量结合。</target>
        </trans-unit>
        <trans-unit id="01433e00bc9b318bce7a3cc505bdb311b1e7b75c" translate="yes" xml:space="preserve">
          <source>Or resulting in the next clause being tested in function heads and case expressions.</source>
          <target state="translated">或者导致下一个子句被函数头和case表达式测试。</target>
        </trans-unit>
        <trans-unit id="0045ed6a97a1146a04c393e163018af002e6d4f9" translate="yes" xml:space="preserve">
          <source>Or what happens if the server goes down in the middle of sending a message, leaving the sending client hanging forever in the &lt;code&gt;await_result&lt;/code&gt; function?</source>
          <target state="translated">或者，如果服务器在发送消息的过程中发生故障，导致发送客户端永远挂在 &lt;code&gt;await_result&lt;/code&gt; 函数中，会发生什么情况？</target>
        </trans-unit>
        <trans-unit id="66e4dcf09aeb43d320a42f1b4be9f68e9c1bc539" translate="yes" xml:space="preserve">
          <source>Oracle Java SE JDK -- The Java Development Kit (Standard Edition). Required for building the application &lt;code&gt;jinterface&lt;/code&gt;. At least version 1.6.0 of the JDK is required.</source>
          <target state="translated">Oracle Java SE JDK-Java开发工具包（标准版）。构建应用程序 &lt;code&gt;jinterface&lt;/code&gt; 必需。至少需要JDK 1.6.0版。</target>
        </trans-unit>
        <trans-unit id="d2f0ae466f7c5d340f95e5db43c368a9a3b0bc8a" translate="yes" xml:space="preserve">
          <source>Orders &lt;code&gt;Common Test&lt;/code&gt; to repeat execution of the cases in the group a given number of times, or until any, or all, cases fail or succeed.</source>
          <target state="translated">命令&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 将给定次数重复执行组中的案例，或者直到任何或所有案例失败或成功为止。</target>
        </trans-unit>
        <trans-unit id="5112607d3f38b5535b071c81b4e3ced527521a31" translate="yes" xml:space="preserve">
          <source>Orders a generic server to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">命令通用服务器以指定的 &lt;code&gt;Reason&lt;/code&gt; 退出并等待其终止。的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 飞去。</target>
        </trans-unit>
        <trans-unit id="54d7ea1c4f89a8a332559591ee4debf050cee229" translate="yes" xml:space="preserve">
          <source>Orders event manager &lt;code&gt;EventMgrRef&lt;/code&gt; to exit with the specifies &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. Before terminating, &lt;code&gt;gen_event&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; for each installed event handler.</source>
          <target state="translated">命令事件管理器 &lt;code&gt;EventMgrRef&lt;/code&gt; 以指定的 &lt;code&gt;Reason&lt;/code&gt; 退出并等待其终止。在终止之前， &lt;code&gt;gen_event&lt;/code&gt; 为每个已安装的事件处理程序调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3f48e6002fbd3799add791dc0a450399f2f90c2" translate="yes" xml:space="preserve">
          <source>Orders the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">命令 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 以指定的 &lt;code&gt;Reason&lt;/code&gt; 退出并等待其终止。所述 &lt;code&gt;gen_statem&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 飞去。</target>
        </trans-unit>
        <trans-unit id="21b34b1ca6772cefd2286c0a8bd7c2c47fffae8f" translate="yes" xml:space="preserve">
          <source>Orders the process to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate.</source>
          <target state="translated">命令进程以指定的 &lt;code&gt;Reason&lt;/code&gt; 退出并等待其终止。</target>
        </trans-unit>
        <trans-unit id="a61c180dee133a0d4fb6e99797fd60387a9fa2b3" translate="yes" xml:space="preserve">
          <source>Orders the process to terminate with the specified &lt;code&gt;Reason&lt;/code&gt;. The termination is done asynchronously, so it is not guaranteed that the process is terminated when the function returns.</source>
          <target state="translated">命令进程以指定的 &lt;code&gt;Reason&lt;/code&gt; 终止。终止是异步完成的，因此不能保证函数返回时终止该过程。</target>
        </trans-unit>
        <trans-unit id="ccb8dd4b62075b726550209fcb7d0f2adb744793" translate="yes" xml:space="preserve">
          <source>Ordinary characters that must match the next input character.</source>
          <target state="translated">普通字符,必须与下一个输入字符相匹配。</target>
        </trans-unit>
        <trans-unit id="e33058c8aca144db86ea897b7f2317a8d1c1af9d" translate="yes" xml:space="preserve">
          <source>Origin-Host AVP</source>
          <target state="translated">Origin-Host AVP</target>
        </trans-unit>
        <trans-unit id="66ca57643d2d91ab73b0b3763337e2fec53749fc" translate="yes" xml:space="preserve">
          <source>Origin-Realm AVP</source>
          <target state="translated">Origin Realm AVP</target>
        </trans-unit>
        <trans-unit id="236ee85d9ea34d47b8bad24ef64b77e613147f6c" translate="yes" xml:space="preserve">
          <source>Origin-State-Id AVP</source>
          <target state="translated">原产地-国家-ID AVP</target>
        </trans-unit>
        <trans-unit id="8a2b322ac24d0d94010349833607bcb6c362fc2e" translate="yes" xml:space="preserve">
          <source>Origin-State-Id is optional but, if configured, will be included in outgoing CER/CEA and DWR/DWA messages. Setting a value of &lt;code&gt;0&lt;/code&gt; (zero) is equivalent to not setting a value, as documented in RFC 6733. The function &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; can be used as to retrieve a value that is computed when the diameter application is started.</source>
          <target state="translated">Origin-State-Id是可选的，但如果配置，它将包含在传出CER / CEA和DWR / DWA消息中。如RFC 6733中所述，将值设置为 &lt;code&gt;0&lt;/code&gt; （零）等效于不设置值。函数 &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; 可用于检索在直径应用程序启动时计算出的值。</target>
        </trans-unit>
        <trans-unit id="e2f0776017330240cb474fc09a019aea6a403d19" translate="yes" xml:space="preserve">
          <source>Originating a Request</source>
          <target state="translated">发起请求</target>
        </trans-unit>
        <trans-unit id="c10643b85fbfbd4fbb63e61c52588993e2ffbfa5" translate="yes" xml:space="preserve">
          <source>Oriya</source>
          <target state="translated">Oriya</target>
        </trans-unit>
        <trans-unit id="42cb2600c161bf7bf85310fb50b63266488059bf" translate="yes" xml:space="preserve">
          <source>Osmanya</source>
          <target state="translated">Osmanya</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="e5f5f875b3d15fa11fe3de5896a4e66d7c090218" translate="yes" xml:space="preserve">
          <source>Other (rare) error condition, such as &lt;code&gt;{error, estale}&lt;/code&gt; if reading from an NFS file system.</source>
          <target state="translated">其他（罕见）错误条件，例如 &lt;code&gt;{error, estale}&lt;/code&gt; 如果从NFS文件系统读取，则为{error，estale}。</target>
        </trans-unit>
        <trans-unit id="03965c1e12674420b58d4f32742d1467e2298c0b" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types and values can differ much from these figures. It is therefore important that you, in every case where you intend to use either of these decodes, perform some tests that show if you will benefit your purpose.</source>
          <target state="translated">其他ASN.1类型和数值可能与这些数字相差很大。因此,重要的是,在你打算使用这些解码器的每一种情况下,你都要进行一些测试,以表明你是否会对你的目的有利。</target>
        </trans-unit>
        <trans-unit id="c1385ef92fd62e1027c2fed35303a7d7f5d9ee0f" translate="yes" xml:space="preserve">
          <source>Other Flags</source>
          <target state="translated">其他旗帜</target>
        </trans-unit>
        <trans-unit id="db5a9e63db2cdafd4d9a58a4d1e203908f440948" translate="yes" xml:space="preserve">
          <source>Other PCRE-specific options can be set by the application when the compiling or matching functions are called. Sometimes the pattern can contain special leading sequences, such as (*CRLF), to override what the application has set or what has been defaulted. Details are provided in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">当调用编译或匹配功能时，应用程序可以设置其他特定于PCRE的选项。有时，模式可以包含特殊的前导序列，例如（* CRLF），以覆盖应用程序已设置的内容或默认值。在前面的 &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; 部分中提供了详细信息。</target>
        </trans-unit>
        <trans-unit id="d244aac16bfbb22cf74ea0c33f98a68a4cf6d192" translate="yes" xml:space="preserve">
          <source>Other Tools</source>
          <target state="translated">其他工具</target>
        </trans-unit>
        <trans-unit id="302303d7df48684e7df86411d56b9659af7d97fb" translate="yes" xml:space="preserve">
          <source>Other Unicode encodings than integers representing code points or UTF-8 in binaries are referred to as &quot;external encodings&quot;. The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding.</source>
          <target state="translated">除了代表码点的整数或二进制中的UTF-8之外的其他Unicode编码被称为 &quot;外部编码&quot;。ISO Latin-1编码在二进制文件和列表中被称为latin1-encoding。</target>
        </trans-unit>
        <trans-unit id="ed0cea3720246c22c3a30bbc4492b0bc7ca1703c" translate="yes" xml:space="preserve">
          <source>Other addresses are possible, for example Linux implements &quot;Abstract Addresses&quot;. See the documentation for Unix Domain Sockets on your system, normally &lt;code&gt;unix&lt;/code&gt; in manual section 7.</source>
          <target state="translated">其他地址也是可能的，例如Linux实现&amp;ldquo;抽象地址&amp;rdquo;。请参见系统部分中有关Unix域套接字的文档，通常是 &lt;code&gt;unix&lt;/code&gt; ，请参见手册第7节。</target>
        </trans-unit>
        <trans-unit id="dd29435e6c5d5cb295da7f257e1e953a855af66c" translate="yes" xml:space="preserve">
          <source>Other applications like ssl/tls or https might have options that are passed down to the &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt;. You will probably not have to call it directly</source>
          <target state="translated">其他应用程序（例如ssl / tls或https）可能具有向下传递到 &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt; 的选项。您可能不必直接调用它</target>
        </trans-unit>
        <trans-unit id="88b1b43caa29bc1ae4d1876c05734a9c8181e624" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only filenames that have exactly the same character in the same position match. Matching is case-sensitive, for example, &quot;a&quot; does not match &quot;A&quot;.</source>
          <target state="translated">其他字符代表自己。只有在相同位置有完全相同字符的文件名才会匹配。匹配是区分大小写的,例如,&quot;a &quot;不匹配 &quot;A&quot;。</target>
        </trans-unit>
        <trans-unit id="14464638b9e33ce4c0d8ac32a7485fa9028da73b" translate="yes" xml:space="preserve">
          <source>Other combinations, such as &lt;code&gt;{Module,'_',Arity}&lt;/code&gt;, are not allowed. Local functions match wildcards only if option &lt;code&gt;local&lt;/code&gt; is in &lt;code&gt;FlagList&lt;/code&gt;.</source>
          <target state="translated">不允许使用其他组合，例如 &lt;code&gt;{Module,'_',Arity}&lt;/code&gt; 。仅当选项 &lt;code&gt;local&lt;/code&gt; 在 &lt;code&gt;FlagList&lt;/code&gt; 中时,本地函数才与通配符匹配。</target>
        </trans-unit>
        <trans-unit id="885f57e5d13595e0ee4f423a6b4d92f55b55a565" translate="yes" xml:space="preserve">
          <source>Other configuration parameters exist, to be used for customizing the overload protection behaviour. The same parameters are used both in the standard handler and the disk_log handler, and are documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存在其他配置参数，这些参数可用于自定义过载保护行为。在标准处理程序和disk_log处理程序中使用相同的参数，并在《 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd2063ac325b87a9381eab00b4e9d208668c9217" translate="yes" xml:space="preserve">
          <source>Other constants (terms and bound variables), all regarded as false</source>
          <target state="translated">其他常数(项和约束变量),均视为假数。</target>
        </trans-unit>
        <trans-unit id="c3ac4deb2089a1f649e5fdba0cc491bef7b16555" translate="yes" xml:space="preserve">
          <source>Other directories in the development environment may be needed. If source code from languages other than Erlang is used, for instance C-code for NIFs, that code should be placed in a separate directory. By convention it is recommended to prefix such directories with the language name, for example &lt;code&gt;c_src&lt;/code&gt; for C, &lt;code&gt;java_src&lt;/code&gt; for Java or &lt;code&gt;go_src&lt;/code&gt; for Go. Directories with &lt;code&gt;_src&lt;/code&gt; suffix indicates that it is a part of the application and the compilation step. The final build artifacts should target the &lt;code&gt;priv/lib&lt;/code&gt; or &lt;code&gt;priv/bin&lt;/code&gt; directories.</source>
          <target state="translated">开发环境中可能需要其他目录。如果使用来自Erlang之外的语言的源代码，例如NIF的C代码，则应将该代码放在单独的目录中。按照惯例，建议在此类目录前添加语言名称，例如 &lt;code&gt;c_src&lt;/code&gt; (对于C）， &lt;code&gt;java_src&lt;/code&gt; (对于Java）或 &lt;code&gt;go_src&lt;/code&gt; (对于Go）。带有 &lt;code&gt;_src&lt;/code&gt; 后缀的目录表示它是应用程序和编译步骤的一部分。最终的构建工件应针对 &lt;code&gt;priv/lib&lt;/code&gt; 或 &lt;code&gt;priv/bin&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="ae9077b452914a72240410cfd78d06125441adc8" translate="yes" xml:space="preserve">
          <source>Other errors than these can occur, as the &lt;code&gt;erlang:halt/1&lt;/code&gt; BIF can generate any message. If the message is not generated by the BIF and does not occur in the list above, it can be because of an error in the emulator. There can however be unusual messages, not mentioned here, which are still connected to an application failure. There is much more information available, so a thorough reading of the crash dump can reveal the crash reason. The size of processes, the number of ETS tables, and the Erlang data on each process stack can be useful to find the problem.</source>
          <target state="translated">可能会发生其他错误，因为 &lt;code&gt;erlang:halt/1&lt;/code&gt; BIF可以生成任何消息。如果该消息不是由BIF生成的，并且没有出现在上面的列表中，则可能是由于模拟器中的错误所致。但是，可能存在此处未提及的异常消息，这些消息仍与应用程序故障有关。有更多可用信息，因此全面阅读故障转储可以揭示崩溃原因。进程的大小，ETS表的数量以及每个进程堆栈上的Erlang数据对于发现问题很有用。</target>
        </trans-unit>
        <trans-unit id="b60efd3d69d9ecb24af68e74d348360a07b5ed6b" translate="yes" xml:space="preserve">
          <source>Other features:</source>
          <target state="translated">其他特点:</target>
        </trans-unit>
        <trans-unit id="a58b6dc215a18ea443d12708103eda9efd5d5635" translate="yes" xml:space="preserve">
          <source>Other fields are rarely used. For complete information, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">其他字段很少使用。有关完整信息，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbd6de3d10f2fc66f49e8c1b345f9c0059ed9ba5" translate="yes" xml:space="preserve">
          <source>Other functions that create sets are &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt;. Special cases of &lt;code&gt;from_term/2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">创建集合的其他函数是 &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;from_term/2&lt;/code&gt; 的特殊情况是 &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8b80772e0f8b1d872444ba18ad7b48f4cc4cfe" translate="yes" xml:space="preserve">
          <source>Other letter</source>
          <target state="translated">其他信件</target>
        </trans-unit>
        <trans-unit id="1e25df6c3ebdcf4ee11a121bc16f17e603a8b7df" translate="yes" xml:space="preserve">
          <source>Other match specs activates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt; accordingly with &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt;.</source>
          <target state="translated">其他匹配规范会相应地使用 &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt; 激活对 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 的调用的跟踪。</target>
        </trans-unit>
        <trans-unit id="51ca0c2d75fe6310043838d9fb791594049c226f" translate="yes" xml:space="preserve">
          <source>Other modules can provide a nullary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;gb_table:table/1&lt;/code&gt; in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">其他模块可以提供无效的 &lt;code&gt;TraverseFun&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 节中的 &lt;code&gt;gb_table:table/1&lt;/code&gt; 是一个示例。</target>
        </trans-unit>
        <trans-unit id="3022c490a2bd62676beabc0c1b504084140a7de5" translate="yes" xml:space="preserve">
          <source>Other number</source>
          <target state="translated">其他号码</target>
        </trans-unit>
        <trans-unit id="97bd01729246532af9de85d0c3ab1ddb360d5a4e" translate="yes" xml:space="preserve">
          <source>Other options are:</source>
          <target state="translated">其他选择有:</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">其他选择:</target>
        </trans-unit>
        <trans-unit id="997739492917d646490ffd1fec1419fa6e98b907" translate="yes" xml:space="preserve">
          <source>Other priorities than &lt;code&gt;normal&lt;/code&gt; are normally not needed. When other priorities are used, use them with care, &lt;strong&gt;especially&lt;/strong&gt; priority &lt;code&gt;high&lt;/code&gt;. A process on priority &lt;code&gt;high&lt;/code&gt; is only to perform work for short periods. Busy looping for long periods in a &lt;code&gt;high&lt;/code&gt; priority process causes most likely problems, as important OTP servers run on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">比其他优先事项 &lt;code&gt;normal&lt;/code&gt; ，通常并不需要。当使用其他优先级时，请谨慎使用，&lt;strong&gt;尤其是&lt;/strong&gt;优先级 &lt;code&gt;high&lt;/code&gt; 。 &lt;code&gt;high&lt;/code&gt; 优先级的过程仅是短期执行工作。 &lt;code&gt;high&lt;/code&gt; 优先级进程中的长时间繁忙循环会导致最可能的问题，因为重要的OTP服务器按 &lt;code&gt;normal&lt;/code&gt; 优先级运行。</target>
        </trans-unit>
        <trans-unit id="8dea56314c50bfb058a315994e322b37ac05f071" translate="yes" xml:space="preserve">
          <source>Other processes can read the digraph (default).</source>
          <target state="translated">其他进程可以读取数字图谱(默认)。</target>
        </trans-unit>
        <trans-unit id="20bc18ec4477d52890b4d5aac0d2cbc92eb389a4" translate="yes" xml:space="preserve">
          <source>Other punctuation</source>
          <target state="translated">其他标点符号</target>
        </trans-unit>
        <trans-unit id="ec9bcce7656bc224a64ce97ba2b5bd792aeb6391" translate="yes" xml:space="preserve">
          <source>Other requirements:</source>
          <target state="translated">其他要求:</target>
        </trans-unit>
        <trans-unit id="e28544fd56893780941b6044efc20d476e8af135" translate="yes" xml:space="preserve">
          <source>Other states do not normally occur in the output from &lt;code&gt;connect/*&lt;/code&gt;. Rather, they can occur in &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; events received instead of data in &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; calls. All of them indicate losing the association because of various error conditions, and are listed here for the sake of completeness:</source>
          <target state="translated">其他状态通常不会出现在 &lt;code&gt;connect/*&lt;/code&gt; 的输出中。相反，它们可能发生在收到的 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 事件中，而不是在 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 调用中的数据中发生。所有这些都表明由于各种错误情况而失去了关联，这里出于完整性的目的列出了它们：</target>
        </trans-unit>
        <trans-unit id="d0a8ec65432412d24f9c042216a5db6173548a99" translate="yes" xml:space="preserve">
          <source>Other symbol</source>
          <target state="translated">其他符号</target>
        </trans-unit>
        <trans-unit id="577365eaf2b9f85de95baced848e1cc288b22cd3" translate="yes" xml:space="preserve">
          <source>Other table access than reading, such as calling &lt;code&gt;InfoFun&lt;/code&gt;, is assumed to be OK at any time.</source>
          <target state="translated">假定在任何时候都可以进行除读取之外的其他表访问，例如调用 &lt;code&gt;InfoFun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24654f0b470cc0982d088fd0b8978733097cbe87" translate="yes" xml:space="preserve">
          <source>Other tuples than the ones defined are ignored.</source>
          <target state="translated">除了定义的元组之外的其他元组将被忽略。</target>
        </trans-unit>
        <trans-unit id="15363bfb92322f3fe6ad2718148dd35e33fdb154" translate="yes" xml:space="preserve">
          <source>Other types can be read, and are returned as binaries.</source>
          <target state="translated">其他类型也可以读取,并作为二进制文件返回。</target>
        </trans-unit>
        <trans-unit id="cdedf43490cc2ff1da81cd679f5229c3c1cc0879" translate="yes" xml:space="preserve">
          <source>Other types cannot be added or changed.</source>
          <target state="translated">其他类型不能添加或更改。</target>
        </trans-unit>
        <trans-unit id="70e28792612da22154d851b53e24c945311f74a0" translate="yes" xml:space="preserve">
          <source>Other useful function(s) for debugging the agent are:</source>
          <target state="translated">其他有用的调试代理功能有:</target>
        </trans-unit>
        <trans-unit id="2ebc4c4dd4036621515140929b889184c451a256" translate="yes" xml:space="preserve">
          <source>Other useful information can be found at our GitHub wiki:</source>
          <target state="translated">其他有用的信息可以在我们的 GitHub wiki 上找到。</target>
        </trans-unit>
        <trans-unit id="198dd873fca5b5131fb3a9224056b4006b7b1428" translate="yes" xml:space="preserve">
          <source>Otherwise all options valid for function &lt;code&gt;compile/2&lt;/code&gt; are also allowed. Options allowed both for compilation and execution of a match, namely &lt;code&gt;anchored&lt;/code&gt; and &lt;code&gt;{newline, NLSpec}&lt;/code&gt;, affect both the compilation and execution if present together with a non-precompiled regular expression.</source>
          <target state="translated">否则，也允许所有对函数 &lt;code&gt;compile/2&lt;/code&gt; 有效的选项。选项允许既用于汇编和匹配，即执行 &lt;code&gt;anchored&lt;/code&gt; 和 &lt;code&gt;{newline, NLSpec}&lt;/code&gt; ，同时影响编译和执行，如果与非预编译的正则表达式一起存在。</target>
        </trans-unit>
        <trans-unit id="e30cc24dff4a8e4fd3505b91e8729e2519c09a8a" translate="yes" xml:space="preserve">
          <source>Otherwise an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">否则会引发 &lt;code&gt;undef&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="75ef1eb055dcb5b6ca421038e624721c946bf1b2" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">否则，将重新创建导出的种子并返回状态。另请参阅 &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b75f15a942afae834871232ccf0ba77e7558f01c" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed in the process dictionary, and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">否则，将在流程字典中重新创建导出的种子，并返回状态。另请参阅 &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d87b5659173c759cef0ab46aa4a7fb80d00cb3c5" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;gen_statem&lt;/code&gt; goes into &lt;code&gt;receive&lt;/code&gt; or hibernation (if &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) to wait for the next message. In hibernation the next non-system event awakens the &lt;code&gt;gen_statem&lt;/code&gt;, or rather the next incoming message awakens the &lt;code&gt;gen_statem&lt;/code&gt;, but if it is a system event it goes right back into hibernation. When a new message arrives the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; is called with the corresponding event, and we start again from the top of this sequence.</source>
          <target state="translated">否则， &lt;code&gt;gen_statem&lt;/code&gt; 进入 &lt;code&gt;receive&lt;/code&gt; 或休眠状态（如果 &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ）以等待下一条消息。在休眠状态下，下一个非系统事件将唤醒 &lt;code&gt;gen_statem&lt;/code&gt; ，或者下一个传入消息将唤醒 &lt;code&gt;gen_statem&lt;/code&gt; ，但是如果它是系统事件，它将立即回到休眠状态。当收到新消息时，将使用相应的事件调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，然后从该序列的顶部重新开始。</target>
        </trans-unit>
        <trans-unit id="ca5bba34991dc2c836a13ba5d708caac9b079155" translate="yes" xml:space="preserve">
          <source>Otherwise the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; and &lt;code&gt;Actions = []&lt;/code&gt;.</source>
          <target state="translated">否则，与 &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 相同，其中 &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; 和 &lt;code&gt;Actions = []&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a3e409482e92d7312335dbbdf06b6be17b9baa1" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;Name&lt;/code&gt; is to be a filename.</source>
          <target state="translated">否则， &lt;code&gt;Name&lt;/code&gt; 将是文件名。</target>
        </trans-unit>
        <trans-unit id="00aeea6c12722cc94d58e2f90a9872f32740085b" translate="yes" xml:space="preserve">
          <source>Otherwise, end the cluster.</source>
          <target state="translated">否则,结束集群。</target>
        </trans-unit>
        <trans-unit id="721932d781d83d618f6a74c5ad3eea7a7cd92826" translate="yes" xml:space="preserve">
          <source>Otherwise, if function &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; is exported, it is called as &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt;Function, Args).</source>
          <target state="translated">否则，如果导出函数 &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; ，则称为 &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt; Function，Args）。</target>
        </trans-unit>
        <trans-unit id="bd45978f4d37112b76326ff6ee1522682525ecd5" translate="yes" xml:space="preserve">
          <source>Otherwise, if the calling process is trapping exits, and/or &lt;code&gt;PidOrPort&lt;/code&gt; is remote, &lt;code&gt;link/1&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but an exit signal with reason &lt;code&gt;noproc&lt;/code&gt; is sent to the calling process.</source>
          <target state="translated">否则，如果调用进程正在捕获退出，并且/或者 &lt;code&gt;PidOrPort&lt;/code&gt; 是远程的，则 &lt;code&gt;link/1&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，但是 &lt;code&gt;noproc&lt;/code&gt; 为原因的退出信号发送到调用进程。</target>
        </trans-unit>
        <trans-unit id="da43d3db522f1f4c7c74271266d895bb136efa89" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns, if possible, the value of &lt;code&gt;apply(Fun, Args)&lt;/code&gt; after an attempt is made to autoload &lt;code&gt;Module&lt;/code&gt;. If this is not possible, the call fails with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">否则，在尝试自动加载 &lt;code&gt;Module&lt;/code&gt; 后，如果可能，它将返回 &lt;code&gt;apply(Fun, Args)&lt;/code&gt; 的值。如果这不可能，则调用失败，退出原因为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cacbdaf48917ea52fc8e545a2f82b0aa7f975a90" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_server&lt;/code&gt; process terminates immediately.</source>
          <target state="translated">否则， &lt;code&gt;gen_server&lt;/code&gt; 进程将立即终止。</target>
        </trans-unit>
        <trans-unit id="94d92e282ea81d3ea91c85388ba278cc5356a549" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_statem&lt;/code&gt; is immediately terminated.</source>
          <target state="translated">否则， &lt;code&gt;gen_statem&lt;/code&gt; 立即终止。</target>
        </trans-unit>
        <trans-unit id="4310db4b8648fe0dc2ce19712dff695071b2d572" translate="yes" xml:space="preserve">
          <source>Otherwise, this option (&lt;code&gt;timeout&lt;/code&gt;) is used as the negotiation timeout only and there is no connection timeout set</source>
          <target state="translated">否则，此选项（ &lt;code&gt;timeout&lt;/code&gt; ）仅用作协商超时，并且未设置连接超时</target>
        </trans-unit>
        <trans-unit id="6fc1fe0597f841fdd158f43b025edbb7cffcfe68" translate="yes" xml:space="preserve">
          <source>Our driver data is also extended, we keep track of the socket used for communication with postgres, and also the port, which is needed when we send data to the port with &lt;code&gt;driver_output&lt;/code&gt;. We have a flag &lt;code&gt;connecting&lt;/code&gt; to tell whether the driver is waiting for a connection or waiting for the result of a query. (This is needed, as the entry &lt;code&gt;ready_io&lt;/code&gt; is called both when connecting and when there is a query result.)</source>
          <target state="translated">我们的驱动程序数据也得到了扩展，我们跟踪用于与postgres通信的套接字以及端口，这是我们通过 &lt;code&gt;driver_output&lt;/code&gt; 将数据发送到端口时所需的端口。我们有一个 &lt;code&gt;connecting&lt;/code&gt; 标志，告诉驱动程序是在等待连接还是在等待查询结果。（这是必需的，因为在连接时以及有查询结果时都会调用 &lt;code&gt;ready_io&lt;/code&gt; 条目。）</target>
        </trans-unit>
        <trans-unit id="6438f58ef6f89d7bd274993ab31926c276b0cdc6" translate="yes" xml:space="preserve">
          <source>Our new release, &quot;SECOND&quot;, is now the current release, but we can also see that our &quot;FIRST&quot; release is still permanent. This means that if the node would be restarted now, it would come up running the &quot;FIRST&quot; release again.</source>
          <target state="translated">我们的新版本 &quot;SECOND &quot;现在是当前版本,但我们也可以看到我们的 &quot;FIRST &quot;版本仍然是永久性的。这意味着,如果现在重新启动节点,它将再次运行 &quot;FIRST &quot;版本。</target>
        </trans-unit>
        <trans-unit id="867b0a717a764649cafbff4174c1ab32b19f1745" translate="yes" xml:space="preserve">
          <source>Outbound binary encoding in binaries</source>
          <target state="translated">二进制文件中的出站二进制编码</target>
        </trans-unit>
        <trans-unit id="59cc61305ef8bc0545ffbb32a894c83964c825a0" translate="yes" xml:space="preserve">
          <source>Outbound percent-encoding in lists and binaries</source>
          <target state="translated">列表和二进制文件中的出站百分比编码。</target>
        </trans-unit>
        <trans-unit id="f6e7d5a9598d3a265926a82b01d7b1deec941696" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). Segment messages are sent all at once (i.e. no acknowledgement awaited before sending the next segment).</source>
          <target state="translated">外发回复消息将根据需要进行细分（请参见下面的 &lt;code&gt;max_pdu_size&lt;/code&gt; ）。段消息一次全部发送（即在发送下一个段之前不等待确认）。</target>
        </trans-unit>
        <trans-unit id="db1552aa4fc51b4e7d46fa43321f568f6c953efb" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). This value, K, indicate the outstanding window, i.e. how many segments can be outstanding (not acknowledged) at any given time.</source>
          <target state="translated">外发回复消息将根据需要进行细分（请参见下面的 &lt;code&gt;max_pdu_size&lt;/code&gt; ）。该值K表示未完成的窗口，即，在任何给定时间可以有多少段未完成（未确认）。</target>
        </trans-unit>
        <trans-unit id="685ad21255174c3fd01ff63b9cc3a546c7bc9ee3" translate="yes" xml:space="preserve">
          <source>Output messages are sent without packet lengths. A user-defined protocol must be used between the Erlang process and the external object.</source>
          <target state="translated">输出消息的发送没有包长。Erlang进程和外部对象之间必须使用用户定义的协议。</target>
        </trans-unit>
        <trans-unit id="1940195f61826f0bf71c04e3e654bd8f616a6a5b" translate="yes" xml:space="preserve">
          <source>Outputs information from parsing the input file and generating the internal tables.</source>
          <target state="translated">输出解析输入文件和生成内部表格的信息。</target>
        </trans-unit>
        <trans-unit id="73c0f26b2a7bd194530650de5672dbbf0d19179d" translate="yes" xml:space="preserve">
          <source>Outputs the message &lt;code&gt;Text&lt;/code&gt; (which can be a plain string, an IO-list, or just an atom). The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">输出消息 &lt;code&gt;Text&lt;/code&gt; （可以是纯字符串，IO列表或仅是原子）。结果总是 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47cdda9f06afdf9eb8f93de49e9252c88f5dc624" translate="yes" xml:space="preserve">
          <source>Outside a character class, a backslash followed by a digit &amp;gt; 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.</source>
          <target state="translated">在字符类之外，反斜杠后跟一个数字&amp;gt; 0（可能还有其他数字）是对模式中更早（即在其左侧）捕获子模式的反向引用，前提是以前有很多捕获左括号的地方。</target>
        </trans-unit>
        <trans-unit id="cd6a3b6581f40f67d6587389bf34b0d7ce3534cd" translate="yes" xml:space="preserve">
          <source>Outside a character class, a dot in the pattern matches any character in the subject string except (by default) a character that signifies the end of a line.</source>
          <target state="translated">在字符类之外,图案中的点与主题字符串中的任何字符相匹配,但(默认情况下)表示行结束的字符除外。</target>
        </trans-unit>
        <trans-unit id="81930bbe14ad5ca39d3f1c5a979f1ece61d2de2e" translate="yes" xml:space="preserve">
          <source>Outside a character class, by default, the escape sequence \R matches any Unicode newline sequence. In non-UTF-8 mode, \R is equivalent to the following:</source>
          <target state="translated">在字符类之外,默认情况下,转义序列\R匹配任何Unicode换行序列。在非UTF-8模式下,\R等同于以下内容。</target>
        </trans-unit>
        <trans-unit id="85b61b9dbc2dcc77797a3d987698e978f37365fe" translate="yes" xml:space="preserve">
          <source>Outside a character class, in the default matching mode, the circumflex character is an assertion that is true only if the current matching point is at the start of the subject string. If argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, circumflex can never match if option &lt;code&gt;multiline&lt;/code&gt; is unset. Inside a character class, circumflex has an entirely different meaning (see below).</source>
          <target state="translated">在字符类之外，在默认的匹配模式下，抑扬符是仅在当前匹配点位于主题字符串的开头时才为真的断言。如果 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的参数 &lt;code&gt;startoffset&lt;/code&gt; 不为零，则未设置选项 &lt;code&gt;multiline&lt;/code&gt; 时，抑扬符将永远不会匹配。在角色类中，抑扬音符的含义完全不同（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="96066ed4fc24874155ae3f2d4ec23afe749bc90e" translate="yes" xml:space="preserve">
          <source>Outside a character class, the escape sequence \C matches any data unit, regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, \C always matches line-ending characters. The feature is provided in Perl to match individual bytes in UTF-8 mode, but it is unclear how it can usefully be used. As \C breaks up characters into individual data units, matching one unit with \C in a UTF mode means that the remaining string can start with a malformed UTF character. This has undefined results, as PCRE assumes that it deals with valid UTF strings.</source>
          <target state="translated">在字符类之外,转义序列\C与任何数据单位相匹配,无论是否设置了UTF模式。一个数据单位就是一个字节。与点号不同,\C总是匹配行尾字符。在Perl中提供了这个功能来匹配UTF-8模式下的单个字节,但不清楚如何有效地使用它。由于\C将字符分解成单个数据单元,在UTF模式下用\C匹配一个单元意味着剩余的字符串可能以一个畸形的UTF字符开始。这有一些未定义的结果,因为PCRE假设它处理的是有效的UTF字符串。</target>
        </trans-unit>
        <trans-unit id="d06e3f0473ed837ae5eabca58e86d752a67b3e6e" translate="yes" xml:space="preserve">
          <source>Over time, as the Framework has evolved from SNMPv1 , through SNMPv2, to SNMPv3 the definitions of each of these architectural components have become richer and more clearly defined, but the fundamental architecture has remained consistent.</source>
          <target state="translated">随着时间的推移,随着该框架从SNMPv1、SNMPv2到SNMPv3的发展,每个架构组件的定义变得更加丰富和清晰,但基本架构一直保持一致。</target>
        </trans-unit>
        <trans-unit id="cef9305d1dcaaa55a42c6722272e0c832cae51ee" translate="yes" xml:space="preserve">
          <source>Overload protection</source>
          <target state="translated">过载保护</target>
        </trans-unit>
        <trans-unit id="1024473923480d46de1a6ce534031a4fb8bf2fe9" translate="yes" xml:space="preserve">
          <source>Overload protection activated on one node does not affect other nodes, where the tracing continues as normal. &lt;code&gt;ttb:stop/0,1&lt;/code&gt; fetches data from all clients, including everything collected before the activation of overload protection.</source>
          <target state="translated">在一个节点上激活的过载保护不会影响其他节点，在该节点上，跟踪正常进行。 &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 从所有客户端获取数据，包括在激活过载保护之前收集的所有内容。</target>
        </trans-unit>
        <trans-unit id="9872bf40547ca2f3f14680ffa0287ececed0c74a" translate="yes" xml:space="preserve">
          <source>Override protocol version when sending a message by adding the item &lt;code&gt;{protocol_version, integer()}&lt;/code&gt; to the Options. See &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过在选项中添加 &lt;code&gt;{protocol_version, integer()}&lt;/code&gt; 项目来发送消息时覆盖协议版本。参见 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07d3d194fae83d351901e71d428409c25c0a3d51" translate="yes" xml:space="preserve">
          <source>Override the default, which is to analyze BEAM files, and analyze starting from Erlang source code instead.</source>
          <target state="translated">覆盖默认值,即分析BEAM文件,而从Erlang源码开始分析。</target>
        </trans-unit>
        <trans-unit id="15565d57245d3503a665b06bb1ebc90f34652149" translate="yes" xml:space="preserve">
          <source>Overrides any value set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">覆盖由 &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt; 函数设置的任何值。</target>
        </trans-unit>
        <trans-unit id="e903860e59ffb2ebea40577767dba45a92e0e0e5" translate="yes" xml:space="preserve">
          <source>Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</source>
          <target state="translated">覆盖主题字符串中换行的默认定义,在Erlang中是LF(ASCII 10)。</target>
        </trans-unit>
        <trans-unit id="2178a71f4d4796adf7ebfc54ce9d2c304cda5e26" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_sctp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_sctp&lt;/code&gt; for IPv6.</source>
          <target state="translated">覆盖使用哪个回调模块。默认为 &lt;code&gt;inet_sctp&lt;/code&gt; IPv4和 &lt;code&gt;inet6_sctp&lt;/code&gt; 使用IPv6。</target>
        </trans-unit>
        <trans-unit id="9febcfe22539c2d72353741f4a91ee3eee5e5d0a" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_tcp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_tcp&lt;/code&gt; for IPv6.</source>
          <target state="translated">覆盖使用哪个回调模块。默认为 &lt;code&gt;inet_tcp&lt;/code&gt; IPv4和 &lt;code&gt;inet6_tcp&lt;/code&gt; 使用IPv6。</target>
        </trans-unit>
        <trans-unit id="fb4575b7495ce7d57228d043087de6f17605a208" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_udp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_udp&lt;/code&gt; for IPv6.</source>
          <target state="translated">覆盖使用哪个回调模块。默认为 &lt;code&gt;inet_udp&lt;/code&gt; IPv4和 &lt;code&gt;inet6_udp&lt;/code&gt; 使用IPv6。</target>
        </trans-unit>
        <trans-unit id="d263dc838fe87831b80976b412672c3d8e02db11" translate="yes" xml:space="preserve">
          <source>Owners can subscribe to &lt;strong&gt;notifications&lt;/strong&gt;, messages of the form &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt;, which are sent from the disk log process when certain events occur, see the functions and in particular the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt;. A log can have many owners, but a process cannot own a log more than once. However, the same process can open the log as a user more than once.</source>
          <target state="translated">所有者可以订阅&lt;strong&gt;通知&lt;/strong&gt;，消息形式为 &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt; ，这些 &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt; 是在发生某些事件时从磁盘日志进程发送的，请参见功能，尤其是 &lt;code&gt;open/1&lt;/code&gt; 选项notify。一个日志可以有许多所有者，但是一个进程不能拥有一个以上的日志。但是，相同的过程可以多次以用户身份打开日志。</target>
        </trans-unit>
        <trans-unit id="0bf7d16b62f8d7d4458289a41b07f8e9ce785647" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications are notified of an error with an &lt;code&gt;error_status&lt;/code&gt; message if the error reason tag is &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;.</source>
          <target state="translated">如果错误原因标记为 &lt;code&gt;invalid_header&lt;/code&gt; 或 &lt;code&gt;file_error&lt;/code&gt; ，则通过 &lt;code&gt;error_status&lt;/code&gt; 消息通知订阅通知的所有者。</target>
        </trans-unit>
        <trans-unit id="47ddeec7968a11b2b2f13154dd59f134a92d672e" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications normally receive a &lt;code&gt;wrap&lt;/code&gt; message, but if an error occurs with a reason tag of &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;, an &lt;code&gt;error_status&lt;/code&gt; message is sent.</source>
          <target state="translated">订阅通知的所有者通常会收到 &lt;code&gt;wrap&lt;/code&gt; 消息，但是如果发生错误，且原因标记为 &lt;code&gt;invalid_header&lt;/code&gt; 或 &lt;code&gt;file_error&lt;/code&gt; ，则会发送 &lt;code&gt;error_status&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="ea5a85a9a6040f17a47f7ba2c861df0d45af862d" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive a &lt;code&gt;truncate&lt;/code&gt; message.</source>
          <target state="translated">订阅通知的所有者收到 &lt;code&gt;truncate&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="69f83710cbb8ab650339dad71d8d01aeb1346e48" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the item cannot be written on the log, and possibly one of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, or &lt;code&gt;error_status&lt;/code&gt; if an item is written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">如果无法将项目写入日志，则订阅通知的所有者将收到消息 &lt;code&gt;read_only&lt;/code&gt; ， &lt;code&gt;blocked_log&lt;/code&gt; 或 &lt;code&gt;format_external&lt;/code&gt; ,如果将项目写入日志，则消息之一可能为 &lt;code&gt;wrap&lt;/code&gt; ， &lt;code&gt;full&lt;/code&gt; 或 &lt;code&gt;error_status&lt;/code&gt; 。如果标头功能有问题或发生文件错误，则会发送消息 &lt;code&gt;error_status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc53f78ca51a5c5588dc259bf4af7ddf544cabda" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the items cannot be written on the log, and possibly one or more of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;error_status&lt;/code&gt; if items are written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">如果无法将项目写入日志，则订阅通知的所有者将收到消息 &lt;code&gt;read_only&lt;/code&gt; ， &lt;code&gt;blocked_log&lt;/code&gt; 或 &lt;code&gt;format_external&lt;/code&gt; ,如果将项目写入日志，则可能会有一条或多条消息 &lt;code&gt;wrap&lt;/code&gt; ， &lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;error_status&lt;/code&gt; 。如果标头功能有问题或发生文件错误，则会发送消息 &lt;code&gt;error_status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36f780fdbda5b2b2ce85c9ebb57086d1880ae757" translate="yes" xml:space="preserve">
          <source>PC</source>
          <target state="translated">PC</target>
        </trans-unit>
        <trans-unit id="d561f41a3e664cc0a8835732d97f931d41f72800" translate="yes" xml:space="preserve">
          <source>PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where &quot;ch&quot; is a &quot;collating element&quot;, but these are not supported, and an error is given if they are encountered.</source>
          <target state="translated">PCRE(和Perl)也能识别Posix语法[.ch.]和[=ch=],其中 &quot;ch &quot;是一个 &quot;整理元素&quot;,但这些语法不被支持,如果遇到这些语法会给出一个错误。</target>
        </trans-unit>
        <trans-unit id="c7e1a3a2c06dd5d35852b8fd7f58b67f48a9a787" translate="yes" xml:space="preserve">
          <source>PCRE contains some optimizations that are used to speed up matching by running some checks at the start of each match attempt. For example, it can know the minimum length of matching subject, or that a particular character must be present. When one of these optimizations bypasses the running of a match, any included backtracking verbs are not processed. processed. You can suppress the start-of-match optimizations by setting option &lt;code&gt;no_start_optimize&lt;/code&gt; when calling &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, or by starting the pattern with (*NO_START_OPT).</source>
          <target state="translated">PCRE包含一些优化，这些优化用于通过在每次匹配尝试开始时进行一些检查来加快匹配速度。例如，它可以知道匹配主题的最小长度，或者必须存在特定字符。当这些优化之一绕过比赛进行时，将不处理所有包含的回溯动词。处理。您可以通过在调用 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 时设置选项 &lt;code&gt;no_start_optimize&lt;/code&gt; 或通过使用（* NO_START_OPT）启动模式来抑制匹配开始优化。</target>
        </trans-unit>
        <trans-unit id="b299ec8de52cb755bee6ddf20ed30414c507680c" translate="yes" xml:space="preserve">
          <source>PCRE differs from Perl in its handling of backtracking verbs in repeated groups. For example, consider:</source>
          <target state="translated">PCRE与Perl的不同之处在于它对重复组动词的回溯处理。例如,可以考虑:</target>
        </trans-unit>
        <trans-unit id="3cc508b88f2a03ca5b89b7762b1f20cd8e196650" translate="yes" xml:space="preserve">
          <source>PCRE does not allow \C to appear in lookbehind assertions (described below) in a UTF mode, as this would make it impossible to calculate the length of the lookbehind.</source>
          <target state="translated">PCRE不允许在UTF模式下的lookbehind断言(如下所述)中出现\C,因为这将导致无法计算lookbehind的长度。</target>
        </trans-unit>
        <trans-unit id="1cbd2b65949cf73edf1658ac5a4fd6ddc42bd83c" translate="yes" xml:space="preserve">
          <source>PCRE has an optimization that automatically &quot;possessifies&quot; certain simple pattern constructs. For example, the sequence A+B is treated as A++B, as there is no point in backtracking into a sequence of A:s when B must follow.</source>
          <target state="translated">PCRE有一个优化,可以自动 &quot;占有 &quot;某些简单的模式构造。例如,序列A+B被视为A++B,因为当B必须跟随时,没有必要回溯到A:s的序列。</target>
        </trans-unit>
        <trans-unit id="f0fc58f08622bddb7678d55039d7a59b7bc48042" translate="yes" xml:space="preserve">
          <source>PCRE supports an extension to Oniguruma: if a number is preceded by a plus or minus sign, it is taken as a relative reference, for example:</source>
          <target state="translated">PCRE支持对Oniguruma的扩展:例如,如果一个数字前面有加号或减号,则将其作为相对参考。</target>
        </trans-unit>
        <trans-unit id="dec962e9c5b1c207185027f300491448a37e5072" translate="yes" xml:space="preserve">
          <source>PCRE supports five conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (line feed) character, the two-character sequence CRLF, any of the three preceding, and any Unicode newline sequence.</source>
          <target state="translated">PCRE支持五种惯例来指示字符串中的换行符:单个CR(回车)字符、单个LF(换行)字符、两个字符序列CRLF、前面三个中的任何一个以及任何Unicode换行序列。</target>
        </trans-unit>
        <trans-unit id="fa87f3aabeb31ade442c9f5f35c180a263350233" translate="yes" xml:space="preserve">
          <source>PEM files, used by ssl API-functions, are cached. The cache is regularly checked to see if any cache entries should be invalidated, however this function provides a way to unconditionally clear the whole cache.</source>
          <target state="translated">PEM文件,由ssl API函数使用,被缓存。缓存会被定期检查,以确定是否有缓存条目无效,但是这个函数提供了一种无条件清除整个缓存的方法。</target>
        </trans-unit>
        <trans-unit id="1cd905f009accd2df9f1ab5f8a17d5b5c38872a6" translate="yes" xml:space="preserve">
          <source>Package the installation in &lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt;, place it wherever you want on your target machine, and run the &lt;code&gt;Install&lt;/code&gt; script on your target machine:</source>
          <target state="translated">将安装程序打包在 &lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt; 中，将其放置在目标计算机上的任意位置，然后在目标计算机上运行 &lt;code&gt;Install&lt;/code&gt; 脚本：</target>
        </trans-unit>
        <trans-unit id="c2b5d604d7f06e3d1f95fc5dc804a3221b871852" translate="yes" xml:space="preserve">
          <source>Packed Encoding Rules (PER), both the aligned and unaligned variant</source>
          <target state="translated">编码规则(PER),包括对齐和不对齐的变体。</target>
        </trans-unit>
        <trans-unit id="e71a71de422305a16e28853d413eeb1fe6adaa8c" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the listening socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 将数据包发送到返回的套接字 &lt;code&gt;Socket&lt;/code&gt; 。从对等方发送的数据包将作为消息传递（除非在侦听套接字的选项列表中指定了 &lt;code&gt;{active, false}&lt;/code&gt; ，在这种情况下，可通过调用 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 来检索数据包）：</target>
        </trans-unit>
        <trans-unit id="999e0ae2fd1b7fad6eb65fd1659da2a1e9675393" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages:</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 将数据包发送到返回的套接字 &lt;code&gt;Socket&lt;/code&gt; 。从对等方发送的数据包将作为消息传递：</target>
        </trans-unit>
        <trans-unit id="a9cbdaa25497050f647df52257a52127df4c6dcd" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The header length can be one, two, or four bytes, and containing an unsigned integer in big-endian byte order. Each send operation generates the header, and the header is stripped off on each receive operation.</source>
          <target state="translated">数据包由一个报头组成,报头指定了数据包中的字节数,然后是该字节数。头部长度可以是一个、两个或四个字节,包含一个无符号整数,按大字节顺序排列。每次发送操作都会产生头,每次接收操作时,头都会被剥离。</target>
        </trans-unit>
        <trans-unit id="d0d592f83333abf860b4699c427f31bf34be37ff" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The length of the header can be one, two, or four bytes; the order of the bytes is big-endian. The header is stripped off when the packet is returned.</source>
          <target state="translated">数据包由一个报头组成,报头指定了数据包中的字节数,然后是该字节数。头部的长度可以是一个、两个或四个字节;字节的顺序是big-endian。当数据包返回时,头会被剥离掉。</target>
        </trans-unit>
        <trans-unit id="b9b4528e2d3cf117ea52177114c90e71d60519dc" translate="yes" xml:space="preserve">
          <source>Pads &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Length&lt;/code&gt; with grapheme cluster &lt;code&gt;Char&lt;/code&gt;. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt;, &lt;code&gt;trailing&lt;/code&gt;, or &lt;code&gt;both&lt;/code&gt;, indicates where the padding should be added.</source>
          <target state="translated">垫 &lt;code&gt;String&lt;/code&gt; 到 &lt;code&gt;Length&lt;/code&gt; 与石墨烯集群 &lt;code&gt;Char&lt;/code&gt; 。 &lt;code&gt;Dir&lt;/code&gt; 可以是 &lt;code&gt;leading&lt;/code&gt; ， &lt;code&gt;trailing&lt;/code&gt; 或 &lt;code&gt;both&lt;/code&gt; ，指示应在何处添加填充。</target>
        </trans-unit>
        <trans-unit id="62bfbd510157d2b2d32934302b71a771f9fb8488" translate="yes" xml:space="preserve">
          <source>Pahawh_Hmong</source>
          <target state="translated">Pahawh_Hmong</target>
        </trans-unit>
        <trans-unit id="ea98d285a450c2d86578176798a994d47e81c69f" translate="yes" xml:space="preserve">
          <source>Palmyrene</source>
          <target state="translated">Palmyrene</target>
        </trans-unit>
        <trans-unit id="eb7595283333290680efe8f59bad4f5efb16ee78" translate="yes" xml:space="preserve">
          <source>Paragraph separator</source>
          <target state="translated">段落分隔符</target>
        </trans-unit>
        <trans-unit id="ea1f90af11a63290665889dc8c71bcb46ef20ff7" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;ArgL&lt;/code&gt; is a list of the following options:</source>
          <target state="translated">参数 &lt;code&gt;ArgL&lt;/code&gt; 是以下选项的列表：</target>
        </trans-unit>
        <trans-unit id="481ff685beef8edc87c1c25cefdedd5dd3072163" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;FlagList&lt;/code&gt; is a list of options. The following are the valid options:</source>
          <target state="translated">参数 &lt;code&gt;FlagList&lt;/code&gt; 是选项列表。以下是有效的选项：</target>
        </trans-unit>
        <trans-unit id="fb58c9f9f7662428e1102cf73d06277b9a9f8408" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Item&lt;/code&gt; specifies which driver to monitor (the driver name) and which state change to monitor. The parameter is a tuple of arity two whose first element is the driver name and second element is one of the following:</source>
          <target state="translated">参数 &lt;code&gt;Item&lt;/code&gt; 指定要监视的驱动程序（驱动程序名称）以及要监视的状态更改。该参数是两个均等的元组，其第一个元素是驱动程序名称，第二个元素是以下之一：</target>
        </trans-unit>
        <trans-unit id="ffc2bcb064cabdbae071c079e72742a961a53078" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;MgrAgentConfName&lt;/code&gt; in the functions is to be a name you allocate in your test suite using a &lt;code&gt;require&lt;/code&gt; statement. Example (where &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt;):</source>
          <target state="translated">函数中的参数 &lt;code&gt;MgrAgentConfName&lt;/code&gt; 将成为您使用 &lt;code&gt;require&lt;/code&gt; 语句在测试套件中分配的名称。示例（其中 &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="67a9b163fdabde30f306efc624573ddbed00e72a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Options&lt;/code&gt; is a list of atoms that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options (&lt;code&gt;[]&lt;/code&gt;) is the same as specifying &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;Options&lt;/code&gt; 是原子列表，用于指定表类型，访问权限，键位置以及表是否命名。默认值用于省略的选项。这意味着未指定任何选项（ &lt;code&gt;[]&lt;/code&gt; ）与指定 &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d795107fbe2f795cba5a352dc3d9eb7ed96b4b2" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;UserPrivate&lt;/code&gt; is typically the result of opening a low-level structure like a file descriptor or an SFTP channel id. The different &lt;code&gt;Fun&lt;/code&gt; clauses operate on that very term.</source>
          <target state="translated">参数 &lt;code&gt;UserPrivate&lt;/code&gt; 通常是打开低级结构（如文件描述符或SFTP通道ID）的结果。不同的 &lt;code&gt;Fun&lt;/code&gt; 子句在该术语上起作用。</target>
        </trans-unit>
        <trans-unit id="178879c4f36263f5398b5fe0c1d2b17ffe37778c" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;buf&lt;/code&gt; points to the data to send, and &lt;code&gt;len&lt;/code&gt; is the number of bytes.</source>
          <target state="translated">参数 &lt;code&gt;buf&lt;/code&gt; 指向要发送的数据，而 &lt;code&gt;len&lt;/code&gt; 是字节数。</target>
        </trans-unit>
        <trans-unit id="8c3b0a66603387ab483d713b83c217fa59d3b555" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;event&lt;/code&gt; identifies an OS-specific event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket or pipe (or other object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use). On Windows, the Win32 API function &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; is used. This places other restrictions on the event object; see the Win32 SDK documentation.</source>
          <target state="translated">参数 &lt;code&gt;event&lt;/code&gt; 标识特定于OS的事件对象。在Unix系统上，使用 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 功能。事件对象必须是套接字或管道（或 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 可以使用的其他对象）。在Windows上，使用Win32 API函数 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 。这对事件对象设置了其他限制；请参阅Win32 SDK文档。</target>
        </trans-unit>
        <trans-unit id="164ddca5ff1565ca4f9e0ee9934496e78da5103a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc based nodes.</source>
          <target state="translated">参数 &lt;code&gt;extra_db_nodes&lt;/code&gt; 也可以在基于磁盘的节点上使用。</target>
        </trans-unit>
        <trans-unit id="19911242e8e159e23d1389d3ca9b289be8023784" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;group_names_or_paths&lt;/code&gt; specifies one or more group names and/or one or more group paths. At startup, &lt;code&gt;Common Test&lt;/code&gt; searches for matching groups in the group definitions tree (that is, the list returned from &lt;code&gt;Suite:groups/0&lt;/code&gt;; for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;group_names_or_paths&lt;/code&gt; 指定一个或多个组名和/或一个或多个组路径。启动时， &lt;code&gt;Common Test&lt;/code&gt; 在组定义树（即 &lt;code&gt;Suite:groups/0&lt;/code&gt; 返回的列表）中搜索匹配的组；有关详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="1db4151b626c494895a3303e3e9dc15c541574a3" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;mode&lt;/code&gt; is a bitwise OR combination of &lt;code&gt;ERL_DRV_READ&lt;/code&gt;, &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt;, and &lt;code&gt;ERL_DRV_USE&lt;/code&gt;. The first two specify whether to wait for read events and/or write events. A fired read event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; and a fired write event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;mode&lt;/code&gt; 是 &lt;code&gt;ERL_DRV_READ&lt;/code&gt; ， &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt; 和 &lt;code&gt;ERL_DRV_USE&lt;/code&gt; 的按位&amp;ldquo;或&amp;rdquo;组合。前两个指定是否等待读取事件和/或写入事件。触发的读取事件调用 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; ，触发的写入事件调用 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24b7e614b3fb7661e3c4bfa669cf966c8e65b191" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;offset&lt;/code&gt; is an offset into the binary and &lt;code&gt;len&lt;/code&gt; is the number of bytes to send.</source>
          <target state="translated">参数 &lt;code&gt;offset&lt;/code&gt; 是二进制文件的偏移量， &lt;code&gt;len&lt;/code&gt; 是要发送的字节数。</target>
        </trans-unit>
        <trans-unit id="2c09fe112bbeb4630f395aac2bcdfe148aca5521" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;on&lt;/code&gt; is to be &lt;code&gt;1&lt;/code&gt; for setting events and &lt;code&gt;0&lt;/code&gt; for clearing them.</source>
          <target state="translated">参数 &lt;code&gt;on&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 表示事件，设置为 &lt;code&gt;0&lt;/code&gt; 表示清除事件。</target>
        </trans-unit>
        <trans-unit id="f74566537c8d9ce233e9f86c48184e78edfc96b6" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;port&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; an ordinary port handle, but a port handle converted using &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;port&lt;/code&gt; 是&lt;strong&gt;不&lt;/strong&gt;普通的端口句柄，但使用一个端口句柄转换 &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31842056db03aa395dd407bca74bccb68a5a26bb" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;process&lt;/code&gt; is to be the return value of an earlier call to &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">参数 &lt;code&gt;process&lt;/code&gt; 将是对 &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; 调用的先前调用的返回值。</target>
        </trans-unit>
        <trans-unit id="66a261af649e0d1c255cd39045bb5e13b9ca6186" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;skip&lt;/code&gt; is a number of bytes to skip of the &lt;code&gt;ev&lt;/code&gt; vector from the head.</source>
          <target state="translated">参数 &lt;code&gt;skip&lt;/code&gt; 是要从头部跳过 &lt;code&gt;ev&lt;/code&gt; 矢量的字节数。</target>
        </trans-unit>
        <trans-unit id="64e4fb00a7835e330447d940e7db2ce15d43c569" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;term&lt;/code&gt; points to an array of &lt;code&gt;ErlDrvTermData&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements. This array contains terms described in the driver term format. Every term consists of 1-4 elements in the array. The first term has a term type and then arguments. Parameter &lt;code&gt;port&lt;/code&gt; specifies the sending port.</source>
          <target state="translated">参数 &lt;code&gt;term&lt;/code&gt; 指向带有 &lt;code&gt;n&lt;/code&gt; 个元素的 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 数组。该数组包含以驱动程序术语格式描述的术语。每个术语由数组中的1-4个元素组成。第一项具有项类型，然后具有参数。参数 &lt;code&gt;port&lt;/code&gt; 指定发送端口。</target>
        </trans-unit>
        <trans-unit id="619a12371bd91db45106e0947981ba34d3c2bd49" translate="yes" xml:space="preserve">
          <source>Parameterization, which is defined in X.683, can be used when defining types, values, value sets, classes, objects, or object sets. A part of a definition can be supplied as a parameter. For example, if a &lt;code&gt;Type&lt;/code&gt; is used in a definition with a certain purpose, you want the type name to express the intention. This can be done with parameterization.</source>
          <target state="translated">在定义类型，值，值集，类，对象或对象集时，可以使用X.683中定义的参数化。定义的一部分可以作为参数提供。例如，如果一个 &lt;code&gt;Type&lt;/code&gt; 是在定义中使用带有一定的目的，你想要的类型名称来表达的意图。这可以通过参数化来完成。</target>
        </trans-unit>
        <trans-unit id="3001577f3d424b071c234b5e5a77e2c797ba8919" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;port&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;port&lt;/code&gt; ， &lt;code&gt;term&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的工作方式与 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="aa047ce05d4bbf51547604b5fd791b6e5ce4e1a0" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;term&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的工作方式与 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="52408a3808b8f3d07d1e351897f44c8601912f48" translate="yes" xml:space="preserve">
          <source>Parameters to be used to call public_key:generate_key/1, to generate a key, or an existing key. Defaults to generating an ECDSA key. Note this could fail if Erlang/OTP is compiled with a very old cryptolib.</source>
          <target state="translated">用于调用public_key:generate_key/1的参数,用来生成一个密钥,或者一个现有的密钥。默认为生成一个ECDSA密钥。请注意,如果Erlang/OTP是用非常老的密码库编译的,那么这个函数可能会失败。</target>
        </trans-unit>
        <trans-unit id="f544c8871ad84d3b8d3ea9af03500476893103ea" translate="yes" xml:space="preserve">
          <source>Parentheses are used for grouping, either to make an expression more readable or to override the default precedence of operators:</source>
          <target state="translated">括号用于分组,可以使表达式更易读,也可以覆盖运算符的默认优先级。</target>
        </trans-unit>
        <trans-unit id="a38e57cb166c131b67e7c17a52a16571f7e59fb9" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions are useful to override &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt;, for example, in arithmetic expressions:</source>
          <target state="translated">带括号的表达式可用于覆盖 &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt; ，例如在算术表达式中：</target>
        </trans-unit>
        <trans-unit id="1ec3038821c8e34cb4ca25c92efd7b368a0d8e5a" translate="yes" xml:space="preserve">
          <source>Parse a stream containing an XML document.</source>
          <target state="translated">解析一个包含XML文档的流。</target>
        </trans-unit>
        <trans-unit id="8217aea2b6b930a773bd2a30eafc88abe67c2fba" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document</source>
          <target state="translated">包含XML文档的解析文件</target>
        </trans-unit>
        <trans-unit id="5a6136b4aa579fcfcffcc46e0f8f8eb6d5603d86" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, DOM style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt; and &lt;code&gt;close_fun&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">解析包含XML文档作为流，DOM样式的文件。包装程序，用于使用 &lt;code&gt;continuation_fun&lt;/code&gt; 调用XML解析器 &lt;code&gt;xmerl_scan&lt;/code&gt; ，以处理XML数据流。请注意，不能使用此解析器来定义 &lt;code&gt;continuation_fun&lt;/code&gt; ， &lt;code&gt;acc_fun&lt;/code&gt; ， &lt;code&gt;fetch_fun&lt;/code&gt; ， &lt;code&gt;rules&lt;/code&gt; 和 &lt;code&gt;close_fun&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="674e40f858960e6e4df14fbdc24544779fa454b2" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt;, &lt;code&gt;hook_fun&lt;/code&gt;, &lt;code&gt;close_fun&lt;/code&gt; and &lt;code&gt;user_state&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">解析包含XML文档作为流的SAX样式的文件。包装程序，用于使用 &lt;code&gt;continuation_fun&lt;/code&gt; 调用XML解析器 &lt;code&gt;xmerl_scan&lt;/code&gt; ，以处理XML数据流。请注意，不能使用此解析器来定义 &lt;code&gt;continuation_fun&lt;/code&gt; ， &lt;code&gt;acc_fun&lt;/code&gt; ， &lt;code&gt;fetch_fun&lt;/code&gt; ， &lt;code&gt;rules&lt;/code&gt; ， &lt;code&gt;hook_fun&lt;/code&gt; ， &lt;code&gt;close_fun&lt;/code&gt; 和 &lt;code&gt;user_state&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fc9ee985dfae362f5f4036d5f83dc0f5fe590d74" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;hook_fun&lt;/code&gt; for using xmerl export functionality directly after an entity is parsed.</source>
          <target state="translated">解析包含SAX样式的XML文档的文件。用于包装XML的包装，该包装使用一个 &lt;code&gt;hook_fun&lt;/code&gt; 来调用XML解析器 &lt;code&gt;xmerl_scan&lt;/code&gt; ，以便在解析实体后立即使用xmerl导出功能。</target>
        </trans-unit>
        <trans-unit id="a7e66c978a3bc50b34f2f8f441cb5d45be8ce70b" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.</source>
          <target state="translated">解析包含XML文档的文件。该函数使用默认的延续函数以块的形式读取文件。</target>
        </trans-unit>
        <trans-unit id="c11cdcc0a2531ae96dc218c56c12636fa75bf6fe" translate="yes" xml:space="preserve">
          <source>Parse string containing an XML document</source>
          <target state="translated">包含XML文档的解析字符串</target>
        </trans-unit>
        <trans-unit id="6b19e7fcfb29d25095c7a452b5d973ecb668a8f0" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables.</source>
          <target state="translated">解析文本并替换元变量。</target>
        </trans-unit>
        <trans-unit id="f3059059775d564c176b513311505460d999325b" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">解析文本并替换元变量。以扫描器的初始位置作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="995f08395199c28811d1c157ebeb410cdf5f6a52" translate="yes" xml:space="preserve">
          <source>Parse text.</source>
          <target state="translated">解析文本。</target>
        </trans-unit>
        <trans-unit id="6f88d437ec32b29a09b77bb3c60dda1a500d3d76" translate="yes" xml:space="preserve">
          <source>Parse text. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">解析文本。以扫描器的初始位置作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="2db8f8fef89f426d3dbefc3cc3581aafe79f6ce1" translate="yes" xml:space="preserve">
          <source>Parse the given test specification files and return the tests to run and skip.</source>
          <target state="translated">解析给定的测试规范文件,并返回要运行和跳过的测试。</target>
        </trans-unit>
        <trans-unit id="2163966b8b6a50fd1cf0cca656abeddf8dd5cc71" translate="yes" xml:space="preserve">
          <source>Parse transform for merl.</source>
          <target state="translated">merl的解析变换。</target>
        </trans-unit>
        <trans-unit id="16b406d744c815ddcee583e6e5df09f0720355fa" translate="yes" xml:space="preserve">
          <source>Parse transform for merl. Enables the use of automatic metavariables and using quasi-quotes in matches and case switches. Also optimizes calls to functions in &lt;code&gt;merl&lt;/code&gt; by partially evaluating them, turning strings to templates, etc., at compile-time.</source>
          <target state="translated">解析转换为梅尔。支持在匹配和大小写转换中使用自动元变量并使用准引用。还可以通过在编译时部分评估函数，将字符串转换为模板等来优化对 &lt;code&gt;merl&lt;/code&gt; 中函数的调用。</target>
        </trans-unit>
        <trans-unit id="1a936ecbdaa0108bef18e5866e06c3f267270543" translate="yes" xml:space="preserve">
          <source>Parse transformations are used if a programmer wants to use Erlang syntax, but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">如果程序员想使用Erlang语法,但语义不同,就会使用解析转换。然后将原来的Erlang代码转换为其他Erlang代码。</target>
        </trans-unit>
        <trans-unit id="e2baf70db7b7c168b6c27755c6350a0d8b3a3116" translate="yes" xml:space="preserve">
          <source>Parse transformations are used when a programmer wants to use Erlang syntax but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">当程序员想使用Erlang语法但语义不同时,就会用到解析转换。然后将原来的Erlang代码转换为其他Erlang代码。</target>
        </trans-unit>
        <trans-unit id="b27625b152a11d3756ff7a956cb8d71acc5d561c" translate="yes" xml:space="preserve">
          <source>Parse trees for Erlang expression, see section &lt;code&gt;The Abstract Format&lt;/code&gt; in the ERTS User's Guide.</source>
          <target state="translated">解析树以获取Erlang表达式，请参阅《 ERTS用户指南》中的 &lt;code&gt;The Abstract Format&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1b485e40955067baa97180fef7a23873d2bbfac9" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a form. Returns one of the following:</source>
          <target state="translated">将 &lt;code&gt;Tokens&lt;/code&gt; 解析为一种形式。返回以下之一：</target>
        </trans-unit>
        <trans-unit id="40605f235bf487ac5cc36c28815be60cb52740c7" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a list of expressions. Returns one of the following:</source>
          <target state="translated">像分析表达式列表一样分析 &lt;code&gt;Tokens&lt;/code&gt; 。返回以下之一：</target>
        </trans-unit>
        <trans-unit id="f5e90d2f7ca99ca3b5931aed84bb2db57dbbc833" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a term. Returns one of the following:</source>
          <target state="translated">将 &lt;code&gt;Tokens&lt;/code&gt; 解析为术语。返回以下之一：</target>
        </trans-unit>
        <trans-unit id="86ede94d84471001f5bfaece799d5f9fa59c6b81" translate="yes" xml:space="preserve">
          <source>Parses a URI. If no scheme defaults are provided, the value of the &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; function is used.</source>
          <target state="translated">解析URI。如果未提供任何方案默认值，则使用 &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; 函数的值。</target>
        </trans-unit>
        <trans-unit id="22aeb59a17ed90dfcd4e4d9f7b96872d034caad8" translate="yes" xml:space="preserve">
          <source>Parses a digit map body</source>
          <target state="translated">解析数字地图主体</target>
        </trans-unit>
        <trans-unit id="dd0ff0f3941a66c29a5874954a99087c88f42111" translate="yes" xml:space="preserve">
          <source>Parses a digit map body, represented as a list of characters, into a list of state transitions suited to be evaluated by megaco:eval_digit_map/1,2.</source>
          <target state="translated">将一个用字符列表表示的数字图体解析成一个适合由megaco:eval_digit_map/1,2来评估的状态转换列表。</target>
        </trans-unit>
        <trans-unit id="f9c79f9646018440e3ebc591b18276096ccfad27" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; and returns an IPv4 or IPv6 address string.</source>
          <target state="translated">解析 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 并返回IPv4或IPv6地址字符串。</target>
        </trans-unit>
        <trans-unit id="b6c5f3cfcbd29b09ebd5d2c45e4555d696f66e8a" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;uri_string()&lt;/code&gt; into a &lt;code&gt;uri_map()&lt;/code&gt;, that holds the parsed components of the &lt;code&gt;URI&lt;/code&gt;. If parsing fails, an error tuple is returned.</source>
          <target state="translated">将符合 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;uri_string()&lt;/code&gt; 解析为 &lt;code&gt;uri_map()&lt;/code&gt; ，该 &lt;code&gt;URI&lt;/code&gt; 中保存了URI的已解析组件。如果解析失败，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="e34be64e7e0d26bd52b330f13bd6dd5de7306b80" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">解析IPv4地址字符串并返回 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 。接受缩短的IPv4地址字符串。</target>
        </trans-unit>
        <trans-unit id="18cc80d670fa4d4c9b9ad5cf24a3ddc556aaf953" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string containing four fields, that is, &lt;strong&gt;not&lt;/strong&gt; shortened, and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析包含四个字段（&lt;strong&gt;未&lt;/strong&gt;缩短）的IPv4地址字符串，并返回 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c579f7b626178d3c420a2e9643120d9f2832584e" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">解析IPv4或IPv6地址字符串，并返回 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 。接受缩短的IPv4地址字符串。</target>
        </trans-unit>
        <trans-unit id="5aa7dda9589a835953ec88f83cdf4c9c4edfbf77" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept a shortened IPv4 address string.</source>
          <target state="translated">解析IPv4或IPv6地址字符串，并返回 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 。难道&lt;strong&gt;不&lt;/strong&gt;接受缩短的IPv4地址字符串。</target>
        </trans-unit>
        <trans-unit id="4b1a2097f959aec277e56d7b2f09d960c163d98b" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept IPv4 addresses.</source>
          <target state="translated">解析IPv6地址字符串并返回 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 。难道&lt;strong&gt;不&lt;/strong&gt;接受IPv4地址。</target>
        </trans-unit>
        <trans-unit id="eac51ea7e0934384fa0112eeeaf88c4ebab04633" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. If an IPv4 address string is specified, an IPv4-mapped IPv6 address is returned.</source>
          <target state="translated">解析IPv6地址字符串并返回 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 。如果指定了IPv4地址字符串，则返回IPv4映射的IPv6地址。</target>
        </trans-unit>
        <trans-unit id="bf75044e156126d255e07b08533855db07ce584c" translate="yes" xml:space="preserve">
          <source>Parses an escript and extracts its sections. This is the reverse of &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析脚本并提取其节。这与 &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="bdec3f2af87f1d33ee6b97ffa74db142958cd9e8" translate="yes" xml:space="preserve">
          <source>Parses the printout from an SQL table and returns a list of tuples.</source>
          <target state="translated">解析SQL表的打印输出并返回一个元组列表。</target>
        </trans-unit>
        <trans-unit id="f5365bc5f3e468cf2148385f40bff58f883061be" translate="yes" xml:space="preserve">
          <source>Parsing URIs into its components and returing a map</source>
          <target state="translated">将URI解析为其组件并返回一个地图。</target>
        </trans-unit>
        <trans-unit id="c8eb7f630b2224852a36c9237667bd9e0484c53a" translate="yes" xml:space="preserve">
          <source>Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">还支持解析和序列化非UTF-8表单编码的查询字符串（ &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="394ec0942f3b3fee9fe7ee73fb59ad007a74829f" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 的测试规范解析。</target>
        </trans-unit>
        <trans-unit id="546554c2840e61b82ab7aeb7ea63ff6baaa80832" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for Common Test.</source>
          <target state="translated">对通用测试的测试规范进行解析。</target>
        </trans-unit>
        <trans-unit id="9769719e65a84af80528eb749196580978ee6445" translate="yes" xml:space="preserve">
          <source>Part of a match specification list cannot be changed directly. If a function has a match specification, it can be replaced with a new one. To change an existing match specification, use the BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; to retrieve the existing match specification.</source>
          <target state="translated">匹配规范列表的一部分不能直接更改。如果一个函数具有匹配规范，则可以用一个新的规范替换它。要更改现有的匹配规范，请使用BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 检索现有的匹配规范。</target>
        </trans-unit>
        <trans-unit id="bf0d342d4ce21f38adfd95210e15a51046211865" translate="yes" xml:space="preserve">
          <source>Part of a pattern within square brackets is called a &quot;character class&quot;. The following are the only metacharacters in a character class:</source>
          <target state="translated">方括号内的部分图案称为 &quot;字符类&quot;。以下是字符类中唯一的元字符。</target>
        </trans-unit>
        <trans-unit id="3bcb9ea04e25a8921a95bf6ab1089af46b847ca3" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into a list of sublists and a remainder. &lt;code&gt;Lists&lt;/code&gt; contains one sublist for each key in &lt;code&gt;Keys&lt;/code&gt;, in the corresponding order. The relative order of the elements in each sublist is preserved from the original &lt;code&gt;List&lt;/code&gt;. &lt;code&gt;Rest&lt;/code&gt; contains the elements in &lt;code&gt;List&lt;/code&gt; that are not associated with any of the specified keys, also with their original relative order preserved.</source>
          <target state="translated">分区 &lt;code&gt;List&lt;/code&gt; 分为子列表和其余列表。 &lt;code&gt;Lists&lt;/code&gt; 按相应顺序为 &lt;code&gt;Keys&lt;/code&gt; 中的每个键包含一个子列表。每个子列表中元素的相对顺序均保留在原始 &lt;code&gt;List&lt;/code&gt; 中。 &lt;code&gt;Rest&lt;/code&gt; 包含 &lt;code&gt;List&lt;/code&gt; 中与任何指定键都不关联的元素，并且保留其原始相对顺序。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
