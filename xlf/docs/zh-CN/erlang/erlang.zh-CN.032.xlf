<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="c745a240a8b09464690a74b0ded828b443277620" translate="yes" xml:space="preserve">
          <source>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</source>
          <target state="translated">由于历史原因,驱动程序名称以字符串列表而不是原子列表的形式返回。</target>
        </trans-unit>
        <trans-unit id="8c90e4dc558838312154093ae7e4d33a042314e8" translate="yes" xml:space="preserve">
          <source>The driver options for a specified driver name need always to be consistent, &lt;strong&gt;even when the driver is reloaded&lt;/strong&gt;, meaning that they are as much a part of the driver as the name.</source>
          <target state="translated">&lt;strong&gt;即使重新加载了驱动程序&lt;/strong&gt;，指定驱动程序名称的驱动程序选项也必须始终保持一致，这意味着它们与名称一样多。</target>
        </trans-unit>
        <trans-unit id="ec7187710cb97de822c20a1794719f5b691ec563" translate="yes" xml:space="preserve">
          <source>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal Erlang message queues). This can be useful if the driver must wait for slow devices, and so on, and wants to yield back to the emulator. The driver queue is implemented as an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">驱动程序队列可用于将仿真器的输出排队到驱动器（从驱动程序到仿真器的数据由仿真器在常规Erlang消息队列中排队）。如果驱动程序必须等待速度较慢的设备等，并且想要让回给仿真器，这将很有用。驱动程序队列实现为 &lt;code&gt;ErlIOVec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267e1ade55aca0a7989f62dc5c3745421b17592a" translate="yes" xml:space="preserve">
          <source>The driver structure contains the driver name and some 15 function pointers, which are called at different times by the emulator.</source>
          <target state="translated">驱动程序结构包含驱动程序名称和大约15个函数指针,这些函数指针在不同的时间被仿真器调用。</target>
        </trans-unit>
        <trans-unit id="777fa5f89808e7871ea95ba4af70a119a6124215" translate="yes" xml:space="preserve">
          <source>The driver structure is filled with the driver name and function pointers. It is returned from the special entry point, declared with the macro &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">驱动程序结构中填充了驱动程序名称和功能指针。它从用宏 &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt; 声明的特殊入口点返回。</target>
        </trans-unit>
        <trans-unit id="ca38a39e87b4ab492f8fbeb01d018493a1577466" translate="yes" xml:space="preserve">
          <source>The driver structure is similar for statically linked-in drivers and dynamically loaded. However, some of the fields are to be left empty (that is, initialized to NULL) in the different types of drivers. The first field (the &lt;code&gt;init&lt;/code&gt; function pointer) is always left blank in a dynamically loaded driver, see line 26. &lt;code&gt;NULL&lt;/code&gt; on line 37 is always to be there, the field is no longer used and is retained for backward compatibility. No timers are used in this driver, why no callback for timers is needed. The &lt;code&gt;outputv&lt;/code&gt; field (line 40) can be used to implement an interface similar to Unix &lt;code&gt;writev&lt;/code&gt; for output. The Erlang runtime system could previously not use &lt;code&gt;outputv&lt;/code&gt; for the distribution, but it can as from ERTS 5.7.2. As this driver was written before ERTS 5.7.2 it does not use the &lt;code&gt;outputv&lt;/code&gt; callback. Using the &lt;code&gt;outputv&lt;/code&gt; callback is preferred, as it reduces copying of data. (We will however use scatter/gather I/O internally in the driver.)</source>
          <target state="translated">对于静态链接的驱动程序和动态加载的驱动程序结构类似。但是，在不同类型的驱动程序中，某些字段将保留为空（即，初始化为NULL）。在动态加载的驱动程序中，第一个字段（ &lt;code&gt;init&lt;/code&gt; 函数指针）始终为空白，请参见第26行。第37 行上的 &lt;code&gt;NULL&lt;/code&gt; 始终存在，不再使用该字段，并且保留该字段是为了向后兼容。在此驱动程序中不使用任何计时器，为什么不需要计时器的回调。所述 &lt;code&gt;outputv&lt;/code&gt; 场（第40行）可以被用于实现类似Unix的接口 &lt;code&gt;writev&lt;/code&gt; 可以获得用于输出。 Erlang运行时系统以前不能使用 &lt;code&gt;outputv&lt;/code&gt; 用于分发，但可以从ERTS 5.7.2开始。由于此驱动程序是在ERTS 5.7.2之前编写的，因此不使用 &lt;code&gt;outputv&lt;/code&gt; 回调。最好使用 &lt;code&gt;outputv&lt;/code&gt; 回调，因为它可以减少数据复制。（但是，我们将在驱动程序内部使用分散/聚集I / O。）</target>
        </trans-unit>
        <trans-unit id="13e83e61fa641454caf4f4f17446cac682b522d1" translate="yes" xml:space="preserve">
          <source>The driver used for Erlang distribution is to implement a reliable, order maintaining, variable length packet-oriented protocol. All error correction, resending and such need to be implemented in the driver or by the underlying communications protocol. If the protocol is stream-oriented (as is the case with both TCP/IP and our streamed Unix domain sockets), some mechanism for packaging is needed. We will use the simple method of having a header of four bytes containing the length of the package in a big-endian 32-bit integer. As Unix domain sockets only can be used between processes on the same machine, we do not need to code the integer in some special endianess, but we will do it anyway because in most situation you need to do it. Unix domain sockets are reliable and order maintaining, so we do not need to implement resends and such in the driver.</source>
          <target state="translated">用于Erlang分发的驱动程序是实现一个可靠的、维持秩序的、面向可变长度包的协议。所有的纠错、重发等都需要在驱动中或由底层通信协议来实现。如果协议是面向流的(如TCP/IP和我们的流式Unix域套接字都是如此),就需要一些打包的机制。我们将使用简单的方法,即有一个由四个字节组成的头,用一个32位的大恩典整数来包含封装的长度。由于Unix域套接字只能在同一台机器上的进程之间使用,所以我们不需要用一些特殊的endianess来编码,但我们还是会这么做,因为在大多数情况下你都需要这么做。Unix域套接字是可靠的,而且是有秩序的,所以我们不需要在驱动中实现重发之类的功能。</target>
        </trans-unit>
        <trans-unit id="885a9c9f85b39e7698683efce0ff5bba88451a67" translate="yes" xml:space="preserve">
          <source>The driver was already loaded by another process or is in use by a living port, or both. The load by you is registered and a corresponding &lt;code&gt;try_unload&lt;/code&gt; is expected sometime in the future.</source>
          <target state="translated">驱动程序已由另一个进程加载，或正在由活动端口使用，或同时被这两个端口使用。您的负载已注册，并且预计将来会出现相应的 &lt;code&gt;try_unload&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="380ea6d015cef2cddc2581f363be87321f771e9f" translate="yes" xml:space="preserve">
          <source>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</source>
          <target state="translated">驱动程序立即被卸载,这意味着驱动程序名称现在可以自由地被其他驱动程序使用,如果底层操作系统允许,驱动程序对象代码所占用的内存现在已经被回收。</target>
        </trans-unit>
        <trans-unit id="e3da2e19322e3c6628d119e07b3e56934634eac8" translate="yes" xml:space="preserve">
          <source>The driver was loaded and is immediately usable.</source>
          <target state="translated">驱动装好了,马上就可以用了。</target>
        </trans-unit>
        <trans-unit id="d864f9d9077463dec755426c28ec5da6f217e91e" translate="yes" xml:space="preserve">
          <source>The driver with the specified name is an Erlang statically linked-in driver, which cannot be manipulated with this API.</source>
          <target state="translated">指定名称的驱动程序是一个Erlang静态链接的驱动程序,不能用这个API进行操作。</target>
        </trans-unit>
        <trans-unit id="f1eb9606d6f4220a244d8c3b7748d550c419a79a" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">驱动程序 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt; 器将在调用driver_monitor_process时提供用于存储监视器的内存。数据的地址未存储在驱动程序外部，因此 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 可以用作任何其他数据，可以复制，移动到内存中，遗忘等等。</target>
        </trans-unit>
        <trans-unit id="4025b3383bc4889c1c9cd923cfef69764fc7fb73" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在以后的驱动程序回调中传递的驱动程序定义的句柄。请注意，此新驱动程序实例未调用 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 。当通过 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 创建端口时，通常在 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 创建驱动程序定义的句柄。</target>
        </trans-unit>
        <trans-unit id="394034fd0da749c1d06ef57ce69c6215ae425eb2" translate="yes" xml:space="preserve">
          <source>The driver-entry structure used by Erlang drivers.</source>
          <target state="translated">Erlang驱动程序使用的驱动程序入口结构。</target>
        </trans-unit>
        <trans-unit id="e67bdfbeb3c1793f1075c60e9dfc86106434ef3f" translate="yes" xml:space="preserve">
          <source>The dump is truncated.</source>
          <target state="translated">转储被截断了。</target>
        </trans-unit>
        <trans-unit id="58fd56942c22b98ca6dfc0e41f2fc24c62b5de4a" translate="yes" xml:space="preserve">
          <source>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</source>
          <target state="translated">转储被截断。在这种情况下,主窗口的状态栏中会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="26da6cb9d5e2b4d506bf3083a6055833ae7a4362" translate="yes" xml:space="preserve">
          <source>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</source>
          <target state="translated">耐久性属性确保事务对DBMS所做的更改是永久性的。一旦事务被提交,对数据库所做的所有更改都是持久的,也就是说,这些更改会被安全地写入磁盘,不会被破坏,也不会消失。</target>
        </trans-unit>
        <trans-unit id="a7aa3c54478ccaa5bbddda8a5fe6086c5ab90507" translate="yes" xml:space="preserve">
          <source>The duration time is specified as &lt;code&gt;HHMMSS&lt;/code&gt;, for example, &lt;code&gt;-duration 012030&lt;/code&gt; or &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</source>
          <target state="translated">持续时间指定为 &lt;code&gt;HHMMSS&lt;/code&gt; ，例如 &lt;code&gt;-duration 012030&lt;/code&gt; 或 &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34138fd668a3a91f262b3c8cc94e10c40614310" translate="yes" xml:space="preserve">
          <source>The dynamic engine is not supported in LibreSSL from version 2.2.1</source>
          <target state="translated">LibreSSL从2.2.1版本开始就不支持动态引擎。</target>
        </trans-unit>
        <trans-unit id="46cf93457fc198c7fc4b11e05da4141275628e59" translate="yes" xml:space="preserve">
          <source>The earlier factorial example can act as a counter-example. It is not tail-recursive, since a multiplication is done on the result of the recursive call to &lt;code&gt;fact(N-1)&lt;/code&gt;.</source>
          <target state="translated">较早的析因示例可以用作反示例。它不是尾递归的，因为对 &lt;code&gt;fact(N-1)&lt;/code&gt; 进行递归调用的结果是乘法。</target>
        </trans-unit>
        <trans-unit id="7471d512bedffa6e5e516b4425ff9cbeaebad94b" translate="yes" xml:space="preserve">
          <source>The easiest path is to mimic the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet_tcp&lt;/code&gt; interfaces, but not much functionality in those modules needs to be implemented. In the example application, only a few of the usual interfaces are implemented, and they are much simplified.</source>
          <target state="translated">最简单的方法是模仿 &lt;code&gt;inet&lt;/code&gt; 和 &lt;code&gt;inet_tcp&lt;/code&gt; 接口，但是这些模块中不需要实现太多功能。在示例应用程序中，仅实现了一些常用接口，并且大大简化了它们。</target>
        </trans-unit>
        <trans-unit id="5a4e2857f3f8ff97859f4357e2a194c2963da6e0" translate="yes" xml:space="preserve">
          <source>The easiest way of using &lt;code&gt;ET&lt;/code&gt;, is to just use it as a graphical tool for displaying message sequence charts. In order to do that you need to first start a &lt;code&gt;Viewer&lt;/code&gt; (which by default starts a &lt;code&gt;Collector&lt;/code&gt;):</source>
          <target state="translated">使用 &lt;code&gt;ET&lt;/code&gt; 的最简单方法是将其用作显示消息序列图的图形工具。为了做到这一点，你需要先启动一个 &lt;code&gt;Viewer&lt;/code&gt; （默认情况下开始 &lt;code&gt;Collector&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3e2ec62c427c4d0d3ce97e74cc8645fe104a328c" translate="yes" xml:space="preserve">
          <source>The easiest way to start Crashdump Viewer is to use shell script &lt;code&gt;cdv&lt;/code&gt; with the full path to the Erlang crashdump as argument. The script is located in directory &lt;code&gt;priv&lt;/code&gt; of the Observer application. This starts the Crashdump Viewer GUI and loads the specified file. If no filename is specified, a file dialog is opened where the file can be selected.</source>
          <target state="translated">启动Crashdump Viewer的最简单方法是将shell脚本 &lt;code&gt;cdv&lt;/code&gt; 与Erlang crashdump的完整路径一起用作参数。该脚本位于Observer应用程序的 &lt;code&gt;priv&lt;/code&gt; 目录中。这将启动Crashdump Viewer GUI并加载指定的文件。如果未指定文件名，则将打开一个文件对话框，可以在其中选择文件。</target>
        </trans-unit>
        <trans-unit id="55d0d417d785ac1626163667303a6253a1c8a917" translate="yes" xml:space="preserve">
          <source>The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.</source>
          <target state="translated">(*THEN)的效果现在只限于内部子模式。在C中失败后,匹配将移至(*FAIL),这将导致整个子模式失败,因为没有更多的替代方案可以尝试。在这种情况下,匹配现在确实回溯到A。</target>
        </trans-unit>
        <trans-unit id="f16407eee4518305b005b9dbecb5884bd7cbf3bc" translate="yes" xml:space="preserve">
          <source>The effect of combining &lt;code&gt;set_on_first_link&lt;/code&gt; with &lt;code&gt;set_on_link&lt;/code&gt; is the same as &lt;code&gt;set_on_first_link&lt;/code&gt; alone. Likewise for &lt;code&gt;set_on_spawn&lt;/code&gt; and &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">合并效果 &lt;code&gt;set_on_first_link&lt;/code&gt; 与 &lt;code&gt;set_on_link&lt;/code&gt; 相同 &lt;code&gt;set_on_first_link&lt;/code&gt; 孤单。同样对于 &lt;code&gt;set_on_spawn&lt;/code&gt; 和 &lt;code&gt;set_on_first_spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb46e1d7474732484a66c32367c6751904b1bed" translate="yes" xml:space="preserve">
          <source>The effect of option &lt;code&gt;cache&lt;/code&gt; is that when generator &lt;code&gt;QH2'&lt;/code&gt; is run the first time, every answer is stored in an ETS table. When the next answer of &lt;code&gt;QH1&lt;/code&gt; is tried, answers to &lt;code&gt;QH2'&lt;/code&gt; are copied from the ETS table, which is very fast. As for option &lt;code&gt;unique&lt;/code&gt; the cost is a possibly substantial amount of RAM memory.</source>
          <target state="translated">选项 &lt;code&gt;cache&lt;/code&gt; 的作用是，当首次运行生成器 &lt;code&gt;QH2'&lt;/code&gt; 时，每个答案都存储在ETS表中。当尝试下一个 &lt;code&gt;QH1&lt;/code&gt; 答案时，将从ETS表中复制 &lt;code&gt;QH2'&lt;/code&gt; 的答案，这非常快。至于 &lt;code&gt;unique&lt;/code&gt; 的选件，成本可能是大量的RAM存储空间。</target>
        </trans-unit>
        <trans-unit id="46af5dbb6ad32f950d071087d55fd5eedd3a2dcc" translate="yes" xml:space="preserve">
          <source>The election process is modified as described in 5.6.4.</source>
          <target state="translated">选举程序按5.6.4所述修改。</target>
        </trans-unit>
        <trans-unit id="cdd607a9ef230a55bb6d74140b011672a2b70ef4" translate="yes" xml:space="preserve">
          <source>The element in position &lt;code&gt;Pos&lt;/code&gt; in &lt;code&gt;Pattern&lt;/code&gt; must be bound. &lt;code&gt;Pos&lt;/code&gt; is an integer (&lt;code&gt;#record.Field&lt;/code&gt;) or an attribute name.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 中位置 &lt;code&gt;Pos&lt;/code&gt; 中的元素必须绑定。 &lt;code&gt;Pos&lt;/code&gt; 是一个整数（ &lt;code&gt;#record.Field&lt;/code&gt; ）或一个属性名称。</target>
        </trans-unit>
        <trans-unit id="c52c7c2c532d8015d87a1ff9dad023e4fb851308" translate="yes" xml:space="preserve">
          <source>The element to update is also the key.</source>
          <target state="translated">要更新的元素也是关键。</target>
        </trans-unit>
        <trans-unit id="133139824edb56fee5c9537204f00d5c8e6d31f2" translate="yes" xml:space="preserve">
          <source>The element to update is not an integer.</source>
          <target state="translated">要更新的元素不是一个整数。</target>
        </trans-unit>
        <trans-unit id="6e2b6d90876d98adc6125d07f13d8d523ed72322" translate="yes" xml:space="preserve">
          <source>The embedded system and all the applications start automatically if the script file shown below is added to directory &lt;code&gt;/etc/rc3.d&lt;/code&gt;. The file must be owned and readable by &lt;code&gt;root&lt;/code&gt;. Its name cannot be arbitrarily assigned; the following name is recommended:</source>
          <target state="translated">如果将以下所示的脚本文件添加到目录 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 中，则嵌入式系统和所有应用程序将自动启动。该文件必须由 &lt;code&gt;root&lt;/code&gt; 拥有并可读。它的名字不能随意分配；建议使用以下名称：</target>
        </trans-unit>
        <trans-unit id="bad88f7a085d192e2f6cec49768a38f2903f8ae0" translate="yes" xml:space="preserve">
          <source>The emulator calls the driver in the following situations:</source>
          <target state="translated">仿真器在以下情况下调用驱动程序。</target>
        </trans-unit>
        <trans-unit id="218b5d9983c658a4cef0aef4b47157f1b19f1a20" translate="yes" xml:space="preserve">
          <source>The emulator has been started with only one scheduler thread.</source>
          <target state="translated">仿真器已经启动,只有一个调度线程。</target>
        </trans-unit>
        <trans-unit id="00ecfc5e261b4531e61f24b2c4f3b8605c732361" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</source>
          <target state="translated">仿真器有一个以上的调度线程,并且没有调度线程被阻塞。也就是说,所有可用的调度器线程都可以调度Erlang进程并执行Erlang代码。</target>
        </trans-unit>
        <trans-unit id="d1335d1e55e250963f0d3ef76a97d106ea1aeeed" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</source>
          <target state="translated">仿真器有一个以上的调度线程,但除了一个调度线程外,其他正常的调度线程都被阻塞了。注意,脏调度器没有被阻塞,可以调度Erlang进程并执行本地代码。</target>
        </trans-unit>
        <trans-unit id="9e09f5c935221131fa5aa069cd7be0f9d773e6f4" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</source>
          <target state="translated">仿真器有一个以上的调度线程,但除了一个调度线程外,所有的调度线程都是阻塞的。也就是说,只有一个调度线程调度Erlang进程并执行Erlang代码。</target>
        </trans-unit>
        <trans-unit id="9414404aaefeb3f5826ea98674c66ad27f121727" translate="yes" xml:space="preserve">
          <source>The emulator probably uses more memory, and because garbage collections occur less frequently, huge binaries can be kept much longer.</source>
          <target state="translated">仿真器可能会使用更多的内存,而且因为垃圾收集发生的频率较低,所以巨大的二进制文件可以保留更多的时间。</target>
        </trans-unit>
        <trans-unit id="8c90a0c569f6e401278d0c92d5efb3209b403c33" translate="yes" xml:space="preserve">
          <source>The emulator refuses to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, as incompatible type changes for the callbacks &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; were introduced in Erlang/OTP R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator, causing it to read random memory and create huge incorrect result blobs.</source>
          <target state="translated">仿真器拒绝加载不使用扩展驱动程序接口的驱动程序，以允许具有64位功能的驱动程序，因为在Erlang / OTP R15B中引入了对回调 &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 不兼容类型更改。用旧类型编写的驱动程序将编译警告，并在被调用时将垃圾大小返回给模拟器，从而导致其读取随机存储器并创建巨大的错误结果Blob。</target>
        </trans-unit>
        <trans-unit id="7a03fbfd7f6822486dc5e29a1dba526a017e4427" translate="yes" xml:space="preserve">
          <source>The emulator restart on Windows NT expects that the system is started using the &lt;code&gt;erlsrv&lt;/code&gt; program (as a service). Furthermore, the release handler expects that the service is named &lt;code&gt;NodeName&lt;/code&gt;_&lt;code&gt;Release&lt;/code&gt;, where &lt;code&gt;NodeName&lt;/code&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;code&gt;Release&lt;/code&gt; is the current release version. The release handler furthermore expects that a program like &lt;code&gt;start_erl.exe&lt;/code&gt; is specified as &quot;machine&quot; to &lt;code&gt;erlsrv&lt;/code&gt;. During upgrading with restart, a new service is registered and started. The new service is set to automatic and the old service is removed when the new release is made permanent.</source>
          <target state="translated">Windows NT上的仿真器重新启动期望使用 &lt;code&gt;erlsrv&lt;/code&gt; 程序（作为服务）启动系统。此外，发布处理程序希望该服务名为 &lt;code&gt;NodeName&lt;/code&gt; _ &lt;code&gt;Release&lt;/code&gt; ，其中 &lt;code&gt;NodeName&lt;/code&gt; 是Erlang节点名称的第一部分（最多但不包括&amp;ldquo; @&amp;rdquo;），而 &lt;code&gt;Release&lt;/code&gt; 是当前的发行版本。发布处理器还预计，等中的程序 &lt;code&gt;start_erl.exe&lt;/code&gt; 被指定为&amp;ldquo;机&amp;rdquo; &lt;code&gt;erlsrv&lt;/code&gt; 。在通过重新启动进行升级的过程中，将注册并启动新服务。将新版本永久化后，新服务将设置为自动，并且旧服务将被删除。</target>
        </trans-unit>
        <trans-unit id="e59343153e5b1fe6b3e23daad5cd40c9373e3696" translate="yes" xml:space="preserve">
          <source>The encoder and decoder can also be run from the shell:</source>
          <target state="translated">编码器和解码器也可以从shell中运行。</target>
        </trans-unit>
        <trans-unit id="5524aa1d01a0ef49a1ac5386a1c63b808ac68425" translate="yes" xml:space="preserve">
          <source>The encoder callback interface is defined by the &lt;code&gt;megaco_encoder&lt;/code&gt; behaviour, see &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">编码器回调接口由 &lt;code&gt;megaco_encoder&lt;/code&gt; 行为定义，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e115c3caf0848d64461367ca5e16e6bd2197d5d0" translate="yes" xml:space="preserve">
          <source>The encoding fails if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 在编码 &lt;code&gt;from_enc&lt;/code&gt; 中不是有效的字符串，则编码失败。</target>
        </trans-unit>
        <trans-unit id="09633aa618d0dc8af3be96ad739582e309ef108d" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">可以通过注释来设置 &lt;code&gt;Filename&lt;/code&gt; 的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="9ac74f2d9e4b6b15103658ee4d9051874ee9e500" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment, as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">可以通过注释设置 &lt;code&gt;Filename&lt;/code&gt; 的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="3d77e867cd506d61a5b722d136e431c9f033298c" translate="yes" xml:space="preserve">
          <source>The encoding of each file can be specified using comments as described in the &lt;code&gt;epp(3)&lt;/code&gt; module.</source>
          <target state="translated">可以使用注释来指定每个文件的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 模块中所述。</target>
        </trans-unit>
        <trans-unit id="9e2118a8dc4b068a3e8e22ff922dd1be302891f7" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (BER), Packed Encoding Rules (PER) aligned, and PER unaligned. If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">要使用的编码规则。支持的编码规则是基本编码规则（BER），对齐的压缩编码规则（PER）和未对齐的PER。如果省略了编码规则选项，则 &lt;code&gt;ber&lt;/code&gt; 为默认值。</target>
        </trans-unit>
        <trans-unit id="6f95e0e32837beadf0f93d78df4e27d5991fa179" translate="yes" xml:space="preserve">
          <source>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, must be set explicitly as follows:</source>
          <target state="translated">上面提到的注释所指定的编码适用于脚本本身。然而,I/O服务器的编码必须明确地设置如下。</target>
        </trans-unit>
        <trans-unit id="d1c828e598776df003c2646b5bcedb28e057c204" translate="yes" xml:space="preserve">
          <source>The encoding_config of the megaco_erl_dist_encoder module may be one of these:</source>
          <target state="translated">megaco_erl_dist_encoder模块的encoding_config可以是其中之一。</target>
        </trans-unit>
        <trans-unit id="f48fa03ddf781f161c43a06b94c0c75681b96550" translate="yes" xml:space="preserve">
          <source>The endianness specification can be either &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, or &lt;code&gt;native&lt;/code&gt;. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is &quot;native&quot; for the CPU that the Erlang machine is run on.</source>
          <target state="translated">字节序规范可以是 &lt;code&gt;big&lt;/code&gt; ， &lt;code&gt;little&lt;/code&gt; 或 &lt;code&gt;native&lt;/code&gt; 。Native-endian表示在加载时将endian解析为big-endian或little-endian，具体取决于运行Erlang机器的CPU的&amp;ldquo;本机&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="60e0f49d56e51cf1a5d46c013c216c0ae5dc1eb9" translate="yes" xml:space="preserve">
          <source>The entire contents of the cache will be deleted.</source>
          <target state="translated">缓存的全部内容将被删除。</target>
        </trans-unit>
        <trans-unit id="a01a496ea7149df2179e8879a105341306c0f911" translate="yes" xml:space="preserve">
          <source>The entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, even when a list of objects is inserted.</source>
          <target state="translated">即使插入了对象列表，也可以保证整个操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="e7a75cc762ec33088a0ac070865ceb613941ab44" translate="yes" xml:space="preserve">
          <source>The entire program is motorcycles2html.erl:</source>
          <target state="translated">整个程序为motorcycles2html.erl。</target>
        </trans-unit>
        <trans-unit id="ac7e661e53cfa83634f92105a4582a374de077bb" translate="yes" xml:space="preserve">
          <source>The entire tar file is compressed, as if it has been run through the &lt;code&gt;gzip&lt;/code&gt; program. To abide to the convention that a compressed tar file is to end in &quot;&lt;code&gt;.tar.gz&lt;/code&gt;&quot; or &quot;&lt;code&gt;.tgz&lt;/code&gt;&quot;, add the appropriate extension.</source>
          <target state="translated">整个tar文件已压缩，就好像它已通过 &lt;code&gt;gzip&lt;/code&gt; 程序运行一样。为了遵守压缩的tar文件以&amp;ldquo; &lt;code&gt;.tar.gz&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;.tgz&lt;/code&gt; &amp;rdquo; 结尾的约定，请添加适当的扩展名。</target>
        </trans-unit>
        <trans-unit id="e1f58ced4a1c7fafa8f4a838e0a3347b18963414" translate="yes" xml:space="preserve">
          <source>The entities involved in this model are the agent, which terminates the management protocol, and the resources, which is to be managed, that is, the actual application entities. The resources should in general have no knowledge of the management protocol used, and the agent should have no knowledge of the managed resources. This implies that a translation mechanism is needed, to translate the management operations to operations on the resources. This translation mechanism is usually called &lt;strong&gt;instrumentation&lt;/strong&gt; and the function that implements it is called &lt;strong&gt;instrumentation function&lt;/strong&gt;. The instrumentation functions are written for each combination of management protocol and resource to be managed. For example, if an application is to be managed by SNMP and HTTP, two sets of instrumentation functions are defined; one that maps SNMP requests to the resources, and one that, for example, generates an HTML page for some resources.</source>
          <target state="translated">此模型中涉及的实体是终止管理协议的代理，以及要管理的资源，即实际的应用程序实体。通常，资源应该不了解所使用的管理协议，而代理也不应该了解所管理的资源。这意味着需要一种转换机制，以将管理操作转换为对资源的操作。这种转换机制通常称为&lt;strong&gt;检测&lt;/strong&gt;功能，而实现该功能的功能称为&lt;strong&gt;检测功能&lt;/strong&gt;。为管理协议和要管理的资源的每种组合编写工具功能。例如，如果一个应用程序要由SNMP和HTTP管理，则定义了两组检测功能；即：一种将SNMP请求映射到资源，另一种例如为某些资源生成HTML页面。</target>
        </trans-unit>
        <trans-unit id="fc41ee140a0e19b3389932dacfd061ee5abd2931" translate="yes" xml:space="preserve">
          <source>The entry format in all files are Erlang terms, separated by a '&lt;strong&gt;.&lt;/strong&gt;' and a &lt;strong&gt;newline&lt;/strong&gt;. In the following sections, the formats of these terms are described. Comments may be specified as ordinary Erlang comments.</source>
          <target state="translated">所有文件中的输入格式均为Erlang术语，以'分隔&lt;strong&gt;。&lt;/strong&gt;和一个&lt;strong&gt;换行符&lt;/strong&gt;。在以下各节中，将描述这些术语的格式。注释可以指定为普通的Erlang注释。</target>
        </trans-unit>
        <trans-unit id="cb54532373ef856c343b0b5dff86075c30ed3fbc" translate="yes" xml:space="preserve">
          <source>The entry point of the process, that is, what function was referenced in the &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt; call that started the process.</source>
          <target state="translated">流程的入口点，即启动流程的 &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;spawn_link&lt;/code&gt; 调用中引用了什么函数。</target>
        </trans-unit>
        <trans-unit id="7f963220ca94e530caaeba1df441378f7d481672" translate="yes" xml:space="preserve">
          <source>The enumerated type is similar to an integer type, when defined with a set of predefined values. The difference is that an enumerated type can only have specified values, whereas an integer can have any value.</source>
          <target state="translated">当用一组预定义的值定义时,枚举类型与整数类型类似。不同的是,枚举型只能有指定的值,而整数型可以有任何值。</target>
        </trans-unit>
        <trans-unit id="a3be6551e42e26d4ead34f786dcb51c0272efaf5" translate="yes" xml:space="preserve">
          <source>The environment can also affect filename interpretation, if Erlang is started with flag &lt;code&gt;+fna&lt;/code&gt; (which is default from Erlang/OTP 17.0).</source>
          <target state="translated">如果Erlang以标志 &lt;code&gt;+fna&lt;/code&gt; （这是Erlang / OTP 17.0的默认值）启动，则环境也会影响文件名的解释。</target>
        </trans-unit>
        <trans-unit id="913d6ab5c0934539b281e92b0bf02bbbfef5d5f9" translate="yes" xml:space="preserve">
          <source>The environment of an Erlang machine started as a service contains two special variables:</source>
          <target state="translated">作为服务启动的Erlang机器的环境包含两个特殊变量。</target>
        </trans-unit>
        <trans-unit id="572b1efce0a6ff1c606a8d7cea991c683d1b2312" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must be &lt;code&gt;NULL&lt;/code&gt; only if calling from a created thread.</source>
          <target state="translated">调用过程的环境。仅当从创建的线程调用时，才必须为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08711127236c0db559a0b4dc910c12dabe3750d5" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must not be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">调用过程的环境。不能为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdd010a7cf9f07e2e5e5be6548225fb6c23b8fd6" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">消息术语的环境。可以是分配给 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;NULL&lt;/code&gt; 的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="3da50f98e6b47c2b008dfdf790cd4b0c2b6bf64d" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">消息术语的环境。必须是分配有 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或NULL的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="2fa8fc26b6ef033d7a364376d908df5f6b781167" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; can be used to indicate which logical cluster a C-node belongs to.</source>
          <target state="translated">环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 可用于指示C节点属于哪个逻辑集群。</target>
        </trans-unit>
        <trans-unit id="e087dc753b87601d38d03f83c1f1759586e203d5" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; can be used to configure the heart time-outs; it can be set in the operating system shell before Erlang is started or be specified at the command line:</source>
          <target state="translated">环境变量 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 可用于配置心跳超时。它可以在启动Erlang之前在操作系统外壳中设置，也可以在命令行中指定：</target>
        </trans-unit>
        <trans-unit id="6dd0dd179f2f7ae89d1e41f5898aa9a98a1d1adc" translate="yes" xml:space="preserve">
          <source>The environment variables can also be used to detect that we are running as a service and make port programs react correctly to the control events generated on logout (see the next section).</source>
          <target state="translated">环境变量也可以用来检测我们是否以服务的形式运行,并使 port 程序对注销时产生的控制事件做出正确的反应 (参见下一节)。</target>
        </trans-unit>
        <trans-unit id="0155a47d2e3d28b9149121cf101f2c0d304723b6" translate="yes" xml:space="preserve">
          <source>The erl scheme is designed to mimic plain CGI, but without the extra overhead. An URL that calls an Erlang &lt;code&gt;erl&lt;/code&gt; function has the following syntax (regular expression):</source>
          <target state="translated">erl方案旨在模仿普通CGI，但没有额外的开销。调用Erlang &lt;code&gt;erl&lt;/code&gt; 函数的URL 具有以下语法（正则表达式）：</target>
        </trans-unit>
        <trans-unit id="9f146c11c8615922912cc793d4380f3827809366" translate="yes" xml:space="preserve">
          <source>The erlang connection process spawned by connect/2, will open a port to a c-process that handles the communication with the database through Microsoft's ODBC API. The erlang port will be kept open for exit signal propagation, if something goes wrong in the c-process and it exits we want know as mush as possible about the reason. The main communication with the c-process is done through sockets. The C-process consists of two threads, the supervisor thread and the database handler thread. The supervisor thread checks for shutdown messages on the supervisor socket and the database handler thread receives requests and sends answers on the database socket. If the database thread seems to hang on some database call, the erlang control process will send a shutdown message on the supervisor socket, in this case the c-process will exit. If the c-process crashes/exits it will bring the erlang-process down too and vice versa i.e. the connection is terminated.</source>
          <target state="translated">由 connect/2 生成的 erlang 连接进程将打开一个端口,通过微软的 ODBC API 处理与数据库的通信。如果c进程出了问题,退出了,我们希望尽可能多的了解原因。与c进程的主要通信是通过套接字完成的。c进程由两个线程组成,即监督线程和数据库处理线程。主管线程在主管套接字上检查是否有挂起消息,数据库处理线程在数据库套接字上接收请求并发送应答。如果数据库线程似乎挂在某个数据库调用上,erlang控制进程会在主管套接字上发送一个关闭消息,在这种情况下,c进程会退出。如果c进程崩溃/退出,会使erlang进程也崩溃,反之亦然,即连接被终止。</target>
        </trans-unit>
        <trans-unit id="df7997d41de6ac2a1785cee171c352d42d04f93c" translate="yes" xml:space="preserve">
          <source>The error behavior differs, see below.</source>
          <target state="translated">错误行为不同,见下文。</target>
        </trans-unit>
        <trans-unit id="011b09627444a05b2b15d34028f40a28dfdddfe0" translate="yes" xml:space="preserve">
          <source>The error descriptor defaults to &lt;code&gt;DefaultED&lt;/code&gt;, but can be overridden with an alternate one by returning &lt;code&gt;{reply,ED}&lt;/code&gt; or &lt;code&gt;{no_reply,ED}&lt;/code&gt; instead of &lt;code&gt;reply&lt;/code&gt; and &lt;code&gt;no_reply&lt;/code&gt; respectively.</source>
          <target state="translated">错误描述符默认为 &lt;code&gt;DefaultED&lt;/code&gt; ，但可以通过返回 &lt;code&gt;{reply,ED}&lt;/code&gt; 或 &lt;code&gt;{no_reply,ED}&lt;/code&gt; 而不是分别为 &lt;code&gt;reply&lt;/code&gt; 和 &lt;code&gt;no_reply&lt;/code&gt; 来替代它。</target>
        </trans-unit>
        <trans-unit id="461fac531aaf141393d180babf97f72d93ada5dc" translate="yes" xml:space="preserve">
          <source>The error handling strategy and possible errors sources are described in the Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">错误处理策略和可能的错误源在《 Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="5d405471c43706742d66ca4dd53edcd35e7ff6cb" translate="yes" xml:space="preserve">
          <source>The error information is handled by Logger, which is part of the Kernel application.</source>
          <target state="translated">错误信息由Kernel应用程序的一部分--Logger处理。</target>
        </trans-unit>
        <trans-unit id="9eb4cd48329bca9a99f8dc4cb317a0559bc9784e" translate="yes" xml:space="preserve">
          <source>The error message will look like this:</source>
          <target state="translated">错误信息会是这样的。</target>
        </trans-unit>
        <trans-unit id="3061a1ab3e6a1d434208df5bfeb44852fc476d18" translate="yes" xml:space="preserve">
          <source>The error report module is configured using the directive &lt;code&gt;error_report_mod&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用伪指令 &lt;code&gt;error_report_mod&lt;/code&gt; 配置错误报告模块，请参见 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36a00c6827ff6af3c91907db56029def4bf079b7" translate="yes" xml:space="preserve">
          <source>The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.</source>
          <target state="translated">错误和警告按在表格中遇到的顺序列出。因此,一个文件中的错误可以被分割成不同的错误列表条目。</target>
        </trans-unit>
        <trans-unit id="0e3460fc594164d8bbf96577fb24868bb714be37" translate="yes" xml:space="preserve">
          <source>The errors detected include:</source>
          <target state="translated">检测到的错误包括:</target>
        </trans-unit>
        <trans-unit id="b62e06cf6a78a94894293a2f2fefb7491e659ccc" translate="yes" xml:space="preserve">
          <source>The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.</source>
          <target state="translated">转义符&quot;/o &quot;后面必须有一串八进制数字,用括号括起来。如果不是这样,就会出现错误。这个转义符是最近在Perl中增加的,它提供了一种方法来指定字符代码点为大于0777的八进制数字,并且它还允许毫不含糊地指定八进制数字和反向引用。</target>
        </trans-unit>
        <trans-unit id="e09cca6482e14cefd7789aca27e688d2b8fc2ae0" translate="yes" xml:space="preserve">
          <source>The escape sequence \K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</source>
          <target state="translated">转义序列\K会导致任何之前匹配的字符不被包含在最终的匹配序列中。例如,下面的模式匹配 &quot;foobar&quot;,但报告说它已经匹配了 &quot;bar&quot;。</target>
        </trans-unit>
        <trans-unit id="1fdcd1532b972da832570c4e46f8a01588e3f319" translate="yes" xml:space="preserve">
          <source>The escape sequence \N behaves like a dot, except that it is not affected by option &lt;code&gt;PCRE_DOTALL&lt;/code&gt;. That is, it matches any character except one that signifies the end of a line. Perl also uses \N to match characters by name but PCRE does not support this.</source>
          <target state="translated">转义序列\ N的行为类似于点，但它不受选项 &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 的影响。也就是说，它匹配除表示行尾的字符以外的任何字符。Perl还使用\ N来按名称匹配字符，但是PCRE不支持此功能。</target>
        </trans-unit>
        <trans-unit id="9ac8458115fbc9af33358e4aea3bbde3c0be1319" translate="yes" xml:space="preserve">
          <source>The escape sequences allowed are the same as for Erlang strings:</source>
          <target state="translated">允许的转义序列与Erlang字符串相同。</target>
        </trans-unit>
        <trans-unit id="32812c856e631f3ed1dcd90e3601c5c2b3077c8f" translate="yes" xml:space="preserve">
          <source>The eval scheme can seriously threaten the integrity of the Erlang node housing a web server, for example:</source>
          <target state="translated">例如,评价方案会严重威胁到容纳web服务器的Erlang节点的完整性。</target>
        </trans-unit>
        <trans-unit id="21baa0e66c42986302a436c2cc18ea33ca352672" translate="yes" xml:space="preserve">
          <source>The eval scheme is straight-forward and does not mimic the behavior of plain CGI. An URL that calls an Erlang &lt;code&gt;eval&lt;/code&gt; function has the following syntax:</source>
          <target state="translated">评估方案简单明了，没有模仿普通CGI的行为。调用Erlang &lt;code&gt;eval&lt;/code&gt; 函数的URL 具有以下语法：</target>
        </trans-unit>
        <trans-unit id="10a18f07017de460e02711d1cf0600325f33b7fb" translate="yes" xml:space="preserve">
          <source>The evaluation of the query fails if the &lt;code&gt;qlc&lt;/code&gt; module cannot carry out the chosen join method. Defaults to &lt;code&gt;any&lt;/code&gt;, which means that some fast join method is used if possible.</source>
          <target state="translated">如果 &lt;code&gt;qlc&lt;/code&gt; 模块无法执行所选的联接方法，则查询评估失败。默认为 &lt;code&gt;any&lt;/code&gt; ，这意味着在可能的情况下使用某种快速连接方法。</target>
        </trans-unit>
        <trans-unit id="fa8e9b7cfecc247f7bff705d3a3988485befc88c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed (user) type application expression.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的（用户）类型的应用程序表达式，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4921b565820162e2c60edc6bea683451b957b890" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed &lt;code&gt;file&lt;/code&gt; attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的 &lt;code&gt;file&lt;/code&gt; 属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="618ce4cbe8b9ff30f535342ccae4d3cf10b313ea" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed application expression.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的应用程序表达式，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7fabf51da4bb4e7f1257e9d4dede7a0e536748" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed export attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的导出属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f66579024f348d7bb0f390e794429a5be199446" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function definition.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的函数定义，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5406ed8fb8fc38e89372ce85d6f56374209215a4" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function name.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的函数名称，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30e8edf0d9aca5a1873eb5bed65e4d0bd6633e76" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed implicit fun.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的隐式乐趣，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbc54914d2a7b46a8529bdd08a5e3617825c157" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed import attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的导入属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce44851dc662379c8d2493f03d24234da3c175f" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed module attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的模块属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d8a2fbebf4113ef3337fce36bf9fbf369a6379" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record declaration attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的记录声明属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf9e76769c09ba06d5b9bf9c1944e2acfb2dfc1a" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record field specifier.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的记录字段说明 &lt;code&gt;syntax_error&lt;/code&gt; 则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="ea05ee075bf7f2350e2fc6059b34cff5cb33b78c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed type name.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的类型名称，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="363e188710c96a0d0d2f45cbb80bd88dddfe084d" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed wild attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的Wild属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="223a63e0ec00c2810aadc750354eca2f59b6acb8" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not well-formed.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 的 &lt;code&gt;syntax_error&lt;/code&gt; 不正确，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="527c092490ea3417d05959de64ac4673c4e2242c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; represents a record expression that is not well-formed.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 表示 &lt;code&gt;syntax_error&lt;/code&gt; 的记录表达式，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="78caee1b9d51c269ecfa277516c192bac800da86" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if an ill-formed Erlang construct is encountered.</source>
          <target state="translated">如果遇到 &lt;code&gt;syntax_error&lt;/code&gt; 不正确的Erlang构造，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="e360281a65b675290b77c855abb3396feae48026" translate="yes" xml:space="preserve">
          <source>The event &lt;code&gt;user_unblock&lt;/code&gt; is not triggered when a user is removed from the block list explicitly using the &lt;code&gt;unblock_user&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;unblock_user&lt;/code&gt; 函数将用户从阻止列表中明确删除时，不会触发事件 &lt;code&gt;user_unblock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9adf6f3e6bc9d678bcfcbf56c75783efdc79bfe" translate="yes" xml:space="preserve">
          <source>The event handler must be able to handle the events in this module, see section &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">事件处理程序必须能够处理此模块中的事件，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="07fadfa5cd3629d9138971bd824a14ddd43b2990" translate="yes" xml:space="preserve">
          <source>The event handler return values are defined in the description of &lt;code&gt;Module:StateName/3&lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">在 &lt;code&gt;gen_statem&lt;/code&gt; 手册页的 &lt;code&gt;Module:StateName/3&lt;/code&gt; 的描述中定义了事件处理程序的返回值，但这是一个更具可读性的列表：</target>
        </trans-unit>
        <trans-unit id="9b5aab32f54b078cb1c0faaf00cf7eb4a19eec31" translate="yes" xml:space="preserve">
          <source>The event handler terminates abnormally and &lt;code&gt;gen_event&lt;/code&gt; logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">事件处理程序异常终止，并且 &lt;code&gt;gen_event&lt;/code&gt; 记录错误。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7f89716df5f45b5490450ec2ac15b0b43b462e0" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler.</source>
          <target state="translated">该事件由默认的Logger处理程序处理。</target>
        </trans-unit>
        <trans-unit id="2545cd2dda316056d2647ebcf0c0876379df39a7" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler. The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该事件由默认的Logger处理程序处理。日志级别可以更改为错误或信息，请参阅 &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836db6626acc8d2b63d4479e731dd11320410d43" translate="yes" xml:space="preserve">
          <source>The event is handled by:</source>
          <target state="translated">该事件的处理方式是:</target>
        </trans-unit>
        <trans-unit id="670f3a97ec79b1617d1253c86abd242fbfe96cb8" translate="yes" xml:space="preserve">
          <source>The event is made into a message and sent to the event manager. When the event is received, the event manager calls &lt;code&gt;handle_event(Event, State)&lt;/code&gt; for each installed event handler, in the same order as they were added. The function is expected to return a tuple &lt;code&gt;{ok,State1}&lt;/code&gt;, where &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the event handler.</source>
          <target state="translated">该事件将成为消息并发送到事件管理器。接收到事件后，事件管理器将为每个已安装的事件处理程序按添加时的相同顺序调用 &lt;code&gt;handle_event(Event, State)&lt;/code&gt; 。该函数应返回一个元组 &lt;code&gt;{ok,State1}&lt;/code&gt; ，其中 &lt;code&gt;State1&lt;/code&gt; 是事件处理程序状态的新值。</target>
        </trans-unit>
        <trans-unit id="b73ba2f2d96d9d903429f26f68141cab3925fb1c" translate="yes" xml:space="preserve">
          <source>The event is sent to the &lt;code&gt;gen_statem&lt;/code&gt;. When the event is received, the &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt;, or &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt;. &lt;code&gt;StateName&lt;/code&gt; is the name of the current state and &lt;code&gt;NewStateName&lt;/code&gt; is the name of the next state to go to. &lt;code&gt;NewData&lt;/code&gt; is a new value for the server data of the &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;Actions&lt;/code&gt; is a list of actions to be performed by the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">该事件被发送到 &lt;code&gt;gen_statem&lt;/code&gt; 。收到事件后， &lt;code&gt;gen_statem&lt;/code&gt; 调用 &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt; ，该状态应返回一个元组 &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt; 或 &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt; 。 &lt;code&gt;StateName&lt;/code&gt; 是当前状态的名称， &lt;code&gt;NewStateName&lt;/code&gt; 是要转到的下一个状态的名称。 &lt;code&gt;NewData&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 的服务器数据的新值，而 &lt;code&gt;Actions&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 引擎要执行的操作的列表。</target>
        </trans-unit>
        <trans-unit id="482c8d79933fe33bda06c58901ec825b1db485ea" translate="yes" xml:space="preserve">
          <source>The event manager essentially maintains a list of &lt;code&gt;{Module, State}&lt;/code&gt; pairs, where each &lt;code&gt;Module&lt;/code&gt; is an event handler, and &lt;code&gt;State&lt;/code&gt; is the internal state of that event handler.</source>
          <target state="translated">事件管理器实质上维护 &lt;code&gt;{Module, State}&lt;/code&gt; 对的列表，其中每个 &lt;code&gt;Module&lt;/code&gt; 是事件处理程序，而 &lt;code&gt;State&lt;/code&gt; 是该事件处理程序的内部状态。</target>
        </trans-unit>
        <trans-unit id="76d57c410515c44cc8bc28a8d09b64ef1f2639aa" translate="yes" xml:space="preserve">
          <source>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, it terminates if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent.</source>
          <target state="translated">如果事件管理器是监视树的一部分，并且由其主管命令终止，则终止。即使它&lt;strong&gt;不是&lt;/strong&gt;监督树的一部分，但如果它从其父级收到 &lt;code&gt;'EXIT'&lt;/code&gt; 消息，它也会终止。</target>
        </trans-unit>
        <trans-unit id="c2ce4c38c0aa823b9e5e74e4d8bcd2d1c4f1111f" translate="yes" xml:space="preserve">
          <source>The event tracer framework is made up of four modules:</source>
          <target state="translated">事件追踪框架由四个模块组成。</target>
        </trans-unit>
        <trans-unit id="d0f7cae16de84ad2c9c39b99cb4c031af931d1d5" translate="yes" xml:space="preserve">
          <source>The event types are described in the next sections.</source>
          <target state="translated">事件类型将在下一节描述。</target>
        </trans-unit>
        <trans-unit id="f1782c63eb3688ca0c9af0612dd19da36a393122" translate="yes" xml:space="preserve">
          <source>The events are also documented in &lt;code&gt;ct_event.erl&lt;/code&gt;. This module can serve as an example of what an event handler for the &lt;code&gt;Common Test&lt;/code&gt; event manager can look like.</source>
          <target state="translated">这些事件也记录在 &lt;code&gt;ct_event.erl&lt;/code&gt; 中。该模块可以作为 &lt;code&gt;Common Test&lt;/code&gt; 事件管理器的事件处理程序外观的示例。</target>
        </trans-unit>
        <trans-unit id="fa54bda16841cabde0c2e6fc00114e179e4c8c7f" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用事件生成过程定义的函数对事件进行格式化（调用 &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d4c6263423994284ba2b9c6d7623abbea04412" translate="yes" xml:space="preserve">
          <source>The example &lt;code&gt;Subject&lt;/code&gt; field has one C, two CN and one O part. It is only the CN (Common Name) that is used by hostname verification. The two other (C and O) is not used here even when they contain a domain name like the O part. The C and O parts are defined elsewhere and meaningful only for other functions.</source>
          <target state="translated">示例 &lt;code&gt;Subject&lt;/code&gt; 字段具有一个C，两个CN和一个O部分。主机名验证仅使用CN（通用名）。即使另外两个（C和O）包含域名（如O部分），也不会在此处使用。C和O部分在其他地方定义，仅对其他功能有意义。</target>
        </trans-unit>
        <trans-unit id="53789d2e92c1fda46d0fae07ec08f87e98bdd01d" translate="yes" xml:space="preserve">
          <source>The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.</source>
          <target state="translated">例子中的I/O服务器将字符存储在ETS表中,构成了一个相当粗糙的RAM文件。</target>
        </trans-unit>
        <trans-unit id="3a18dec0331c54c7d131f7f05a54cda624c44be5" translate="yes" xml:space="preserve">
          <source>The example below sets up trace on the exported functions (default) of module &lt;code&gt;snmp_generic&lt;/code&gt; and all functions of module &lt;code&gt;snmp_generic_mnesia&lt;/code&gt;. With return values (which is default) and timestamps in both cases (which is also default):</source>
          <target state="translated">下面的示例对模块 &lt;code&gt;snmp_generic&lt;/code&gt; 的导出函数（默认）和模块snmp_generic_mnesia的所有函数进行设置 &lt;code&gt;snmp_generic_mnesia&lt;/code&gt; 。在两种情况下都带有返回值（这是默认值）和时间戳（这也是默认值）：</target>
        </trans-unit>
        <trans-unit id="40ec67cee0f09e7e1f38061d74546bfcd1432fac" translate="yes" xml:space="preserve">
          <source>The example manager, &lt;code&gt;snmp_ex2_manager&lt;/code&gt;, is a simple example of how to implement an snmp manager using the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">示例管理器 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 是有关如何使用SNMP开发工具包的管理器组件实现snmp管理器的简单示例。</target>
        </trans-unit>
        <trans-unit id="bfa0e44fefc9103dfe63a4cd1030807bc049d616" translate="yes" xml:space="preserve">
          <source>The example servers so far in this chapter print the full internal state in the error log, for example, when killed by an exit signal or because of an internal error. This state contains both the code lock code and which digits that remain to unlock.</source>
          <target state="translated">本章到目前为止的例子服务器在错误日志中打印了完整的内部状态,例如,当被退出信号杀死或因为内部错误时。这个状态既包含了代码锁定码,也包含了哪些还未解锁的数字。</target>
        </trans-unit>
        <trans-unit id="266205b844f4f6e3267e956b4430b205e05dad6e" translate="yes" xml:space="preserve">
          <source>The example showed the background work that the shell performs just to interpret the first command line. Most work is done by &lt;code&gt;erl_eval&lt;/code&gt; and &lt;code&gt;orddict&lt;/code&gt;.</source>
          <target state="translated">该示例显示了shell只是为了解释第一个命令行而执行的后台工作。大多数工作由 &lt;code&gt;erl_eval&lt;/code&gt; 和 &lt;code&gt;orddict&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="8f7ad9497d8d5ee7ec068f8bbaf412b434e2689f" translate="yes" xml:space="preserve">
          <source>The example shown can be found in the toolkit distribution.</source>
          <target state="translated">所示的例子可以在工具包发行版中找到。</target>
        </trans-unit>
        <trans-unit id="396a52ee352a84ef61ae01c6d40809962c1134e8" translate="yes" xml:space="preserve">
          <source>The example shown, &lt;strong&gt;ex2&lt;/strong&gt;, can be found in the toolkit distribution.</source>
          <target state="translated">显示的示例&lt;strong&gt;ex2&lt;/strong&gt;可以在工具包发行版中找到。</target>
        </trans-unit>
        <trans-unit id="ab7c4a3f89e04c623143e7c4c121106db17b0068" translate="yes" xml:space="preserve">
          <source>The example shows some details of how &lt;code&gt;lists:sort/1&lt;/code&gt; works. It used 6047 function calls in the module &lt;code&gt;lists_sort&lt;/code&gt; to complete the work.</source>
          <target state="translated">该示例显示了 &lt;code&gt;lists:sort/1&lt;/code&gt; 工作原理的一些细节。它在 &lt;code&gt;lists_sort&lt;/code&gt; 模块中使用了6047个函数调用来完成工作。</target>
        </trans-unit>
        <trans-unit id="361c007ea7390ae514b7d7274e3225478c75cf81" translate="yes" xml:space="preserve">
          <source>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</source>
          <target state="translated">这个例子指定了两个方向(client2server和server2client)的不同算法,对于密码,但指定了两个方向的mac和压缩的相同算法。kex(密钥交换)是隐式的,但public_key是显式设置的。</target>
        </trans-unit>
        <trans-unit id="c97ac9647ab00e65e37eca74aa7e20c8819a73a3" translate="yes" xml:space="preserve">
          <source>The example specifies that:</source>
          <target state="translated">本例规定:</target>
        </trans-unit>
        <trans-unit id="839951ee6733677e5315d3af4eb38dc5514df04f" translate="yes" xml:space="preserve">
          <source>The example specifies the following:</source>
          <target state="translated">本例规定如下:</target>
        </trans-unit>
        <trans-unit id="5e9468869847362818e3653dadf86b7f55f088d1" translate="yes" xml:space="preserve">
          <source>The example tells us that &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot; was registered on a Monday (since the return value of the first command is 1), and that the &lt;code&gt;calendar&lt;/code&gt; module needed 9 function calls to calculate that.</source>
          <target state="translated">该示例告诉我们，&amp;ldquo; Aktiebolaget LM Ericsson＆Co&amp;rdquo;是在星期一注册的（因为第一个命令的返回值为1），并且 &lt;code&gt;calendar&lt;/code&gt; 模块需要9个函数调用来计算该值。</target>
        </trans-unit>
        <trans-unit id="4ffa934118cebf3f90cde4787faaae21bba8d06a" translate="yes" xml:space="preserve">
          <source>The exec-option fun is called with the same number of parameters as the arity of the fun, and the result is returned to the client.</source>
          <target state="translated">调用exec-option fun时,参数数与fun的arity相同,结果返回给客户端。</target>
        </trans-unit>
        <trans-unit id="b071e577cae1eeba87f1871188878bd3a2873b58" translate="yes" xml:space="preserve">
          <source>The exec-option has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-4 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">exec-option已经存在了很长时间,但以前没有被记录下来。旧的定义和行为被保留,但如果有冲突,则遵守上面的规则1-4。在新程序中不应该使用旧的和未被记录的样式。</target>
        </trans-unit>
        <trans-unit id="b1895955082bfa77ca24a94c48e11688ebe85d9a" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client.</source>
          <target state="translated">exec-request没有被评估,并向客户端返回一个错误信息。</target>
        </trans-unit>
        <trans-unit id="0c24b69b74e8713f113ddc4cb4727d97ca1bd44b" translate="yes" xml:space="preserve">
          <source>The executable name (also known as &lt;code&gt;argv[0]&lt;/code&gt;) is not to be specified in this list. The proper executable name is automatically used as &lt;code&gt;argv[0]&lt;/code&gt;, where applicable.</source>
          <target state="translated">可执行文件名称（也称为 &lt;code&gt;argv[0]&lt;/code&gt; ）不在此列表中指定。适当的可执行文件名称会自动用作 &lt;code&gt;argv[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7703497b2d1d6d7ae666f5086932193209c602a9" translate="yes" xml:space="preserve">
          <source>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</source>
          <target state="translated">当运行时系统决定是否要发送跟踪消息时,匹配表达式的执行情况如下。</target>
        </trans-unit>
        <trans-unit id="f2a8e42abde3dd1496d089519cf10c81e1be53df" translate="yes" xml:space="preserve">
          <source>The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块功能的执行时间取决于对列表进行排序所花费的时间。当不需要排序时，在最坏的情况下，执行时间与输入参数和返回值的大小之和成比例。一些函数在恒定时间内执行： &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="420632c27cadb89b2f399b84682c82a68f0a0d31" translate="yes" xml:space="preserve">
          <source>The existing association argument &lt;code&gt;Assoc&lt;/code&gt; can be either a &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; record as returned from, for example, &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, or from a listening socket in active mode. It can also be just the field &lt;code&gt;assoc_id&lt;/code&gt; integer from such a record.</source>
          <target state="translated">现有的关联参数 &lt;code&gt;Assoc&lt;/code&gt; 可以是 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 记录，例如从 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 或活动模式下的侦听套接字返回的记录。它也可以只是来自此类记录的字段 &lt;code&gt;assoc_id&lt;/code&gt; 整数。</target>
        </trans-unit>
        <trans-unit id="78f8f6f791625c1c8fdb334b26d42632cd9d6c18" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt;Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Errors and Error Handling&lt;/code&gt; 中描述了运行时系统使用的退出原因（例如 &lt;code&gt;badarg&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d5ae7040a803e376f91e7e700a11833b4ef1676c" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">退出值可以稍后由另一个线程通过 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 检索。</target>
        </trans-unit>
        <trans-unit id="5fde359ee385d3e78714231ab869d10ea4d9e799" translate="yes" xml:space="preserve">
          <source>The exported function &lt;code&gt;f/1&lt;/code&gt; is deprecated. Nothing is said whether &lt;code&gt;f/1&lt;/code&gt; will be removed or not.</source>
          <target state="translated">不推荐使用导出的函数 &lt;code&gt;f/1&lt;/code&gt; 。没有说是否可以删除 &lt;code&gt;f/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e6598c7dcf7a2b613f4f2e9c2f96997e697806" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;Expr&lt;/code&gt; is evaluated and the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result. If a match succeeds and the optional guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;Body&lt;/code&gt; is evaluated.</source>
          <target state="translated">计算表达式 &lt;code&gt;Expr&lt;/code&gt; ，然后将模式 &lt;code&gt;Pattern&lt;/code&gt; 与结果进行顺序匹配。如果匹配成功，并且可选的保护序列 &lt;code&gt;GuardSeq&lt;/code&gt; 为true，则将评估相应的 &lt;code&gt;Body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb08adeb4f1b661f39b36975cfaf70cfc2a2ac3a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; is the list of all elements in &lt;code&gt;T&lt;/code&gt; that are less than &lt;code&gt;Pivot&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 中所有小于 &lt;code&gt;Pivot&lt;/code&gt; 的元素的列表。</target>
        </trans-unit>
        <trans-unit id="a1e90b9cd13dd08f75832cad1c6cf3f69ae835ff" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; is processed by the Erlang preprocessor and returns a list of the record field names. With the record definition &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt;, the expression &lt;code&gt;record_info(fields,foo)&lt;/code&gt; is expanded to the list &lt;code&gt;[x,y,z]&lt;/code&gt;. It is therefore possible for you to provide the attribute names or to use the &lt;code&gt;record_info/2&lt;/code&gt; notation.</source>
          <target state="translated">表达式 &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; 由Erlang预处理程序处理，并返回记录字段名称的列表。使用记录定义 &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt; ，将 &lt;code&gt;record_info(fields,foo)&lt;/code&gt; 表达式扩展到列表 &lt;code&gt;[x,y,z]&lt;/code&gt; 。因此，可以提供属性名称或使用 &lt;code&gt;record_info/2&lt;/code&gt; 表示法。</target>
        </trans-unit>
        <trans-unit id="46c25aa4f264a013c217a6e6c0cd1f11966c0297" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">扩展编码仅在磁盘文件（通过功能 &lt;code&gt;file:open/2&lt;/code&gt; ）上受支持。</target>
        </trans-unit>
        <trans-unit id="2a6444a6ceb013adde9ead96d92efa55f0f4c658" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">写入文件页脚的扩展信息，以便在从表加载文件期间进行更强的验证，如对 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 所指定。请注意，此功能只告诉&lt;strong&gt;其&lt;/strong&gt;信息存在，而不是在文件尾的值。该值是一个包含一个或多个原子 &lt;code&gt;object_count&lt;/code&gt; 和 &lt;code&gt;md5sum&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="7699dc7022a8a1b6e975d2c9f7052dbc61739221" translate="yes" xml:space="preserve">
          <source>The extensible agent in this toolkit understands the SNMPv1, SNMPv2c and SNMPv3. Recall that SNMP consists of two separate parts, the MIB definition language (SMI), and the protocol. On the protocol level, the agent can be configured to speak v1, v2c, v3 or any combination of them at the same time, i.e. a v1 request gets an v1 reply, a v2c request gets a v2c reply, and a v3 request gets a v3 reply. On the MIB level, the MIB compiler can compile both SMIv1 and SMIv2 MIBs. Once compiled, any of the formats can be loaded into the agent, regardless of which protocol version the agent is configured to use. This means that the agent translates from v2 notifications to v1 traps, and vice versa. For example, v2 MIBs can be loaded into an agent that speaks v1 only. The procedures for the translation between the two protocols are described in RFC 1908 and RFC 2089.</source>
          <target state="translated">该工具包中的可扩展代理了解SNMPv1、SNMPv2c和SNMPv3。回顾一下,SNMP由两个独立的部分组成,MIB定义语言(SMI)和协议。在协议层面,可以配置代理同时讲v1、v2c、v3或它们的任意组合,即v1请求得到v1回复,v2c请求得到v2c回复,v3请求得到v3回复。在MIB层面,MIB编译器可以同时编译SMIv1和SMIv2 MIB。一旦编译完成,任何一种格式都可以加载到代理中,而不管代理被配置成使用哪个协议版本。这意味着代理可以将v2通知翻译成v1陷阱,反之亦然。例如,v2 MIB可以加载到一个只讲v1的代理中。RFC 1908和RFC 2089中描述了两种协议之间的翻译程序。</target>
        </trans-unit>
        <trans-unit id="57de3f33cd01d18ece5f1f8bac4a92c384bb136f" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process than the Erlang runtime system. In some cases this is not acceptable. Consider, for example, drivers with very hard time requirements. It is therefore possible to write a program in C according to certain principles, and dynamically link it to the Erlang runtime system. This is called a &lt;strong&gt;linked-in driver&lt;/strong&gt;.</source>
          <target state="translated">外部程序位于Erlang运行时系统之外的其他OS进程中。在某些情况下，这是不可接受的。例如，考虑对时间要求非常高的驾驶员。因此，可以根据某些原则用C编写程序，并将其动态链接到Erlang运行时系统。这称为&lt;strong&gt;链接驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="483a7ce8598855903aaac7d43e33a8b6a176d6b3" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process. By default, it reads from standard input (file descriptor 0) and writes to standard output (file descriptor 1). The external program is to terminate when the port is closed.</source>
          <target state="translated">外部程序驻留在另一个操作系统进程中。默认情况下,它从标准输入 (文件描述符 0)读取,并向标准输出 (文件描述符 1)写入。当端口关闭时,外部程序将终止。</target>
        </trans-unit>
        <trans-unit id="222a1e19175406b6aa7a82dcd2394935006c713e" translate="yes" xml:space="preserve">
          <source>The external term format is mainly used in the distribution mechanism of Erlang.</source>
          <target state="translated">外部术语格式主要用于Erlang的发布机制。</target>
        </trans-unit>
        <trans-unit id="474968dd4f560dffd7389aa9ca6143617036ffea" translate="yes" xml:space="preserve">
          <source>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">事实上,(*PRUNE:NAME)记住名字对Erlang程序员来说是没有用的,因为名字不能被检索。</target>
        </trans-unit>
        <trans-unit id="e08d6e43db0948fdcb04ad39ee35684175d7b088" translate="yes" xml:space="preserve">
          <source>The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">事实上,(*THEN:NAME)记住名字对Erlang程序员来说是没有用的,因为名字不能被检索。</target>
        </trans-unit>
        <trans-unit id="a45ac2df0b9d463c5e0e5db641eebadc3836e7a0" translate="yes" xml:space="preserve">
          <source>The factor when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;).</source>
          <target state="translated">计算新计时器时间的因子（ &lt;code&gt;wait_for&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3b32182822028d3d94853cdaecf2932942b85c07" translate="yes" xml:space="preserve">
          <source>The fastest selective decode is when the decoded type is a primitive type and not so deep in the structure of the top type. &lt;code&gt;selected_decode_Window2&lt;/code&gt; decodes a high constructed value, which explains why this operation is relatively slow.</source>
          <target state="translated">最快的选择性解码是当解码的类型是原始类型并且在顶级类型的结构中没有那么深的时候。 &lt;code&gt;selected_decode_Window2&lt;/code&gt; 解码一个较高的构造值，这解释了为什么此操作相对较慢。</target>
        </trans-unit>
        <trans-unit id="e539ae850e97a5a9057ff2bb6d6c8fcc08bab73d" translate="yes" xml:space="preserve">
          <source>The feature was added in Erlang 5.7.5/OTP R13B04.</source>
          <target state="translated">这个功能是在Erlang 5.7.5/OTP R13B04中加入的。</target>
        </trans-unit>
        <trans-unit id="a7d9b7c2c0bd1f2fc3f2c7d85835796c435f8f44" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;ModData&lt;/code&gt; is a list. This list is the list returned from the last call to &lt;code&gt;do/1&lt;/code&gt;.</source>
          <target state="translated">现场 &lt;code&gt;data&lt;/code&gt; 在 &lt;code&gt;ModData&lt;/code&gt; 是一个列表。该列表是上次对 &lt;code&gt;do/1&lt;/code&gt; 的调用返回的列表。</target>
        </trans-unit>
        <trans-unit id="6456be6965c0349e34f864167682f7b31ae172c8" translate="yes" xml:space="preserve">
          <source>The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the &lt;strong&gt;same&lt;/strong&gt; call to &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt;. For example, using &lt;code&gt;T&lt;/code&gt; above:</source>
          <target state="translated">字段宽度指定最大行长。默认值为80。精度指定术语的初始缩进。它默认为在&lt;strong&gt;同一&lt;/strong&gt;调用 &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt; 中此行上打印的字符数。例如，使用上面的 &lt;code&gt;T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="45f234045151c357743a7016e59e80ebbcce1cad" translate="yes" xml:space="preserve">
          <source>The fields can be in any order, not necessarily the same order as in the record definition, and fields can be omitted. Omitted fields get their respective default value instead.</source>
          <target state="translated">字段的顺序可以是任意的,不一定与记录定义中的顺序相同,字段也可以省略。被省略的字段会得到各自的默认值。</target>
        </trans-unit>
        <trans-unit id="08c771e3c02df1bde386f66f03b2e079f068c16e" translate="yes" xml:space="preserve">
          <source>The fields in the structure are as follows:</source>
          <target state="translated">该结构中的字段如下:</target>
        </trans-unit>
        <trans-unit id="4eaa6a16da05e6ff18f84c1ebcd0b7aefc5111a7" translate="yes" xml:space="preserve">
          <source>The fields of record &lt;code&gt;mod&lt;/code&gt; have the following meaning:</source>
          <target state="translated">record &lt;code&gt;mod&lt;/code&gt; 的字段具有以下含义：</target>
        </trans-unit>
        <trans-unit id="e9f5d2712650575f495813aa5945d3da6ac26a56" translate="yes" xml:space="preserve">
          <source>The fields referred to in the pattern can be given in any order.</source>
          <target state="translated">模式中提到的字段可以按任何顺序给出。</target>
        </trans-unit>
        <trans-unit id="08db3122b6c1da4a657ae8cba808796dd5cb6b86" translate="yes" xml:space="preserve">
          <source>The fifth argument is the magic cookie.</source>
          <target state="translated">第五个论点是魔法饼干。</target>
        </trans-unit>
        <trans-unit id="9f962ab964ce6cd051f2dbc6e617195062eacc4f" translate="yes" xml:space="preserve">
          <source>The figures in this section illustrate the steps involved in the development of an SNMP agent.</source>
          <target state="translated">本节中的数字说明了开发SNMP代理的相关步骤。</target>
        </trans-unit>
        <trans-unit id="4cbdd4fa4fa7eb06d2c2cd3f4fc02cfd3c4c58d8" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;FileName&lt;/code&gt; is to be a plain text file and can contain comments and command-line arguments. A comment begins with a &lt;code&gt;#&lt;/code&gt; character and continues until the next end of line character. Backslash (\\) is used as quoting character. All command-line arguments accepted by &lt;code&gt;erl&lt;/code&gt; are allowed, also flag &lt;code&gt;-args_file FileName&lt;/code&gt;. Be careful not to cause circular dependencies between files containing flag &lt;code&gt;-args_file&lt;/code&gt;, though.</source>
          <target state="translated">文件名 &lt;code&gt;FileName&lt;/code&gt; 是纯文本文件，可以包含注释和命令行参数。注释以 &lt;code&gt;#&lt;/code&gt; 字符开头，并一直持续到下一行字符为止。反斜杠（\\）用作引号字符。允许 &lt;code&gt;erl&lt;/code&gt; 接受的所有命令行参数，以及 &lt;code&gt;-args_file FileName&lt;/code&gt; 标志。但是请注意不要在包含标志 &lt;code&gt;-args_file&lt;/code&gt; 的文件之间引起循环依赖。</target>
        </trans-unit>
        <trans-unit id="ef2a4ab9b2cbfd5981924e055242be9d6523c2f1" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;appl.erl&lt;/code&gt; is transferred from the remote to the local host. When the session is opened, the current directory at the remote host is &lt;code&gt;/home/guest&lt;/code&gt;, and &lt;code&gt;/home/fred&lt;/code&gt; at the local host. Before transferring the file, the current local directory is changed to &lt;code&gt;/home/eproj/examples&lt;/code&gt;, and the remote directory is set to &lt;code&gt;/home/guest/appl/examples&lt;/code&gt;.</source>
          <target state="translated">文件 &lt;code&gt;appl.erl&lt;/code&gt; 从远程传输到本地主机。打开会话时，远程主机上的当前目录为 &lt;code&gt;/home/guest&lt;/code&gt; ，本地主机上的 &lt;code&gt;/home/fred&lt;/code&gt; 。传输文件之前，当前本地目录已更改为 &lt;code&gt;/home/eproj/examples&lt;/code&gt; ，远程目录已设置为 &lt;code&gt;/home/guest/appl/examples&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5712e30f3c91d1fa3a6c8c851828ea49909dab0b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;ch_app.appup&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;ch_app.appup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed1f252a17bd502cae6f65b494d7abad29887093" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;foo.DCD&lt;/code&gt; has been created. This file will eventually store all data that is written into the &lt;code&gt;foo&lt;/code&gt; table.</source>
          <target state="translated">文件 &lt;code&gt;foo.DCD&lt;/code&gt; 已创建。该文件最终将存储所有写入 &lt;code&gt;foo&lt;/code&gt; 表的数据。</target>
        </trans-unit>
        <trans-unit id="cef24f2335b5ba7f0dd2cc5fad1d52fb9d3d09b4" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; is a copy of our &lt;code&gt;mysystem.boot&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; 是我们的 &lt;code&gt;mysystem.boot&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="2b8b8152527aa20a7d4a0566192d86d3094913d9" translate="yes" xml:space="preserve">
          <source>The file cannot be found in any of the directories in &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Path&lt;/code&gt; 中的任何目录中找不到该文件。</target>
        </trans-unit>
        <trans-unit id="fc7fabdf332059e44e2eb17eeef692885d373bdb" translate="yes" xml:space="preserve">
          <source>The file cannot be opened.</source>
          <target state="translated">该文件无法打开。</target>
        </trans-unit>
        <trans-unit id="a9a0257416ae53879f4ba75c38e4782504676962" translate="yes" xml:space="preserve">
          <source>The file descriptor of the socket associated with the port.</source>
          <target state="translated">与 port 相关的 socket 的文件描述符。</target>
        </trans-unit>
        <trans-unit id="8273bc28b08e309fc9dd43621c30c7519263c61b" translate="yes" xml:space="preserve">
          <source>The file does not exist.</source>
          <target state="translated">该文件不存在。</target>
        </trans-unit>
        <trans-unit id="56db91f9bccb5529a0d13172d3cd82f3fa8e8d12" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the local host.</source>
          <target state="translated">该文件在本地主机上获得相同的名称。</target>
        </trans-unit>
        <trans-unit id="116b44d8dffe981177c481cc8f3dc87f0f7f4c3e" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the remote host.</source>
          <target state="translated">文件在远程主机上获得相同的名称。</target>
        </trans-unit>
        <trans-unit id="51b34af4a175f2b4aa90381774d3f18723da3b3d" translate="yes" xml:space="preserve">
          <source>The file includes both version 1, 2 and version 3 messages.</source>
          <target state="translated">该文件包括版本1、2和版本3的信息。</target>
        </trans-unit>
        <trans-unit id="9a9625a98d2c47b406a8f7769a6753258132546c" translate="yes" xml:space="preserve">
          <source>The file is a directory and the user is not superuser.</source>
          <target state="translated">文件是一个目录,用户不是超级用户。</target>
        </trans-unit>
        <trans-unit id="b21cd2436d24bafe2e40702865abc3fbecc09148" translate="yes" xml:space="preserve">
          <source>The file is in both these cases then best processed using the &lt;code&gt;io&lt;/code&gt; module, as the functions in that module can handle code points beyond the ISO Latin-1 range.</source>
          <target state="translated">在这两种情况下，都最好使用 &lt;code&gt;io&lt;/code&gt; 模块来处理文件，因为该模块中的功能可以处理超出ISO Latin-1范围的代码点。</target>
        </trans-unit>
        <trans-unit id="b2eb2fd7e69007e3b27fc3504af5f6bbd478142a" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;LocalFile&lt;/code&gt; on the local host.</source>
          <target state="translated">该文件在本地主机上名为 &lt;code&gt;LocalFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1df462cd01acebe1ec004334e0f1a8efe5b7e5b1" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;RemoteFile&lt;/code&gt; on the remote host.</source>
          <target state="translated">该文件在远程主机上名为 &lt;code&gt;RemoteFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03b686e18d29e8b42dc1dbee506d16c2eb2c5609" translate="yes" xml:space="preserve">
          <source>The file is not opened for reading.</source>
          <target state="translated">该文件未被打开阅读。</target>
        </trans-unit>
        <trans-unit id="0285680290f8aeb50ca6b7cbc6c042e3ad3dd657" translate="yes" xml:space="preserve">
          <source>The file is not opened for writing.</source>
          <target state="translated">文件没有打开写。</target>
        </trans-unit>
        <trans-unit id="e4982f438e094effbe19f49bddea5cc4009fdfdb" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. Every write operation to a file opened with &lt;code&gt;append&lt;/code&gt; takes place at the end of the file.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则会创建它。对通过 &lt;code&gt;append&lt;/code&gt; 打开的文件的每个写操作都在文件末尾进行。</target>
        </trans-unit>
        <trans-unit id="6d726a268237e91f14236fd6ff2803260e2e1532" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists and &lt;code&gt;write&lt;/code&gt; is not combined with &lt;code&gt;read&lt;/code&gt;, the file is truncated.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则会创建它。如果该文件存在并且 &lt;code&gt;write&lt;/code&gt; 不能与 &lt;code&gt;read&lt;/code&gt; 组合，则该文件将被截断。</target>
        </trans-unit>
        <trans-unit id="a197a2f03b6e053838765608c827205470531e6d" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists, &lt;code&gt;{error, eexist}&lt;/code&gt; is returned.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则创建它。如果文件存在，则返回 &lt;code&gt;{error, eexist}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1abdf85470ebe2b741440d62063d01b5682aba19" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file and &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">该文件以请求的模式打开。 &lt;code&gt;IoDevice&lt;/code&gt; 是对该文件的引用，而 &lt;code&gt;FullName&lt;/code&gt; 是该文件的全名。</target>
        </trans-unit>
        <trans-unit id="7acf8ec21fa42c861a4f88f31a1e3b43a849b057" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file.</source>
          <target state="translated">该文件以请求的模式打开。 &lt;code&gt;IoDevice&lt;/code&gt; 是对该文件的引用。</target>
        </trans-unit>
        <trans-unit id="916ee7c748bb5e7a2bf22555efc9c7ba3e8e1d3f" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data in the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">使用不同于 &lt;code&gt;latin1&lt;/code&gt; 的其他 &lt;code&gt;encoding&lt;/code&gt; 打开文件，并且文件中的数据无法转换为该函数返回的面向字节的数据。</target>
        </trans-unit>
        <trans-unit id="af4cd6106424f7957ea5b09a69738ba162a42d0a" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data on the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">使用不同于 &lt;code&gt;latin1&lt;/code&gt; 的其他 &lt;code&gt;encoding&lt;/code&gt; 打开文件，并且文件上的数据无法转换为此函数返回的面向字节的数据。</target>
        </trans-unit>
        <trans-unit id="f1447089fad09b9920a3125bbbcb71e40fcf03b8" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file and &lt;code&gt;Value&lt;/code&gt; the value of the last expression.</source>
          <target state="translated">读取并评估文件。 &lt;code&gt;FullName&lt;/code&gt; 是文件的全名， &lt;code&gt;Value&lt;/code&gt; 是最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="ab1ff8d4200f6f26fb7134240fe2228fd2ecd31d" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">读取并评估文件。 &lt;code&gt;FullName&lt;/code&gt; 是文件的全名。</target>
        </trans-unit>
        <trans-unit id="2975a465dfe23956015ba6c274ed78e16024bfa9" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;Value&lt;/code&gt; is the value of the last expression.</source>
          <target state="translated">读取并评估文件。 &lt;code&gt;Value&lt;/code&gt; 是最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="e333fb72ddfdad9f98da967fd861cc9cecde73c6" translate="yes" xml:space="preserve">
          <source>The file is read by the application controller when an application is loaded/started. It is also used by the functions in &lt;code&gt;systools&lt;/code&gt;, for example when generating start scripts.</source>
          <target state="translated">加载/启动应用程序时，应用程序控制器将读取文件。 &lt;code&gt;systools&lt;/code&gt; 中的功能也使用它，例如，在生成启动脚本时。</target>
        </trans-unit>
        <trans-unit id="d522dbd681f4cd878e0a0aeb3cbd943d113a8c38" translate="yes" xml:space="preserve">
          <source>The file is successfully read. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">已成功读取文件。 &lt;code&gt;FullName&lt;/code&gt; 是文件的全名。</target>
        </trans-unit>
        <trans-unit id="e117edda70b67ee50f9d2f7fce2e7996b73bd637" translate="yes" xml:space="preserve">
          <source>The file must be in &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt;. The file is read when the daemon starts.</source>
          <target state="translated">该文件必须为 &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt; 。守护程序启动时将读取文件。</target>
        </trans-unit>
        <trans-unit id="80ee3eac8f806ec9cde470e2d7d3f7c22d220194" translate="yes" xml:space="preserve">
          <source>The file must be named &lt;code&gt;Rel.rel&lt;/code&gt;, where &lt;code&gt;Rel&lt;/code&gt; is a unique name.</source>
          <target state="translated">该文件必须命名为 &lt;code&gt;Rel.rel&lt;/code&gt; ，其中 &lt;code&gt;Rel&lt;/code&gt; 是唯一名称。</target>
        </trans-unit>
        <trans-unit id="7582f5f80d20de2502ad5d3c778be456df031796" translate="yes" xml:space="preserve">
          <source>The file must contain a single Erlang term, which is called an &lt;strong&gt;application specification&lt;/strong&gt;:</source>
          <target state="translated">该文件必须包含一个单独的Erlang术语，称为&lt;strong&gt;应用程序规范&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="d15a1263b243302ad1b99430abd18bc925e32e3e" translate="yes" xml:space="preserve">
          <source>The file must have one or more three-tuples &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; terminated by a dot. The file is read when the daemon starts.</source>
          <target state="translated">该文件必须具有一个或多个三元组 &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; ，以点号结束。守护程序启动时将读取文件。</target>
        </trans-unit>
        <trans-unit id="56458bdbcf5690ec8658261e5325164ce2a2a111" translate="yes" xml:space="preserve">
          <source>The file name of the current module.</source>
          <target state="translated">当前模块的文件名。</target>
        </trans-unit>
        <trans-unit id="a5d1d6d598f59230fdf0a71188330092a7de64cf" translate="yes" xml:space="preserve">
          <source>The file name requirement on the engine dynamic library can differ between SSL versions.</source>
          <target state="translated">不同的SSL版本对引擎动态库的文件名要求可能不同。</target>
        </trans-unit>
        <trans-unit id="5cf117b829fc2877fe7b8ccf793bd866ee82bf7d" translate="yes" xml:space="preserve">
          <source>The file names consist of eight hexadecimal digits followed by &lt;code&gt;.rN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer, e.g. &lt;code&gt;1a2b3c4d.r0&lt;/code&gt;. For the first version of the CRL, &lt;code&gt;N&lt;/code&gt; starts at zero, and for each new version, &lt;code&gt;N&lt;/code&gt; is incremented by one. The OpenSSL utility &lt;code&gt;c_rehash&lt;/code&gt; creates symlinks according to this pattern.</source>
          <target state="translated">文件名由八个十六进制数字组成，后跟 &lt;code&gt;.rN&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是整数，例如 &lt;code&gt;1a2b3c4d.r0&lt;/code&gt; 。对于CRL的第一个版本， &lt;code&gt;N&lt;/code&gt; 从零开始，对于每个新版本， &lt;code&gt;N&lt;/code&gt; 递增一。OpenSSL实用程序 &lt;code&gt;c_rehash&lt;/code&gt; 根据此模式创建符号链接。</target>
        </trans-unit>
        <trans-unit id="d7d30bf4111cf6d645a316a6236bd904ed813968" translate="yes" xml:space="preserve">
          <source>The file offset in the zip archive (used internally)</source>
          <target state="translated">压缩包中的文件偏移量(内部使用)</target>
        </trans-unit>
        <trans-unit id="98c7f36c4669e374fe284c2ff98a9ddaef5cf51f" translate="yes" xml:space="preserve">
          <source>The file permissions as the sum of the following bit values:</source>
          <target state="translated">文件权限为以下位值之和。</target>
        </trans-unit>
        <trans-unit id="9515e875a26b329b033fd7640f399fd9edd7196e" translate="yes" xml:space="preserve">
          <source>The file privileges and ownership of the &lt;code&gt;mod_syslog&lt;/code&gt; utility must be modified.</source>
          <target state="translated">必须修改 &lt;code&gt;mod_syslog&lt;/code&gt; 实用程序的文件特权和所有权。</target>
        </trans-unit>
        <trans-unit id="e4f22a3c177173ba882d73ea3867a6b6cb6d9dc7" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;</source>
          <target state="translated">传入URL的文件后缀映射到 &lt;code&gt;MimeType&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4eba4c3a153db010c6d9b7a15465b2d5b3ce266" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;.</source>
          <target state="translated">传入URL的文件后缀映射到 &lt;code&gt;MimeType&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f294360a334b35b807188de18da95f7579b0fb4d" translate="yes" xml:space="preserve">
          <source>The file system on the other host has a different structure to the the master.</source>
          <target state="translated">另一台主机上的文件系统与主机的结构不同。</target>
        </trans-unit>
        <trans-unit id="c75ca2cbc895f2093ee4a98814185b1afc3a8e1a" translate="yes" xml:space="preserve">
          <source>The file system path to the directory where the driver object file is located. The filename of the object file (minus extension) must correspond to the driver name (used in parameter &lt;code&gt;Name&lt;/code&gt;) and the driver must identify itself with the same name. &lt;code&gt;Path&lt;/code&gt; can be provided as an &lt;strong&gt;iolist()&lt;/strong&gt;, meaning it can be a list of other &lt;code&gt;iolist()&lt;/code&gt;s, characters (8-bit integers), or binaries, all to be flattened into a sequence of characters.</source>
          <target state="translated">驱动程序目标文件所在目录的文件系统路径。目标文件的文件名（减去扩展名）必须与驱动程序名称（在参数 &lt;code&gt;Name&lt;/code&gt; 中使用）相对应，并且驱动程序必须使用相同的名称进行标识。可以将 &lt;code&gt;Path&lt;/code&gt; 提供为&lt;strong&gt;iolist（）&lt;/strong&gt;，这意味着它可以是其他 &lt;code&gt;iolist()&lt;/code&gt; 的列表，字符（8位整数）或二进制文件，所有这些都将被压平为一个字符序列。</target>
        </trans-unit>
        <trans-unit id="bf2eb9cc34b90180610fbc75837cbfad30b948cc" translate="yes" xml:space="preserve">
          <source>The file trace driver expects a filename or a wrap files specification as parameter. A file is written with a high degree of buffering, why all trace messages are &lt;strong&gt;not&lt;/strong&gt; guaranteed to be saved in the file in case of a system crash. That is the price to pay for low tracing overhead.</source>
          <target state="translated">文件跟踪驱动程序需要文件名或自动换行规范作为参数。文件写入时具有很高的缓冲能力，因此如果系统崩溃，为什么&lt;strong&gt;不能&lt;/strong&gt;保证所有跟踪消息都保存在文件中。这是为低跟踪开销付出的代价。</target>
        </trans-unit>
        <trans-unit id="083d3049caca9cb4909e07d982cf1c0a253eda8d" translate="yes" xml:space="preserve">
          <source>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCCI mode.</source>
          <target state="translated">文件传输类型设置为打开会话时FTP服务器的默认值。这通常是ASCCI模式。</target>
        </trans-unit>
        <trans-unit id="d7d87c17221873fd0d28c7a0cf27f97994b73b47" translate="yes" xml:space="preserve">
          <source>The file used must be opened using the &lt;code&gt;raw&lt;/code&gt; flag, and the process calling &lt;code&gt;sendfile&lt;/code&gt; must be the controlling process of the socket. See &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须使用 &lt;code&gt;raw&lt;/code&gt; 标志打开使用的文件，并且调用 &lt;code&gt;sendfile&lt;/code&gt; 的进程必须是套接字的控制进程。参见 &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0739dac79b5f4f1aa7ca70031ae5a16c934c399" translate="yes" xml:space="preserve">
          <source>The file was read and evaluated.</source>
          <target state="translated">读取并评估了该文件。</target>
        </trans-unit>
        <trans-unit id="4e58a2f1e91ddce67de54ef340e3da2cb9cb63a1" translate="yes" xml:space="preserve">
          <source>The file was successfully read.</source>
          <target state="translated">文件被成功读取。</target>
        </trans-unit>
        <trans-unit id="c72d65e1c03281b49322438db24cb3e3334edd0b" translate="yes" xml:space="preserve">
          <source>The file, which must exist, is opened for reading.</source>
          <target state="translated">该文件必须存在,是打开阅读的。</target>
        </trans-unit>
        <trans-unit id="552bd26b6c475a1374de92e4954676c79da00420" translate="yes" xml:space="preserve">
          <source>The filename</source>
          <target state="translated">文件名</target>
        </trans-unit>
        <trans-unit id="26016e882c6ac80280490e30771a8dba2723ae37" translate="yes" xml:space="preserve">
          <source>The filename must be &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The path must be the same as the backup copy.</source>
          <target state="translated">文件名必须是 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 。该路径必须与备份副本相同。</target>
        </trans-unit>
        <trans-unit id="29478f77cee4c57798b46ebd0b4dff9c27a01cc8" translate="yes" xml:space="preserve">
          <source>The filename of the copy must be &lt;code&gt;syslog.conf.ORIG&lt;/code&gt;. The directory location is optional; usually it is &lt;code&gt;/etc&lt;/code&gt;. A simple way to do this is to issue the following command:</source>
          <target state="translated">副本的文件名必须为 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 。目录位置是可选的；通常它是 &lt;code&gt;/etc&lt;/code&gt; 。一种简单的方法是发出以下命令：</target>
        </trans-unit>
        <trans-unit id="5af1d694b8b3cdebbfc3c0f00daedcbcdd080514" translate="yes" xml:space="preserve">
          <source>The filename of the crashdump.</source>
          <target state="translated">崩溃的文件名。</target>
        </trans-unit>
        <trans-unit id="f51e4a22a3fd6a63b9b7c7d8ef4afc50be94d9de" translate="yes" xml:space="preserve">
          <source>The filename translation mode can be read with function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, which returns &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) or &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">可以使用函数 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 读取文件名转换模式，该函数返回 &lt;code&gt;latin1&lt;/code&gt; （按字节编码）或 &lt;code&gt;utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bbf7541fe0325c793eec29d4cd8ad35ed00aa5e" translate="yes" xml:space="preserve">
          <source>The files are unzipped to memory or to file, depending on the options specified to function &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; when opening the archive.</source>
          <target state="translated">这些文件将解压缩到内存或文件中，具体取决于打开存档时为 &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; 功能指定的选项。</target>
        </trans-unit>
        <trans-unit id="e8c783c92fcd9bf942dd424f42fc61d302ddafc6" translate="yes" xml:space="preserve">
          <source>The files are:</source>
          <target state="translated">这些文件是:</target>
        </trans-unit>
        <trans-unit id="c0b32d670fd0928ee57d4da38842a479ce59c02a" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;did not pass&lt;/strong&gt;, and the log event is immediately discarded.</source>
          <target state="translated">过滤器&lt;strong&gt;未通过&lt;/strong&gt;，日志事件立即被丢弃。</target>
        </trans-unit>
        <trans-unit id="2fec5992ce5b4648b9da53b9fca03126f14195c8" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next handler filter, if any, is applied. If no more filters exist for this handler, the log event is forwarded to the handler callback.</source>
          <target state="translated">筛选器&lt;strong&gt;通过&lt;/strong&gt;。下一个处理程序过滤器（如果有）将被应用。如果此处理程序没有更多的过滤器，则将日志事件转发到处理程序回调。</target>
        </trans-unit>
        <trans-unit id="c64e728f01227118a6f0a504e74466c80ec0c979" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next primary filter, if any, is applied. If no more primary filters exist, the log event is forwarded to the handler part of Logger, where handler filters are applied.</source>
          <target state="translated">筛选器&lt;strong&gt;通过&lt;/strong&gt;。下一个主过滤器（如果有）将被应用。如果不再存在主过滤器​​，则将日志事件转发到Logger的处理程序部分，在此应用处理程序过滤器。</target>
        </trans-unit>
        <trans-unit id="7f4778fe9a2d1bb2efd40561548fc65defaa0949" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the &lt;code&gt;domain&lt;/code&gt; field in the log event's metadata (&lt;code&gt;Domain&lt;/code&gt;) against &lt;code&gt;MatchDomain&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Compare&lt;/code&gt; is:</source>
          <target state="translated">筛选器将日志事件的元数据（ &lt;code&gt;Domain&lt;/code&gt; ）中的 &lt;code&gt;domain&lt;/code&gt; 字段的值与 &lt;code&gt;MatchDomain&lt;/code&gt; 进行比较。如果&amp;ldquo; &lt;code&gt;Compare&lt;/code&gt; 的值是：</target>
        </trans-unit>
        <trans-unit id="fb57b499845a0930b0e37c62f80d02bcd2cb10f3" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the event's log level (&lt;code&gt;Level&lt;/code&gt;) to &lt;code&gt;MatchLevel&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Operator&lt;/code&gt; is:</source>
          <target state="translated">过滤器通过调用 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt; 将事件的日志级别（ &lt;code&gt;Level&lt;/code&gt; ）的值与 &lt;code&gt;MatchLevel&lt;/code&gt; 进行比较。如果 &lt;code&gt;Operator&lt;/code&gt; 的值是：</target>
        </trans-unit>
        <trans-unit id="beafc4357de407d81ed4a70bb524b690f9b684ec" translate="yes" xml:space="preserve">
          <source>The filter fun is called with the log event as the first parameter, and the specified &lt;code&gt;filter_args()&lt;/code&gt; as the second parameter.</source>
          <target state="translated">使用log事件作为第一个参数，并使用指定的 &lt;code&gt;filter_args()&lt;/code&gt; 作为第二个参数来调用filter fun 。</target>
        </trans-unit>
        <trans-unit id="109bfa797ec0aa4b76af245de1501f0741f1a95b" translate="yes" xml:space="preserve">
          <source>The filter function can return &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;ignore&lt;/code&gt; or the (possibly modified) log event.</source>
          <target state="translated">过滤器功能可以返回 &lt;code&gt;stop&lt;/code&gt; ， &lt;code&gt;ignore&lt;/code&gt; 或（可能已修改的）日志事件。</target>
        </trans-unit>
        <trans-unit id="fd11c27d7fbe5210f24b8d1e40d0d071f2e3ec4c" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next handler filter, if any, is applied. If no more filters exist for this handler, the value of the &lt;code&gt;filter_default&lt;/code&gt; configuration parameter for the handler specifies if the log event shall be discarded or forwarded to the handler callback.</source>
          <target state="translated">筛选器不知道日志事件。下一个处理程序过滤器（如果有）将被应用。如果此处理程序没有更多的过滤器，则该处理程序的 &lt;code&gt;filter_default&lt;/code&gt; 配置参数的值指定是将日志事件丢弃还是转发到处理程序回调。</target>
        </trans-unit>
        <trans-unit id="ddc0b8589e411612b38fdd950c86be1e96f3d934" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next primary filter, if any, is applied. If no more primary filters exist, the value of the primary &lt;code&gt;filter_default&lt;/code&gt; configuration parameter specifies if the log event shall be discarded or forwarded to the handler part.</source>
          <target state="translated">筛选器不了解日志事件。下一个主过滤器（如果有）将被应用。如果不再存在主过滤器​​，则主 &lt;code&gt;filter_default&lt;/code&gt; 配置参数的值指定是否应丢弃日志事件或将其转发到处理程序部分。</target>
        </trans-unit>
        <trans-unit id="41d4a36552fad1262f02d4b7fdc2ca2fb3a329a9" translate="yes" xml:space="preserve">
          <source>The filter returns &lt;code&gt;ignore&lt;/code&gt; for all other log events.</source>
          <target state="translated">对于所有其他日志事件，过滤器将返回 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfb975166536b9370277fc5b05c55860c6bb1974" translate="yes" xml:space="preserve">
          <source>The final result is automatically compacted (compare &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">最终结果将自动压缩（比较 &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1526dc18038f8fccad4ff828c37ad6dc7b944d4a" translate="yes" xml:space="preserve">
          <source>The final use of backslash is for certain simple assertions. An assertion specifies a condition that must be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The following are the backslashed assertions:</source>
          <target state="translated">反斜杠的最后一个用法是用于某些简单的断言。一个断言指定了一个必须在匹配中的某个特定点满足的条件,而不需要消耗主题字符串中的任何字符。下面将介绍子模式在更复杂的断言中的使用。下面是反斜线断言。</target>
        </trans-unit>
        <trans-unit id="e6d536c130f15c0094632e977773d39a9eb1e1bc" translate="yes" xml:space="preserve">
          <source>The finish time can be specified as &lt;code&gt;HHMMSS&lt;/code&gt; and is then interpreted as a time today (or possibly tomorrow), but can also be specified as &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt;, for example, &lt;code&gt;-until 071001120000&lt;/code&gt; or &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt;. This means that the tests are executed and (if time allows) repeated, until 12 o'clock on the 1st of October 2007.</source>
          <target state="translated">可以将完成时间指定为 &lt;code&gt;HHMMSS&lt;/code&gt; ，然后将其解释为今天（或可能是明天）的时间，但也可以指定为 &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt; ，例如， &lt;code&gt;-until 071001120000&lt;/code&gt; 或 &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt; 。这意味着将执行测试并（如果时间允许）重复进行测试，直到2007年10月1日12时为止。</target>
        </trans-unit>
        <trans-unit id="6e0ddb058b574885245c8e1eb45a6f332a495743" translate="yes" xml:space="preserve">
          <source>The first 4-bits segment of &lt;code&gt;Dgram&lt;/code&gt; is not equal to 4.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 的前4位段不等于4。</target>
        </trans-unit>
        <trans-unit id="8565b4f54aaccfcff566979872a65ab909534a87" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;[&lt;/code&gt; bracket is read as &quot;build the list&quot;.</source>
          <target state="translated">第 &lt;code&gt;[&lt;/code&gt; 支架读作&amp;ldquo;生成列表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97b9da02f0f552217d5f6a05e46d62406ee40ed2" translate="yes" xml:space="preserve">
          <source>The first and longest match is preferred to a shorter, which is illustrated by the following example:</source>
          <target state="translated">第一和最长的匹配优于较短的匹配,下面的例子说明了这一点。</target>
        </trans-unit>
        <trans-unit id="6694406df610cd0f2b38fa2673a9cd35f9806c5a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;code&gt;{down,Vsn}&lt;/code&gt; if there is a downgrade, or &lt;code&gt;Vsn&lt;/code&gt; if there is a upgrade. The term &lt;code&gt;Vsn&lt;/code&gt; is fetched from the 'original' version of the module, that is, the version you are upgrading from, or downgrading to.</source>
          <target state="translated">第一个参数是 &lt;code&gt;{down,Vsn}&lt;/code&gt; 如果有降级或 &lt;code&gt;Vsn&lt;/code&gt; 如果有升级。术语 &lt;code&gt;Vsn&lt;/code&gt; 是从模块的&amp;ldquo;原始&amp;rdquo;版本中提取的，即您要从其升级或降级到的版本。</target>
        </trans-unit>
        <trans-unit id="ce41fd29eb3e83bdeb71be9c3fb406a35efdd54a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;strong&gt;not&lt;/strong&gt; a problem. It is variable, but it is a variable in all clauses. The problem is the variable in the second argument, &lt;code&gt;Xs&lt;/code&gt;, in the middle clause. Because the variable can match anything, the compiler is not allowed to rearrange the clauses, but must generate code that matches them in the order written.</source>
          <target state="translated">第一个论点&lt;strong&gt;不是&lt;/strong&gt;问题。它是变量，但在所有子句中都是变量。问题是中间子句中第二个参数 &lt;code&gt;Xs&lt;/code&gt; 中的变量。因为变量可以匹配任何内容，所以不允许编译器重新排列子句，但必须生成按编写顺序与子句匹配的代码。</target>
        </trans-unit>
        <trans-unit id="32cd604e114cd5b8cc3d471ee8e9bda4b1cee80b" translate="yes" xml:space="preserve">
          <source>The first argument is the host name.</source>
          <target state="translated">第一个参数是主机名。</target>
        </trans-unit>
        <trans-unit id="d1c68fc721622601f7d260f14b31c96cc4eaab50" translate="yes" xml:space="preserve">
          <source>The first argument is the integer used to construct the node name.</source>
          <target state="translated">第一个参数是用来构造节点名称的整数。</target>
        </trans-unit>
        <trans-unit id="f32a2498eb521e7ca9e58ea1c17356aedb30f6e1" translate="yes" xml:space="preserve">
          <source>The first argument is the internal state &lt;code&gt;State&lt;/code&gt;, passed from function &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt;, and called by the special process when a system message is received. In &lt;code&gt;ch4&lt;/code&gt;, the internal state is the set of available channels &lt;code&gt;Chs&lt;/code&gt;.</source>
          <target state="translated">第一个参数是内部状态 &lt;code&gt;State&lt;/code&gt; ，从状态 &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt; 传递，并在接收到系统消息时由特殊进程调用。在 &lt;code&gt;ch4&lt;/code&gt; 中，内部状态是可用通道 &lt;code&gt;Chs&lt;/code&gt; 的集合。</target>
        </trans-unit>
        <trans-unit id="c12ca04f8508bcca65e776d0a609f335e9ddf7b5" translate="yes" xml:space="preserve">
          <source>The first argument is the name of the &lt;code&gt;gen_statem&lt;/code&gt; and must agree with the name used to start it. So, we use the same macro &lt;code&gt;?NAME&lt;/code&gt; as when starting. &lt;code&gt;{button,Digit}&lt;/code&gt; is the event content.</source>
          <target state="translated">第一个参数是 &lt;code&gt;gen_statem&lt;/code&gt; 的名称，必须与用于启动它的名称一致。因此，我们使用与启动时相同的宏 &lt;code&gt;?NAME&lt;/code&gt; 。 &lt;code&gt;{button,Digit}&lt;/code&gt; 是事件的内容。</target>
        </trans-unit>
        <trans-unit id="aefd6aec912ef4431dbd33b887c26f8e830aec81" translate="yes" xml:space="preserve">
          <source>The first argument must be the name of the Erlang module as a C-identifier. It will be stringified by the macro.</source>
          <target state="translated">第一个参数必须是Erlang模块的名称,作为C-标识符。宏将对其进行字符串化处理。</target>
        </trans-unit>
        <trans-unit id="6d796fe4c495cce6f5931a9ed26cf94f76f97e87" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;ttb:format/1,2&lt;/code&gt; specifies which binary log(s) to format. This is usually the name of a directory that &lt;code&gt;ttb&lt;/code&gt; created during log fetch. Unless option &lt;code&gt;disable_sort&lt;/code&gt; is provided, the logs from different files are always sorted according to time-stamp in traces.</source>
          <target state="translated">&lt;code&gt;ttb:format/1,2&lt;/code&gt; 的第一个参数指定要格式化的二进制日志。这通常是 &lt;code&gt;ttb&lt;/code&gt; 在日志提取期间创建的目录的名称。除非提供选项 &lt;code&gt;disable_sort&lt;/code&gt; ，否则始终根据跟踪中的时间戳对来自不同文件的日志进行排序。</target>
        </trans-unit>
        <trans-unit id="f1fc18bc1a4475d49a5401a7876f067a569b9a43" translate="yes" xml:space="preserve">
          <source>The first argument to these functions is the name of the test case. This value can be used with pattern matching in function clauses or conditional expressions to choose different initialization and cleanup routines for different test cases, or perform the same routine for many, or all, test cases.</source>
          <target state="translated">这些函数的第一个参数是测试用例的名称。这个值可以与函数子句或条件表达式中的模式匹配一起使用,为不同的测试用例选择不同的初始化和清理例程,或者为许多或所有的测试用例执行相同的例程。</target>
        </trans-unit>
        <trans-unit id="ecdfdb297a347255c9331f18e2ac5e6afd881831" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;ch_sup&lt;/code&gt;, is the name of the callback module, that is, the module where the &lt;code&gt;init&lt;/code&gt; callback function is located.</source>
          <target state="translated">第一个参数 &lt;code&gt;ch_sup&lt;/code&gt; 是回调模块的名称，即 &lt;code&gt;init&lt;/code&gt; 回调函数所在的模块。</target>
        </trans-unit>
        <trans-unit id="283cb26772a001cdc7fe1371d58b95c0c89083e7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local, ch3}&lt;/code&gt;, specifies the name. The gen_server is then locally registered as &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;{local, ch3}&lt;/code&gt; 指定名称。gen_server然后在本地注册为 &lt;code&gt;ch3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9747ca5abb30d92b09649a3fe92d54bbd6136b7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local,?NAME}&lt;/code&gt;, specifies the name. In this case, the &lt;code&gt;gen_statem&lt;/code&gt; is locally registered as &lt;code&gt;code_lock&lt;/code&gt; through the macro &lt;code&gt;?NAME&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;{local,?NAME}&lt;/code&gt; 指定名称。在这种情况下， &lt;code&gt;gen_statem&lt;/code&gt; 在本地注册为 &lt;code&gt;code_lock&lt;/code&gt; 通过宏 &lt;code&gt;?NAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81bf6f9dd47061daa5ebed0dbe0e76693e63afed" translate="yes" xml:space="preserve">
          <source>The first call to &lt;code&gt;enif_select&lt;/code&gt; for a specific OS &lt;code&gt;event&lt;/code&gt; will establish a relation between the event object and the containing resource. All subsequent calls for an &lt;code&gt;event&lt;/code&gt; must pass its containing resource as argument &lt;code&gt;obj&lt;/code&gt;. The relation is dissolved when &lt;code&gt;enif_select&lt;/code&gt; has been called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and the corresponding &lt;code&gt;stop&lt;/code&gt; callback has returned. A resource can contain several event objects but one event object can only be contained within one resource. A resource will not be destructed until all its contained relations have been dissolved.</source>
          <target state="translated">针对特定OS &lt;code&gt;event&lt;/code&gt; &lt;code&gt;enif_select&lt;/code&gt; 的首次调用将在事件对象和包含的资源之间建立关系。 &lt;code&gt;event&lt;/code&gt; 所有后续调用都必须将其包含的资源作为参数 &lt;code&gt;obj&lt;/code&gt; 传递。当关系溶解 &lt;code&gt;enif_select&lt;/code&gt; 已经调用 &lt;code&gt;mode&lt;/code&gt; 为 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 和相应的 &lt;code&gt;stop&lt;/code&gt; 回调又回来了。一个资源可以包含多个事件对象，但是一个事件对象只能包含在一个资源中。在资源中所有包含的关系都消失之前，它不会被破坏。</target>
        </trans-unit>
        <trans-unit id="2bd2696be64fe7162dc1485b1d2c990c6c549132" translate="yes" xml:space="preserve">
          <source>The first call to an interpreted function by this process. (&lt;code&gt;Module:Function/Arity&lt;/code&gt;)</source>
          <target state="translated">此过程首次调用解释函数。（ &lt;code&gt;Module:Function/Arity&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f928094b6da781dfbc891a4120343ae4cc293b55" translate="yes" xml:space="preserve">
          <source>The first case is when we have the identity-function (&lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt;).</source>
          <target state="translated">第一种情况是我们具有身份功能（ &lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0fbbc3247a8beb8eb5ac78e663feb3fa54615a2" translate="yes" xml:space="preserve">
          <source>The first element in the list is isolated and the list is split into two sublists.</source>
          <target state="translated">列表中的第一个元素被隔离,列表被分成两个子列表。</target>
        </trans-unit>
        <trans-unit id="014ba2d1758d0deccfe95265702308ef94fdf898" translate="yes" xml:space="preserve">
          <source>The first element of &lt;code&gt;Type_List&lt;/code&gt; is the top type of the encoded message. In &lt;code&gt;Element_List&lt;/code&gt;, it is followed by each of the component names that leads to selected type.</source>
          <target state="translated">&lt;code&gt;Type_List&lt;/code&gt; 的第一个元素是编码消息的顶部类型。在 &lt;code&gt;Element_List&lt;/code&gt; 中，紧随其后的是每个导致所选类型的组件名称。</target>
        </trans-unit>
        <trans-unit id="dc44175b8c8ad2a17dc68dd4333970027d3739a1" translate="yes" xml:space="preserve">
          <source>The first element of a non-empty &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; provides the local IP address if an &lt;code&gt;ip&lt;/code&gt; option is not specified. The local address is either returned from&lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; or passed in a &lt;code&gt;connected&lt;/code&gt; message over the transport interface.</source>
          <target state="translated">如果未指定 &lt;code&gt;ip&lt;/code&gt; 选项，则 &lt;code&gt;Svc&lt;/code&gt; 中非空 &lt;code&gt;Host-IP-Address&lt;/code&gt; 列表的第一个元素将提供本地IP地址。本地地址可以从 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 返回，也可以通过传输接口通过 &lt;code&gt;connected&lt;/code&gt; 消息传递。</target>
        </trans-unit>
        <trans-unit id="1fb0352349ee5a8c0a7eb65cc210b44843f0b004" translate="yes" xml:space="preserve">
          <source>The first element of the tuple that is sent is your own pid. This enables &lt;code&gt;my_server&lt;/code&gt; to reply. For more information about the primitives, see the &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">发送的元组的第一个元素是您自己的pid。这使 &lt;code&gt;my_server&lt;/code&gt; 可以回复。有关原语的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="35c3d22f06a7d30ce2b647923cf3347f78831669" translate="yes" xml:space="preserve">
          <source>The first field of a record is the second element of the tuple, which is the representation of the record.</source>
          <target state="translated">记录的第一个字段是元组的第二个元素,它是记录的表示。</target>
        </trans-unit>
        <trans-unit id="2595903ccef1ec77d7c52522a5524a8e9b27b8b6" translate="yes" xml:space="preserve">
          <source>The first filter that the trace data is exposed for is the &lt;code&gt;Collector Filter&lt;/code&gt;. When a trace &lt;code&gt;Event&lt;/code&gt; is reported with &lt;code&gt;et_collector:report/2&lt;/code&gt; (or &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt;) the first thing that happens, is that a message is sent to the &lt;code&gt;Collector&lt;/code&gt; process to fetch a handle that contains some useful stuff, such as the &lt;code&gt;Collector Filter Fun&lt;/code&gt; and an Ets table identifier. Then the &lt;code&gt;Collector Filter Fun&lt;/code&gt; is applied and if it returns &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;{true, NewEvent}&lt;/code&gt;), the &lt;code&gt;Event&lt;/code&gt; will be stored in an Ets table. As an optimization, subsequent calls to &lt;code&gt;et_collector:report&lt;/code&gt;-functions can use the handle directly instead of the &lt;code&gt;Collector Pid&lt;/code&gt;.</source>
          <target state="translated">公开跟踪数据的第一个过滤器是 &lt;code&gt;Collector Filter&lt;/code&gt; 。当使用 &lt;code&gt;et_collector:report/2&lt;/code&gt; （或 &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; ）报告跟踪 &lt;code&gt;Event&lt;/code&gt; ，发生的第一件事是将一条消息发送到 &lt;code&gt;Collector&lt;/code&gt; 进程以获取包含一些有用内容的句柄，例如所述 &lt;code&gt;Collector Filter Fun&lt;/code&gt; 和ETS表标识符。然后应用 &lt;code&gt;Collector Filter Fun&lt;/code&gt; 功能，如果它返回 &lt;code&gt;true&lt;/code&gt; （或 &lt;code&gt;{true, NewEvent}&lt;/code&gt; ），则该 &lt;code&gt;Event&lt;/code&gt; 将存储在Ets表中。作为优化，随后对 &lt;code&gt;et_collector:report&lt;/code&gt; 的调用-functions可以直接使用该句柄，而不是 &lt;code&gt;Collector Pid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e93729010b78d1e9fdfb6095e599e11dc46611ef" translate="yes" xml:space="preserve">
          <source>The first has the effect of clearing any previous inherits, the second of replacing a previous inherits of &lt;code&gt;Prev&lt;/code&gt; to one of &lt;code&gt;Mod&lt;/code&gt;. This allows the semantics of the input dictionary to be changed without modifying the file itself.</source>
          <target state="translated">第一个具有清除所有先前继承的作用，第二个具有将 &lt;code&gt;Prev&lt;/code&gt; 的先前继承替换为 &lt;code&gt;Mod&lt;/code&gt; 之一的作用。这允许在不修改文件本身的情况下更改输入字典的语义。</target>
        </trans-unit>
        <trans-unit id="ceb71912301094043ae2a458700ad5b6cfbe752e" translate="yes" xml:space="preserve">
          <source>The first implementation of DTrace probes for the Erlang virtual machine was presented at the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt;. That work, based on the Erlang/OTP R12 release, was discontinued due to what appears to be miscommunication with the original developers.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt; 介绍了针对Erlang虚拟机的DTrace探针的第一个实现。由于与原始开发人员的沟通不畅，该基于Erlang / OTP R12版本的工作被终止了。</target>
        </trans-unit>
        <trans-unit id="3f97c49dffef8a26851ac783d21a876b74a6d528" translate="yes" xml:space="preserve">
          <source>The first instruction, &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; is described in the previous section.</source>
          <target state="translated">第一条指令 &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; 在上一节中进行了描述。</target>
        </trans-unit>
        <trans-unit id="e790f114bc8cf3a2ce28aebcfae1d5a3836f6a2d" translate="yes" xml:space="preserve">
          <source>The first is the current value.</source>
          <target state="translated">第一个是当前值。</target>
        </trans-unit>
        <trans-unit id="314cc6cc859765f9b7338047d208d202513bf56d" translate="yes" xml:space="preserve">
          <source>The first level is at the UDP entry / exit point, i.e. immediately after the receipt of the message, before any message processing is done (accept_recv) and immediately before sending the message, after all message processing is done (accept_send).</source>
          <target state="translated">第一层是在UDP入口/出口处,即在收到消息后,在任何消息处理完成之前(accept_recv),以及在发送消息前,在所有消息处理完成后(accept_send)。</target>
        </trans-unit>
        <trans-unit id="c16552c0f99d14efe5fd0c93c7ebdd486a4076a9" translate="yes" xml:space="preserve">
          <source>The first level is at the transport entry / exit point, i.e. immediately after the receipt of the message before any message processing is done (accept_recv) and immediately before sending the message after all message processing is done (accept_send).</source>
          <target state="translated">第一级是在传输入口/出口处,即在收到消息后紧接着进行任何消息处理(accept_recv)和在完成所有消息处理后紧接着发送消息(accept_send)。</target>
        </trans-unit>
        <trans-unit id="bbb474799d3c2ceaecdb69173050f2d2cde6ff68" translate="yes" xml:space="preserve">
          <source>The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, as no-pattern is not present, the subpattern matches nothing. That is, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.</source>
          <target state="translated">第一部分匹配一个可选的开头小括号,如果该字符存在,则将其设置为第一个捕获的子串。第二部分匹配一个或多个非小括号的字符。第三部分是一个条件子模式,测试第一组小括号是否匹配。如果它们符合,也就是说,如果主题是以开头的小括号开始的,那么条件为真,所以执行yes-pattern,并且需要关闭小括号。否则,由于no-pattern不存在,子模式什么也不匹配。也就是说,这个模式匹配的是一个非括号的序列,可以选择用括号括起来。</target>
        </trans-unit>
        <trans-unit id="f02f68659112d26dce19edf7fe8cbae93aa2769c" translate="yes" xml:space="preserve">
          <source>The first part of the 64 bit template is identical to the 32 bit one, but there are some environment variable differences:</source>
          <target state="translated">64位模板的第一部分与32位模板相同,但有一些环境变量的差异。</target>
        </trans-unit>
        <trans-unit id="f65a1941d5d1778fd847b32c5e58a7ed60e551a2" translate="yes" xml:space="preserve">
          <source>The first part of the crash dump shows the following:</source>
          <target state="translated">崩溃转储的第一部分显示以下内容。</target>
        </trans-unit>
        <trans-unit id="2cc97c1e58d4679396d3bf61c813a63a062816e6" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a DEFINE group inside which is a another group named &quot;byte&quot; is defined. This matches an individual component of an IPv4 address (a number &amp;lt; 256). When matching takes place, this part of the pattern is skipped, as DEFINE acts like a false condition. The remaining pattern uses references to the named group to match the four dot-separated components of an IPv4 address, insisting on a word boundary at each end.</source>
          <target state="translated">模式的第一部分是DEFINE组，在其中定义了另一个名为&amp;ldquo;字节&amp;rdquo;的组。这与IPv4地址的单个组成部分匹配（数字&amp;lt;256）。进行匹配时，由于DEFINE的作用类似于错误条件，因此会跳过此部分模式。其余的模式使用对命名组的引用来匹配IPv4地址的四个点分隔的部分，并在每一端都坚持单词边界。</target>
        </trans-unit>
        <trans-unit id="7724368c62d5b897d69875d863fc670d000c0a9f" translate="yes" xml:space="preserve">
          <source>The first part of the reference number in ref &lt;code&gt;t&lt;/code&gt;. Use only for compatibility.</source>
          <target state="translated">参考数字的第一部分在ref &lt;code&gt;t&lt;/code&gt; 中。仅用于兼容性。</target>
        </trans-unit>
        <trans-unit id="232ebbaa469296f40c7a1846dbf2fa546b56c045" translate="yes" xml:space="preserve">
          <source>The first part says that the factorial of 1 is 1.:</source>
          <target state="translated">第一部分说,1的阶乘是1。</target>
        </trans-unit>
        <trans-unit id="dac65be594adc3151ec035f4511e37fe28d74a93" translate="yes" xml:space="preserve">
          <source>The first program contains some inadequacies regarding handling of nodes which disappear. These are corrected in a later version of the program.</source>
          <target state="translated">第一个程序在处理消失的节点方面有一些不足之处。这些问题在程序的后一版本中得到了纠正。</target>
        </trans-unit>
        <trans-unit id="90106de27192d6ca833e750e4d48c96656c2317b" translate="yes" xml:space="preserve">
          <source>The first record attribute is the primary key, or key for short.</source>
          <target state="translated">第一个记录属性是主键,简称键。</target>
        </trans-unit>
        <trans-unit id="3a82a7bb7498f5fc4876294f7dfadf942e9bd19c" translate="yes" xml:space="preserve">
          <source>The first state that is entered will get a state enter call with &lt;code&gt;OldState&lt;/code&gt; equal to the current state.</source>
          <target state="translated">输入的第一个状态将获得状态输入调用，其中 &lt;code&gt;OldState&lt;/code&gt; 等于当前状态。</target>
        </trans-unit>
        <trans-unit id="6086c2b9bf8be61602b6ebcc9d1ba07de24d3cb9" translate="yes" xml:space="preserve">
          <source>The first sublist contains all elements that are smaller than the first element in the list.</source>
          <target state="translated">第一个子列表包含所有比列表中第一个元素小的元素。</target>
        </trans-unit>
        <trans-unit id="7c16a3275bdd107763aa82124e29bdb96e0aa246" translate="yes" xml:space="preserve">
          <source>The first subsection will give a short background of the SSH protocol while later sections describes the implementation and provides some examples</source>
          <target state="translated">第一小节将简要介绍SSH协议的背景,而后面的章节则描述了SSH协议的实现,并提供了一些例子。</target>
        </trans-unit>
        <trans-unit id="ea7284e31b879942988ef1c4ac5a9d9ef85d8089" translate="yes" xml:space="preserve">
          <source>The first test to run includes all suites for system &lt;code&gt;t1&lt;/code&gt;. Suites &lt;code&gt;t1B&lt;/code&gt; and &lt;code&gt;t1D&lt;/code&gt; are excluded from the test. Test cases &lt;code&gt;test3&lt;/code&gt; and &lt;code&gt;test4&lt;/code&gt; in &lt;code&gt;t1A&lt;/code&gt; and &lt;code&gt;test1&lt;/code&gt; case in &lt;code&gt;t1C&lt;/code&gt; are also excluded from the test.</source>
          <target state="translated">运行的第一个测试包括系统 &lt;code&gt;t1&lt;/code&gt; 的所有套件。套件 &lt;code&gt;t1B&lt;/code&gt; 和 &lt;code&gt;t1D&lt;/code&gt; 从测试中排除。测试用例 &lt;code&gt;test3&lt;/code&gt; 和 &lt;code&gt;test4&lt;/code&gt; 在 &lt;code&gt;t1A&lt;/code&gt; 和 &lt;code&gt;test1&lt;/code&gt; 的情况下， &lt;code&gt;t1C&lt;/code&gt; ，也排除了检验。</target>
        </trans-unit>
        <trans-unit id="5ca5c4abe4913702f7baf25de35a02c261b509bb" translate="yes" xml:space="preserve">
          <source>The first thing &lt;code&gt;blend/2&lt;/code&gt; does is to calculate the resulting alpha channel:</source>
          <target state="translated">&lt;code&gt;blend/2&lt;/code&gt; 做的第一件事是计算所得的alpha通道：</target>
        </trans-unit>
        <trans-unit id="39ceda5701132f42099520c75ed5fefa2f0ce8cf" translate="yes" xml:space="preserve">
          <source>The first thing you need to do, is to make sure you have an ODBC driver installed for the database that you want to access. Both the client machine where you plan to run your erlang node and the server machine running the database needs the the ODBC driver. (In some cases the client and the server may be the same machine).</source>
          <target state="translated">首先,你需要做的是确保你要访问的数据库已经安装了ODBC驱动。运行erlang节点的客户机和运行数据库的服务器都需要安装ODBC驱动。在某些情况下,客户端和服务器可能是同一台机器)。</target>
        </trans-unit>
        <trans-unit id="2aae989cc7522942aff9cad7059abdf3f11420db" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;Fun&lt;/code&gt; is applied, &lt;code&gt;Acc0&lt;/code&gt; is the second argument. The next time &lt;code&gt;Fun&lt;/code&gt; is called, the return value from the previous call is used as the second argument. The term the last call to &lt;code&gt;Fun&lt;/code&gt; returns is the return value of the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第一次应用 &lt;code&gt;Fun&lt;/code&gt; 时， &lt;code&gt;Acc0&lt;/code&gt; 是第二个参数。下次调用 &lt;code&gt;Fun&lt;/code&gt; 时，上一次调用的返回值将用作第二个参数。最后一次调用 &lt;code&gt;Fun&lt;/code&gt; 返回的术语是函数 &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="50b73034e77a90f94080fa89965c6eaf0283e9d6" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;bchunk/2&lt;/code&gt; is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided.</source>
          <target state="translated">首次调用 &lt;code&gt;bchunk/2&lt;/code&gt; &lt;code&gt;start&lt;/code&gt; ，必须提供初始延续，即原子start。</target>
        </trans-unit>
        <trans-unit id="0c2f550699da636c0cd8e01902373a891091a02a" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; (or &lt;code&gt;bchunk()&lt;/code&gt;) is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided. If a disk log process is running on the current node, terms are read from that log. Otherwise, an individual distributed log on some other node is chosen, if such a log exists.</source>
          <target state="translated">第一次调用 &lt;code&gt;chunk()&lt;/code&gt; （或 &lt;code&gt;bchunk()&lt;/code&gt; ） &lt;code&gt;start&lt;/code&gt; ，必须提供一个初始延续，即原子start。如果当前节点上正在运行磁盘日志进程，则会从该日志中读取术语。否则，将选择某个其他节点上的单个分布式日志（如果存在）。</target>
        </trans-unit>
        <trans-unit id="2ae42b9440fbcdcd3aef0e04e0d47cfcd6b93638" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; is called, an initial continuation returned from &lt;code&gt;open/1&lt;/code&gt; or &lt;code&gt;open/2&lt;/code&gt; must be provided.</source>
          <target state="translated">第一次调用 &lt;code&gt;chunk()&lt;/code&gt; 时，必须提供从 &lt;code&gt;open/1&lt;/code&gt; 或 &lt;code&gt;open/2&lt;/code&gt; 返回的初始延续。</target>
        </trans-unit>
        <trans-unit id="f24cb290ca20c81eb6b4416fabb904d4e10dd7ea" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;my_binary_to_list/1&lt;/code&gt; is called, a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; is created. The match context points to the first byte of the binary. 1 byte is matched out and the match context is updated to point to the second byte in the binary.</source>
          <target state="translated">首次调用 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 时，将创建一个 &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; 。匹配上下文指向二进制文件的第一个字节。1个字节被匹配，并且匹配上下文被更新以指向二进制文件中的第二个字节。</target>
        </trans-unit>
        <trans-unit id="1823ded8e66bfbd9fc7ce09687bb9aaa31338fbb" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;save_scenario/0&lt;/code&gt; is called a server will be started. This server will save runtime scenarios. All saved scenarios can be removed by calling &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首次调用 &lt;code&gt;save_scenario/0&lt;/code&gt; 时,将启动服务器。该服务器将保存运行时方案。可以通过调用 &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; 删除所有保存的方案。</target>
        </trans-unit>
        <trans-unit id="2da631291d48912dfb7f5e3e966ba2a0afa5f92f" translate="yes" xml:space="preserve">
          <source>The first time this function is called, &lt;code&gt;error_logger&lt;/code&gt; is added as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is started.</source>
          <target state="translated">第一次调用此函数时，将 &lt;code&gt;error_logger&lt;/code&gt; 添加为Logger处理程序，并启动 &lt;code&gt;error_logger&lt;/code&gt; 进程。</target>
        </trans-unit>
        <trans-unit id="0ac2627c749c91f8bf457c1c48d430daa18c89a6" translate="yes" xml:space="preserve">
          <source>The first user &quot;sends&quot; the message in the example above by:</source>
          <target state="translated">在上面的例子中,第一个用户通过 &quot;发送 &quot;消息。</target>
        </trans-unit>
        <trans-unit id="03cb12d8f1c72fe9141e80abe570426dd8888741" translate="yes" xml:space="preserve">
          <source>The first value indicates the default &lt;code&gt;priv_dir&lt;/code&gt; behavior, that is, one private directory created per test run. The two latter values tell &lt;code&gt;Common Test&lt;/code&gt; to generate a unique test directory name per test case and execution. If the auto version is used, &lt;strong&gt;all&lt;/strong&gt; private directories are created automatically. This can become very inefficient for test runs with many test cases or repetitions, or both. Therefore, if the manual version is used instead, the test case must tell &lt;code&gt;Common Test&lt;/code&gt; to create &lt;code&gt;priv_dir&lt;/code&gt; when it needs it. It does this by calling the function &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第一个值指示默认的 &lt;code&gt;priv_dir&lt;/code&gt; 行为，即，每次测试运行都创建一个私有目录。后两个值告诉 &lt;code&gt;Common Test&lt;/code&gt; 为每个测试用例和执行生成唯一的测试目录名称。如果使用自动版本，则会自动创建&lt;strong&gt;所有&lt;/strong&gt;私有目录。对于具有许多测试用例或重复项（或两者都有）的测试运行，这可能变得非常低效。因此，如果改为使用手动版本，则测试用例必须告诉 &lt;code&gt;Common Test&lt;/code&gt; 在需要时创建 &lt;code&gt;priv_dir&lt;/code&gt; 。它通过调用函数 &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt; 来做到这一点。</target>
        </trans-unit>
        <trans-unit id="5b7f2b74f4ad7fcb69baccbea779f423b38f85de" translate="yes" xml:space="preserve">
          <source>The first value is limited to the values 0, 1, or 2. The second value must be in the range 0..39 when the first value is 0 or 1.</source>
          <target state="translated">第一个值限制在0、1或2的范围内。当第一个值为0或1时,第二个值必须在0...39的范围内。</target>
        </trans-unit>
        <trans-unit id="76cac286407464f1a3cab30ae6ed03a1a8b426a4" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-extra&lt;/code&gt; is treated in special way. Its scope ends at the end of the file. Arguments following an &lt;code&gt;-extra&lt;/code&gt; flag are moved on the command line into the &lt;code&gt;-extra&lt;/code&gt; section, that is, the end of the command line following after an &lt;code&gt;-extra&lt;/code&gt; flag.</source>
          <target state="translated">标志 &lt;code&gt;-extra&lt;/code&gt; 以特殊方式处理。其作用域在文件末尾结束。 &lt;code&gt;-extra&lt;/code&gt; 标志后面的参数在命令行上移至 &lt;code&gt;-extra&lt;/code&gt; 部分，即，在 &lt;code&gt;-extra&lt;/code&gt; 标志后面的命令行末尾。</target>
        </trans-unit>
        <trans-unit id="095fd71fa9f6ba7fe4c40943793a2bb698c7bbdc" translate="yes" xml:space="preserve">
          <source>The flag can also be set by the STDLIB application variable &lt;code&gt;shell_strings&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;, which means that lists of integers are printed using the string syntax, when possible. Value &lt;code&gt;false&lt;/code&gt; means that no lists are printed using the string syntax.</source>
          <target state="translated">该标志也可以由STDLIB应用程序变量 &lt;code&gt;shell_strings&lt;/code&gt; 设置。默认值为 &lt;code&gt;true&lt;/code&gt; ，这意味着尽可能使用字符串语法打印整数列表。值 &lt;code&gt;false&lt;/code&gt; 表示不使用字符串语法打印任何列表。</target>
        </trans-unit>
        <trans-unit id="16ee325443e908603dacad16b814927c10a42e37" translate="yes" xml:space="preserve">
          <source>The flag field of an atom cache reference has the following format:</source>
          <target state="translated">原子缓存引用的标志字段有如下格式。</target>
        </trans-unit>
        <trans-unit id="a080305c71ef71f1663e7718a0bc9d58d29dd1e8" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;suite&lt;/code&gt;, and &lt;code&gt;group/case&lt;/code&gt; can be combined. For example, to run &lt;code&gt;x_SUITE&lt;/code&gt; and &lt;code&gt;y_SUITE&lt;/code&gt; in directory &lt;code&gt;testdir&lt;/code&gt;, as follows:</source>
          <target state="translated">可以将标志 &lt;code&gt;dir&lt;/code&gt; ， &lt;code&gt;suite&lt;/code&gt; 和 &lt;code&gt;group/case&lt;/code&gt; 组合在一起。例如，要在目录 &lt;code&gt;testdir&lt;/code&gt; 中运行 &lt;code&gt;x_SUITE&lt;/code&gt; 和 &lt;code&gt;y_SUITE&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="b93b96139f6762ecd80290edd696f2ed98f35890" translate="yes" xml:space="preserve">
          <source>The flags specific to the MIB compiler can be specified by using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">可以使用 &lt;code&gt;+&lt;/code&gt; 语法指定特定于MIB编译器的标志：</target>
        </trans-unit>
        <trans-unit id="428847ac69b6b0b0a5e6c4145d8ec6d570f6c395" translate="yes" xml:space="preserve">
          <source>The flex libraries. Without it, the flex powered codecs cannot be used.</source>
          <target state="translated">flex库。没有它,就无法使用flex动力编解码器。</target>
        </trans-unit>
        <trans-unit id="c159710396ee724ac90ec79947b2b5b4c1587632" translate="yes" xml:space="preserve">
          <source>The flex scanner is written using a tool called &lt;strong&gt;flex&lt;/strong&gt;. In order to be able to compile the flex scanner driver, this tool has to be available.</source>
          <target state="translated">flex扫描仪是使用称为&lt;strong&gt;flex&lt;/strong&gt;的工具编写的。为了能够编译Flex扫描仪驱动程序，该工具必须可用。</target>
        </trans-unit>
        <trans-unit id="d7c4ca511a9bd4686762da41fca66fa99a0af1b0" translate="yes" xml:space="preserve">
          <source>The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag.</source>
          <target state="translated">本模块中的浮点生成函数在从整数转换时浪费了最低位,所以它们避免了这个问题。</target>
        </trans-unit>
        <trans-unit id="c041ae86c5f8c7016b0e10add46c29cac233bc88" translate="yes" xml:space="preserve">
          <source>The floating point value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 的浮点值。</target>
        </trans-unit>
        <trans-unit id="e419b2fab0b36bcecd87f0c3d0efca53ec378a69" translate="yes" xml:space="preserve">
          <source>The focus of the Erlang reference manual is on the language itself, not the implementation of it. The language constructs are described in text and with examples rather than formally specified. This is to make the manual more readable. The Erlang reference manual is not intended as a tutorial.</source>
          <target state="translated">Erlang参考手册的重点是语言本身,而不是它的实现。语言的结构用文字和例子来描述,而不是正式指定。这是为了使手册更易读。Erlang参考手册并不是作为一个教程。</target>
        </trans-unit>
        <trans-unit id="14233773185c2d086e35c41f6b44cd3cb166311c" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;#hs_data{}&lt;/code&gt; record fields need to be set unless otherwise stated:</source>
          <target state="translated">除非另有说明，否则需要设置以下 &lt;code&gt;#hs_data{}&lt;/code&gt; 记录字段：</target>
        </trans-unit>
        <trans-unit id="755882894d7fd28bede6b99ec073119565eb9367" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s are available. All states are exclusive, meaning that a thread cannot be in two states at once. So, if you add the numbers of all counters in a thread, you get the total runtime for that thread.</source>
          <target state="translated">以下 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; 可用。所有状态都是互斥的，这意味着一个线程不能同时处于两种状态。因此，如果将一个线程中所有计数器的数量相加，则将获得该线程的总运行时间。</target>
        </trans-unit>
        <trans-unit id="9f76f02eae75217eb2a5f3c4fb6a601b97548d9f" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes pretty printing of NETCONF traffic to separate logs for the connections named &lt;code&gt;nc_server1&lt;/code&gt; and &lt;code&gt;nc_server2&lt;/code&gt;. Any other connections are logged to default NETCONF log.</source>
          <target state="translated">下面的 &lt;code&gt;ct_hooks&lt;/code&gt; 语句可以漂亮地打印NETCONF通信量，以分隔名为 &lt;code&gt;nc_server1&lt;/code&gt; 和 &lt;code&gt;nc_server2&lt;/code&gt; 的连接的日志。任何其他连接都记录到默认的NETCONF日志中。</target>
        </trans-unit>
        <trans-unit id="60898a22579d212b66c103e94e65e3704c005128" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes printing of Telnet traffic to separate logs for the connections &lt;code&gt;server1&lt;/code&gt; and &lt;code&gt;server2&lt;/code&gt;. Traffic for any other connections is logged in the default Telnet log.</source>
          <target state="translated">以下 &lt;code&gt;ct_hooks&lt;/code&gt; 语句导致打印Telnet流量，以将连接 &lt;code&gt;server1&lt;/code&gt; 和 &lt;code&gt;server2&lt;/code&gt; 的日志分开。其他任何连接的流量都记录在默认的Telnet日志中。</target>
        </trans-unit>
        <trans-unit id="1bc4e72d8d4d5620576eec368f8680635ae64598" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;upgrade&lt;/code&gt; instruction is used for supervisors:</source>
          <target state="translated">以下 &lt;code&gt;upgrade&lt;/code&gt; 说明适用于主管：</target>
        </trans-unit>
        <trans-unit id="7721dfe03e9c154ea4e1c34f92eac19aef611c75" translate="yes" xml:space="preserve">
          <source>The following ASN.1 type is used for real numbers:</source>
          <target state="translated">以下ASN.1类型用于实数。</target>
        </trans-unit>
        <trans-unit id="da76d97e2e28f2e89ed233e203305a30d4111d61" translate="yes" xml:space="preserve">
          <source>The following BIFs, which are used to create processes, return values of this data type:</source>
          <target state="translated">以下用于创建流程的BIF返回该数据类型的值。</target>
        </trans-unit>
        <trans-unit id="ca462812b4b616c1a4a1c09a1f4a79f0f85f0e72" translate="yes" xml:space="preserve">
          <source>The following CTH logs information about a test run into a format parseable by &lt;code&gt;file:consult/1&lt;/code&gt; (in Kernel):</source>
          <target state="translated">以下CTH将有关测试运行的信息记录为 &lt;code&gt;file:consult/1&lt;/code&gt; （在内核中）可解析的格式：</target>
        </trans-unit>
        <trans-unit id="9e71ecc8d7cab4d72922ae4ed2e33319f8122346" translate="yes" xml:space="preserve">
          <source>The following I/O request is optional to implement and a client is to be prepared for an error return:</source>
          <target state="translated">下面的I/O请求是可以选择实现的,客户端要做好错误返回的准备。</target>
        </trans-unit>
        <trans-unit id="0827ebd08d8a02057148a27dc548b0eb839f8cf1" translate="yes" xml:space="preserve">
          <source>The following Item's are valid:</source>
          <target state="translated">以下项目有效。</target>
        </trans-unit>
        <trans-unit id="8931f5659efe1bfa45e91bfba89a696d04a3885e" translate="yes" xml:space="preserve">
          <source>The following Kernel configuration parameters apply to Logger:</source>
          <target state="translated">以下内核配置参数适用于记录仪。</target>
        </trans-unit>
        <trans-unit id="9f963b53749dee80b3ebd6d93009cb72dd723e7e" translate="yes" xml:space="preserve">
          <source>The following Logger API functions can trigger this callback:</source>
          <target state="translated">以下记录仪 API 函数可以触发此回调。</target>
        </trans-unit>
        <trans-unit id="59d2e24198262f39e955cdd7b2bb38352780ad95" translate="yes" xml:space="preserve">
          <source>The following MIBs are built-ins of the Erlang SNMP compiler: SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and RFC1155-SMI. They cannot therefore be compiled separately.</source>
          <target state="translated">以下MIB是Erlang SNMP编译器内置的。SNMPv2-SMI、RFC-1215、RFC-1212、SNMPv2-TC、SNMPv2-CONF和RFC1155-SMI。因此,它们不能被单独编译。</target>
        </trans-unit>
        <trans-unit id="52d19d789c25255eed9a979999ac8863363f1228" translate="yes" xml:space="preserve">
          <source>The following MIBs are defined in the OTP system:</source>
          <target state="translated">OTP系统中定义了以下MIB。</target>
        </trans-unit>
        <trans-unit id="f58c9a6d16d6a288dad320d6e8998be16e44721f" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private DSA key:</source>
          <target state="translated">下面的PEM文件只有一个条目,一个私人DSA密钥。</target>
        </trans-unit>
        <trans-unit id="0a1e06caf4405f8154436d98b0b535f1d1da5766" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private RSA key:</source>
          <target state="translated">下面的PEM文件只有一个条目,一个私人RSA密钥。</target>
        </trans-unit>
        <trans-unit id="bf6e0ebe475e308588ade6bad38f0a1b0d7fad83" translate="yes" xml:space="preserve">
          <source>The following activity access contexts are currently supported:</source>
          <target state="translated">目前支持以下活动访问环境:</target>
        </trans-unit>
        <trans-unit id="9f7f3d9893eedee1a260cc5b49377b2f1f743ccc" translate="yes" xml:space="preserve">
          <source>The following algorithms are provided:</source>
          <target state="translated">提供以下算法:</target>
        </trans-unit>
        <trans-unit id="390e0b5eb1e3b7230aad019d3e06855c658180f0" translate="yes" xml:space="preserve">
          <source>The following allocators are present:</source>
          <target state="translated">有以下分配器:</target>
        </trans-unit>
        <trans-unit id="c4821bb8c6c116cef14beeab931818f4969279b8" translate="yes" xml:space="preserve">
          <source>The following are primitives, which do not contain other test sets as arguments:</source>
          <target state="translated">以下是基元,不包含其他测试集作为参数。</target>
        </trans-unit>
        <trans-unit id="b988567cb4ebfa83309f7036c88dc38f105b9489" translate="yes" xml:space="preserve">
          <source>The following are reserved words in Erlang:</source>
          <target state="translated">以下是Erlang中的保留字。</target>
        </trans-unit>
        <trans-unit id="23a58c2300ac41928639f29dbe01e89240b2ddfc" translate="yes" xml:space="preserve">
          <source>The following are some of the most important and attractive capabilities provided by Mnesia:</source>
          <target state="translated">以下是Mnesia提供的一些最重要和最有吸引力的能力。</target>
        </trans-unit>
        <trans-unit id="446aea39bd6d645ca35077d4770c830fb9a617e9" translate="yes" xml:space="preserve">
          <source>The following are the fun clauses parameter lists:</source>
          <target state="translated">以下是趣味子句参数表。</target>
        </trans-unit>
        <trans-unit id="b9a2d4753855996ec68919109001bdcfdfab1176" translate="yes" xml:space="preserve">
          <source>The following are the horizontal space characters:</source>
          <target state="translated">以下是横向空格字符。</target>
        </trans-unit>
        <trans-unit id="5e7dca09b462b81dbf316dd39e6aa81ce86d2e59" translate="yes" xml:space="preserve">
          <source>The following are the main features of Trace Tool Builder:</source>
          <target state="translated">以下是Trace Tool Builder的主要功能。</target>
        </trans-unit>
        <trans-unit id="4e925277c492d9e6356d76bfacfb3ab772525403" translate="yes" xml:space="preserve">
          <source>The following are the most widely spread encodings:</source>
          <target state="translated">以下是传播最广的编码:</target>
        </trans-unit>
        <trans-unit id="1d30a8b8e3b663292a1ad0bd4a17fb0b5f2c8ae2" translate="yes" xml:space="preserve">
          <source>The following are the possible runtime errors:</source>
          <target state="translated">以下是可能的运行时错误。</target>
        </trans-unit>
        <trans-unit id="11e4ce827beb7d257dafdeafaf65224573e225ee" translate="yes" xml:space="preserve">
          <source>The following are the predefined sets of subpatterns:</source>
          <target state="translated">以下是预定义的子模式集。</target>
        </trans-unit>
        <trans-unit id="b8aeeeb29a22d61e4651a7f7c64491c002da04f2" translate="yes" xml:space="preserve">
          <source>The following are the supported class names:</source>
          <target state="translated">以下是支持的类名。</target>
        </trans-unit>
        <trans-unit id="0ae73677bdb343efa75ef5239df98c3995eb5a45" translate="yes" xml:space="preserve">
          <source>The following are the vertical space characters:</source>
          <target state="translated">以下是垂直空间字符。</target>
        </trans-unit>
        <trans-unit id="e13eea1a0552634ec49861dfedef83923f03fb36" translate="yes" xml:space="preserve">
          <source>The following argument is required:</source>
          <target state="translated">需要以下参数:</target>
        </trans-unit>
        <trans-unit id="b3fe3a25174fa0e4b7397791cbe163414c93cae5" translate="yes" xml:space="preserve">
          <source>The following behavior applies if &lt;code&gt;Reason&lt;/code&gt; is any term, except &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;kill&lt;/code&gt;:</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Reason&lt;/code&gt; 是除 &lt;code&gt;normal&lt;/code&gt; 或 &lt;code&gt;kill&lt;/code&gt; 之外的任何术语，则以下行为适用：</target>
        </trans-unit>
        <trans-unit id="ed43b5794a433578fe75d6227c8f8fec9b973992" translate="yes" xml:space="preserve">
          <source>The following built-in handlers exist:</source>
          <target state="translated">存在以下内置处理程序。</target>
        </trans-unit>
        <trans-unit id="e48df9c121f20b43e9189951e6b161ed4e78306b" translate="yes" xml:space="preserve">
          <source>The following built-in list types also exist, but they are expected to be rarely used. Hence, they have long names:</source>
          <target state="translated">下列内置列表类型也存在,但预计很少使用。因此,它们的名字很长。</target>
        </trans-unit>
        <trans-unit id="56efeb40efc4a8607cb2cf3d6a1bbfa58461fecd" translate="yes" xml:space="preserve">
          <source>The following call would create a table that is replicated on two nodes, has an extra index on attribute &lt;code&gt;y&lt;/code&gt;, and is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">以下调用将创建一个表，该表在两个节点上复制，在属性 &lt;code&gt;y&lt;/code&gt; 上具有额外的索引，并且类型为 &lt;code&gt;bag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b93cef34769b4ac84bcc58e1f7579a27e1900915" translate="yes" xml:space="preserve">
          <source>The following calls use the default client profile. Use the proxy &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt;, except from requests to localhost. This applies to all the following requests.</source>
          <target state="translated">以下调用使用默认的客户端配置文件。使用代理 &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt; ，但对本地主机的请求除外。这适用于以下所有请求。</target>
        </trans-unit>
        <trans-unit id="6ce6762a2b45b2a9419ebd342a2248363882b1ec" translate="yes" xml:space="preserve">
          <source>The following can be done from the shell:</source>
          <target state="translated">可以在shell中进行以下操作。</target>
        </trans-unit>
        <trans-unit id="53f1ccb49a8a37c5657c1e09929d43e77df7e6d3" translate="yes" xml:space="preserve">
          <source>The following can help you estimate the buffer requirements for a term. Notice that this information is implementation-specific, and can change in future versions. If you are unsure, use &lt;code&gt;erl_term_len()&lt;/code&gt;.</source>
          <target state="translated">以下内容可以帮助您估算一个学期的缓冲区要求。请注意，此信息是特定于实现的，并且在以后的版本中可能会更改。如果不确定，请使用 &lt;code&gt;erl_term_len()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f875dcb652b105150192f44a7e364beec117361" translate="yes" xml:space="preserve">
          <source>The following capability flags are defined:</source>
          <target state="translated">定义了以下能力标志:</target>
        </trans-unit>
        <trans-unit id="b153457b0c6c74e16cf68b399d11c4fdbeda5276" translate="yes" xml:space="preserve">
          <source>The following capability identifiers, defined in RFC 4741 NETCONF Configuration Protocol, can be returned:</source>
          <target state="translated">可以返回RFC 4741 NETCONF配置协议中定义的以下能力标识符。</target>
        </trans-unit>
        <trans-unit id="729ccfc9617ba57afc9d1a89abcf609beb87615d" translate="yes" xml:space="preserve">
          <source>The following causes an error at compile time:</source>
          <target state="translated">以下情况在编译时导致错误。</target>
        </trans-unit>
        <trans-unit id="46da2b6d47972d1cbb42e35ed601e935a7066068" translate="yes" xml:space="preserve">
          <source>The following changes are added:</source>
          <target state="translated">增加了以下变化:</target>
        </trans-unit>
        <trans-unit id="223954bbc5bf81b4921c410a25f0bd6051babb47" translate="yes" xml:space="preserve">
          <source>The following code adds a parser interface to the grammar:</source>
          <target state="translated">下面的代码为该语法添加了一个解析器接口。</target>
        </trans-unit>
        <trans-unit id="132d723fbc5d22b21ca88cffc9fa6e6381b81134" translate="yes" xml:space="preserve">
          <source>The following code defines a function &lt;code&gt;pconst(X)&lt;/code&gt; in the module &lt;code&gt;funparse&lt;/code&gt;, which returns a fun that parses a list of tokens:</source>
          <target state="translated">下面的代码定义了一个函数 &lt;code&gt;pconst(X)&lt;/code&gt; 在模块 &lt;code&gt;funparse&lt;/code&gt; ，它返回解析的令牌列表的乐趣：</target>
        </trans-unit>
        <trans-unit id="56844778b2176882fb2364c894e6a3f1cbf9d20a" translate="yes" xml:space="preserve">
          <source>The following code exemplifies a search with a non-normalized data model. To find all employees at department &lt;code&gt;Dep&lt;/code&gt; with a salary higher than &lt;code&gt;Salary&lt;/code&gt;, use the following code:</source>
          <target state="translated">以下代码举例说明了使用非规范化数据模型进行的搜索。要查找部门 &lt;code&gt;Dep&lt;/code&gt; 中薪水高于 &lt;code&gt;Salary&lt;/code&gt; 的所有员工，请使用以下代码：</target>
        </trans-unit>
        <trans-unit id="3cf0020bc55d0fa1c895bb9fac0126cb39735295" translate="yes" xml:space="preserve">
          <source>The following code fragment is a simple example of a client connecting to a server at port 5678, transferring a binary, and closing the connection:</source>
          <target state="translated">下面的代码片段是一个简单的例子,客户端连接到5678端口的服务器,传输二进制文件,并关闭连接。</target>
        </trans-unit>
        <trans-unit id="aa22415381d6bc1bea3d2a6fcf7c7cf3cea03a9e" translate="yes" xml:space="preserve">
          <source>The following code illustrates how a &lt;code&gt;Mnesia&lt;/code&gt; table is converted to be a fragmented table and how more fragments are added later:</source>
          <target state="translated">以下代码说明了如何将 &lt;code&gt;Mnesia&lt;/code&gt; 表转换为碎片表以及以后如何添加更多碎片：</target>
        </trans-unit>
        <trans-unit id="4edc8cb91e65e300012f8cc9f371bfd50b18952b" translate="yes" xml:space="preserve">
          <source>The following code is executed to achieve this:</source>
          <target state="translated">执行以下代码来实现这一目的。</target>
        </trans-unit>
        <trans-unit id="bf087b2d7139054e72c10f87277f4e9105ae6aae" translate="yes" xml:space="preserve">
          <source>The following code is from the sample file &lt;code&gt;next_perm.cc&lt;/code&gt;. The driver entry looks like before, but also contains the callback &lt;code&gt;ready_async&lt;/code&gt;.</source>
          <target state="translated">以下代码来自示例文件 &lt;code&gt;next_perm.cc&lt;/code&gt; 。驱动程序条目看起来像以前一样，但还包含回调 &lt;code&gt;ready_async&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd629e06b526d07e792ece40b307e86e30aa4c96" translate="yes" xml:space="preserve">
          <source>The following code is slightly slower because the shape of the list of arguments is unknown at compile time.</source>
          <target state="translated">下面的代码速度稍慢,因为在编译时参数列表的形状是未知的。</target>
        </trans-unit>
        <trans-unit id="1c15d7bb6d9f5ccee5265bb8903dc3f1c45a0ae2" translate="yes" xml:space="preserve">
          <source>The following code is the Erlang part of the synchronous postgres driver, &lt;code&gt;pg_sync.erl&lt;/code&gt;:</source>
          <target state="translated">以下代码是同步postgres驱动程序 &lt;code&gt;pg_sync.erl&lt;/code&gt; 的Erlang部分：</target>
        </trans-unit>
        <trans-unit id="dca40145d4c0653ae61a32b900aff83a1d19f042" translate="yes" xml:space="preserve">
          <source>The following code reduces the search space and is more efficient:</source>
          <target state="translated">下面的代码可以减少搜索空间,效率更高。</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">以下代码:</target>
        </trans-unit>
        <trans-unit id="10e52292e9dee4a0e3fd6642d8202ab55d1217aa" translate="yes" xml:space="preserve">
          <source>The following command are directly available for indentation.</source>
          <target state="translated">以下命令可直接用于缩进。</target>
        </trans-unit>
        <trans-unit id="a54ee1055259696f0cf635190505ae13de7c7874" translate="yes" xml:space="preserve">
          <source>The following commands and functions are used to initiate the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">以下命令和功能用于初始化 &lt;code&gt;Company&lt;/code&gt; 数据库：</target>
        </trans-unit>
        <trans-unit id="a32fdf2e9df498e6565b300a038b14cb68a1735d" translate="yes" xml:space="preserve">
          <source>The following compilers are supported:</source>
          <target state="translated">支持以下编译器:</target>
        </trans-unit>
        <trans-unit id="8cfc763d98ab927b97e114c3d3db99c10685fbd5" translate="yes" xml:space="preserve">
          <source>The following configuration file causes raw logging of all NETCONF traffic in to one single text file:</source>
          <target state="translated">下面的配置文件可以将所有NETCONF流量的原始日志记录到一个单一的文本文件中。</target>
        </trans-unit>
        <trans-unit id="f14322549f377ad730735aaebaa29c12d04adf7a" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time interval and threshold:</source>
          <target state="translated">以下配置参数可用于更改时间间隔和阈值的默认值。</target>
        </trans-unit>
        <trans-unit id="193ce5872a1a6b1151ebfa805bdd3ed1418c9a2b" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time intervals and thresholds:</source>
          <target state="translated">以下配置参数可用于更改时间间隔和阈值的默认值。</target>
        </trans-unit>
        <trans-unit id="b8d3f81dcc2fefa92fa2bf61c616cec96c1c09f3" translate="yes" xml:space="preserve">
          <source>The following custom metadata keys have special meaning:</source>
          <target state="translated">以下自定义元数据键具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="9245e4a9bd60ce63efee4dfb325d04bbf467167e" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions below:</source>
          <target state="translated">下面的函数中使用了以下数据类型。</target>
        </trans-unit>
        <trans-unit id="48be2dc36e35956a8e3588aca9cfc84f77c588b6" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;public_key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;public_key&lt;/code&gt; 函数使用以下数据类型：</target>
        </trans-unit>
        <trans-unit id="cbde7c9ddb7eaf9bcf77f4db441bfdef5bb61047" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;ssl_session_cache_api&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ssl_session_cache_api&lt;/code&gt; 函数使用以下数据类型：</target>
        </trans-unit>
        <trans-unit id="5ae4ee24ac66de733888ad1963744fbfbce6e5f4" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for SSL/TLS/DTLS:</source>
          <target state="translated">SSL/TLS/DTLS的函数中使用了以下数据类型。</target>
        </trans-unit>
        <trans-unit id="4f214626dc0835db98c5ea380264f0633bf284ba" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for mod_esi:</source>
          <target state="translated">以下数据类型用于mod_esi的函数中。</target>
        </trans-unit>
        <trans-unit id="79cd8536de4f9b5bd968aa07ab5a04ff86d91140" translate="yes" xml:space="preserve">
          <source>The following data types concern the DNS client:</source>
          <target state="translated">以下数据类型涉及DNS客户端。</target>
        </trans-unit>
        <trans-unit id="59d37752ba97444275d3af617925c81e1b46edf9" translate="yes" xml:space="preserve">
          <source>The following data types concern the resolver:</source>
          <target state="translated">下列数据类型与解析器有关:</target>
        </trans-unit>
        <trans-unit id="5ceb88a84344840ee75edbb731e8eaf81fb9c735" translate="yes" xml:space="preserve">
          <source>The following data-types are used in the functions below:</source>
          <target state="translated">下面的函数中使用了以下数据类型。</target>
        </trans-unit>
        <trans-unit id="1484bd1263f6980852c4824bd6d929836444bb83" translate="yes" xml:space="preserve">
          <source>The following definitions are used in the SNMP User's Guide.</source>
          <target state="translated">SNMP用户指南中使用了以下定义。</target>
        </trans-unit>
        <trans-unit id="39b4ce09657d83e126a92760457f3f4da1a2f574" translate="yes" xml:space="preserve">
          <source>The following dialog within the Erlang shell illustrates the functionality of the Erlang ODBC interface. The table used in the example does not have any relevance to anything that exist in reality, it is just a simple example. The example was created using &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; as database and the ODBC driver for &lt;code&gt;sqlserver&lt;/code&gt; with version &lt;code&gt;2000.80.194.00&lt;/code&gt;.</source>
          <target state="translated">Erlang Shell中的以下对话框说明了Erlang ODBC接口的功能。该示例中使用的表与现实中存在的任何内容都不相关，它只是一个简单的示例。该示例是使用 &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; 作为数据库以及版本 &lt;code&gt;2000.80.194.00&lt;/code&gt; 的 &lt;code&gt;sqlserver&lt;/code&gt; 的ODBC驱动程序创建的。</target>
        </trans-unit>
        <trans-unit id="99bffcf83f746fcc6153881b4b1631f84352b58c" translate="yes" xml:space="preserve">
          <source>The following directory must exist in the system to run the manager:</source>
          <target state="translated">系统中必须存在以下目录才能运行管理器。</target>
        </trans-unit>
        <trans-unit id="b4067663f255bf23f8ace734d9a80cb7e8eb13f2" translate="yes" xml:space="preserve">
          <source>The following distinct values are recognised:</source>
          <target state="translated">以下是公认的不同价值:</target>
        </trans-unit>
        <trans-unit id="5bbdb173d3c169abec87c3f3bd04716fdb1d1176" translate="yes" xml:space="preserve">
          <source>The following elements are always present in the list for both local and external funs:</source>
          <target state="translated">对于本地和外部的fun,以下元素总是存在于列表中。</target>
        </trans-unit>
        <trans-unit id="314e2c48845f15727630c647a2291eeb21cc401b" translate="yes" xml:space="preserve">
          <source>The following elements are only present in the list if &lt;code&gt;Fun&lt;/code&gt; is local:</source>
          <target state="translated">如果 &lt;code&gt;Fun&lt;/code&gt; 是本地的，则以下元素仅出现在列表中：</target>
        </trans-unit>
        <trans-unit id="f117ec12e436f6ca90db1a4bc190e20fe521a5b3" translate="yes" xml:space="preserve">
          <source>The following encoding modules are provided:</source>
          <target state="translated">提供以下编码模块:</target>
        </trans-unit>
        <trans-unit id="77da27c3c246440f97582892c2d759bcdbc2e044" translate="yes" xml:space="preserve">
          <source>The following environment variables are recognized by &lt;code&gt;run_erl&lt;/code&gt; and change the logging behavior. For more information, see the previous section.</source>
          <target state="translated">以下环境变量由 &lt;code&gt;run_erl&lt;/code&gt; 识别并更改日志记录行为。有关更多信息，请参见上一节。</target>
        </trans-unit>
        <trans-unit id="555e6e3612dc9741d46001a128eafcf81c3f1408" translate="yes" xml:space="preserve">
          <source>The following equalities hold for all sequences:</source>
          <target state="translated">以下等式对所有序列都成立。</target>
        </trans-unit>
        <trans-unit id="31645542bb6c8a8301b513644f9cd8b30b64cec9" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the basic functionality used to run the Erlang ASN.1 compiler.</source>
          <target state="translated">下面的例子演示了用于运行Erlang ASN.1编译器的基本功能。</target>
        </trans-unit>
        <trans-unit id="80f9ad21016f571b21439d39ef29483bf86436fd" translate="yes" xml:space="preserve">
          <source>The following example generates all permutations of the elements in a list:</source>
          <target state="translated">下面的例子会生成一个列表中所有元素的排列组合。</target>
        </trans-unit>
        <trans-unit id="c404080201f0735af63fd0d67d38459effaabe41" translate="yes" xml:space="preserve">
          <source>The following example illustrate how code can be divided into a generic and a specific part. Consider the following code (written in plain Erlang) for a simple server, which keeps track of a number of &quot;channels&quot;. Other processes can allocate and free the channels by calling the functions &lt;code&gt;alloc/0&lt;/code&gt; and &lt;code&gt;free/1&lt;/code&gt;, respectively.</source>
          <target state="translated">下面的示例说明如何将代码分为通用部分和特定部分。考虑以下用于简单服务器的代码（用普通的Erlang编写），该服务器跟踪多个&amp;ldquo;通道&amp;rdquo;。其他进程可以分别通过调用函数 &lt;code&gt;alloc/0&lt;/code&gt; 和 &lt;code&gt;free/1&lt;/code&gt; 来分配和释放通道。</target>
        </trans-unit>
        <trans-unit id="49ac7049a1dcc2d7a9ce14f9a85fbfcae1153db4" translate="yes" xml:space="preserve">
          <source>The following example illustrates a simple, functional parser that parses the grammar:</source>
          <target state="translated">下面的例子说明了一个简单的功能解析器来解析语法。</target>
        </trans-unit>
        <trans-unit id="8140848b7fdb3cf3311bc85e2c217120f0d742dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates a situation in which we have an SNMP table that we wish to implement as a Mnesia table. The table stores information about employees at a company. Each employee is indexed with the department number and the name.</source>
          <target state="translated">下面的例子说明了这样一种情况:我们有一个SNMP表,希望将其作为Mnesia表来实现。该表存储了一个公司员工的信息。每个员工都以部门号和姓名为索引。</target>
        </trans-unit>
        <trans-unit id="e0bf2809ff12bfda2aa29b8a9ba782d668e893f5" translate="yes" xml:space="preserve">
          <source>The following example illustrates how this function and &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; are used:</source>
          <target state="translated">以下示例说明了如何使用此函数和 &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="474a94a5e901e0dd50063b0b025da701b6e45408" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between type &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;bag&lt;/code&gt;:</source>
          <target state="translated">以下示例说明了类型 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;bag&lt;/code&gt; 之间的区别：</target>
        </trans-unit>
        <trans-unit id="39a99dfd22c81e72385e303daaf447a32f1dcfba" translate="yes" xml:space="preserve">
          <source>The following example illustrates this idea:</source>
          <target state="translated">下面的例子说明了这个想法。</target>
        </trans-unit>
        <trans-unit id="0064c1a1c0bd35406debf90dd3f22d06ce617d65" translate="yes" xml:space="preserve">
          <source>The following example illustrates use of option &lt;code&gt;{active,once}&lt;/code&gt; and multiple accepts by implementing a server as a number of worker processes doing accept on a single listening socket. Function &lt;code&gt;start/2&lt;/code&gt; takes the number of worker processes and the port number on which to listen for incoming connections. If &lt;code&gt;LPort&lt;/code&gt; is specified as &lt;code&gt;0&lt;/code&gt;, an ephemeral port number is used, which is why the start function returns the actual port number allocated:</source>
          <target state="translated">以下示例通过将服务器实现为在单个侦听套接字上执行接受的许多工作进程 &lt;code&gt;{active,once}&lt;/code&gt; 说明了选项{active，once}和多重接受的使用。函数 &lt;code&gt;start/2&lt;/code&gt; 接收工作进程数和侦听传入连接的端口号。如果将 &lt;code&gt;LPort&lt;/code&gt; 指定为 &lt;code&gt;0&lt;/code&gt; ，则使用临时端口号，这就是启动函数返回分配的实际端口号的原因：</target>
        </trans-unit>
        <trans-unit id="86c0c5045f0b4867ff5d5e4af410f343d35c255f" translate="yes" xml:space="preserve">
          <source>The following example is a long dialog with the shell. Commands starting with &lt;code&gt;&amp;gt;&lt;/code&gt; are inputs to the shell. All other lines are output from the shell.</source>
          <target state="translated">以下示例是与外壳的长对话框。以 &lt;code&gt;&amp;gt;&lt;/code&gt; 开头的命令是shell的输入。所有其他行都从外壳输出。</target>
        </trans-unit>
        <trans-unit id="10240151e7e7d2b5c92ad81d3640bc34e05d9082" translate="yes" xml:space="preserve">
          <source>The following example is more complex:</source>
          <target state="translated">下面的例子比较复杂。</target>
        </trans-unit>
        <trans-unit id="2d992e491915820ad2afb49cfea9c8e41cff67a2" translate="yes" xml:space="preserve">
          <source>The following example is useful when new object code is to be loaded on all nodes in the network, and indicates some side effects that RPCs can produce:</source>
          <target state="translated">当新的对象代码要加载到网络中的所有节点上时,下面的例子很有用,它表明了RPC可能产生的一些副作用。</target>
        </trans-unit>
        <trans-unit id="1bc5ca4ed5e654ab061544449ba776cebd53a7ec" translate="yes" xml:space="preserve">
          <source>The following example selects UTF-8 as default encoding:</source>
          <target state="translated">下面的例子选择UTF-8作为默认编码。</target>
        </trans-unit>
        <trans-unit id="51e5b893c5c0823be8635b7d769cf2d225ca2947" translate="yes" xml:space="preserve">
          <source>The following example shows a &quot;manual&quot; implementation of the EX1-MIB in Erlang. In this example, the values of the objects are stored in an Erlang server. The server has a 2-tuple as loop data, where the first element is the value of variable &lt;code&gt;myName&lt;/code&gt;, and the second is a sorted list of rows in the table &lt;code&gt;friendsTable&lt;/code&gt;. Each row is a 4-tuple.</source>
          <target state="translated">以下示例显示了Erlang中的EX1-MIB的&amp;ldquo;手动&amp;rdquo;实现。在此示例中，对象的值存储在Erlang服务器中。服务器有一个2元组作为循环数据，其中第一个元素是变量 &lt;code&gt;myName&lt;/code&gt; 的值，第二个元素是表 &lt;code&gt;friendsTable&lt;/code&gt; 中行的排序列表。每行是一个4元组。</target>
        </trans-unit>
        <trans-unit id="0dda83918f4c357871181a8e692213f82ec6620d" translate="yes" xml:space="preserve">
          <source>The following example shows a &lt;code&gt;manager.conf&lt;/code&gt; file:</source>
          <target state="translated">以下示例显示了一个 &lt;code&gt;manager.conf&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="3692690cff3bbc46fbe7542193823a072dbd398f" translate="yes" xml:space="preserve">
          <source>The following example shows a C program communicating with an Erlang program over a plain port with home made encoding:</source>
          <target state="translated">下面的例子显示了一个C程序与Erlang程序通过普通端口进行通信,并使用了自制的编码。</target>
        </trans-unit>
        <trans-unit id="4d9615b54f64438d5e8028f7a0519b6178976cdb" translate="yes" xml:space="preserve">
          <source>The following example shows a process performing a certain action, and if this action is not completed within a certain limit, the process is killed:</source>
          <target state="translated">下面的例子显示了一个进程在执行某个动作,如果这个动作在一定的限制内没有完成,这个进程就会被杀死。</target>
        </trans-unit>
        <trans-unit id="1096089eeb70a3303a9760156d2d4be7631f7e69" translate="yes" xml:space="preserve">
          <source>The following example shows a simple pushbutton model for a toggling pushbutton implemented with &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;state_functions&lt;/code&gt;. You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on.</source>
          <target state="translated">以下示例显示了使用 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;state_functions&lt;/code&gt; 实现的切换按钮的简单按钮模型。您可以按一下按钮，它会回答该按钮是打开还是关闭，并且您可以要求对按下该按钮打开多少次进行计数。</target>
        </trans-unit>
        <trans-unit id="0dd42ec45016c93db472143966e5ca24703f9ed4" translate="yes" xml:space="preserve">
          <source>The following example shows a simple tool for &quot;debug tracing&quot;, that is, tracing of function calls with return values:</source>
          <target state="translated">下面的例子展示了一个简单的 &quot;调试跟踪 &quot;工具,即跟踪带有返回值的函数调用。</target>
        </trans-unit>
        <trans-unit id="19d3f1e8b5799f072b4359cce670be47936dfd69" translate="yes" xml:space="preserve">
          <source>The following example shows a slightly different solution:</source>
          <target state="translated">下面的例子显示了一个稍微不同的解决方案。</target>
        </trans-unit>
        <trans-unit id="5d4636c02ccef3bb3a01dfd35e9b59f4a603be21" translate="yes" xml:space="preserve">
          <source>The following example shows a test suite that uses configuration functions to open and close a log file for the test cases (an operation that is unnecessary and irrelevant to perform by each test case):</source>
          <target state="translated">下面的例子显示了一个测试套件,它使用配置功能来打开和关闭测试用例的日志文件(每个测试用例都要执行的不必要和不相关的操作)。</target>
        </trans-unit>
        <trans-unit id="e3b94c02f704d04153b1383ced31f3788f464a7b" translate="yes" xml:space="preserve">
          <source>The following example shows a transaction that raises the salary of certain employee numbers:</source>
          <target state="translated">下面的例子显示了一个提高某些员工人数工资的交易。</target>
        </trans-unit>
        <trans-unit id="f6d9b06dc36617a94b5e02afafc0ad8dfc4a0dad" translate="yes" xml:space="preserve">
          <source>The following example shows a valid &lt;code&gt;standard.conf&lt;/code&gt; file:</source>
          <target state="translated">以下示例显示了有效的 &lt;code&gt;standard.conf&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="bace4401d809de6e0147dcd93d7d2ad50c7143ee" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;agent.conf&lt;/code&gt; file:</source>
          <target state="translated">以下示例显示了一个 &lt;code&gt;agent.conf&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="847239863685661d182c63f6a400e539c34b547a" translate="yes" xml:space="preserve">
          <source>The following example shows an Erlang program communicating with a C program over a plain port with home made encoding:</source>
          <target state="translated">下面的例子显示了一个Erlang程序与一个C程序通过自制编码的普通端口进行通信。</target>
        </trans-unit>
        <trans-unit id="53825087d6b7108771ca3d6e0c8ef6217b528b80" translate="yes" xml:space="preserve">
          <source>The following example shows an implementation of a table which is stored in Mnesia, but with some checks performed at set-request operations.</source>
          <target state="translated">下面的例子显示了一个存储在Mnesia中的表的实现,但在set-request操作中进行了一些检查。</target>
        </trans-unit>
        <trans-unit id="595ffdab36e0d6fd3473bedf69696fe4094f27bb" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; can be used to rename a &lt;code&gt;db_node&lt;/code&gt; in a backup file:</source>
          <target state="translated">以下示例显示如何使用 &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; 重命名备份文件中的 &lt;code&gt;db_node&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9fa86a2eb1c462e43e94db58a5942b848857fdbd" translate="yes" xml:space="preserve">
          <source>The following example shows how a shared subterm can be created:</source>
          <target state="translated">下面的例子显示了如何创建一个共享子项。</target>
        </trans-unit>
        <trans-unit id="6776554b0d8b27d6e71dbb65c3430e626c70d4bf" translate="yes" xml:space="preserve">
          <source>The following example shows how it works. Assume the following specification is in file &lt;code&gt;PrimStrings.asn1&lt;/code&gt;:</source>
          <target state="translated">以下示例显示了它的工作方式。假设以下规范位于文件 &lt;code&gt;PrimStrings.asn1&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="d86195a9ba7fbeb4a3a2a88335f091528178a8bf" translate="yes" xml:space="preserve">
          <source>The following example shows how the &lt;code&gt;Erl_Interface&lt;/code&gt; library supports remote procedure calls:</source>
          <target state="translated">下面的示例显示 &lt;code&gt;Erl_Interface&lt;/code&gt; 库如何支持远程过程调用：</target>
        </trans-unit>
        <trans-unit id="d2278792ed447b1b0474672cdb32370ece1d60bb" translate="yes" xml:space="preserve">
          <source>The following example shows how these tasks are performed:</source>
          <target state="translated">下面的例子展示了如何执行这些任务。</target>
        </trans-unit>
        <trans-unit id="0eb710a17335cffa4195147f0b090692db507fb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to access a record field:</source>
          <target state="translated">下面的例子显示了如何访问一个记录字段。</target>
        </trans-unit>
        <trans-unit id="5dc0d07b42694dec0693419e5a61930ecf09e7b5" translate="yes" xml:space="preserve">
          <source>The following example shows how to calculate alpha blending using maps to reference color and alpha channels. Enter the code in a file named &lt;code&gt;color.erl&lt;/code&gt;):</source>
          <target state="translated">以下示例显示如何使用到参考颜色和Alpha通道的映射来计算Alpha混合。在名为 &lt;code&gt;color.erl&lt;/code&gt; 的文件中输入代码：</target>
        </trans-unit>
        <trans-unit id="c239b66af7053b04b58eb08cb9f4bfdfc1ec12a9" translate="yes" xml:space="preserve">
          <source>The following example shows how to change all letters in &lt;code&gt;L&lt;/code&gt; to upper case and then count them.</source>
          <target state="translated">下面的示例演示如何将 &lt;code&gt;L&lt;/code&gt; 中的所有字母都更改为大写字母，然后对其进行计数。</target>
        </trans-unit>
        <trans-unit id="a2b77ebb5034759887438d2b947908450b7a2b16" translate="yes" xml:space="preserve">
          <source>The following example shows how to find the length of a list. Enter the following code in a file named &lt;code&gt;tut4.erl&lt;/code&gt;):</source>
          <target state="translated">下面的示例显示如何查找列表的长度。在名为 &lt;code&gt;tut4.erl&lt;/code&gt; 的文件中输入以下代码：</target>
        </trans-unit>
        <trans-unit id="cabff7d830edf1695f519312aec99e8c8a4f83ba" translate="yes" xml:space="preserve">
          <source>The following example shows how to override properties in a scenario with deeply nested groups:</source>
          <target state="translated">下面的例子展示了如何在具有深度嵌套组的场景中覆盖属性。</target>
        </trans-unit>
        <trans-unit id="5c2ed5f4e4ba13285a99659d63cce80153eafd62" translate="yes" xml:space="preserve">
          <source>The following example shows how to print &quot;Hello World!&quot; in 5 seconds:</source>
          <target state="translated">下面的例子显示了如何在5秒内打印 &quot;Hello World!&quot;。</target>
        </trans-unit>
        <trans-unit id="42718ac464a329f1e12022f8904c812c6a41cbb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to reconstruct Erlang source code from the debug information in a BEAM file &lt;code&gt;Beam&lt;/code&gt;:</source>
          <target state="translated">下面的示例演示如何从BEAM文件 &lt;code&gt;Beam&lt;/code&gt; 中的调试信息重建Erlang源代码：</target>
        </trans-unit>
        <trans-unit id="36d0968402854fd2204e4f8284f220657779d484" translate="yes" xml:space="preserve">
          <source>The following example shows how to set up a trace that is automatically stopped and formatted after 5 seconds:</source>
          <target state="translated">下面的例子显示了如何设置一个5秒后自动停止并格式化的跟踪。</target>
        </trans-unit>
        <trans-unit id="df6f58ee5cbd6c36262b198728ebe89b5c130696" translate="yes" xml:space="preserve">
          <source>The following example shows how to start an event manager and add an event handler to it by using the shell:</source>
          <target state="translated">下面的例子显示了如何使用shell启动一个事件管理器并为其添加一个事件处理程序。</target>
        </trans-unit>
        <trans-unit id="5fc528ca550abf4d7a434c41bd619acd146ef168" translate="yes" xml:space="preserve">
          <source>The following example shows how to update a record:</source>
          <target state="translated">下面的例子显示了如何更新记录。</target>
        </trans-unit>
        <trans-unit id="cbb352e84c7618cb263e59542ab972df29182936" translate="yes" xml:space="preserve">
          <source>The following example shows that the guard succeeds if &lt;code&gt;P&lt;/code&gt; is record of type &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">以下示例显示，如果 &lt;code&gt;P&lt;/code&gt; 是 &lt;code&gt;person&lt;/code&gt; 类型的记录，则保护成功：</target>
        </trans-unit>
        <trans-unit id="c27427b8d967e296729a0172b87b5c1cb7821f6e" translate="yes" xml:space="preserve">
          <source>The following example shows the basic use of &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell. Default options are used both for starting the tracer and for formatting (the custom fetch directory is however provided). This gives a trace log named &lt;code&gt;Node-ttb&lt;/code&gt; in the newly created directory, where &lt;code&gt;Node&lt;/code&gt; is the node name. The default handler prints the formatted trace messages in the shell:</source>
          <target state="translated">以下示例显示了Erlang Shell 中 &lt;code&gt;ttb&lt;/code&gt; 的基本用法。默认选项用于启动跟踪程序和格式化（但是提供了自定义提取目录）。这将在新创建的目录中提供一个名为 &lt;code&gt;Node-ttb&lt;/code&gt; 的跟踪日志，其中 &lt;code&gt;Node&lt;/code&gt; 是节点名称。缺省处理程序在外​​壳中打印格式化的跟踪消息：</target>
        </trans-unit>
        <trans-unit id="33c400b4d7bc90cf1fb4285d622a80e1394cc3a9" translate="yes" xml:space="preserve">
          <source>The following example shows the reports generated when a process crashes. The example process is a &lt;code&gt;permanent&lt;/code&gt; process supervised by the &lt;code&gt;test_sup&lt;/code&gt; supervisor. A division by zero is executed and the error is first reported by the faulty process. A crash report is generated, as the process was started using function &lt;code&gt;proc_lib:spawn/3&lt;/code&gt;. The supervisor generates a supervisor report showing the crashed process. A progress report is generated when the process is finally restarted.</source>
          <target state="translated">以下示例显示了进程崩溃时生成的报告。示例过程是一个由 &lt;code&gt;test_sup&lt;/code&gt; 主管监督的 &lt;code&gt;permanent&lt;/code&gt; 过程。执行零除，错误过程首先报告错误。当使用 &lt;code&gt;proc_lib:spawn/3&lt;/code&gt; 函数启动该过程时，将生成崩溃报告。主管生成主管报告，该报告显示崩溃的过程。最终重新启动过程时，将生成进度报告。</target>
        </trans-unit>
        <trans-unit id="862f8553aec4c38b6ab11aac95b152a39de64479" translate="yes" xml:space="preserve">
          <source>The following example successfully constructs a bitstring of 7 bits, provided that all of X and Y are integers:</source>
          <target state="translated">下面的例子成功地构造了一个7位的比特串,前提是所有的X和Y都是整数。</target>
        </trans-unit>
        <trans-unit id="b791c8b4e90272c4405c7aeae4b46da3f6bb6c8f" translate="yes" xml:space="preserve">
          <source>The following example test suite shows some tests of a database server:</source>
          <target state="translated">下面的测试套件示例显示了数据库服务器的一些测试。</target>
        </trans-unit>
        <trans-unit id="b6d5422eedcad9f5caa434fa7b207125a77682b5" translate="yes" xml:space="preserve">
          <source>The following example uses an explicit match specification to traverse the table:</source>
          <target state="translated">下面的例子使用显式匹配规范来遍历表。</target>
        </trans-unit>
        <trans-unit id="03a4faf8451b45afff5a5b66483b40e3d0740248" translate="yes" xml:space="preserve">
          <source>The following example was run on OTP/R8 on Solaris 8, all OTP internals in this example are very version dependent.</source>
          <target state="translated">下面的例子是在Solaris 8上的OTP/R8上运行的,这个例子中的所有OTP内部结构都非常依赖于版本。</target>
        </trans-unit>
        <trans-unit id="46aa402444b6b984aa7f78159a16377f4c23a61a" translate="yes" xml:space="preserve">
          <source>The following example would match a simple Erlang integer or float and return a token which could be sent to the Erlang parser:</source>
          <target state="translated">下面的例子将匹配一个简单的Erlang整数或float,并返回一个可以发送给Erlang解析器的标记。</target>
        </trans-unit>
        <trans-unit id="1ed0171fcebc0acc5e68cccfc60c0381e6097256" translate="yes" xml:space="preserve">
          <source>The following examples assume that the current directory is the top of an Erlang/OTP installation.</source>
          <target state="translated">下面的例子假设当前目录是Erlang/OTP安装的顶部。</target>
        </trans-unit>
        <trans-unit id="9e3429edd1596d9bb7aa13fb024e8021be184516" translate="yes" xml:space="preserve">
          <source>The following examples define simplified versions of a few Erlang data types:</source>
          <target state="translated">下面的例子定义了一些Erlang数据类型的简化版本。</target>
        </trans-unit>
        <trans-unit id="f8bd6a0797d263a055952885390142cbff7bc575" translate="yes" xml:space="preserve">
          <source>The following examples illustrate a function that returns an error, and the method to retrieve more detailed error information:</source>
          <target state="translated">下面的例子说明了一个返回错误的函数,以及检索更详细错误信息的方法。</target>
        </trans-unit>
        <trans-unit id="02e03cbd265b56591c07a5d42abac6e2a5b935ba" translate="yes" xml:space="preserve">
          <source>The following examples illustrate how binaries are constructed, or matched, and how elements and tails are specified.</source>
          <target state="translated">下面的例子说明了二进制文件是如何构造或匹配的,以及如何指定元素和尾部。</target>
        </trans-unit>
        <trans-unit id="8d07d5eba80d244e874b251ee11faf436794868c" translate="yes" xml:space="preserve">
          <source>The following examples illustrate these rules:</source>
          <target state="translated">下面的例子说明了这些规则。</target>
        </trans-unit>
        <trans-unit id="3f52213112fefdbc53dc8c9767c67e39d0c5dce9" translate="yes" xml:space="preserve">
          <source>The following examples show a dialogue with the Erlang shell. All the higher order functions discussed are exported from the module &lt;code&gt;lists&lt;/code&gt;.</source>
          <target state="translated">以下示例显示了与Erlang Shell的对话。讨论的所有高阶函数都从模块 &lt;code&gt;lists&lt;/code&gt; 中导出。</target>
        </trans-unit>
        <trans-unit id="4e3ffd9c68f42312446cc6dbf3d84bd42d447765" translate="yes" xml:space="preserve">
          <source>The following examples show parsers of the following type:</source>
          <target state="translated">下面的例子显示了以下类型的解析器。</target>
        </trans-unit>
        <trans-unit id="18a677a2dd5f46875b6af8f8c34c6eb70fbe49be" translate="yes" xml:space="preserve">
          <source>The following examples show the resulting C programs. First a C node server using short node names:</source>
          <target state="translated">下面的例子展示了由此产生的C程序。首先是一个使用短节点名的C节点服务器。</target>
        </trans-unit>
        <trans-unit id="379499ad8751de711870d7f29677a3a780a463f0" translate="yes" xml:space="preserve">
          <source>The following examples show the two startup options:</source>
          <target state="translated">下面的例子显示了两个启动选项。</target>
        </trans-unit>
        <trans-unit id="f2e4438a8f07510d88683d4b04f8f84085bdfc63" translate="yes" xml:space="preserve">
          <source>The following examples use the utility function &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; to start all needed applications (&lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;). All examples are run in an Erlang shell, or in a bash shell, using &lt;strong&gt;openssh&lt;/strong&gt; to illustrate how the &lt;code&gt;ssh&lt;/code&gt; application can be used. The examples are run as the user &lt;code&gt;otptest&lt;/code&gt; on a local network where the user is authorized to log in over &lt;code&gt;ssh&lt;/code&gt; to the host &lt;strong&gt;tarlop&lt;/strong&gt;.</source>
          <target state="translated">以下示例使用实用程序功能 &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; 启动所有需要的应用程序（ &lt;code&gt;crypto&lt;/code&gt; ， &lt;code&gt;public_key&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; ）。所有示例都使用&lt;strong&gt;openssh&lt;/strong&gt;在Erlang shell或bash shell中运行，以说明如何使用 &lt;code&gt;ssh&lt;/code&gt; 应用程序。这些示例在本地网络上以 &lt;code&gt;otptest&lt;/code&gt; 用户身份运行，该用户被授权通过 &lt;code&gt;ssh&lt;/code&gt; 登录到主机&lt;strong&gt;tarlop&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5cd0b11976b5319f2006d2a53413541627fed4ce" translate="yes" xml:space="preserve">
          <source>The following executes &lt;code&gt;tc12&lt;/code&gt;&lt;strong&gt;only&lt;/strong&gt; in group &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">下面执行 &lt;code&gt;tc12&lt;/code&gt; &lt;strong&gt;只有&lt;/strong&gt;在组 &lt;code&gt;top1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="88857e0adb91607265c1fd3c40132140d6d97f6c" translate="yes" xml:space="preserve">
          <source>The following executes one test for all cases and subgroups under &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">以下代码对 &lt;code&gt;top1&lt;/code&gt; 下的所有案例和子组执行一项测试：</target>
        </trans-unit>
        <trans-unit id="25e14a4c0f0dd8657c260321ddf24593cbf2714d" translate="yes" xml:space="preserve">
          <source>The following executes only the test cases for &lt;code&gt;sub22&lt;/code&gt; and in reverse order compared to the group definition:</source>
          <target state="translated">与组定义相比，以下仅以相反的顺序执行 &lt;code&gt;sub22&lt;/code&gt; 的测试用例：</target>
        </trans-unit>
        <trans-unit id="9d59ae5da72969b4283c1cf98a39c82e69b73434" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one for all cases and all subgroups under &lt;code&gt;top1&lt;/code&gt;, and one for all under &lt;code&gt;top2&lt;/code&gt;:</source>
          <target state="translated">以下代码执行两项测试，一项针对所有案例和 &lt;code&gt;top1&lt;/code&gt; 下的所有子组，一项针对所有 &lt;code&gt;top2&lt;/code&gt; 下的测试：</target>
        </trans-unit>
        <trans-unit id="88efd1d16122c7dfa20482784039de0e7578cec9" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one including all cases and subgroups under &lt;code&gt;sub12&lt;/code&gt;, and one with &lt;strong&gt;only&lt;/strong&gt; the test cases in &lt;code&gt;sub12&lt;/code&gt;:</source>
          <target state="translated">以下执行两个测试，一个包含 &lt;code&gt;sub12&lt;/code&gt; 下的所有案例和子组，一个&lt;strong&gt;仅&lt;/strong&gt;包含 &lt;code&gt;sub12&lt;/code&gt; 中的测试用例：</target>
        </trans-unit>
        <trans-unit id="1a7ba64d043b7996c073a0f4af0d073005f423a1" translate="yes" xml:space="preserve">
          <source>The following expression creates a new &lt;code&gt;Name&lt;/code&gt; record where the value of each field &lt;code&gt;FieldI&lt;/code&gt; is the value of evaluating the corresponding expression &lt;code&gt;ExprI&lt;/code&gt;:</source>
          <target state="translated">以下表达式创建一个新的 &lt;code&gt;Name&lt;/code&gt; 记录，其中每个字段 &lt;code&gt;FieldI&lt;/code&gt; 的值是评估相应表达式 &lt;code&gt;ExprI&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="ae6de457c01e1fb1a3e00546eff8958609de12b0" translate="yes" xml:space="preserve">
          <source>The following expression returns the position of the specified field in the tuple representation of the record:</source>
          <target state="translated">以下表达式返回指定字段在记录元组表示中的位置。</target>
        </trans-unit>
        <trans-unit id="c58518dfed86937c32c0b6a021322cd7beecbd65" translate="yes" xml:space="preserve">
          <source>The following expression yields &lt;code&gt;true&lt;/code&gt;::</source>
          <target state="translated">以下表达式产生 &lt;code&gt;true&lt;/code&gt; ::</target>
        </trans-unit>
        <trans-unit id="dd1a2e6659306c0be27370e1c7239f7c64f5c457" translate="yes" xml:space="preserve">
          <source>The following expressions are translated equally:</source>
          <target state="translated">下列表达方式翻译相同的是:</target>
        </trans-unit>
        <trans-unit id="f600fa95580d128a5b55c2d2a3bd52715c966b7f" translate="yes" xml:space="preserve">
          <source>The following expressions yield &lt;code&gt;false&lt;/code&gt;, as variable &lt;code&gt;Broken&lt;/code&gt; contains a compiled match specification that has passed through external representation:</source>
          <target state="translated">以下表达式产生 &lt;code&gt;false&lt;/code&gt; ，因为变量 &lt;code&gt;Broken&lt;/code&gt; 包含已通过外部表示传递的已编译匹配规范：</target>
        </trans-unit>
        <trans-unit id="b9eb1676778caddf159cfe9acf52d248a3850a31" translate="yes" xml:space="preserve">
          <source>The following fapply:</source>
          <target state="translated">以下是适用的。</target>
        </trans-unit>
        <trans-unit id="f3d7d3c3deb0a0a629d81950bc6b6134511197b1" translate="yes" xml:space="preserve">
          <source>The following fields are not described in the ERTS User's Guide:</source>
          <target state="translated">ERTS用户指南中没有说明以下字段。</target>
        </trans-unit>
        <trans-unit id="61d54bcd350d6740f125ef1579264955f1c65547" translate="yes" xml:space="preserve">
          <source>The following fields are used from the record, if they are specified:</source>
          <target state="translated">以下是记录中使用的字段,如果它们被指定:</target>
        </trans-unit>
        <trans-unit id="579212e906c367c5e65524f9d589806b1a4dfd60" translate="yes" xml:space="preserve">
          <source>The following fields can exist for a process:</source>
          <target state="translated">流程可存在以下字段:</target>
        </trans-unit>
        <trans-unit id="8cec82fe0d57eb1d23921e0d50a78837999069a1" translate="yes" xml:space="preserve">
          <source>The following fields typically must be specified by the sender:</source>
          <target state="translated">以下字段通常必须由发件人指定:</target>
        </trans-unit>
        <trans-unit id="08329a98a990baea9fd4cf44d504f845faefdaf6" translate="yes" xml:space="preserve">
          <source>The following figure shows a conceptual overview of Logger. The figure shows two log handlers, but any number of handlers can be installed.</source>
          <target state="translated">下图显示了Logger的概念性概述。图中显示的是两个日志处理程序,但可以安装任意数量的处理程序。</target>
        </trans-unit>
        <trans-unit id="0bef9dc10cd953efe4cb861873187dfba852609d" translate="yes" xml:space="preserve">
          <source>The following figure shows the bytes of a &lt;code&gt;Window:status&lt;/code&gt; message. The components &lt;code&gt;buttonList&lt;/code&gt; and &lt;code&gt;actions&lt;/code&gt; are excluded from decode. Only &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt; are decoded when &lt;code&gt;decode__Window_exclusive&lt;/code&gt; is called.</source>
          <target state="translated">下图显示了 &lt;code&gt;Window:status&lt;/code&gt; 消息的字节。组件 &lt;code&gt;buttonList&lt;/code&gt; 和 &lt;code&gt;actions&lt;/code&gt; 从解码中排除。调用 &lt;code&gt;decode__Window_exclusive&lt;/code&gt; 时，仅解码 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;enabled&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="5e130f9f78c1692a150e4f0eeb068783cb173914" translate="yes" xml:space="preserve">
          <source>The following figure shows which components are in &lt;code&gt;TypeList&lt;/code&gt;&lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;:</source>
          <target state="translated">下图显示了 &lt;code&gt;TypeList&lt;/code&gt; &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 中的哪些组件：</target>
        </trans-unit>
        <trans-unit id="b445689ad7fd0436cd7641f643a07c0561a2fe9a" translate="yes" xml:space="preserve">
          <source>The following file includes two certificates:</source>
          <target state="translated">以下文件包括两个证书。</target>
        </trans-unit>
        <trans-unit id="3db502e7fd49532c31554150f0c64ab687cd78ab" translate="yes" xml:space="preserve">
          <source>The following file types are defined in Erlang/OTP:</source>
          <target state="translated">在Erlang/OTP中定义了以下文件类型。</target>
        </trans-unit>
        <trans-unit id="71254e9506c929f7f52ca316b3c356b831887b19" translate="yes" xml:space="preserve">
          <source>The following flags are available:</source>
          <target state="translated">以下是可用的标志:</target>
        </trans-unit>
        <trans-unit id="719ce2e093c09df2408e42a7406958a700ac71ea" translate="yes" xml:space="preserve">
          <source>The following flags are defined automatically and can be retrieved using this function:</source>
          <target state="translated">以下标志是自动定义的,可以用这个函数来检索。</target>
        </trans-unit>
        <trans-unit id="5fe356642f0df6916029c9299326bc02952f156d" translate="yes" xml:space="preserve">
          <source>The following flags are recognised:</source>
          <target state="translated">认可以下标志:</target>
        </trans-unit>
        <trans-unit id="2791d823738fc796e3aff5cac56fe1c0dc58c276" translate="yes" xml:space="preserve">
          <source>The following flags are supported:</source>
          <target state="translated">支持以下标志:</target>
        </trans-unit>
        <trans-unit id="9a37b4b5f5db6694294b80fe420424b434a55049" translate="yes" xml:space="preserve">
          <source>The following flags are useful in special situations, such as rebuilding the OTP system:</source>
          <target state="translated">以下标志在特殊情况下很有用,比如重建OTP系统。</target>
        </trans-unit>
        <trans-unit id="e3e7ff31b4722f8ae27b4760d8e2609571bf918c" translate="yes" xml:space="preserve">
          <source>The following flags can also be used with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">以下标志也可以与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="fe0b90a260b51ac7fbb2626eba5e49455fbc6475" translate="yes" xml:space="preserve">
          <source>The following four installation procedures require super user privilege:</source>
          <target state="translated">以下四个安装步骤需要超级用户权限。</target>
        </trans-unit>
        <trans-unit id="857a38dd46b2870a572b2281f80d819712f630b7" translate="yes" xml:space="preserve">
          <source>The following fun expressions are also allowed:</source>
          <target state="translated">还允许使用以下有趣的表达方式。</target>
        </trans-unit>
        <trans-unit id="7e53e9cb8d584334c556a4497982894d55fd0779" translate="yes" xml:space="preserve">
          <source>The following function extracts a list of female employees from the database:</source>
          <target state="translated">以下函数从数据库中提取女性雇员的名单。</target>
        </trans-unit>
        <trans-unit id="504f3189fc42a4b1e4cebcb03cdadcfe20e2ff16" translate="yes" xml:space="preserve">
          <source>The following function extracts the names of the female employees stored in the database:</source>
          <target state="translated">以下函数提取数据库中存储的女性雇员的姓名。</target>
        </trans-unit>
        <trans-unit id="e7ccfae3bc62070f3a6d6f25984d604af2dca20b" translate="yes" xml:space="preserve">
          <source>The following function must be exported from a &lt;code&gt;supervisor&lt;/code&gt; callback module.</source>
          <target state="translated">必须从 &lt;code&gt;supervisor&lt;/code&gt; 回调模块导出以下函数。</target>
        </trans-unit>
        <trans-unit id="07aad394cfc87e43c34047ccb79c6f62e522e12b" translate="yes" xml:space="preserve">
          <source>The following function takes a list of &lt;code&gt;person&lt;/code&gt; records and searches for the phone number of a person with a particular name:</source>
          <target state="translated">以下功能获取 &lt;code&gt;person&lt;/code&gt; 记录列表，并搜索具有特定名称的人员的电话号码：</target>
        </trans-unit>
        <trans-unit id="d42b26451a776d64cc4668a7081444af7e2c2a1e" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;add_one&lt;/code&gt;, adds one to every element in a list:</source>
          <target state="translated">以下函数 &lt;code&gt;add_one&lt;/code&gt; 将一个添加到列表中的每个元素：</target>
        </trans-unit>
        <trans-unit id="fdcde9b058d15df816f05ecda9bd41f522994a81" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;double&lt;/code&gt;, doubles every element in a list:</source>
          <target state="translated">以下函数 &lt;code&gt;double&lt;/code&gt; 会将列表中的每个元素加倍：</target>
        </trans-unit>
        <trans-unit id="4a3f4a02410e47e9c3849742c5727d2c0861cf66" translate="yes" xml:space="preserve">
          <source>The following functionally equivalent code writes 128 bytes per call to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; and so does the same work in 0.08 seconds, which is roughly 30 times faster:</source>
          <target state="translated">以下功能上等效的代码每个调用 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 写入128个字节，因此在0.08秒内完成相同的工作，这大约快30倍：</target>
        </trans-unit>
        <trans-unit id="4851a85cacd7cea8fbbb07ff6c65612ebb17807b" translate="yes" xml:space="preserve">
          <source>The following functions are exported by the generated scanner.</source>
          <target state="translated">生成的扫描器输出了以下功能。</target>
        </trans-unit>
        <trans-unit id="5f67bcd3deeb0c90fe208811b94f6ecb50fdd70e" translate="yes" xml:space="preserve">
          <source>The following functions are inlined:</source>
          <target state="translated">以下是内联功能:</target>
        </trans-unit>
        <trans-unit id="6e8f6071853dc23038c690be527eb7aed97d99f5" translate="yes" xml:space="preserve">
          <source>The following functions are mandatory:</source>
          <target state="translated">以下功能是必须的:</target>
        </trans-unit>
        <trans-unit id="6ab66b86479cb4b8966432e55db73f7b8eac0221" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_event&lt;/code&gt; callback module.</source>
          <target state="translated">以下功能将从 &lt;code&gt;gen_event&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="eaf6f53e0685fd921f6065ec533398767638e814" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_server&lt;/code&gt; callback module.</source>
          <target state="translated">以下功能将从 &lt;code&gt;gen_server&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="baab9084b49f784e0a7049c6d9a71e4b999906d7" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_statem&lt;/code&gt; callback module.</source>
          <target state="translated">以下函数将从 &lt;code&gt;gen_statem&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="f6d8fd0dedca27c09b82ec5cdf80b62654de4c23" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_client_channel&lt;/code&gt; callback module.</source>
          <target state="translated">以下功能将从 &lt;code&gt;ssh_client_channel&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="b8fd8927d0a9812c875db0dd32e79d269aceb81c" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_server_channel&lt;/code&gt; callback module.</source>
          <target state="translated">以下功能将从 &lt;code&gt;ssh_server_channel&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="e23fa44c13429a2fd437dba0988c988e7a312614" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a formatter callback module.</source>
          <target state="translated">以下函数将从formatter回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="f3a0c7ead32b20d4fc3d927da2c12376abf896b9" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a handler callback module.</source>
          <target state="translated">以下函数将从处理程序回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="324102d29dfa0e459c285f94eb4c3c3798cd41d3" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;application&lt;/code&gt; callback module.</source>
          <target state="translated">以下功能将从 &lt;code&gt;application&lt;/code&gt; 回调模块中导出。</target>
        </trans-unit>
        <trans-unit id="623497a405a43189792a81522e86a8b9226d067f" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;erl_tracer&lt;/code&gt; callback module:</source>
          <target state="translated">以下功能将从 &lt;code&gt;erl_tracer&lt;/code&gt; 回调模块导出：</target>
        </trans-unit>
        <trans-unit id="64dc45bde2a752b8cec35e2e33de402f72f6cc40" translate="yes" xml:space="preserve">
          <source>The following functions are used for convenience.</source>
          <target state="translated">为方便起见,使用了以下功能。</target>
        </trans-unit>
        <trans-unit id="c872bca07adade7d8cc574c2485887affd6e5d83" translate="yes" xml:space="preserve">
          <source>The following functions are used to back up data, to install a backup as fallback, and for disaster recovery:</source>
          <target state="translated">以下功能用于备份数据,安装备份作为后备,以及用于灾难恢复。</target>
        </trans-unit>
        <trans-unit id="02628df42092a5c994d8e891c4403f91bfbbbb66" translate="yes" xml:space="preserve">
          <source>The following functions are used when implementing a special process. This is an ordinary process, which does not use a standard behavior, but a process that understands the standard system messages.</source>
          <target state="translated">在实现一个特殊的进程时,会用到以下函数。这是一个普通的进程,它不使用标准行为,而是一个理解标准系统消息的进程。</target>
        </trans-unit>
        <trans-unit id="26b92712bb4c99562ee4a3caab022028754f5836" translate="yes" xml:space="preserve">
          <source>The following functions can be used to test upgrade and downgrade of single applications (instead of upgrading/downgrading an entire release). A script corresponding to the instructions in the &lt;code&gt;relup&lt;/code&gt; file is created on-the-fly, based on the &lt;code&gt;.appup&lt;/code&gt; file for the application, and evaluated exactly in the same way as &lt;code&gt;release_handler&lt;/code&gt; does.</source>
          <target state="translated">以下功能可用于测试单个应用程序的升级和降级（而不是升级/降级整个版本）。将根据应用程序的 &lt;code&gt;.appup&lt;/code&gt; 文件即时创建与 &lt;code&gt;relup&lt;/code&gt; 文件中的指令相对应的脚本，并按照与 &lt;code&gt;release_handler&lt;/code&gt; 相同的方式进行评估。</target>
        </trans-unit>
        <trans-unit id="24d76d64ddf59c8af9a65858beb15de37d52e968" translate="yes" xml:space="preserve">
          <source>The following functions control the behavior of the internal counters.</source>
          <target state="translated">以下函数控制内部计数器的行为。</target>
        </trans-unit>
        <trans-unit id="c8f7d8e59ac7e38340a3c25c101d522f5875e82c" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a CTH.</source>
          <target state="translated">以下函数定义了CTH的回调接口。</target>
        </trans-unit>
        <trans-unit id="02a00b734983835a88dfd4ba08c110451f346e89" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a test suite.</source>
          <target state="translated">以下函数定义了测试套件的回调接口。</target>
        </trans-unit>
        <trans-unit id="647d81b837420325efd90808d2b34ee3893c58a1" translate="yes" xml:space="preserve">
          <source>The following functions describe the interface to &lt;code&gt;snmpa_local_db&lt;/code&gt;. Each function has a Mnesia equivalent. The argument &lt;code&gt;NameDb&lt;/code&gt; is a tuple &lt;code&gt;{Name, Db}&lt;/code&gt; where &lt;code&gt;Name&lt;/code&gt; is the symbolic name of the managed object (as defined in the MIB), and &lt;code&gt;Db&lt;/code&gt; is either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;persistent&lt;/code&gt;. &lt;code&gt;mnesia&lt;/code&gt; is not possible since all these functions are &lt;code&gt;snmpa_local_db&lt;/code&gt; specific.</source>
          <target state="translated">以下函数描述了 &lt;code&gt;snmpa_local_db&lt;/code&gt; 的接口。每个功能都有一个Mnesia等效项。参数 &lt;code&gt;NameDb&lt;/code&gt; 是一个元组 &lt;code&gt;{Name, Db}&lt;/code&gt; ，其中 &lt;code&gt;Name&lt;/code&gt; 是被管理对象的符号名称（如MIB中所定义），而 &lt;code&gt;Db&lt;/code&gt; 是 &lt;code&gt;volatile&lt;/code&gt; 或 &lt;code&gt;persistent&lt;/code&gt; 。 &lt;code&gt;mnesia&lt;/code&gt; 是不可能的，因为所有这些功能都 &lt;code&gt;snmpa_local_db&lt;/code&gt; 具体。</target>
        </trans-unit>
        <trans-unit id="a1100a11b4b80e1ec32b674331fc67603b3198a3" translate="yes" xml:space="preserve">
          <source>The following functions in this module also exist and provides the same functionality in the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; modules. That is, by only changing the module name for each call, you can try out different set representations.</source>
          <target state="translated">此模块中还存在以下功能，并在 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 模块中提供相同的功能。也就是说，通过仅更改每个调用的模块名称，就可以尝试不同的集合表示形式。</target>
        </trans-unit>
        <trans-unit id="403a88e7d4193643f2441bbe4104eef783bcc30f" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;mib-server&lt;/code&gt; data callback module:</source>
          <target state="translated">必须从 &lt;code&gt;mib-server&lt;/code&gt; 数据回调模块导出以下函数：</target>
        </trans-unit>
        <trans-unit id="211427edb5cce5619a96cf4257a0132f6686ca2a" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;supervisor_bridge&lt;/code&gt; callback module.</source>
          <target state="translated">必须从 &lt;code&gt;supervisor_bridge&lt;/code&gt; 回调模块导出以下函数。</target>
        </trans-unit>
        <trans-unit id="5e7c33747a8a7210784ba4d3e34376c30cdfd02d" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_edist_compress&lt;/code&gt; callback module:</source>
          <target state="translated">应从 &lt;code&gt;megaco_edist_compress&lt;/code&gt; 回调模块导出以下函数：</target>
        </trans-unit>
        <trans-unit id="1c2eb550d5e0fd353c08fabab97a3148ca0012e2" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_encoder&lt;/code&gt; callback module:</source>
          <target state="translated">以下功能应从 &lt;code&gt;megaco_encoder&lt;/code&gt; 回调模块中导出：</target>
        </trans-unit>
        <trans-unit id="36e94e447d27f2ba2ddd7dbee957d9efa47d84bf" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_transport&lt;/code&gt; callback module:</source>
          <target state="translated">以下函数应从 &lt;code&gt;megaco_transport&lt;/code&gt; 回调模块中导出：</target>
        </trans-unit>
        <trans-unit id="f8ee1e36bf47047325c371be3bfaa01a6b15fc9a" translate="yes" xml:space="preserve">
          <source>The following functions, &lt;code&gt;read_cmd()&lt;/code&gt; and &lt;code&gt;write_cmd()&lt;/code&gt;, from the &lt;code&gt;erl_comm.c&lt;/code&gt; example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; can still be used for reading from and writing to the port:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;erl_comm.c&lt;/code&gt; 示例中的以下函数 &lt;code&gt;read_cmd()&lt;/code&gt; 和 &lt;code&gt;write_cmd()&lt;/code&gt; 仍可用于读取和写入端口：</target>
        </trans-unit>
        <trans-unit id="0c0cc9a33559cd30dd7c5dee49a32a3678fc0996" translate="yes" xml:space="preserve">
          <source>The following general category property codes are supported:</source>
          <target state="translated">支持以下一般类别的属性代码:</target>
        </trans-unit>
        <trans-unit id="00b20eb40ed0d659393e7ede6b8509b03c2165e1" translate="yes" xml:space="preserve">
          <source>The following illustration shows how a system can look in runtime.</source>
          <target state="translated">下面的图示显示了系统在运行时的样子。</target>
        </trans-unit>
        <trans-unit id="d0fc102c368e541c6de8ef4f6fd846441148303d" translate="yes" xml:space="preserve">
          <source>The following information is given for each child specification/process:</source>
          <target state="translated">以下是每个子规格/流程的信息。</target>
        </trans-unit>
        <trans-unit id="0cce2ff92e643403b8a8a43b7b39a2cc520dd904" translate="yes" xml:space="preserve">
          <source>The following information is returned for every application:</source>
          <target state="translated">每个申请都会返回以下信息。</target>
        </trans-unit>
        <trans-unit id="b3fbdd770d4e0e0bb91f42f7653cca9a0fa8d845" translate="yes" xml:space="preserve">
          <source>The following information is returned for every library module:</source>
          <target state="translated">每个库模块都会返回以下信息。</target>
        </trans-unit>
        <trans-unit id="b25c49ec2d0414911fc31e80509041b6c00e1677" translate="yes" xml:space="preserve">
          <source>The following information is returned for every release:</source>
          <target state="translated">每次发布都会返回以下信息:</target>
        </trans-unit>
        <trans-unit id="d5e22fc9271f190429a4be85a97f17d1b778ca80" translate="yes" xml:space="preserve">
          <source>The following instructions are for building &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下说明用于构建 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bb6feade4582730097dc79e92bae679305ea48e" translate="yes" xml:space="preserve">
          <source>The following is a checklist for rewriting a pre ERTS 5.9 driver, most important first:</source>
          <target state="translated">以下是重写ERTS 5.9前驱动的检查表,最重要的是先。</target>
        </trans-unit>
        <trans-unit id="3b1759541f1940201849307e8f98dd17638ad123" translate="yes" xml:space="preserve">
          <source>The following is a complete &lt;code&gt;Fun&lt;/code&gt; parameter for reading and writing on files using the &lt;code&gt;file&lt;/code&gt; module:</source>
          <target state="translated">以下是用于使用 &lt;code&gt;file&lt;/code&gt; 模块读写文件的完整 &lt;code&gt;Fun&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="fc7d7129dd6f6c58173a187543c25f188276eaf0" translate="yes" xml:space="preserve">
          <source>The following is a complete list of event types and where they come from:</source>
          <target state="translated">以下是事件类型及其来源的完整列表。</target>
        </trans-unit>
        <trans-unit id="c8a14f55bfff88da1be28bb766800640bcd62c50" translate="yes" xml:space="preserve">
          <source>The following is a list of the ANSI data types. For details turn to the ANSI standard documentation. Usage of other data types is of course possible, but you should be aware that this makes your application dependent on the database you are using at the moment.</source>
          <target state="translated">以下是ANSI数据类型的列表。详情请参考ANSI标准文档。当然也可以使用其他的数据类型,但是你应该意识到,这使得你的应用程序依赖于你现在使用的数据库。</target>
        </trans-unit>
        <trans-unit id="9dffda4d1a563c216467972b2fef4d25fa28c442" translate="yes" xml:space="preserve">
          <source>The following is a rather unnatural example to show another exception:</source>
          <target state="translated">下面用一个比较不自然的例子来说明另一个例外。</target>
        </trans-unit>
        <trans-unit id="fc5496457b8761bac15ca387a14c23e2f06d56e0" translate="yes" xml:space="preserve">
          <source>The following is a shell session when running it:</source>
          <target state="translated">下面是运行它时的shell会话。</target>
        </trans-unit>
        <trans-unit id="1c1afe341a3a40e5c215a483f55d3776b92db0f3" translate="yes" xml:space="preserve">
          <source>The following is a short program to show the workings of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">以下是演示 &lt;code&gt;if&lt;/code&gt; 的工作原理的简短程序。</target>
        </trans-unit>
        <trans-unit id="92e3b552e54cc6f54aad0df369b0b7192bcf382d" translate="yes" xml:space="preserve">
          <source>The following is a simple example of an FTP session, where the user &lt;code&gt;guest&lt;/code&gt; with password &lt;code&gt;password&lt;/code&gt; logs on to the remote host &lt;code&gt;erlang.org&lt;/code&gt;:</source>
          <target state="translated">以下是FTP会话的一个简单示例，其中带有密码 &lt;code&gt;password&lt;/code&gt; 的用户 &lt;code&gt;guest&lt;/code&gt; 登录到远程主机 &lt;code&gt;erlang.org&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="af00308e7be83b75dde0c794afc64df924d05311" translate="yes" xml:space="preserve">
          <source>The following is a simpler example of a handler which logs to a file through one single process:</source>
          <target state="translated">下面是一个比较简单的处理程序的例子,该处理程序通过一个单一的进程记录到一个文件。</target>
        </trans-unit>
        <trans-unit id="2985e72c56df70fad7f40fc868951b90ac475392" translate="yes" xml:space="preserve">
          <source>The following is a slightly more complicated example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; providing one key for module &lt;code&gt;t&lt;/code&gt; and another key for all other modules:</source>
          <target state="translated">以下是 &lt;code&gt;.erlang.crypt&lt;/code&gt; 的稍微复杂的示例，它为模块 &lt;code&gt;t&lt;/code&gt; 提供一个密钥，为所有其他模块提供另一个密钥：</target>
        </trans-unit>
        <trans-unit id="c2e759eba9876095f44fce0efab73cd548a24130" translate="yes" xml:space="preserve">
          <source>The following is a template example of how to create and return a resource object.</source>
          <target state="translated">下面是一个关于如何创建和返回资源对象的模板示例。</target>
        </trans-unit>
        <trans-unit id="407235d853511b8f33bb270ef89fc50a0d62af2a" translate="yes" xml:space="preserve">
          <source>The following is an easy way of obtaining a unique value to seed with:</source>
          <target state="translated">下面是一个简单的方法来获得一个独特的值来进行播种。</target>
        </trans-unit>
        <trans-unit id="559fe21097f15ddc3169882128ef5ed665f04654" translate="yes" xml:space="preserve">
          <source>The following is an example module to trace on:</source>
          <target state="translated">以下是一个跟踪模块的例子。</target>
        </trans-unit>
        <trans-unit id="80aa757f4a9a7af17950895f0cec0bc27ec18d99" translate="yes" xml:space="preserve">
          <source>The following is an example of Erlang code that assigns values for the types in the previous list:</source>
          <target state="translated">下面是一个为前面列表中的类型赋值的Erlang代码的例子。</target>
        </trans-unit>
        <trans-unit id="d01528f16015b5f29f1097c6ec1da0702097e439" translate="yes" xml:space="preserve">
          <source>The following is an example of X509 certificates:</source>
          <target state="translated">以下是一个X509证书的例子。</target>
        </trans-unit>
        <trans-unit id="b27cba48368a69cfcb442391037a03176a6a6532" translate="yes" xml:space="preserve">
          <source>The following is an example of a callback module for a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor:</source>
          <target state="translated">以下是用于 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管的回调模块的示例：</target>
        </trans-unit>
        <trans-unit id="1f30318b19c32d664f2f54026ca7ff0b8355f643" translate="yes" xml:space="preserve">
          <source>The following is an example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; file that returns the same key for all modules:</source>
          <target state="translated">以下是 &lt;code&gt;.erlang.crypt&lt;/code&gt; 文件的示例，该文件为所有模块返回相同的密钥：</target>
        </trans-unit>
        <trans-unit id="beaf428bf8cc669201276ed3d29a25f483cbffc1" translate="yes" xml:space="preserve">
          <source>The following is an example of how the functions in the previous example can be rewritten if it is necessary to open multiple connections to the FTP server:</source>
          <target state="translated">以下是一个例子,如果需要打开多个连接到FTP服务器,可以重写前面例子中的函数。</target>
        </trans-unit>
        <trans-unit id="7f7272e68f14b299a421c24c15d68c41acc39f20" translate="yes" xml:space="preserve">
          <source>The following is an example of how to assert that the configuration data is available and can be used for an FTP session:</source>
          <target state="translated">下面是一个例子,说明如何断言配置数据是可用的,并且可以用于FTP会话。</target>
        </trans-unit>
        <trans-unit id="006f54e284f6eaf59f32808c04b6087a85040dff" translate="yes" xml:space="preserve">
          <source>The following is an example of how to return the status from a group:</source>
          <target state="translated">下面是一个如何从组中返回状态的例子。</target>
        </trans-unit>
        <trans-unit id="de8c4707aa64df488804045d788d163861ba1459" translate="yes" xml:space="preserve">
          <source>The following is an example session using it on Linux:</source>
          <target state="translated">下面是一个在Linux上使用它的实例会话。</target>
        </trans-unit>
        <trans-unit id="22fa03b054cca550539d61bd30740fe445725fe1" translate="yes" xml:space="preserve">
          <source>The following is an ordinary asynchronous request:</source>
          <target state="translated">下面是一个普通的异步请求。</target>
        </trans-unit>
        <trans-unit id="1617114c5fde90021a15fd0405960852bae70f6c" translate="yes" xml:space="preserve">
          <source>The following is an ordinary synchronous request:</source>
          <target state="translated">以下是一个普通的同步请求。</target>
        </trans-unit>
        <trans-unit id="25cf5f91df4951ef8502f305f460dc3e467e107b" translate="yes" xml:space="preserve">
          <source>The following is another special sequence that can appear at the start of a pattern:</source>
          <target state="translated">下面是另一个可以出现在模式开始时的特殊序列。</target>
        </trans-unit>
        <trans-unit id="25f3a545690924d83cc64312bc56248e3f69655a" translate="yes" xml:space="preserve">
          <source>The following is called when the application is stopped.</source>
          <target state="translated">停止应用程序时,将调用以下内容。</target>
        </trans-unit>
        <trans-unit id="a7bb8990a6d72dd204c6cca6df9719f6eb039d12" translate="yes" xml:space="preserve">
          <source>The following is the complete callback module file &lt;code&gt;pushbutton.erl&lt;/code&gt;:</source>
          <target state="translated">以下是完整的回调模块文件 &lt;code&gt;pushbutton.erl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eba1404bcd0f1c2d40b6a68a0e51cd8231cb108f" translate="yes" xml:space="preserve">
          <source>The following is the instruction for adding an application:</source>
          <target state="translated">以下是添加申请的说明。</target>
        </trans-unit>
        <trans-unit id="eef8732ed7e4037c0a3fb4336a9e4dba89b8f906" translate="yes" xml:space="preserve">
          <source>The following is the instruction for removing an application:</source>
          <target state="translated">以下是删除申请的说明。</target>
        </trans-unit>
        <trans-unit id="314b2a42ea1284b836958c707ebdeebfb1e761a9" translate="yes" xml:space="preserve">
          <source>The following is the instruction for restarting an application:</source>
          <target state="translated">以下是重启应用程序的操作步骤。</target>
        </trans-unit>
        <trans-unit id="04b2d72b40a1cd44a0454da6f08a0b030bd3218c" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start a profile at application startup:</source>
          <target state="translated">以下内容要放在Erlang节点应用配置文件中,以便在应用启动时启动配置文件。</target>
        </trans-unit>
        <trans-unit id="062b29997a05c71efe23ac3949d3086ab3d47473" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start an HTTP server at application startup:</source>
          <target state="translated">以下内容要放在Erlang节点应用配置文件中,以便在应用启动时启动HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="d3155b2a460c30a139bad84db61b5cb13f89e622" translate="yes" xml:space="preserve">
          <source>The following items are returned:</source>
          <target state="translated">以下项目被退回。</target>
        </trans-unit>
        <trans-unit id="cd7738cf632ddaa8eb52ecadbb7505cd9d32c89a" translate="yes" xml:space="preserve">
          <source>The following items are valid:</source>
          <target state="translated">下列项目有效:</target>
        </trans-unit>
        <trans-unit id="4561a64f009cfbd6722c632e8eb5a471d1923a59" translate="yes" xml:space="preserve">
          <source>The following list details the application versions that were part of OTP 17.0. If the normal part of an application version number compares as smaller than the corresponding application version in the list, the version number does not adhere to the version scheme introduced in OTP 17.0 and is to be considered as not having an order against versions used as of OTP 17.0.</source>
          <target state="translated">下表详细说明了OTP 17.0中的应用程序版本。如果一个应用程序版本号的正常部分比列表中相应的应用程序版本号小,则该版本号不符合OTP 17.0中引入的版本方案,并被视为与OTP 17.0时使用的版本没有顺序。</target>
        </trans-unit>
        <trans-unit id="f6f5aff715179f741e21746f788a0d571fc3772d" translate="yes" xml:space="preserve">
          <source>The following macro directives are supplied:</source>
          <target state="translated">提供以下宏指令:</target>
        </trans-unit>
        <trans-unit id="361a3fd4702c110455bbcea82ba2c037e63e708b" translate="yes" xml:space="preserve">
          <source>The following macros are defined:</source>
          <target state="translated">定义了以下宏:</target>
        </trans-unit>
        <trans-unit id="c28f5023d2a208f7eb90d1c1666a542586bef327" translate="yes" xml:space="preserve">
          <source>The following macros are predefined:</source>
          <target state="translated">以下是预定义的宏。</target>
        </trans-unit>
        <trans-unit id="bee950191de94f676ee96776b15e0ccba25dfb73" translate="yes" xml:space="preserve">
          <source>The following macros can be used for retrieving parts of Erlang terms. None of these do any type checking. Results are undefined if you pass an &lt;code&gt;ETERM*&lt;/code&gt; containing the wrong type. For example, passing a tuple to &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; likely results in garbage.</source>
          <target state="translated">以下宏可用于检索部分Erlang术语。这些都不进行任何类型检查。如果传递的 &lt;code&gt;ETERM*&lt;/code&gt; 包含错误的类型，则结果不确定。例如，将元组传递给 &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; 可能会导致垃圾。</target>
        </trans-unit>
        <trans-unit id="a6e5655e09259732c78235fc15eeeb16532c8c59" translate="yes" xml:space="preserve">
          <source>The following macros can make tests more compact and readable:</source>
          <target state="translated">下面的宏可以使测试更加紧凑和可读。</target>
        </trans-unit>
        <trans-unit id="3ca8309f3b4453ebe12d39150b4c1a41828a11c5" translate="yes" xml:space="preserve">
          <source>The following matches &lt;code&gt;Expr1&lt;/code&gt;, a pattern, against &lt;code&gt;Expr2&lt;/code&gt;:</source>
          <target state="translated">以下与 &lt;code&gt;Expr2&lt;/code&gt; 匹配一个模式 &lt;code&gt;Expr1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b69739288091f88fd2e2b7df4c33b95efbcb7de9" translate="yes" xml:space="preserve">
          <source>The following matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;:</source>
          <target state="translated">以下符合任何 &quot;foo &quot;后面没有 &quot;bar &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="484da9e33049d8639a65d77742562fb2909ccd89" translate="yes" xml:space="preserve">
          <source>The following matches exactly eight digits:</source>
          <target state="translated">以下正好符合八位数。</target>
        </trans-unit>
        <trans-unit id="a06f765490e0bde0129ff3bc5255ac6d9e037e52" translate="yes" xml:space="preserve">
          <source>The following matchings are performed:</source>
          <target state="translated">进行以下匹配。</target>
        </trans-unit>
        <trans-unit id="10508667a9f0cb2b801a082330c255eed8059206" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process, provided it is stopped at a breakpoint (for details, see section &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">以下菜单项适用于当前选定的进程，前提是该进程在断点处停止（有关详细信息，请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 部分）：</target>
        </trans-unit>
        <trans-unit id="012b9ddb6f5b2f9ff9b23f710bee122c826518c8" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process:</source>
          <target state="translated">以下菜单项适用于当前选定的流程。</target>
        </trans-unit>
        <trans-unit id="961db581de293dbe681aab0fe7f1fa5413883ae0" translate="yes" xml:space="preserve">
          <source>The following message is sent to fred's client:</source>
          <target state="translated">下面的信息是发给fred的客户的。</target>
        </trans-unit>
        <trans-unit id="040a3190564c92ea22bf0b64f131001c6c8e6bcc" translate="yes" xml:space="preserve">
          <source>The following message is sent to peter's client:</source>
          <target state="translated">下面的信息是发给彼得的客户的。</target>
        </trans-unit>
        <trans-unit id="46e910fb5b7dc40614e76e8f199ed8c133275031" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;ssh_client_channel&lt;/code&gt; 行为负责处理以下消息。</target>
        </trans-unit>
        <trans-unit id="568021cb728093af7ccf7e34bcf43fc6d465a610" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_server_channel&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;ssh_server_channel&lt;/code&gt; 行为负责处理以下消息。</target>
        </trans-unit>
        <trans-unit id="95574b85a29dc16b146c7d05b6e10a7f4673d155" translate="yes" xml:space="preserve">
          <source>The following message is used to report that a response to a request has been received. The only request an agent can send is an Inform-Request.</source>
          <target state="translated">以下消息用于报告已收到对请求的响应。代理人只能发送的请求是Inform-Request。</target>
        </trans-unit>
        <trans-unit id="0c7528a0e8b223caeddcbcb738daf3c373f6236b" translate="yes" xml:space="preserve">
          <source>The following options are accepted by &lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; 接受以下选项：</target>
        </trans-unit>
        <trans-unit id="61183e21017b0486797e22d4c6cd3d34960e2bbe" translate="yes" xml:space="preserve">
          <source>The following options are also available, but their use is not recommended (they are mostly for Dialyzer developers and internal debugging):</source>
          <target state="translated">以下选项也是可用的,但不建议使用(它们主要用于Dialyzer开发人员和内部调试)。</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">有以下选项:</target>
        </trans-unit>
        <trans-unit id="bd679e7b65020adaa7caadfb8cc5ecd8137541b1" translate="yes" xml:space="preserve">
          <source>The following options are client-specific or have a slightly different meaning in the client than in the server:</source>
          <target state="translated">以下选项是客户机特有的,或者在客户机中的含义与在服务器中的略有不同。</target>
        </trans-unit>
        <trans-unit id="43fc95d7126c192227c57609b602277d7d9fc9c6" translate="yes" xml:space="preserve">
          <source>The following options are relevant for execution:</source>
          <target state="translated">下列选项与执行有关:</target>
        </trans-unit>
        <trans-unit id="e08de76658d5ff2a86a979ad65f0c82faad76c53" translate="yes" xml:space="preserve">
          <source>The following options are server-specific or have a slightly different meaning in the server than in the client:</source>
          <target state="translated">以下选项是服务器特有的,或者在服务器中的含义与在客户端中的略有不同。</target>
        </trans-unit>
        <trans-unit id="05f80f80cb76aee8e2eb49065b6adb6528a602a4" translate="yes" xml:space="preserve">
          <source>The following options are valid for specifying an SSH/SFTP connection (that is, can be used as configuration elements):</source>
          <target state="translated">以下选项对于指定SSH/SFTP连接有效(可以作为配置元素使用)。</target>
        </trans-unit>
        <trans-unit id="64236fe6def7f266116ddf3fd4dbff2f206d4ac0" translate="yes" xml:space="preserve">
          <source>The following options can also be specified with the suite information list:</source>
          <target state="translated">以下选项也可以通过套房信息列表指定。</target>
        </trans-unit>
        <trans-unit id="7f19a5edc418a6bcc2f47d78030913af7ccd1058" translate="yes" xml:space="preserve">
          <source>The following options can be used:</source>
          <target state="translated">可以使用以下选项:</target>
        </trans-unit>
        <trans-unit id="11c58ec5e85924908f7ac6436290b127a355d50e" translate="yes" xml:space="preserve">
          <source>The following options have the same meaning in the client and the server:</source>
          <target state="translated">以下选项在客户端和服务器上具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="cc3e03d64e601199200fd4b43567e38970933b0e" translate="yes" xml:space="preserve">
          <source>The following options modify the defaults for the extraction as follows:</source>
          <target state="translated">以下选项修改提取的默认值如下:</target>
        </trans-unit>
        <trans-unit id="ce8906ae4045d2d535cd313e6ec00213370b53c4" translate="yes" xml:space="preserve">
          <source>The following options must be present:</source>
          <target state="translated">必须有以下选项:</target>
        </trans-unit>
        <trans-unit id="0a2f1d45ea56db7e397408b134364d0f8afeb1b3" translate="yes" xml:space="preserve">
          <source>The following output is shown:</source>
          <target state="translated">以下为输出结果。</target>
        </trans-unit>
        <trans-unit id="1e25b43e0cc5f60f33a4f8cad836e1610d7400d5" translate="yes" xml:space="preserve">
          <source>The following pair is returned for halt logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">对于以 &lt;code&gt;read_write&lt;/code&gt; 模式打开的暂停日志，返回以下对：</target>
        </trans-unit>
        <trans-unit id="c33b12b3e0b9d36e7372996a4a7abaf00697933a" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">对于以 &lt;code&gt;read_write&lt;/code&gt; 模式打开的所有日志，返回以下对：</target>
        </trans-unit>
        <trans-unit id="7611c3aa913240353c120613c97a195274c20308" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs:</source>
          <target state="translated">以下是所有日志的返回对:</target>
        </trans-unit>
        <trans-unit id="91a838c6cf493f03c500bbdbcdd502edf542e0fe" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for wrap logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">对于以 &lt;code&gt;read_write&lt;/code&gt; 模式打开的换行日志，返回以下对：</target>
        </trans-unit>
        <trans-unit id="224537c90399cde228dbede4c53cbc30f714374c" translate="yes" xml:space="preserve">
          <source>The following parameters can be specified for each Erlang service:</source>
          <target state="translated">可以为每个Erlang服务指定以下参数。</target>
        </trans-unit>
        <trans-unit id="7561aff36c4e31e9b40cf0d53c766582f8727228" translate="yes" xml:space="preserve">
          <source>The following parameters represents the SNMP configuration files &lt;code&gt;context.conf&lt;/code&gt;, &lt;code&gt;standard.conf&lt;/code&gt;, &lt;code&gt;community.conf&lt;/code&gt;, &lt;code&gt;vacm.conf&lt;/code&gt;, &lt;code&gt;usm.conf&lt;/code&gt;, &lt;code&gt;notify.conf&lt;/code&gt;, &lt;code&gt;target_addr.conf&lt;/code&gt;, and &lt;code&gt;target_params.conf&lt;/code&gt;. Notice that all values in &lt;code&gt;agent.conf&lt;/code&gt; can be modified by the parameters listed above. All these configuration files have default values set by the &lt;code&gt;SNMP&lt;/code&gt; application. These values can be overridden by suppling a list of valid configuration values or a file located in the test suites data directory, which can produce a list of valid configuration values if you apply function &lt;code&gt;file:consult/1&lt;/code&gt; to the file.</source>
          <target state="translated">以下参数表示SNMP配置文件 &lt;code&gt;context.conf&lt;/code&gt; ， &lt;code&gt;standard.conf&lt;/code&gt; ， &lt;code&gt;community.conf&lt;/code&gt; ， &lt;code&gt;vacm.conf&lt;/code&gt; ， &lt;code&gt;usm.conf&lt;/code&gt; ， &lt;code&gt;notify.conf&lt;/code&gt; ， &lt;code&gt;target_addr.conf&lt;/code&gt; 和 &lt;code&gt;target_params.conf&lt;/code&gt; 。请注意， &lt;code&gt;agent.conf&lt;/code&gt; 中的所有值都可以通过上面列出的参数进行修改。所有这些配置文件均具有由 &lt;code&gt;SNMP&lt;/code&gt; 应用程序设置的默认值。可以通过提供有效配置值列表或位于测试套件数据目录中的文件来覆盖这些值，如果应用function &lt;code&gt;file:consult/1&lt;/code&gt; ，则可以生成有效配置值列表。 到文件。</target>
        </trans-unit>
        <trans-unit id="cf9b8bf83a4a013f2ea8d7a63a8c6eceb1e8ce5f" translate="yes" xml:space="preserve">
          <source>The following pattern matches &quot;foo&quot; preceded by three digits and any three characters that are not &quot;999&quot;:</source>
          <target state="translated">以下模式匹配 &quot;foo &quot;前面的三个数字和任何三个非 &quot;999 &quot;的字符。</target>
        </trans-unit>
        <trans-unit id="b6c387fc7cb1c2a0aaf335c75b4b32deefd1c2b6" translate="yes" xml:space="preserve">
          <source>The following picture gives an overview of the mechanism to select an MIB view:</source>
          <target state="translated">下图为选择MIB视图的机制概述。</target>
        </trans-unit>
        <trans-unit id="343b7de69e7382fea1083cf8cb82178662515737" translate="yes" xml:space="preserve">
          <source>The following picture illustrates the idea:</source>
          <target state="translated">下图说明了这个想法。</target>
        </trans-unit>
        <trans-unit id="4b30adf5dd015c5f072d818ec045884b44dff621" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; User's Guide:</source>
          <target state="translated">要了解《 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 用户指南》中的资料，需要满足以下先决条件：</target>
        </trans-unit>
        <trans-unit id="f494d18baeb5626e63a43266d42eed96b8ed12a2" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Megaco User's Guide:</source>
          <target state="translated">要理解Megaco用户指南中的材料,需要以下先决条件。</target>
        </trans-unit>
        <trans-unit id="1cbd57540b48d0efa55b14338c8830cec00d8547" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Reltool User's Guide:</source>
          <target state="translated">要理解Reltool用户指南中的材料,需要以下前提条件。</target>
        </trans-unit>
        <trans-unit id="7e4d733e362ec6903442fab3ca35dcd536f3cdbe" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the SNMP User's Guide:</source>
          <target state="translated">要理解《SNMP用户指南》中的材料,需要以下前提条件。</target>
        </trans-unit>
        <trans-unit id="fab1a3516c76bbdd3d05df3eae1d2f555b42050e" translate="yes" xml:space="preserve">
          <source>The following procedure does not require root privilege:</source>
          <target state="translated">以下过程不需要root权限。</target>
        </trans-unit>
        <trans-unit id="a8602668ad76f501ac94f891d7bfbf36be343c4f" translate="yes" xml:space="preserve">
          <source>The following program illustrates the different ways of creating funs:</source>
          <target state="translated">下面的程序说明了创建趣味的不同方式。</target>
        </trans-unit>
        <trans-unit id="dbcee6e28420ee50b59b118c6bd9505eaeb1f3e3" translate="yes" xml:space="preserve">
          <source>The following program module creates and populates previously defined tables:</source>
          <target state="translated">以下程序模块创建并填充先前定义的表格。</target>
        </trans-unit>
        <trans-unit id="872226e20506f4791f4924b86b65d0e2ff5aeff1" translate="yes" xml:space="preserve">
          <source>The following queries are accepted from remote nodes:</source>
          <target state="translated">接受来自远程节点的以下查询。</target>
        </trans-unit>
        <trans-unit id="34fcb8ab715f637bf664ee99fb64aae24ae2711f" translate="yes" xml:space="preserve">
          <source>The following record definitions can be created:</source>
          <target state="translated">可以创建以下记录定义:</target>
        </trans-unit>
        <trans-unit id="7aba38102e6596c004eb1b74efe69102547563ee" translate="yes" xml:space="preserve">
          <source>The following records are generated because of type &lt;code&gt;Emb&lt;/code&gt;:</source>
          <target state="translated">由于类型为 &lt;code&gt;Emb&lt;/code&gt; 而生成以下记录：</target>
        </trans-unit>
        <trans-unit id="52b8b7242e195bbd29d16d5919c21b7b689163ef" translate="yes" xml:space="preserve">
          <source>The following records used by xmerl to save the parsed data are defined in &lt;code&gt;xmerl.hrl&lt;/code&gt;</source>
          <target state="translated">使用xmerl保存解析数据如下记录中定义 &lt;code&gt;xmerl.hrl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a7943f947fe72299ad61ae324cdc2eb219124" translate="yes" xml:space="preserve">
          <source>The following representations control how and where tests are executed:</source>
          <target state="translated">以下表示控制测试的执行方式和地点。</target>
        </trans-unit>
        <trans-unit id="86bacadf1ea90a3c97d82c63773f210e42c2a214" translate="yes" xml:space="preserve">
          <source>The following representations specify fixture handling for test sets:</source>
          <target state="translated">下面的表示方式指定了测试集的夹具处理。</target>
        </trans-unit>
        <trans-unit id="010a5b84d478f42d2d6af978a84f08199f613d86" translate="yes" xml:space="preserve">
          <source>The following requirements apply to the &lt;code&gt;.app&lt;/code&gt; file for an included application:</source>
          <target state="translated">以下要求适用于包含的应用程序的 &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="47012e55fe1825d2922f7d5fb219850e8c4ce7ee" translate="yes" xml:space="preserve">
          <source>The following runs a test executing &lt;code&gt;tc12&lt;/code&gt; in &lt;code&gt;top1&lt;/code&gt; and any subgroup under &lt;code&gt;top1&lt;/code&gt; where it can be found (&lt;code&gt;sub11&lt;/code&gt; and &lt;code&gt;sub121&lt;/code&gt;):</source>
          <target state="translated">以下运行测试执行 &lt;code&gt;tc12&lt;/code&gt; 在 &lt;code&gt;top1&lt;/code&gt; 和下的任意亚类 &lt;code&gt;top1&lt;/code&gt; ，其中可以发现（ &lt;code&gt;sub11&lt;/code&gt; 和 &lt;code&gt;sub121&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0e90b96a7f25790f2708f620c0e643b1c7f52c18" translate="yes" xml:space="preserve">
          <source>The following script illustrates a modification where the node is given the name &lt;code&gt;cp1&lt;/code&gt;, and where the environment variables &lt;code&gt;HEART_COMMAND&lt;/code&gt; and &lt;code&gt;TERM&lt;/code&gt; have been added to the previous script:</source>
          <target state="translated">以下脚本说明了一个修改，其中该节点的名称为 &lt;code&gt;cp1&lt;/code&gt; ，并且环境变量 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 和 &lt;code&gt;TERM&lt;/code&gt; 已添加到先前的脚本中：</target>
        </trans-unit>
        <trans-unit id="5db13a72ee33e776ce2ddcad2d3b2330d02936db" translate="yes" xml:space="preserve">
          <source>The following script illustrates the behaviour of the program:</source>
          <target state="translated">下面的脚本说明了该程序的行为。</target>
        </trans-unit>
        <trans-unit id="4cb6bb01c4a2fc6f1d31fffabe3ea35bf47bbd99" translate="yes" xml:space="preserve">
          <source>The following script illustrates the default behaviour of the program:</source>
          <target state="translated">下面的脚本说明了程序的默认行为。</target>
        </trans-unit>
        <trans-unit id="1730c3be7b670e5f6ed8dc96c7503a465a16bfb5" translate="yes" xml:space="preserve">
          <source>The following searches &lt;code&gt;top1&lt;/code&gt; and all its subgroups for &lt;code&gt;tc16&lt;/code&gt; resulting in that this test case executes in group &lt;code&gt;sub121&lt;/code&gt;:</source>
          <target state="translated">下面的搜索 &lt;code&gt;top1&lt;/code&gt; 及其所有子群 &lt;code&gt;tc16&lt;/code&gt; 导致这个测试用例组执行 &lt;code&gt;sub121&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="526a47fb0328941b790c466199e779b1931bd0e8" translate="yes" xml:space="preserve">
          <source>The following section describes the mandatory and optional test suite functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">以下部分描述了 &lt;code&gt;Common Test&lt;/code&gt; 在测试执行期间调用的强制性和可选测试套件功能。有关更多详细信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="72c1a7ce03d50e78be89c8cc10dbc16d75c4a19c" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material for the regular expressions used by this module. The information is based on the PCRE documentation, with changes where this module behaves differently to the PCRE library.</source>
          <target state="translated">下面的章节包含了本模块使用的正则表达式的参考资料。这些信息以PCRE文档为基础,在本模块与PCRE库不同的地方进行了修改。</target>
        </trans-unit>
        <trans-unit id="83810d4821d49c1738acda1b065dd05f79bc8cd1" translate="yes" xml:space="preserve">
          <source>The following sections deal with target systems with different requirements of functionality:</source>
          <target state="translated">以下各节涉及的是对功能有不同要求的目标系统。</target>
        </trans-unit>
        <trans-unit id="38eecd6e67f72292d41c686c8caab1a223f8a8a9" translate="yes" xml:space="preserve">
          <source>The following sections describe how the instrumentation functions should be defined in Erlang for the different operations. In the following, &lt;code&gt;RowIndex&lt;/code&gt; is a list of key values for the table, and &lt;code&gt;Column&lt;/code&gt; is a column number.</source>
          <target state="translated">以下各节描述应如何在Erlang中为不同的操作定义检测功能。在下面， &lt;code&gt;RowIndex&lt;/code&gt; 是表的键值的列表，而 &lt;code&gt;Column&lt;/code&gt; 是列号。</target>
        </trans-unit>
        <trans-unit id="93b41da5ab42cf67eae696be1649b8c0efaf1bfc" translate="yes" xml:space="preserve">
          <source>The following sections describe how to use CTHs, when they are run, and how to manipulate the test results in a CTH.</source>
          <target state="translated">下文将介绍如何使用CTH、何时运行CTH以及如何在CTH中操作测试结果。</target>
        </trans-unit>
        <trans-unit id="31ea898329f4b3682826cd0bafcd93ad163d085b" translate="yes" xml:space="preserve">
          <source>The following sections describe sequential tracing and its most fundamental concepts.</source>
          <target state="translated">以下章节将介绍顺序跟踪及其最基本的概念。</target>
        </trans-unit>
        <trans-unit id="9600ad9c1d4332036b9e8528fa9289370114665e" translate="yes" xml:space="preserve">
          <source>The following sections describe some of the fields in the information tabs. These are fields that do not exist in the raw crashdump, or in some way differ from the fields in the raw crashdump. For details about other fields, see the &lt;code&gt;ERTS User's Guide&lt;/code&gt;, section &quot;How to interpret the Erlang crash dumps&quot;. That section can also be opened from the &lt;strong&gt;Help&lt;/strong&gt; menu in the main window. There are also links from the following sections to related information in &quot;How to interpret the Erlang crash dumps&quot;.</source>
          <target state="translated">以下各节描述了信息选项卡中的某些字段。这些是原始崩溃转储中不存在的字段，或与原始崩溃转储中的字段有所不同。有关其他字段的详细信息，请参见《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 》的&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;部分。也可以从主窗口的&amp;ldquo; &lt;strong&gt;帮助&amp;rdquo;&lt;/strong&gt;菜单中打开该部分。以下各节中还有指向&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;中相关信息的链接。</target>
        </trans-unit>
        <trans-unit id="e038c99195f68fa297f2e5f9e78c69595a14730e" translate="yes" xml:space="preserve">
          <source>The following sections describe the mandatory and optional CTH functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">以下各节描述了 &lt;code&gt;Common Test&lt;/code&gt; 在测试执行期间调用的强制和可选CTH函数。有关更多详细信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="8ca82394dc00f1e6d08913e914b59a46cf6c2484" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each metacharacter.</source>
          <target state="translated">以下各节介绍各元字的使用情况。</target>
        </trans-unit>
        <trans-unit id="57bd03425adcf43ca596408a2b02f2936cfeb5dd" translate="yes" xml:space="preserve">
          <source>The following sections describe these steps.</source>
          <target state="translated">以下各节将介绍这些步骤。</target>
        </trans-unit>
        <trans-unit id="ef3caea09c20221894e510d93d0376e9f32ba13c" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of how to profile with Fprof. See also the reference manual &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下各节显示了一些如何使用Fprof进行分析的示例。另请参见参考手册 &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98275a3598f57cab63cd60d26cf4b95397a5db2f" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of profiling with &lt;code&gt;cprof&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下各节显示了使用 &lt;code&gt;cprof&lt;/code&gt; 进行分析的一些示例。另请参阅 &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3346c4bffa9bbaca48b8099eae111ab7c83c1879" translate="yes" xml:space="preserve">
          <source>The following sections show some features of Xref, beginning with a module check and a predefined analysis. Then follow examples that can be skipped on the first reading; not all of the concepts used are explained, and it is assumed that the &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; has been at least skimmed.</source>
          <target state="translated">以下各节从模块检查和预定义分析开始，展示了Xref的一些功能。然后按照可以在第一次阅读时跳过的示例进行操作；并非所有使用的概念都得到解释，并且假定 &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 至少已被略读。</target>
        </trans-unit>
        <trans-unit id="4f224d7ff4347a5d76be2a01609f9bb95ab48bc8" translate="yes" xml:space="preserve">
          <source>The following sequence of calls fails:</source>
          <target state="translated">以下一连串的呼叫失败。</target>
        </trans-unit>
        <trans-unit id="6f684598ccd6c3370add4d7675b782860903e544" translate="yes" xml:space="preserve">
          <source>The following sequence works, as the call to &lt;code&gt;repair_continuation/2&lt;/code&gt; reestablishes the (deliberately) invalidated continuation &lt;code&gt;Broken&lt;/code&gt;.</source>
          <target state="translated">以下序列起作用，因为对 &lt;code&gt;repair_continuation/2&lt;/code&gt; 的调用重新建立了（故意）无效的延续 &lt;code&gt;Broken&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8d34878ccc7af10841358fe32d20c8e85617519" translate="yes" xml:space="preserve">
          <source>The following session with the Erlang shell shows how to load the &lt;code&gt;FRUITS&lt;/code&gt; database:</source>
          <target state="translated">以下与Erlang Shell的会话显示了如何加载 &lt;code&gt;FRUITS&lt;/code&gt; 数据库：</target>
        </trans-unit>
        <trans-unit id="1ca2b9cadd413c828114f5fdadb155510f45b89f" translate="yes" xml:space="preserve">
          <source>The following shell interaction starts &lt;code&gt;Mnesia&lt;/code&gt; and initializes the schema for the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">以下外壳交互将启动 &lt;code&gt;Mnesia&lt;/code&gt; 并初始化 &lt;code&gt;Company&lt;/code&gt; 数据库的架构：</target>
        </trans-unit>
        <trans-unit id="3e56ec35aa2570200adfb4251b42d9a7a4dbc048" translate="yes" xml:space="preserve">
          <source>The following shows an example &lt;code&gt;.rel&lt;/code&gt; file with TLS added:</source>
          <target state="translated">下面显示了添加了TLS 的示例 &lt;code&gt;.rel&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="e94749126c9966bcf63f22766109b91add03d6be" translate="yes" xml:space="preserve">
          <source>The following shows examples of how UTF-8 encoded binaries can be created and manipulated:</source>
          <target state="translated">下面展示了如何创建和操作UTF-8编码的二进制文件的例子。</target>
        </trans-unit>
        <trans-unit id="53b230af1628e298070b4609c7e79b754d5b0d07" translate="yes" xml:space="preserve">
          <source>The following shows how the compiler can be called from the Erlang shell:</source>
          <target state="translated">下面展示了如何从Erlang shell中调用编译器。</target>
        </trans-unit>
        <trans-unit id="729768340129de2ea35b78f26817f116e7bf52b6" translate="yes" xml:space="preserve">
          <source>The following simple code illustrates the relationship between the simplified access functions used in most of the examples and their more flexible counterparts:</source>
          <target state="translated">下面的简单代码说明了大多数例子中使用的简化访问函数与它们更灵活的对应函数之间的关系。</target>
        </trans-unit>
        <trans-unit id="b84b8caa8b26cb602514d1eab6fc03a38ae48762" translate="yes" xml:space="preserve">
          <source>The following small module is used in the subsequent example:</source>
          <target state="translated">在随后的例子中,使用了以下小模块。</target>
        </trans-unit>
        <trans-unit id="6b1dfc37e671a01a444893fce16128adaeffd6fa" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get a running agent:</source>
          <target state="translated">要获得运行的代理,需要以下步骤。</target>
        </trans-unit>
        <trans-unit id="bc08bddc5161d849d8adaf8a442d077969754d3f" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get the manager running:</source>
          <target state="translated">以下是让管理器运行所需的步骤。</target>
        </trans-unit>
        <trans-unit id="fa6e913607cc215db5650f46601c1682dec9a4c4" translate="yes" xml:space="preserve">
          <source>The following tags appears in the list:</source>
          <target state="translated">列表中出现了以下标签。</target>
        </trans-unit>
        <trans-unit id="59f95e04d57dcd84839504590aa3ea9df899aa69" translate="yes" xml:space="preserve">
          <source>The following tags have special meaning:</source>
          <target state="translated">以下标签具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="1e75dc33e0130efecbbf3b0c117aa1a4317b0d14" translate="yes" xml:space="preserve">
          <source>The following terms are allowed in a cover specification file:</source>
          <target state="translated">封面规格文件中允许使用以下术语:</target>
        </trans-unit>
        <trans-unit id="082dcb2df904c716cc9a3e85c660d6af2e65ff42" translate="yes" xml:space="preserve">
          <source>The following top level &lt;code&gt;options&lt;/code&gt; are supported:</source>
          <target state="translated">支持以下顶级 &lt;code&gt;options&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="49a42c98aae1a012fca04ff4fc1c26473f67efa7" translate="yes" xml:space="preserve">
          <source>The following topics are included:</source>
          <target state="translated">包括以下主题:</target>
        </trans-unit>
        <trans-unit id="05245f82bf6574a4a5eff794c54d89c9d6171eb9" translate="yes" xml:space="preserve">
          <source>The following topics are not treated in this section:</source>
          <target state="translated">本节不涉及以下专题:</target>
        </trans-unit>
        <trans-unit id="ab7564645416f18d8a1c44a537bed7227fcf3ddd" translate="yes" xml:space="preserve">
          <source>The following trace output is received during test:</source>
          <target state="translated">在测试过程中,收到以下跟踪输出。</target>
        </trans-unit>
        <trans-unit id="b466650d4111c63d9300f7fbae0b73cc83cacf0c" translate="yes" xml:space="preserve">
          <source>The following two Kernel configuration parameters affect the behavior of all sockets opened on an Erlang node:</source>
          <target state="translated">以下两个内核配置参数会影响在Erlang节点上打开的所有socket的行为。</target>
        </trans-unit>
        <trans-unit id="4a11518ecf3b3d71056ddbfd18678d2117872201" translate="yes" xml:space="preserve">
          <source>The following two calls give the same result (but certainly not the same execution time):</source>
          <target state="translated">以下两个调用给出的结果是一样的(但执行时间肯定不一样)。</target>
        </trans-unit>
        <trans-unit id="5507869e7948c09fc8040111e6b2cadd35e4aff0" translate="yes" xml:space="preserve">
          <source>The following two directories must exist in the system to run the agent:</source>
          <target state="translated">系统中必须存在以下两个目录才能运行代理。</target>
        </trans-unit>
        <trans-unit id="113cb904554a59290d2e213118f8d8428037b8fb" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to retrieve system information. For details, see the Reference Manual.</source>
          <target state="translated">以下两个功能可用于检索系统信息。详情请参见《参考手册》。</target>
        </trans-unit>
        <trans-unit id="71cd872babc8d6113efd7cead6cf75e880db8ea3" translate="yes" xml:space="preserve">
          <source>The following two functions manipulate indexes on existing tables:</source>
          <target state="translated">以下两个函数对现有表的索引进行操作。</target>
        </trans-unit>
        <trans-unit id="706b90dd5c946a37fcc3ef255278e31f7c9293de" translate="yes" xml:space="preserve">
          <source>The following two notations are available for representation of &lt;code&gt;BIT STRING&lt;/code&gt; values in Erlang and as input to the encode functions:</source>
          <target state="translated">以下两种符号可用于用Erlang 表示 &lt;code&gt;BIT STRING&lt;/code&gt; 值，以及作为编码函数的输入：</target>
        </trans-unit>
        <trans-unit id="9929e878110d22fef5c962cd4c16eef48be74d8c" translate="yes" xml:space="preserve">
          <source>The following two pairs of functions support this scenario:</source>
          <target state="translated">以下两对函数支持这种情况。</target>
        </trans-unit>
        <trans-unit id="09ba41aca160585c0b08fc3e3fe758e0deed5098" translate="yes" xml:space="preserve">
          <source>The following type definitions are used by more than one function in the FTP client API:</source>
          <target state="translated">以下类型定义在FTP客户端API中被多个函数使用。</target>
        </trans-unit>
        <trans-unit id="9226ce7513015120a190ef4af2c57e38cf1718d8" translate="yes" xml:space="preserve">
          <source>The following values are allowed for &lt;code&gt;Key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 允许使用以下值：</target>
        </trans-unit>
        <trans-unit id="6c84aa8502d90e7ba6f618344ec9f0990938b08f" translate="yes" xml:space="preserve">
          <source>The following verb causes a matching failure, forcing backtracking to occur. It is equivalent to (?!) but easier to read.</source>
          <target state="translated">下面的动词会导致匹配失败,迫使回溯发生。相当于(?!),但读起来比较容易。</target>
        </trans-unit>
        <trans-unit id="c74b31c10443669b849931e80db4cb844acc7e6d" translate="yes" xml:space="preserve">
          <source>The following verb causes a skip to the next innermost alternative when backtracking reaches it. That is, it cancels any further backtracking within the current alternative.</source>
          <target state="translated">当回溯到下一个最里面的选项时,下面的动词会导致跳转到该选项。也就是说,它取消了当前选项中的任何进一步的回溯。</target>
        </trans-unit>
        <trans-unit id="3626ed56739d6ce7e205e1a6154059baf311b051" translate="yes" xml:space="preserve">
          <source>The following verb causes the match to fail at the current starting position in the subject if there is a later matching failure that causes backtracking to reach it:</source>
          <target state="translated">下面的动词如果有后来的匹配失败,导致回溯到达主语的当前起始位置,就会导致匹配失败。</target>
        </trans-unit>
        <trans-unit id="20e32c99b23fb1cb8aa4ff4619bdeb76fe057cfe" translate="yes" xml:space="preserve">
          <source>The following verb, when specified without a name, is like (*PRUNE), except that if the pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next character, but to the position in the subject where (*SKIP) was encountered.</source>
          <target state="translated">下面的动词,在没有指定名称的情况下,和(*PRUNE)一样,只是如果模式是无锚的,&quot;撞龙 &quot;前进不是到下一个字符,而是到主题中遇到(*SKIP)的位置。</target>
        </trans-unit>
        <trans-unit id="56e82a4845f59e054a6c2a8f1874cfef875f8736" translate="yes" xml:space="preserve">
          <source>The following verb, which must not be followed by a name, causes the whole match to fail outright if there is a later matching failure that causes backtracking to reach it. Even if the pattern is unanchored, no further attempts to find a match by advancing the starting point take place.</source>
          <target state="translated">下面的动词,后面不能有名字,如果后面出现匹配失败,导致回溯到达,会导致整个匹配直接失败。即使该模式没有锚定,也不会再尝试通过推进起点来寻找匹配。</target>
        </trans-unit>
        <trans-unit id="4d2ee15663a5b3e2b4b9ab4b42fcb763860ca710" translate="yes" xml:space="preserve">
          <source>The following verbs act as soon as they are encountered. They must not be followed by a name.</source>
          <target state="translated">以下动词一遇到就会行动。这些动词后面不能有名字。</target>
        </trans-unit>
        <trans-unit id="6bc631f8808db5a059db58a11cb23a25b194b9bc" translate="yes" xml:space="preserve">
          <source>The following verbs do nothing when they are encountered. Matching continues with what follows, but if there is no subsequent match, causing a backtrack to the verb, a failure is forced. That is, backtracking cannot pass to the left of the verb. However, when one of these verbs appears inside an atomic group or an assertion that is true, its effect is confined to that group, as once the group has been matched, there is never any backtracking into it. In this situation, backtracking can &quot;jump back&quot; to the left of the entire atomic group or assertion. (Remember also, as stated above, that this localization also applies in subroutine calls.)</source>
          <target state="translated">遇到以下动词时,什么都不做。与后面的内容继续匹配,但如果没有后续的匹配,导致回溯到动词,就会被迫失败。也就是说,回溯不能传递到动词的左边。但是,当其中一个动词出现在一个原子组或一个真的断言里面时,它的作用仅限于该组,因为一旦该组被匹配,就永远不会回溯到该组。在这种情况下,回溯可以 &quot;跳回 &quot;到整个原子组或断言的左边。还请记住,如上所述,这种局部也适用于子程序调用中)。</target>
        </trans-unit>
        <trans-unit id="e618ac47f63af62ceb8671ae5e22050d8ff5aec4" translate="yes" xml:space="preserve">
          <source>The following warnings and restrictions apply to the funs used in with &lt;code&gt;ets:fun2ms/1&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">以下警告和限制适用于 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 和 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 所使用的乐趣。</target>
        </trans-unit>
        <trans-unit id="58ed2789e1ec56e8739ba6ba58818f4844d3585c" translate="yes" xml:space="preserve">
          <source>The following will appear at the console on the node that started the trace client:</source>
          <target state="translated">以下内容将出现在启动跟踪客户端的节点的控制台。</target>
        </trans-unit>
        <trans-unit id="4f6cfe143c1844487af6c9d7af979551cc8a56ef" translate="yes" xml:space="preserve">
          <source>The foreign key</source>
          <target state="translated">外键</target>
        </trans-unit>
        <trans-unit id="d5bbce337b986ce05bfb1074200a1cd8e6ba791d" translate="yes" xml:space="preserve">
          <source>The format and value of &lt;code&gt;FixationTime&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FixationTime&lt;/code&gt; 的格式和值取决于 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="403056f7b6145ea80b76c6096562c79850393812" translate="yes" xml:space="preserve">
          <source>The format function is also optional. It is called by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; to give feedback at runtime of how the query is to be evaluated. Try to give as good feedback as possible without showing too much details. In the example, at most seven objects of the table are shown. The format function handles two cases: &lt;code&gt;all&lt;/code&gt; means that all objects of the table are traversed; &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; means that the lookup function is used for looking up key values.</source>
          <target state="translated">格式功能也是可选的。它由 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 调用，以在运行时给出如何评估查询的反馈。尝试在不显示过多细节的情况下提供尽可能好的反馈。在该示例中，最多显示了该表的七个对象。格式函数处理两种情况： &lt;code&gt;all&lt;/code&gt; 表示遍历表的所有对象。 &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; 表示查找功能用于查找键值。</target>
        </trans-unit>
        <trans-unit id="a28925d546a087448d542d4ec3fe58c4d1daac9b" translate="yes" xml:space="preserve">
          <source>The format is parsable with the standard Erlang parsing tools &lt;code&gt;erl_scan&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt;, &lt;code&gt;file:consult/1&lt;/code&gt; or &lt;code&gt;io:read/2&lt;/code&gt;. The parse format is not explained here - it should be easy for the interested to try it out. Note that some flags to &lt;code&gt;analyse/1&lt;/code&gt; will affect the format.</source>
          <target state="translated">该格式可以使用标准的Erlang解析工具 &lt;code&gt;erl_scan&lt;/code&gt; 和 &lt;code&gt;erl_parse&lt;/code&gt; ， &lt;code&gt;file:consult/1&lt;/code&gt; 或 &lt;code&gt;io:read/2&lt;/code&gt; 进行解析。解析格式在这里没有解释-有兴趣的人应该很容易尝试一下。请注意， &lt;code&gt;analyse/1&lt;/code&gt; 的某些标志会影响格式。</target>
        </trans-unit>
        <trans-unit id="dd5e5f8070fec3acf0e1ec232310a61ff03f8b85" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Drive&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;Drive&lt;/code&gt; 的格式无效。</target>
        </trans-unit>
        <trans-unit id="dbaf4dd1e5a91b60292984d5a8e1ea127c178da5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; depends on the operating system. On UNIX, it is typically produced from the output of the &lt;code&gt;ls -l&lt;/code&gt; shell command.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 的格式取决于操作系统。在UNIX上，通常由 &lt;code&gt;ls -l&lt;/code&gt; shell命令的输出产生。</target>
        </trans-unit>
        <trans-unit id="3a8dac735cad80fa64163e77b01f6b5b6e6b931f" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; is a stream of filenames where each filename is separated by &amp;lt;CRLF&amp;gt; or &amp;lt;NL&amp;gt;. Contrary to function &lt;code&gt;ls&lt;/code&gt;, the purpose of &lt;code&gt;nlist&lt;/code&gt; is to enable a program to process filename information automatically.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 的格式是文件名流，其中每个文件名用&amp;lt;CRLF&amp;gt;或&amp;lt;NL&amp;gt;分隔。与函数 &lt;code&gt;ls&lt;/code&gt; 相反， &lt;code&gt;nlist&lt;/code&gt; 的目的是使程序能够自动处理文件名信息。</target>
        </trans-unit>
        <trans-unit id="ca6bda514e36415bd8dfddbfd465c752506ba14c" translate="yes" xml:space="preserve">
          <source>The format of an audit trail log text item is as follows:</source>
          <target state="translated">审计线索日志文本项的格式如下:</target>
        </trans-unit>
        <trans-unit id="44015ed1506dab2702bf874c622404e1cdd4a16b" translate="yes" xml:space="preserve">
          <source>The format of decoded messages and grouped AVPs in the &lt;code&gt;msg&lt;/code&gt; field of diameter_packet records and &lt;code&gt;value&lt;/code&gt; field of diameter_avp records respectively. If &lt;code&gt;record&lt;/code&gt; then a record whose definition is generated from the dictionary file in question. If &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; then a &lt;code&gt;[Name | Avps]&lt;/code&gt; pair where &lt;code&gt;Avps&lt;/code&gt; is a list of AVP name/values pairs or a map keyed on AVP names respectively. If &lt;code&gt;none&lt;/code&gt; then the atom-value message name, or &lt;code&gt;undefined&lt;/code&gt; for a Grouped AVP. See also &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">分别在diameter_packet记录的 &lt;code&gt;msg&lt;/code&gt; 字段和diameter_avp记录的 &lt;code&gt;value&lt;/code&gt; 字段中的解码消息格式和分组的AVP 。如果 &lt;code&gt;record&lt;/code&gt; 则其定义是从有问题的字典文件生成一个记录。如果 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;map&lt;/code&gt; 则 &lt;code&gt;[Name | Avps]&lt;/code&gt; 对，其中， &lt;code&gt;Avps&lt;/code&gt; 是AVP名称/值对的列表或分别键入AVP名称的映射。如果 &lt;code&gt;none&lt;/code&gt; ，则为原子值消息名称，或者为分组AVP &lt;code&gt;undefined&lt;/code&gt; 。另请参见 &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="317788b6344114efeaf6f36e9948bb10fc231c82" translate="yes" xml:space="preserve">
          <source>The format of file &lt;code&gt;.hosts.erlang&lt;/code&gt; must be one host name per line. The host names must be within quotes.</source>
          <target state="translated">文件 &lt;code&gt;.hosts.erlang&lt;/code&gt; 的格式必须是每行一个主机名。主机名必须用引号引起来。</target>
        </trans-unit>
        <trans-unit id="2487f5cf9c75d813920c0dba73a01025e41c80a7" translate="yes" xml:space="preserve">
          <source>The format of received events is not defined.</source>
          <target state="translated">收到的事件的格式没有定义。</target>
        </trans-unit>
        <trans-unit id="9bfd68e235d56611f777394a5db1608f345a2ba3" translate="yes" xml:space="preserve">
          <source>The format of the &lt;code&gt;otp_versions.table&lt;/code&gt; might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;otp_versions.table&lt;/code&gt; 的格式可能会在OTP 17版本期间发生更改。</target>
        </trans-unit>
        <trans-unit id="689c1f8b385b83aa3589eb65a1746eb08236ca62" translate="yes" xml:space="preserve">
          <source>The format of the configuration file is found in the &lt;code&gt;syslog.conf(5)&lt;/code&gt; manual page, by issuing the command &lt;code&gt;man syslog.conf&lt;/code&gt;.</source>
          <target state="translated">可以通过发出命令 &lt;code&gt;man syslog.conf&lt;/code&gt; 在 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 手册页中找到配置文件的格式。</target>
        </trans-unit>
        <trans-unit id="f9f90e37b89af3e970911fe6712a87407f263ba3" translate="yes" xml:space="preserve">
          <source>The format of the crash dump evolves between OTP releases. Some information described here may not apply to your version. A description like this will never be complete; it is meant as an explanation of the crash dump in general and as a help when trying to find application errors, not as a complete specification.</source>
          <target state="translated">崩溃转储的格式在不同的OTP版本之间会发生变化。这里描述的一些信息可能不适用于你的版本。像这样的描述永远不会是完整的,它只是作为对崩溃转储的一个解释,并在试图找到应用程序错误时提供帮助,而不是作为一个完整的规范。</target>
        </trans-unit>
        <trans-unit id="eb9b12cb8d3ac8423ae8bea95db89eaec323992a" translate="yes" xml:space="preserve">
          <source>The format of the messages is one of the following, depending on if flag &lt;code&gt;timestamp&lt;/code&gt; of the trace token is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">消息的格式是以下格式之一，具体取决于跟踪令牌的标志 &lt;code&gt;timestamp&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="168262e7bb4ad03b8f9aa164f315f9eabe54fc52" translate="yes" xml:space="preserve">
          <source>The format of the node name is an atom &lt;code&gt;name@host&lt;/code&gt;. &lt;code&gt;name&lt;/code&gt; is the name given by the user. &lt;code&gt;host&lt;/code&gt; is the full host name if long names are used, or the first part of the host name if short names are used. &lt;code&gt;node()&lt;/code&gt; returns the name of the node.</source>
          <target state="translated">节点名称的格式为atom &lt;code&gt;name@host&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; 是用户提供的名称。 &lt;code&gt;host&lt;/code&gt; 是完整的主机名（如果使用了长名称），或者是主机名的第一部分（如果使用了短名称）。 &lt;code&gt;node()&lt;/code&gt; 返回节点的名称。</target>
        </trans-unit>
        <trans-unit id="e18dae497a998ac661c28b510144fccadd65f4ce" translate="yes" xml:space="preserve">
          <source>The format of the node status change messages depends on &lt;code&gt;Options&lt;/code&gt;. If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, which is the default, the format is as follows:</source>
          <target state="translated">节点状态更改消息的格式取决于 &lt;code&gt;Options&lt;/code&gt; 。如果 &lt;code&gt;Options&lt;/code&gt; 为 &lt;code&gt;[]&lt;/code&gt; ，这是默认设置，则格式如下：</target>
        </trans-unit>
        <trans-unit id="765472921ad5d1b4e5d1dc40a24f50b66dda836a" translate="yes" xml:space="preserve">
          <source>The format of the status message is as follows:</source>
          <target state="translated">状态信息的格式如下:</target>
        </trans-unit>
        <trans-unit id="f119a1fe58fd91d2d32fa64f2417a092c14ccb82" translate="yes" xml:space="preserve">
          <source>The format of the text file is as follows:</source>
          <target state="translated">文本文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="4333a537987dd2c37f631936cd505a940685024b" translate="yes" xml:space="preserve">
          <source>The format stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. To retrieve particular code representation from the backend, &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; must be invoked. &lt;code&gt;Format&lt;/code&gt; is an atom, such as &lt;code&gt;erlang_v1&lt;/code&gt; for the Erlang Abstract Format or &lt;code&gt;core_v1&lt;/code&gt; for Core Erlang. &lt;code&gt;Module&lt;/code&gt; is the module represented by the beam file and &lt;code&gt;Data&lt;/code&gt; is the value stored in the debug info chunk. &lt;code&gt;Opts&lt;/code&gt; is any list of values supported by the &lt;code&gt;Backend&lt;/code&gt;. &lt;code&gt;Backend:debug_info/4&lt;/code&gt; must return &lt;code&gt;{ok, Code}&lt;/code&gt; or &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;debug_info&lt;/code&gt; 块中的格式。要从后端检索特定的代码表示形式 &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; 必须调用Backend：debug_info（Format，Module，Data，Opts）。 &lt;code&gt;Format&lt;/code&gt; 是一个原子，如 &lt;code&gt;erlang_v1&lt;/code&gt; 为Erlang的摘要格式或 &lt;code&gt;core_v1&lt;/code&gt; 为核心的Erlang。 &lt;code&gt;Module&lt;/code&gt; 是由波束文件表示的模块， &lt;code&gt;Data&lt;/code&gt; 是存储在调试信息块中的值。 &lt;code&gt;Opts&lt;/code&gt; 是 &lt;code&gt;Backend&lt;/code&gt; 支持的任何值列表。 &lt;code&gt;Backend:debug_info/4&lt;/code&gt; 必须返回 &lt;code&gt;{ok, Code}&lt;/code&gt; 或 &lt;code&gt;{error, Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8e6ead11c3e1eac26901161b759833474cba3a4" translate="yes" xml:space="preserve">
          <source>The formatter information consist of a formatter module, &lt;code&gt;FModule&lt;/code&gt; and its configuration, &lt;code&gt;FConfig&lt;/code&gt;. &lt;code&gt;FModule&lt;/code&gt; must export the following function, which can be called by the handler:</source>
          <target state="translated">格式化程序信息包括一个格式化程序模块 &lt;code&gt;FModule&lt;/code&gt; 及其配置 &lt;code&gt;FConfig&lt;/code&gt; 。 &lt;code&gt;FModule&lt;/code&gt; 必须导出以下函数，该函数可以由处理程序调用：</target>
        </trans-unit>
        <trans-unit id="d115f8a8e36f58c079d74b58f98933595ecc3ef9" translate="yes" xml:space="preserve">
          <source>The formatter information for a handler is set as a part of its configuration when the handler is added. It can also be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt;, which overwrites the current formatter information, or with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, which only modifies the formatter configuration.</source>
          <target state="translated">添加处理程序时，处理程序的格式化程序信息将被设置为其配置的一部分。也可以在运行时使用 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt; （覆盖当前格式化程序信息）或使用 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; （仅修改格式化程序配置）进行更改。</target>
        </trans-unit>
        <trans-unit id="31df239ad5b8271efa81cda13e999773cde8976a" translate="yes" xml:space="preserve">
          <source>The formatter information is specified when adding the handler. The formatter configuration can be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, or the complete formatter information can be overwritten with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">格式化程序信息是在添加处理程序时指定的。可以在运行时使用 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 更改格式化程序配置，或者可以使用 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt; 覆盖完整的格式化程序信息。</target>
        </trans-unit>
        <trans-unit id="b8f30a9a1bf44181155aa2e71449137d3512f394" translate="yes" xml:space="preserve">
          <source>The formatting succeeded.</source>
          <target state="translated">格式化成功。</target>
        </trans-unit>
        <trans-unit id="10bd3287c5d5cb11c97ef91fb582e7bddc5c508a" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;code&gt;NULL&lt;/code&gt; is ignored. It was earlier used for the deprecated &lt;code&gt;reload&lt;/code&gt; callback which is no longer supported since OTP 20.</source>
          <target state="translated">第四个参数 &lt;code&gt;NULL&lt;/code&gt; 被忽略。它较早用于过时的 &lt;code&gt;reload&lt;/code&gt; 回调，自OTP 20起不再支持该回调。</target>
        </trans-unit>
        <trans-unit id="fd6d48968ca41cf916b0c1706ee59abd18b5be81" translate="yes" xml:space="preserve">
          <source>The fourth argument is a pointer to an &lt;code&gt;in_addr&lt;/code&gt; struct with the IP address of the host.</source>
          <target state="translated">第四个参数是指向具有主机IP地址的 &lt;code&gt;in_addr&lt;/code&gt; 结构的指针。</target>
        </trans-unit>
        <trans-unit id="e236ba0b32b561d73bf0d206f0aebabfe0c3ba82" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. For the available options, see &lt;code&gt;gen_statem:start_link/3&lt;/code&gt;.</source>
          <target state="translated">第四个参数 &lt;code&gt;[]&lt;/code&gt; 是选项列表。有关可用选项，请参见 &lt;code&gt;gen_statem:start_link/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ce7182b37b9940508d39bc849560d216ed57126" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. See the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page for available options.</source>
          <target state="translated">第四个参数 &lt;code&gt;[]&lt;/code&gt; 是选项列表。有关可用选项，请参见 &lt;code&gt;gen_server(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9100d905b13d1377220d70070d7d60982d6749a4" translate="yes" xml:space="preserve">
          <source>The framework consists of:</source>
          <target state="translated">该框架包括:</target>
        </trans-unit>
        <trans-unit id="1c8d31fc362ef9b832d0b697fa5e6ecb8f8d5cf1" translate="yes" xml:space="preserve">
          <source>The full log entry is composed according to the &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">完整的日志条目是根据 &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt; 组成的。</target>
        </trans-unit>
        <trans-unit id="700f5d03995315807276176315f6bb17647929bf" translate="yes" xml:space="preserve">
          <source>The full name for the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 的Solaris标准配置文件的全名</target>
        </trans-unit>
        <trans-unit id="0e81e9ea5253fb51f8c99babc5aff5902bbe7489" translate="yes" xml:space="preserve">
          <source>The full name of the binary executable file is derived from the position of application &lt;code&gt;os_mon&lt;/code&gt; in the file system by adding &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt;. The generic full name of the binary executable file is thus:</source>
          <target state="translated">通过添加 &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt; 从文件系统中应用程序 &lt;code&gt;os_mon&lt;/code&gt; 的位置派生二进制可执行文件的全名。因此，二进制可执行文件的通用全名是：</target>
        </trans-unit>
        <trans-unit id="563d73d181f3e9108cba87d81726b482ec3d260c" translate="yes" xml:space="preserve">
          <source>The full name of the minor log file (that is, the name of the file including the absolute directory path) can be read during execution of the test case. It comes as value in tuple &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list (which means it can also be read by a pre- or post &lt;code&gt;Common Test Hook&lt;/code&gt; function). Also, at the start of a test case, this data is sent with an event to any installed event handler. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">次要日志文件的全名（即包括绝对目录路径的文件名）可以在测试用例执行期间读取。它作为 &lt;code&gt;Config&lt;/code&gt; 列表 &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; 组{tc_logfile，LogFileName}中的值出现（这意味着它也可以由 &lt;code&gt;Common Test Hook&lt;/code&gt; 函数之前或之后读取）。同样，在测试用例开始时，此数据将与事件一起发送到任何已安装的事件处理程序。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="add619cb56fecf8eaa2173268a66512e2ca14e79" translate="yes" xml:space="preserve">
          <source>The full path to the &lt;code&gt;erlsrv.exe&lt;/code&gt;, which can be used to manipulate the service. This comes in handy when defining a heart command for your service.</source>
          <target state="translated">&lt;code&gt;erlsrv.exe&lt;/code&gt; 的完整路径，可用于处理服务。在为您的服务定义心脏命令时，这很方便。</target>
        </trans-unit>
        <trans-unit id="504f71220986791fe2ea8dea00b27516f0e65c24" translate="yes" xml:space="preserve">
          <source>The fun &lt;code&gt;F&lt;/code&gt; can be evaluated with the following syntax:</source>
          <target state="translated">可以使用以下语法评估乐趣 &lt;code&gt;F&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ae8ca975ecc3e8edf173345a968b651e47f611e5" translate="yes" xml:space="preserve">
          <source>The fun can have many clauses. Assume that we want to do the following:</source>
          <target state="translated">趣味可以有很多条款。假设我们想做以下事情。</target>
        </trans-unit>
        <trans-unit id="a7bc8a3f1e4f51084c68a1c0c777f1a27337cb3c" translate="yes" xml:space="preserve">
          <source>The fun has the following type specification:</source>
          <target state="translated">fun的类型规范如下。</target>
        </trans-unit>
        <trans-unit id="5f32b8a5a9bbfbf624a0644c5247fde5edb3a429" translate="yes" xml:space="preserve">
          <source>The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple. It must use the &lt;code&gt;is_&lt;/code&gt; guard tests. Language constructs that have no representation in a match specification (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt;, and so on) are not allowed.</source>
          <target state="translated">乐趣非常有限，它只能接受一个参数（要匹配的对象）：唯一变量或元组。它必须使用 &lt;code&gt;is_&lt;/code&gt; Guard测试。不允许在匹配规范中没有表示形式的语言构造（ &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;receive&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="71d9e7bf1fc41cd7eae3c3b2faa71bd3df3e1269" translate="yes" xml:space="preserve">
          <source>The fun must be defined as:</source>
          <target state="translated">趣必须定义为:</target>
        </trans-unit>
        <trans-unit id="07c9bc55442a1b08276f48311f68a88a3fb5ef18" translate="yes" xml:space="preserve">
          <source>The fun must be literally constructed inside the parameter list to the pseudo functions. The fun cannot be bound to a variable first and then passed to &lt;code&gt;ets:fun2ms/1&lt;/code&gt; or &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;. For example, &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; works, but not &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt;. The latter results in a compile-time error if the header is included, otherwise a runtime error.</source>
          <target state="translated">必须在伪函数的参数列表中按字面意义构造好玩的东西。乐趣不能先绑定到变量，然后再传 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 或 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 。例如， &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; 有效，但 &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt; 。如果包含标头，则后者会导致编译时错误，否则会导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="c2fc65e668d470b6dcc72f27bda164d6dff73c81" translate="yes" xml:space="preserve">
          <source>The fun must handle the following arguments:</source>
          <target state="translated">fun必须处理以下参数。</target>
        </trans-unit>
        <trans-unit id="737c0846a588f1657ff7845917aac0579f2be1af" translate="yes" xml:space="preserve">
          <source>The fun returns the root certificate and certificate chain that has signed the CRL.</source>
          <target state="translated">趣味返回已签署CRL的根证书和证书链。</target>
        </trans-unit>
        <trans-unit id="efd695af69ad480c89612803c86acd8baa7d18ec" translate="yes" xml:space="preserve">
          <source>The fun should return:</source>
          <target state="translated">乐趣应该回归。</target>
        </trans-unit>
        <trans-unit id="d737e56a33d9100f6b6abcd80be538364e25ad0c" translate="yes" xml:space="preserve">
          <source>The fun uses the information in the distribution point to access the latest possible version of the CRL. If this fun is not specified, Public Key uses the default implementation:</source>
          <target state="translated">该函数使用分发点的信息来访问CRL的最新版本。如果没有指定这个fun,公钥会使用默认的实现。</target>
        </trans-unit>
        <trans-unit id="7f1a8e313c80aee065197a6cfd60c195f83fb231" translate="yes" xml:space="preserve">
          <source>The funcion &lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; is performed as an atomic operation although it is not protected by a transaction. Therfore no table update is lost if two processes simultaneously execute the function &lt;code&gt;dirty_update_counter/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; 功能dirty_update_counter / 2作为原子操作执行，尽管它不受事务保护。如果两个进程同时执行功能 &lt;code&gt;dirty_update_counter/2&lt;/code&gt; ,则不会丢失任何表更新。</target>
        </trans-unit>
        <trans-unit id="e0013b0c35bbaebef0c54217eeb1d56ac822fe5f" translate="yes" xml:space="preserve">
          <source>The function 'undefined' that has called &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; is an unknown function because that call was not recorded in the trace. It was only recorded that the execution returned from &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; to some other function above in the call stack, or that the process exited from there.</source>
          <target state="translated">调用 &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 的函数&amp;ldquo;未定义&amp;rdquo; 是一个未知函数，因为该调用未记录在跟踪中。仅记录到执行从 &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 返回到调用堆栈中上面的某个其他函数，或者该进程从那里退出。</target>
        </trans-unit>
        <trans-unit id="ae773ba648b2dd3111bf9ff1bd1ae44f3998a92d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter requires to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 用于将直径 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 编译为Erlang源。结果源实现了对字典的消息和AVP进行编码和解码所需的接口直径。</target>
        </trans-unit>
        <trans-unit id="b1eeb1350e2bae25f92e23b1d2b563721196dfbc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; returns the tuple &lt;code&gt;{aborted,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is the tuple &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; 返回元组 &lt;code&gt;{aborted,Reason}&lt;/code&gt; ，其中 &lt;code&gt;Reason&lt;/code&gt; 是元组 &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab82066f7afa34b039ac973980ff4ef53ba41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; returns the term &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt;, which is an error description suitable for display.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; 返回术语 &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt; ，这是适合显示的错误描述。</target>
        </trans-unit>
        <trans-unit id="416085a9cc04b82b99ed7eea9c9814ce71342d35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; can be used to retrieve the result of the latest periodic memory check.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; 可用于检索最新定期内存检查的结果。</target>
        </trans-unit>
        <trans-unit id="d90d9bd2e78e7f66c786fdc154ab3630fd58d990" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; and the constructor functions &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case.</source>
          <target state="translated">如果要遍历语法树，访问其所有子树，但在大多数情况下以统一的方式对待树的节点，则 &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; 函数和构造函数 &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; 可以提供很大的帮助。使用这些函数使此操作变得简单，并且还可以确保您的代码对语法树数据类型的扩展不会过于敏感，因为任何未由代码明确处理的节点类型都可以保留为默认情况。</target>
        </trans-unit>
        <trans-unit id="4b9d557c07ad7843b1aa33917e03437c2191df84" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; returns one of the following values:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; 返回以下值之一：</target>
        </trans-unit>
        <trans-unit id="7829e947c9fda3671f982c368ab35a66949366af" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; returns all keys in a table.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; 返回表中的所有键。</target>
        </trans-unit>
        <trans-unit id="29d2bb31f2eb0b09a4594530fbd096f08be20052" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; activates a new checkpoint that covers all &lt;code&gt;Mnesia&lt;/code&gt; tables with maximum degree of redundancy and performs a backup. Maximum redundancy means that each table replica has a checkpoint retainer. Tables with property &lt;code&gt;local_contents&lt;/code&gt; are backed up as they look on the current node.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; 激活一个新的检查点，该检查点以最大程度的冗余度覆盖所有 &lt;code&gt;Mnesia&lt;/code&gt; 表并执行备份。最大冗余意味着每个表副本都有一个检查点保留器。在 &lt;code&gt;local_contents&lt;/code&gt; 节点上查找具有local_contents属性的表时，将对其进行备份。</target>
        </trans-unit>
        <trans-unit id="36376c0ad23644747aaadff922c6c829e1451912" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. When executing this function, it returns one of the following responses:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 创建表。执行此函数时，它将返回以下响应之一：</target>
        </trans-unit>
        <trans-unit id="a1a6864b3dbbae165f2d507c1a853d0af094ec0c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; creates a brand new fragmented table, by setting table property &lt;code&gt;frag_properties&lt;/code&gt; to some proper values.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 通过将表属性 &lt;code&gt;frag_properties&lt;/code&gt; 设置为一些适当的值来创建一个全新的碎片表。</target>
        </trans-unit>
        <trans-unit id="fd24999a16cc29e37c736949b94f5785cba2b786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; deletes a fragmented table including all its fragments. There must however not exist any other fragmented tables that refer to this table in their foreign key.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; 删除包含所有碎片的碎片表。但是，不得存在在其外键中引用该表的任何其他碎片表。</target>
        </trans-unit>
        <trans-unit id="30691173c7709ef9a4f3af204d9b1fcd4e7de68a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; can be used to dump RAM table replicas to disc.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; 可用于将RAM表副本转储到磁盘。</target>
        </trans-unit>
        <trans-unit id="9bca628c2f6585264d68c5ff447dbb6e315d490b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to force load the table regardless of which table load mechanism that is activated.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 可用于强制加载表，而不管激活了哪种表加载机制。</target>
        </trans-unit>
        <trans-unit id="4da340c660c7601de0e1ab6532b1b4defd72ac7f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; can now be used to print some system information even before &lt;code&gt;Mnesia&lt;/code&gt; is started. When &lt;code&gt;Mnesia&lt;/code&gt; is started, the function prints more information.</source>
          <target state="translated">现在，即使在启动 &lt;code&gt;Mnesia&lt;/code&gt; 之前，功能 &lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; 也可以用于打印一些系统信息。当 &lt;code&gt;Mnesia&lt;/code&gt; 的启动后，打印功能的更多信息。</target>
        </trans-unit>
        <trans-unit id="60a3e9499c0d1ca23244a4d32bf0a317d6112fb3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; installs a backup as fallback. It uses the backup module &lt;code&gt;Mod&lt;/code&gt;, or the default backup module, to access the backup media. The function returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, Reason}&lt;/code&gt; if there is an error.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; 将备份安装为后备。它使用备份模块 &lt;code&gt;Mod&lt;/code&gt; 或默认备份模块来访问备份媒体。如果成功，该函数将返回 &lt;code&gt;ok&lt;/code&gt; ，如果存在 &lt;code&gt;{error, Reason}&lt;/code&gt; 则返回{error，Reason}。</target>
        </trans-unit>
        <trans-unit id="4f2ed7053b64d799ffc3ded34968b7ea59f0d544" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; is intended to support table locks (as mentioned previously) but also for situations when locks need to be acquired regardless of how tables have been replicated:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; 旨在支持表锁（如前所述），但也适用于无论表如何被复制都需要获取锁的情况：</target>
        </trans-unit>
        <trans-unit id="a04c9c87e126ea98a8324770baffee72b7c15012" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; lacks some important features that &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; have. For example, &lt;code&gt;mnesia:match_object/3&lt;/code&gt; can only return the matching records, and it cannot express constraints other than equality. To find the names of the male employees on the second floor:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 缺少 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; 具有的一些重要功能。例如， &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 只能返回匹配的记录，并且不能表达除相等以外的约束。要在二楼找到男性雇员的姓名：</target>
        </trans-unit>
        <trans-unit id="0917cc1d0fa48c8f542630d30c1cd7b2345a64a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; sets master nodes for all tables. For each table it determines its replica nodes and starts &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; with those replica nodes that are included in the &lt;code&gt;Nodes&lt;/code&gt; list (that is, &lt;code&gt;TabNodes&lt;/code&gt; is the intersection of &lt;code&gt;Nodes&lt;/code&gt; and the replica nodes of the table). If the intersection is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; 设置所有表的主节点。对于每个表，它确定其副本节点，并使用&amp;ldquo; &lt;code&gt;Nodes&lt;/code&gt; 列表中包含的那些副本节点（即， &lt;code&gt;TabNodes&lt;/code&gt; 是 &lt;code&gt;Nodes&lt;/code&gt; 与表的副本节点的交集 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; 开始mnesia：set_master_nodes（Tab，TabNodes）。如果交集为空，则将重置特定表的主节点恢复机制，并在下次重新启动时使用常规加载机制。</target>
        </trans-unit>
        <trans-unit id="3124976c6cc4afa58829120e681ccee3319f8f32" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes.</source>
          <target state="translated">在两个节点上都调用了函数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="362b910adc258b676d8a22204af77b93afeab4c8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; stops &lt;code&gt;Mnesia&lt;/code&gt; on the node where the function is executed. The functions &lt;code&gt;mnesia:start/0&lt;/code&gt; and &lt;code&gt;mnesia:stop/0&lt;/code&gt; work on the &quot;local&quot; &lt;code&gt;Mnesia&lt;/code&gt; system. No functions start or stop a set of nodes.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; 在执行该函数的节点上停止 &lt;code&gt;Mnesia&lt;/code&gt; 。函数 &lt;code&gt;mnesia:start/0&lt;/code&gt; 和 &lt;code&gt;mnesia:stop/0&lt;/code&gt; 在&amp;ldquo;本地&amp;rdquo; &lt;code&gt;Mnesia&lt;/code&gt; 系统上运行。没有功能可以启动或停止一组节点。</target>
        </trans-unit>
        <trans-unit id="5acaf5a283731e99e901e6928e2526a7dcf95f24" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; now understands item &lt;code&gt;frag_properties&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; 现在可以理解项目 &lt;code&gt;frag_properties&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1334bf42da6253566700391caa3cba76ccf9209" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Callback:read_config/1&lt;/code&gt; is to be exported from the callback module to read configuration data, initially before the tests start, or as a result of data being reloaded during test execution. The input argument is the same as for function &lt;code&gt;check_parameter/1&lt;/code&gt;.</source>
          <target state="translated">最初从测试开始之前，或者由于在测试执行期间重新加载数据，将从回调模块导出函数 &lt;code&gt;Callback:read_config/1&lt;/code&gt; 以读取配置数据。输入参数与函数 &lt;code&gt;check_parameter/1&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="7fbf758a3229cc65bafd27a8b6bc7ae6dded54d7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">调用函数 &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; 以生成测试集。</target>
        </trans-unit>
        <trans-unit id="41ef4085ec8a8d22de70a87050ca088731db21f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;check_process_code/3&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt;.</source>
          <target state="translated">发送请求后，函数 &lt;code&gt;check_process_code/3&lt;/code&gt; 立即返回 &lt;code&gt;async&lt;/code&gt; 值。处理完请求后，调用此函数的进程 &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt; 的形式传递消息。</target>
        </trans-unit>
        <trans-unit id="2f6002fc8f958da3877d27d37d914957a73927e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;company:init/0&lt;/code&gt; creates the tables. Two tables are of type &lt;code&gt;bag&lt;/code&gt;. This is the &lt;code&gt;manager&lt;/code&gt; relation as well the &lt;code&gt;in_proj&lt;/code&gt; relation. This is interpreted as: an employee can be manager over several departments, and an employee can participate in several projects. However, the &lt;code&gt;at_dep&lt;/code&gt; relation is &lt;code&gt;set&lt;/code&gt;, as an employee can only work in one department. In this data model, there are examples of relations that are 1-to-1 (&lt;code&gt;set&lt;/code&gt;) and 1-to-many (&lt;code&gt;bag&lt;/code&gt;).</source>
          <target state="translated">函数 &lt;code&gt;company:init/0&lt;/code&gt; 创建表。两张桌子是 &lt;code&gt;bag&lt;/code&gt; 类型。这是 &lt;code&gt;manager&lt;/code&gt; 关系，也是 &lt;code&gt;in_proj&lt;/code&gt; 关系。这可以解释为：一个雇员可以是多个部门的经理，一个雇员可以参与多个项目。但是， &lt;code&gt;set&lt;/code&gt; 了 &lt;code&gt;at_dep&lt;/code&gt; 关系，因为员工只能在一个部门工作。在此数据模型中，有一些示例是一对一（ &lt;code&gt;set&lt;/code&gt; ）和一对多（ &lt;code&gt;bag&lt;/code&gt; ）关系。</target>
        </trans-unit>
        <trans-unit id="e1b3a72aa7ba46bfc3b05ebd94c234d7bb780fb0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;erl_decode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; converts the binary into an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">功能 &lt;code&gt;erl_decode()&lt;/code&gt; 从 &lt;code&gt;erl_marshal&lt;/code&gt; 转换二进制成 &lt;code&gt;ETERM&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="c72f7b6a5b6f347ed0767231df7d01b1b2dde191" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform any necessary clean-up.</source>
          <target state="translated">从代理卸载MIB时 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; MIB中的每个对象调用函数f（delete [，ExtraArgs]）。这使得可以执行任何必要的清理。</target>
        </trans-unit>
        <trans-unit id="af08e789dab44b8458cb66f5d674a989015f5322" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform necessary clean-up.</source>
          <target state="translated">从代理卸载MIB时 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; MIB中的每个对象调用函数f（delete [，ExtraArgs]）。这使得可以执行必要的清理。</target>
        </trans-unit>
        <trans-unit id="6c5b6c8f67651723c9f3e56c22f4f4ab0b1c577a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; is called when a get-request or a get-next request refers to the variable.</source>
          <target state="translated">当get-request或get-next请求引用该变量时 &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; 将调用函数f（get [，ExtraArgs]）。</target>
        </trans-unit>
        <trans-unit id="7f44a9f942983582de9a504377c1237da5bfe42a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-request refers to a table.</source>
          <target state="translated">当get-request引用表时 &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 将调用函数f（get，RowIndex，Cols [，ExtraArgs]）。</target>
        </trans-unit>
        <trans-unit id="f9472e8e9d7e877a982c1ad293026a6058a914d6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-next- or a get-bulk-request refers to the table.</source>
          <target state="translated">当get-next-或get-bulk-request引用表时 &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 将调用函数f（get_next，RowIndex，Cols [，ExtraArgs]）。</target>
        </trans-unit>
        <trans-unit id="dc9c0fe89d1c4041733fa53cdcec2b986419a3b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that the new value can be checked for inconsistencies.</source>
          <target state="translated">在设置请求处理的第一阶段调用函数 &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; ，以便可以检查新值是否存在不一致。</target>
        </trans-unit>
        <trans-unit id="4d16c30ff848f270285384e5cc25e325a037b629" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that new values can be checked for inconsistencies.</source>
          <target state="translated">在设置请求处理的第一阶段调用函数 &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; ，以便可以检查新值是否存在不一致。</target>
        </trans-unit>
        <trans-unit id="ff5330b2475c665d4944e0a229f93d0602e0e5fa" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is loaded into the agent. This makes it possible to perform the necessary initialization.</source>
          <target state="translated">当MIB加载到代理中时 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; MIB中的每个对象调用函数f（new [，ExtraArgs]）。这使得可以执行必要的初始化。</target>
        </trans-unit>
        <trans-unit id="0d1ebb83f7fcf0843f0835365552c7f4c0cad7ca" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each variable in the MIB when the MIB is loaded into the agent. This makes it possible to perform necessary initialization.</source>
          <target state="translated">当MIB加载到代理中时 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; MIB中的每个变量调用函数f（new [，ExtraArgs]）。这使得可以执行必要的初始化。</target>
        </trans-unit>
        <trans-unit id="133213fffa730c11eb89996e85007a915e9f1756" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function did not exist, or returned &lt;code&gt;{noError, 0}&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 在设置请求处理的第二阶段执行设置。仅在相应的 &lt;code&gt;is_set_ok&lt;/code&gt; 函数不存在或未返回 &lt;code&gt;{noError, 0}&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="beb994d1c8d031347e7906599f79761b788164a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;find_max_and_min&lt;/code&gt; works out the maximum and minimum temperature. A new construct, &lt;code&gt;if&lt;/code&gt;, is introduced here. If works as follows:</source>
          <target state="translated">函数 &lt;code&gt;find_max_and_min&lt;/code&gt; 计算出最高和最低温度。这里引入了一个新的结构 &lt;code&gt;if&lt;/code&gt; 。如果工作如下：</target>
        </trans-unit>
        <trans-unit id="e3c365109eb0604df295111a6b478883a0063173" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foreach&lt;/code&gt; expresses this similarity:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 函数表达了这种相似性：</target>
        </trans-unit>
        <trans-unit id="32b248029fdb79694c3f91257a1b49d6e08c1720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format/2&lt;/code&gt; (that is, &lt;code&gt;format&lt;/code&gt; with two arguments) takes two lists. The first one is nearly always a list written between &quot; &quot;. This list is printed out as it is, except that each ~w is replaced by a term taken in order from the second list. Each ~n is replaced by a new line. The &lt;code&gt;io:format/2&lt;/code&gt; function itself returns the atom &lt;code&gt;ok&lt;/code&gt; if everything goes as planned. Like other functions in Erlang, it crashes if an error occurs. This is not a fault in Erlang, it is a deliberate policy. Erlang has sophisticated mechanisms to handle errors which are shown later. As an exercise, try to make &lt;code&gt;io:format&lt;/code&gt; crash, it should not be difficult. But notice that although &lt;code&gt;io:format&lt;/code&gt; crashes, the Erlang shell itself does not crash.</source>
          <target state="translated">函数 &lt;code&gt;format/2&lt;/code&gt; （即具有两个参数的 &lt;code&gt;format&lt;/code&gt; ）具有两个列表。第一个几乎总是在&amp;ldquo;&amp;rdquo;之间编写的列表。此列表按原样打印，只是每个〜w替换为从第二个列表中按顺序获取的术语。每个〜n都用换行替换。该 &lt;code&gt;io:format/2&lt;/code&gt; 函数本身返回原子 &lt;code&gt;ok&lt;/code&gt; 了，如果一切按计划进行。像Erlang中的其他函数一样，如果发生错误，它会崩溃。这不是Erlang的错，这是有计划的政策。 Erlang具有复杂的机制来处理错误，稍后将对此进行介绍。作为练习，尝试使 &lt;code&gt;io:format&lt;/code&gt; 崩溃，这并不难。但是请注意，尽管 &lt;code&gt;io:format&lt;/code&gt; 崩溃，Erlang外壳本身不会崩溃。</target>
        </trans-unit>
        <trans-unit id="3aac06ca8d394b3646df1b427f505d8cf51b76fc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/1&lt;/code&gt; is deprecated and will be removed in next version.</source>
          <target state="translated">不建议使用功能 &lt;code&gt;g/1&lt;/code&gt; ，并将在下一版本中将其删除。</target>
        </trans-unit>
        <trans-unit id="88abc7d88e609edf90b5266ee54f52aa2a6dcc51" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/2&lt;/code&gt; is deprecated and will be removed in next major release.</source>
          <target state="translated">不建议使用功能 &lt;code&gt;g/2&lt;/code&gt; ，并将在下一个主要版本中将其删除。</target>
        </trans-unit>
        <trans-unit id="81d897d03e553a2581073072bbd55d8966c2a444" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/3&lt;/code&gt; is deprecated and will eventually be removed.</source>
          <target state="translated">不推荐使用功能 &lt;code&gt;g/3&lt;/code&gt; ，最终将其删除。</target>
        </trans-unit>
        <trans-unit id="dd9a50875733e809d1405bf85bfdecd386ca67c2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;garbage_collect/2&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt;.</source>
          <target state="translated">发送请求后，函数 &lt;code&gt;garbage_collect/2&lt;/code&gt; 将立即返回 &lt;code&gt;async&lt;/code&gt; 值。处理完请求后，调用此函数的进程 &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt; 的形式传递消息。</target>
        </trans-unit>
        <trans-unit id="fd04d9687a79d761d32b2c43de1576259fb5f864" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert_emp/3&lt;/code&gt; creates a Functional Object (Fun). &lt;code&gt;Fun&lt;/code&gt; is passed as a single argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt;. This means that &lt;code&gt;Fun&lt;/code&gt; is run as a transaction with the following properties:</source>
          <target state="translated">函数 &lt;code&gt;insert_emp/3&lt;/code&gt; 创建一个功能对象（Fun）。 &lt;code&gt;Fun&lt;/code&gt; 作为单个参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt; 。这意味着 &lt;code&gt;Fun&lt;/code&gt; 作为具有以下属性的事务运行：</target>
        </trans-unit>
        <trans-unit id="ea55fdab4365faa7f773834a49baba846da23b95" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; is intended to be used for reconfiguration of fragmented tables. Argument &lt;code&gt;Change&lt;/code&gt; is to have one of the following values:</source>
          <target state="translated">函数 &lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; 用于重新配置碎片表。参数 &lt;code&gt;Change&lt;/code&gt; 将具有以下值之一：</target>
        </trans-unit>
        <trans-unit id="b1c90e4ee481c7da73002efc510d14130a3a01a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:dirty_*&lt;/code&gt; always executes with &lt;code&gt;async_dirty&lt;/code&gt; semantics regardless of which activity access contexts that are started. It can even start contexts without any enclosing activity access context.</source>
          <target state="translated">无论启动了哪个活动访问上下文，函数 &lt;code&gt;mnesia:dirty_*&lt;/code&gt; 始终以 &lt;code&gt;async_dirty&lt;/code&gt; 语义执行。它甚至可以启动上下文，而无需任何封闭的活动访问上下文。</target>
        </trans-unit>
        <trans-unit id="670d344917e31e9f9f7bd59eee0e7cb0d02a6cdf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:lock/2&lt;/code&gt; is intended to support explicit locking on tables, but is also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two kinds of &lt;code&gt;LockKind&lt;/code&gt; are supported:</source>
          <target state="translated">函数 &lt;code&gt;mnesia:lock/2&lt;/code&gt; 用于支持对表的显式锁定，但也适用于无论如何复制表都需要获取锁的情况。当前，支持两种 &lt;code&gt;LockKind&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d77603a1f02efb7a0e1f99f991914c28109971d3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:match_object/3&lt;/code&gt; automatically uses indexes if these exist. However, no heuristics are performed to select the best index.</source>
          <target state="translated">如果存在索引，函数 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 自动使用索引。但是，没有执行试探法来选择最佳索引。</target>
        </trans-unit>
        <trans-unit id="6edabfd9b5590580f8f9657171a96caa4b74ebe3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;new/4&lt;/code&gt; creates a new map term and lets the keys &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, and &lt;code&gt;alpha&lt;/code&gt; be associated with an initial value. In this case, only float values between and including 0.0 and 1.0 are allowed, as ensured by the &lt;code&gt;?is_channel/1&lt;/code&gt; macro for each argument. Only the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is allowed when creating a new map.</source>
          <target state="translated">函数 &lt;code&gt;new/4&lt;/code&gt; 创建一个新的映射项，并使键 &lt;code&gt;red&lt;/code&gt; ， &lt;code&gt;green&lt;/code&gt; ， &lt;code&gt;blue&lt;/code&gt; 和 &lt;code&gt;alpha&lt;/code&gt; 与初始值相关联。在这种情况下，如每个参数的 &lt;code&gt;?is_channel/1&lt;/code&gt; 宏所保证的，仅允许介于0.0到1.0之间的浮点值。创建新地图时仅允许 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="34e4f0d7c8457880dafad073945fded626331720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pyth(N)&lt;/code&gt; generates a list of all integers &lt;code&gt;{A,B,C}&lt;/code&gt; such that &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; and where the sum of the sides is equal to, or less than, &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">函数 &lt;code&gt;pyth(N)&lt;/code&gt; 生成所有整数 &lt;code&gt;{A,B,C}&lt;/code&gt; 的列表，使得 &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; 且边的总和等于或小于 &lt;code&gt;N&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6137179b93256e30bc3aeec2790f9eeac4bbcd5d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise/2&lt;/code&gt; contains a Fun made up of four code lines. This Fun is called by the statement &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; and returns a value.</source>
          <target state="translated">函数 &lt;code&gt;raise/2&lt;/code&gt; 包含一个由四行代码组成的Fun。此Fun由语句 &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; 调用，并返回一个值。</target>
        </trans-unit>
        <trans-unit id="99cf9b671e2d9b419e9dca0fedf06d36961f6433" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise_females/1&lt;/code&gt; returns the tuple &lt;code&gt;{atomic, Number}&lt;/code&gt;, where &lt;code&gt;Number&lt;/code&gt; is the number of female employees who received a salary increase. If an error occurs, the value &lt;code&gt;{aborted, Reason}&lt;/code&gt; is returned, and &lt;code&gt;Mnesia&lt;/code&gt; guarantees that the salary is not raised for any employee.</source>
          <target state="translated">函数 &lt;code&gt;raise_females/1&lt;/code&gt; 返回元组 &lt;code&gt;{atomic, Number}&lt;/code&gt; ，其中 &lt;code&gt;Number&lt;/code&gt; 是获得加薪的女性雇员人数。如果发生错误，则返回 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 值， &lt;code&gt;Mnesia&lt;/code&gt; 保证不会为任何员工加薪。</target>
        </trans-unit>
        <trans-unit id="a03f0af918ed9a2c831249c7c193fd4857632c71" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;select&lt;/code&gt; can be used to add more constraints and create output that cannot be done with &lt;code&gt;mnesia:match_object/3&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;select&lt;/code&gt; 可以用于添加更多约束并创建 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 无法完成的输出。</target>
        </trans-unit>
        <trans-unit id="9a509a3ad87b3c1678e41395b1c17d5a940026b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_message/3&lt;/code&gt; will only be called if the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option has been set to the value &lt;code&gt;flag&lt;/code&gt;. The third argument, &lt;code&gt;Resend&lt;/code&gt; then indicates if the message send is a resend or not.</source>
          <target state="translated">仅当将 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config选项设置为value &lt;code&gt;flag&lt;/code&gt; 才会调用 &lt;code&gt;send_message/3&lt;/code&gt; 函数。然后，第三个参数 &lt;code&gt;Resend&lt;/code&gt; 指示发送的消息是否为重新发送。</target>
        </trans-unit>
        <trans-unit id="7470406d16d9455cca5984d08f7d4c3396313445" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_trap&lt;/code&gt; is kept for backwards compatibility and should not be used in new code. Applications that use this function will continue to work. The &lt;code&gt;snmpNotifyName&lt;/code&gt; is used as the community string by the agent when a notification is sent.</source>
          <target state="translated">保留 &lt;code&gt;send_trap&lt;/code&gt; 函数是为了向后兼容，因此不应在新代码中使用。使用此功能的应用程序将继续运行。该 &lt;code&gt;snmpNotifyName&lt;/code&gt; 当发送的通知作为由代理的团体字符串。</target>
        </trans-unit>
        <trans-unit id="103c9badd4ad12f4e6468c8e8de6801ce063239b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;start&lt;/code&gt; first creates a process, let us call it &quot;pong&quot;:</source>
          <target state="translated">该功能 &lt;code&gt;start&lt;/code&gt; 首先创建一个过程，我们称之为&amp;ldquo;傍&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="eb32c2f2d1549c3a5030e2171eab2d919298928c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;subsystem/4&lt;/code&gt; and subsequent calls of &lt;code&gt;send/3,4,5&lt;/code&gt; must be executed in the same process.</source>
          <target state="translated">必须在同一过程中执行功能 &lt;code&gt;subsystem/4&lt;/code&gt; 和随后的 &lt;code&gt;send/3,4,5&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="338ff9986a9cbcb124e3833af89e3fbd5600e24b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:create/1&lt;/code&gt; performs the following:</source>
          <target state="translated">函数 &lt;code&gt;target_system:create/1&lt;/code&gt; 执行以下操作：</target>
        </trans-unit>
        <trans-unit id="0cd28e869f41fdc007104b6030c49cc7a75a7292" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:install/2&lt;/code&gt; performs the following:</source>
          <target state="translated">函数 &lt;code&gt;target_system:install/2&lt;/code&gt; 执行以下操作：</target>
        </trans-unit>
        <trans-unit id="4199649f879206d3b2fa3c3bd5824df5cda6d3e9" translate="yes" xml:space="preserve">
          <source>The function accepts the following parameters:</source>
          <target state="translated">该函数接受以下参数:</target>
        </trans-unit>
        <trans-unit id="094a87c2e8a4a6a2a6be76b4ad60bd189810ef39" translate="yes" xml:space="preserve">
          <source>The function arguments are as follows:</source>
          <target state="translated">该函数的参数如下:</target>
        </trans-unit>
        <trans-unit id="f8347209966cf7f71c1646053d74ccb363214ea1" translate="yes" xml:space="preserve">
          <source>The function arguments passed to a NIF appears in an array &lt;code&gt;argv&lt;/code&gt;, with &lt;code&gt;argc&lt;/code&gt; as the length of the array, and thus the arity of the function. The Nth argument of the function can be accessed as &lt;code&gt;argv[N-1]&lt;/code&gt;. NIFs also take an environment argument that serves as an opaque handle that is needed to be passed on to most API functions. The environment contains information about the calling Erlang process:</source>
          <target state="translated">传递给NIF的函数参数出现在数组 &lt;code&gt;argv&lt;/code&gt; 中，其中 &lt;code&gt;argc&lt;/code&gt; 作为数组的长度，因此函数的有效性。该函数的第N个参数可以作为 &lt;code&gt;argv[N-1]&lt;/code&gt; 。NIF还接受一个环境参数，该参数用作传递给大多数API函数的不透明句柄。该环境包含有关调用Erlang进程的信息：</target>
        </trans-unit>
        <trans-unit id="fa68aed990974c1565915491205a9e47d95de75c" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; deletes node &lt;code&gt;mynode@host&lt;/code&gt; from the &lt;code&gt;Mnesia&lt;/code&gt; system. The call fails if &lt;code&gt;Mnesia&lt;/code&gt; is running on &lt;code&gt;mynode@host&lt;/code&gt;. The other &lt;code&gt;Mnesia&lt;/code&gt; nodes never try to connect to that node again. Notice that if there is a disc resident schema on node &lt;code&gt;mynode@host&lt;/code&gt;, the entire &lt;code&gt;Mnesia&lt;/code&gt; directory is to be deleted. This is done with the function &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Mnesia&lt;/code&gt; is started again on node &lt;code&gt;mynode@host&lt;/code&gt; and the directory has not been cleared, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is undefined.</source>
          <target state="translated">函数调用 &lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; 从 &lt;code&gt;Mnesia&lt;/code&gt; 系统中删除节点 &lt;code&gt;mynode@host&lt;/code&gt; 。如果 &lt;code&gt;Mnesia&lt;/code&gt; 在 &lt;code&gt;mynode@host&lt;/code&gt; 上运行，则调用失败。其他 &lt;code&gt;Mnesia&lt;/code&gt; 节点再也不会尝试连接到该节点。请注意，如果节点 &lt;code&gt;mynode@host&lt;/code&gt; 上有光盘驻留模式，则将删除整个 &lt;code&gt;Mnesia&lt;/code&gt; 目录。这可以通过功能 &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt; 完成。如果 &lt;code&gt;Mnesia&lt;/code&gt; 在节点 &lt;code&gt;mynode@host&lt;/code&gt; 上再次启动，并且尚未清除目录，则 &lt;code&gt;Mnesia&lt;/code&gt; 的行为未定义。</target>
        </trans-unit>
        <trans-unit id="dc50b6ebf32dde9a3ad360a39afe42dd265bea37" translate="yes" xml:space="preserve">
          <source>The function can also return &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">该函数还可以返回 &lt;code&gt;ignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54500a01f09be1a2bd2f0c1abfeddba6e33a00fa" translate="yes" xml:space="preserve">
          <source>The function can be called by a log handler to convert a log event term to a printable string. The returned value can, for example, be printed as a log entry to the console or a file using &lt;code&gt;io:put_chars/1,2&lt;/code&gt;.</source>
          <target state="translated">日志处理程序可以调用该函数，以将日志事件项转换为可打印的字符串。例如，可以使用 &lt;code&gt;io:put_chars/1,2&lt;/code&gt; 将返回的值打印为控制台的日志条目或文件。</target>
        </trans-unit>
        <trans-unit id="c504308064f08c5f9ea9e812d1f6e5a760e998d0" translate="yes" xml:space="preserve">
          <source>The function can be called, for example, when these files are generated at the target. The function is to be called after &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; has been called.</source>
          <target state="translated">例如，在目标上生成这些文件时，可以调用该函数。将在调用 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 之后调用该函数。</target>
        </trans-unit>
        <trans-unit id="dfcfdf84d3a74a872f6ce266bc40953da7783b4c" translate="yes" xml:space="preserve">
          <source>The function can be used as follows:</source>
          <target state="translated">该功能的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="18f3fe03e8503c073eac107ed5ad24dbaeb411a0" translate="yes" xml:space="preserve">
          <source>The function can be used on a running system, or by copying the entire log directory and calling this function. SNMP must be running in order to provide MIB information.</source>
          <target state="translated">该函数可以在运行中的系统上使用,也可以通过复制整个日志目录并调用该函数。为了提供MIB信息,必须运行SNMP。</target>
        </trans-unit>
        <trans-unit id="b8fb21fb19b96fc3f558cb35f3055df39d441e2b" translate="yes" xml:space="preserve">
          <source>The function can be used on files opened in &lt;code&gt;raw&lt;/code&gt; mode. However, it is inefficient to use it on &lt;code&gt;raw&lt;/code&gt; files if the file is not opened with option &lt;code&gt;{read_ahead, Size}&lt;/code&gt; specified. Thus, combining &lt;code&gt;raw&lt;/code&gt; and &lt;code&gt;{read_ahead, Size}&lt;/code&gt; is highly recommended when opening a text file for raw line-oriented reading.</source>
          <target state="translated">该功能可用于以 &lt;code&gt;raw&lt;/code&gt; 模式打开的文件。但是，如果未在指定选项 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 打开文件，则无法在 &lt;code&gt;raw&lt;/code&gt; 文件上使用它。因此，在打开文本文件以进行面向行的原始阅读时 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 强烈建议将 &lt;code&gt;raw&lt;/code&gt; 和{read_ahead，Size}结合使用。</target>
        </trans-unit>
        <trans-unit id="8a30119da22bc70b60e3eb0a2546500296120c22" translate="yes" xml:space="preserve">
          <source>The function can return any term. If the event handler is deleted because of a call to &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt;, the return value of that function becomes the return value of this function. If the event handler is to be replaced with another event handler because of a swap, the return value is passed to the &lt;code&gt;init&lt;/code&gt; function of the new event handler. Otherwise the return value is ignored.</source>
          <target state="translated">该函数可以返回任何项。如果由于调用 &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt; 而删除了事件处理程序，则该函数的返回值将成为该函数的返回值。如果由于交换而要用另一个事件处理程序替换事件处理程序，则将返回值传递给新事件处理程序的 &lt;code&gt;init&lt;/code&gt; 函数。否则，返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="ed95f32e82d2850058944611e44392a4e4ff3345" translate="yes" xml:space="preserve">
          <source>The function can return numerous errors, some can only be returned given a certain combination of options.</source>
          <target state="translated">该函数可以返回许多错误,有些错误只能给定一定的选项组合才能返回。</target>
        </trans-unit>
        <trans-unit id="ea57ec1a4ff4fb3ef55b1134a75586251178e601" translate="yes" xml:space="preserve">
          <source>The function can return the following error conditions, all well specified (no opaque values):</source>
          <target state="translated">该函数可以返回以下错误条件,都是指定好的(没有不透明的值)。</target>
        </trans-unit>
        <trans-unit id="c5c489b2375429e225473997aebd4b0f058730b3" translate="yes" xml:space="preserve">
          <source>The function cannot be found when evaluating a function call.</source>
          <target state="translated">在评估函数调用时,找不到该函数。</target>
        </trans-unit>
        <trans-unit id="900b2cc1343be73658d225cf863655824f14c352" translate="yes" xml:space="preserve">
          <source>The function check provides an error tuple if Unicode code points &amp;gt; 255 are to be returned if the client requested &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">如果客户端请求了 &lt;code&gt;latin1&lt;/code&gt; ,则如果要返回Unicode代码点&amp;gt; 255，则函数检查将提供一个错误元组。</target>
        </trans-unit>
        <trans-unit id="d2f0030f1dc39e1c15798593d550e2c64df3c720" translate="yes" xml:space="preserve">
          <source>The function creates a copy of &lt;code&gt;channel.erl&lt;/code&gt; where it for each executable line is specified how many times that line has been executed. The output file is called &lt;code&gt;channel.COVER.out&lt;/code&gt;.</source>
          <target state="translated">该函数创建 &lt;code&gt;channel.erl&lt;/code&gt; 的副本，在其中为每个可执行行指定执行该行的次数。输出文件称为 &lt;code&gt;channel.COVER.out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4bf61d20b6e51c3f3e2be4195443a2547ef5d88" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang list object, whose length &lt;code&gt;arrsize&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">该函数创建一个Erlang列表对象，其长度为 &lt;code&gt;arrsize&lt;/code&gt; ，其元素取自 &lt;code&gt;array&lt;/code&gt; 中的术语。</target>
        </trans-unit>
        <trans-unit id="e824f3f61fcb9a0cc2524376c6e7e48b567c62f2" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang tuple, whose arity is &lt;code&gt;size&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">该函数创建一个Erlang元组，其Arity为 &lt;code&gt;size&lt;/code&gt; ，其元素来自 &lt;code&gt;array&lt;/code&gt; 中的术语。</target>
        </trans-unit>
        <trans-unit id="a0c7fe697609b06db41d8d42bbc188f96462c7d5" translate="yes" xml:space="preserve">
          <source>The function descriptions are sorted in alphabetical order. It is recommended to start to read about &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, &lt;code&gt;mnesia:lock/2&lt;/code&gt;, and &lt;code&gt;mnesia:activity/4&lt;/code&gt; before you continue and learn about the rest.</source>
          <target state="translated">功能描述按字母顺序排序。建议您先阅读 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; ， &lt;code&gt;mnesia:lock/2&lt;/code&gt; 和 &lt;code&gt;mnesia:activity/4&lt;/code&gt; ,然后再继续学习其余内容。</target>
        </trans-unit>
        <trans-unit id="a4a4d3bf61b03f1db00124a05a395c3a8430b995" translate="yes" xml:space="preserve">
          <source>The function does not return until the application is started, stopped, or successfully moved to another node. However, in some cases where permission is set to &lt;code&gt;true&lt;/code&gt;, the function returns &lt;code&gt;ok&lt;/code&gt; even though the application is not started. This is true when an application cannot start because of dependencies to other applications that are not yet started. When they are started, &lt;code&gt;Application&lt;/code&gt; is started as well.</source>
          <target state="translated">在应用程序启动，停止或成功移动到另一个节点之前，该函数不会返回。但是，在某些情况下，将权限设置为 &lt;code&gt;true&lt;/code&gt; ，即使未启动应用程序，该函数也会返回 &lt;code&gt;ok&lt;/code&gt; 。当应用程序由于与尚未启动的其他应用程序的依赖关系而无法启动时，这是正确的。当它们启动时， &lt;code&gt;Application&lt;/code&gt; 也会启动。</target>
        </trans-unit>
        <trans-unit id="1a469b96b6bc66c5e0081f41213671f5c1c3834d" translate="yes" xml:space="preserve">
          <source>The function evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the specified nodes and collects the answers. It returns &lt;code&gt;{ResL, BadNodes}&lt;/code&gt;, where &lt;code&gt;BadNodes&lt;/code&gt; is a list of the nodes that do not exist, and &lt;code&gt;ResL&lt;/code&gt; is a list of the return values, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; for failing calls. &lt;code&gt;Timeout&lt;/code&gt; is a time (integer) in milliseconds, or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">该函数在指定节点上评估 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 并收集答案。它返回 &lt;code&gt;{ResL, BadNodes}&lt;/code&gt; ，其中 &lt;code&gt;BadNodes&lt;/code&gt; 是不存在的节点的列表，而 &lt;code&gt;ResL&lt;/code&gt; 是返回值的列表，或者 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 用于失败的调用。 &lt;code&gt;Timeout&lt;/code&gt; 是以毫秒为单位的时间（整数），或者是 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfd306c3cfcdf7cb094583b8a0337221382f9540" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调用过程不是由 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; start函数启动的，或者未根据 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 注册，则该函数将失败。</target>
        </trans-unit>
        <trans-unit id="0d8167d08507c4718349622be594e2c2117b70ec" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;proc_lib&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;ServerName&lt;/code&gt;.</source>
          <target state="translated">如果调用过程不是由 &lt;code&gt;proc_lib&lt;/code&gt; start函数启动的，或者未根据 &lt;code&gt;ServerName&lt;/code&gt; 注册，则该函数将失败。</target>
        </trans-unit>
        <trans-unit id="5ed33b0170b87b32a6fff91a9848a8bb7508e2c1" translate="yes" xml:space="preserve">
          <source>The function fails if the mandatory applications Kernel and STDLIB are not included in the &lt;code&gt;.rel&lt;/code&gt; file and have start type &lt;code&gt;permanent&lt;/code&gt; (which is default).</source>
          <target state="translated">如果 &lt;code&gt;.rel&lt;/code&gt; 文件中未包含必需的应用程序内核和STDLIB，并且具有 &lt;code&gt;permanent&lt;/code&gt; 启动类型（默认值），则该功能将失败。</target>
        </trans-unit>
        <trans-unit id="6976675cebc3455eafac8b880bffae5936b6e076" translate="yes" xml:space="preserve">
          <source>The function fails with a &lt;code&gt;badarg&lt;/code&gt; run-time error if &lt;code&gt;Dest&lt;/code&gt; is an atom name, but this name is not registered. This is the only case when &lt;code&gt;send&lt;/code&gt; fails for an unreachable destination &lt;code&gt;Dest&lt;/code&gt; (of correct type).</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 是原子名称，该函数将失败，并显示 &lt;code&gt;badarg&lt;/code&gt; 运行时错误，但该名称未注册。这是针对无法到达的目的地 &lt;code&gt;Dest&lt;/code&gt; （正确类型） &lt;code&gt;send&lt;/code&gt; 失败的唯一情况。</target>
        </trans-unit>
        <trans-unit id="f9fbf6c475826079470707701e2d9650785e7704" translate="yes" xml:space="preserve">
          <source>The function fails with reason &lt;code&gt;badarg&lt;/code&gt; in the following situations:</source>
          <target state="translated">在以下情况下，函数失败，原因为 &lt;code&gt;badarg&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe345735a6f8cc2af489da60647a5b2eb92480ca" translate="yes" xml:space="preserve">
          <source>The function is applied to each argument in the list. &lt;code&gt;foreach&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt;. It is only used for its side-effect:</source>
          <target state="translated">该函数将应用于列表中的每个参数。 &lt;code&gt;foreach&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; 。它仅用于其副作用：</target>
        </trans-unit>
        <trans-unit id="8ed286726d563576b74209031d0c844b5706bbb8" translate="yes" xml:space="preserve">
          <source>The function is asynchronous in the sense that it does not invoke a disk check, but returns the latest available value.</source>
          <target state="translated">该函数是异步的,因为它不调用磁盘检查,而是返回最新的可用值。</target>
        </trans-unit>
        <trans-unit id="b851161538f61def55e8def7663e88f86cb96f48" translate="yes" xml:space="preserve">
          <source>The function is called by Logger when the formatter configuration for a handler is set or modified. It returns &lt;code&gt;ok&lt;/code&gt; if the configuration is valid, and &lt;code&gt;{error,term()}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">设置或修改处理程序的格式化程序配置时，Logger会调用该函数。如果配置有效，则返回 &lt;code&gt;ok&lt;/code&gt; ,如果配置 &lt;code&gt;{error,term()}&lt;/code&gt; 则返回{error，term（）}。</target>
        </trans-unit>
        <trans-unit id="685ab0b87ed3c05c293ea5d73e5639b4e1ff9576" translate="yes" xml:space="preserve">
          <source>The function is called by a Logger when formatter configuration is set or modified. The formatter must validate the given configuration and return &lt;code&gt;ok&lt;/code&gt; if it is correct, and &lt;code&gt;{error,Reason}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">设置或修改格式化程序配置时，记录器会调用该函数。格式化程序必须验证给定的配置，如果正确，则返回 &lt;code&gt;ok&lt;/code&gt; ,如果 &lt;code&gt;{error,Reason}&lt;/code&gt; 则返回{error，Reason}。</target>
        </trans-unit>
        <trans-unit id="7fcd6de716b12c9ffa6272634f06715a4cc1ce07" translate="yes" xml:space="preserve">
          <source>The function is called for each start phase (as defined for the primary application) for the primary application and all included applications, for which the start phase is defined.</source>
          <target state="translated">对于主应用程序和所有包含的应用程序的每个启动阶段(如为主应用程序定义的),该函数被调用。</target>
        </trans-unit>
        <trans-unit id="c011a777dda4570cb71bfb1ec0fb55355e1ee1d3" translate="yes" xml:space="preserve">
          <source>The function is called if a user related error occurs at run-time, for example if a user defined instrumentation function returns erroneous.</source>
          <target state="translated">如果在运行时发生与用户相关的错误,例如用户定义的仪表函数返回错误,则调用该函数。</target>
        </trans-unit>
        <trans-unit id="af4ce4e1efa0b48a530a0c78c675702975921a0a" translate="yes" xml:space="preserve">
          <source>The function is called if an error occurs during the configuration phase, for example if a syntax error is found in a configuration file.</source>
          <target state="translated">如果在配置阶段发生错误,例如在配置文件中发现语法错误,就会调用该函数。</target>
        </trans-unit>
        <trans-unit id="66a34ca9f0458ec66fedbe0a7a5d4d658f1bc216" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when a handler is about to be removed. The purpose is to release all resources used by the handler.</source>
          <target state="translated">当一个处理程序即将被移除时,该函数在一个临时进程上被调用,目的是释放处理程序使用的所有资源。其目的是释放处理程序使用的所有资源。</target>
        </trans-unit>
        <trans-unit id="ad2afb8b57f9d81965d61a6dce572893b3ec7c89" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when an new handler is about to be added. The purpose is to verify the configuration and initiate all resources needed by the handler.</source>
          <target state="translated">当一个新的处理程序即将被添加时,该函数在一个临时进程上被调用,目的是验证配置并启动处理程序所需的所有资源。其目的是验证配置并启动处理程序所需的所有资源。</target>
        </trans-unit>
        <trans-unit id="fdbb67b2c606784fb7d08c84801ed6ce232a3ebb" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when the configuration for a handler is about to change. The purpose is to verify and act on the new configuration.</source>
          <target state="translated">当一个处理程序的配置即将改变时,该函数在临时进程上被调用。其目的是验证并执行新的配置。</target>
        </trans-unit>
        <trans-unit id="80c74d3f2c316470e0f2a09c6499b88b08ed5921" translate="yes" xml:space="preserve">
          <source>The function is called when all primary filters and all handler filters for the handler in question have passed for the given log event. It is called on the client process, that is, the process that issued the log event.</source>
          <target state="translated">当给定日志事件的所有主要过滤器和有关处理程序的所有处理程序过滤器都通过时,该函数被调用。该函数在客户端进程上被调用,也就是发出日志事件的进程。</target>
        </trans-unit>
        <trans-unit id="729c9968acf86cfc5b4d0b16abd57720e8543995" translate="yes" xml:space="preserve">
          <source>The function is called with the current line, up to the cursor, as a reversed string. It is to return a three-tuple: &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt;. The first element gives a beep if &lt;code&gt;no&lt;/code&gt;, otherwise the expansion is silent; the second is a string that will be entered at the cursor position; the third is a list of possible expansions. If this list is not empty, it is printed and the current input line is written once again.</source>
          <target state="translated">该函数以当前行（直到光标）作为反向字符串被调用。它返回一个三元组： &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt; 。如果为 &lt;code&gt;no&lt;/code&gt; ，则第一个元素发出蜂鸣声，否则扩展为无声；第二个是将在光标位置输入的字符串；第三个是可能的扩展列表。如果该列表不为空，则将其打印并再次写入当前输入行。</target>
        </trans-unit>
        <trans-unit id="5bcd5b77b7b4d998e29896caa372504ff0881133" translate="yes" xml:space="preserve">
          <source>The function is called with the data the I/O server finds on its I/O device, returning one of:</source>
          <target state="translated">该函数以I/O服务器在其I/O设备上找到的数据进行调用,返回其中之一。</target>
        </trans-unit>
        <trans-unit id="05b6947d52059ff05be463986c224ccf19b497f6" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments. The first argument is the successive elements in the list. The second argument is the accumulator. The function must return a new accumulator, which is used the next time the function is called.</source>
          <target state="translated">函数调用时有两个参数。第一个参数是列表中的连续元素。第二个参数是累加器。函数必须返回一个新的累加器,在下次调用函数时使用。</target>
        </trans-unit>
        <trans-unit id="c1d7045b7530f750d5c794463ab3ef61f6f0030e" translate="yes" xml:space="preserve">
          <source>The function is intended to be called in function &lt;code&gt;init_per_suite&lt;/code&gt; in the test suite.</source>
          <target state="translated">该功能旨在在测试套件的 &lt;code&gt;init_per_suite&lt;/code&gt; 函数中调用。</target>
        </trans-unit>
        <trans-unit id="91d0a41107672655c3969ea037e3566edb95fc7c" translate="yes" xml:space="preserve">
          <source>The function is normally asynchronous in the sense that it does not invoke a memory check, but returns the latest available value. The one exception if is the function is called before a first memory check is finished, in which case it does not return a value until the memory check is finished.</source>
          <target state="translated">该函数通常是异步的,因为它不调用内存检查,而是返回最新的可用值。唯一的例外是在第一次内存检查结束之前调用该函数,在这种情况下,它不会返回一个值,直到内存检查结束。</target>
        </trans-unit>
        <trans-unit id="34af02f93e44d91dfb2270e53d1db1bc513f0b80" translate="yes" xml:space="preserve">
          <source>The function is optional and can be omitted when implementing an application callback module.</source>
          <target state="translated">该函数是可选的,在实现应用回调模块时可以省略。</target>
        </trans-unit>
        <trans-unit id="982df6f9c963401aaf5cd8cce719f4c21d1397c5" translate="yes" xml:space="preserve">
          <source>The function is optional. If it is not defined, the processes are terminated and then &lt;code&gt;Module:stop(State)&lt;/code&gt; is called.</source>
          <target state="translated">该功能是可选的。如果未定义，则终止进程，然后调用 &lt;code&gt;Module:stop(State)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3c75677662ff31b49062b31fc1d308b57eded17" translate="yes" xml:space="preserve">
          <source>The function is synchronous and all the nodes, and all the system servers, are running when it returns a value.</source>
          <target state="translated">该函数是同步的,当它返回一个值时,所有的节点以及所有的系统服务器都在运行。</target>
        </trans-unit>
        <trans-unit id="4bd22d2a35c5c88266eecbb86f7699a4e9f4d949" translate="yes" xml:space="preserve">
          <source>The function is synchronous in the sense that it is known that all servers have received the message when the call returns. It is not possible to know that the servers have processed the message.</source>
          <target state="translated">该函数是同步的,即当调用返回时,知道所有服务器都收到了消息。不可能知道服务器已经处理了消息。</target>
        </trans-unit>
        <trans-unit id="a3e80a528bd9ed8d253ab3a636d365b349c0df48" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that change the details of the current state of the event handler. Any term is allowed for &lt;code&gt;Status&lt;/code&gt;. The &lt;code&gt;gen_event&lt;/code&gt; module uses &lt;code&gt;Status&lt;/code&gt; as follows:</source>
          <target state="translated">该函数将返回 &lt;code&gt;Status&lt;/code&gt; ，即用来更改事件处理程序当前状态的详细信息的术语。 &lt;code&gt;Status&lt;/code&gt; 可以使用任何条款。该 &lt;code&gt;gen_event&lt;/code&gt; 模块使用 &lt;code&gt;Status&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="f5e6848577b63036dd2df41149bfea0f17b8cf85" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that changes the details of the current state and status of the &lt;code&gt;gen_server&lt;/code&gt; process. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_server&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value.</source>
          <target state="translated">该函数将返回 &lt;code&gt;Status&lt;/code&gt; ，该术语会更改 &lt;code&gt;gen_server&lt;/code&gt; 进程的当前状态和状态的详细信息。对于 &lt;code&gt;Status&lt;/code&gt; 可以采用的形式没有任何限制，但是对于 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 情况（当 &lt;code&gt;Opt&lt;/code&gt; 为 &lt;code&gt;normal&lt;/code&gt; 时）， &lt;code&gt;Status&lt;/code&gt; 值的推荐形式为 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; ，其中 &lt;code&gt;Term&lt;/code&gt; 提供 &lt;code&gt;gen_server&lt;/code&gt; 状态的相关详细信息。不需要遵循此建议，但这会使回调模块的状态与 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回值的其余部分一致。</target>
        </trans-unit>
        <trans-unit id="22b229f5a7773458a1b22bbef3b9114da9d0467f" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that contains the appropriate details of the current state and status of the &lt;code&gt;gen_statem&lt;/code&gt;. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_statem&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value.</source>
          <target state="translated">该函数将返回 &lt;code&gt;Status&lt;/code&gt; ，该术语包含有关 &lt;code&gt;gen_statem&lt;/code&gt; 的当前状态和状态的适当详细信息。对于 &lt;code&gt;Status&lt;/code&gt; 可以采用的形式没有任何限制，但是对于 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 情况（当 &lt;code&gt;Opt&lt;/code&gt; 为 &lt;code&gt;normal&lt;/code&gt; 时）， &lt;code&gt;Status&lt;/code&gt; 值的推荐形式为 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; ，其中 &lt;code&gt;Term&lt;/code&gt; 提供 &lt;code&gt;gen_statem&lt;/code&gt; 状态的相关详细信息。不需要遵循此建议，但这会使回调模块的状态与 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回值的其余部分保持一致。</target>
        </trans-unit>
        <trans-unit id="2e735ad6e373adc70cb8848117759dd2a569193e" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the main process in the subsystem and &lt;code&gt;State&lt;/code&gt; is any term.</source>
          <target state="translated">函数是返回 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是子系统中主进程的pid，而 &lt;code&gt;State&lt;/code&gt; 是任何术语。</target>
        </trans-unit>
        <trans-unit id="b33f514bbf6653a3186283c4cae20e76aa53b9a4" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid}&lt;/code&gt; or &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the top supervisor and &lt;code&gt;State&lt;/code&gt; is any term. If omitted, &lt;code&gt;State&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;. If the application is stopped later, &lt;code&gt;State&lt;/code&gt; is passed to &lt;code&gt;Module:prep_stop/1&lt;/code&gt;.</source>
          <target state="translated">函数是返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; 或 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是最高主管的pid，而 &lt;code&gt;State&lt;/code&gt; 是任何术语。如果省略，则 &lt;code&gt;State&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 。如果应用程序稍后停止， &lt;code&gt;Module:prep_stop/1&lt;/code&gt; &lt;code&gt;State&lt;/code&gt; 传递给Module：prep_stop / 1。</target>
        </trans-unit>
        <trans-unit id="29043cd3dfeb40d4aadad45c2081e6be85789b31" translate="yes" xml:space="preserve">
          <source>The function is to return the updated internal state.</source>
          <target state="translated">该功能是返回更新后的内部状态。</target>
        </trans-unit>
        <trans-unit id="0abf3dd01db775a71cf749a86135b99f1e7db1dc" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">该函数在 &lt;code&gt;.appup&lt;/code&gt; 文件中查找并尝试从当前应用程序版本中查找降级脚本。高级指令转换为低级指令。指令的排序方式与生成 &lt;code&gt;relup&lt;/code&gt; 文件时相同。</target>
        </trans-unit>
        <trans-unit id="ad728199fe8cc2addea2e4edf8ccc9c3d563c12d" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script to the previous version of the application using &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">该函数在 &lt;code&gt;.appup&lt;/code&gt; 文件中查找，并尝试使用 &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt; 查找到应用程序先前版本的降级脚本。使用 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 评估此脚本，其方式与 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="043e22dee6e39d2801de5bf62c0f13acd1fb7f3e" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">该函数在 &lt;code&gt;.appup&lt;/code&gt; 文件中查找并尝试从当前应用程序版本中查找升级脚本。高级指令转换为低级指令。指令的排序方式与生成 &lt;code&gt;relup&lt;/code&gt; 文件时相同。</target>
        </trans-unit>
        <trans-unit id="8c31fe3b9fb91cec2a465fbf77df750e586faa18" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current version of the application using &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">该函数在 &lt;code&gt;.appup&lt;/code&gt; 文件中查找，并尝试使用 &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt; 从应用程序的当前版本中查找升级脚本。使用 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 评估此脚本，其方式与 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="dae77798ddae832b867b1859c814067bb73455e5" translate="yes" xml:space="preserve">
          <source>The function megaco:connect/4 is used to tell the Megaco application about which control process it should supervise, which MID the remote user has, which callback module it should use to send messages etc. When this &quot;virtual&quot; connection is established the user may use megaco:call/3 and megaco:cast/3 in order to send messages to the other side. Then it is up to the MG to send its first Service Change Request message after applying some clever algorithm in order to fight the problem with startup avalanche (as discussed in the RFC).</source>
          <target state="translated">功能megaco:connect/4用来告诉Megaco应用程序它应该监督哪个控制进程,远程用户有哪个MID,应该用哪个回调模块来发送消息等等。当这个 &quot;虚拟 &quot;连接建立后,用户可以使用megaco:call/3和megaco:cast/3来向对方发送消息。然后由MG在应用一些巧妙的算法后,发送它的第一个服务变更请求消息,以对抗启动雪崩的问题(如RFC中讨论的)。</target>
        </trans-unit>
        <trans-unit id="8ccc872bcbfbd97b2f8f68cc4d29e1cdf3b26f8a" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;ok&lt;/code&gt; if the module is to become the new current code for the module and become callable.</source>
          <target state="translated">如果模块要成为该模块的新当前代码并可以调用，则该函数必须返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd0b359eea39bf0334c200db138df73b605bda4d" translate="yes" xml:space="preserve">
          <source>The function name is an atom. Each argument is a pattern.</source>
          <target state="translated">函数名是一个原子。每个参数是一个模式。</target>
        </trans-unit>
        <trans-unit id="9406ba0cad4fe7e53495b5806fdfd8af528e2c11" translate="yes" xml:space="preserve">
          <source>The function names &lt;code&gt;load_driver&lt;/code&gt; and &lt;code&gt;unload_driver&lt;/code&gt; are kept for backward compatibility.</source>
          <target state="translated">保留函数名称 &lt;code&gt;load_driver&lt;/code&gt; 和 &lt;code&gt;unload_driver&lt;/code&gt; 是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="79180ba05daadaf9ff778778be432cdae4488b2e" translate="yes" xml:space="preserve">
          <source>The function notifying the code lock about a button event is implemented using &lt;code&gt;gen_statem:cast/2&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;gen_statem:cast/2&lt;/code&gt; 来实现通知代码锁有关按钮事件的功能：</target>
        </trans-unit>
        <trans-unit id="9bcdf8490fa58034ee65eebf4713860825158535" translate="yes" xml:space="preserve">
          <source>The function print_version_info/0 uses the result of function version1/0 as &lt;code&gt;VersionInfo&lt;/code&gt;.</source>
          <target state="translated">函数print_version_info / 0将函数version1 / 0的结果用作 &lt;code&gt;VersionInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a4124fa895f394038737b2a3c8f1d3ab62f5b7" translate="yes" xml:space="preserve">
          <source>The function produces lines of &lt;code&gt;Key: Value&lt;/code&gt; from key-value lists. Strings are printed with &lt;code&gt;~ts&lt;/code&gt; and other terms with &lt;code&gt;~tp&lt;/code&gt;.</source>
          <target state="translated">该函数从键值列表中生成&amp;ldquo; &lt;code&gt;Key: Value&lt;/code&gt; 行。字符串用 &lt;code&gt;~ts&lt;/code&gt; 打印，其他术语用 &lt;code&gt;~tp&lt;/code&gt; 打印。</target>
        </trans-unit>
        <trans-unit id="9cb60460defa522f2257f4190da9c81a7ebadbf4" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource destructor function.</source>
          <target state="translated">资源析产函数的函数原型。</target>
        </trans-unit>
        <trans-unit id="251a711b61dad3eb243d0cc657f90de99a8cb62d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource down function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;pid&lt;/code&gt; is the identity of the monitored process that is exiting, and &lt;code&gt;mon&lt;/code&gt; is the identity of the monitor.</source>
          <target state="translated">资源中断函数的函数原型，代表 &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;obj&lt;/code&gt; 是资源， &lt;code&gt;pid&lt;/code&gt; 是正在退出的受监视进程的标识， &lt;code&gt;mon&lt;/code&gt; 是监视器的标识。</target>
        </trans-unit>
        <trans-unit id="c45bd32e6496942fbb5d72602a01f8593df7f20d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource stop function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;event&lt;/code&gt; is OS event, &lt;code&gt;is_direct_call&lt;/code&gt; is true if the call is made directly from &lt;code&gt;enif_select&lt;/code&gt; or false if it is a scheduled call (potentially from another thread).</source>
          <target state="translated">资源停止函数的函数原型，代表 &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;obj&lt;/code&gt; 是资源， &lt;code&gt;event&lt;/code&gt; 是OS事件，如果直接从 &lt;code&gt;enif_select&lt;/code&gt; 进行调用，则 &lt;code&gt;is_direct_call&lt;/code&gt; 为true；如果是计划的调用（可能从另一个线程），则为 false。</target>
        </trans-unit>
        <trans-unit id="48037bd5e6edfdffb2f1110aafc54b00f51f984c" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration and kills the other one.</source>
          <target state="translated">该函数随机选择其中一个pids进行注册,并杀死另一个。</target>
        </trans-unit>
        <trans-unit id="305e01bbc8fe93b497a733f359ad553dd0edafee" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration, and sends the message &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; to the other pid.</source>
          <target state="translated">该函数随机选择一个pid进行注册，然后将消息 &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; 发送到另一个pid。</target>
        </trans-unit>
        <trans-unit id="8abbebafab7e64fd67ec141e6747533671416e1f" translate="yes" xml:space="preserve">
          <source>The function removes the &lt;code&gt;Key&lt;/code&gt;, if it exists, and its associated value from &lt;code&gt;Map1&lt;/code&gt; and returns a tuple with the removed &lt;code&gt;Value&lt;/code&gt; and the new map &lt;code&gt;Map2&lt;/code&gt; without key &lt;code&gt;Key&lt;/code&gt;. If the key does not exist &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">该函数从 &lt;code&gt;Map1&lt;/code&gt; 中删除 &lt;code&gt;Key&lt;/code&gt; （如果存在）及其关联的值，并返回具有删除的 &lt;code&gt;Value&lt;/code&gt; 和没有键 &lt;code&gt;Key&lt;/code&gt; 的新映射 &lt;code&gt;Map2&lt;/code&gt; 的元组。如果密钥不存在，则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e238717dba0649170fc233d2b4fe4554b94fb51d" translate="yes" xml:space="preserve">
          <source>The function reports &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; for errors, where &lt;code&gt;Reason&lt;/code&gt; is any possible reason returned by &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; when starting a specific dependency.</source>
          <target state="translated">该函数报告 &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; 中的错误，其中 &lt;code&gt;Reason&lt;/code&gt; 是启动特定依赖项时 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 返回的任何可能原因。</target>
        </trans-unit>
        <trans-unit id="76d19e4d2aef11065f3b75825b4b1412100e2c14" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; for &lt;code&gt;latin1&lt;/code&gt; encoding, as there is no BOM for ISO Latin-1.</source>
          <target state="translated">对于 &lt;code&gt;latin1&lt;/code&gt; 编码，该函数返回 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ，因为没有针对ISO Latin-1的BOM。</target>
        </trans-unit>
        <trans-unit id="cea6a4ed4ab166dce1a5c11aa39053c9e188fc54" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;1&lt;/code&gt; on successful decoding, &lt;code&gt;-1&lt;/code&gt; on error, and &lt;code&gt;0&lt;/code&gt; if the term seems alright, but does not fit in the &lt;code&gt;term&lt;/code&gt; structure. If &lt;code&gt;1&lt;/code&gt; is returned, the &lt;code&gt;index&lt;/code&gt; is incremented, and &lt;code&gt;term&lt;/code&gt; contains the decoded term.</source>
          <target state="translated">该函数返回 &lt;code&gt;1&lt;/code&gt; 上成功解码， &lt;code&gt;-1&lt;/code&gt; 上的错误，以及 &lt;code&gt;0&lt;/code&gt; 如果术语似乎好，但不适合在 &lt;code&gt;term&lt;/code&gt; 结构。如果返回 &lt;code&gt;1&lt;/code&gt; ，则 &lt;code&gt;index&lt;/code&gt; 增加，并且 &lt;code&gt;term&lt;/code&gt; 包含解码的term。</target>
        </trans-unit>
        <trans-unit id="0c0efff847bddce6b19a713a0f0517e02e510df4" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the event manager terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果事件管理器因预期原因终止，则该函数返回 &lt;code&gt;ok&lt;/code&gt; 。除了 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 之外的任何其他原因都会导致使用 &lt;code&gt;logger(3)&lt;/code&gt; 发出错误报告。默认的 &lt;code&gt;Reason&lt;/code&gt; 是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c7b3421431470de3120253d455529b919367ac1" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果服务器因预期原因终止，则该函数返回 &lt;code&gt;ok&lt;/code&gt; 。除了 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 以外的任何其他原因都会导致使用 &lt;code&gt;logger(3)&lt;/code&gt; 发出错误报告。默认的 &lt;code&gt;Reason&lt;/code&gt; 是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd73f7ab11de774d64402ce75fdbcce6bc66eb53" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; or an error tuple where the second element contains the I/O error that made the writing impossible.</source>
          <target state="translated">该函数返回 &lt;code&gt;ok&lt;/code&gt; 或错误元组，其中第二个元素包含导致无法写入的I / O错误。</target>
        </trans-unit>
        <trans-unit id="9d8bcc68d7d1e1c02534b3299d71875a81aa57c0" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt;, or terminates if an error occurs. For example, the transaction terminates if no &lt;code&gt;person&lt;/code&gt; table exists.</source>
          <target state="translated">该函数返回 &lt;code&gt;ok&lt;/code&gt; ，或者在发生错误时终止。例如，如果不存在 &lt;code&gt;person&lt;/code&gt; 表，则事务终止。</target>
        </trans-unit>
        <trans-unit id="ae9ce4bfa4732575d07ad75abe832d18209cf6d5" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;profiling&lt;/code&gt; if tracing could be enabled for all processes in &lt;code&gt;Rootset&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt; otherwise.</source>
          <target state="translated">如果可以为 &lt;code&gt;Rootset&lt;/code&gt; 中的所有进程启用跟踪，则该函数返回 &lt;code&gt;profiling&lt;/code&gt; 文件，否则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82b7eb2d16fbf6159cd686bcbf5282210683decd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if all of the following apply:</source>
          <target state="translated">如果满足以下所有条件，则该函数返回 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ade0bfc225f1f56359228ebdf66a4c04b123ddc2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;yes&lt;/code&gt; if successful, &lt;code&gt;no&lt;/code&gt; if it fails. For example, &lt;code&gt;no&lt;/code&gt; is returned if an attempt is made to register an already registered process or to register a process with a name that is already in use.</source>
          <target state="translated">该函数返回 &lt;code&gt;yes&lt;/code&gt; 如果成功， &lt;code&gt;no&lt;/code&gt; 如果失败。例如，如果尝试注册已经注册的进程或使用已经使用的名称注册进程，则返回 &lt;code&gt;no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00e48b1c0bb58c163a4b66da8eb059d14d44d0a7" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{Pos, Length}&lt;/code&gt; for the binary in &lt;code&gt;Pattern&lt;/code&gt;, starting at the lowest position in &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">该函数返回 &lt;code&gt;{Pos, Length}&lt;/code&gt; 在二进制 &lt;code&gt;Pattern&lt;/code&gt; ，开始于在最低位置 &lt;code&gt;Subject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51c7380f6ccd2c685f838a5778eff11acc171a3c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{SourceFile, Options}&lt;/code&gt; if it succeeds. &lt;code&gt;SourceFile&lt;/code&gt; is the absolute path to the source file without extension &lt;code&gt;&quot;.erl&quot;&lt;/code&gt;. &lt;code&gt;Options&lt;/code&gt; includes the options that are necessary to recompile the file with &lt;code&gt;compile:file/2&lt;/code&gt;, but excludes options such as &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;verbose&lt;/code&gt;, which do not change the way code is generated. The paths in options &lt;code&gt;{outdir, Path}&lt;/code&gt; and &lt;code&gt;{i, Path}&lt;/code&gt; are guaranteed to be absolute.</source>
          <target state="translated">如果成功 &lt;code&gt;{SourceFile, Options}&lt;/code&gt; 该函数将返回{SourceFile，Options}。 &lt;code&gt;SourceFile&lt;/code&gt; 是没有扩展名 &lt;code&gt;&quot;.erl&quot;&lt;/code&gt; 的源文件的绝对路径。 &lt;code&gt;Options&lt;/code&gt; 包括使用 &lt;code&gt;compile:file/2&lt;/code&gt; 重新编译文件所必需的选项，但不包括诸如 &lt;code&gt;report&lt;/code&gt; 和 &lt;code&gt;verbose&lt;/code&gt; 之类的选项，它们不会改变代码的生成方式。选项 &lt;code&gt;{outdir, Path}&lt;/code&gt; 和 &lt;code&gt;{i, Path}&lt;/code&gt; 中的路径保证是绝对的。</target>
        </trans-unit>
        <trans-unit id="95f12585f0eeb736eca25c313b53ecf1f8719509" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,Reason}&lt;/code&gt; if the module cannot be interpreted. &lt;code&gt;Reason&lt;/code&gt; can have the following values:</source>
          <target state="translated">如果无法解释该模块，则该函数返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。 &lt;code&gt;Reason&lt;/code&gt; 可以具有以下值：</target>
        </trans-unit>
        <trans-unit id="327593fcc1fe364e7a22ff37db545a09532407de" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,eacces}&lt;/code&gt; if the directory is not readable or &lt;code&gt;{error,enoent}&lt;/code&gt; if the directory does not exist.</source>
          <target state="translated">如果目录不可读 &lt;code&gt;{error,eacces}&lt;/code&gt; 函数返回{error，eacces}；如果目录不存在 &lt;code&gt;{error,enoent}&lt;/code&gt; 则返回{error，enoent}。</target>
        </trans-unit>
        <trans-unit id="9a6679cb30215fd3bbce3430d53f63d245192cc6" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{ok, Node}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the new node, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; can be one of:</source>
          <target state="translated">该函数返回 &lt;code&gt;{ok, Node}&lt;/code&gt; ，其中 &lt;code&gt;Node&lt;/code&gt; 是新节点的名称，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; ，其中 &lt;code&gt;Reason&lt;/code&gt; 可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="926a41dded8f50f5bd40efe538f9bd8d662e5429" translate="yes" xml:space="preserve">
          <source>The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings, for example:</source>
          <target state="translated">该函数返回一个列表,每个匹配对象有一个元素,其中每个元素是模式变量绑定的有序列表,例如。</target>
        </trans-unit>
        <trans-unit id="ef467049df8eebfb47a732dfe257b75164507468" translate="yes" xml:space="preserve">
          <source>The function returns a new list.</source>
          <target state="translated">该函数返回一个新的列表。</target>
        </trans-unit>
        <trans-unit id="8e921d3a34acd22129663174bed5a4222ddb5120" translate="yes" xml:space="preserve">
          <source>The function returns a tuple &lt;code&gt;{Replies,BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of &lt;code&gt;{Node,Reply}&lt;/code&gt; and &lt;code&gt;BadNodes&lt;/code&gt; is a list of node that either did not exist, or where the &lt;code&gt;gen_server&lt;/code&gt;&lt;code&gt;Name&lt;/code&gt; did not exist or did not reply.</source>
          <target state="translated">该函数返回一个元组 &lt;code&gt;{Replies,BadNodes}&lt;/code&gt; ，其中 &lt;code&gt;Replies&lt;/code&gt; 是 &lt;code&gt;{Node,Reply}&lt;/code&gt; 的列表，而 &lt;code&gt;BadNodes&lt;/code&gt; 是不存在或 &lt;code&gt;gen_server&lt;/code&gt; &lt;code&gt;Name&lt;/code&gt; 不存在或未答复的节点的列表。</target>
        </trans-unit>
        <trans-unit id="b1e8d384f3de9f24fc9976775486188b88a64ca7" translate="yes" xml:space="preserve">
          <source>The function returns according to the specification of an instrumentation function.</source>
          <target state="translated">该函数根据仪表函数的规格返回。</target>
        </trans-unit>
        <trans-unit id="ba15e145974c7c4548255818d03130da786830bb" translate="yes" xml:space="preserve">
          <source>The function returns an Erlang term, or &lt;code&gt;NULL&lt;/code&gt; if &lt;code&gt;FormatStr&lt;/code&gt; does not describe a valid Erlang term.</source>
          <target state="translated">该函数返回一个Erlang术语，如果 &lt;code&gt;FormatStr&lt;/code&gt; 没有描述有效的Erlang术语，则返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84b04ee2da4370d4c96804f7728600a7d4958614" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many functions that matched, in the same way as the processes and ports are presented in the return value of &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数返回错误元组或元组 &lt;code&gt;{ok, List}&lt;/code&gt; 。该 &lt;code&gt;List&lt;/code&gt; 包含与 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 的返回值中呈现的进程和端口相同的方式匹配的功能数量的规范。</target>
        </trans-unit>
        <trans-unit id="dff9f8ac1b740a28f21f75b322ee576a5c1a3db8" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many processes and ports that matched (in the case of a pure pid() exactly 1). The specification of matched processes is &lt;code&gt;{matched, Node, N}&lt;/code&gt;. If the remote processor call,&lt;code&gt;rpc&lt;/code&gt;, to a remote node fails, the &lt;code&gt;rpc&lt;/code&gt; error message is delivered as a fourth argument and the number of matched processes are 0. Note that the result {ok, List} may contain a list where &lt;code&gt;rpc&lt;/code&gt; calls to one, several or even all nodes failed.</source>
          <target state="translated">该函数返回错误元组或元组 &lt;code&gt;{ok, List}&lt;/code&gt; 。该 &lt;code&gt;List&lt;/code&gt; 由匹配的进程和端口的规格组成（在纯pid（）的情况下，精确为1）。匹配进程的规范为 &lt;code&gt;{matched, Node, N}&lt;/code&gt; 。如果对远程节点的远程处理器调用 &lt;code&gt;rpc&lt;/code&gt; 失败，则将 &lt;code&gt;rpc&lt;/code&gt; 错误消息作为第四个参数传递，并且匹配的进程数为0。请注意，结果{ok，List}可能包含一个列表，其中 &lt;code&gt;rpc&lt;/code&gt; 调用了以下内容：一个，几个甚至所有节点发生故障。</target>
        </trans-unit>
        <trans-unit id="47ce2b2bb012a9e9a4743dfb100ef52ab194f4a8" translate="yes" xml:space="preserve">
          <source>The function returns one of the following statuses upon success:</source>
          <target state="translated">该函数成功后返回以下状态之一。</target>
        </trans-unit>
        <trans-unit id="af80ca7f3d62f6cac6e62e9f90f2843e1b33444b" translate="yes" xml:space="preserve">
          <source>The function returns the answer &lt;code&gt;Reply&lt;/code&gt; as produced by the server &lt;code&gt;Name&lt;/code&gt;, or &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">该函数返回由服务器 &lt;code&gt;Name&lt;/code&gt; 或 &lt;code&gt;{error, Reason}&lt;/code&gt; 产生的答案 &lt;code&gt;Reply&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fa69a661585fbc212f6bcd6110e5d9551001a6f" translate="yes" xml:space="preserve">
          <source>The function returns the list of file names of all created modules, including any automatically created stub modules. The file name of the target module is always first in the list.</source>
          <target state="translated">该函数返回所有已创建模块的文件名列表,包括任何自动创建的存根模块。目标模块的文件名总是排在列表的第一位。</target>
        </trans-unit>
        <trans-unit id="67e6d37d8f8ed9b75d952e7999fb2087c89daf86" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects deleted from the table.</source>
          <target state="translated">该函数返回从表中删除的对象数量。</target>
        </trans-unit>
        <trans-unit id="f97fd237860bed04d4fc7be045423bcf8705b592" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects matched.</source>
          <target state="translated">该函数返回匹配对象的数量。</target>
        </trans-unit>
        <trans-unit id="c874ae6f3ce13ecf61704660eadd7378f687f995" translate="yes" xml:space="preserve">
          <source>The function returns the pid() of a handler process, that does the supervision on behalf of the client application. Note that the client application is linked to this handler.</source>
          <target state="translated">该函数返回一个处理程序的pid(),该处理程序代表客户端应用程序进行监督。请注意,客户端应用程序与该处理程序有关联。</target>
        </trans-unit>
        <trans-unit id="8826e27f40bae39e6afc8b99ead67cefc85ed51f" translate="yes" xml:space="preserve">
          <source>The function returns the test result, represented by the tuple &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt;, where each element is an integer. If test execution fails, the function returns the tuple &lt;code&gt;{error,Reason}&lt;/code&gt;, where the term &lt;code&gt;Reason&lt;/code&gt; explains the failure.</source>
          <target state="translated">该函数返回测试结果，由元组 &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt; 表示，其中每个元素都是整数。如果测试执行失败，则该函数返回元组 &lt;code&gt;{error,Reason}&lt;/code&gt; ，其中&amp;ldquo; &lt;code&gt;Reason&lt;/code&gt; &amp;rdquo;一词说明了失败。</target>
        </trans-unit>
        <trans-unit id="66053340efa519d76743820bb26595016a5a05f7" translate="yes" xml:space="preserve">
          <source>The function returns the total number of replaced objects.</source>
          <target state="translated">该函数返回被替换对象的总数。</target>
        </trans-unit>
        <trans-unit id="13b54d91784d634be011a5d8f40eca029f4c1437" translate="yes" xml:space="preserve">
          <source>The function returns when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled.</source>
          <target state="translated">当回复到达时,当请求计时器最终超时时,或者当未完成的请求被明确取消时,该函数返回。</target>
        </trans-unit>
        <trans-unit id="0e911cfd5f3fbfe1f052ffaa063943cb8b0fe46c" translate="yes" xml:space="preserve">
          <source>The function returns:</source>
          <target state="translated">该函数返回:</target>
        </trans-unit>
        <trans-unit id="9be9148ebe8c1af83ecb810b37aa82c15bf5d001" translate="yes" xml:space="preserve">
          <source>The function should now return:</source>
          <target state="translated">现在函数应该返回。</target>
        </trans-unit>
        <trans-unit id="89ceb7fdfb37fece3ab74b229b8cea9443cca0bd" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system or if the tag is not supported.</source>
          <target state="translated">如果驱动程序不存在于系统中或不支持该标记，则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="95ce52efa32ec5a1e922545d8dfcff54dd9fa145" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system.</source>
          <target state="translated">如果系统中不存在驱动程序，则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e2803735d718719dbf8ff59057508925d737d41f" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameter is not a &lt;code&gt;reference()&lt;/code&gt;.</source>
          <target state="translated">如果参数不是 &lt;code&gt;reference()&lt;/code&gt; ,则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="66d20dcf7ad9c489aba044486ad7cfb8ef93a242" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameters are not specified as described here.</source>
          <target state="translated">如果未按此处所述指定参数，则该函数将引发 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="5d9e44a0ad0773f97c4f379d41e06e651c358097" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameter is in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">如果参数格式错误,函数会抛出一个badarg。如果底层OpenSSL实现中没有引擎支持,它也可能抛出异常notsup。</target>
        </trans-unit>
        <trans-unit id="eda733b256a520d564c901fe8c2c263fe4e56cd1" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameters are in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">如果参数的格式不对,函数会抛出一个badarg。如果底层OpenSSL实现中没有引擎支持,该函数也可能抛出异常notsup。</target>
        </trans-unit>
        <trans-unit id="31c1041afe84cb2dbdbb948e8208c9f84bf59ebd" translate="yes" xml:space="preserve">
          <source>The function unregisters both pids and sends the message &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; to both processes.</source>
          <target state="translated">该函数注销两个pid并将消息 &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; 发送到两个进程。</target>
        </trans-unit>
        <trans-unit id="c3a1f79b06aa96385eb181ed86fb6eae9b5e9415" translate="yes" xml:space="preserve">
          <source>The function waits for user input, and does not return until the remote shell is ended (that is, exit from the shell).</source>
          <target state="translated">该函数等待用户输入,直到远程shell结束(即退出shell)才返回。</target>
        </trans-unit>
        <trans-unit id="b8892ca0441d17488cdcc2015a61701f971adb9a" translate="yes" xml:space="preserve">
          <source>The function will also return an error if the node &lt;code&gt;Nodename&lt;/code&gt; is not reachable.</source>
          <target state="translated">如果节点 &lt;code&gt;Nodename&lt;/code&gt; 不可访问，该函数还将返回错误。</target>
        </trans-unit>
        <trans-unit id="fe48f3115cf0be1263ce3632f413691699d232ac" translate="yes" xml:space="preserve">
          <source>The function will also return the &lt;code&gt;Name&lt;/code&gt; instead of the table identifier. To get the table identifier of a named table, use &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数还将返回 &lt;code&gt;Name&lt;/code&gt; 而不是表标识符。要获取命名表的表标识符，请使用 &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc605a27b48f7b91fedc8d92d1b0ced2f10b5eee" translate="yes" xml:space="preserve">
          <source>The function will return an error, either due to I/O problems (like a non existing or non readable file) or due to file format problems. The errors from a bad format file are in a more or less textual format, which will give a hint to what's causing the problem.</source>
          <target state="translated">该函数将返回一个错误,可能是由于I/O问题(如一个不存在或不可读的文件)或由于文件格式问题。格式不好的文件所产生的错误或多或少是以文本格式出现的,这会给人提示是什么原因导致的问题。</target>
        </trans-unit>
        <trans-unit id="1192b2e61e715c06fc73aea33efb68d8d4e10a72" translate="yes" xml:space="preserve">
          <source>The function will throw an exception if the &lt;code&gt;dyntrace&lt;/code&gt; NIF library could not be loaded by the on_load function of this module.</source>
          <target state="translated">如果此模块的on_load函数无法加载 &lt;code&gt;dyntrace&lt;/code&gt; NIF库，则该函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="877225bff459640b7fb2492bce96b16257fca8af" translate="yes" xml:space="preserve">
          <source>The function works as &lt;code&gt;ei_reg_send&lt;/code&gt; with one exception. Instead of taking &lt;code&gt;ei_cnode&lt;/code&gt; as first argument, it takes a second argument, an &lt;code&gt;erlang_pid&lt;/code&gt;, which is to be the process identifier of the sending process (in the Erlang distribution protocol).</source>
          <target state="translated">该函数作为 &lt;code&gt;ei_reg_send&lt;/code&gt; 起作用，但有一个例外。代替使用 &lt;code&gt;ei_cnode&lt;/code&gt; 作为第一个参数，它使用第二个参数 &lt;code&gt;erlang_pid&lt;/code&gt; ，它将作为发送进程的进程标识符（在Erlang分发协议中）。</target>
        </trans-unit>
        <trans-unit id="96c1202d0cd6c2fd8c2454e3ec64b0d84b6bd072" translate="yes" xml:space="preserve">
          <source>The functionality described in EEP10 was implemented in Erlang/OTP R13A.</source>
          <target state="translated">EEP10中描述的功能是在Erlang/OTP R13A中实现的。</target>
        </trans-unit>
        <trans-unit id="f4c5930ab45c4ff48e920b1f1f0e771ba10a38ad" translate="yes" xml:space="preserve">
          <source>The functionality of &lt;code&gt;server&lt;/code&gt; can be extended without having to change &lt;code&gt;ch2&lt;/code&gt; or any other callback module.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 功能可以扩展，而无需更改 &lt;code&gt;ch2&lt;/code&gt; 或任何其他回调模块。</target>
        </trans-unit>
        <trans-unit id="42a7b913d2b289987ee5e2464734af014db9f20b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; may be used to modify and read verbosity levels during test execution.</source>
          <target state="translated">功能 &lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; 可以用于在测试执行期间修改和读取详细级别。</target>
        </trans-unit>
        <trans-unit id="4e9c838a14637c7a4c6ed49ae71fd28e08b8189c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt;, in the &lt;code&gt;erl_parse&lt;/code&gt; module can be used for manipulating annotations in abstract code.</source>
          <target state="translated">功能 &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt; ,和 &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt; ，中 &lt;code&gt;erl_parse&lt;/code&gt; 模块可用于在抽象代码操纵注释。</target>
        </trans-unit>
        <trans-unit id="4ef5f76ccaeeff0245cc5352fd37788847bc8dd4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;erl_scan&lt;/code&gt; module can be used for inspecting annotations in tokens.</source>
          <target state="translated">功能 &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;erl_scan&lt;/code&gt; 模块可用于在令牌检查注释。</target>
        </trans-unit>
        <trans-unit id="8f1eb93f5b31a056ece4e165a375a5884952e8c6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; can be used to add and delete replicas of the schema table. Adding a node to the list of nodes where the schema is replicated affects the following:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 可用于添加和删除模式表的副本。将节点添加到复制架构的节点列表中会影响以下内容：</target>
        </trans-unit>
        <trans-unit id="1886785ff0b77240f1ec57a522b97c8411209098" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; are used to get a limited number of results, where &lt;code&gt;Continuation&lt;/code&gt; gets the next chunk of results. &lt;code&gt;Mnesia&lt;/code&gt; uses &lt;code&gt;NObjects&lt;/code&gt; as a recommendation only. Thus, more or less results than specified with &lt;code&gt;NObjects&lt;/code&gt; can be returned in the result list, even the empty list can be returned even if there are more results to collect.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 用于获取有限数量的结果，其中 &lt;code&gt;Continuation&lt;/code&gt; 获取下一个结果块。 &lt;code&gt;Mnesia&lt;/code&gt; 仅将 &lt;code&gt;NObjects&lt;/code&gt; 用作建议。因此，可以在结果列表中返回比 &lt;code&gt;NObjects&lt;/code&gt; 指定的结果更多或更少的结果，即使可以收集更多结果，也可以返回空列表。</target>
        </trans-unit>
        <trans-unit id="902b2335f36e3393b5572f1006845ff1177285c7" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; can be used to obtain information about the potential master nodes.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; 可用于获取有关潜在主节点的信息。</target>
        </trans-unit>
        <trans-unit id="d7162f97290d0f08d1d6fce536552b6112fd005e" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; can now be expressed in terms of &lt;code&gt;map&lt;/code&gt; as follows:</source>
          <target state="translated">现在可以使用 &lt;code&gt;map&lt;/code&gt; 来表示 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;add_one&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="222156c9e6dd9e3d178176d3e89b557b47249290" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; have a similar structure. This can be used by writing a function &lt;code&gt;map&lt;/code&gt; that expresses this similarity:</source>
          <target state="translated">函数 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;add_one&lt;/code&gt; 具有相似的结构。可以通过编写表示这种相似性的功能 &lt;code&gt;map&lt;/code&gt; 来使用此功能：</target>
        </trans-unit>
        <trans-unit id="648f7da232361f38f861a299d3f2d536886a367c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;first/[1,2]&lt;/code&gt;, &lt;code&gt;last/[1,2]&lt;/code&gt;, &lt;code&gt;next/[1,2]&lt;/code&gt;, &lt;code&gt;prev[1,2]&lt;/code&gt; and &lt;code&gt;select/[3,4]&lt;/code&gt; assumes there is a result set associated with the connection to work on. Calling the function &lt;code&gt;select_count/[2,3]&lt;/code&gt; associates such a result set with the connection. Calling select_count again will remove the current result set association and create a new one. Calling a function which dose not operate on an associated result sets, such as &lt;code&gt;sql_query/[2,3]&lt;/code&gt;, will remove the current result set association.</source>
          <target state="translated">函数 &lt;code&gt;first/[1,2]&lt;/code&gt; ， &lt;code&gt;last/[1,2]&lt;/code&gt; ， &lt;code&gt;next/[1,2]&lt;/code&gt; ， &lt;code&gt;prev[1,2]&lt;/code&gt; 和 &lt;code&gt;select/[3,4]&lt;/code&gt; 假定存在与连接关联的结果集继续努力。调用函数 &lt;code&gt;select_count/[2,3]&lt;/code&gt; 将这样的结果集与连接相关联。再次调用select_count将删除当前结果集关联并创建一个新的关联。调用对关联结果集不起作用的函数，例如 &lt;code&gt;sql_query/[2,3]&lt;/code&gt; ，将删除当前结果集关联。</target>
        </trans-unit>
        <trans-unit id="f5fc6fff1054bde43efdc57cd822c6d67516d395" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;get_s&lt;/code&gt; and &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; are utilities that are used to make the code shorter. &lt;code&gt;get_s&lt;/code&gt; duplicates the string and zero-terminates it, as the postgres client library wants that. &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; takes an &lt;code&gt;ei_x_buff&lt;/code&gt; buffer, allocates a binary, and copies the data there. This binary is returned in &lt;code&gt;*rbuf&lt;/code&gt;. (Notice that this binary is freed by the emulator, not by us.)</source>
          <target state="translated">函数 &lt;code&gt;get_s&lt;/code&gt; 和 &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 是用于使代码更短的实用程序。 &lt;code&gt;get_s&lt;/code&gt; 复制该字符串并以0终止该字符串，因为postgres客户端库希望这样做。 &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 使用 &lt;code&gt;ei_x_buff&lt;/code&gt; 缓冲区，分配一个二进制文件，然后将数据复制到那里。该二进制文件在 &lt;code&gt;*rbuf&lt;/code&gt; 中返回。（请注意，此二进制文件是由仿真器而不是我们释放的。）</target>
        </trans-unit>
        <trans-unit id="5096e39491b69e094a3f98629aa50fa1108f0a5e" translate="yes" xml:space="preserve">
          <source>The functions above have an optional argument, &lt;code&gt;Options&lt;/code&gt;. It is a list which can contain the following elements:</source>
          <target state="translated">上面的函数有一个可选参数 &lt;code&gt;Options&lt;/code&gt; 。该列表可以包含以下元素：</target>
        </trans-unit>
        <trans-unit id="4cf9cf212abd94252e34e02e2e21ec1dc4af5994" translate="yes" xml:space="preserve">
          <source>The functions allowed in &lt;code&gt;match_spec&lt;/code&gt; work as follows:</source>
          <target state="translated">&lt;code&gt;match_spec&lt;/code&gt; 允许的功能如下：</target>
        </trans-unit>
        <trans-unit id="b49c5e0b193b751df77e5b417fa995fca0d1e1a2" translate="yes" xml:space="preserve">
          <source>The functions allowed only for tracing work as follows:</source>
          <target state="translated">只允许用于追踪的功能如下:</target>
        </trans-unit>
        <trans-unit id="c38557bf4878ec1f68819130f6538837da45503c" translate="yes" xml:space="preserve">
          <source>The functions are also used as input and output for parse transforms, see the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">该函数还用作解析转换的输入和输出，请参见 &lt;code&gt;compile(3)&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="b767ef0cfc20ad008772285b7b151d13f3e95f0c" translate="yes" xml:space="preserve">
          <source>The functions are deliberately kept as simple as possible, for readability reasons.</source>
          <target state="translated">出于可读性的考虑,这些功能被刻意保持得尽可能简单。</target>
        </trans-unit>
        <trans-unit id="45f09a589c0917e05c505ec254a5e8229659ac40" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-run&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">这些功能在初始化过程中顺序执行，然后正常终止，并将控制权传递给用户。这意味着不返回的 &lt;code&gt;-run&lt;/code&gt; 调用会阻止进一步的处理。为了避免这种情况，请在这种情况下使用 &lt;code&gt;spawn&lt;/code&gt; 的某些变体。</target>
        </trans-unit>
        <trans-unit id="926aaaf3b21fb32d1bbb6e4c88da0fdf9d06509c" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-s&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">这些功能在初始化过程中顺序执行，然后正常终止，并将控制权传递给用户。这意味着不返回的 &lt;code&gt;-s&lt;/code&gt; 调用会阻止进一步的处理。为了避免这种情况，请在这种情况下使用 &lt;code&gt;spawn&lt;/code&gt; 的某些变体。</target>
        </trans-unit>
        <trans-unit id="16b3d921f3dab11c8bd9dcd981b467c9ea9eb69b" translate="yes" xml:space="preserve">
          <source>The functions are kept for backward compatibility, but are not recommended. They will be deprecated in a future release.</source>
          <target state="translated">保留这些功能是为了向后兼容,但不推荐使用。它们将在未来的版本中被废弃。</target>
        </trans-unit>
        <trans-unit id="e16c3bfea1464fe2701a69fbec438e22d449fa1c" translate="yes" xml:space="preserve">
          <source>The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but not all functions verify that all binaries are encoded correctly.</source>
          <target state="translated">对于非有效的输入字符串,这些函数可能会崩溃。例如,函数期望UTF-8二进制文件,但并非所有函数都能验证所有二进制文件是否正确编码。</target>
        </trans-unit>
        <trans-unit id="dd2b5b372777bf5bb017e0da931269beb671e840" translate="yes" xml:space="preserve">
          <source>The functions for receiving and sending data are combined into a function, pointed out by the driver structure. The data sent into the port is given as arguments, and the replied data is sent with the C-function &lt;code&gt;driver_output&lt;/code&gt;.</source>
          <target state="translated">驱动程序结构指出，用于接收和发送数据的功能被组合为一个功能。发送到端口的数据作为参数给出，并且使用C函数 &lt;code&gt;driver_output&lt;/code&gt; 发送已复制的数据。</target>
        </trans-unit>
        <trans-unit id="ebbfff7f1d8a39c016464e3f5cebc0cf7001e164" translate="yes" xml:space="preserve">
          <source>The functions implemented by this module cover the following use cases:</source>
          <target state="translated">该模块实现的功能涵盖以下用例:</target>
        </trans-unit>
        <trans-unit id="c86b667b04bbb8c7ab1bce69786f4f6966eec074" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;systools&lt;/code&gt; require more information. If they are used, the following keys are mandatory:</source>
          <target state="translated">&lt;code&gt;systools&lt;/code&gt; 中的功能需要更多信息。如果使用它们，则必须使用以下密钥：</target>
        </trans-unit>
        <trans-unit id="2c1aa340d685d0c3733736a0ada3b9ea70cc9c9a" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;io&lt;/code&gt; module cannot be used, as they can only talk to an Erlang process. Instead, use functions &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 模块中的功能无法使用，因为它们只能与Erlang进程通信。而是使用函数 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25876dba4377f3e108142ac910ecc80fd99f8dd" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;timer&lt;/code&gt; module that do not manage timers (such as &lt;code&gt;timer:tc/3&lt;/code&gt; or &lt;code&gt;timer:sleep/1&lt;/code&gt;), do not call the timer-server process and are therefore harmless.</source>
          <target state="translated">中相应的功能 &lt;code&gt;timer&lt;/code&gt; 模块不管理定时器（如 &lt;code&gt;timer:tc/3&lt;/code&gt; 或 &lt;code&gt;timer:sleep/1&lt;/code&gt; ），不叫定时器服务器进程，因此是无害的。</target>
        </trans-unit>
        <trans-unit id="bc5c8ab81c744e8799da4f1bbc208d8534384ca8" translate="yes" xml:space="preserve">
          <source>The functions in the module &lt;code&gt;file&lt;/code&gt; usually treat binaries as raw filenames, that is, they are passed &quot;as is&quot; even when the encoding of the binary does not agree with &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt;. However, this function expects binaries to be encoded according to the value returned by &lt;code&gt;native_name_encoding()&lt;/code&gt;.</source>
          <target state="translated">模块 &lt;code&gt;file&lt;/code&gt; 的函数通常将二进制文件视为原始文件名，也就是说，即使二进制文件的编码与 &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt; 不一致，它们也会&amp;ldquo;按原样&amp;rdquo;传递。但是，此函数希望根据 &lt;code&gt;native_name_encoding()&lt;/code&gt; 返回的值对二进制文件进行编码。</target>
        </trans-unit>
        <trans-unit id="59fe37bf337f659a6dcf2745738cdc7eba91db8e" translate="yes" xml:space="preserve">
          <source>The functions in this module are invoked automatically by the Erlang compiler. There is no reason to invoke these functions separately unless you have written your own Erlang compiler.</source>
          <target state="translated">这个模块中的函数是由Erlang编译器自动调用的,除非你自己编写Erlang编译器,否则没有必要单独调用这些函数。除非你自己编写了Erlang编译器,否则没有理由单独调用这些函数。</target>
        </trans-unit>
        <trans-unit id="83d017ac05dd2cacc80880c2e28d8a757b9c1403" translate="yes" xml:space="preserve">
          <source>The functions in this module are operating system-specific. Careless use of these functions results in programs that will only run on a specific platform. On the other hand, with careful use, these functions can be of help in enabling a program to run on most platforms.</source>
          <target state="translated">本模块中的函数是操作系统专用的。如果不小心使用这些函数,就会导致程序只能在特定的平台上运行。另一方面,如果谨慎使用,这些函数可以帮助程序在大多数平台上运行。</target>
        </trans-unit>
        <trans-unit id="0090b523e8b96e6009643e2f865f32e534e6e35f" translate="yes" xml:space="preserve">
          <source>The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong.</source>
          <target state="translated">本模块中的函数用于生成抽象表格的美观表示,这些表格适合打印。所有函数都会返回(可能是很深的)字符列表,如果表格出错,会产生错误。</target>
        </trans-unit>
        <trans-unit id="6379807804d510c1358bcad10b50d619a7c10261" translate="yes" xml:space="preserve">
          <source>The functions in this module exits with reason &lt;code&gt;badarg&lt;/code&gt; if any argument has the wrong format, if the table identifier is invalid, or if the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果任何参数的格式错误，表标识符无效或由于表访问权限（ &lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt; ）而拒绝了该操作，则此模块中的函数将以 &lt;code&gt;badarg&lt;/code&gt; 原因退出。</target>
        </trans-unit>
        <trans-unit id="407acf4eb1d452f08e4cd9870e0fbf1bd80ec28b" translate="yes" xml:space="preserve">
          <source>The functions make references to a debug structure. The debug structure is a list of &lt;code&gt;dbg_opt()&lt;/code&gt;, which is an internal data type used by function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt;. No debugging is performed if it is an empty list.</source>
          <target state="translated">这些函数引用调试结构。调试结构是 &lt;code&gt;dbg_opt()&lt;/code&gt; 的列表，该列表是函数 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 使用的内部数据类型。如果它为空列表，则不执行调试。</target>
        </trans-unit>
        <trans-unit id="95e0480086d8c1cfed57c30b1e75f554c1263ba9" translate="yes" xml:space="preserve">
          <source>The functions of this module exit the process with a &lt;code&gt;badarg&lt;/code&gt;, &lt;code&gt;bad_function&lt;/code&gt;, or &lt;code&gt;type_mismatch&lt;/code&gt; message when given badly formed arguments or sets the types of which are not compatible.</source>
          <target state="translated">当给定 &lt;code&gt;type_mismatch&lt;/code&gt; 错误的参数或设置类型不兼容的参数时，此模块的功能将使用 &lt;code&gt;badarg&lt;/code&gt; ， &lt;code&gt;bad_function&lt;/code&gt; 或type_mismatch消息退出该过程。</target>
        </trans-unit>
        <trans-unit id="8bcd836e7cff1f3fb60829e13f437e52a77a3d68" translate="yes" xml:space="preserve">
          <source>The functions returns &lt;code&gt;{module,Module}&lt;/code&gt; if the module was interpreted, otherwise &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">如果模块已解释，则函数返回 &lt;code&gt;{module,Module}&lt;/code&gt; ，否则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8c5ba17f384a51d8defb699da21623e5d4d6f29" translate="yes" xml:space="preserve">
          <source>The functions with explicit state never use the process dictionary.</source>
          <target state="translated">具有显式状态的函数从不使用进程字典。</target>
        </trans-unit>
        <trans-unit id="1dee609877073beca17837c5cc489fd792ebd7be" translate="yes" xml:space="preserve">
          <source>The functions with implicit state use the process dictionary variable &lt;code&gt;rand_seed&lt;/code&gt; to remember the current state.</source>
          <target state="translated">具有隐式状态的函数使用过程字典变量 &lt;code&gt;rand_seed&lt;/code&gt; 来记住当前状态。</target>
        </trans-unit>
        <trans-unit id="3598aafeb02f3f06b45b8fa49e0ea66cd9f4c8c2" translate="yes" xml:space="preserve">
          <source>The fundamental difference between this API and &lt;code&gt;connect/*&lt;/code&gt; is that the return value is that of the underlying OS &lt;code&gt;connect(2)&lt;/code&gt; system call. If &lt;code&gt;ok&lt;/code&gt; is returned, the result of the association establishment is received by the calling process as an &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; event. The calling process must be prepared to receive this, or poll for it using &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, depending on the value of the active option.</source>
          <target state="translated">此API和 &lt;code&gt;connect/*&lt;/code&gt; 之间的根本区别是返回值是基础操作系统 &lt;code&gt;connect(2)&lt;/code&gt; 系统调用的返回值。如果返回 &lt;code&gt;ok&lt;/code&gt; ，则关联建立的结果由调用进程作为 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 事件接收。调用程序必须准备好接收它，或使用 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 对其进行轮询，具体取决于活动选项的值。</target>
        </trans-unit>
        <trans-unit id="988b6a9c1d9ecd81d685b26b761fdee058fdc894" translate="yes" xml:space="preserve">
          <source>The gain is twofold:</source>
          <target state="translated">收益是双重的。</target>
        </trans-unit>
        <trans-unit id="bcf404e4d234a44441e22cb6261963b4fedd0d7d" translate="yes" xml:space="preserve">
          <source>The gain of using selective and exclusive decode instead of a complete decode is greater the bigger the value and the less deep in the structure you have to decode.</source>
          <target state="translated">使用选择性和排他性解码而不是完全解码的收益是值越大越好,在结构中需要解码的深度越小越好。</target>
        </trans-unit>
        <trans-unit id="fe50c99cca6dabfaacf57c3d4d8ac0b0024f73ef" translate="yes" xml:space="preserve">
          <source>The garbage collector can also shrink the heap if it is much larger than the amount of data stored on it; setting the minimum heap size prevents that.</source>
          <target state="translated">如果垃圾收集器的数据量远大于其上存储的数据量,垃圾收集器也可以收缩堆,设置最小堆大小可以防止这种情况。</target>
        </trans-unit>
        <trans-unit id="977899977ecd5bafb69cd4c8bac5e829e78b713f" translate="yes" xml:space="preserve">
          <source>The general events are as follows:</source>
          <target state="translated">一般活动如下:</target>
        </trans-unit>
        <trans-unit id="0a45457862e4fc4686a75b757e6f11948bde74a0" translate="yes" xml:space="preserve">
          <source>The general form of bit strings is &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are positive integers. It denotes a bit string that is &lt;code&gt;M + (k*N)&lt;/code&gt; bits long (that is, a bit string that starts with &lt;code&gt;M&lt;/code&gt; bits and continues with &lt;code&gt;k&lt;/code&gt; segments of &lt;code&gt;N&lt;/code&gt; bits each, where &lt;code&gt;k&lt;/code&gt; is also a positive integer). The notations &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; are convenient shorthands for the cases that &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt;, or both, are zero.</source>
          <target state="translated">位字符串的一般形式是 &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 是正整数。它表示一个长度为 &lt;code&gt;M + (k*N)&lt;/code&gt; 位的位串（即，以 &lt;code&gt;M&lt;/code&gt; 位开始并以 &lt;code&gt;k&lt;/code&gt; 个段（每个 &lt;code&gt;N&lt;/code&gt; 位）继续的位串，其中 &lt;code&gt;k&lt;/code&gt; 也是一个正整数）。对于 &lt;code&gt;M&lt;/code&gt; 或 &lt;code&gt;N&lt;/code&gt; 或两者均为零的情况，符号 &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 是方便的简写。</target>
        </trans-unit>
        <trans-unit id="15c107121f9e396eb9a5cd9589f0c40d15c3390b" translate="yes" xml:space="preserve">
          <source>The general form of map types is &lt;code&gt;#{AssociationList}&lt;/code&gt;. The key types in &lt;code&gt;AssociationList&lt;/code&gt; are allowed to overlap, and if they do, the leftmost association takes precedence. A map association has a key in &lt;code&gt;AssociationList&lt;/code&gt; if it belongs to this type. &lt;code&gt;AssociationList&lt;/code&gt; can contain both mandatory and optional association types. If an association type is mandatory, an association with that type is to be present. In the case of an optional association type it is not required for the key type to be present.</source>
          <target state="translated">地图类型的一般形式是 &lt;code&gt;#{AssociationList}&lt;/code&gt; 。允许 &lt;code&gt;AssociationList&lt;/code&gt; 中的键类型重叠，如果重叠，则最左边的关联优先。如果地图关联属于此类型，则它在 &lt;code&gt;AssociationList&lt;/code&gt; 中具有一个键。 &lt;code&gt;AssociationList&lt;/code&gt; 可以包含强制和可选的关联类型。如果关联类型是强制性的，则将存在与该类型的关联。对于可选的关联类型，不需要密钥类型。</target>
        </trans-unit>
        <trans-unit id="aa26e067e726a95a6d2e3dc44ecd0d512cccd537" translate="yes" xml:space="preserve">
          <source>The general format of a control sequence is &lt;code&gt;~F.P.PadModC&lt;/code&gt;.</source>
          <target state="translated">控制序列的一般格式为 &lt;code&gt;~F.P.PadModC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48292e72b50e679a5bd265d2003a203029b9008b" translate="yes" xml:space="preserve">
          <source>The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be &amp;lt; 65536, and the first must be less than or equal to the second. For example, the following matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;:</source>
          <target state="translated">通用重复量词通过在大括号（大括号）中用逗号分隔两个数字来指定允许的匹配的最小和最大数目。数字必须小于65536，并且第一个必须小于或等于第二个。例如，以下匹配&amp;ldquo; zz&amp;rdquo;，&amp;ldquo; zzz&amp;rdquo;或&amp;ldquo; zzzz&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="e8ceed6edc3f642d5944e6d5d983920ce28f447b" translate="yes" xml:space="preserve">
          <source>The general verbosity level is not associated with any particular category. This level sets the threshold for the standard I/O printouts, uncategorized &lt;code&gt;ct:log/print/pal&lt;/code&gt; printouts, and printouts for categories with undefined verbosity level.</source>
          <target state="translated">一般详细程度级别与任何特定类别都不相关。此级别为标准I / O打印输出，未分类 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 打印输出以及具有未定义详细级别的类别的打印输出设置阈值。</target>
        </trans-unit>
        <trans-unit id="15f1ac9edee948d6f4ef43892cbf77bf286d9bf4" translate="yes" xml:space="preserve">
          <source>The generated .script (and .boot) file uses the environment variable &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; as prefix for the paths to all applications. The &lt;code&gt;-boot_var&lt;/code&gt; option to &lt;code&gt;erl&lt;/code&gt; can be used for specifying the value of this variable, typically &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt;.</source>
          <target state="translated">生成的.script（和.boot）文件使用环境变量 &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; 作为所有应用程序路径的前缀。 &lt;code&gt;erl&lt;/code&gt; 的 &lt;code&gt;-boot_var&lt;/code&gt; 选项可用于指定此变量的值，通常是 &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c99eee4f85e52f6340a9da42977768f1eebdd2c" translate="yes" xml:space="preserve">
          <source>The generated Erlang files are placed in the current directory or in the directory specified with option &lt;code&gt;{outdir,Dir}&lt;/code&gt;.</source>
          <target state="translated">生成的Erlang文件放置在当前目录或使用选项 &lt;code&gt;{outdir,Dir}&lt;/code&gt; 指定的目录中。</target>
        </trans-unit>
        <trans-unit id="c577f200898187404181ae175171d50fcb091818" translate="yes" xml:space="preserve">
          <source>The generated Erlang module always gets the same name as the &lt;code&gt;ASN.1&lt;/code&gt; module. Therefore, only one encoding rule per &lt;code&gt;ASN.1&lt;/code&gt; module can be used at runtime.</source>
          <target state="translated">生成的Erlang模块始终与 &lt;code&gt;ASN.1&lt;/code&gt; 模块具有相同的名称。因此，每个 &lt;code&gt;ASN.1&lt;/code&gt; 模块只能在运行时使用一个编码规则。</target>
        </trans-unit>
        <trans-unit id="6fc9a629a78265b39c4931fa85c066a035d12976" translate="yes" xml:space="preserve">
          <source>The generated conversion functions are named &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; and &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt;.</source>
          <target state="translated">生成的转换函数分别名为 &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; 和 &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70590dbda20778e7131e69e54b148688eb50a6db" translate="yes" xml:space="preserve">
          <source>The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval.</source>
          <target state="translated">生成的数字是N*2.0^(-53)的形式,即;在区间内等距。</target>
        </trans-unit>
        <trans-unit id="d46f1c06452ab11c5b4b6ecb5baaa5c431f8b627" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">由于尾数中的所有位都是随机的，因此此函数所生成的数字对于较小的数字而言，其粒度比常规的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 更好。此属性与永不返回零的事实结合在一起，对于执行 &lt;code&gt;1.0 / X&lt;/code&gt; 或 &lt;code&gt;math:log(X)&lt;/code&gt; 的算法很有用。</target>
        </trans-unit>
        <trans-unit id="73171ef35be5bd8ba621019aa17e69f855a0576a" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">由于尾数中的所有位都是随机的，因此此函数所生成的数字对于较小的数字而言，其粒度比常规的 &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; 更好。此属性与永不返回零的事实结合在一起，对于执行 &lt;code&gt;1.0 / X&lt;/code&gt; 或 &lt;code&gt;math:log(X)&lt;/code&gt; 的算法很有用。</target>
        </trans-unit>
        <trans-unit id="9601b63aa3ab5a33ac60d263c74f85eedd8bb618" translate="yes" xml:space="preserve">
          <source>The generation of default functions for tables works for tables which use the &lt;code&gt;RowStatus&lt;/code&gt; textual convention from SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.</source>
          <target state="translated">表的默认功能的生成适用于使用SNMPv2中的 &lt;code&gt;RowStatus&lt;/code&gt; 文本约定的表，该约定在STANDARD-MIB和SNMPv2-TC中定义。</target>
        </trans-unit>
        <trans-unit id="a98f897827fbccc29809d0ff98a0c6185bd547f8" translate="yes" xml:space="preserve">
          <source>The generator function &lt;code&gt;GenFun&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">调用生成器函数 &lt;code&gt;GenFun&lt;/code&gt; 生成测试集。</target>
        </trans-unit>
        <trans-unit id="1f65b0f29d2eaf723597fb4ded6e5f61662cb2a0" translate="yes" xml:space="preserve">
          <source>The generator now contains unbound variables and the test has been moved into the filter.</source>
          <target state="translated">生成器现在包含未绑定的变量,并且测试已被移到过滤器中。</target>
        </trans-unit>
        <trans-unit id="df67d175f37e161fc283f4c21214ba8ff79c07f4" translate="yes" xml:space="preserve">
          <source>The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment:</source>
          <target state="translated">通用URI语法由一个分层的组件序列组成,分别称为scheme、authority、path、query和fragment。</target>
        </trans-unit>
        <trans-unit id="edcc58c1f9412f2d84d5eca2fbc303265ca32bc7" translate="yes" xml:space="preserve">
          <source>The generic encode and decode functions can be called as follows:</source>
          <target state="translated">可以调用通用的编码和解码函数,具体如下。</target>
        </trans-unit>
        <trans-unit id="a6a0f25dc460ac798f2b85a01f268cff421ca237" translate="yes" xml:space="preserve">
          <source>The generic full name of the file is thus:</source>
          <target state="translated">因此,该文件的通用全称是:</target>
        </trans-unit>
        <trans-unit id="953d4c56983eabeb70f721a6678334568e77d77a" translate="yes" xml:space="preserve">
          <source>The given BEAM file (with or without the &lt;code&gt;.beam&lt;/code&gt; extension) or the file found by calling &lt;code&gt;code:which(Module)&lt;/code&gt; is checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">给定的BEAM文件（具有或不具有 &lt;code&gt;.beam&lt;/code&gt; 扩展名）或通过调用 &lt;code&gt;code:which(Module)&lt;/code&gt; 找到的文件，将检查是否 &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 以及未使用的本地函数。代码路径用作 &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e66a4ab696e12e0f12a8dd69e7f5bb33fedf0273" translate="yes" xml:space="preserve">
          <source>The global name server also performs the critical task of continuously monitoring changes in node configuration. If a node that runs a globally registered process goes down, the name is globally unregistered. To this end, the global name server subscribes to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages sent from module &lt;code&gt;net_kernel&lt;/code&gt;. Relevant Kernel application variables in this context are &lt;code&gt;net_setuptime&lt;/code&gt;, &lt;code&gt;net_ticktime&lt;/code&gt;, and &lt;code&gt;dist_auto_connect&lt;/code&gt;. See also &lt;code&gt;kernel(6)&lt;/code&gt;.</source>
          <target state="translated">全局名称服务器还执行关键任务，即不断监视节点配置中的更改。如果运行全局注册的进程的节点发生故障，则该名称将在全局范围内取消注册。为此，全局名称服务器订阅从模块 &lt;code&gt;net_kernel&lt;/code&gt; 发送的 &lt;code&gt;nodeup&lt;/code&gt; 和 &lt;code&gt;nodedown&lt;/code&gt; 消息。在此上下文中，相关的内核应用程序变量是 &lt;code&gt;net_setuptime&lt;/code&gt; ， &lt;code&gt;net_ticktime&lt;/code&gt; 和 &lt;code&gt;dist_auto_connect&lt;/code&gt; 。另请参阅 &lt;code&gt;kernel(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f36454620d0c52943c78b70c7b2d67415456c6b" translate="yes" xml:space="preserve">
          <source>The global name server keeps track of all processes sharing the same lock, that is, if two processes set the same lock, both processes must delete the lock.</source>
          <target state="translated">全局名称服务器会跟踪所有共享同一个锁的进程,也就是说,如果两个进程设置了同一个锁,两个进程都必须删除这个锁。</target>
        </trans-unit>
        <trans-unit id="46c28148b1520b8f7f30b407f534c21425582a89" translate="yes" xml:space="preserve">
          <source>The global state of the scanner, represented by the #xmerl_scanner{} record.</source>
          <target state="translated">扫描仪的全局状态,由#xmerl_scanner{}记录表示。</target>
        </trans-unit>
        <trans-unit id="162600e8983ca6d0de97e2e5c21045cca4665270" translate="yes" xml:space="preserve">
          <source>The global state of the validator. It is representated by the &lt;code&gt;#xsd_state{}&lt;/code&gt; record.</source>
          <target state="translated">验证器的全局状态。它由 &lt;code&gt;#xsd_state{}&lt;/code&gt; 记录表示。</target>
        </trans-unit>
        <trans-unit id="1531d8568b38b4970f1055504bbf9c235ba48c8c" translate="yes" xml:space="preserve">
          <source>The grammar starts with an optional &lt;code&gt;header&lt;/code&gt; section. The header is put first in the generated file, before the module declaration. The purpose of the header is to provide a means to make the documentation generated by EDoc look nicer. Each header line should be enclosed in double quotes, and newlines will be inserted between the lines. For example:</source>
          <target state="translated">语法以可选的 &lt;code&gt;header&lt;/code&gt; 部分开始。标头放在模块声明之前，首先放在生成的文件中。标头的目的是提供一种使EDoc生成的文档看起来更好的方法。每个标题行都应该用双引号引起来，并且在行之间插入换行符。例如：</target>
        </trans-unit>
        <trans-unit id="95e4974bf09526a8ed59c2c706017450837fabc7" translate="yes" xml:space="preserve">
          <source>The granularity of both measurement types can be high. Therefore, ensure that each individual measurement lasts for at least several seconds.</source>
          <target state="translated">这两种测量类型的颗粒度可能很高。因此,确保每个单独的测量至少持续几秒钟。</target>
        </trans-unit>
        <trans-unit id="db89aebec1f27ef7ea7b0173203949ea669de4bc" translate="yes" xml:space="preserve">
          <source>The graphical library &lt;code&gt;wx&lt;/code&gt; has extensive support for Unicode text.</source>
          <target state="translated">图形库 &lt;code&gt;wx&lt;/code&gt; 对Unicode文本有广泛的支持。</target>
        </trans-unit>
        <trans-unit id="3809a7766a11eb66968ebebc3b973ccfe307fc2b" translate="yes" xml:space="preserve">
          <source>The group information properties override those set with the suite information function, and can in turn be overridden by test case information properties. For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">组信息属性会覆盖使用套件信息功能设置的属性，并且可以依次被测试用例信息属性所覆盖。有关有效信息属性和更多常规信息的列表，请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1851720cf81d08f4729a487b12a49fba130b63d" translate="yes" xml:space="preserve">
          <source>The group leader should be rarely changed in applications with a supervision tree, because OTP assumes the group leader of their processes is their application master.</source>
          <target state="translated">在有监督树的应用程序中,组长应该很少改变,因为OTP假设他们的进程的组长是他们的应用程序主控。</target>
        </trans-unit>
        <trans-unit id="e52640716213a6b8b724c7b3e51f40080bcd9da2" translate="yes" xml:space="preserve">
          <source>The group path specification does not necessarily have to include &lt;strong&gt;all&lt;/strong&gt; groups in the path to the terminating group. &lt;code&gt;Common Test&lt;/code&gt; searches for all matching paths if an incomplete group path is specified.</source>
          <target state="translated">组路径规范并不一定必须在终止组的路径中包括&lt;strong&gt;所有&lt;/strong&gt;组。如果指定了不完整的组路径， &lt;code&gt;Common Test&lt;/code&gt; 将搜索所有匹配的路径。</target>
        </trans-unit>
        <trans-unit id="6fc0b568a02963a296071a7bbdb0400eec8c4cbb" translate="yes" xml:space="preserve">
          <source>The group specification feature, as presented in this section, can also be used in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; (with some extra features added).</source>
          <target state="translated">本节中介绍的组规范功能也可以在 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; （添加了一些额外的功能）。</target>
        </trans-unit>
        <trans-unit id="75d39fc54f161038ac9929455075c4ce189bfbf6" translate="yes" xml:space="preserve">
          <source>The groups are given explicitly in this list. There may be several elements with the same &lt;code&gt;Size&lt;/code&gt;. In such a case, the server will choose one randomly in the negotiated Size.</source>
          <target state="translated">这些组在此列表中明确给出。可能有几个具有相同 &lt;code&gt;Size&lt;/code&gt; 的元素。在这种情况下，服务器将在协商的大小中随机选择一个。</target>
        </trans-unit>
        <trans-unit id="57c1aab7095657e5f03ad172fdff464c6e0393b1" translate="yes" xml:space="preserve">
          <source>The guard BIFs: &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;, &lt;code&gt;hd&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;tl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">警卫队BIF： &lt;code&gt;abs&lt;/code&gt; ， &lt;code&gt;element&lt;/code&gt; ， &lt;code&gt;hd&lt;/code&gt; ， &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;node&lt;/code&gt; ， &lt;code&gt;round&lt;/code&gt; ， &lt;code&gt;size&lt;/code&gt; ， &lt;code&gt;tl&lt;/code&gt; ， &lt;code&gt;trunc&lt;/code&gt; ， &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf11284c55c81df64e31546d61edba51bacfcf93" translate="yes" xml:space="preserve">
          <source>The guard section can contain any guard expression of Erlang. The following is a list of BIFs and expressions:</source>
          <target state="translated">守护部分可以包含Erlang的任何守护表达式。下面是BIF和表达式的列表。</target>
        </trans-unit>
        <trans-unit id="08f011ebed41a7bf74303ee2b30d0e5329b2ea66" translate="yes" xml:space="preserve">
          <source>The guard sequence, if any, is true.</source>
          <target state="translated">守护序列,如果有,则为真。</target>
        </trans-unit>
        <trans-unit id="49c4b028972dd181f72352fd5792e1cbd70780a8" translate="yes" xml:space="preserve">
          <source>The handler has an overload protection mechanism that keeps the handler process and the Kernel application alive during high loads of log events. How overload protection works, and how to configure it, is described in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理程序具有过载保护机制，可在大量日志事件期间使处理程序进程和内核应用程序保持活动状态。 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 介绍了过载保护的工作原理以及如何对其进行配置。</target>
        </trans-unit>
        <trans-unit id="2de57b137d6629cde5167564ce3d26dcfae749ef" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config1&lt;/code&gt;.</source>
          <target state="translated">处理程序标识与 &lt;code&gt;Config1&lt;/code&gt; 中的 &lt;code&gt;id&lt;/code&gt; 密钥相关联。</target>
        </trans-unit>
        <trans-unit id="4eeb6be906051436af44ca3913114022b11b4c8a" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">处理程序标识与 &lt;code&gt;Config&lt;/code&gt; 中的 &lt;code&gt;id&lt;/code&gt; 键关联。</target>
        </trans-unit>
        <trans-unit id="88387fc69eaf6d2117329bee1a573a3818611863" translate="yes" xml:space="preserve">
          <source>The handler is not overload protected.</source>
          <target state="translated">该处理程序不受过载保护。</target>
        </trans-unit>
        <trans-unit id="d7cc7f26c0b9fef31e9d9003214e5eb8f80f6985" translate="yes" xml:space="preserve">
          <source>The handler must log the event.</source>
          <target state="translated">处理程序必须记录该事件。</target>
        </trans-unit>
        <trans-unit id="91c3bfd8524a78feb62740d6ae1b2a4f89bcfb08" translate="yes" xml:space="preserve">
          <source>The handler process keeps track of the length of its message queue and takes some form of action when the current length exceeds a configurable threshold. The purpose is to keep the handler in, or to as quickly as possible get the handler into, a state where it can keep up with the pace of incoming log events. The memory use of the handler must never grow larger and larger, since that will eventually cause the handler to crash. These three thresholds, with associated actions, exist:</source>
          <target state="translated">处理程序会跟踪消息队列的长度,并在当前长度超过可配置的阈值时采取某种形式的行动。这样做的目的是使处理程序处于或尽快使处理程序进入一个能够跟上传入的日志事件的速度的状态。处理器的内存使用量决不能越来越大,因为这最终会导致处理器崩溃。这三个阈值,以及相关的动作,都是存在的。</target>
        </trans-unit>
        <trans-unit id="d669a7746b992304543fe0d69213b6644ee12b90" translate="yes" xml:space="preserve">
          <source>The handlers are called in sequence, and the order is not defined.</source>
          <target state="translated">处理程序是按顺序调用的,顺序没有定义。</target>
        </trans-unit>
        <trans-unit id="fa6b9a858fe6ebad4a9654a225cc08daa061a060" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated, and Perl has changed in recent releases, causing PCRE also to change. Outside a character class, PCRE reads the digit and any following digits as a decimal number. If the number is &amp;lt; 8, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a &lt;strong&gt;back reference&lt;/strong&gt;. A description of how this works is provided later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">反斜杠后跟0以外的数字的处理非常复杂，并且Perl在最新版本中已更改，从而导致PCRE也发生了更改。在字符类之外，PCRE读取该数字及其后的任何数字作为十进制数字。如果数字&amp;lt;8，或者在表达式中至少有许多以前捕获的左括号，则将整个序列用作&lt;strong&gt;反向引用&lt;/strong&gt;。在讨论带括号的子模式之后，稍后将提供有关其工作方式的描述。</target>
        </trans-unit>
        <trans-unit id="ce133ffa97494a3447425009d85e45fe4a4884e0" translate="yes" xml:space="preserve">
          <source>The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship is that both involve newlines. Dot has no special meaning in a character class.</source>
          <target state="translated">点的处理完全独立于圆点和美元的处理,唯一的关系是两者都涉及到换行。点在字符类中没有特殊意义。</target>
        </trans-unit>
        <trans-unit id="75675acc51f4abea249c539fbe54b590467b1b3e" translate="yes" xml:space="preserve">
          <source>The handshake will continue, but &lt;code&gt;A&lt;/code&gt; is informed that &lt;code&gt;B&lt;/code&gt; has another ongoing connection attempt that will be shut down (simultaneous connect where &lt;code&gt;A&lt;/code&gt;'s name is greater than &lt;code&gt;B&lt;/code&gt;'s name, compared literally).</source>
          <target state="translated">握手将继续，但会通知 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 正在关闭另一正在进行的连接尝试（从字面上比较， &lt;code&gt;A&lt;/code&gt; 的名称大于 &lt;code&gt;B&lt;/code&gt; 的名称的同时连接）。</target>
        </trans-unit>
        <trans-unit id="aff3a3821cc248a671eac45e5517c958f3438bd4" translate="yes" xml:space="preserve">
          <source>The handshake will continue.</source>
          <target state="translated">握手会继续。</target>
        </trans-unit>
        <trans-unit id="c48205cabd15c9a3f6c801a9934891e2a4ee54fe" translate="yes" xml:space="preserve">
          <source>The handshake will not continue, as &lt;code&gt;B&lt;/code&gt; already has an ongoing handshake, which it itself has initiated (simultaneous connect where &lt;code&gt;B&lt;/code&gt;'s name is greater than &lt;code&gt;A&lt;/code&gt;'s).</source>
          <target state="translated">握手将不会继续，因为 &lt;code&gt;B&lt;/code&gt; 本身已经发起了正在进行的握手（在 &lt;code&gt;B&lt;/code&gt; 的名称大于 &lt;code&gt;A&lt;/code&gt; 的同时进行连接）。</target>
        </trans-unit>
        <trans-unit id="4a492d4993cb9390498042b969391a3f2772dbec" translate="yes" xml:space="preserve">
          <source>The hardware watchdog timer, which is controlled by the &lt;code&gt;heart&lt;/code&gt; port program, requires package &lt;code&gt;FORCEvme&lt;/code&gt;, which contains the VME bus driver, to be installed. However, this driver can clash with the Sun &lt;code&gt;mcp&lt;/code&gt; driver and cause the system to refuse to boot. To cure this problem, the following lines are to be added to &lt;code&gt;/etc/system&lt;/code&gt;:</source>
          <target state="translated">硬件监视程序计时器由 &lt;code&gt;heart&lt;/code&gt; 端口程序控制，需要安装包含VME总线驱动程序的软件包 &lt;code&gt;FORCEvme&lt;/code&gt; 。但是，此驱动程序可能与Sun &lt;code&gt;mcp&lt;/code&gt; 驱动程序冲突，并导致系统拒绝引导。要解决此问题，请将以下行添加到 &lt;code&gt;/etc/system&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="9e6408f5b48151485bdfcfab3159c61f5c8fa341" translate="yes" xml:space="preserve">
          <source>The head element of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">列表 &lt;code&gt;t&lt;/code&gt; 的head元素。</target>
        </trans-unit>
        <trans-unit id="5798187c9bcc3504a1324e24484f637b68bd2984" translate="yes" xml:space="preserve">
          <source>The head of the &lt;code&gt;modify_algs_list()&lt;/code&gt; modifies &lt;code&gt;A&lt;/code&gt; giving the result &lt;code&gt;A'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modify_algs_list()&lt;/code&gt; 的头将 &lt;code&gt;A&lt;/code&gt; 修改为结果 &lt;code&gt;A'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4983c0390f19223c1a70e5dfad48870fe4110265" translate="yes" xml:space="preserve">
          <source>The head of the fun is a head matching (or mismatching) &lt;strong&gt;one&lt;/strong&gt; parameter, one object of the table we select from. The object is always a single variable (can be &lt;code&gt;_&lt;/code&gt;) or a tuple, as ETS, Dets, and Mnesia tables include that. The match specification returned by &lt;code&gt;ets:fun2ms/1&lt;/code&gt; can be used with &lt;code&gt;dets:select/2&lt;/code&gt; and &lt;code&gt;mnesia:select/2&lt;/code&gt;, and with &lt;code&gt;ets:select/2&lt;/code&gt;. The use of &lt;code&gt;=&lt;/code&gt; in the head is allowed (and encouraged) at the top-level.</source>
          <target state="translated">乐趣的头是一个头匹配（或不匹配）&lt;strong&gt;一个&lt;/strong&gt;参数，即我们从中选择的表的一个对象。对象始终是单个变量（可以是 &lt;code&gt;_&lt;/code&gt; ）或元组，因为ETS，Dets和Mnesia表包括该对象。 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 返回的匹配规范可以与 &lt;code&gt;dets:select/2&lt;/code&gt; 和 &lt;code&gt;mnesia:select/2&lt;/code&gt; 以及 &lt;code&gt;ets:select/2&lt;/code&gt; 一起使用。在顶层允许（并鼓励）在头部使用 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91864c391383ab349ccd4d45371e04aafcfcc9ac" translate="yes" xml:space="preserve">
          <source>The header and objects in the file are checksummed using the built-in MD5 functions. The MD5 sum of all objects is written in the file footer, so that verification while reading detects the slightest bitflip in the file data. Using this costs a fair amount of CPU time.</source>
          <target state="translated">文件头和文件中的对象使用内置的MD5函数进行校验和。所有对象的MD5和写在文件的页脚中,这样在读取时的校验就能检测到文件数据中最细微的位错。使用这种方式会耗费相当多的CPU时间。</target>
        </trans-unit>
        <trans-unit id="2eb240ffbba0a0a325acedfed500d5fbbd4064ac" translate="yes" xml:space="preserve">
          <source>The header includes some system information:</source>
          <target state="translated">头部包括一些系统信息。</target>
        </trans-unit>
        <trans-unit id="68595adcb3ea51d515a7e1ae094708cbf3e1144b" translate="yes" xml:space="preserve">
          <source>The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">标头&lt;strong&gt;未&lt;/strong&gt;剥离。</target>
        </trans-unit>
        <trans-unit id="882ae0c9d1778c987cd41c3f90417de21ef032f7" translate="yes" xml:space="preserve">
          <source>The header name will be in lower case and should not be altered.</source>
          <target state="translated">头部名称将采用小写,不应更改。</target>
        </trans-unit>
        <trans-unit id="af3ed8fba11aa29a77ab51965b8edb72b975c8e9" translate="yes" xml:space="preserve">
          <source>The header of the Erlang script in the example differs from a normal Erlang module. The first line is intended to be the interpreter line, which invokes &lt;code&gt;escript&lt;/code&gt;.</source>
          <target state="translated">示例中的Erlang脚本的标头与普通的Erlang模块不同。第一行旨在作为解释器行，它调用 &lt;code&gt;escript&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aef96215b80c7223d8af26cee2243d32f40daa22" translate="yes" xml:space="preserve">
          <source>The heap size of a process is quite hard to predict, especially the amount of memory that is used during the garbage collection. When contemplating using this option, it is recommended to first run it in production with &lt;code&gt;kill&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and inspect the log events to see what the normal peak sizes of the processes in the system is and then tune the value accordingly.</source>
          <target state="translated">进程的堆大小很难预测，尤其是在垃圾回收期间使用的内存量。考虑使用此选项时，建议先在 &lt;code&gt;kill&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 的生产环境中运行它，然后检查日志事件以查看系统中进程的正常峰值大小，然后相应地调整该值。</target>
        </trans-unit>
        <trans-unit id="5e2e37a09af7e8f1d009a1717a88fe618ed3d52c" translate="yes" xml:space="preserve">
          <source>The heavyweight commit protocol is also non-blocking, which allows the surviving participants and their coordinator to finish the transaction regardless (even if a node crashes in the middle of the commit protocol). When a node fails at startup, &lt;code&gt;Mnesia&lt;/code&gt; determines the outcome of the transaction and recovers it. Lightweight protocols, heavyweight protocols, and dirty updates, are dependent on other nodes to be operational to make the correct heavyweight transaction recovery decision.</source>
          <target state="translated">重量级提交协议也是非阻塞的，这使幸存的参与者及其协调者无论完成什么事务都可以完成事务（即使节点在提交协议中间崩溃）。当节点在启动时发生故障时， &lt;code&gt;Mnesia&lt;/code&gt; 会确定事务的结果并进行恢复。轻量级协议，重量级协议和脏更新依赖于其他节点才能进行操作，以做出正确的重量级事务恢复决策。</target>
        </trans-unit>
        <trans-unit id="cafb3c516580a793b7de731b14722e5eebd23ea8" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;h...&lt;/code&gt;.</source>
          <target state="translated">十六进制值 &lt;code&gt;h...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11e5e2ec0fa10fbdd5f8dd78491bb19a12164f59" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;hh&lt;/code&gt;.</source>
          <target state="translated">十六进制值 &lt;code&gt;hh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74f0a534d2309926a7d494022615e9a9b4923160" translate="yes" xml:space="preserve">
          <source>The highest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="translated">这个节点能够处理的最高发行版本。在Erlang/OTP R6B及以后的版本中,这个值是5。</target>
        </trans-unit>
        <trans-unit id="0a981eec686f456d91d8a6bc03a6775c554a6fb0" translate="yes" xml:space="preserve">
          <source>The home directory:</source>
          <target state="translated">家目录。</target>
        </trans-unit>
        <trans-unit id="2e797c1729cd1e5a1ad1f79c83782a1c6c07da5c" translate="yes" xml:space="preserve">
          <source>The hook function should return either the data to be exported, or a tuple &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt;, or a tuple &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt;, where &lt;code&gt;Content&lt;/code&gt; is a content list (which can be on simple-form; see &lt;code&gt;export_simple/2&lt;/code&gt; for details).</source>
          <target state="translated">hook函数应该返回要导出的数据，或者返回一个元组 &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt; ，或者返回一个元组 &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt; ，其中 &lt;code&gt;Content&lt;/code&gt; 为内容列表（可以是简单形式；有关详细信息，请参见 &lt;code&gt;export_simple/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4a1cb12a27b6d6707a5d80ba125a5cfb6386b02f" translate="yes" xml:space="preserve">
          <source>The hook options can also be specified in a configuration file with configuration variable &lt;code&gt;ct_conn_log&lt;/code&gt;:</source>
          <target state="translated">挂钩选项也可以在配置文件中使用配置变量 &lt;code&gt;ct_conn_log&lt;/code&gt; 来指定：</target>
        </trans-unit>
        <trans-unit id="44ea7e5b4f10ff2cea08d024c8bb140192260555" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are allowed access.</source>
          <target state="translated">主机 &lt;code&gt;123.34.56.11&lt;/code&gt; 和 &lt;code&gt;150.100.23&lt;/code&gt; 子网中的所有计算机都被允许访问。</target>
        </trans-unit>
        <trans-unit id="e966a241193fc6bb63b6fabbd2c9e1a2a953a3a8" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are not allowed access.</source>
          <target state="translated">&lt;code&gt;123.34.56.11&lt;/code&gt; 主机123.34.56.11和 &lt;code&gt;150.100.23&lt;/code&gt; 子网上的所有计算机。</target>
        </trans-unit>
        <trans-unit id="6b0786bc370f61e14470bf6a8ad6a449f7a915d2" translate="yes" xml:space="preserve">
          <source>The host keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 更改主机密钥目录。</target>
        </trans-unit>
        <trans-unit id="d878e97eeb73ea425731416807f352daf86ada0a" translate="yes" xml:space="preserve">
          <source>The hrl generated from a dictionary specification defines records for the messages and grouped AVPs defined in &lt;code&gt;@messages&lt;/code&gt; and &lt;code&gt;@grouped&lt;/code&gt; sections. For each message or grouped AVP definition, a record is defined whose name is the message or AVP name, prefixed with any dictionary prefix defined with &lt;code&gt;@prefix&lt;/code&gt;, and whose fields are the names of the AVPs contained in the message or grouped AVP in the order specified in the definition in question. For example, the grouped AVP</source>
          <target state="translated">从字典规范生成的hrl定义了在 &lt;code&gt;@messages&lt;/code&gt; 和 &lt;code&gt;@grouped&lt;/code&gt; 部分中定义的消息和分组AVP的记录。对于每个消息或分组的AVP定义，定义一条记录，其名称为消息或AVP名称，并以 &lt;code&gt;@prefix&lt;/code&gt; 定义的任何字典前缀作为前缀，并且其字段是消息或分组的AVP中按顺序排列的AVP的名称。在相关定义中指定。例如，分组的AVP</target>
        </trans-unit>
        <trans-unit id="962862212161f4c21176923512e551b47c09f8ac" translate="yes" xml:space="preserve">
          <source>The id of the child specification cannot be changed.</source>
          <target state="translated">子规格的id不能改变。</target>
        </trans-unit>
        <trans-unit id="f091d047abb87ec231553541a5fdb6a8b0e0548d" translate="yes" xml:space="preserve">
          <source>The idea is that it either matches a single character, or two identical characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it does not work if the pattern is longer than three characters. Consider the subject string &quot;abcba&quot;.</source>
          <target state="translated">这个想法是,它要么匹配一个单一的字符,要么匹配两个相同的字符,围绕着一个子词组。在Perl中,这种模式是有效的;而在PCRE中,如果模式长于三个字符,它就不起作用。考虑一下主题字符串 &quot;abcba&quot;。</target>
        </trans-unit>
        <trans-unit id="b7b5bed6fe9a9f3870ec94f665573cd5c7dd092c" translate="yes" xml:space="preserve">
          <source>The idea is to have a &lt;code&gt;Common Test&lt;/code&gt; test suite calling a property testing tool with special property test suites as defined by that tool. The usual Erlang application directory structure is assumed. The tests are collected in the &lt;code&gt;test&lt;/code&gt; directory of the application. The &lt;code&gt;test&lt;/code&gt; directory has a subdirectory &lt;code&gt;property_test&lt;/code&gt;, where everything needed for the property tests is collected.</source>
          <target state="translated">这个想法是让 &lt;code&gt;Common Test&lt;/code&gt; 测试套件调用一个属性测试工具，以及该工具定义的特殊属性测试套件。假定使用通常的Erlang应用程序目录结构。测试收集在应用程序的 &lt;code&gt;test&lt;/code&gt; 目录中。该 &lt;code&gt;test&lt;/code&gt; 目录下有一个子目录 &lt;code&gt;property_test&lt;/code&gt; ，其中所需性能测试一切都被收集。</target>
        </trans-unit>
        <trans-unit id="874f09de1158faee11366ea5b25b0d18155a826f" translate="yes" xml:space="preserve">
          <source>The idea is to write something like:</source>
          <target state="translated">我们的想法是写一些像。</target>
        </trans-unit>
        <trans-unit id="35794ac2165e7b77623ae5db4356014c0f1e5071" translate="yes" xml:space="preserve">
          <source>The identifier for the table. If the table is a &lt;code&gt;named_table&lt;/code&gt;, this is the name.</source>
          <target state="translated">表的标识符。如果表是 &lt;code&gt;named_table&lt;/code&gt; ，则为名称。</target>
        </trans-unit>
        <trans-unit id="948f1754e2dc2f5e9da0d93fd230e4e30fc1f680" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller identifier created by the acceptor process. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">接受者进程创建的分发控制器标识符的标识符。传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcd66a26de4ddbf0baac1e4c1845007eafbabac4" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller.</source>
          <target state="translated">分销控制器的标识符。</target>
        </trans-unit>
        <trans-unit id="727ced51237452469691fc0707b1de9d7db70736" translate="yes" xml:space="preserve">
          <source>The identifier, an arbitrary string, should be reused whenever the same application (or node) wants to start the process. &lt;code&gt;nteventlog&lt;/code&gt; is informed about all events that have arrived to the eventlog since the last accepted message for the current identifier. As long as the same identifier is used, the same eventlog record will not be sent to &lt;code&gt;nteventlog&lt;/code&gt; more than once (with the exception of when graved system failures arise, in which case the last records written before the failure may be sent to Erlang again after reboot).</source>
          <target state="translated">每当同一应用程序（或节点）想要启动该进程时，都应重用该标识符（任意字符串）。 &lt;code&gt;nteventlog&lt;/code&gt; 被告知有关自当前标识符的最后一条接受消息以来到达事件日志的所有事件的信息。只要使用了相同的标识符，相同的 &lt;code&gt;nteventlog&lt;/code&gt; 记录就不会多次发送到nteventlog（例外情况是发生严重系统故障时例外，在这种情况下，在故障之前写入的最后一条记录可能会在之后发送到Erlang）重启）。</target>
        </trans-unit>
        <trans-unit id="cf2c592a7835be79474c810d342bb74da9b68ee0" translate="yes" xml:space="preserve">
          <source>The identity (handle) of a connection.</source>
          <target state="translated">连接的标识(句柄)。</target>
        </trans-unit>
        <trans-unit id="8db0de3330260ae6e24af59a9d387dbcefe2afa7" translate="yes" xml:space="preserve">
          <source>The identity of a server, specified in a configuration file.</source>
          <target state="translated">服务器的身份,在配置文件中指定。</target>
        </trans-unit>
        <trans-unit id="be2c0371fbc7fc4fed32a1fa7d6f534addbd004b" translate="yes" xml:space="preserve">
          <source>The implemenation of the distribution driver is not completely covered here, details about buffering and other things unrelated to driver writing are not explained. Likewise are some peculiarities of the UDS protocol not explained in detail. The chosen protocol is not important.</source>
          <target state="translated">这里没有完全介绍分发驱动的实现,关于缓冲和其他与驱动编写无关的细节没有解释。同样是UDS协议的一些特殊性也没有详细解释。所选协议并不重要。</target>
        </trans-unit>
        <trans-unit id="8024f6f807f5eee458a55b3f38fa11d2c9f7c8b5" translate="yes" xml:space="preserve">
          <source>The implementation based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__atomic_*&lt;/code&gt; builtins.</source>
          <target state="translated">基于 &lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__atomic_*&lt;/code&gt; 内置函数的实现。</target>
        </trans-unit>
        <trans-unit id="d22b507e359bf39c3398b52ef33d5269e6b83f2b" translate="yes" xml:space="preserve">
          <source>The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks applications that expect a specific output for a specified seed. The output is still deterministic number series, but different compared to releases older than R15. Seed &lt;code&gt;{0,0,0}&lt;/code&gt; does, for example, no longer produce a flawed series of only zeros.</source>
          <target state="translated">实现在Erlang / OTP R15中进行了更改。升级到R15会中断那些期望为指定种子提供特定输出的应用程序。输出仍然是确定性的数字序列，但与R15之前的版本相比有所不同。例如，种子 &lt;code&gt;{0,0,0}&lt;/code&gt; 不再产生仅零的有缺陷序列。</target>
        </trans-unit>
        <trans-unit id="17794ee5af2140bd9337aefc9afc392b9c6a3f30" translate="yes" xml:space="preserve">
          <source>The implementation of a system tracer process that produces this printout can look like this:</source>
          <target state="translated">产生这种打印输出的系统跟踪过程的实现可以是这样的。</target>
        </trans-unit>
        <trans-unit id="b110452523f370779c51e763c1f9fff3540f763c" translate="yes" xml:space="preserve">
          <source>The implementation of a test case. Call the functions to test and check the result. If something fails, ensure the function causes a runtime error or call &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; (which also causes the test case process to terminate).</source>
          <target state="translated">执行一个测试用例。调用函数进行测试并检查结果。如果失败，请确保该函数导致运行时错误或调用 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; （这也会导致测试用例进程终止）。</target>
        </trans-unit>
        <trans-unit id="7fde479db40a86f01a45d84f1970e3229f422aaa" translate="yes" xml:space="preserve">
          <source>The implementation of different asynchronous signals in the virtual machine can vary over time, but the behavior always respects this concept of asynchronous signals being passed between entities as described above.</source>
          <target state="translated">不同的异步信号在虚拟机中的实现可以随着时间的推移而变化,但行为总是尊重这种异步信号在实体之间传递的概念,如上所述。</target>
        </trans-unit>
        <trans-unit id="78fb563a772c1aec013eb172f1594ea4c2023024" translate="yes" xml:space="preserve">
          <source>The implementation of lookbehind assertions is, for each alternative, to move the current position back temporarily by the fixed length and then try to match. If there are insufficient characters before the current position, the assertion fails.</source>
          <target state="translated">lookbehind断言的实现方式是,对于每一个备选方案,将当前位置暂时后移固定长度,然后尝试匹配。如果当前位置前的字符不足,则断言失败。</target>
        </trans-unit>
        <trans-unit id="47c1e5901ab1f453c1b563ce5cd6710f3f98aaf0" translate="yes" xml:space="preserve">
          <source>The implementation of the port mechanism depends on the platform. For UNIX, pipes are used and the external program is assumed to read from standard input and write to standard output. The external program can be written in any programming language as long as it can handle the interprocess communication mechanism with which the port is implemented.</source>
          <target state="translated">端口机制的实现取决于平台。对于 UNIX,使用管道,并假定外部程序从标准输入读取并写入标准输出。外部程序可以用任何编程语言编写,只要它能处理实现端口的进程间通信机制。</target>
        </trans-unit>
        <trans-unit id="478af3e7f92746327d6e9ba13837a8097b170322" translate="yes" xml:space="preserve">
          <source>The implementation of the statistic counters is lightweight. I.e. the statistic counters are handled separately by different entities of the application. For instance our two transport module(s) (see &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;) maintain their own counters and the application engine (see &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt;) maintain its own counters.</source>
          <target state="translated">统计计数器的实现是轻量级的。即，统计计数器由应用程序的不同实体分别处理。例如，我们的两个传输模块（请参阅 &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; ）维护自己的计数器，而应用程序引擎（请参见 &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt; ）维护自己的计数器。</target>
        </trans-unit>
        <trans-unit id="298d2d2a07f7dd0f09f6657d3ded4573b0d17570" translate="yes" xml:space="preserve">
          <source>The implementation of this function is based on the &lt;code&gt;terminate&lt;/code&gt; system message, and requires that the process handles system messages correctly. For information about system messages, see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; and section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">此功能的实现基于 &lt;code&gt;terminate&lt;/code&gt; 系统消息，并且要求该进程正确处理系统消息。有关系统消息的信息，请参见OTP设计原则中的 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;sys and proc_lib&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="8382bdd6585df4f1f98e136541a6143a6f059e2f" translate="yes" xml:space="preserve">
          <source>The implementation provided by Erlang/OTP.</source>
          <target state="translated">由Erlang/OTP提供的实现。</target>
        </trans-unit>
        <trans-unit id="8260c038977748412f519079cece24fe64e2829f" translate="yes" xml:space="preserve">
          <source>The implementation using ets tables introduces a semantic incompatibility with older implementations. In those older implementations, using pure Erlang terms, the index was garbage collected like any other Erlang term and did not have to be deleted when discarded. An ets table is deleted only when the process creating it explicitly deletes it or when the creating process terminates.</source>
          <target state="translated">使用ets表的实现引入了与旧实现的语义不兼容。在那些旧的实现中,使用纯Erlang术语,索引就像其他Erlang术语一样被垃圾收集,并且在丢弃时不必删除。一个ets表只有在创建它的进程明确删除它或创建进程终止时才会被删除。</target>
        </trans-unit>
        <trans-unit id="d24ced9c8492598a6342e78545fd97461c5c3534" translate="yes" xml:space="preserve">
          <source>The important line is the last line in the function: the &lt;code&gt;do_read&lt;/code&gt; routine is called to handle new input. The remaining function handles input on a listen socket, which means that it is to be possible to do an accept on the socket, which is also recognized as a read event.</source>
          <target state="translated">重要的一行是函数的最后一行：调用 &lt;code&gt;do_read&lt;/code&gt; 例程以处理新输入。其余函数处理侦听套接字上的输入，这意味着可以在套接字上执行接受，这也被视为读取事件。</target>
        </trans-unit>
        <trans-unit id="d0e9c528ecacf2cef07eb906cdbaca615ae9bccf" translate="yes" xml:space="preserve">
          <source>The imported variables are replaced by match specification &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang funs. However, local or global function calls cannot be in the guard or body of the fun. Calls to built-in match specification functions is of course allowed:</source>
          <target state="translated">导入的变量将替换为匹配规范 &lt;code&gt;const&lt;/code&gt; 表达式，这与对Erlang funs的静态作用域一致。但是，本地或全局函数调用不能处于保护范围内。当然，可以调用内置的匹配规范函数：</target>
        </trans-unit>
        <trans-unit id="acfda62ec5b11dd2be3e7e609916ea872e30b97c" translate="yes" xml:space="preserve">
          <source>The imported variables will be replaced by match_spec &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang &lt;code&gt;fun()&lt;/code&gt;s. Local or global function calls can not be in the guard or body of the fun however. Calls to builtin match_spec functions of course is allowed:</source>
          <target state="translated">导入的变量将由match_spec &lt;code&gt;const&lt;/code&gt; 表达式替换，这与Erlang &lt;code&gt;fun()&lt;/code&gt; 的静态作用域一致。但是，本地或全局函数调用不能处于保护范围内。当然可以调用内置的match_spec函数：</target>
        </trans-unit>
        <trans-unit id="19bfe86fb1471efac1e72c2d15460bf77e3a9408" translate="yes" xml:space="preserve">
          <source>The improved &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; module is to be used instead of this module.</source>
          <target state="translated">改进的 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 模块将代替该模块使用。</target>
        </trans-unit>
        <trans-unit id="15c1fb9f30dd76e79041f3806d5e4590f2c710b6" translate="yes" xml:space="preserve">
          <source>The included application can be started in two ways. This is described in the next two sections.</source>
          <target state="translated">包含的应用程序可以通过两种方式启动。这将在接下来的两节中描述。</target>
        </trans-unit>
        <trans-unit id="06e8644e190d6991435ff4de5c47198aaef4670f" translate="yes" xml:space="preserve">
          <source>The incoming message prior to encode or the outgoing message after encode.</source>
          <target state="translated">编码前的收信或编码后的发信。</target>
        </trans-unit>
        <trans-unit id="4f31b1830353b2c8d2b0ce96b3ddc62f7dea448b" translate="yes" xml:space="preserve">
          <source>The incoming/outgoing message. For an incoming message, a term corresponding to the configured &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; if the message can be decoded in a non-relay application, &lt;code&gt;undefined&lt;/code&gt; otherwise. For an outgoing message, setting a &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; list is equivalent to setting the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;avps&lt;/code&gt; fields to the corresponding values.</source>
          <target state="translated">传入/传出消息。对于传入消息，如果可以在非中继应用程序中对消息进行解码，则该术语与配置的 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 相对应，否则为 &lt;code&gt;undefined&lt;/code&gt; 。对于外发邮件，设置 &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; 列表等效于将 &lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;avps&lt;/code&gt; 字段设置为相应的值。</target>
        </trans-unit>
        <trans-unit id="ed6f20fe9042257fdf8f4d534ef82f96072c8261" translate="yes" xml:space="preserve">
          <source>The increment value when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;). Note that this value &lt;strong&gt;can&lt;/strong&gt; be negative and that a timer restart can therefor lead to a &lt;code&gt;wait_for&lt;/code&gt; value of zero! It is up to the user to be aware of the consequences of a &lt;code&gt;wait_for&lt;/code&gt; value of zero.</source>
          <target state="translated">计算新的计时器时间时的增量值（ &lt;code&gt;wait_for&lt;/code&gt; ）。请注意，该值&lt;strong&gt;可以&lt;/strong&gt;为负，并且计时器重启可能导致 &lt;code&gt;wait_for&lt;/code&gt; 值为零！由用户决定 &lt;code&gt;wait_for&lt;/code&gt; 值为零的后果。</target>
        </trans-unit>
        <trans-unit id="b2b8955465cefc3c169ad13d16bfd76b94516280" translate="yes" xml:space="preserve">
          <source>The indentation features can be used to reindent large sections of a file. If some lines use nonstandard indentation they will be reindented.</source>
          <target state="translated">缩进功能可以用来重新缩进文件的大部分。如果某些行使用非标准缩进,它们将被重新缩进。</target>
        </trans-unit>
        <trans-unit id="3228c669ff974e48e8faf71906a7cfa3fca40c98" translate="yes" xml:space="preserve">
          <source>The indexing capabilities of &lt;code&gt;Mnesia&lt;/code&gt; are used with the following three functions, which retrieve and match records based on index entries in the database:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 的索引功能与以下三个功能一起使用，这些功能基于数据库中的索引条目来检索和匹配记录：</target>
        </trans-unit>
        <trans-unit id="66a67c598f5e1e4fe6dac7c8d61746c5da5f3c1a" translate="yes" xml:space="preserve">
          <source>The indices must be given in descending order.</source>
          <target state="translated">指数必须按降序给出。</target>
        </trans-unit>
        <trans-unit id="0c9802ae4d36471d390cc5236f59166f9448cefa" translate="yes" xml:space="preserve">
          <source>The indices must be integer literals, not variables or expressions.</source>
          <target state="translated">指数必须是整数,而不是变量或表达式。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
