<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="389d84201c8d9fc72ea3759187e87ed97f94a3cc" translate="yes" xml:space="preserve">
          <source>The result is a pair &lt;code&gt;{Tree, Stubs}&lt;/code&gt;, where &lt;code&gt;Tree&lt;/code&gt; represents the source code that is the result of merging all the code in &lt;code&gt;Sources&lt;/code&gt;, and &lt;code&gt;Stubs&lt;/code&gt; is a list of stub module descriptors (see below).</source>
          <target state="translated">结果是一对 &lt;code&gt;{Tree, Stubs}&lt;/code&gt; ，其中 &lt;code&gt;Tree&lt;/code&gt; 表示源代码，是合并 &lt;code&gt;Sources&lt;/code&gt; 中所有代码的结果，而 &lt;code&gt;Stubs&lt;/code&gt; 是存根模块描述符的列表（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="1812142f22d2ec8fea49815c861b9d307af9e096" translate="yes" xml:space="preserve">
          <source>The result is an utf8 encoded binary.</source>
          <target state="translated">结果是一个utf8编码的二进制。</target>
        </trans-unit>
        <trans-unit id="163326ca75ef4e4877fd05e7489373dbafc7e29a" translate="yes" xml:space="preserve">
          <source>The result is as follows:</source>
          <target state="translated">结果如下:</target>
        </trans-unit>
        <trans-unit id="96bc7dfc5e6c338c6e144779bbc57eea9d034108" translate="yes" xml:space="preserve">
          <source>The result is given as a list of &quot;strings&quot;, the preferred data type specified in option &lt;code&gt;return&lt;/code&gt; (default &lt;code&gt;iodata&lt;/code&gt;).</source>
          <target state="translated">结果以&amp;ldquo;字符串&amp;rdquo;列表形式给出，&amp;ldquo;字符串&amp;rdquo;是在选项 &lt;code&gt;return&lt;/code&gt; 中指定的首选数据类型（默认 &lt;code&gt;iodata&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36b8ec2df33b161570c66397c14edb7740f68481" translate="yes" xml:space="preserve">
          <source>The result is sent to the calling process as &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt;.</source>
          <target state="translated">结果作为 &lt;code&gt;{http, {ReqestId, Result}}&lt;/code&gt; 发送到调用过程。</target>
        </trans-unit>
        <trans-unit id="a900f3ce3edf2d3ac29948402338e0f316e3fe94" translate="yes" xml:space="preserve">
          <source>The result is that the child process is started by calling &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt;, or actually:</source>
          <target state="translated">结果是通过调用 &lt;code&gt;apply(call, start_link, []++[id1])&lt;/code&gt; 或实际上启动了子进程：</target>
        </trans-unit>
        <trans-unit id="0c3fa086682c777519a4e26ac33755c0fbf61a9a" translate="yes" xml:space="preserve">
          <source>The result is that the test case is skipped with &lt;code&gt;Reason&lt;/code&gt; printed to the log file (as described earlier) and &lt;code&gt;ConfigList&lt;/code&gt; is saved for the next test case. &lt;code&gt;ConfigList&lt;/code&gt; can be read using &lt;code&gt;?config(saved_config, Config)&lt;/code&gt;, as described earlier. &lt;code&gt;skip_and_save&lt;/code&gt; can also be returned from &lt;code&gt;init_per_suite&lt;/code&gt;. In this case, the saved data can be read by &lt;code&gt;init_per_suite&lt;/code&gt; in the suite that follows.</source>
          <target state="translated">结果是跳过了测试用例，并在日志文件中打印了 &lt;code&gt;Reason&lt;/code&gt; （如前所述），并为下一个测试用例保存了 &lt;code&gt;ConfigList&lt;/code&gt; 。 &lt;code&gt;ConfigList&lt;/code&gt; 可以使用读 &lt;code&gt;?config(saved_config, Config)&lt;/code&gt; ，如前所述。 &lt;code&gt;skip_and_save&lt;/code&gt; 也可以从 &lt;code&gt;init_per_suite&lt;/code&gt; 返回。在这种情况下，保存的数据可由 &lt;code&gt;init_per_suite&lt;/code&gt; 的套件中的init_per_suite读取。</target>
        </trans-unit>
        <trans-unit id="6438c51f348652f581a109f7cba2e137928b4597" translate="yes" xml:space="preserve">
          <source>The result of &lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; is an &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; event that contains, in particular, the new &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code id=&quot;record-sctp_assoc_change&quot;&gt;connect/*&lt;/code&gt; 的结果是 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 事件，其中特别包含新的 &lt;code&gt;&lt;a href=&quot;#type-assoc_id&quot;&gt;Association ID&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ea5e27a92975d3fafc60ea5040ed17aae30c19cc" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt;) represents the same source code text as the original &lt;code&gt;Node&lt;/code&gt;, assuming that &lt;code&gt;subtrees(Node)&lt;/code&gt; yields a nonempty list. However, it does not necessarily have the same data representation as &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">的结果 &lt;code&gt;copy_attrs(Node, make_tree(type(Node), subtrees(Node)))&lt;/code&gt; （见 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; ）表示相同的源代码的文本作为原始 &lt;code&gt;Node&lt;/code&gt; ，假设 &lt;code&gt;subtrees(Node)&lt;/code&gt; 产生一个非空列表。但是，它不一定具有与 &lt;code&gt;Node&lt;/code&gt; 相同的数据表示形式。</target>
        </trans-unit>
        <trans-unit id="fda083e58e6dac620272874f82b040b4ce2c7034" translate="yes" xml:space="preserve">
          <source>The result of a call to &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3&lt;/a&gt;&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="935e389e977d887f2bcee20a8d60eab32fcf9be1" translate="yes" xml:space="preserve">
          <source>The result of a successful parsing is a tuple &lt;code&gt;{DataStructure,M}&lt;/code&gt;. &lt;code&gt;M&lt;/code&gt; is the XML production Misc, which is the mark-up that comes after the element of the document. It is returned &quot;as is&quot;. &lt;code&gt;DataStructure&lt;/code&gt; is an &lt;code&gt;xmlElement&lt;/code&gt; record, that among others have the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;parents&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; like:</source>
          <target state="translated">成功解析的结果是元组 &lt;code&gt;{DataStructure,M}&lt;/code&gt; 。 &lt;code&gt;M&lt;/code&gt; 是XML生产Misc，它是文档元素之后的标记。它按&amp;ldquo;原样&amp;rdquo;返回。 &lt;code&gt;DataStructure&lt;/code&gt; 是一个 &lt;code&gt;xmlElement&lt;/code&gt; 记录，这其中包括有田 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;parents&lt;/code&gt; ， &lt;code&gt;attributes&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; ，如：</target>
        </trans-unit>
        <trans-unit id="3bdf97f5167b1c9ccc6355ba9b80fe296b53b3fa" translate="yes" xml:space="preserve">
          <source>The result of executing the command can be only one line or thousands of lines depending on the command.</source>
          <target state="translated">根据命令的不同,执行命令的结果可以是只有一行,也可以是上千行。</target>
        </trans-unit>
        <trans-unit id="d2d72cb2c002561132566b627196b081cc82e743" translate="yes" xml:space="preserve">
          <source>The result of passing the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) as a value is platform-dependent. On some platforms the variable value is set to the empty string, on others the environment variable is removed.</source>
          <target state="translated">将空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）作为值传递的结果取决于平台。在某些平台上，变量值设置为空字符串，在其他平台上，环境变量被删除。</target>
        </trans-unit>
        <trans-unit id="176ec7aa5b60be46f47fbe0fe14c3723b77fddec" translate="yes" xml:space="preserve">
          <source>The result of setting up module data is the  &lt;strong id=&quot;call_graph&quot;&gt;Call Graph&lt;/strong&gt;. A (directed) graph consists of a set of vertices and a set of (directed) edges. The edges represent  &lt;strong id=&quot;call&quot;&gt;calls&lt;/strong&gt; (From, To) between functions, modules, applications or releases. From is said to call To, and To is said to be used by From. The vertices of the Call Graph are the functions of all module data: local and exported functions of analyzed modules; used BIFs; used exported functions of library modules; and unknown functions. The functions &lt;code&gt;module_info/0,1&lt;/code&gt; added by the compiler are included among the exported functions, but only when called from some module. The edges are the function calls of all module data. A consequence of the edges being a set is that there is only one edge if a function is locally or externally used several times on one and the same line of code.</source>
          <target state="translated">设置模块数据的结果是 &lt;strong id=&quot;call_graph&quot;&gt;调用图&lt;/strong&gt;。 （有向）图由一组顶点和一组（有向）边组成。边表示 函数，模块，应用程序或发行版之间的&lt;strong id=&quot;call&quot;&gt;调用&lt;/strong&gt;（从，到）。据说From调用To，而To则被From使用。调用图的顶点是所有模块数据的功能：已分析模块的本地和导出功能；使用过的BIF；使用了库模块的导出功能；和未知的功能。函数 &lt;code&gt;module_info/0,1&lt;/code&gt; 由编译器添加的函数包括在导出的函数中，但仅当从某个模块调用时才包含。边是所有模块数据的函数调用。边为一组的结果是，如果在同一条代码行上在本地或外部多次使用某个功能，则仅存在一条边。</target>
        </trans-unit>
        <trans-unit id="b6d992ed8fa86e71532f265c49bcbb4dc25bd864" translate="yes" xml:space="preserve">
          <source>The result of the call is:</source>
          <target state="translated">呼叫的结果是:</target>
        </trans-unit>
        <trans-unit id="aec8dee4e2044b61dfd39541deba480b6fc0f212" translate="yes" xml:space="preserve">
          <source>The result of the port initialization. Can be the same values as the return value of &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt;, that is, any of the error codes or the &lt;code&gt;ErlDrvData&lt;/code&gt; that is to be used for this port.</source>
          <target state="translated">端口初始化的结果。可以与 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; 的返回值相同，即，该端口要使用的任何错误代码或 &lt;code&gt;ErlDrvData&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c00d452be45830984444ced9bba7583a3c4c38e3" translate="yes" xml:space="preserve">
          <source>The result shows that &amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt; is selected instead of the shorter match &amp;lt;&amp;lt;&quot;bc&quot;&amp;gt;&amp;gt; (which would have given raise to one more match, &amp;lt;&amp;lt;&quot;de&quot;&amp;gt;&amp;gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in &lt;code&gt;re&lt;/code&gt; (and Perl), where instead lexical ordering in the search pattern selects which string matches.</source>
          <target state="translated">结果显示，选择了&amp;lt;&amp;lt;&amp;ldquo; bcde&amp;rdquo; &amp;gt;&amp;gt;而不是较短的比赛&amp;lt;&amp;lt;&amp;ldquo; bc&amp;rdquo; &amp;gt;&amp;gt;（这将导致加注另外一场比赛，&amp;lt;&amp;lt;&amp;ldquo; de&amp;rdquo; &amp;gt;&amp;gt;）。这与POSIX正则表达式（和诸如awk之类的程序）的行为相对应，但是与 &lt;code&gt;re&lt;/code&gt; （和Per​​l）中的替代匹配不一致，而是在搜索模式中按词法顺序选择匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="ea7c245c3de8a57733480ff4f2d83525a81309ec" translate="yes" xml:space="preserve">
          <source>The result value is the tuple &lt;code&gt;{ok, List}&lt;/code&gt;, where &lt;code&gt;List&lt;/code&gt; contains the zip archive comment as the first element.</source>
          <target state="translated">结果值为元组 &lt;code&gt;{ok, List}&lt;/code&gt; ，其中 &lt;code&gt;List&lt;/code&gt; 包含zip归档注释作为第一个元素。</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="3b29ae4d5e694ab8389bf2e90d3d34997e8aec86" translate="yes" xml:space="preserve">
          <source>The result would be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="f25af746c0ce14546dc62a293ebeb0fa347f8166" translate="yes" xml:space="preserve">
          <source>The result, ValidElement, is the valid element that conforms to the post-schema-validation infoset. When the validator finds an error it tries to continue and reports a list of all errors found. In those cases an unexpected error is found it may cause a single error reason.</source>
          <target state="translated">结果ValidElement是符合schema后验证信息集的有效元素。当验证器发现一个错误时,它会尝试继续,并报告所有发现的错误列表。在那些发现意外错误的情况下,它可能会引起一个单一的错误原因。</target>
        </trans-unit>
        <trans-unit id="d2c0cc39b7355bd656ef96e65ce99409f2da03cd" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ETERM&lt;/code&gt; struct is converted into the Erlang external term format using the function &lt;code&gt;erl_encode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; and sent to Erlang using &lt;code&gt;write_cmd()&lt;/code&gt;:</source>
          <target state="translated">将所得 &lt;code&gt;ETERM&lt;/code&gt; 结构被转换成使用该函数的外部的Erlang术语格式 &lt;code&gt;erl_encode()&lt;/code&gt; 从 &lt;code&gt;erl_marshal&lt;/code&gt; 并使用发送到二郎 &lt;code&gt;write_cmd()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c67db894cf4a73ec37644dab582a90190d4ea154" translate="yes" xml:space="preserve">
          <source>The resulting C program is as follows:</source>
          <target state="translated">由此产生的C程序如下。</target>
        </trans-unit>
        <trans-unit id="76387c891c14647ed37c7c26b256256d64b3a197" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program is as follows:</source>
          <target state="translated">由此产生的Erlang程序如下。</target>
        </trans-unit>
        <trans-unit id="dde85e9e8384430e4dfd5c8f18cbf940581018ee" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functionality for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">由此产生的 Erlang 程序,包括停止 port 和检测 port 故障的功能,如下所示。</target>
        </trans-unit>
        <trans-unit id="b6e57ccb1752b17aec9fbb1ccc1b61f1ccbf9235" translate="yes" xml:space="preserve">
          <source>The resulting Erlang program, including functions for stopping the port and detecting port failures, is as follows:</source>
          <target state="translated">由此产生的 Erlang 程序,包括停止端口和检测端口故障的功能,如下所示。</target>
        </trans-unit>
        <trans-unit id="f57a31a3619a4eacb10fbb043b62b825bcea6a9d" translate="yes" xml:space="preserve">
          <source>The resulting output from the command can be read with &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#get_data-1&quot;&gt;ct_telnet:get_data/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#expect-2&quot;&gt;ct_telnet:expect/2,3&lt;/a&gt;&lt;/code&gt; 读取命令的结果输出。</target>
        </trans-unit>
        <trans-unit id="2db028a846be38d0f5b491dc0acc0c2de71c7201" translate="yes" xml:space="preserve">
          <source>The resulting source code is written to a file named &quot;&lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt;&quot; in the current directory, unless otherwise specified by the options &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; described below.</source>
          <target state="translated">除非通过下面描述的 &lt;code&gt;dir&lt;/code&gt; 和 &lt;code&gt;outfile&lt;/code&gt; 选项另外指定，否则将所得的源代码写入当前目录中名为&amp;ldquo; &lt;code&gt;&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;.erl&lt;/code&gt; &amp;rdquo;的文件中。</target>
        </trans-unit>
        <trans-unit id="0942845035c845f735b01ad27ac6b970e03ffed1" translate="yes" xml:space="preserve">
          <source>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</source>
          <target state="translated">由此产生的语法树通常只对漂亮的打印或类似的视觉格式化有用。</target>
        </trans-unit>
        <trans-unit id="3fac0a475f9b69478ab11507fafdcda6f58da223" translate="yes" xml:space="preserve">
          <source>The results from the measurement run (meas) is four excel-compatible textfiles:</source>
          <target state="translated">测量运行(meas)的结果是四个excel兼容的文本文件。</target>
        </trans-unit>
        <trans-unit id="f095f8b68579bff1b0c6a6018ac10269dfd93fd4" translate="yes" xml:space="preserve">
          <source>The results of calling the instrumentation are propagated back to the Master Agent.</source>
          <target state="translated">调用仪器的结果会传播回主代理。</target>
        </trans-unit>
        <trans-unit id="f749a3c0024a4110d2c9ec3020e59247d2fa1de4" translate="yes" xml:space="preserve">
          <source>The results, the mstone value(s), are written to stdout.</source>
          <target state="translated">结果,mstone的值,被写入stdout。</target>
        </trans-unit>
        <trans-unit id="68b25f8a798e229a222e707ac3c343b84eeef3a3" translate="yes" xml:space="preserve">
          <source>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</source>
          <target state="translated">这个函数的返回是一个字符串,其中包含了Erlang/OTP编译中使用的系统的PCRE版本。</target>
        </trans-unit>
        <trans-unit id="a5daa3a58a54feb209df655b37c5e59522b9e4ee" translate="yes" xml:space="preserve">
          <source>The return type is always a list of binaries that are all referencing &lt;code&gt;Subject&lt;/code&gt;. This means that the data in &lt;code&gt;Subject&lt;/code&gt; is not copied to new binaries, and that &lt;code&gt;Subject&lt;/code&gt; cannot be garbage collected until the results of the split are no longer referenced.</source>
          <target state="translated">返回类型始终是所有引用 &lt;code&gt;Subject&lt;/code&gt; 的二进制文件列表。这意味着 &lt;code&gt;Subject&lt;/code&gt; 中的数据不会复制到新的二进制文件中，并且在不再引用拆分结果之前，无法对 &lt;code&gt;Subject&lt;/code&gt; 进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="cc16505451734ce394057d5190ddadeecb680cef" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Pid&lt;/code&gt; is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</source>
          <target state="translated">返回值 &lt;code&gt;Pid&lt;/code&gt; 在所有其他函数中均用作对新创建的FTP客户端的引用，创建连接的进程将调用它们。FTP客户端进程监视创建它的进程，并在该进程终止时终止。</target>
        </trans-unit>
        <trans-unit id="f78465bb43d8aa089c1a2e5e2c700b8de6570b00" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">返回值 &lt;code&gt;Reply&lt;/code&gt; 在 &lt;code&gt;Module:handle_call/2&lt;/code&gt; 的返回值中定义。如果未安装指定的事件处理程序，则该函数返回 &lt;code&gt;{error,bad_module}&lt;/code&gt; 。如果回调函数因 &lt;code&gt;Reason&lt;/code&gt; 失败或返回意外值 &lt;code&gt;Term&lt;/code&gt; ，则此函数分别返回 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 或 &lt;code&gt;{error,Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6289ce75177b974046367704a47c1b35eb2e270" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;Reply&lt;/code&gt; 在 &lt;code&gt;Module:handle_call/3&lt;/code&gt; 的返回值中定义。</target>
        </trans-unit>
        <trans-unit id="4e65900c2497a0e4adbf3bab8d430efb090697d7" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;Result&lt;/code&gt; is not further defined, and is always to be ignored.</source>
          <target state="translated">返回值 &lt;code&gt;Result&lt;/code&gt; 没有进一步定义，始终将被忽略。</target>
        </trans-unit>
        <trans-unit id="9c23fe4eff7b888efd68f97990dace6d93d015ba" translate="yes" xml:space="preserve">
          <source>The return value and the handling of errors and warnings are the same as described for &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值以及错误和警告的处理与对 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 的描述相同。</target>
        </trans-unit>
        <trans-unit id="ba22696e46bcb1ab14efe031c40d755d114fc6e5" translate="yes" xml:space="preserve">
          <source>The return value can have one of the following types.</source>
          <target state="translated">返回值可以有以下类型之一:</target>
        </trans-unit>
        <trans-unit id="741aa2cae249c15277ff6de1b81ff1f7de2350e9" translate="yes" xml:space="preserve">
          <source>The return value consists of a &lt;code&gt;Listen&lt;/code&gt; handle (which is later passed to the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback), &lt;code&gt;Address&lt;/code&gt; which is a &lt;code&gt;#net_address{}&lt;/code&gt; record with information about the address for the node (the &lt;code&gt;#net_address{}&lt;/code&gt; record is defined in &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt;), and &lt;code&gt;Creation&lt;/code&gt; which (currently) is an integer &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">返回值包含一个 &lt;code&gt;Listen&lt;/code&gt; 句柄（此后将传递给 &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; 回调）， &lt;code&gt;Address&lt;/code&gt; 它是 &lt;code&gt;#net_address{}&lt;/code&gt; 记录和有关节点地址的信息）（ &lt;code&gt;#net_address{}&lt;/code&gt; 记录在 &lt;code&gt;kernel/include/net_address.hrl&lt;/code&gt; ），以及 &lt;code&gt;Creation&lt;/code&gt; 其中（目前）是整数 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; 或 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab79f181d05026b86f1878e51d4d3441d03c4055" translate="yes" xml:space="preserve">
          <source>The return value follow the same style as for &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值采用与 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 相同的样式。</target>
        </trans-unit>
        <trans-unit id="346315afa40134fb62265d734d0e42452e705832" translate="yes" xml:space="preserve">
          <source>The return value for all output functions is &lt;code&gt;0&lt;/code&gt; for normal use. If the driver is used for distribution, it can fail and return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">正常使用时，所有输出函数的返回值为 &lt;code&gt;0&lt;/code&gt; 。如果使用驱动程序进行分发，则驱动程序可能会失败并返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afe44e353cb6821f37b9d4bc7c2c6cb33639ce4d" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; can be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">&lt;code&gt;enif_make_badarg&lt;/code&gt; 的返回值只能用作（直接或间接）调用它的NIF的返回值，或传递给 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; ，但不能传递给任何其他NIF API函数。</target>
        </trans-unit>
        <trans-unit id="10dc23a005ca2cd50fc7c1d7990584e9fd2be429" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;enif_raise_exception&lt;/code&gt; can only be used as the return value from the NIF that invoked it (directly or indirectly) or be passed to &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt;, but not to any other NIF API function.</source>
          <target state="translated">&lt;code&gt;enif_raise_exception&lt;/code&gt; 的返回值只能用作（直接或间接）调用它的NIF的返回值，或传递给 &lt;code&gt;&lt;a href=&quot;#enif_is_exception&quot;&gt;enif_is_exception&lt;/a&gt;&lt;/code&gt; ，但不能传递给任何其他NIF API函数。</target>
        </trans-unit>
        <trans-unit id="41dab507981d86110830d0fd24280799a5b4ee46" translate="yes" xml:space="preserve">
          <source>The return value from the filter fun.</source>
          <target state="translated">过滤器乐趣的返回值。</target>
        </trans-unit>
        <trans-unit id="001a5abd75600054653994ccb358aab2ae66f787" translate="yes" xml:space="preserve">
          <source>The return value from the function is in this case a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</source>
          <target state="translated">在这种情况下，函数的返回值是 &lt;code&gt;list()&lt;/code&gt; 的 &lt;code&gt;list()&lt;/code&gt; 。每个子列表都以从主题字符串中挑选出的字符串开始，然后是与每个子表达式匹配的部分（按正则表达式中出现的顺序）。</target>
        </trans-unit>
        <trans-unit id="5ccdc21b3308e8b9c79db59288c10d44a28814f7" translate="yes" xml:space="preserve">
          <source>The return value from this function is ignored by Logger.</source>
          <target state="translated">该函数的返回值被Logger忽略。</target>
        </trans-unit>
        <trans-unit id="a4da786e1a06fe4c80b86166fcf1fc85113c7b88" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;-1&lt;/code&gt; if the &lt;code&gt;driver_async&lt;/code&gt; call fails.</source>
          <target state="translated">如果 &lt;code&gt;driver_async&lt;/code&gt; 调用失败，则返回值为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c3504d0b1f9c55bafbdc1d0b5cee931f0f08b2" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt; for normal use.</source>
          <target state="translated">正常使用时，返回值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a5dc674809351c5092cd01b94fa3534964ae836" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless &lt;code&gt;ready_input&lt;/code&gt;/&lt;code&gt;ready_output&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, in which case it is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;0&lt;/code&gt; ，除非 &lt;code&gt;ready_input&lt;/code&gt; / &lt;code&gt;ready_output&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，在这种情况下为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4d60964b41244106524f6879c28f2c548eae606" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;, unless the &lt;code&gt;now&lt;/code&gt; pointer is invalid, in which case it is &amp;lt; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;0&lt;/code&gt; ，除非 &lt;code&gt;now&lt;/code&gt; 指针无效，在这种情况下，它是&amp;lt; &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d105bd7aa7f6ee8eda692ca7d456479ff1aacb66" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">返回值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e56d80f6b96cb9980b29b64b5003509e50ff6732" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;{Item, Value}&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the requested information as described earlier. If a pid for a dead process was specified, or the name of a non-existing function, &lt;code&gt;Value&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">返回值为 &lt;code&gt;{Item, Value}&lt;/code&gt; ，其中 &lt;code&gt;Value&lt;/code&gt; 是如前所述的请求的信息。如果指定了死进程的pid或不存在的函数的名称，则 &lt;code&gt;Value&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c03446d5b267ccb3efe0ace7759b550ebc06efd8" translate="yes" xml:space="preserve">
          <source>The return value is a list of 0, 1, or 2 possible UTC times:</source>
          <target state="translated">返回值是一个0、1或2个可能的UTC时间的列表。</target>
        </trans-unit>
        <trans-unit id="ce9057d164fb05944ea3d2ae98a443e394d333df" translate="yes" xml:space="preserve">
          <source>The return value is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">返回值始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3da23e054f258b1199e04f5ad3b9dd62d3edb83" translate="yes" xml:space="preserve">
          <source>The return value is constructed using the &quot;match variables&quot; bound in &lt;code&gt;MatchHead&lt;/code&gt; or using the special match variables &lt;code&gt;'$_'&lt;/code&gt; (the whole matching object) and &lt;code&gt;'$$'&lt;/code&gt; (all match variables in a list), so that the following &lt;code&gt;match/2&lt;/code&gt; expression:</source>
          <target state="translated">返回值是使用 &lt;code&gt;MatchHead&lt;/code&gt; 中绑定的&amp;ldquo;匹配变量&amp;rdquo; 或特殊匹配变量 &lt;code&gt;'$_'&lt;/code&gt; （整个匹配对象）和 &lt;code&gt;'$$'&lt;/code&gt; （列表中的所有匹配变量）构造的，因此以下 &lt;code&gt;match/2&lt;/code&gt; 表达：</target>
        </trans-unit>
        <trans-unit id="37128074a43cf6aae3aba83c9d932bd47e3048e4" translate="yes" xml:space="preserve">
          <source>The return value is ignored by Logger.</source>
          <target state="translated">返回值被记录仪忽略。</target>
        </trans-unit>
        <trans-unit id="c1dfea7d28396da4de4489ef281ff15cca821d15" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;*rbuf&lt;/code&gt; 中返回的字节数。</target>
        </trans-unit>
        <trans-unit id="a34c82452edda3fc5f857c3e407fba4f89b70680" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes returned in &lt;code&gt;*rbuf&lt;/code&gt;. If &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; is returned (or in fact, anything &amp;lt; 0), &lt;code&gt;erlang:port_call/3&lt;/code&gt; throws a &lt;code&gt;BAD_ARG&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;*rbuf&lt;/code&gt; 中返回的字节数。如果返回 &lt;code&gt;ERL_DRV_ERROR_GENERAL&lt;/code&gt; （或者实际上是任何&amp;lt;0），则 &lt;code&gt;erlang:port_call/3&lt;/code&gt; 抛出 &lt;code&gt;BAD_ARG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb09cfa81ef1177832f57170b310c9386fb04033" translate="yes" xml:space="preserve">
          <source>The return value is the number of characters written to the file or string, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;buf[index]&lt;/code&gt; does not contain a valid term. Unfortunately, I/O errors on &lt;code&gt;fp&lt;/code&gt; is not checked.</source>
          <target state="translated">返回值是写入文件或字符串的字符数；如果 &lt;code&gt;buf[index]&lt;/code&gt; 不包含有效术语，则返回 &lt;code&gt;-1&lt;/code&gt; 。不幸的是，没有检查 &lt;code&gt;fp&lt;/code&gt; 上的I / O错误。</target>
        </trans-unit>
        <trans-unit id="d80fb99a8a27fa381ecc5c817818b46b3ab15dd8" translate="yes" xml:space="preserve">
          <source>The return value is the resulting match specification.</source>
          <target state="translated">返回值是产生的匹配规范。</target>
        </trans-unit>
        <trans-unit id="57668a668af4374fe9545618abb646616a496fcc" translate="yes" xml:space="preserve">
          <source>The return value is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. If the specified event handler is not installed, the function returns &lt;code&gt;{error,module_not_found}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;Module:terminate/2&lt;/code&gt; 的返回值。如果未安装指定的事件处理程序，则该函数返回 &lt;code&gt;{error,module_not_found}&lt;/code&gt; 。如果回调函数因 &lt;code&gt;Reason&lt;/code&gt; 失败，则该函数返回 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f156a768e7d53f51540a13419deed4e225aae89a" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#ei_receive&quot;&gt;ei_receive&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1dfedeee7a3af1d51782288cef9cd7e711ef3e94" translate="yes" xml:space="preserve">
          <source>The return value is the same as for &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. The number of matched events are never larger than 1 as &lt;code&gt;tpe/2&lt;/code&gt; does not accept any form of wildcards for argument &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 相同。匹配事件的数量永远不会大于1，因为 &lt;code&gt;tpe/2&lt;/code&gt; 不接受参数 &lt;code&gt;Event&lt;/code&gt; 的任何形式的通配符。</target>
        </trans-unit>
        <trans-unit id="d9518162065c311fec4cb8d7246362f3b51e7aea" translate="yes" xml:space="preserve">
          <source>The return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;{error, noconnection}&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not a connected node or &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不是连接的节点或 &lt;code&gt;new&lt;/code&gt; ，则返回值与 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;{error, noconnection}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a43749a23c3f85f80f04d4b8d3793842d7c78d0b" translate="yes" xml:space="preserve">
          <source>The return value is the space left in the buffer, that is, if &lt;code&gt;ev&lt;/code&gt; contains less than &lt;code&gt;len&lt;/code&gt; bytes it is the difference, and if &lt;code&gt;ev&lt;/code&gt; contains &lt;code&gt;len&lt;/code&gt; bytes or more, it is &lt;code&gt;0&lt;/code&gt;. This is faster if there is more than one header byte, as the binary syntax can construct integers directly from the binary.</source>
          <target state="translated">返回值是缓冲区中剩余的空间，即，如果 &lt;code&gt;ev&lt;/code&gt; 包含少于 &lt;code&gt;len&lt;/code&gt; 个字节，则为差；如果 &lt;code&gt;ev&lt;/code&gt; 包含 &lt;code&gt;len&lt;/code&gt; 个字节或更大，则为 &lt;code&gt;0&lt;/code&gt; 。如果头字节不止一个，则这样做会更快，因为二进制语法可以直接从二进制构造整数。</target>
        </trans-unit>
        <trans-unit id="ac2f53a327ddcef69bcfc81c81e743ec02f58d49" translate="yes" xml:space="preserve">
          <source>The return value is to be any of the following values, indicating if the specified configuration parameter is valid:</source>
          <target state="translated">返回值为以下任意一个值,表示指定的配置参数是否有效。</target>
        </trans-unit>
        <trans-unit id="a53de66b6befed22fef727bcfc1593e2a3510e89" translate="yes" xml:space="preserve">
          <source>The return value is to be either of the following:</source>
          <target state="translated">返回值为以下任何一种:</target>
        </trans-unit>
        <trans-unit id="ceafeb40fcc33ae37d1bb500d86c43da7ff973a6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;case&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;case&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="667b4e9527fb89bbee21bc3c659692855e17e45e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;if&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="12267bfd95ce2e9cae7b8fb4988fa796d16c0a33" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;Body&lt;/code&gt; is the return value of the &lt;code&gt;receive&lt;/code&gt; expression.</source>
          <target state="translated">的返回值 &lt;code&gt;Body&lt;/code&gt; 是的返回值 &lt;code&gt;receive&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="ea4fae033ca5b8c06d8b471ec021531504980c6e" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;end_per_testcase/2&lt;/code&gt; is ignored by the test server, with exception of the &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; tuple.</source>
          <target state="translated">除了 &lt;code&gt;&lt;a href=&quot;dependencies_chapter#save_config&quot;&gt;save_config&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;fail&lt;/code&gt; 元组，测试服务器将忽略 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="56770d741c762804a23c8684019a89bbb9d3b32f" translate="yes" xml:space="preserve">
          <source>The return value of calling this function is intended to be used in the &lt;code&gt;match_fun&lt;/code&gt; option in &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数的返回值打算在 &lt;code&gt;&lt;a href=&quot;#pkix_verify_hostname-3&quot;&gt;pkix_verify_hostname/3&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;match_fun&lt;/code&gt; 选项中使用。</target>
        </trans-unit>
        <trans-unit id="76590aed6da8a4573a438a60f16632978a2bec67" translate="yes" xml:space="preserve">
          <source>The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;. If you do not want the callback to affect the outcome of the test, return the &lt;code&gt;Return&lt;/code&gt; data as it is given to the CTH. You can also modify the test result. By returning the &lt;code&gt;Config&lt;/code&gt; list with element &lt;code&gt;tc_status&lt;/code&gt; removed, you can recover from a test failure. As in all the pre hooks, it is also possible to fail/skip the test case in the post hook.</source>
          <target state="translated">CTH函数的返回值始终是套件/组/测试的结果与更新的 &lt;code&gt;CTHState&lt;/code&gt; 的组合。如果您不希望回调影响测试结果，请返回给CTH 的 &lt;code&gt;Return&lt;/code&gt; 数据。您也可以修改测试结果。通过返回删除了 &lt;code&gt;tc_status&lt;/code&gt; 元素的 &lt;code&gt;Config&lt;/code&gt; 列表，您可以从测试失败中恢复。像在所有前挂钩中一样，在后挂钩中失败/跳过测试用例也是可能的。</target>
        </trans-unit>
        <trans-unit id="dc96c849cea9a13470890e82d87865cfd4ec3cde" translate="yes" xml:space="preserve">
          <source>The return value of the expression is the resulting fun.</source>
          <target state="translated">表达式的返回值是产生的fun。</target>
        </trans-unit>
        <trans-unit id="ca104835aa5ad01d1fa3d939ad04e391832ceb22" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handler callback:</source>
          <target state="translated">fun的返回值指定日志事件是被丢弃还是转发到处理程序回调。</target>
        </trans-unit>
        <trans-unit id="d4e70786797f2c0c82a992fd6de3d9da04e6d44f" translate="yes" xml:space="preserve">
          <source>The return value of the fun specifies if a log event is to be discarded or forwarded to the handlers:</source>
          <target state="translated">fun的返回值指定日志事件是被丢弃还是转发到处理程序。</target>
        </trans-unit>
        <trans-unit id="8a15ba4a5d207f8ff27af670138d14092b913977" translate="yes" xml:space="preserve">
          <source>The return value of this call is:</source>
          <target state="translated">这个调用的返回值是:</target>
        </trans-unit>
        <trans-unit id="ad0e0fbdd470e29f0445d4c32a3c5589be7037b8" translate="yes" xml:space="preserve">
          <source>The return value of this function is the same as the result of the commands &lt;code&gt;openssl crl -hash&lt;/code&gt; and &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt;, when passed the issuer name of a CRL or a certificate, respectively. This hash is used by the &lt;code&gt;c_rehash&lt;/code&gt; tool to maintain a directory of symlinks to CRL files, in order to facilitate looking up a CRL by its issuer name.</source>
          <target state="translated">当分别传递CRL或证书的颁发者名称时，此函数的返回值与 &lt;code&gt;openssl crl -hash&lt;/code&gt; 和 &lt;code&gt;openssl x509 -issuer_hash&lt;/code&gt; 命令的结果相同。 &lt;code&gt;c_rehash&lt;/code&gt; 工具使用此哈希来维护指向CRL文件的符号链接目录，以便于通过其发行者名称查找CRL。</target>
        </trans-unit>
        <trans-unit id="556ae7c31e2eeb819041e01f0988fe1443eb20ac" translate="yes" xml:space="preserve">
          <source>The return value reflects how many functions that matched, and is constructed as described in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. No tuple &lt;code&gt;{saved, N}&lt;/code&gt; is however ever returned (for obvious reasons).</source>
          <target state="translated">返回值反映了匹配的函数数量，并按 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 中的描述进行构造。但是，不会返回任何元组 &lt;code&gt;{saved, N}&lt;/code&gt; （出于明显的原因）。</target>
        </trans-unit>
        <trans-unit id="a2493a1b75922ce60ff03955e74f63fe68c01230" translate="yes" xml:space="preserve">
          <source>The return values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;blocked&lt;/code&gt;, &lt;code&gt;blocked_normal&lt;/code&gt;, or &lt;code&gt;enabled&lt;/code&gt;. The returned value describes the state just after the call to &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; has been made. For information about the return values, see &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值被 &lt;code&gt;disabled&lt;/code&gt; ， &lt;code&gt;blocked&lt;/code&gt; ， &lt;code&gt;blocked_normal&lt;/code&gt; 或 &lt;code&gt;enabled&lt;/code&gt; 。返回值描述了对 &lt;code&gt;erlang:system_flag(multi_scheduling, BlockState)&lt;/code&gt; 的调用之后的状态。有关返回值的信息，请参见 &lt;code&gt;&lt;a href=&quot;#system_info_multi_scheduling&quot;&gt;erlang:system_info(multi_scheduling)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7a5c4a4e2556d9fc5599788448978bc86e18491" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; except that they also contain a term &lt;code&gt;Reply&lt;/code&gt;, which is the reply to the client as the return value of &lt;code&gt;call/3,4&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; 相同，除了它们还包含术语 &lt;code&gt;Reply&lt;/code&gt; ，这是作为对 &lt;code&gt;call/3,4&lt;/code&gt; 的返回值的客户端答复。</target>
        </trans-unit>
        <trans-unit id="16402449b6bab46b6acb25bee9687ea3d1da1cef" translate="yes" xml:space="preserve">
          <source>The return values are the same as for &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值与 &lt;code&gt;&lt;a href=&quot;#scan_erl_exprs-1&quot;&gt;scan_erl_exprs/1,2,3,4&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="34736dd65ea7c5f985adcd3b21d438aa1d48110e" translate="yes" xml:space="preserve">
          <source>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;nlist&lt;/code&gt; varies. Often real errors are not reported as errors by &lt;code&gt;ls&lt;/code&gt;, even if, for example, a file or directory does not exist. &lt;code&gt;nlist&lt;/code&gt; is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</source>
          <target state="translated">以下函数的返回值在很大程度上取决于远程主机上FTP服务器的实现。特别是， &lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;nlist&lt;/code&gt; 的结果有所不同。 &lt;code&gt;ls&lt;/code&gt; 经常不会将实际错误报告为错误，即使例如文件或目录不存在。 &lt;code&gt;nlist&lt;/code&gt; 通常更严格，但是如果请求是存在但为空的目录内容的列表，则某些实现具有响应错误的特殊行为。</target>
        </trans-unit>
        <trans-unit id="d7e4973c70cdd56da241fcf626185e66a1c55705" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UtilDesc&lt;/code&gt;(s) will be even more detailed.</source>
          <target state="translated">返回的 &lt;code&gt;UtilDesc&lt;/code&gt; 将更加详细。</target>
        </trans-unit>
        <trans-unit id="ea4255b1bb88d05e61ad743eab72330c07b40c58" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;outbound_streams&lt;/code&gt; and &lt;code&gt;inbound_streams&lt;/code&gt; are the stream numbers on the socket. These can be different from the requested values (&lt;code&gt;OutStreams&lt;/code&gt; and &lt;code&gt;MaxInStreams&lt;/code&gt;, respectively) if the peer requires lower values.</source>
          <target state="translated">返回的 &lt;code&gt;outbound_streams&lt;/code&gt; 和 &lt;code&gt;inbound_streams&lt;/code&gt; 是套接字上的流号。如果对等方要求使用较低的值，则这些值可以与请求的值（分别为 &lt;code&gt;OutStreams&lt;/code&gt; 和 &lt;code&gt;MaxInStreams&lt;/code&gt; ）不同。</target>
        </trans-unit>
        <trans-unit id="78c4a176ab5344343a3680d64f0f87276de46ba2" translate="yes" xml:space="preserve">
          <source>The returned array is suitable to use with the Unix system call &lt;code&gt;writev&lt;/code&gt;.</source>
          <target state="translated">返回的数组适合与Unix系统调用 &lt;code&gt;writev&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="45ff48530f77dbc6cc0743bbf1b0bea13f7efa44" translate="yes" xml:space="preserve">
          <source>The returned continuation either is or is not valid in the next call to this function. This is because the log can wrap and delete the file into which the continuation points. To ensure this does not occur, the log can be blocked during the search.</source>
          <target state="translated">返回的continuation在下一次调用该函数时要么有效,要么无效。这是因为日志可以包裹和删除延续指向的文件。为了确保这种情况不会发生,可以在搜索过程中屏蔽日志。</target>
        </trans-unit>
        <trans-unit id="563414bf21c4083de3c0b515b0ae801f03daf271" translate="yes" xml:space="preserve">
          <source>The returned fun augments the verify hostname matching according to the specific rules for the protocol in the argument.</source>
          <target state="translated">返回的fun会根据参数中协议的具体规则来增强验证主机名的匹配。</target>
        </trans-unit>
        <trans-unit id="1f4757970518220fdc7fe112f9433dc5ad370dd2" translate="yes" xml:space="preserve">
          <source>The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.</source>
          <target state="translated">返回的指针对任何适合分配的内存中的内置类型进行适当的对齐。</target>
        </trans-unit>
        <trans-unit id="b2f0dd9c815f2da7d427b069f2a9894879c7f90c" translate="yes" xml:space="preserve">
          <source>The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established.</source>
          <target state="translated">返回的引用唯一地标识服务范围内的传输。请注意,该函数会在传输连接建立之前返回。</target>
        </trans-unit>
        <trans-unit id="4e5ed52f640bec9583fe09c321a1dc7cfa7d394d" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;ListenSocket&lt;/code&gt; should be used in calls to &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; to accept incoming connection requests.</source>
          <target state="translated">返回的套接字 &lt;code&gt;ListenSocket&lt;/code&gt; 应在调用 &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; 中使用,以接受传入的连接请求。</target>
        </trans-unit>
        <trans-unit id="ab1d27e257509f8da3d8e76915e7736db74a82b0" translate="yes" xml:space="preserve">
          <source>The returned socket &lt;code&gt;Socket&lt;/code&gt; is used to send packets from this port with &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt;. When UDP packets arrive at the opened port, if the socket is in an active mode, the packets are delivered as messages to the controlling process:</source>
          <target state="translated">返回的套接字 &lt;code&gt;Socket&lt;/code&gt; 用于使用 &lt;code&gt;&lt;a href=&quot;#send-4&quot;&gt;send/4&lt;/a&gt;&lt;/code&gt; 从此端口发送数据包。UDP数据包到达打开的端口时，如果套接字处于活动模式，则将这些数据包作为消息传递给控制进程：</target>
        </trans-unit>
        <trans-unit id="ba58f4a868c9920a0accc2470109df28ce1c8b33" translate="yes" xml:space="preserve">
          <source>The returned value equals &lt;code&gt;How&lt;/code&gt; before flag &lt;code&gt;scheduler_bind_type&lt;/code&gt; was changed.</source>
          <target state="translated">返回的值等于 &lt;code&gt;How&lt;/code&gt; 前旗 &lt;code&gt;scheduler_bind_type&lt;/code&gt; 改变。</target>
        </trans-unit>
        <trans-unit id="ad1f4738d1ee235637e8713b2fb0e1aed7b3c9ff" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;info&lt;/code&gt; is part of &lt;code&gt;OptionList&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;info&lt;/code&gt; 是 &lt;code&gt;OptionList&lt;/code&gt; 的一部分，否则返回的值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="704d94c2e818c260decb81dbc9e54e317cedcd87" translate="yes" xml:space="preserve">
          <source>The returned value is one of the following:</source>
          <target state="translated">返回的值是以下之一。</target>
        </trans-unit>
        <trans-unit id="17c9f8dadb89f1f4731e454e478946ba8977d737" translate="yes" xml:space="preserve">
          <source>The returned value of the first call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt; by a process will on most systems be the CPU utilization since system boot, but this is not guaranteed and the value should therefore be regarded as garbage. This also applies to the first call after a restart of &lt;code&gt;cpu_sup&lt;/code&gt;.</source>
          <target state="translated">自系统启动以来，在大多数系统上，进程首次调用 &lt;code&gt;util/0&lt;/code&gt; 或 &lt;code&gt;util/1&lt;/code&gt; 的返回值将是CPU利用率，但这不能保证，因此应将其视为垃圾。这也适用于 &lt;code&gt;cpu_sup&lt;/code&gt; 重新启动后的第一次调用。</target>
        </trans-unit>
        <trans-unit id="4bbb8b0494dfde82da9ec11120fc8e7694cd4f11" translate="yes" xml:space="preserve">
          <source>The right hand side of a grammar rule may be empty. This is indicated by using the special symbol &lt;code&gt;'$empty'&lt;/code&gt; as rhs. Then the list grammar above may be simplified to:</source>
          <target state="translated">语法规则的右侧可能为空。这可以通过使用特殊符号 &lt;code&gt;'$empty'&lt;/code&gt; 作为rhs来表示。然后，上面的列表语法可以简化为：</target>
        </trans-unit>
        <trans-unit id="dc75d0c89181a304f45200607807515a4ebde020" translate="yes" xml:space="preserve">
          <source>The role of a Diameter node is determined by the user's implementation.</source>
          <target state="translated">Diameter节点的作用由用户的实现决定。</target>
        </trans-unit>
        <trans-unit id="416c824ca6a43adb95da91e2cb1751ab089f31b7" translate="yes" xml:space="preserve">
          <source>The room number is an attribute of the employee record. This is a structured attribute that consists of a tuple. The first element of the tuple identifies a corridor, and the second element identifies the room in that corridor. An alternative is to represent this as a record &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; instead of an anonymous tuple representation.</source>
          <target state="translated">房间号是员工记录的属性。这是一个由元组组成的结构化属性。元组的第一个元素标识一条走廊，第二个元素标识该走廊中的房间。一种替代方法是将其表示为一个记录 &lt;code&gt;-record(room, {corr, no}).&lt;/code&gt; 而不是匿名元组表示。</target>
        </trans-unit>
        <trans-unit id="577f0039c4fa2f0d1ea23b58d0300c235c47b7fd" translate="yes" xml:space="preserve">
          <source>The root certificate is a trusted certificate that is present in the trusted certificate database kept by the peer.</source>
          <target state="translated">根证书是对等体保存的可信证书数据库中存在的可信证书。</target>
        </trans-unit>
        <trans-unit id="52dbe02f6473ea542b1777651fa34126c38819b1" translate="yes" xml:space="preserve">
          <source>The root certificate name.</source>
          <target state="translated">根证书名称。</target>
        </trans-unit>
        <trans-unit id="53cd33d8adcdb9225af5611f87476b60c6686390" translate="yes" xml:space="preserve">
          <source>The root directory (&lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt;)</source>
          <target state="translated">根目录（ &lt;code&gt;&quot;/usr/local/erl-target&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="59cc46abe2ddea6a9a499abb0a284b3438d6e2bb" translate="yes" xml:space="preserve">
          <source>The routine above is called from the &lt;code&gt;uds_output&lt;/code&gt; routine:</source>
          <target state="translated">上面的例程是从 &lt;code&gt;uds_output&lt;/code&gt; 例程中调用的：</target>
        </trans-unit>
        <trans-unit id="899ef76204638a6cfef4214df04665f53c56597c" translate="yes" xml:space="preserve">
          <source>The routine builds an I/O vector containing the header bytes and the buffer (the opcode has been removed and the buffer length decreased by the output routine). If the queue is empty, we write the data directly to the socket (or at least try to). If any data is left, it is stored in the queue and then we try to send the queue (line 38). An acknowledgement is sent when the message is delivered completely (line 22). The &lt;code&gt;send_out_queue&lt;/code&gt; sends acknowledgements if the sending is completed there. If the port is in &lt;code&gt;command&lt;/code&gt; mode, the Erlang code serializes the send operations so that only one packet can be waiting for delivery at a time. Therefore the acknowledgement can be sent whenever the queue is empty.</source>
          <target state="translated">该例程将构建一个包含头字节和缓冲区的I / O向量（输出例程已删除操作码，并减小了缓冲区长度）。如果队列为空，则将数据直接写入套接字（或至少尝试写入）。如果有剩余数据，则将其存储在队列中，然后尝试发送队列（第38行）。消息完全传递后，将发送确认（第22行）。该 &lt;code&gt;send_out_queue&lt;/code&gt; 如果发送的还有完成发送确认。如果端口处于 &lt;code&gt;command&lt;/code&gt; 模式，则Erlang代码会序列化发送操作，以便一次只能等待一个数据包。因此，只要队列为空，就可以发送确认。</target>
        </trans-unit>
        <trans-unit id="673662eb2121ca41425305edda42a80c288cd1e9" translate="yes" xml:space="preserve">
          <source>The routine initializes the single global data structure and returns a pointer to the driver entry. The routine is called when &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; is called from Erlang.</source>
          <target state="translated">该例程初始化单个全局数据结构，并返回指向驱动程序条目的指针。从Erlang 调用 &lt;code&gt;erl_ddll:load_driver&lt;/code&gt; 时将调用该例程。</target>
        </trans-unit>
        <trans-unit id="c17dc336612f84d4c81b404a94002b4ef123f628" translate="yes" xml:space="preserve">
          <source>The routine is simple: it first handles the fact that the output select will concern a socket in the business of connecting (and the connecting blocked). If the socket is in a connected state, it simply sends the output queue. This routine is called when it is possible to write to a socket where we have an output queue, so there is no question what to do.</source>
          <target state="translated">该例程很简单:它首先处理输出选择将关注一个处于连接业务中的套接字(以及连接阻塞)的事实。如果套接字处于连接状态,它只需发送输出队列。当我们可以向一个有输出队列的套接字写入时,就会调用这个例程,所以不存在该怎么做的问题。</target>
        </trans-unit>
        <trans-unit id="77a723120b7e543c1800db7036e53529bcbbae13" translate="yes" xml:space="preserve">
          <source>The routine tries to read data until a packet is read or the &lt;code&gt;buffered_read_package&lt;/code&gt; routine returns a &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; (an internally defined constant for the module, which means that the read operation resulted in an &lt;code&gt;EWOULDBLOCK&lt;/code&gt;). If the port is in &lt;code&gt;command&lt;/code&gt; mode, the reading stops when one package is read. If the port is in &lt;code&gt;data&lt;/code&gt; mode, the reading continues until the socket buffer is empty (read failure). If no more data can be read and more is wanted (which is always the case when the socket is in &lt;code&gt;data&lt;/code&gt; mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_input&lt;/code&gt; callback be called when more data is available for reading.</source>
          <target state="translated">该例程尝试读取数据，直到读取了数据包或 &lt;code&gt;buffered_read_package&lt;/code&gt; 例程返回 &lt;code&gt;NORMAL_READ_FAILURE&lt;/code&gt; （模块的内部定义常量，这意味着读取操作导致 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; ）。如果端口处于 &lt;code&gt;command&lt;/code&gt; 模式，则在读取一个程序包时停止读取。如果端口处于 &lt;code&gt;data&lt;/code&gt; 模式，则继续读取直到套接字缓冲区为空（读取失败）。如果无法读取更多数据并且需要更多数据（在套接字处于 &lt;code&gt;data&lt;/code&gt; 模式时， &lt;code&gt;driver_select&lt;/code&gt; 就是这种情况），则在可以读取更多数据时，将调用 &lt;code&gt;uds_input&lt;/code&gt; 以使uds_input回调被调用。</target>
        </trans-unit>
        <trans-unit id="594d38181d8b0e2c57da4b81cceed123220efbd4" translate="yes" xml:space="preserve">
          <source>The row for the &lt;strong&gt;marked&lt;/strong&gt; function simply contains the sum of all &lt;strong&gt;calling&lt;/strong&gt; rows.</source>
          <target state="translated">被&lt;strong&gt;标记&lt;/strong&gt;函数的行仅包含所有&lt;strong&gt;调用&lt;/strong&gt;行的总和。</target>
        </trans-unit>
        <trans-unit id="f63f268b5b1ba7e518b6ca9840895c249dbd9600" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;called&lt;/strong&gt; functions contains statistics for the &lt;strong&gt;row's&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;marked&lt;/strong&gt; to the &lt;strong&gt;row's&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">被&lt;strong&gt;调用&lt;/strong&gt;函数的&lt;strong&gt;行&lt;/strong&gt;包含该行函数的统计信息，并具有约束条件，即仅考虑从&lt;strong&gt;标记&lt;/strong&gt;到该&lt;strong&gt;行&lt;/strong&gt;函数&lt;strong&gt;的&lt;/strong&gt;调用的情况。</target>
        </trans-unit>
        <trans-unit id="b591b9ee5241f27713065c70477c2cb23e6ae07b" translate="yes" xml:space="preserve">
          <source>The rows for the &lt;strong&gt;calling&lt;/strong&gt; functions contain statistics for the &lt;strong&gt;marked&lt;/strong&gt; function with the constraint that only the occasions when a call was made from the &lt;strong&gt;row's&lt;/strong&gt; function to the &lt;strong&gt;marked&lt;/strong&gt; function are accounted for.</source>
          <target state="translated">&lt;strong&gt;调用&lt;/strong&gt;函数的行包含&lt;strong&gt;标记&lt;/strong&gt;函数的统计信息，并具有以下约束：仅考虑从该&lt;strong&gt;行的&lt;/strong&gt;函数对&lt;strong&gt;标记&lt;/strong&gt;函数进行调用的情况。</target>
        </trans-unit>
        <trans-unit id="23c9bc526d84923d88d3f3c4aca6eb88d00853db" translate="yes" xml:space="preserve">
          <source>The rules for handling the two address passing options are:</source>
          <target state="translated">两个地址传递选项的处理规则是:。</target>
        </trans-unit>
        <trans-unit id="65d47d40f9e3322daa06f6a9cc9586d8bced1031" translate="yes" xml:space="preserve">
          <source>The rules for importing variables into a fun has the consequence that certain pattern matching operations must be moved into guard expressions and cannot be written in the head of the fun. For example, you might write the following code if you intend the first clause of &lt;code&gt;F&lt;/code&gt; to be evaluated when the value of its argument is &lt;code&gt;Y&lt;/code&gt;:</source>
          <target state="translated">将变量导入有趣的规则的结果是，某些模式匹配操作必须移入保护表达式中，并且不能写在有趣的头部。例如，如果您打算在 &lt;code&gt;F&lt;/code&gt; 的第一个子句的参数值为 &lt;code&gt;Y&lt;/code&gt; 时对其进行评估，则可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="2b91da3a1a048b58314c1c111db21a5595f2f19a" translate="yes" xml:space="preserve">
          <source>The rules in an access file apply to files in the same directory and in subdirectories. If there exists more than one access file in the path to an asset, the rules in the access file nearest the requested asset is applied.</source>
          <target state="translated">访问文件中的规则适用于同一目录和子目录中的文件。如果一个资产的路径中存在多个访问文件,则适用离所请求的资产最近的访问文件中的规则。</target>
        </trans-unit>
        <trans-unit id="1d38dd44eba1bb3a7ed4f14eaa12a0a33476ba0b" translate="yes" xml:space="preserve">
          <source>The running configuration cannot be deleted and &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; must be advertised by the server.</source>
          <target state="translated">运行中的配置不能删除，并且 &lt;code&gt;:candidate&lt;/code&gt; 或 &lt;code&gt;:startup&lt;/code&gt; 必须由服务器发布。</target>
        </trans-unit>
        <trans-unit id="c79b5264357f5534cee7c6ef4abc2fbac9660cbd" translate="yes" xml:space="preserve">
          <source>The runtime encoders and decoders execute within a catch and return &lt;code&gt;{ok, Data}&lt;/code&gt; or &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; where &lt;code&gt;Description&lt;/code&gt; is an Erlang term describing the error.</source>
          <target state="translated">运行时编码器和解码器在catch中执行并返回 &lt;code&gt;{ok, Data}&lt;/code&gt; 或 &lt;code&gt;{error, {asn1, Description}}&lt;/code&gt; ，其中 &lt;code&gt;Description&lt;/code&gt; 是描述错误的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="1bd1e0cd445f2587e2d274da2e56ba41b0124a77" translate="yes" xml:space="preserve">
          <source>The runtime for the process, that is, the time that the process has been scheduled in.</source>
          <target state="translated">进程的运行时间,即进程被安排的时间。</target>
        </trans-unit>
        <trans-unit id="0477f575396c2d31573bf1177d25d393514ae802" translate="yes" xml:space="preserve">
          <source>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</source>
          <target state="translated">启用时,运行时开销为每次分配一个字。这一点可能会在将来的任何时候改变。</target>
        </trans-unit>
        <trans-unit id="b52f5dd159b93b951f3b921ca939f057c72f0232" translate="yes" xml:space="preserve">
          <source>The runtime system aborts producing a core dump, if that is enabled in the OS.</source>
          <target state="translated">如果操作系统中启用了核心转储,运行时系统会中止生成核心转储。</target>
        </trans-unit>
        <trans-unit id="aedc7575975308f8d984dc3da045923bc133d996" translate="yes" xml:space="preserve">
          <source>The runtime system always takes a lock before running any code in a driver.</source>
          <target state="translated">运行时系统总是在运行驱动程序中的任何代码之前采取锁。</target>
        </trans-unit>
        <trans-unit id="0b7cb9b63bdfde371041fe9ecc549e2d3f8291fb" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in &lt;strong&gt;interactive&lt;/strong&gt; or &lt;strong&gt;embedded&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;:</source>
          <target state="translated">可以在&lt;strong&gt;交互式&lt;/strong&gt;或&lt;strong&gt;嵌入式&lt;/strong&gt;模式下启动运行系统。哪一个由命令行标志 &lt;code&gt;-mode&lt;/code&gt; 决定：</target>
        </trans-unit>
        <trans-unit id="4f194749f9a0abb8f1fc16278fdf82b7ab426657" translate="yes" xml:space="preserve">
          <source>The runtime system can be started in either &lt;strong&gt;embedded&lt;/strong&gt; or &lt;strong&gt;interactive&lt;/strong&gt; mode. Which one is decided by the command-line flag &lt;code&gt;-mode&lt;/code&gt;.</source>
          <target state="translated">可以以&lt;strong&gt;嵌入式&lt;/strong&gt;或&lt;strong&gt;交互&lt;/strong&gt;方式启动运行系统。哪一个由命令行标志 &lt;code&gt;-mode&lt;/code&gt; 决定。</target>
        </trans-unit>
        <trans-unit id="15f0b229ab22b4247144711faf8addfff0acec04" translate="yes" xml:space="preserve">
          <source>The runtime system can represent binaries up to 64 bytes as heap binaries. They are always copied when sent in messages, but they require less memory if they are not sent to another process and garbage collection is cheaper.</source>
          <target state="translated">运行时系统可以将最大64字节的二进制文件表示为堆二进制文件。它们在消息中发送时总是被复制,但如果它们不被发送到另一个进程,则需要较少的内存,而且垃圾收集也比较便宜。</target>
        </trans-unit>
        <trans-unit id="52f7c1d9fec74d1d87c2aa61e92b2f7031396fc6" translate="yes" xml:space="preserve">
          <source>The runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors.</source>
          <target state="translated">运行时系统的默认操作&lt;strong&gt;不&lt;/strong&gt;绑定调度到逻辑处理器。</target>
        </trans-unit>
        <trans-unit id="fc86dfe1cb0ce649fa9cfc863da2e29d5456fcde" translate="yes" xml:space="preserve">
          <source>The runtime system exits with integer value &lt;code&gt;Status&lt;/code&gt; as status code to the calling environment (OS).</source>
          <target state="translated">运行时系统以整数值 &lt;code&gt;Status&lt;/code&gt; 退出，作为到调用环境（OS）的状态代码。</target>
        </trans-unit>
        <trans-unit id="d758492b235e5ae70fd740805f185d0f947792cf" translate="yes" xml:space="preserve">
          <source>The runtime system is halted by calling &lt;code&gt;halt/0,1&lt;/code&gt;. For details, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">通过调用 &lt;code&gt;halt/0,1&lt;/code&gt; 停止运行时系统。有关详细信息，请参见ERTS中的 &lt;code&gt;erlang(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="737f6644d46fc0b71dce7d366db4bb2df97d5f28" translate="yes" xml:space="preserve">
          <source>The runtime system is started using a &lt;strong&gt;boot script&lt;/strong&gt;. The boot script contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">运行时系统使用&lt;strong&gt;启动脚本启动&lt;/strong&gt;。启动脚本包含有关加载哪些代码以及启动哪些进程和应用程序的说明。</target>
        </trans-unit>
        <trans-unit id="f56dfcd70ad1156309d29b60e153328381d89995" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries can however fail if deprecated features are used.</source>
          <target state="translated">如果主要版本不同,或者主要版本相同,而NIF库使用的次要版本大于运行时系统使用的版本,运行时系统通常会拒绝加载NIF库。然而,在两个主要版本的过渡期内,在主要版本发生变化后,允许使用主要版本较低的旧NIF库。但是,如果使用了废弃的功能,这种旧的NIF库可能会失败。</target>
        </trans-unit>
        <trans-unit id="08dd149e2b409426602405250d51453a541efc1d" translate="yes" xml:space="preserve">
          <source>The runtime system normally refuses to load a driver if the major versions differ, or if the major versions are equal and the minor version used by the driver is greater than the one used by the runtime system. Old drivers with lower major versions are however allowed after a bump of the major version during a transition period of two major releases. Such old drivers can, however, fail if deprecated features are used.</source>
          <target state="translated">如果主要版本不同,或者主要版本相同,而驱动程序使用的次要版本大于运行时系统使用的版本,运行时系统通常会拒绝加载驱动程序。然而,在两个主要版本的过渡期内,在主要版本发生变化后,允许使用主要版本较低的旧驱动程序。但是,如果使用了被废弃的功能,这样的旧驱动可能会失败。</target>
        </trans-unit>
        <trans-unit id="dc8941217d6f38b36e1857530b5476e0fe59285c" translate="yes" xml:space="preserve">
          <source>The runtime system rereads the CPU information available and updates its internally stored information about the &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; and the number of logical processors &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行时系统重新读取可用的CPU信息，并更新其内部存储的有关 &lt;code&gt;&lt;a href=&quot;#system_info_cpu_topology_detected&quot;&gt;detected CPU topology&lt;/a&gt;&lt;/code&gt; 以及已 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors&quot;&gt;configured&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_online&quot;&gt;online&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;available&lt;/a&gt;&lt;/code&gt; 的逻辑处理器数量的信息。</target>
        </trans-unit>
        <trans-unit id="1318205b88fb228dd3bc1e3526e8e8a8014305b4" translate="yes" xml:space="preserve">
          <source>The runtime system sees that &lt;code&gt;Bin1&lt;/code&gt; is the result from a previous append operation (not from the latest append operation), so it &lt;strong&gt;copies&lt;/strong&gt; the contents of &lt;code&gt;Bin1&lt;/code&gt; to a new binary, reserve extra storage, and so on. (Here is not explained how the runtime system can know that it is not allowed to write into &lt;code&gt;Bin1&lt;/code&gt;; it is left as an exercise to the curious reader to figure out how it is done by reading the emulator sources, primarily &lt;code&gt;erl_bits.c&lt;/code&gt;.)</source>
          <target state="translated">运行时系统会发现 &lt;code&gt;Bin1&lt;/code&gt; 是上一个追加操作（而不是最新的追加操作）的结果，因此它将 &lt;code&gt;Bin1&lt;/code&gt; 的内容&lt;strong&gt;复制&lt;/strong&gt;到新的二进制文件中，保留了额外的存储空间，依此类推。（这里没有解释运行时系统如何知道不允许将其写入 &lt;code&gt;Bin1&lt;/code&gt; ；好奇的读者可以将其作为练习，通过读取仿真器源（主要是 &lt;code&gt;erl_bits.c&lt;/code&gt; ）来了解如何完成此操作。）</target>
        </trans-unit>
        <trans-unit id="68dc9c39652a0fdf0a0c35a5221cd9cab865f995" translate="yes" xml:space="preserve">
          <source>The runtime system terminates if the Erlang shell is terminated.</source>
          <target state="translated">如果Erlang shell被终止,运行时系统就会终止。</target>
        </trans-unit>
        <trans-unit id="8b6b04664129c94fdc81f4426dc13b0df0dd9a3c" translate="yes" xml:space="preserve">
          <source>The runtime system thread that caused the crash dump</source>
          <target state="translated">导致崩溃转储的运行时系统线程。</target>
        </trans-unit>
        <trans-unit id="788e5f8c02e60181a54b252b202da78929f68515" translate="yes" xml:space="preserve">
          <source>The runtime system uses port-level locking on all ports executing this driver instead of driver-level locking when the driver is run in a runtime system with SMP support. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在具有SMP支持的运行时系统中运行驱动程序时，运行时系统在执行此驱动程序的所有端口上使用端口级锁定，而不是驱动程序级锁定。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_driver#smp_support&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="625eb63fcb0f8ad6e285974d83dcb34f448ce002" translate="yes" xml:space="preserve">
          <source>The runtime user interface for exclusive decode consists of the following two functions:</source>
          <target state="translated">独占解码的运行时用户界面由以下两个函数组成。</target>
        </trans-unit>
        <trans-unit id="e8b6a0c2dcea74f8fdf356aa85c68643c16e46c9" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;ct_hooks&lt;/code&gt; statement without the configuration file would cause HTML logging of all NETCONF connections in to the test case HTML log.</source>
          <target state="translated">没有配置文件的相同 &lt;code&gt;ct_hooks&lt;/code&gt; 语句将导致将所有NETCONF连接的HTML日志记录到测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="c6d70dc4cc333eac788e481d9bbdc225c08c481a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#check_process_code-3&quot;&gt;check_process_code(Pid,Module, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2aaed7b59951ec082934bf672a9d13e59338ac6" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Actions = []&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered. This creates an anonymous server.</source>
          <target state="translated">与 &lt;code&gt;Actions = []&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 相同，除了必须没有注册任何 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 。这将创建一个匿名服务器。</target>
        </trans-unit>
        <trans-unit id="01deb53c6f9077db7db997ce628218c4238aba6e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#garbage_collect-2&quot;&gt;garbage_collect(Pid, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85756b3d7fbfe5ef4170983b9b2a6fc5fb5e5087" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(0, [])&lt;/a&gt;&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="1e5fb0bebe29ee84d11970a1ce3108bad78b288e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt;. Example:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#halt-2&quot;&gt;halt(Status, [])&lt;/a&gt;&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="74fa8e723ce6c07be8e482111c905cf750f679e8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt;, but with a Boolean return value.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend |Options])&lt;/a&gt;&lt;/code&gt; ，但是具有布尔返回值。</target>
        </trans-unit>
        <trans-unit id="d2197ab46f758634a9dcf871583d61827a00cf65" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt;, but returns &lt;code&gt;true&lt;/code&gt; if the message was sent and &lt;code&gt;false&lt;/code&gt; if the message was not sent because the sender would have had to be suspended.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;erlang:send(Dest,Msg, [nosuspend])&lt;/a&gt;&lt;/code&gt; ，但是如果发送了消息，则返回 &lt;code&gt;true&lt;/code&gt; ;如果未发送消息，则返回 &lt;code&gt;false&lt;/code&gt; ，因为必须暂停发送者。</target>
        </trans-unit>
        <trans-unit id="1075e0e25bfb14e858cab7e38be5445bc5ac4682" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;, except that it also include information about all dirty I/O schedulers.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 相同，除了它还包含有关所有脏I / O调度程序的信息。</target>
        </trans-unit>
        <trans-unit id="f4ceb7a27c576e85ef9e754da89ddaf1dfd654ed" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#stop-1&quot;&gt;stop(0)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4b72b3a948c1e65ff99938c20b299ba036c263f7" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(ServerRef, normal, infinity)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="feaf6b5c71e3fafb1e75897b45c0e3840025bb7c" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt;, retained for backward compatibility.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern(Event, MatchSpec, [])&lt;/a&gt;&lt;/code&gt; ，保留它是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="d5a1ef850fec5e3df173bd9dd2c7e3dbb0636f60" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;binary_part(Subject, {Start, Length})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="619006029171444306cc4c87f6a95f63bb972338" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;compile(Regexp,[])&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;compile(Regexp,[])&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="17d52831ded701ec877189bfcc53acad1352798f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;eval/1&lt;/code&gt;, but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. For information about the variable bindings, see &lt;code&gt;erl_eval(3)&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;eval/1&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定的信息，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08c1e708a98116e2d68d4f0a5026b6a10643e95a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;float_to_binary(Float,[{scientific,20}])&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3ebcfaf2f1268befcb2c2ddd0543f3e6acf79842" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;float_to_list(Float,[{scientific,20}])&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="47b9133116b8c5faac32e3c70f25a2bffa651d8f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;path_script/2&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">与 &lt;code&gt;path_script/2&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40cc315183d06f20b4fd979426474e04d552a45f" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;script/1&lt;/code&gt; but the variable bindings &lt;code&gt;Bindings&lt;/code&gt; are used in the evaluation. See &lt;code&gt;erl_eval(3)&lt;/code&gt; about variable bindings.</source>
          <target state="translated">与 &lt;code&gt;script/1&lt;/code&gt; 相同，但变量绑定 &lt;code&gt;Bindings&lt;/code&gt; 用于评估中。有关变量绑定，请参见 &lt;code&gt;erl_eval(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e8982b6aae2a82fb446c9ac15561cf18afb817" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{bof, Offset}&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;{bof, Offset}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0277407f00337c8bdaf1cca96cdd266e8ea8198" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; with reasonable default values for &lt;code&gt;Size&lt;/code&gt; and &lt;code&gt;Delay&lt;/code&gt; (roughly some 64 KB, 2 seconds).</source>
          <target state="translated">与 &lt;code&gt;{delayed_write, Size, Delay}&lt;/code&gt; 相同，并具有合理的 &lt;code&gt;Size&lt;/code&gt; 和 &lt;code&gt;Delay&lt;/code&gt; 默认值（大约64 KB，2秒）。</target>
        </trans-unit>
        <trans-unit id="7228431770d5bb25829bb566f3e53142c058363b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;{read_ahead, Size}&lt;/code&gt; with a reasonable default value for &lt;code&gt;Size&lt;/code&gt; (roughly some 64 KB).</source>
          <target state="translated">一样 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 与用于合理的默认值 &lt;code&gt;Size&lt;/code&gt; （大致约64 KB）。</target>
        </trans-unit>
        <trans-unit id="cb4ea9e9c62a5f384a690dd1c1b7a864f413d95a" translate="yes" xml:space="preserve">
          <source>The same as above with &lt;code&gt;Offset&lt;/code&gt; 0.</source>
          <target state="translated">与上面的 &lt;code&gt;Offset&lt;/code&gt; 0 相同。</target>
        </trans-unit>
        <trans-unit id="c0b12e07cbe44403181759c4034c4f3d2fe0c1ce" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks&quot;&gt;statistics(active_tasks)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="71c6f84a59f77755e69a52beb91ed4b1a4c03ff2" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_active_tasks_all&quot;&gt;statistics(active_tasks_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="ee4e69e3e7435faa22aa0647b7b837e57300ad5e" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths&quot;&gt;statistics(run_queue_lengths)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但效率更高。</target>
        </trans-unit>
        <trans-unit id="4780b4915f09916bc2a903be56062c7fb948d806" translate="yes" xml:space="preserve">
          <source>The same as calling &lt;code&gt;lists:sum(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">与调用 &lt;code&gt;lists:sum(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#statistics_run_queue_lengths_all&quot;&gt;statistics(run_queue_lengths_all)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 相同，但是效率更高。</target>
        </trans-unit>
        <trans-unit id="bf890bcea15d91e1f7af9ee8721c2b6276c19354" translate="yes" xml:space="preserve">
          <source>The same as eariler with &lt;code&gt;Offset&lt;/code&gt; 0, that is, &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Offset&lt;/code&gt; 0的伯尼尔（即 &lt;code&gt;{bof, 0} | {cur, 0} | {eof, 0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efec8691cd75c256c32c494b80c6d71a6ded7b5a" translate="yes" xml:space="preserve">
          <source>The same example as the first sign example, except that a password protects the key down in the Engine.</source>
          <target state="translated">与第一个标志的例子相同,只是在Engine中用密码保护键下来。</target>
        </trans-unit>
        <trans-unit id="11685d22af41c7bdec311d8efb6717608cc97597" translate="yes" xml:space="preserve">
          <source>The same failure as for &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 相同的故障。</target>
        </trans-unit>
        <trans-unit id="37284fa9bdbec3125fb6f5f2938b0a9140415e5c" translate="yes" xml:space="preserve">
          <source>The same happens if you insert a binary into an Ets table, send it to a port using &lt;code&gt;erlang:port_command/2&lt;/code&gt;, or pass it to &lt;code&gt;enif_inspect_binary&lt;/code&gt; in a NIF.</source>
          <target state="translated">如果将二进制文件插入Ets表，使用 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 将其发送到端口，或者将其传递到NIF中的 &lt;code&gt;enif_inspect_binary&lt;/code&gt; ，也会发生同样的情况。</target>
        </trans-unit>
        <trans-unit id="8dd676fc032f39da8f11e805e928df982b381e69" translate="yes" xml:space="preserve">
          <source>The same logic applies to explicitly imported functions from other modules, as to locally defined functions. It is not allowed to both import a function from another module and have the function declared in the module at the same time:</source>
          <target state="translated">同样的逻辑适用于从其他模块中显式导入的函数和本地定义的函数。不允许既从另一个模块导入一个函数,同时又在该模块中声明该函数。</target>
        </trans-unit>
        <trans-unit id="c9a8dd64d3d825a10122f8306efa89f8d1dff40d" translate="yes" xml:space="preserve">
          <source>The same occurs if &lt;code&gt;Dest&lt;/code&gt; refers to a local port that is busy. For all other destinations (allowed for the ordinary send operator &lt;code&gt;'!'&lt;/code&gt;), this function sends the message and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Dest&lt;/code&gt; 引用的是繁忙的本地端口，则会发生同样的情况。对于所有其他目的地（允许普通的send运算符 &lt;code&gt;'!'&lt;/code&gt; ），此函数发送消息并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c986670ac5f53fe5b7d5d769f706fae8b44b1bd" translate="yes" xml:space="preserve">
          <source>The same principles of serialization apply when passing resource terms in messages to remote nodes and back again. A resource term will act stale on all nodes except the node where its resource object is still alive in memory.</source>
          <target state="translated">在将消息中的资源项传递给远程节点并再传递回来时,同样适用序列化原则。除了其资源对象在内存中仍然有效的节点外,资源项在所有节点上都会失效。</target>
        </trans-unit>
        <trans-unit id="4f281f033368479cef02a66d827c4b8a6fe27bfd" translate="yes" xml:space="preserve">
          <source>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to &lt;code&gt;error_logger.&lt;/code&gt;</source>
          <target state="translated">脏更新可能会发生相同的问题。在当前节点上本地检测到过载，但其原因可能在另一个节点上。如果任何表驻留在另一个节点上（无论是否复制），应用程序进程都可能导致高负载。默认情况下，此事件报告给 &lt;code&gt;error_logger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb9bbb6e34766185444c1af2a9a7f778b5a58e67" translate="yes" xml:space="preserve">
          <source>The same program can also be written as:</source>
          <target state="translated">同样的程序也可以写成。</target>
        </trans-unit>
        <trans-unit id="2fc6942530a03944111630cfbde674aeb2b9833c" translate="yes" xml:space="preserve">
          <source>The same reasons for using the parse transformation apply to &lt;code&gt;dbg&lt;/code&gt;, maybe even more, as filtering using Erlang code is not a good idea when tracing (except afterwards, if you trace to file). The concept is similar to that of &lt;code&gt;ets:fun2ms/1&lt;/code&gt; except that you usually use it directly from the shell (which can also be done with &lt;code&gt;ets:fun2ms/1&lt;/code&gt;).</source>
          <target state="translated">使用parg转换的相同原因也适用于 &lt;code&gt;dbg&lt;/code&gt; ，甚至更多，因为在跟踪时使用Erlang代码进行过滤不是一个好主意（除非以后跟踪到文件，否则除外）。该概念与 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 相似，不同之处在于您通常直接从外壳中使用它（也可以使用 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 来完成）。</target>
        </trans-unit>
        <trans-unit id="be2c67bb51461ede16f91f4276fe7a51514360a8" translate="yes" xml:space="preserve">
          <source>The same result can be obtained by using the flag &lt;code&gt;call&lt;/code&gt; only and setting a match specification on local or global function calls as follows:</source>
          <target state="translated">通过仅使用标志 &lt;code&gt;call&lt;/code&gt; 并在本地或全局函数调用上设置匹配规范，可以获得相同的结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="6367b3aadbf1b22efb4fe6d60edce34f7915ed4d" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used by the preprocessor, which supports file inclusion, macros, and conditional compilation:</source>
          <target state="translated">预处理器使用与模块属性相同的语法,支持文件包含、宏和条件编译。</target>
        </trans-unit>
        <trans-unit id="1ba61a6106c571f4543444dde7af8861fee4288b" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for changing the pre-defined macros &lt;code&gt;?FILE&lt;/code&gt; and &lt;code&gt;?LINE&lt;/code&gt;:</source>
          <target state="translated">与模块属性相同的语法用于更改预定义的宏 &lt;code&gt;?FILE&lt;/code&gt; 和 &lt;code&gt;?LINE&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="49b27eed80040be071f7bd6b90b55a6ca7a1a602" translate="yes" xml:space="preserve">
          <source>The same syntax as for module attributes is used for record definitions:</source>
          <target state="translated">记录定义使用与模块属性相同的语法。</target>
        </trans-unit>
        <trans-unit id="652d4a8a5d229c7cd102ddf9155b41205986af36" translate="yes" xml:space="preserve">
          <source>The same, provided there are &amp;lt; 40 previous capturing subpatterns</source>
          <target state="translated">相同，前提是之前的捕获子图案少于40个</target>
        </trans-unit>
        <trans-unit id="1f8c820898fda9a674e186f206f12995037f99bb" translate="yes" xml:space="preserve">
          <source>The scanner will, by default, be built as a reentrant scanner &lt;strong&gt;if&lt;/strong&gt; the flex utility supports this (it depends on the version of flex). It is possible to explicitly disable this even when flex support this. Use &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; when configuring the application.</source>
          <target state="translated">&lt;strong&gt;如果&lt;/strong&gt; flex实用程序支持，则默认情况下，该扫描程序将被构建为可重入扫描程序（取决于flex的版本）。即使flex支持此功能，也可以显式禁用此功能。配置应用程序时，请使用 &lt;code&gt;--disable-megaco-reentrant-flex-scanner&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0106bb004e9ef4cae180d81bd2193ccedbf77a79" translate="yes" xml:space="preserve">
          <source>The scanning was successful. &lt;code&gt;Tokens&lt;/code&gt; is the list of tokens including &lt;strong&gt;dot&lt;/strong&gt;.</source>
          <target state="translated">扫描成功。 &lt;code&gt;Tokens&lt;/code&gt; 是令牌的列表，包括&lt;strong&gt;dot&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5b2eae5d531637391bdf1a2942db36f759f3d1ab" translate="yes" xml:space="preserve">
          <source>The scenario is illustrated in the following figure:</source>
          <target state="translated">该方案如下图所示。</target>
        </trans-unit>
        <trans-unit id="6bb445fb55208c8d6300f1c0c3c7ddd0fdd5dffb" translate="yes" xml:space="preserve">
          <source>The scheduler bind type can also be set by passing command-line argument &lt;code&gt;+sbt&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">也可以通过将命令行参数 &lt;code&gt;+sbt&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 来设置调度程序绑定类型。</target>
        </trans-unit>
        <trans-unit id="b9aa6c41e456afc02a165b00e6454af974767459" translate="yes" xml:space="preserve">
          <source>The scheduler ids whose allocator instances will be searched. A scheduler id of 0 will refer to the global instance that is not tied to any particular scheduler. Defaults to all schedulers and the global instance.</source>
          <target state="translated">调度器id,其分配器实例将被搜索。调度程序id为0时,指的是不与任何特定调度程序绑定的全局实例。默认为所有调度程序和全局实例。</target>
        </trans-unit>
        <trans-unit id="f8238b4700efd0d55eb3ba098718fdc8466aa0bb" translate="yes" xml:space="preserve">
          <source>The schema file and all other files that Mnesia needs are kept in the Mnesia directory. The command-line option &lt;code&gt;-mnesia dir Dir&lt;/code&gt; can be used to specify the location of this directory to the Mnesia system. If no such command-line option is found, the name of the directory defaults to &lt;code&gt;Mnesia.Node&lt;/code&gt;.</source>
          <target state="translated">Mnesia所需的架构文件和所有其他文件都保存在Mnesia目录中。命令行选项 &lt;code&gt;-mnesia dir Dir&lt;/code&gt; 可用于指定该目录在Mnesia系统中的位置。如果找不到这样的命令行选项，则目录的名称默认为 &lt;code&gt;Mnesia.Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3f92f1963a15447bf5f1771a2c485f240d49382" translate="yes" xml:space="preserve">
          <source>The schema functions are as follows:</source>
          <target state="translated">模式功能如下:</target>
        </trans-unit>
        <trans-unit id="6c514498238aab18641162374c9ebc46e751b79e" translate="yes" xml:space="preserve">
          <source>The schema in the backup file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; has been used to generate the file &lt;code&gt;schema.DAT&lt;/code&gt;. Since there are no other disc resident tables than the schema, no other data files were created. The file &lt;code&gt;FALLBACK.BUP&lt;/code&gt; was removed after the successful &quot;restoration&quot;. You also see some files that are for internal use by &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">备份文件 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 中的模式已用于生成文件 &lt;code&gt;schema.DAT&lt;/code&gt; 。由于除架构外没有其他磁盘驻留表，因此未创建其他数据文件。成功的&amp;ldquo;还原&amp;rdquo;后，文件 &lt;code&gt;FALLBACK.BUP&lt;/code&gt; 被删除。您还会看到一些 &lt;code&gt;Mnesia&lt;/code&gt; 内部使用的文件。</target>
        </trans-unit>
        <trans-unit id="9c0d7180f9e8c49acad7689271d60b75c4177036" translate="yes" xml:space="preserve">
          <source>The schema itself is a table and is possibly included in the backup. Each node where the schema table resides is regarded as a &lt;code&gt;db_node&lt;/code&gt;.</source>
          <target state="translated">模式本身是一个表，可能包含在备份中。模式表所在的每个节点都被视为 &lt;code&gt;db_node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cd14602cf9237e1ff86bf0c3f394217395aea3d" translate="yes" xml:space="preserve">
          <source>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;ram_copies&lt;/code&gt; (but not &lt;code&gt;disc_only_copies&lt;/code&gt;). At startup, &lt;code&gt;Mnesia&lt;/code&gt; uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; contains a list of nodes that &lt;code&gt;Mnesia&lt;/code&gt; also is to establish contact with besides those found in the schema. Default is &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">与其他表一样，模式表可以驻留在一个或多个节点上。模式表的存储类型可以是 &lt;code&gt;disc_copies&lt;/code&gt; 或 &lt;code&gt;ram_copies&lt;/code&gt; （但不能是 &lt;code&gt;disc_only_copies&lt;/code&gt; ）。在启动时， &lt;code&gt;Mnesia&lt;/code&gt; 使用其架构来确定要与哪些节点建立联系。如果已经启动任何其他节点，则启动节点会将其表定义与从其他节点带来的表定义合并。这也适用于架构表本身的定义。应用程序参数 &lt;code&gt;extra_db_nodes&lt;/code&gt; 包含一个列表， &lt;code&gt;Mnesia&lt;/code&gt; 除了在架构中找到的那些节点之外，还将与该节点建立联系。默认值为 &lt;code&gt;[]&lt;/code&gt; （空列表）。</target>
        </trans-unit>
        <trans-unit id="503d5a4fc67df91a919a603a14d890c204b2864e" translate="yes" xml:space="preserve">
          <source>The scheme portion of the URI gets converted into atom, meaning that atom leak may occur. Specifying a scheme validation fun is recommended unless the URI is already sanitized.</source>
          <target state="translated">URI的scheme部分会被转换为atom,这意味着可能会发生atom泄漏。建议指定一个方案验证函数,除非URI已经被净化。</target>
        </trans-unit>
        <trans-unit id="d3677cc5dde8dec9f0943fbc75e45b112aeaf536" translate="yes" xml:space="preserve">
          <source>The scope for a variable is its function clause. Variables bound in a branch of an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, or &lt;code&gt;receive&lt;/code&gt; expression must be bound in all branches to have a value outside the expression. Otherwise they are regarded as 'unsafe' outside the expression.</source>
          <target state="translated">变量的范围是其功能子句。绑定在 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; 或 &lt;code&gt;receive&lt;/code&gt; 表达式的分支中的变量必须在所有分支中进行绑定，以使其值在表达式之外。否则，它们在表达式之外被视为&amp;ldquo;不安全&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c6288b2668a38169687226d8d788cc7da7e3e234" translate="yes" xml:space="preserve">
          <source>The scope of a &lt;code&gt;::&lt;/code&gt; constraint is the &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; specification after which it appears. To avoid confusion, it is suggested that different variables are used in different constituents of an overloaded contract, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 约束的范围是 &lt;code&gt;(...) -&amp;gt; RetType&lt;/code&gt; 规范，之后出现。为避免混淆，建议在重载合同的不同组成部分中使用不同的变量，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="6888ff9909aa4d3472400691e9c55573d784edc2" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in funs are as follows:</source>
          <target state="translated">funs中出现的变量的作用域规则如下。</target>
        </trans-unit>
        <trans-unit id="4404d931933003579634af4e100185e648005e9e" translate="yes" xml:space="preserve">
          <source>The scope rules for variables that occur in list comprehensions are as follows:</source>
          <target state="translated">列表理解中出现的变量的范围规则如下。</target>
        </trans-unit>
        <trans-unit id="57d16d66e3e9f378f0fafcdd50a83455cdc8ed0f" translate="yes" xml:space="preserve">
          <source>The script is checked for syntactic and semantic correctness before it is run. If there are warnings (such as unused variables), they are printed and the script will still be run. If there are errors, they are printed and the script will not be run and its exit status is &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">在运行脚本之前，将检查该脚本的语法和语义正确性。如果有警告（例如未使用的变量），则会打印警告，并且脚本仍将运行。如果有错误，将打印它们并且脚本将不会运行，并且其退出状态为 &lt;code&gt;127&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb62b1588228fdb2e00bea0a69e7992a3a90205" translate="yes" xml:space="preserve">
          <source>The search is retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (&lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">在同一位置使用选项 &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; 重试搜索，该搜索不会给出任何较长长度的有趣结果，因此搜索位置将前进到下一个字符（ &lt;code&gt;a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4117f8cd43f5fed32f2aebfe701accad0f731400" translate="yes" xml:space="preserve">
          <source>The search once again matches the empty string, giving &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt;.</source>
          <target state="translated">搜索再次匹配空字符串，得到 &lt;code&gt;[{3,0},{3,0}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2957d4c2e73e120f5160a9d5de1e8eab79ab85bf" translate="yes" xml:space="preserve">
          <source>The search results in &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt;, so this search is also repeated with the extra options.</source>
          <target state="translated">搜索结果为 &lt;code&gt;[{1,0},{1,0}]&lt;/code&gt; ，因此还会使用其他选项重复此搜索。</target>
        </trans-unit>
        <trans-unit id="7019ec1c2fea8d709b52cfb8681127b05dd6a6ce" translate="yes" xml:space="preserve">
          <source>The second argument is a string defining the magic cookie.</source>
          <target state="translated">第二个参数是一个定义魔力饼干的字符串。</target>
        </trans-unit>
        <trans-unit id="5d7c556937d2f0d9d84069b86f16a68647203e8c" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;code&gt;Config&lt;/code&gt; key-value list of runtime configuration data, which has the same value as the list returned by &lt;code&gt;init_per_suite&lt;/code&gt;. &lt;code&gt;init_per_testcase/2&lt;/code&gt; can modify this parameter or return it &quot;as is&quot;. The return value of &lt;code&gt;init_per_testcase/2&lt;/code&gt; is passed as parameter &lt;code&gt;Config&lt;/code&gt; to the test case itself.</source>
          <target state="translated">第二个参数是运行时配置数据的 &lt;code&gt;Config&lt;/code&gt; 键值列表，其值与 &lt;code&gt;init_per_suite&lt;/code&gt; 返回的列表相同。 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 可以修改此参数或&amp;ldquo;按原样&amp;rdquo;返回它。 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 的返回值作为参数 &lt;code&gt;Config&lt;/code&gt; 传递给测试用例本身。</target>
        </trans-unit>
        <trans-unit id="ab475df1b91ae9d944e6820d1389807d78bf68f6" translate="yes" xml:space="preserve">
          <source>The second argument is the array of &lt;code&gt;ErlNifFunc&lt;/code&gt; structures containing name, arity, and function pointer of each NIF.</source>
          <target state="translated">第二个参数是 &lt;code&gt;ErlNifFunc&lt;/code&gt; 结构的数组，其中包含每个NIF的名称，Arity和函数指针。</target>
        </trans-unit>
        <trans-unit id="0886faad82449f45fc6af07be32433d58c83fd99" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the module (&lt;code&gt;ch4&lt;/code&gt;).</source>
          <target state="translated">第二个参数是模块的名称（ &lt;code&gt;ch4&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ae91f868e0e36c5aab81d0643e970c9ad85647d4" translate="yes" xml:space="preserve">
          <source>The second argument is the plain node name.</source>
          <target state="translated">第二个参数是普通节点名称。</target>
        </trans-unit>
        <trans-unit id="68aa2b0acb6c307f4edca5d2585ef7f3b4bc172b" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;erl_accept&lt;/code&gt; is a struct &lt;code&gt;ErlConnect&lt;/code&gt; which contains useful information when a connection has been established, for example, the name of the Erlang node.</source>
          <target state="translated">&lt;code&gt;erl_accept&lt;/code&gt; 的第二个参数是结构 &lt;code&gt;ErlConnect&lt;/code&gt; ，该结构包含建立连接后的有用信息，例如Erlang节点的名称。</target>
        </trans-unit>
        <trans-unit id="fa4ea88aab8e44c4912833f7bf79be8a3c8b83f1" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;select&lt;/code&gt; is a &lt;code&gt;MatchSpecification&lt;/code&gt;. A &lt;code&gt;MatchSpecification&lt;/code&gt; is a list of &lt;code&gt;MatchFunction&lt;/code&gt;s, where each &lt;code&gt;MatchFunction&lt;/code&gt; consists of a tuple containing &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 的第二个参数是 &lt;code&gt;MatchSpecification&lt;/code&gt; 。甲 &lt;code&gt;MatchSpecification&lt;/code&gt; 是列表 &lt;code&gt;MatchFunction&lt;/code&gt; s，其中每个 &lt;code&gt;MatchFunction&lt;/code&gt; 由包含元组 &lt;code&gt;{MatchHead, MatchCondition, MatchBody}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="859328262eb9b89de95770488ed8f287011c831c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;ttb:format/2&lt;/code&gt; is a list of options as follows:</source>
          <target state="translated">&lt;code&gt;ttb:format/2&lt;/code&gt; 的第二个参数是选项列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="d294655854fb12427e99c41c78c6470facb9f485" translate="yes" xml:space="preserve">
          <source>The second argument to the filter fun.</source>
          <target state="translated">过滤器乐趣的第二个参数。</target>
        </trans-unit>
        <trans-unit id="c06be8768f8415da3e4862a8bcd381b621322fa1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;?MODULE&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located, which is this module.</source>
          <target state="translated">第二个参数 &lt;code&gt;?MODULE&lt;/code&gt; 是回调模块的名称，即回调函数所在的模块，即该模块。</target>
        </trans-unit>
        <trans-unit id="e11f122b81a9ab6f35f17499a7c2e31dc0343a63" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">第二个参数 &lt;code&gt;[]&lt;/code&gt; 是一个原样传递给回调函数 &lt;code&gt;init&lt;/code&gt; 的术语。在此， &lt;code&gt;init&lt;/code&gt; 不需要任何indata并忽略该参数。</target>
        </trans-unit>
        <trans-unit id="b862edb2184436a21646c9503b2f3762af04c9d1" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;ch3&lt;/code&gt;, is the name of the callback module, that is, the module where the callback functions are located.</source>
          <target state="translated">第二个参数 &lt;code&gt;ch3&lt;/code&gt; 是回调模块的名称，即回调函数所在的模块。</target>
        </trans-unit>
        <trans-unit id="12a6cc1ddca791145f200b7b0393d7c9270fb068" translate="yes" xml:space="preserve">
          <source>The second clause sends a message to &quot;pong&quot;:</source>
          <target state="translated">第二个子句向 &quot;朋 &quot;发出信息。</target>
        </trans-unit>
        <trans-unit id="7315fa80ba44205c16b829da74dfc058d1a1d7a4" translate="yes" xml:space="preserve">
          <source>The second element of the PEM-entry is the ASN.1 &lt;code&gt;DER&lt;/code&gt; encoded key data:</source>
          <target state="translated">PEM条目的第二个元素是ASN.1 &lt;code&gt;DER&lt;/code&gt; 编码的密钥数据：</target>
        </trans-unit>
        <trans-unit id="c40944389ed2e7f80311414a40c89625de90b8fe" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is a string (list of characters) representing the filename of the source file of the function.</source>
          <target state="translated">元组的第二个元素是一个字符串(字符列表),代表函数的源文件的文件名。</target>
        </trans-unit>
        <trans-unit id="30419a9fbcf62ba4094ad4eff3e638ac58c744c8" translate="yes" xml:space="preserve">
          <source>The second element of the tuple is the line number (an integer &amp;gt; 0) in the source file where the exception occurred or the function was called.</source>
          <target state="translated">元组的第二个元素是发生异常或调用函数的源文件中的行号（整数&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="bc7d989f87dede2e2ca73a50e9ef9b041bd4465f" translate="yes" xml:space="preserve">
          <source>The second instruction, &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt;, takes component &lt;code&gt;number&lt;/code&gt; in the &lt;code&gt;handle&lt;/code&gt; component of type &lt;code&gt;Action&lt;/code&gt;. If the value is &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt;, the internal value 4711 is to be picked by &lt;code&gt;selected_decode_Action&lt;/code&gt;. In an Erlang terminal it looks as follows:</source>
          <target state="translated">第二条指令 &lt;code&gt;{selected_decode_Action,['Action',handle,number]}&lt;/code&gt; 在 &lt;code&gt;Action&lt;/code&gt; 类型的 &lt;code&gt;handle&lt;/code&gt; 组件中获取组件 &lt;code&gt;number&lt;/code&gt; 。如果值为 &lt;code&gt;ValAction = {'Action',17,{'Button',4711,false}}&lt;/code&gt; ，则内部值4711将由 &lt;code&gt;selected_decode_Action&lt;/code&gt; 选择。在Erlang终端中，其外观如下：</target>
        </trans-unit>
        <trans-unit id="09b4b4758afce0f888fa8c4488323d46e48b894d" translate="yes" xml:space="preserve">
          <source>The second is the maximum value since the last call to &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">第二个是自上次调用 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 以来的最大值。</target>
        </trans-unit>
        <trans-unit id="4cb423e42dd15bcd7222df4611672554d769f082" translate="yes" xml:space="preserve">
          <source>The second level is at the MPD entry / exit point, i.e. immediately after the basic message processing (accept_recv_pdu) / immediately before the basic message processing (accept_send_pdu).</source>
          <target state="translated">第二级是在MPD的入口/出口处,即紧接着基本信息处理(accept_recv_pdu)/紧接着基本信息处理(accept_send_pdu)。</target>
        </trans-unit>
        <trans-unit id="774b9d51f0c992a280af87374e7739fea47b5a73" translate="yes" xml:space="preserve">
          <source>The second line also says that this function can be called from outside the module &lt;code&gt;tut&lt;/code&gt;. More about this later. Again, notice the &quot;.&quot; at the end of the line.</source>
          <target state="translated">第二行还说，可以从模块 &lt;code&gt;tut&lt;/code&gt; 外部调用此函数。稍后再详细介绍。再次注意&amp;ldquo;。&amp;rdquo; 在该行的末尾。</target>
        </trans-unit>
        <trans-unit id="ea3a8607657a10cb904d6d19adb9e7a687aaf47e" translate="yes" xml:space="preserve">
          <source>The second line in the example contains an optional directive to the &lt;code&gt;Emacs&lt;/code&gt; editor, which causes it to enter the major mode for editing Erlang source files. If the directive is present, it must be located on the second line.</source>
          <target state="translated">示例中的第二行包含 &lt;code&gt;Emacs&lt;/code&gt; 编辑器的可选指令，这使它进入用于编辑Erlang源文件的主要模式。如果存在该指令，则它必须位于第二行。</target>
        </trans-unit>
        <trans-unit id="e7ea568009a70c36f6990dad1c35ac2c65ca7ebb" translate="yes" xml:space="preserve">
          <source>The second line says that the module &lt;code&gt;tut&lt;/code&gt; contains a function called &lt;code&gt;double&lt;/code&gt;, which takes one argument (&lt;code&gt;X&lt;/code&gt; in our example):</source>
          <target state="translated">第二行说模块 &lt;code&gt;tut&lt;/code&gt; 包含一个名为 &lt;code&gt;double&lt;/code&gt; 的函数，该函数带有一个参数（在我们的示例中为 &lt;code&gt;X&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="1dd56257c238ab45a9b4f237dd6d44c5ddae2994" translate="yes" xml:space="preserve">
          <source>The second occurrence of &lt;code&gt;Age&lt;/code&gt; causes a test for equality between the terms, as &lt;code&gt;Age&lt;/code&gt; is already bound to &lt;code&gt;21&lt;/code&gt;. As &lt;code&gt;Age&lt;/code&gt; is bound to &lt;code&gt;21&lt;/code&gt;, the equality test succeeds and the match continues until the end of the pattern.</source>
          <target state="translated">由于 &lt;code&gt;Age&lt;/code&gt; 已经绑定到 &lt;code&gt;21&lt;/code&gt; ，因此第二次出现 &lt;code&gt;Age&lt;/code&gt; 会测试两个词之间是否相等。当 &lt;code&gt;Age&lt;/code&gt; 绑定到 &lt;code&gt;21&lt;/code&gt; 时，相等性测试成功，并且匹配持续到模式结束。</target>
        </trans-unit>
        <trans-unit id="382e51e975a6ee94aa9da00eaf8c1fd3b5f3d623" translate="yes" xml:space="preserve">
          <source>The second part says that the factorial of N is N multiplied by the factorial of N - 1:</source>
          <target state="translated">第二部分说,N的阶乘是N乘以N-1的阶乘。</target>
        </trans-unit>
        <trans-unit id="30c810f9bece7434133db436ed3f6c1cf5d3af46" translate="yes" xml:space="preserve">
          <source>The second sublist contains all elements that are greater than, or equal to, the first element in the list.</source>
          <target state="translated">第二个子列表包含所有大于或等于列表中第一个元素的元素。</target>
        </trans-unit>
        <trans-unit id="627c2faa2a7cc1454aac523f61132caf4581e1f2" translate="yes" xml:space="preserve">
          <source>The second test to run is for system &lt;code&gt;t2&lt;/code&gt;. The included suites are &lt;code&gt;t2B&lt;/code&gt; and &lt;code&gt;t2C&lt;/code&gt;. Test cases &lt;code&gt;test4&lt;/code&gt;, &lt;code&gt;test1&lt;/code&gt;, and &lt;code&gt;test7&lt;/code&gt; in suite &lt;code&gt;t2A&lt;/code&gt; are also included. The test cases are executed in the specified order.</source>
          <target state="translated">要运行的第二项测试是针对系统 &lt;code&gt;t2&lt;/code&gt; 的。包括的套件是 &lt;code&gt;t2B&lt;/code&gt; 和 &lt;code&gt;t2C&lt;/code&gt; 。还包括套件 &lt;code&gt;t2A&lt;/code&gt; 中的测试用例 &lt;code&gt;test4&lt;/code&gt; ， &lt;code&gt;test1&lt;/code&gt; 和 &lt;code&gt;test7&lt;/code&gt; 。测试用例以指定的顺序执行。</target>
        </trans-unit>
        <trans-unit id="55d61df65623e70a8f8d590c69696f032eeda08b" translate="yes" xml:space="preserve">
          <source>The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern:</source>
          <target state="translated">PCRE和Perl在递归处理中的第二个不同之处是对捕获值的处理。在Perl中,当一个子模式被递归调用或作为子模式调用时(见下一节),它无法访问递归之外捕获的任何值。在PCRE中,这些值可以被引用。考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="80e6aee2483553449b41d11b56e552008e4da471" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Definition of Instrumentation Functions&lt;/strong&gt; describes the user defined functions, which the agent calls at different times.</source>
          <target state="translated">&lt;strong&gt;工具功能&lt;/strong&gt;的定义部分介绍了用户定义的功能，代理在不同时间调用这些功能。</target>
        </trans-unit>
        <trans-unit id="8504a92d5b318cac713f3b2e89234cb14dbccfe1" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send and be able to receive.</source>
          <target state="translated">&lt;strong&gt;消息&lt;/strong&gt;部分描述了必填消息，如果必须发送并能够接收，则为Net。</target>
        </trans-unit>
        <trans-unit id="a2e0f488aa581aec3c47fd790570dbca655fc2d9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;Messages&lt;/strong&gt; describes mandatory messages, which Net if must send to the manager server process.</source>
          <target state="translated">&lt;strong&gt;消息&lt;/strong&gt;部分描述了必填消息，如果必须将其发送到管理器服务器进程，则该消息为Net。</target>
        </trans-unit>
        <trans-unit id="cb5bc25d5302176ca65d13f47ab8764077fb82e9" translate="yes" xml:space="preserve">
          <source>The section &lt;strong&gt;When to use a Sub-agent&lt;/strong&gt; describes situations where the mechanism of loading and unloading MIBs is insufficient. In these cases a sub-agent is needed.</source>
          <target state="translated">部分&lt;strong&gt;当使用子代理&lt;/strong&gt;描述的情况下装载和卸载的MIB的机构是不充分的。在这些情况下，需要一个子代理。</target>
        </trans-unit>
        <trans-unit id="e27ee525c2d7a1c95013bf055cd814b7495974ff" translate="yes" xml:space="preserve">
          <source>The section is a step-by-step explanation of the &lt;code&gt;uds_dist&lt;/code&gt; example application (in the Kernel application &lt;code&gt;examples&lt;/code&gt; directory). The &lt;code&gt;uds_dist&lt;/code&gt; application implements distribution over Unix domain sockets and is written for the Sun Solaris 2 operating environment. The mechanisms are however general and apply to any operating system Erlang runs on. The reason the C code is not made portable, is simply readability.</source>
          <target state="translated">本节是 &lt;code&gt;uds_dist&lt;/code&gt; 示例应用程序的逐步说明（在Kernel application &lt;code&gt;examples&lt;/code&gt; 目录中）。该 &lt;code&gt;uds_dist&lt;/code&gt; 在Unix域套接字的应用程序实现分发，它是太阳的Solaris 2操作环境编写。但是，这些机制是通用的，适用于运行Erlang的任何操作系统。C代码不具有可移植性的原因仅仅是可读性。</target>
        </trans-unit>
        <trans-unit id="10205e6d7e5decf9f073a8f33e8e352f8ecad2b8" translate="yes" xml:space="preserve">
          <source>The sections about release structure and release handling have been moved to section &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">有关发行结构和发行处理的部分已移至 &lt;code&gt;OTP Design Principles&lt;/code&gt; &lt;strong&gt;系统文档&lt;/strong&gt;&amp;rdquo;中的&amp;ldquo; OTP设计原则&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4e2ce648e32ac1ae793549c46cd55a4f21a2abef" translate="yes" xml:space="preserve">
          <source>The security level depends on the parameters provided to the TLS connection setup. Erlang node cookies are however always used, as they can be used to differentiate between two different Erlang networks.</source>
          <target state="translated">安全级别取决于提供给TLS连接设置的参数。然而,Erlang节点cookie总是被使用,因为它们可以用来区分两个不同的Erlang网络。</target>
        </trans-unit>
        <trans-unit id="8d926590307164245688269e8d14c40ab7bc091d" translate="yes" xml:space="preserve">
          <source>The selective receive in this case causes implicitly &lt;code&gt;open&lt;/code&gt; to postpone any events to the &lt;code&gt;locked&lt;/code&gt; state.</source>
          <target state="translated">在这种情况下，选择性接收会导致隐式 &lt;code&gt;open&lt;/code&gt; 以将任何事件推迟到 &lt;code&gt;locked&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="5fd2a7b375c615e788c6695ee553f4da41abbaa4" translate="yes" xml:space="preserve">
          <source>The semantics is that a trace message is sent when a call traced function returns, that is, when a chain of tail recursive calls ends. Only one trace message is sent per chain of tail recursive calls, so the properties of tail recursiveness for function calls are kept while tracing with this flag. Using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; trace together makes it possible to know exactly in which function a process executes at any time.</source>
          <target state="translated">语义是当跟踪调用的函数返回时（即尾尾递归调用链结束时）发送跟踪消息。每条尾部递归调用链仅发送一条跟踪消息，因此在使用此标志进行跟踪时，将保留函数调用的尾部递归属性。一起使用 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;return_to&lt;/code&gt; 跟踪，可以随时准确地知道进程在哪个函数中执行。</target>
        </trans-unit>
        <trans-unit id="4de46ccd64eaf7c6a99ec541d1cbcc55c06b408c" translate="yes" xml:space="preserve">
          <source>The semantics of the protocol has jointly been defined by two standardization bodies:</source>
          <target state="translated">该协议的语义由两个标准化机构共同定义。</target>
        </trans-unit>
        <trans-unit id="1ff24da2ee4416d81d99c41d0ad247bd1489bb83" translate="yes" xml:space="preserve">
          <source>The semantics of them and their exact signatures are explained below.</source>
          <target state="translated">下面解释它们的语义及其确切的签名。</target>
        </trans-unit>
        <trans-unit id="b1fa04e102f76c0ed958b51776ec1323ba2b420c" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; in the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在记录中获取 &lt;code&gt;LockKind&lt;/code&gt; 类型的锁。当前，支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dec37a1381140705a37e8b22974825983130016" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在整个表或单个记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁定类型 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="544565c18f11c3bd2d1b3b57f9c37bb23e28513e" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table or on a single record. Currently, the lock type &lt;code&gt;read&lt;/code&gt; is supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在整个表或单个记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁定类型 &lt;code&gt;read&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ac9b81a840d90d3353dd0dc88e91326c5df9221" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the record. Currently, the lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它在记录上获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="398f5d70441c50ce9d5e9fd6b232c3ecc7fd8dc0" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. Currently, the lock types &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。当前，支持锁类型 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb63a329083b4ebe624da3e57823d281920ca895" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt;. The lock types &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;sticky_write&lt;/code&gt; are supported.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取类型为 &lt;code&gt;LockKind&lt;/code&gt; 的锁。支持锁类型 &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;sticky_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03d20c7795cec81709642f2df218bc112e235d99" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires a read lock on the entire table.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取整个表的读锁。</target>
        </trans-unit>
        <trans-unit id="06b7f2394cceb9a5d1549e5bd69d686fb86fba7d" translate="yes" xml:space="preserve">
          <source>The semantics of this function is context-sensitive. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt;. In transaction-context, it acquires locks, otherwise it ignores the request.</source>
          <target state="translated">该函数的语义是上下文相关的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 。在事务上下文中，它获取锁，否则将忽略请求。</target>
        </trans-unit>
        <trans-unit id="c555e927f36b7c980e9c0d2dd029f5af17719b16" translate="yes" xml:space="preserve">
          <source>The send handle is provided by the preferred transport module, e.g. megaco_tcp, megaco_udp. Read the documentation about each transport module about the details.</source>
          <target state="translated">发送句柄是由首选的传输模块提供的,例如 megaco_tcp,megaco_udp。请阅读每个传输模块的文档了解详情。</target>
        </trans-unit>
        <trans-unit id="8783fac7786ee217686c1dc22e76c11e2bd7dd7d" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes no use of this info, so the only use for it in such a configuration (when using the built in net-if) would be tracing.</source>
          <target state="translated">send选项 &lt;code&gt;extra&lt;/code&gt; 指定传递给net-if进程的不透明数据结构。此应用程序中包含的net-if进程不使用此信息，因此在这种配置中（当使用内置的net-if时）唯一可用于跟踪。</target>
        </trans-unit>
        <trans-unit id="461af368454e12216cec44ca03086a38551ee6d2" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;extra&lt;/code&gt; specifies an opaque data structure passed on to the net-if process. The net-if process included in this application makes, with one exception, no use of this info, so the only use for it in such a option (when using the built in net-if) would be tracing. The one usage exception is: &lt;strong&gt;Any&lt;/strong&gt; tuple with &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; as its first element is reserved for internal use.</source>
          <target state="translated">send选项 &lt;code&gt;extra&lt;/code&gt; 指定传递给net-if进程的不透明数据结构。除了一个例外，此应用程序中包含的net-if进程不使用此信息，因此（在使用内置net-if时）在此选项中唯一可使用的将是跟踪。一个使用例外是：&lt;strong&gt;任何&lt;/strong&gt;以 &lt;code&gt;snmpm_extra_info_tag&lt;/code&gt; 作为第一个元素的元组保留供内部使用。</target>
        </trans-unit>
        <trans-unit id="f927792dbf5cf189b45274ee4c9fa05e9b3d6c92" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the management targets. The &lt;code&gt;receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">发送选项 &lt;code&gt;receiver&lt;/code&gt; 指定应将有关Inform-Requests传递的信息发送到何处。代理发送Inform-Requests并等待来自管理目标的确认。该 &lt;code&gt;receiver&lt;/code&gt; 可以有三个值：</target>
        </trans-unit>
        <trans-unit id="b674ec7cb2a069afaa45f294232597630bb8d191" translate="yes" xml:space="preserve">
          <source>The send option &lt;code&gt;timeout&lt;/code&gt; specifies for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">发送选项 &lt;code&gt;timeout&lt;/code&gt; 指定请求有效的时间（此后管理员可以自由删除请求）。</target>
        </trans-unit>
        <trans-unit id="a653cc1f1926ea809d716348869498af401847a8" translate="yes" xml:space="preserve">
          <source>The sender can receive this event if a send operation fails.</source>
          <target state="translated">如果发送操作失败,发送方可以收到这个事件。</target>
        </trans-unit>
        <trans-unit id="8ab6737312426170b7d594e871570564adefdefd" translate="yes" xml:space="preserve">
          <source>The sender of a transaction request has the option of deciding, whether the originating Erlang process should synchronously wait (&lt;code&gt;megaco:call/3&lt;/code&gt;) for a reply or if the message should be sent asynchronously (&lt;code&gt;megaco:cast/3&lt;/code&gt;) and the processing of the reply should be delegated this callback function.</source>
          <target state="translated">事务请求的发送者可以选择确定发起的Erlang进程是否应同步等待（ &lt;code&gt;megaco:call/3&lt;/code&gt; ）答复或是否应异步发送消息（ &lt;code&gt;megaco:cast/3&lt;/code&gt; ）以及处理应将委托委托给此回调函数。</target>
        </trans-unit>
        <trans-unit id="b4cb9ec2065f8938c37ab4fe9dffa3ac54b3a9dd" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file &quot;as is&quot; without any formatting. A link to the file is added to the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF数据被记录到一个单独的文本文件中,没有任何格式化。该文件的链接被添加到测试案例的HTML日志中。</target>
        </trans-unit>
        <trans-unit id="4c9c5717f02ffea08eb9b9a69a645cb0063d78fe" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF数据被记录在一个单独的文本文件中,XML数据被很好地缩进。该文件的链接被添加到测试案例的HTML日志中。</target>
        </trans-unit>
        <trans-unit id="97f2e4431b5646badaae5263442c80d42e8a09b1" translate="yes" xml:space="preserve">
          <source>The sent and received NETCONF traffic is pretty printed directly in the test case HTML log.</source>
          <target state="translated">发送和接收的NETCONF流量很直接地打印在测试用例HTML日志中。</target>
        </trans-unit>
        <trans-unit id="526a6b0c86f2a163790ccae9cdeca981359b2f9f" translate="yes" xml:space="preserve">
          <source>The sequence (?# marks the start of a comment that continues up to the next closing parenthesis. Nested parentheses are not permitted. If option PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which in this case continues to immediately after the next newline character or character sequence in the pattern. Which characters are interpreted as newlines is controlled by the options passed to a compiling function or by a special sequence at the start of the pattern, as described in section &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">序列（？＃表示注释的开始，一直延续到下一个右括号。不允许使用嵌套的括号。如果设置了选项PCRE_EXTENDED，则未转义的＃字符也会引入注释，在这种情况下，注释将继续到注释之后。模式中的下一个换行符或字符序列哪些字符被解释为换行符，是由传递给编译函数的选项控制的，或由模式开头的特殊序列控制的，如前面&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#newline_conventions&quot;&gt;Newline Conventions&lt;/a&gt;&lt;/code&gt; 一节中所述。</target>
        </trans-unit>
        <trans-unit id="17d5ba7a2bea4311848902de65874e5e13256c29" translate="yes" xml:space="preserve">
          <source>The sequence \g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">序列\g后面跟着一个无符号或负数,可选择用括号括起来,是一个绝对或相对的后参照。命名的后引用可以编码为 \g{name}。后引用将在后面的括号子模式讨论中讨论。</target>
        </trans-unit>
        <trans-unit id="cf397042cff1c5cb3ebfe293ff40d06f71fdc8c2" translate="yes" xml:space="preserve">
          <source>The sequence \g{-1} is a reference to the most recently started capturing subpattern before \g, that is, it is equivalent to \2 in this example. Similarly, \g{-2} would be equivalent to \1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves.</source>
          <target state="translated">序列\g{-1}是指在\g之前最近开始捕获的子模式,也就是说,它相当于本例中的\2。同样,\g{-2}也等同于\1。相对引用的使用在长模式中是很有帮助的,在通过连接包含引用的片段而创建的模式中也是如此。</target>
        </trans-unit>
        <trans-unit id="78acc7e07953d38a1ab22f1d92af436b05725d02" translate="yes" xml:space="preserve">
          <source>The sequence number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="a730581ed9394e9f512b17bf00122fa40d5d6a8c" translate="yes" xml:space="preserve">
          <source>The sequence number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">端口 &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="d9835c9de2ba951e30c90819750512630463b537" translate="yes" xml:space="preserve">
          <source>The sequence of steps shown is probably more complex than normal, but it illustrates the amount of functionality which is available. The following points should be noted:</source>
          <target state="translated">所示的一系列步骤可能比正常情况下更复杂,但它说明了可用的功能数量。应注意以下几点:</target>
        </trans-unit>
        <trans-unit id="8ad58d75452c7e291a38fc9baa9ff4ed0360940a" translate="yes" xml:space="preserve">
          <source>The sequences \h, \H, \v, and \V are features that were added to Perl in release 5.10. In contrast to the other sequences, which match only ASCII characters by default, these always match certain high-valued code points, regardless if &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">序列\ h，\ H，\ v和\ V是在5.10版中添加到Perl的功能。与默认情况下仅匹配ASCII字符的其他序列相反，这些序列始终匹配某些高价值代码点，无论是否设置了 &lt;code&gt;ucp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc5373a2646de360aa46ef11847fc92698bb563" translate="yes" xml:space="preserve">
          <source>The serial number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 中的序列号。</target>
        </trans-unit>
        <trans-unit id="8111e7055dd7801086cd5e9dd759c58638f73514" translate="yes" xml:space="preserve">
          <source>The server always sends a certificate chain as part of the TLS handshake, but the client only sends one if requested by the server. If the client does not have an appropriate certificate, it can send an &quot;empty&quot; certificate to the server.</source>
          <target state="translated">服务器总是发送一个证书链作为TLS握手的一部分,但客户端只有在服务器要求时才会发送一个证书链。如果客户端没有合适的证书,它可以向服务器发送一个 &quot;空 &quot;证书。</target>
        </trans-unit>
        <trans-unit id="229d25bbfa88632fdde58ad8585ae739c0a0640c" translate="yes" xml:space="preserve">
          <source>The server can also take the options &lt;code&gt;dhfile&lt;/code&gt; and &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; (also prefixed).</source>
          <target state="translated">服务器还可以采用选项 &lt;code&gt;dhfile&lt;/code&gt; 和 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; （也带有前缀）。</target>
        </trans-unit>
        <trans-unit id="1700b3d48eb2b123d28d0da14b6deae45c75c3b4" translate="yes" xml:space="preserve">
          <source>The server implements numerous features, such as:</source>
          <target state="translated">服务器实现了许多功能,如:。</target>
        </trans-unit>
        <trans-unit id="a419e1724123900e8550b29498eed9bbee902340" translate="yes" xml:space="preserve">
          <source>The server interprets the message headers and most of them are transformed into HTTP headers and sent back to the client together with the message-body.</source>
          <target state="translated">服务器对消息头进行解释,大部分消息头被转化为HTTP头,和消息体一起发回给客户端。</target>
        </trans-unit>
        <trans-unit id="35e7a7b10ff76bf44d32ec3e60b336ed7bd9d091" translate="yes" xml:space="preserve">
          <source>The server is configured using an Erlang property list. For the available properties, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;. For backwards compatibility, apache-like configuration files are also supported.</source>
          <target state="translated">使用Erlang属性列表配置服务器。有关可用属性，请参见 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 。为了向后兼容，还支持类似apache的配置文件。</target>
        </trans-unit>
        <trans-unit id="5e64a9d0d0fd7079393371b1454efd0dd5fbdc81" translate="yes" xml:space="preserve">
          <source>The server name, in this example the atom &lt;code&gt;ch2&lt;/code&gt;, is hidden from the users of the client functions. This means that the name can be changed without affecting them.</source>
          <target state="translated">服务器名称（在此示例中为原子 &lt;code&gt;ch2&lt;/code&gt; )对客户端功能的用户隐藏。这意味着可以更改名称而不会影响它们。</target>
        </trans-unit>
        <trans-unit id="281168d64e74220aa9892e9cc7f847641edee61a" translate="yes" xml:space="preserve">
          <source>The server receives this message and calls:</source>
          <target state="translated">服务器收到此消息后,调用。</target>
        </trans-unit>
        <trans-unit id="e465284becdbbb53a7c1b2b2feedaf65818bc0a6" translate="yes" xml:space="preserve">
          <source>The server side must abort any ongoing operations, release any locks and resources associated with the session, and close any associated connections.</source>
          <target state="translated">服务器端必须中止任何正在进行的操作,释放任何与会话相关的锁和资源,并关闭任何相关的连接。</target>
        </trans-unit>
        <trans-unit id="eada9e87d673d14717c1c6d8d19ed52103f05b62" translate="yes" xml:space="preserve">
          <source>The service is being started or stopped. No event precedes a &lt;code&gt;start&lt;/code&gt; event. No event follows a &lt;code&gt;stop&lt;/code&gt; event, and this event implies the termination of all transport processes.</source>
          <target state="translated">服务正在启动或停止。 &lt;code&gt;start&lt;/code&gt; 事件之前没有事件。 &lt;code&gt;stop&lt;/code&gt; 事件之后没有事件，并且此事件表示所有传输过程的终止。</target>
        </trans-unit>
        <trans-unit id="0bb9705bf71fb4b8fce2bf74aeec82fd5334268d" translate="yes" xml:space="preserve">
          <source>The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer (&lt;code&gt;connect&lt;/code&gt;) or by accepting incoming connection requests (&lt;code&gt;listen&lt;/code&gt;). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many.</source>
          <target state="translated">该服务将根据需要启动传输过程，以通过与对等方建立连接（ &lt;code&gt;connect&lt;/code&gt; ）或接受传入的连接请求（ &lt;code&gt;listen&lt;/code&gt; ）来建立与对等方的连接。连接传输最多与一个对等点建立传输连接，侦听传输可能与许多对等点建立传输连接。</target>
        </trans-unit>
        <trans-unit id="d2cadccf6e95d9c9b64838c77b38958e4188f878" translate="yes" xml:space="preserve">
          <source>The session is closed.</source>
          <target state="translated">本届会议闭幕。</target>
        </trans-unit>
        <trans-unit id="7cd1dac17852f58fd5b35cb68eccba90aabb1d2d" translate="yes" xml:space="preserve">
          <source>The set of admissible SCTP socket options is by construction orthogonal to the sets of TCP, UDP, and generic &lt;code&gt;inet&lt;/code&gt; options. Only options listed here are allowed for SCTP sockets. Options can be set on the socket using &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, retrieved using &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt;. Options can be changed when calling &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">允许的SCTP套接字选项集在构造上与TCP，UDP和通用 &lt;code&gt;inet&lt;/code&gt; 选项集正交。SCTP套接字仅允许使用此处列出的选项。可以使用 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 在套接字上设置选项，并使用 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; 进行检索。调用 &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4,5&lt;/a&gt;&lt;/code&gt; 时可以更改选项。</target>
        </trans-unit>
        <trans-unit id="ab0f75a569127c073d8755a64ed39c5868d2acc4" translate="yes" xml:space="preserve">
          <source>The set of algorithms that the SSH app uses by default depends on the algoritms supported by the:</source>
          <target state="translated">SSH应用程序默认使用的算法集取决于所支持的算法。</target>
        </trans-unit>
        <trans-unit id="735c513e608e0b547b56dcea8d9766ffad148df8" translate="yes" xml:space="preserve">
          <source>The set of integers returned by &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; using different sets of &lt;code&gt;Modifier&lt;/code&gt;s &lt;strong&gt;will overlap&lt;/strong&gt;. For example, by calling &lt;code&gt;unique_integer([monotonic])&lt;/code&gt;, and &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; repeatedly, you will eventually see some integers that are returned by both calls.</source>
          <target state="translated">该组由返回整数 &lt;code&gt;erlang:unique_integer/1&lt;/code&gt; 使用不同组的 &lt;code&gt;Modifier&lt;/code&gt; 小号&lt;strong&gt;就会重叠&lt;/strong&gt;。例如，通过 &lt;code&gt;unique_integer([monotonic])&lt;/code&gt; 调用unique_integer（[monotonic]）和 &lt;code&gt;unique_integer([positive, monotonic])&lt;/code&gt; ，您最终将看到两个调用都返回一些整数。</target>
        </trans-unit>
        <trans-unit id="192a51abc57907a3173222d0f7d8aab02a2d5adc" translate="yes" xml:space="preserve">
          <source>The set of nodes that makes up a Mnesia system is kept in a schema. Mnesia nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function &lt;code&gt;mnesia:create_schema/1&lt;/code&gt;. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the startup procedure, Mnesia exchanges schema information between the nodes to verify that the table definitions are compatible.</source>
          <target state="translated">组成Mnesia系统的节点集保留在架构中。 Mnesia节点可以添加到架构中，也可以从架构中删除。通常使用功能 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 在磁盘上创建初始模式。在无盘节点上，每次启动Mnesia时都会生成一个很小的默认架构。在启动过程中，Mnesia在节点之间交换架构信息，以验证表定义是否兼容。</target>
        </trans-unit>
        <trans-unit id="e6b6ca74b9f0531554c93c10cb1c7070b93217b8" translate="yes" xml:space="preserve">
          <source>The set of predefined types and the syntax for types follows:</source>
          <target state="translated">预定义类型集和类型的语法如下。</target>
        </trans-unit>
        <trans-unit id="d57bb3e21d7efc4c4d6d866577c535b86827e6e3" translate="yes" xml:space="preserve">
          <source>The set of valid &lt;strong&gt;guard expressions&lt;/strong&gt; (sometimes called guard tests) is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</source>
          <target state="translated">有效的&lt;strong&gt;保护表达式集&lt;/strong&gt;（有时称为保护测试）是有效的Erlang表达式集的子集。限制有效表达式集的原因是，必须确保对保护表达式的评估没有副作用。有效的保护表达式如下：</target>
        </trans-unit>
        <trans-unit id="4b4e6c237902f03c9d37f0c7a6d60075f64b2cbe" translate="yes" xml:space="preserve">
          <source>The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that:</source>
          <target state="translated">本模块所识别的集合由关系Sets的元素表示,关系Sets被定义为最小的集合,即:</target>
        </trans-unit>
        <trans-unit id="2cd8e823885a626feb78a98cd7d6126c5141df4e" translate="yes" xml:space="preserve">
          <source>The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms:</source>
          <target state="translated">由Sets代表的集合是由Sets到Erlang项和Erlang项集合的函数Set范围的元素。</target>
        </trans-unit>
        <trans-unit id="1e6bfb67315ff8c660eaf25c1733e37c10bf2a84" translate="yes" xml:space="preserve">
          <source>The setting has no effect on a halt log.</source>
          <target state="translated">该设置对停止日志没有影响。</target>
        </trans-unit>
        <trans-unit id="708e1c55726f99e92712010fcf842caa93f6beee" translate="yes" xml:space="preserve">
          <source>The settings of the Perl-compatible options &lt;code&gt;caseless&lt;/code&gt;, &lt;code&gt;multiline&lt;/code&gt;, &lt;code&gt;dotall&lt;/code&gt;, and &lt;code&gt;extended&lt;/code&gt; can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows:</source>
          <target state="translated">Perl兼容选项 &lt;code&gt;caseless&lt;/code&gt; ， &lt;code&gt;multiline&lt;/code&gt; ， &lt;code&gt;dotall&lt;/code&gt; 和 &lt;code&gt;extended&lt;/code&gt; 可以在模式中通过用&amp;ldquo;（？&amp;rdquo;和&amp;ldquo;）&amp;rdquo;之间的一系列Perl选项字母进行更改。选项字母如下：</target>
        </trans-unit>
        <trans-unit id="20fbd9576783a14ac9df5dccf183005898be344d" translate="yes" xml:space="preserve">
          <source>The severity level for the message to be logged.</source>
          <target state="translated">要记录的消息的严重程度。</target>
        </trans-unit>
        <trans-unit id="906ae5d296f5eecb26331f0380669f16fbcadddb" translate="yes" xml:space="preserve">
          <source>The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.</source>
          <target state="translated">shell还允许用户启动多个并发作业。一个作业可以看作是一组可以与shell通信的进程。</target>
        </trans-unit>
        <trans-unit id="3c5f2ea6c7e1929748b9a3f26e85b7652daf0ffd" translate="yes" xml:space="preserve">
          <source>The shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if allowed. This feature makes it possible to, for example, prevent a user from accidentally calling a function from the prompt that could harm a running system (useful in combination with system flag &lt;code&gt;+Bi&lt;/code&gt;).</source>
          <target state="translated">外壳程序可以以受限模式启动。在这种模式下，shell仅在允许的情况下评估函数调用。例如，使用此功能可以防止用户从提示中意外调用可能损害正在运行的系统的功能（与系统标志 &lt;code&gt;+Bi&lt;/code&gt; 结合使用）。</target>
        </trans-unit>
        <trans-unit id="6b1db3783eaf47b941529ec43e9feba2a87d50ce" translate="yes" xml:space="preserve">
          <source>The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules &lt;code&gt;shell_default&lt;/code&gt; and &lt;code&gt;user_default&lt;/code&gt; (if loaded) are read each time a new job is started. For example, adding the following line to &lt;code&gt;user_default&lt;/code&gt; makes the definition of &lt;code&gt;file_info&lt;/code&gt; readily available in the shell:</source>
          <target state="translated">下面介绍了用于读取，定义，忘记，列出和打印记录的shell命令。请注意，每个作业都有其自己的记录定义集。为方便 &lt;code&gt;shell_default&lt;/code&gt; ，每次启动新作业时都会读取shell_default和 &lt;code&gt;user_default&lt;/code&gt; 模块（如果已加载）中的记录定义。例如，添加下列行来 &lt;code&gt;user_default&lt;/code&gt; 使得定义 &lt;code&gt;file_info&lt;/code&gt; 在壳容易获得的：</target>
        </trans-unit>
        <trans-unit id="0dffc89af87f5c93512d139994f93842341103ef" translate="yes" xml:space="preserve">
          <source>The shell escape key &lt;code&gt;^G&lt;/code&gt; (Control G) detaches the current job and activates &lt;code&gt;JCL&lt;/code&gt; mode. The &lt;code&gt;JCL&lt;/code&gt; mode prompt is &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt;. If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is entered at the prompt, the following help message is displayed:</source>
          <target state="translated">Shell退出键 &lt;code&gt;^G&lt;/code&gt; （控制G）将分离当前作业并激活 &lt;code&gt;JCL&lt;/code&gt; 模式。的 &lt;code&gt;JCL&lt;/code&gt; 模式提示是 &lt;code&gt;&quot;--&amp;gt;&quot;&lt;/code&gt; 。如果是 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 在提示符下输入时，将显示以下帮助消息：</target>
        </trans-unit>
        <trans-unit id="f22132507cc2cbecae41be645fa330c7e74cc00c" translate="yes" xml:space="preserve">
          <source>The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt;, or by setting the application configuration parameters &lt;code&gt;shell_history_length&lt;/code&gt; and &lt;code&gt;shell_saved_results&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">该外壳是用于输入表达序列的用户界面程序。计算表达式并返回一个值。历史记录机制保存以前的命令及其值，然后可以将其合并到以后的命令中。用户可以交互方式，通过调用 &lt;code&gt;&lt;a href=&quot;#history-1&quot;&gt;history/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#results-1&quot;&gt;results/1&lt;/a&gt;&lt;/code&gt; 或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_history_length&lt;/code&gt; 和 &lt;code&gt;shell_saved_results&lt;/code&gt; 来确定要保存多少命令和结果。</target>
        </trans-unit>
        <trans-unit id="8b3c2d38847db4b9d384443450a1704fbe5a9310" translate="yes" xml:space="preserve">
          <source>The shell is usually not invoked to start the program, it is executed directly. &lt;code&gt;PATH&lt;/code&gt; (or equivalent) is not searched. To find a program in &lt;code&gt;PATH&lt;/code&gt; to execute, use &lt;code&gt;os:find_executable/1&lt;/code&gt;.</source>
          <target state="translated">通常不调用Shell来启动程序，而是直接执行。不搜索 &lt;code&gt;PATH&lt;/code&gt; （或等效路径）。要在 &lt;code&gt;PATH&lt;/code&gt; 中找到要执行的程序，请使用 &lt;code&gt;os:find_executable/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ba8c777e2892e18ef92162fb3ae948b677e7e96" translate="yes" xml:space="preserve">
          <source>The shell mode is useful, for example, for debugging test suites, analyzing and debugging the SUT during &quot;simulated&quot; test case execution, and trying out various operations during test suite development.</source>
          <target state="translated">例如,shell模式对于调试测试套件、在 &quot;模拟 &quot;测试用例执行过程中分析和调试SUT,以及在测试套件开发过程中尝试各种操作都很有用。</target>
        </trans-unit>
        <trans-unit id="dccc3d081d31c25afe702e15e4a49fe7f5d58e4e" translate="yes" xml:space="preserve">
          <source>The shell runs in two modes:</source>
          <target state="translated">shell以两种模式运行。</target>
        </trans-unit>
        <trans-unit id="547a340a87f4e04c610a24150bcba68bc72ae2d3" translate="yes" xml:space="preserve">
          <source>The shell script &lt;code&gt;start&lt;/code&gt;, which is generated from erts-5.10.4/bin/start.src during installation, is only an example. Edit it to suite your needs. Typically it is executed when the UNIX system boots.</source>
          <target state="translated">仅在安装过程中从erts-5.10.4 / bin / start.src生成的shell脚本 &lt;code&gt;start&lt;/code&gt; 。编辑它以满足您的需求。通常，它在UNIX系统引导时执行。</target>
        </trans-unit>
        <trans-unit id="49dd983c72c713d084adde4deb3fce82550d00d2" translate="yes" xml:space="preserve">
          <source>The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; or by setting the application configuration parameter &lt;code&gt;shell_catch_exception&lt;/code&gt; for the STDLIB application this behavior can be changed. See also the example below.</source>
          <target state="translated">Shell使用帮助程序进程来评估命令，以保护历史记录机制免受异常影响。默认情况下，发生异常时，评估程序将被 &lt;code&gt;&lt;a href=&quot;#catch_exception-1&quot;&gt;catch_exception/1&lt;/a&gt;&lt;/code&gt; ，但是可以通过调用catch_exception / 1或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_catch_exception&lt;/code&gt; 来更改此行为。另请参见下面的示例。</target>
        </trans-unit>
        <trans-unit id="aa42edd7ea14c7efba24c3aff26f9dcace9d4328" translate="yes" xml:space="preserve">
          <source>The short version: choose &lt;code&gt;state_functions&lt;/code&gt; - it is the one most like &lt;code&gt;gen_fsm&lt;/code&gt;. But if you do not want the restriction that the state must be an atom, or if you do not want to write one event handler function per state; please read on...</source>
          <target state="translated">简短的版本：选择 &lt;code&gt;state_functions&lt;/code&gt; -最类似于 &lt;code&gt;gen_fsm&lt;/code&gt; 。但是，如果您不希望状态必须是一个原子的限制，或者不想为每个状态编写一个事件处理程序函数，则可以；请继续阅读...</target>
        </trans-unit>
        <trans-unit id="8fc2135229ea382a9e721c2e40582626084b92c6" translate="yes" xml:space="preserve">
          <source>The shortcuts are as follows:</source>
          <target state="translated">捷径如下:</target>
        </trans-unit>
        <trans-unit id="ecbf2eb1175e2e5b06e38c7c0a22fd7f8f8611cd" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished repeatedly and reliably when reading time values. Precision is limited by the &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt;, but resolution and precision can differ significantly.</source>
          <target state="translated">读取时间值时可以重复可靠地区分的最短时间间隔。精度受 &lt;code&gt;&lt;a href=&quot;#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 限制，但分辨率和精度可能会有很大差异。</target>
        </trans-unit>
        <trans-unit id="f84d7886a0f9257a8fa3cb849cd4e77cfe8aa126" translate="yes" xml:space="preserve">
          <source>The shortest time interval that can be distinguished when reading time values.</source>
          <target state="translated">读取时间值时,可以区分的最短时间间隔。</target>
        </trans-unit>
        <trans-unit id="d2bb1e51130dab7f5283d9470e62aab2d5f6ca06" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the child specification of the supervisor is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">主管的子级规范中定义的关闭策略是整数超时值，而不是 &lt;code&gt;brutal_kill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c80708d1012fab3c8f472912a306a1e18b063172" translate="yes" xml:space="preserve">
          <source>The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not &lt;code&gt;brutal_kill&lt;/code&gt;.</source>
          <target state="translated">主管的子级规范中定义的关闭策略是整数超时值，而不是 &lt;code&gt;brutal_kill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9028aec69bf73d6c7de5318e8338d0a2f1c2357" translate="yes" xml:space="preserve">
          <source>The signal &lt;code&gt;SIGUSR2&lt;/code&gt; is reserved for internal usage. No other signals are handled.</source>
          <target state="translated">信号 &lt;code&gt;SIGUSR2&lt;/code&gt; 保留供内部使用。没有其他信号被处理。</target>
        </trans-unit>
        <trans-unit id="d074b9e825fff0fd1ebfc3258cb4dafc95050e70" translate="yes" xml:space="preserve">
          <source>The signal carries information about the pid it was sent from and the exit reason.</source>
          <target state="translated">该信号携带着从哪里发出的pid和退出原因的信息。</target>
        </trans-unit>
        <trans-unit id="186b6e9957386fe2a5f08032e0ba5ef2925f605f" translate="yes" xml:space="preserve">
          <source>The signedness specification can be either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. Notice that signedness only matters for matching.</source>
          <target state="translated">签名规范可以是已 &lt;code&gt;signed&lt;/code&gt; 或未 &lt;code&gt;unsigned&lt;/code&gt; 。请注意，签名仅对匹配很重要。</target>
        </trans-unit>
        <trans-unit id="0a422acc04b6a76708f58fc88d786a11c4476b80" translate="yes" xml:space="preserve">
          <source>The simple event handler sends all alarms as info reports to the error logger, and saves all in a list. This list can be passed to a user-defined event handler, which can be installed later. The list can grow large if many alarms are generated. This is a good reason to install a better user-defined handler.</source>
          <target state="translated">简单的事件处理程序将所有的报警以信息报告的形式发送到错误记录器,并将所有的报警保存在一个列表中。这个列表可以传递给用户定义的事件处理程序,可以在以后安装。如果产生了很多报警,这个列表可能会变得很大。这是个很好的理由,可以安装一个更好的用户自定义处理程序。</target>
        </trans-unit>
        <trans-unit id="863023573a43dd8e0ae2605daf1e7cad870d2b5e" translate="yes" xml:space="preserve">
          <source>The simple server from &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;, implemented using &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; so it fits into a supervision tree:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; 的简单服务器，使用 &lt;code&gt;sys&lt;/code&gt; 和 &lt;code&gt;proc_lib&lt;/code&gt; 实现，因此适合于监视树：</target>
        </trans-unit>
        <trans-unit id="2b9f3602307725a54911301be89734f09963d9b4" translate="yes" xml:space="preserve">
          <source>The simple-form structure is any of &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt;, &lt;code&gt;{Tag, Content}&lt;/code&gt; or &lt;code&gt;Tag&lt;/code&gt; where:</source>
          <target state="translated">简单形式的结构是 &lt;code&gt;{Tag, Attributes, Content}&lt;/code&gt; ， &lt;code&gt;{Tag, Content}&lt;/code&gt; 或 &lt;code&gt;Tag&lt;/code&gt; 中的任何一个，其中：</target>
        </trans-unit>
        <trans-unit id="020fdda90aa20fcb7b4204c69ad0944a63e101ce" translate="yes" xml:space="preserve">
          <source>The simplest SSL/TLS options in the following list can be specified by adding the prefix &lt;code&gt;server_&lt;/code&gt; or &lt;code&gt;client_&lt;/code&gt; to the option name:</source>
          <target state="translated">可以通过在选项名称中添加前缀 &lt;code&gt;server_&lt;/code&gt; 或 &lt;code&gt;client_&lt;/code&gt; 来指定以下列表中最简单的SSL / TLS选项：</target>
        </trans-unit>
        <trans-unit id="67ab52b7039e217a939df83566a221e65ed54107" translate="yes" xml:space="preserve">
          <source>The simplest applications do not have any processes, but consist of a collection of functional modules. Such an application is called a &lt;strong&gt;library application&lt;/strong&gt;. An example of a library application is STDLIB.</source>
          <target state="translated">最简单的应用程序没有任何过程，但是由功能模块的集合组成。这样的应用程序称为&lt;strong&gt;库应用程序&lt;/strong&gt;。库应用程序的一个示例是STDLIB。</target>
        </trans-unit>
        <trans-unit id="9d81d04034c8d22db20deb185b1f215da194b3b1" translate="yes" xml:space="preserve">
          <source>The simplest boot script possible includes only the Kernel and STDLIB applications. Such a script is located in the &lt;code&gt;bin&lt;/code&gt; directory of the Erlang distribution. The source for the script is found under the Erlang installation top directory under &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt;.</source>
          <target state="translated">最简单的启动脚本可能仅包括内核和STDLIB应用程序。这样的脚本位于Erlang发行版的 &lt;code&gt;bin&lt;/code&gt; 目录中。该脚本的源代码位于 &lt;code&gt;releases/&amp;lt;OTP version&amp;gt;/start_clean.rel&lt;/code&gt; 下的Erlang安装目录下。</target>
        </trans-unit>
        <trans-unit id="d6fd995f7841419eb481c6384fc5f636193cf5af" translate="yes" xml:space="preserve">
          <source>The simplest case is to segment the input string into a list of identifiers (atoms) and use those atoms both as categories and values of the tokens. For example, the input string &lt;code&gt;aaa bbb 777, X&lt;/code&gt; may be scanned (tokenized) as:</source>
          <target state="translated">最简单的情况是将输入字符串分成标识符（原子）列表，并将这些原子用作标记的类别和值。例如，输入字符串 &lt;code&gt;aaa bbb 777, X&lt;/code&gt; 可能被扫描（标记为）：</target>
        </trans-unit>
        <trans-unit id="010ac940341106a56ccca622ae5fd2705ac4ec5a" translate="yes" xml:space="preserve">
          <source>The simplest form of expression is a term, that is an integer, float, atom, string, list, map, or tuple. The return value is the term itself.</source>
          <target state="translated">最简单的表达式是一个术语,即整数、浮点数、原子、字符串、列表、映射或元组。返回值是术语本身。</target>
        </trans-unit>
        <trans-unit id="da4929ec0fe8e8e239995092f36e1eed41d6db7c" translate="yes" xml:space="preserve">
          <source>The simplest usage is to call &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最简单的用法是调用 &lt;code&gt;&lt;a href=&quot;#utilization-1&quot;&gt;scheduler:utilization(Seconds)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc802fe07c47aed57126bce485b313dc00cf24cf" translate="yes" xml:space="preserve">
          <source>The simplest way of tracing from the Erlang shell is to use &lt;code&gt;dbg:c/3&lt;/code&gt; or &lt;code&gt;dbg:c/4&lt;/code&gt;, e.g. tracing the function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt;:</source>
          <target state="translated">从Erlang shell进行跟踪的最简单方法是使用 &lt;code&gt;dbg:c/3&lt;/code&gt; 或 &lt;code&gt;dbg:c/4&lt;/code&gt; ，例如，跟踪函数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd591e91084c3f463556c98ff8fcc73c0b642942" translate="yes" xml:space="preserve">
          <source>The simplest way to send a notification is to call the function &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt;. In this case, the agent performs a get-operation to retrieve the object values that are defined in the notification specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros). The notification is sent to all managers defined in the target and notify tables, either unacknowledged as traps, or acknowledged as inform requests.</source>
          <target state="translated">发送通知的最简单方法是调用函数 &lt;code&gt;snmpa:send_notification(Agent, Notification, no_receiver)&lt;/code&gt; 。在这种情况下，代理执行获取操作以检索在通知规范中定义的对象值（使用TRAP-TYPE或NOTIFICATION-TYPE宏）。该通知将发送到目标和通知表中定义的所有管理器，它们要么未被确认为陷阱，要么被确认为通知请求。</target>
        </trans-unit>
        <trans-unit id="67648b768786640bf14fe9b8b58cbe1c7d6f3c6d" translate="yes" xml:space="preserve">
          <source>The simplest way to use EUnit in an Erlang module is to add the following line at the beginning of the module (after the &lt;code&gt;-module&lt;/code&gt; declaration, but before any function definitions):</source>
          <target state="translated">在Erlang模块中使用EUnit的最简单方法是在模块的开头（在 &lt;code&gt;-module&lt;/code&gt; 声明之后，但在任何函数定义之前）添加以下行：</target>
        </trans-unit>
        <trans-unit id="94829f2b959259f751a0e01f1565faf0e83453ae" translate="yes" xml:space="preserve">
          <source>The simplest way to use the setting is to call &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;, which uses the return value of this function to decide if a list is a string of printable characters.</source>
          <target state="translated">使用该设置的最简单方法是调用 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; ，它使用此函数的返回值来确定列表是否为可打印字符的字符串。</target>
        </trans-unit>
        <trans-unit id="410ab688ad74fcb927d318148676d55f9fa41dc2" translate="yes" xml:space="preserve">
          <source>The sixth argument is the instance number.</source>
          <target state="translated">第六个参数是实例号。</target>
        </trans-unit>
        <trans-unit id="09584020841c67187a5e4c45090a98af5e53582d" translate="yes" xml:space="preserve">
          <source>The size and offset of the specific field</source>
          <target state="translated">特定字段的大小和偏移量</target>
        </trans-unit>
        <trans-unit id="04a41d7d5ebfc159ad47e6d9484bf8d344a4ee18" translate="yes" xml:space="preserve">
          <source>The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later.</source>
          <target state="translated">如果表是公共的,在转储过程中,表的记录会被添加或删除,那么表头的大小字段可能与文件中的记录数不一致。在转储过程中更新的公共表,在读取时想要验证,至少需要一个字段的扩展信息,以便以后读取验证过程可靠。</target>
        </trans-unit>
        <trans-unit id="15a82dee25c7ae3a3f7d6659ea3993b106858ed6" translate="yes" xml:space="preserve">
          <source>The size includes 233 words for the heap area (which includes the stack). The garbage collector increases the heap as needed.</source>
          <target state="translated">大小包括233字的堆区(包括栈)。垃圾收集器会根据需要增加堆的大小。</target>
        </trans-unit>
        <trans-unit id="b0f54d25af981835a640f1718c86bf5f2b930bc6" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;Dgram&lt;/code&gt; is less than &lt;code&gt;4*HLen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 的大小小于 &lt;code&gt;4*HLen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="240cf2840ab83e06087b3c823b3105d452ce4e2c" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;struct tcp_info&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;struct tcp_info&lt;/code&gt; 的大小</target>
        </trans-unit>
        <trans-unit id="1b6bd4cbaa0c4a01c449ef3a984d1775fb023405" translate="yes" xml:space="preserve">
          <source>The size of the &quot;old heap&quot;. The Erlang virtual machine uses generational garbage collection with two generations. There is one heap for new data items and one for the data that has survived two garbage collections. The assumption (which is almost always correct) is that data surviving two garbage collections can be &quot;tenured&quot; to a heap more seldom garbage collected, as they will live for a long period. This is a usual technique in virtual machines. The sum of the heaps and stack together constitute most of the allocated memory of the process.</source>
          <target state="translated">老堆 &quot;的大小。Erlang虚拟机采用代际垃圾收集,有两代。新数据项有一个堆,两次垃圾收集后存活的数据有一个堆。假设(几乎总是正确的)是,经过两次垃圾收集幸存下来的数据可以被 &quot;终身 &quot;到一个更少被垃圾收集的堆中,因为它们会活很长时间。这在虚拟机中是一种常用的技术。堆和栈的总和一起构成了进程的大部分分配内存。</target>
        </trans-unit>
        <trans-unit id="8045fd58723fbeefad6762911d1edbd926bdac7b" translate="yes" xml:space="preserve">
          <source>The size of the &lt;code&gt;PlainText&lt;/code&gt; must be less than &lt;code&gt;byte_size(N)-11&lt;/code&gt; if &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; is used, and &lt;code&gt;byte_size(N)&lt;/code&gt; if &lt;code&gt;rsa_no_padding&lt;/code&gt; is used, where N is public modulus of the RSA key.</source>
          <target state="translated">的大小 &lt;code&gt;PlainText&lt;/code&gt; 必须小于 &lt;code&gt;byte_size(N)-11&lt;/code&gt; 如果 &lt;code&gt;rsa_pkcs1_padding&lt;/code&gt; 被使用，并且 &lt;code&gt;byte_size(N)&lt;/code&gt; 如果 &lt;code&gt;rsa_no_padding&lt;/code&gt; 被使用，其中，N是RSA密钥的公共模量。</target>
        </trans-unit>
        <trans-unit id="20a866d073ca584886db7c9d897f09b98c62abbf" translate="yes" xml:space="preserve">
          <source>The size of the call counters is the host machine word size. One bit is used when pausing the counter, so the maximum counter value for a 32-bit host is 2147483647.</source>
          <target state="translated">调用计数器的大小是主机的字大小。暂停计数器时要用一个位,所以32位主机的最大计数器值是2147483647。</target>
        </trans-unit>
        <trans-unit id="fb56015c8eab043674edf8d83f2180e86ae9a77a" translate="yes" xml:space="preserve">
          <source>The size of the compressed file (the size of the uncompressed file is found in &lt;code&gt;info&lt;/code&gt;)</source>
          <target state="translated">压缩文件的大小（可在 &lt;code&gt;info&lt;/code&gt; 中找到未压缩文件的大小）</target>
        </trans-unit>
        <trans-unit id="2f0d2a526b810e744210895a97ddddfb9dfdd679" translate="yes" xml:space="preserve">
          <source>The size of the data that survived the previous garbage collection.</source>
          <target state="translated">上次垃圾收集后存活的数据大小。</target>
        </trans-unit>
        <trans-unit id="e9d65b80debf675400c50641feff8560b459d932" translate="yes" xml:space="preserve">
          <source>The size of the encoded values was 458 bytes for &lt;code&gt;GUI&lt;/code&gt; and 464 bytes for &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GUI&lt;/code&gt; 的编码值大小为458 字节， &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 的编码值为464字节。</target>
        </trans-unit>
        <trans-unit id="6de9b33cf1949c23faaaa88b249a1008b2802a9a" translate="yes" xml:space="preserve">
          <source>The size of the largest contiguous free memory block available to the Erlang emulator.</source>
          <target state="translated">Erlang仿真器可用的最大的连续可用内存块的大小。</target>
        </trans-unit>
        <trans-unit id="6d118a2b54a2818588ac5a0110de6ef29741d438" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the heap and the stack.</source>
          <target state="translated">用于存储堆和栈的内存块的大小。</target>
        </trans-unit>
        <trans-unit id="e6c71457bdeadfc9d10261846b10fe6f6d7f7a91" translate="yes" xml:space="preserve">
          <source>The size of the memory block used for storing the old heap.</source>
          <target state="translated">用于存储旧堆的内存块的大小。</target>
        </trans-unit>
        <trans-unit id="dc966159ad664aaf70a48fd1f0edce70ddc61365" translate="yes" xml:space="preserve">
          <source>The size of the process in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 获得的进程大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="764453484226497e0bb92b39542a42c4b18f03bf" translate="yes" xml:space="preserve">
          <source>The size of the process, in bytes, obtained by a call to &lt;code&gt;process_info(Pid,memory)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;process_info(Pid,memory)&lt;/code&gt; 获得的进程大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="191298b20bbe06d47611b490fefa2f8a4b372b8e" translate="yes" xml:space="preserve">
          <source>The size of the stack and heap (they share memory segment).</source>
          <target state="translated">栈和堆的大小(它们共享内存段)。</target>
        </trans-unit>
        <trans-unit id="178ae932ebc1af7c2dda4dfd8f46a38ebd32810a" translate="yes" xml:space="preserve">
          <source>The size of the stack.</source>
          <target state="translated">栈的大小。</target>
        </trans-unit>
        <trans-unit id="8f1488fc1dd7db66c80f3a57b0e5af0af66de229" translate="yes" xml:space="preserve">
          <source>The size of the tail must be evenly divisible by 8.</source>
          <target state="translated">尾巴的大小必须均匀地除以8。</target>
        </trans-unit>
        <trans-unit id="0d0d88986d4bbf13803d8e24b41f46f6997c4e2c" translate="yes" xml:space="preserve">
          <source>The size of the used part of the heap.</source>
          <target state="translated">堆中已使用部分的大小。</target>
        </trans-unit>
        <trans-unit id="2b09e2b23bece918b025556de700326cad53b8b5" translate="yes" xml:space="preserve">
          <source>The size of the used part of the old heap.</source>
          <target state="translated">旧堆的使用部分的大小。</target>
        </trans-unit>
        <trans-unit id="6b3a8f533f48a479fd53920b8d4e9fa6257ad510" translate="yes" xml:space="preserve">
          <source>The size of the user-level software buffer used by the driver. Not to be confused with options &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt;, which correspond to the Kernel socket buffers. It is recommended to have &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; to avoid performance issues because of unnecessary copying. &lt;code&gt;val(buffer)&lt;/code&gt; is automatically set to the above maximum when values &lt;code&gt;sndbuf&lt;/code&gt; or &lt;code&gt;recbuf&lt;/code&gt; are set. However, as the sizes set for &lt;code&gt;sndbuf&lt;/code&gt; and &lt;code&gt;recbuf&lt;/code&gt; usually become larger, you are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to analyze the behavior of your operating system.</source>
          <target state="translated">驱动程序使用的用户级软件缓冲区的大小。不要与 &lt;code&gt;sndbuf&lt;/code&gt; 和 &lt;code&gt;recbuf&lt;/code&gt; 选项混淆，它们与内核套接字缓冲区相对应。建议使 &lt;code&gt;val(buffer) &amp;gt;= max(val(sndbuf),val(recbuf))&lt;/code&gt; 避免由于不必要的复制而导致的性能问题。当设置了值 &lt;code&gt;sndbuf&lt;/code&gt; 或 &lt;code&gt;recbuf&lt;/code&gt; 时， &lt;code&gt;val(buffer)&lt;/code&gt; 会自动设置为上述最大值。但是，由于为 &lt;code&gt;sndbuf&lt;/code&gt; 和 &lt;code&gt;recbuf&lt;/code&gt; 设置的大小通常会变大，因此建议您使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 来分析操作系统的行为。</target>
        </trans-unit>
        <trans-unit id="0337cb0052fe5c48f17d9708364b5583f847dcf3" translate="yes" xml:space="preserve">
          <source>The size used by the atom table.</source>
          <target state="translated">原子表使用的大小。</target>
        </trans-unit>
        <trans-unit id="e83812695b4a0e2f148a81a290a4a4d654c89eac" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of a log file before switching to a new log file. Defaults to 100000, minimum is 1000, maximum is about 2^30.</source>
          <target state="translated">在切换到新的日志文件之前,日志文件的大小,以字节为单位。默认为100000,最小为1000,最大约为2^30。</target>
        </trans-unit>
        <trans-unit id="50b5375e0c8bae3f537af36dd5bfe134a6c1fd3a" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel receive buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(recbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">此套接字的OS内核接收缓冲区的大小（以字节为单位）。对于大于 &lt;code&gt;val(recbuf)&lt;/code&gt; 的数据报，将发生发送错误。设置此选项还可以调整驱动程序缓冲区的大小（请参见上面的 &lt;code&gt;buffer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="744f9981cac8532f8de991a560a3c78c830d93a6" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the OS kernel send buffer for this socket. Sending errors would occur for datagrams larger than &lt;code&gt;val(sndbuf)&lt;/code&gt;. Setting this option also adjusts the size of the driver buffer (see &lt;code&gt;buffer&lt;/code&gt; above).</source>
          <target state="translated">此套接字的OS内核发送缓冲区的大小（以字节为单位）。对于大于 &lt;code&gt;val(sndbuf)&lt;/code&gt; 的数据报，将发生发送错误。设置此选项还可以调整驱动程序缓冲区的大小（请参见上面的 &lt;code&gt;buffer&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80ca8cbf4860dc45abcab2ee816502487d967651" translate="yes" xml:space="preserve">
          <source>The sizes of the log events affect the memory needs of the handler. For information about how to limit the size of log events, see the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">日志事件的大小会影响处理程序的内存需求。有关如何限制日志事件大小的信息，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="e2bdd08787f901adfc9bda5806a8294e711f82f7" translate="yes" xml:space="preserve">
          <source>The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used.</source>
          <target state="translated">从属节点要在主节点使用相同的文件系统。至少,Erlang/OTP要安装在两台计算机的同一个地方,并且要使用相同版本的Erlang。</target>
        </trans-unit>
        <trans-unit id="f96a0c0475b2702681a975d50f5c5275575ff811" translate="yes" xml:space="preserve">
          <source>The slave node resets its &lt;code&gt;user&lt;/code&gt; process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master.</source>
          <target state="translated">从属节点重置其 &lt;code&gt;user&lt;/code&gt; 进程，以便在从属节点上生成的所有终端I / O自动中继到主节点。同样，文件过程将中继到主服务器。</target>
        </trans-unit>
        <trans-unit id="c5dfcb751ff28f219d1d581b79806c8ef4c53f7f" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt;, passing along &lt;code&gt;Name&lt;/code&gt; and, if provided, &lt;code&gt;Args&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; is used as the first part of the node names, &lt;code&gt;Args&lt;/code&gt; is used to specify command-line arguments.</source>
          <target state="translated">从节点以 &lt;code&gt;&lt;a href=&quot;slave#start-2&quot;&gt;slave:start/2,3&lt;/a&gt;&lt;/code&gt; 开头，并传递 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Args&lt;/code&gt; （如果提供）。 &lt;code&gt;Name&lt;/code&gt; 用作节点名称的第一部分， &lt;code&gt;Args&lt;/code&gt; 用于指定命令行参数。</target>
        </trans-unit>
        <trans-unit id="b6a9facae6762d3a2d983123523a049078f4b929" translate="yes" xml:space="preserve">
          <source>The slave nodes are started with the &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; module. This effects terminal I/O, file I/O, and code loading.</source>
          <target state="translated">从节点通过 &lt;code&gt;&lt;a href=&quot;slave&quot;&gt;slave(3)&lt;/a&gt;&lt;/code&gt; 模块启动。这会影响终端I / O，文件I / O和代码加载。</target>
        </trans-unit>
        <trans-unit id="eff695ae8a9be5c2401875ebeb79790be1f1fe68" translate="yes" xml:space="preserve">
          <source>The slave nodes send regular reports to the master about their current load.</source>
          <target state="translated">从属节点定期向主节点发送关于当前负载的报告。</target>
        </trans-unit>
        <trans-unit id="1bd8d8ae05660e3f8d1c448fac43b54c3d2e34e2" translate="yes" xml:space="preserve">
          <source>The smallest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">最小的多块载波大小（ &lt;code&gt;&lt;a href=&quot;#M_smbcs&quot;&gt;smbcs&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="aa74489ccfd55ad582b4db554e67d3965db81df4" translate="yes" xml:space="preserve">
          <source>The smallest unit that the test server is concerned with is a test case. Each test case can test many things, for example, make several calls to the same interface function with different parameters.</source>
          <target state="translated">测试服务器所关注的最小单元是测试用例。每个测试用例可以测试很多东西,例如,用不同的参数对同一个接口函数进行多次调用。</target>
        </trans-unit>
        <trans-unit id="9ea79c809c45352a9e00179e7da2c36055d038e8" translate="yes" xml:space="preserve">
          <source>The snmp application provides two different modules, &lt;code&gt;snmpm_net_if&lt;/code&gt; (the default) and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;, both uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;. The difference between the two modules is that the latter is &quot;multi-threaded&quot;, i.e. for each message/request a new process is created that processes the message/request and then exits.</source>
          <target state="translated">snmp应用程序提供了两个不同的模块 &lt;code&gt;snmpm_net_if&lt;/code&gt; （默认值）和 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ，它们均使用UDP作为传输协议，即传输域 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 和/或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 。这两个模块之间的区别在于后者是&amp;ldquo;多线程的&amp;rdquo;，即，对于每个消息/请求，都会创建一个新进程来处理消息/请求，然后退出。</target>
        </trans-unit>
        <trans-unit id="890d257b12c0103c2f2773954dbb3903b79d49e7" translate="yes" xml:space="preserve">
          <source>The socket is set to a busy state when the amount of data queued internally by the ERTS socket implementation reaches this limit. Defaults to 8 kB.</source>
          <target state="translated">当ERTS套接字实现内部排队的数据量达到该限制时,套接字被设置为繁忙状态。默认值为8 kB。</target>
        </trans-unit>
        <trans-unit id="ab70c80adb0296ab4476e7326e05623f1d1b81ea" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be from &lt;code&gt;gen_tcp:connect&lt;/code&gt; or &lt;code&gt;gen_tcp:accept&lt;/code&gt; with option &lt;code&gt;{active,false}&lt;/code&gt;</source>
          <target state="translated">该套接字应该来自 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 或 &lt;code&gt;gen_tcp:accept&lt;/code&gt; ,带有选项 &lt;code&gt;{active,false}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44cb3c6e112d60616f61ce3179ae2f5db9db0cba" translate="yes" xml:space="preserve">
          <source>The socket is supposed to be result of a &lt;code&gt;gen_tcp:connect&lt;/code&gt; or a &lt;code&gt;gen_tcp:accept&lt;/code&gt;. The socket must be in passive mode (that is, opened with the option &lt;code&gt;{active,false})&lt;/code&gt;.</source>
          <target state="translated">该套接字应该是 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 或 &lt;code&gt;gen_tcp:accept&lt;/code&gt; 的结果。套接字必须处于被动模式（即，使用选项 &lt;code&gt;{active,false})&lt;/code&gt; 打开）。</target>
        </trans-unit>
        <trans-unit id="925659a2ced1ee88f823aa52063a42e6955489e2" translate="yes" xml:space="preserve">
          <source>The socket message queue is set to a busy state when the amount of data on the message queue reaches this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 8 kB.</source>
          <target state="translated">当消息队列上的数据量达到这个限制时,套接字消息队列就会被设置为繁忙状态。注意,这个限制只涉及尚未到达ERTS内部套接字实现的数据。默认值为8 kB。</target>
        </trans-unit>
        <trans-unit id="f02f850d90c7fd6701fa67a1c73724ba84ac1faf" translate="yes" xml:space="preserve">
          <source>The socket owner process.</source>
          <target state="translated">套接字所有者进程。</target>
        </trans-unit>
        <trans-unit id="72f50e8cca44d427ecdea919b729a9f976d4b8f1" translate="yes" xml:space="preserve">
          <source>The socket returned can only be used with &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt;. No traffic can be sent or received before that call.</source>
          <target state="translated">返回的套接字只能与 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 。在该呼叫之前，无法发送或接收流量。</target>
        </trans-unit>
        <trans-unit id="68853c7896ab72f079055456a599e669b94ec773" translate="yes" xml:space="preserve">
          <source>The socket, in format &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;, depending on &lt;code&gt;socket_type&lt;/code&gt;.</source>
          <target state="translated">套接字，格式为 &lt;code&gt;ip_comm&lt;/code&gt; 或 &lt;code&gt;ssl&lt;/code&gt; ，具体取决于 &lt;code&gt;socket_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2268a9a9dea928b5f653dddc6d70d3d7abdecd4b" translate="yes" xml:space="preserve">
          <source>The software the client claims to be using (if it could not be determined, a minus sign is placed in this field).</source>
          <target state="translated">客户声称使用的软件(如果无法确定,则在此字段打上减号);</target>
        </trans-unit>
        <trans-unit id="59919acf7ad71bce9fc6539c387deaefebd73d43" translate="yes" xml:space="preserve">
          <source>The sorter uses temporary files only if &lt;code&gt;QH1&lt;/code&gt; does not evaluate to a list and the size of the binary representation of the answers exceeds &lt;code&gt;Size&lt;/code&gt; bytes, where &lt;code&gt;Size&lt;/code&gt; is the value of option &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;QH1&lt;/code&gt; 不求值到列表并且答案的二进制表示形式的 &lt;code&gt;Size&lt;/code&gt; 超过Size字节时，排序器才使用临时文件，其中 &lt;code&gt;Size&lt;/code&gt; 是option &lt;code&gt;size&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="881ec9a1f2e48b94ddfd3fa755f8d866af15e90d" translate="yes" xml:space="preserve">
          <source>The source code can be downloaded from the official site of Erlang/OTP or GitHub.</source>
          <target state="translated">源码可以从Erlang/OTP的官方网站或GitHub下载。</target>
        </trans-unit>
        <trans-unit id="1e180c78c274b1e63d26ec543874e277c8a7cd9c" translate="yes" xml:space="preserve">
          <source>The source code is indented and each line is prefixed with its line number.</source>
          <target state="translated">源代码是缩进的,每一行都以行号为前缀。</target>
        </trans-unit>
        <trans-unit id="772cf36afe48c0ca08d944464d6f5613843516b5" translate="yes" xml:space="preserve">
          <source>The source file is compiled with the the original options appended to the given &lt;code&gt;Options&lt;/code&gt;, the output replacing the old object file if and only if compilation succeeds. A function &lt;code&gt;Filter&lt;/code&gt; can be specified for removing elements from from the original compiler options before the new options are added.</source>
          <target state="translated">源文件将使用原始选项附加到给定的 &lt;code&gt;Options&lt;/code&gt; 进行编译，当且仅当编译成功时，输出才会替换旧的目标文件。可以指定功能 &lt;code&gt;Filter&lt;/code&gt; 器，以在添加新选项之前从原始编译器选项中删除元素。</target>
        </trans-unit>
        <trans-unit id="d06894cd41dc043df906ea8b5e56fb15f704aa5a" translate="yes" xml:space="preserve">
          <source>The source for a backup is an activated checkpoint. The backup function &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; is most commonly used and returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;. It has the following arguments:</source>
          <target state="translated">备份的源是激活的检查点。备份函数 &lt;code&gt;&lt;a href=&quot;mnesia#backup_checkpoint-2&quot;&gt;mnesia:backup_checkpoint(Name, Opaque,[Mod])&lt;/a&gt;&lt;/code&gt; 最常用，并返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 。它具有以下参数：</target>
        </trans-unit>
        <trans-unit id="21ba4b6f6db86323236436d5d356017eead9a57a" translate="yes" xml:space="preserve">
          <source>The source of the message, usually the name of the application that generated it. This could be almost any string. When matching messages from certain applications, the version number of the application may have to be accounted for. This is what the NT event viewer calls &quot;source&quot;.</source>
          <target state="translated">消息的来源,通常是生成该消息的应用程序的名称。这几乎可以是任何字符串。当匹配来自某些应用程序的消息时,可能必须考虑到应用程序的版本号。这就是NT事件查看器所说的 &quot;源&quot;。</target>
        </trans-unit>
        <trans-unit id="fcf8739969b05c2227a6f3526a3eecacb416317d" translate="yes" xml:space="preserve">
          <source>The source release is delivered with a lot of platform independent build results already pre-built. If you want to remove these pre-built files, invoke &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; from the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. After you have done this, you can build exactly the same way as before, but the build process will take a much longer time.</source>
          <target state="translated">提供的源代码版本已预先构建了许多与平台无关的构建结果。如果要删除这些预构建文件， &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; 从 &lt;code&gt;$ERL_TOP&lt;/code&gt; 目录中调用./otp_build remove_prebuilt_files。完成此操作后，您可以按照与以前完全相同的方式进行构建，但是构建过程将花费更长的时间。</target>
        </trans-unit>
        <trans-unit id="61ba3eb61829a7833d7384b19b027906c4b3feb1" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$ROOT&lt;/code&gt; variable can only be used in the script, not as a command-line argument. The given directory is relative the Erlang installation directory.</source>
          <target state="translated">特殊的 &lt;code&gt;$ROOT&lt;/code&gt; 变量只能在脚本中使用，而不能用作命令行参数。给定目录是相对于Erlang安装目录的。</target>
        </trans-unit>
        <trans-unit id="fd2015df355d448e0a3bd19ecbc252e161ab2cfb" translate="yes" xml:space="preserve">
          <source>The special match specification variables &lt;code&gt;'$_'&lt;/code&gt; and &lt;code&gt;'$*'&lt;/code&gt; can be accessed through the pseudo functions &lt;code&gt;object()&lt;/code&gt; (for &lt;code&gt;'$_'&lt;/code&gt;) and &lt;code&gt;bindings()&lt;/code&gt; (for &lt;code&gt;'$*'&lt;/code&gt;). As an example, one can translate the following &lt;code&gt;ets:match_object/2&lt;/code&gt; call to a &lt;code&gt;ets:select/2&lt;/code&gt; call:</source>
          <target state="translated">特殊的匹配规范变量 &lt;code&gt;'$_'&lt;/code&gt; 和 &lt;code&gt;'$*'&lt;/code&gt; 可以通过伪函数 &lt;code&gt;object()&lt;/code&gt; （对于 &lt;code&gt;'$_'&lt;/code&gt; ）和 &lt;code&gt;bindings()&lt;/code&gt; （对于 &lt;code&gt;'$*'&lt;/code&gt; ）访问。例如，可以将以下 &lt;code&gt;ets:match_object/2&lt;/code&gt; 调用转换为 &lt;code&gt;ets:select/2&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="3d184230e40d23967b4ecaa91bc5e82ccd5cf4c3" translate="yes" xml:space="preserve">
          <source>The special property L&amp;amp; is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or &quot;other&quot;.</source>
          <target state="translated">还支持特殊属性L＆。它与具有Lu，Ll或Lt属性的字符匹配，即，未被分类为修饰语或&amp;ldquo;其他&amp;rdquo;的字母。</target>
        </trans-unit>
        <trans-unit id="6d78a416b1fb043fc9e7a30712c95b72e4af2747" translate="yes" xml:space="preserve">
          <source>The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.</source>
          <target state="translated">特殊的shell命令都具有(本地)函数调用的语法。它们与普通函数调用一样被评估,许多命令可以在一个表达式序列中使用。</target>
        </trans-unit>
        <trans-unit id="63aa3b1e5890590b0f6ee8261569fec19c3e02cf" translate="yes" xml:space="preserve">
          <source>The special term &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; is used to &quot;splice&quot; in a string in a list, a string specified this way is not a list in itself, but the elements are elements of the surrounding list.</source>
          <target state="translated">特殊术语 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 用于&amp;ldquo;拼接&amp;rdquo;列表中的字符串，用这种方式指定的字符串本身并不是列表，而是元素是周围列表的元素。</target>
        </trans-unit>
        <trans-unit id="9f706ef9a4d4e07f69004ede757b96ff5ef984e0" translate="yes" xml:space="preserve">
          <source>The special value &lt;strong&gt;flag&lt;/strong&gt; instead indicates that the function &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; shall be used.</source>
          <target state="translated">相反，特殊值&lt;strong&gt;标志&lt;/strong&gt;指示应使用功能 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcbf785b1e1daf48fbb6ef71da6f40a7025aba2b" translate="yes" xml:space="preserve">
          <source>The specification key does not exist.</source>
          <target state="translated">规格键不存在。</target>
        </trans-unit>
        <trans-unit id="e6b11d2daf1d2fe5ce8435f49d6f63466ec21923" translate="yes" xml:space="preserve">
          <source>The specification of &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; can be hard-coded as &lt;code&gt;{index, [2]}&lt;/code&gt; and &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 和 &lt;code&gt;attributes&lt;/code&gt; 的规范可以分别硬编码为 &lt;code&gt;{index, [2]}&lt;/code&gt; 和 &lt;code&gt;{attributes, [name, age, address, salary, children]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="569ad77b917c89cf2cb18ed8978c4e321b16e950" translate="yes" xml:space="preserve">
          <source>The specifications &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; were used in the test.</source>
          <target state="translated">测试中使用了 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;GUI&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://www.itu.int/ITU-T/asn1/database/itu-t/h/h248/2002/MEDIA-GATEWAY-CONTROL.html&quot;&gt;MEDIA-GATEWAY-CONTROL&lt;/a&gt;&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="3c9f9bb6dda1817bac37a46fe84e1fbe4666f5af" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Filename&lt;/code&gt; is prefixed with the node name. Default &lt;code&gt;Filename&lt;/code&gt; is &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">指定的 &lt;code&gt;Filename&lt;/code&gt; 以节点名为前缀。默认 &lt;code&gt;Filename&lt;/code&gt; 名为 &lt;code&gt;ttb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a78dd1ea59140a32308f444a3d3f489add93983" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;comparing equal&lt;/strong&gt; the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table, or &lt;strong&gt;matching&lt;/strong&gt; in other types of tables (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定的 &lt;code&gt;Key&lt;/code&gt; 用于通过&lt;strong&gt;比较&lt;/strong&gt; &lt;code&gt;ordered_set&lt;/code&gt; 表中的对象的键或&lt;strong&gt;与&lt;/strong&gt;其他类型的表中的对象进行&lt;strong&gt;匹配&lt;/strong&gt;来标识对象（有关差异的详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="832d1f70c554be8c643c3c3c0c699e86c09d600d" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;Key&lt;/code&gt; is used to identify the object by either &lt;strong&gt;matching&lt;/strong&gt; the key of an object in a &lt;code&gt;set&lt;/code&gt; table, or &lt;strong&gt;compare equal&lt;/strong&gt; to the key of an object in an &lt;code&gt;ordered_set&lt;/code&gt; table (for details on the difference, see &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定的 &lt;code&gt;Key&lt;/code&gt; 所使用的任一识别对象&lt;strong&gt;匹配&lt;/strong&gt;的对象的键的 &lt;code&gt;set&lt;/code&gt; 的表，或&lt;strong&gt;比较相等&lt;/strong&gt;，以在对象的键 &lt;code&gt;ordered_set&lt;/code&gt; 表（对于该差的详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5c6caca78cf0733387e75985a561e3ed41d83af2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;logdir&lt;/code&gt; directory is used for storing the HTML log files (in subdirectories tagged with node name, date, and time).</source>
          <target state="translated">指定的 &lt;code&gt;logdir&lt;/code&gt; 目录用于存储HTML日志文件（在带有节点名称，日期和时间标记的子目录中）。</target>
        </trans-unit>
        <trans-unit id="d8f4d5f198f549cf59998ab6e9b38627280804f7" translate="yes" xml:space="preserve">
          <source>The specified XML document is sent &quot;as is&quot; to the server. This function can be used for sending XML documents that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">指定的XML文档 &quot;按原样 &quot;发送到服务器。这个函数可以用来发送本模块中其他接口函数无法表达的XML文档。</target>
        </trans-unit>
        <trans-unit id="67af2595bd4825418d486d6611387842fada4fe3" translate="yes" xml:space="preserve">
          <source>The specified XML document is wrapped in a valid NETCONF &lt;code&gt;rpc&lt;/code&gt; request and sent to the server. The &lt;code&gt;message-id&lt;/code&gt; and namespace attributes are added to element &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">指定的XML文档包装在有效的NETCONF &lt;code&gt;rpc&lt;/code&gt; 请求中，并发送到服务器。所述 &lt;code&gt;message-id&lt;/code&gt; 和名称空间的属性被添加到元件 &lt;code&gt;rpc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77ace5a3a9ee7abec7d82aa98cb78832103cfb00" translate="yes" xml:space="preserve">
          <source>The specified application is not loaded.</source>
          <target state="translated">指定的应用程序未加载。</target>
        </trans-unit>
        <trans-unit id="7d093a57604a6ecaca53b3ce36fbb95e4bc18f8a" translate="yes" xml:space="preserve">
          <source>The specified module flows from your instantiation of the &lt;code&gt;Viewer&lt;/code&gt;, to the &lt;code&gt;Collector&lt;/code&gt; that it automatically creates, gets stashed in as the &lt;code&gt;Trace Pattern&lt;/code&gt;, and eventually goes down into the bowels of the &lt;code&gt;Selector&lt;/code&gt;.</source>
          <target state="translated">指定的模块从您的 &lt;code&gt;Viewer&lt;/code&gt; 实例流向它自动创建的 &lt;code&gt;Collector&lt;/code&gt; ，将其藏入 &lt;code&gt;Trace Pattern&lt;/code&gt; 中，最后进入 &lt;code&gt;Selector&lt;/code&gt; 的肠道。</target>
        </trans-unit>
        <trans-unit id="d37865ea2af043489e228e4a87a6f2db90cb4c8d" translate="yes" xml:space="preserve">
          <source>The specified release version &lt;code&gt;Vsn&lt;/code&gt; does not exist.</source>
          <target state="translated">指定的发行版本 &lt;code&gt;Vsn&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="3b8bce2d65b733b38425b28f665ddd56d541e379" translate="yes" xml:space="preserve">
          <source>The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged</source>
          <target state="translated">指定的字符串或字符会进行大小写转换。请注意,支持的字符集是ISO/IEC 8859-1(也称为拉丁文1);该字符集之外的所有值都不会改变。</target>
        </trans-unit>
        <trans-unit id="a909f58eed86dcb459bb7e97f8bf0f61f50ce1e8" translate="yes" xml:space="preserve">
          <source>The spelling &lt;code&gt;behavior&lt;/code&gt; is also accepted.</source>
          <target state="translated">也接受拼写 &lt;code&gt;behavior&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5309c7fe313dda17e9facd4377c48f36ec3201cb" translate="yes" xml:space="preserve">
          <source>The stack back-trace (&lt;strong&gt;stacktrace&lt;/strong&gt;) is a list of &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; tuples. The field &lt;code&gt;Arity&lt;/code&gt; in the first tuple can be the argument list of that function call instead of an arity integer, depending on the exception.</source>
          <target state="translated">堆栈回溯（&lt;strong&gt;stacktrace&lt;/strong&gt;）是 &lt;code&gt;{Module,Function,Arity,Location}&lt;/code&gt; 元组的列表。根据 &lt;code&gt;Arity&lt;/code&gt; ，第一个元组中的Arity字段可以是该函数调用的参数列表，而不是arity整数。</target>
        </trans-unit>
        <trans-unit id="45ce8e9f1c15d0274292ea0288412d440ab1701d" translate="yes" xml:space="preserve">
          <source>The stack dump is a dump of the Erlang process stack. Most of the live data (that is, variables currently in use) are placed on the stack; thus this can be interesting. One has to &quot;guess&quot; what is what, but as the information is symbolic, thorough reading of this information can be useful. As an example, we can find the state variable of the Erlang primitive loader online &lt;code&gt;(5)&lt;/code&gt; and &lt;code&gt;(6)&lt;/code&gt; in the following example:</source>
          <target state="translated">堆栈转储是Erlang进程堆栈的转储。大多数实时数据（即当前正在使用的变量）都放置在堆栈中。因此这可能很有趣。人们必须&amp;ldquo;猜测&amp;rdquo;什么是什么，但是由于该信息是象征性的，因此彻底阅读此信息可能会很有用。例如，可以在以下示例中在线找到 &lt;code&gt;(5)&lt;/code&gt; 和 &lt;code&gt;(6)&lt;/code&gt; 的Erlang基本加载器的状态变量：</target>
        </trans-unit>
        <trans-unit id="f4779fab4d980187187f7b568fd5d1cecf627b61" translate="yes" xml:space="preserve">
          <source>The stack trace can be be bound to a variable from within a &lt;code&gt;try&lt;/code&gt; expression, and is returned for exceptions of class &lt;code&gt;error&lt;/code&gt; from a &lt;code&gt;catch&lt;/code&gt; expression.</source>
          <target state="translated">堆栈跟踪可被从内绑定到变量 &lt;code&gt;try&lt;/code&gt; 表达，并且返回类的异常 &lt;code&gt;error&lt;/code&gt; 由一个 &lt;code&gt;catch&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="0fe8ca8ba7f9cf2f1cf34954b8c2fda1504010ff" translate="yes" xml:space="preserve">
          <source>The stacktrace is the same data as operator &lt;code&gt;catch&lt;/code&gt; returns, for example:</source>
          <target state="translated">stacktrace与运算符 &lt;code&gt;catch&lt;/code&gt; 返回的数据相同，例如：</target>
        </trans-unit>
        <trans-unit id="fc5e2be1fd73b3184fa33140f882adc2e4eaf503" translate="yes" xml:space="preserve">
          <source>The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the current maximum stacktrace depth.</source>
          <target state="translated">堆栈跟踪作为调用进程的异常堆栈跟踪,它被截断到当前最大的堆栈跟踪深度。</target>
        </trans-unit>
        <trans-unit id="95f65f456f73c264cfc1076a4ff37600ccf76a4a" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP behaviours are:</source>
          <target state="translated">标准的Erlang/OTP行为是。</target>
        </trans-unit>
        <trans-unit id="bf7122f2f75170b13714d7076b64a347b292a606" translate="yes" xml:space="preserve">
          <source>The standard Erlang/OTP system can be reconfigured to change the default behavior on startup.</source>
          <target state="translated">可以重新配置标准的Erlang/OTP系统,以改变启动时的默认行为。</target>
        </trans-unit>
        <trans-unit id="b7b586ddbaa84cea01ad2740636b956444f85f5b" translate="yes" xml:space="preserve">
          <source>The standard behaviours (&lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, and so on) send progress and error information to Logger. Progress reports are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;. Supervisor reports, crash reports and other error and information reports are by default logged through the log handler which is set up when the Kernel application is started.</source>
          <target state="translated">标准行为（ &lt;code&gt;supervisor&lt;/code&gt; ， &lt;code&gt;gen_server&lt;/code&gt; 等）将进度和错误信息发送到Logger。默认情况下不会记录进度报告，但是可以通过将主要日志级别设置为 &lt;code&gt;info&lt;/code&gt; 来启用，例如，使用内核配置参数 &lt;code&gt;logger_level&lt;/code&gt; 。默认情况下，主管报告，崩溃报告以及其他错误和信息报告通过启动内核应用程序时设置的日志处理程序进行记录。</target>
        </trans-unit>
        <trans-unit id="2005b81eb265a1528dcd843192ed7f5d98a0c04c" translate="yes" xml:space="preserve">
          <source>The standard binary encoding is used whenever a library function in Erlang is to handle Unicode data in binaries, but is of course not enforced when communicating externally. Functions and bit syntax exist to encode and decode both UTF-8, UTF-16, and UTF-32 in binaries. However, library functions dealing with binaries and Unicode in general only deal with the default encoding.</source>
          <target state="translated">每当Erlang中的库函数要处理二进制文件中的Unicode数据时,都会使用标准的二进制编码,当然在对外通信时并不强制执行。存在着对二进制文件中UTF-8、UTF-16和UTF-32进行编码和解码的函数和位语法。然而,处理二进制文件和Unicode的库函数一般只处理默认编码。</target>
        </trans-unit>
        <trans-unit id="4183835861454020cbfc8b77885a3f621959b27b" translate="yes" xml:space="preserve">
          <source>The standard certificate extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">标准证书扩展OID名称原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="e8da6740394a506d3316b11fa47e1c984ea529f7" translate="yes" xml:space="preserve">
          <source>The standard documents that define SNMPv2 are incomplete, in the sense that they do not specify how an SNMPv2 message looks like. The message format and security issues are left to a special Administrative Framework. One such framework is the Community-based SNMPv2 Framework (SNMPv2c), which uses the same message format and framework as SNMPv1. Other experimental frameworks as exist, e.g. SNMPv2u and SNMPv2*.</source>
          <target state="translated">定义SNMPv2的标准文件是不完整的,因为它们没有规定SNMPv2消息的样子。消息格式和安全问题留给了一个特殊的管理框架。其中一个框架是基于社区的SNMPv2框架(SNMPv2c),它使用与SNMPv1相同的消息格式和框架。 其他实验性框架也存在,例如SNMPv2u和SNMPv2*。</target>
        </trans-unit>
        <trans-unit id="dc54a83b77765211d993fa09d8d0f6be7eb0aa1e" translate="yes" xml:space="preserve">
          <source>The standard example is when formatting source code as HTML to be placed within &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; markup, and using e.g. &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; to make parts of the source code stand out. In this case, the markup does not add to the width of the text when viewed in an HTML browser, so the layout engine should simply pretend that the markup has zero width.</source>
          <target state="translated">标准示例是将源代码格式化为HTML以放置在 &lt;code&gt;&amp;lt;pre&amp;gt;...&amp;lt;/pre&amp;gt;&lt;/code&gt; 标记内，并使用例如 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 来使部分源代码脱颖而出。在这种情况下，在HTML浏览器中查看时，标记不会增加文本的宽度，因此布局引擎应该简单地假设标记的宽度为零。</target>
        </trans-unit>
        <trans-unit id="913db80fae0242e7eb7aa0597b7610d00dd2e55e" translate="yes" xml:space="preserve">
          <source>The standard list encoding for strings was therefore easily extended to handle the whole Unicode range. A Unicode string in Erlang is a list containing integers, where each integer is a valid Unicode code point and represents one character in the Unicode character set.</source>
          <target state="translated">因此,字符串的标准列表编码很容易被扩展到处理整个Unicode范围。Erlang中的Unicode字符串是一个包含整数的列表,其中每个整数都是一个有效的Unicode码点,代表Unicode字符集中的一个字符。</target>
        </trans-unit>
        <trans-unit id="96e137cd77a79e26488628d7b4bc6d3c818af033" translate="yes" xml:space="preserve">
          <source>The standard module &lt;code&gt;lists&lt;/code&gt; also contains a function &lt;code&gt;sort(Fun, List)&lt;/code&gt; where &lt;code&gt;Fun&lt;/code&gt; is a fun with two arguments. This fun returns &lt;code&gt;true&lt;/code&gt; if the first argument is less than the second argument, or else &lt;code&gt;false&lt;/code&gt;. Sorting is added to the &lt;code&gt;convert_list_to_c&lt;/code&gt;:</source>
          <target state="translated">标准模块 &lt;code&gt;lists&lt;/code&gt; 还包含一个函数 &lt;code&gt;sort(Fun, List)&lt;/code&gt; ，其中 &lt;code&gt;Fun&lt;/code&gt; 是带有两个参数的乐趣。如果第一个参数小于第二个参数，则此fun返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。排序已添加到 &lt;code&gt;convert_list_to_c&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b21571b3224dc79a2851fad7a8fdb257c1dfd3c9" translate="yes" xml:space="preserve">
          <source>The standard shell is set for &lt;code&gt;unicode&lt;/code&gt; or &lt;code&gt;latin1&lt;/code&gt; encoding when the system is started. The encoding is set with the help of the &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in &lt;code&gt;{encoding, unicode}&lt;/code&gt; mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option.</source>
          <target state="translated">启动系统时，将标准外壳程序设置为 &lt;code&gt;unicode&lt;/code&gt; 或 &lt;code&gt;latin1&lt;/code&gt; 编码。在类Unix系统上借助 &lt;code&gt;LANG&lt;/code&gt; 或 &lt;code&gt;LC_CTYPE&lt;/code&gt; 环境变量或在其他系统上通过其他方式设置编码。因此，如果I / O设备支持，则用户可以输入Unicode字符，并且I / O设备处于 &lt;code&gt;{encoding, unicode}&lt;/code&gt; 模式。如果运行时系统的假设错误，则可以通过设置此选项来更改模式。</target>
        </trans-unit>
        <trans-unit id="60bbcd01c05d5bf0aeb5fe03e942b16191c94a69" translate="yes" xml:space="preserve">
          <source>The start function &lt;strong&gt;must create and link to&lt;/strong&gt; the child process, and must return &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, where &lt;code&gt;Child&lt;/code&gt; is the pid of the child process and &lt;code&gt;Info&lt;/code&gt; any term that is ignored by the supervisor.</source>
          <target state="translated">启动函数&lt;strong&gt;必须创建并链接到&lt;/strong&gt;子进程，并且必须返回 &lt;code&gt;{ok,Child}&lt;/code&gt; 或 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; ，其中 &lt;code&gt;Child&lt;/code&gt; 是子进程的pid， &lt;code&gt;Info&lt;/code&gt; 是主管忽略的任何术语。</target>
        </trans-unit>
        <trans-unit id="32924ed60f44bfc045cee6cadfb10d688a40ff5d" translate="yes" xml:space="preserve">
          <source>The start function can also return &lt;code&gt;ignore&lt;/code&gt; if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored.</source>
          <target state="translated">如果由于某种原因无法启动子进程，则启动功能还可以返回 &lt;code&gt;ignore&lt;/code&gt; ，在这种情况下，子规范由主管保留（除非它是一个临时子进程），但是不存在的子进程将被忽略。</target>
        </trans-unit>
        <trans-unit id="a860e23df31c942b2bc0c3412b761a4dcef25730" translate="yes" xml:space="preserve">
          <source>The start function required by &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 所需的启动函数。</target>
        </trans-unit>
        <trans-unit id="27f87c72bb318d024045b5c43b6afc31f6ec794d" translate="yes" xml:space="preserve">
          <source>The start function should use the &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; and/or &lt;code&gt;Config&lt;/code&gt; to select and return an appropriate list of local IP addresses. In the connecting case, the local address list can instead be communicated in a &lt;code&gt;connected&lt;/code&gt; message (see &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; below) following connection establishment. In either case, the local address list is used to populate &lt;code&gt;Host-IP-Address&lt;/code&gt; AVPs in outgoing capabilities exchange messages if &lt;code&gt;Host-IP-Address&lt;/code&gt; is unspecified.</source>
          <target state="translated">启动功能应使用 &lt;code&gt;Svc&lt;/code&gt; 和/或 &lt;code&gt;Config&lt;/code&gt; 中的&amp;ldquo; &lt;code&gt;Host-IP-Address&lt;/code&gt; 列表来选择并返回适当的本地IP地址列表。在连接的情况下，可以在建立 &lt;code&gt;connected&lt;/code&gt; 后以连接的消息（请参见下面的 &lt;code&gt;&lt;a href=&quot;#MESSAGES&quot;&gt;MESSAGES&lt;/a&gt;&lt;/code&gt; ）传达本地地址列表。在这两种情况下，如果未指定 &lt;code&gt;Host-IP-Address&lt;/code&gt; ，则本地地址列表都用于在传出功能交换消息中填充 &lt;code&gt;Host-IP-Address&lt;/code&gt; AVP 。</target>
        </trans-unit>
        <trans-unit id="4cef6600c64628b5df747acb2766fd1cbe1d3b19" translate="yes" xml:space="preserve">
          <source>The start phases are defined by the application specification key &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt;. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</source>
          <target state="translated">起始阶段由应用程序规范键 &lt;code&gt;start_phases == [{Phase,PhaseArgs}]&lt;/code&gt; 。对于包含的应用程序，一组阶段必须是为包含的应用程序定义的一组阶段的子集。</target>
        </trans-unit>
        <trans-unit id="7acb8d9625f3baf5a2f8a4a89f3e914252275eb8" translate="yes" xml:space="preserve">
          <source>The start program must call &lt;code&gt;run_erl&lt;/code&gt; as shown below. It must also take an optional parameter, which defaults to &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">启动程序必须调用 &lt;code&gt;run_erl&lt;/code&gt; ，如下所示。它还必须带有一个可选参数，默认为 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/releases/start_erl.data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dadcd9880753a230e08e39eb7ab7929eb5a6e0c2" translate="yes" xml:space="preserve">
          <source>The startup procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory is referred to as the Mnesia directory. Mnesia can also be started on disc-less nodes. For more information about disc-less nodes, see &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">一组Mnesia节点的启动过程是一个相当复杂的操作。Mnesia系统由一组节点组成，Mnesia在所有参与的节点上本地启动。通常，每个节点都有一个写入所有Mnesia文件的目录。此目录称为Mnesia目录。Mnesia也可以在无盘节点上启动。有关 &lt;code&gt;mnesia:create_schema/1&lt;/code&gt; 节点的更多信息，请参见mnesia：create_schema / 1和《用户指南》。</target>
        </trans-unit>
        <trans-unit id="9ec6e88891409b6ff8f9a27843da0963ec7c3164" translate="yes" xml:space="preserve">
          <source>The state can be any term and the callback function &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; is used for all states.</source>
          <target state="translated">状态可以是任何术语，并且回调函数 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 用于所有状态。</target>
        </trans-unit>
        <trans-unit id="77f821816af50887b3f025a4e6599280206657b6" translate="yes" xml:space="preserve">
          <source>The state is either the name of the function itself or an argument to it. The other arguments are the &lt;code&gt;EventType&lt;/code&gt; described in section &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt;, the event dependent &lt;code&gt;EventContent&lt;/code&gt;, and the current server &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">状态可以是函数本身的名称，也可以是其参数。其他参数是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Types&lt;/a&gt;&lt;/code&gt; 一节中描述的 &lt;code&gt;EventType&lt;/code&gt; ，事件相关的 &lt;code&gt;EventContent&lt;/code&gt; 和当前服务器 &lt;code&gt;Data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9426ff2ed56deac331065c555f73deceea5d2d1f" translate="yes" xml:space="preserve">
          <source>The state must be of type &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; and one callback function per state, that is, &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;, is used.</source>
          <target state="translated">该状态必须为 &lt;code&gt;&lt;a href=&quot;#type-state_name&quot;&gt;state_name()&lt;/a&gt;&lt;/code&gt; 类型，并且每个状态使用一个回调函数，即 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d13d42182a76700706e21237d549fc59709fd9b9" translate="yes" xml:space="preserve">
          <source>The state of the handler.</source>
          <target state="translated">处理器的状态。</target>
        </trans-unit>
        <trans-unit id="15825c6d947625e874b105c1baf6a684fccb64cc" translate="yes" xml:space="preserve">
          <source>The state of the process. This can be one of the following:</source>
          <target state="translated">进程的状态。可以是以下几种情况之一:</target>
        </trans-unit>
        <trans-unit id="289e59e1fe9a8e03ffb9d797627caef032453480" translate="yes" xml:space="preserve">
          <source>The state returned from each call of &lt;code&gt;Function&lt;/code&gt; is passed to the next call, even if the next call is to format a message from another log file.</source>
          <target state="translated">即使下一次调用是格式化另一个日志文件中的消息，从 &lt;code&gt;Function&lt;/code&gt; 的每次调用返回的状态也会传递到下一个调用。</target>
        </trans-unit>
        <trans-unit id="dd050ef7cc16c451eba6404d640a1ee02e6c6b42" translate="yes" xml:space="preserve">
          <source>The state returned from this function can not be used to get a reproducable random sequence as from the other &lt;code&gt;rand&lt;/code&gt; functions, since reproducability does not match cryptographically safe.</source>
          <target state="translated">与其他 &lt;code&gt;rand&lt;/code&gt; 函数一样，此函数返回的状态不能用于获取可重现的随机序列，因为可重现性与密码安全性不匹配。</target>
        </trans-unit>
        <trans-unit id="3fae0626bf69d79a71c33c9da2c9ae7fb12888d7" translate="yes" xml:space="preserve">
          <source>The state specified when calling &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt;. The tracer state is an immutable value that is passed to &lt;code&gt;erl_tracer&lt;/code&gt; callbacks and is to contain all the data that is needed to generate the trace event.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])&lt;/a&gt;&lt;/code&gt; 时指定的状态。跟踪器状态是一个不变的值，该值传递给 &lt;code&gt;erl_tracer&lt;/code&gt; 回调，并且包含生成跟踪事件所需的所有数据。</target>
        </trans-unit>
        <trans-unit id="1ab345b32e922b70cc7799981ef1e76b747d4f17" translate="yes" xml:space="preserve">
          <source>The state.</source>
          <target state="translated">国家。</target>
        </trans-unit>
        <trans-unit id="43d74fe2df87f64ba71d3e82fa6cf8b2cdbfe68c" translate="yes" xml:space="preserve">
          <source>The status bar at the bottom of the window shows a warning if the currently loaded dump is truncated.</source>
          <target state="translated">如果当前加载的转储被截断,窗口底部的状态栏会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="7fb7334448d68c19546b3da05bde0756339f62d8" translate="yes" xml:space="preserve">
          <source>The status of a subgroup can be returned (&lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;failed&lt;/code&gt;), to affect the execution of the group on the level above. This is accomplished by, in &lt;code&gt;end_per_group/2&lt;/code&gt;, looking up the value of &lt;code&gt;tc_group_properties&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list and checking the result of the test cases in the group. If status &lt;code&gt;failed&lt;/code&gt; is to be returned from the group as a result, &lt;code&gt;end_per_group/2&lt;/code&gt; is to return the value &lt;code&gt;{return_group_result,failed}&lt;/code&gt;. The status of a subgroup is taken into account by &lt;code&gt;Common Test&lt;/code&gt; when evaluating if execution of a group is to be repeated or not (unless the basic &lt;code&gt;repeat&lt;/code&gt; property is used).</source>
          <target state="translated">可以返回子组的状态（&amp;ldquo; &lt;code&gt;ok&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;failed&lt;/code&gt; ），以影响上一级的组执行。这是通过在 &lt;code&gt;end_per_group/2&lt;/code&gt; 中在 &lt;code&gt;Config&lt;/code&gt; 列表中 &lt;code&gt;tc_group_properties&lt;/code&gt; 的值并检查组中测试用例的结果来完成的。如果要从组返回状态 &lt;code&gt;failed&lt;/code&gt; ，则 &lt;code&gt;end_per_group/2&lt;/code&gt; 将返回值 &lt;code&gt;{return_group_result,failed}&lt;/code&gt; 。在评估是否要重复执行某个组时（除非使用基本的 &lt;code&gt;repeat&lt;/code&gt; 属性）， &lt;code&gt;Common Test&lt;/code&gt; 会考虑子组的状态。</target>
        </trans-unit>
        <trans-unit id="b85c37fec76de27c56e3406adaafa6e8b1d27921" translate="yes" xml:space="preserve">
          <source>The status of a test case explicitly skipped in any of the ways described in section &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例的状态以&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#skipping_test_cases&quot;&gt;Skipping Test Cases&lt;/a&gt;&lt;/code&gt; 一节中描述的任何方式明确地跳过了。</target>
        </trans-unit>
        <trans-unit id="6ae5f35d675d1272e78fb3eaf4d81a316518f52b" translate="yes" xml:space="preserve">
          <source>The step functionality can be used together with flag/option &lt;code&gt;suite&lt;/code&gt; and &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt;, but not together with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">step功能可以与flag / option &lt;code&gt;suite&lt;/code&gt; 和 &lt;code&gt;suite&lt;/code&gt; + &lt;code&gt;case/testcase&lt;/code&gt; 一起使用，但不能与 &lt;code&gt;dir&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="23a47861a1df8e95627b42341a8487a2338f8876" translate="yes" xml:space="preserve">
          <source>The stop callback was called directly by &lt;code&gt;enif_select&lt;/code&gt;.</source>
          <target state="translated">stop回调由 &lt;code&gt;enif_select&lt;/code&gt; 直接调用。</target>
        </trans-unit>
        <trans-unit id="eff8dcd2a113b22b62950f59f611b3549632ee05" translate="yes" xml:space="preserve">
          <source>The stop callback was scheduled to run on some other thread or later by this thread.</source>
          <target state="translated">停止回调被这个线程安排在其他线程或稍后运行。</target>
        </trans-unit>
        <trans-unit id="6eb9b8c23b1b206be09c84ebb2950996bdcd33b8" translate="yes" xml:space="preserve">
          <source>The storage engine must call &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; and &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt;. See the OpenSSL cryptolib's &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存储引擎必须调用 &lt;code&gt;ENGINE_set_load_privkey_function&lt;/code&gt; 和 &lt;code&gt;ENGINE_set_load_pubkey_function&lt;/code&gt; 。请参阅OpenSSL cryptolib的 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/manpages.html&quot;&gt;manpages&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f1ee5838e32832bdcc704cd56398a34eb2a5f6f" translate="yes" xml:space="preserve">
          <source>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</source>
          <target state="translated">存储类型被保留下来。例如,从一个节点移出的RAM表在新节点上仍然是RAM。在表被移动时,其他事务仍然可以在表中进行读写。</target>
        </trans-unit>
        <trans-unit id="29dd2c34d1090a0d800c2e247d0fc176342cf1f0" translate="yes" xml:space="preserve">
          <source>The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first &lt;code&gt;next_event&lt;/code&gt; in the containing list becomes the first to process.</source>
          <target state="translated">存储的事件将在任何已排队事件之前插入队列中，作为下一个要处理的事件。这些存储事件的顺序得以保留，因此包含列表中的第一个 &lt;code&gt;next_event&lt;/code&gt; 成为第一个要处理的事件。</target>
        </trans-unit>
        <trans-unit id="c05a53cb68134dabc5d7bae05169ae1a11647b27" translate="yes" xml:space="preserve">
          <source>The stream hasn't been initialized, eg. if &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; wasn't called prior to a call to &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">流尚未初始化，例如。如果 &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; 以前未在呼叫之前被调用到 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6455104e94ea1d2cc707927b01ebea3a44bfd27f" translate="yes" xml:space="preserve">
          <source>The stream was used by a process that doesn't control it. Use &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; if you need to transfer a stream to a different process.</source>
          <target state="translated">流由不受控制的进程使用。如果需要将流传输到其他进程，请使用 &lt;code&gt;&lt;a href=&quot;#set_controlling_process-2&quot;&gt;set_controlling_process/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e2fdb4e651b9aa41fcc3bc6966fd38ca9895ed9" translate="yes" xml:space="preserve">
          <source>The string is copied to &lt;code&gt;p&lt;/code&gt;, and enough space must be allocated. The returned string is &lt;code&gt;NULL&lt;/code&gt;-terminated, so you must add an extra byte to the memory requirement.</source>
          <target state="translated">字符串被复制到 &lt;code&gt;p&lt;/code&gt; ，并且必须分配足够的空间。返回的字符串以 &lt;code&gt;NULL&lt;/code&gt; 终止，因此您必须在内存要求中添加一个额外的字节。</target>
        </trans-unit>
        <trans-unit id="68785b1bbdb54c599efe5a2a41d523ae7b013997" translate="yes" xml:space="preserve">
          <source>The string length of &quot;&amp;szlig;&amp;uarr;e̊&quot; is 3, even though it is represented by the codepoints &lt;code&gt;[223,8593,101,778]&lt;/code&gt; or the UTF-8 binary &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">即使由代码点 &lt;code&gt;[223,8593,101,778]&lt;/code&gt; 或UTF-8二进制 &lt;code&gt;&amp;lt;&amp;lt;195,159,226,134,145,101,204,138&amp;gt;&amp;gt;&lt;/code&gt; 表示，&amp;ldquo;&amp;szlig;&amp;uarr;&amp;eacute;&amp;rdquo;的字符串长度也为3 。</target>
        </trans-unit>
        <trans-unit id="4cf40fddbed63f7ac0d755d714db5efcb0dab3f9" translate="yes" xml:space="preserve">
          <source>The string the daemon will present to a connecting peer initially. The default value is &quot;Erlang/VSN&quot; where VSN is the ssh application version number.</source>
          <target state="translated">守护进程最初将向连接的对等体提供的字符串,默认值是 &quot;Erlang/VSN&quot;,其中VSN是ssh应用程序的版本号。默认值是 &quot;Erlang/VSN&quot;,其中VSN是ssh应用程序的版本号。</target>
        </trans-unit>
        <trans-unit id="36753c090f707fe68109d16ad9e5e9da7b79ac27" translate="yes" xml:space="preserve">
          <source>The string was read, but more input is needed to complete the original format string. &lt;code&gt;RestFormat&lt;/code&gt; is the remaining format string, &lt;code&gt;Nchars&lt;/code&gt; is the number of characters scanned, and &lt;code&gt;InputStack&lt;/code&gt; is the reversed list of inputs matched up to that point.</source>
          <target state="translated">已读取该字符串，但需要更多输入才能完成原始格式的字符串。 &lt;code&gt;RestFormat&lt;/code&gt; 是剩余的格式字符串， &lt;code&gt;Nchars&lt;/code&gt; 是扫描的字符数，InputStack是 &lt;code&gt;InputStack&lt;/code&gt; 匹配的输入的反向列表。</target>
        </trans-unit>
        <trans-unit id="6cf01db782c53881c8e9b381ef1af37e91bea8ec" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the input characters not used.</source>
          <target state="translated">字符串被读取。 &lt;code&gt;InputList&lt;/code&gt; 是成功匹配和读取的项目的列表，而 &lt;code&gt;LeftOverChars&lt;/code&gt; 是未使用的输入字符。</target>
        </trans-unit>
        <trans-unit id="45cb7749daf0319866610d1f7a6f2fda868e24e9" translate="yes" xml:space="preserve">
          <source>The string was read. &lt;code&gt;InputList&lt;/code&gt; is the list of successfully matched and read items, and &lt;code&gt;LeftOverChars&lt;/code&gt; are the remaining characters.</source>
          <target state="translated">字符串被读取。 &lt;code&gt;InputList&lt;/code&gt; 是成功匹配和读取的项目的列表，而 &lt;code&gt;LeftOverChars&lt;/code&gt; 是剩余的字符。</target>
        </trans-unit>
        <trans-unit id="7023fc710fcbee2ee1b2d0076f2bbb73fe92a4c8" translate="yes" xml:space="preserve">
          <source>The structure defines six tables in the database. In &lt;code&gt;Mnesia&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. &lt;code&gt;Name&lt;/code&gt; is the table name.</source>
          <target state="translated">该结构在数据库中定义了六个表。在 &lt;code&gt;Mnesia&lt;/code&gt; 中，函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 创建表。 &lt;code&gt;Name&lt;/code&gt; 是表名称。</target>
        </trans-unit>
        <trans-unit id="39d9e3d6533e72d537d969467d83db3f839ba80c" translate="yes" xml:space="preserve">
          <source>The structured types of ASN.1 are constructed from other types in a manner similar to the concepts of array and struct in C.</source>
          <target state="translated">ASN.1的结构化类型是以类似于C语言中数组和结构体概念的方式从其他类型中构造出来的。</target>
        </trans-unit>
        <trans-unit id="3d28e19e96e7591f2c1e234739ca3d285e1425a0" translate="yes" xml:space="preserve">
          <source>The structured types previously described can have other named types as their components. The general syntax to assign a value to component &lt;code&gt;C&lt;/code&gt; of a named ASN.1 type &lt;code&gt;T&lt;/code&gt; in Erlang is the record syntax &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt;. Here &lt;code&gt;Value&lt;/code&gt; can be a value of yet another type &lt;code&gt;T2&lt;/code&gt;, for example:</source>
          <target state="translated">先前描述的结构化类型可以将其他命名类型作为其组件。将值分配给Erlang中名为ASN.1类型 &lt;code&gt;T&lt;/code&gt; 的组件 &lt;code&gt;C&lt;/code&gt; 的值的通用语法是记录语法 &lt;code&gt;#'T'{'C'=Value}&lt;/code&gt; 。这里的 &lt;code&gt;Value&lt;/code&gt; 可以是另一个 &lt;code&gt;T2&lt;/code&gt; 类型的值，例如：</target>
        </trans-unit>
        <trans-unit id="0fc0372505592d800b784db4902cf9621fae67f0" translate="yes" xml:space="preserve">
          <source>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; The syntax is as follows:</source>
          <target state="translated">订阅功能可激活事件的订阅。事件作为消息传递给评估功能 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 的过程，语法如下：</target>
        </trans-unit>
        <trans-unit id="c6fc9553c48dee56909efc052afcae5e3f5e6f87" translate="yes" xml:space="preserve">
          <source>The subset of calls from any of the vertices.</source>
          <target state="translated">来自任何一个顶点的调用子集。</target>
        </trans-unit>
        <trans-unit id="5f5b8c212a6fee019c36df2950bd77268424ff70" translate="yes" xml:space="preserve">
          <source>The subset of calls to and from any of the vertices. For all sets of calls &lt;code&gt;CS&lt;/code&gt; and all sets of vertices &lt;code&gt;VS&lt;/code&gt;, &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; is equivalent to &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt;.</source>
          <target state="translated">呼入或呼出任何顶点的子集。对于所有调用 &lt;code&gt;CS&lt;/code&gt; 和所有顶点 &lt;code&gt;VS&lt;/code&gt; ， &lt;code&gt;CS&amp;nbsp;|||&amp;nbsp;VS&amp;nbsp;&lt;/code&gt; 相当于 &lt;code&gt;CS&amp;nbsp;|&amp;nbsp;VS&amp;nbsp;*&amp;nbsp;CS&amp;nbsp;||&amp;nbsp;VS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5085549ad982bc38493bd15cfb61ace15049e68" translate="yes" xml:space="preserve">
          <source>The subset of calls to any of the vertices.</source>
          <target state="translated">对任何一个顶点的调用的子集。</target>
        </trans-unit>
        <trans-unit id="2fe87376a37704db2bf21986e270c17fe93f1cb0" translate="yes" xml:space="preserve">
          <source>The subsystem can be run on the host &lt;strong&gt;tarlop&lt;/strong&gt; with the generated keys, as described in Section &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">子系统可以使用生成的密钥在主机&lt;strong&gt;tarlop&lt;/strong&gt;上 &lt;code&gt;&lt;a href=&quot;#Running%20an%20Erlang%20ssh%20Daemon&quot;&gt;Running an Erlang ssh Daemon&lt;/a&gt;&lt;/code&gt; ，如运行Erlang ssh守护程序一节中所述：</target>
        </trans-unit>
        <trans-unit id="e7163b547fafca1e1a01c6c85101dafd95545463" translate="yes" xml:space="preserve">
          <source>The subtype constraint (&lt;code&gt;CONTAINING&lt;/code&gt;/&lt;code&gt;ENCODED BY&lt;/code&gt;) to constrain the content of an octet string or a bit string is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">编译时会分析用于约束八位位组字符串或位字符串的内容的子类型约束（ &lt;code&gt;CONTAINING&lt;/code&gt; / &lt;code&gt;ENCODED BY&lt;/code&gt; ），但不会采取进一步的措施。此约束不是PER可见约束。</target>
        </trans-unit>
        <trans-unit id="996c8474dfc5442a02a67e994d403bba3cebf442" translate="yes" xml:space="preserve">
          <source>The subtype constraint by regular expressions (&lt;code&gt;PATTERN&lt;/code&gt;) for character string types is parsed when compiling, but no further action is taken. This constraint is not a PER-visible constraint.</source>
          <target state="translated">编译时会分析正则表达式（ &lt;code&gt;PATTERN&lt;/code&gt; ）对字符串类型的子类型约束，但不会采取进一步的措施。此约束不是PER可见约束。</target>
        </trans-unit>
        <trans-unit id="449b6a9e34717e9034f068e9ddd7557ac6068822" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;FuncCallCount&lt;/code&gt; values for all functions in module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mod&lt;/code&gt; 模块中所有函数的 &lt;code&gt;FuncCallCount&lt;/code&gt; 值的总和。</target>
        </trans-unit>
        <trans-unit id="3234d4076f0843a2b33750a12acc0b2c6ea1ad8f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;ModCallCount&lt;/code&gt; values for all modules concerned in &lt;code&gt;ModAnalysisList&lt;/code&gt;.</source>
          <target state="translated">总和 &lt;code&gt;ModCallCount&lt;/code&gt; 所有有关模块值 &lt;code&gt;ModAnalysisList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7d6e1d3697888bda0178100688b0ec34a104aff" translate="yes" xml:space="preserve">
          <source>The sum of all memory categories.</source>
          <target state="translated">所有记忆类别的总和。</target>
        </trans-unit>
        <trans-unit id="ff0037c4e027cabbd2193a3640bbe8630c8ea4e3" translate="yes" xml:space="preserve">
          <source>The sum of all off-heap binaries allocated.</source>
          <target state="translated">分配的所有离堆二进制文件的总和。</target>
        </trans-unit>
        <trans-unit id="b154828ab69194ef3277c5a0a09ca37fe5a5d84e" translate="yes" xml:space="preserve">
          <source>The sum of all process memory used.</source>
          <target state="translated">使用的所有进程内存的总和。</target>
        </trans-unit>
        <trans-unit id="44dab01c88ded1b7b32e51ef73e1252818de000b" translate="yes" xml:space="preserve">
          <source>The supervision tree is a hierarchical arrangement of code into supervisors and workers, which makes it possible to design and program fault-tolerant software.</source>
          <target state="translated">监督树是将代码按层次排列成主管和工人,这使得设计和编程容错软件成为可能。</target>
        </trans-unit>
        <trans-unit id="2b52420c5f524763cf64a935f578714dd96d159c" translate="yes" xml:space="preserve">
          <source>The supervisor behaviour supports changing the internal state, that is, changing the restart strategy and maximum restart frequency properties, as well as changing the existing child specifications.</source>
          <target state="translated">主管行为支持改变内部状态,即改变重启策略和最大重启频率属性,以及改变现有的子规范。</target>
        </trans-unit>
        <trans-unit id="cffb4f2e0dfb75d9604922d437c1a8dd8826e6a0" translate="yes" xml:space="preserve">
          <source>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">监督器负责启动、停止和监控它的子进程。监督者的基本思想是,它必须在必要时通过重新启动子进程来保持其活力。</target>
        </trans-unit>
        <trans-unit id="768e22d6442b06516d91f5426c41a68d034c3f04" translate="yes" xml:space="preserve">
          <source>The supervisor must be registered as &lt;code&gt;ch_sup&lt;/code&gt; for the script to work. If the supervisor is not registered, it cannot be accessed directly from the script. Instead a help function that finds the pid of the supervisor and calls &lt;code&gt;supervisor:restart_child&lt;/code&gt;, and so on, must be written. This function is then to be called from the script using the &lt;code&gt;apply&lt;/code&gt; instruction.</source>
          <target state="translated">主管必须注册为 &lt;code&gt;ch_sup&lt;/code&gt; ，脚本才能正常工作。如果主管未注册，则不能直接从脚本中访问它。相反，必须编写一个帮助函数，该函数查找主管的pid并调用 &lt;code&gt;supervisor:restart_child&lt;/code&gt; 等。然后，使用 &lt;code&gt;apply&lt;/code&gt; 指令从脚本中调用此函数。</target>
        </trans-unit>
        <trans-unit id="dd784bb324ef894ad782bd6fc54c8cbffbd00c9c" translate="yes" xml:space="preserve">
          <source>The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows:</source>
          <target state="translated">主管属性是由主管标志来定义的。监管人标志的类型定义如下。</target>
        </trans-unit>
        <trans-unit id="445d5aae8f507ca020cd700c1e982027b7aa04d5" translate="yes" xml:space="preserve">
          <source>The supervisor then starts all its child processes according to the child specifications in the start specification. In this case there is one child process, &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">然后，主管根据启动规范中的子规范启动其所有子进程。在这种情况下，有一个子进程 &lt;code&gt;ch3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1ea33c0638456c050fb5c1069b48715bb9e4c7a" translate="yes" xml:space="preserve">
          <source>The supervisor tree of an included application is started as part of the supervisor tree of the including application. If there is a need for synchronization between processes in the including and included applications, this can be achieved by using &lt;strong&gt;start phases&lt;/strong&gt;.</source>
          <target state="translated">作为包含应用程序的主管树的一部分，将启动包含应用程序的主管树。如果需要在包含应用程序和包含应用程序中的进程之间进行同步，则可以通过使用&lt;strong&gt;启动阶段&lt;/strong&gt;来实现。</target>
        </trans-unit>
        <trans-unit id="a588b6125bf699dd160cdf7a903456eed3b8cbe9" translate="yes" xml:space="preserve">
          <source>The supervisors have a built-in mechanism to limit the number of restarts which can occur in a given time interval. This is specified by the two keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the supervisor flags map returned by the callback function &lt;code&gt;init&lt;/code&gt;:</source>
          <target state="translated">主管具有内置机制，可以限制在给定时间间隔内可能发生的重新启动次数。这由回调函数 &lt;code&gt;init&lt;/code&gt; 返回的主管标志映射中的两个键 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 指定：</target>
        </trans-unit>
        <trans-unit id="2b2633e4167b1433781a2f1a62c27832d676f8d6" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;Reason&lt;/code&gt; becomes the exit reason for the server process. Default Any &lt;code&gt;Reason&lt;/code&gt; other than &lt;code&gt;kill&lt;/code&gt; sends a request to the server and waits for it to clean up, reply and exit. If &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;kill&lt;/code&gt;, the server is bluntly killed.</source>
          <target state="translated">提供的 &lt;code&gt;Reason&lt;/code&gt; 将成为服务器进程的退出原因。缺省值除 &lt;code&gt;kill&lt;/code&gt; 以外的任何其他 &lt;code&gt;Reason&lt;/code&gt; 都会向服务器发送请求，并等待其清理，回复并退出。如果 &lt;code&gt;Reason&lt;/code&gt; 为 &lt;code&gt;kill&lt;/code&gt; ，则服务器将被直接杀死。</target>
        </trans-unit>
        <trans-unit id="96f30a73bfb2b83438049030688c67e96198fa91" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. It is released before it is ready to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release.</source>
          <target state="translated">对从存档文件加载代码的支持是试验性的。它是在获得早期反馈之前发布的。文件格式、语义、接口等可以在未来的版本中进行修改。</target>
        </trans-unit>
        <trans-unit id="7908060a0b898a45469fbc25ab16112e1c77d124" translate="yes" xml:space="preserve">
          <source>The support for loading code from archive files is experimental. The purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The function &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; and flag &lt;code&gt;-code_path_choice&lt;/code&gt; are also experimental.</source>
          <target state="translated">从存档文件加载代码的支持是实验性的。在准备就绪之前将其释放的目的是获得早期反馈。在将来的版本中，可以更改文件格式，语义，接口等。函数 &lt;code&gt;&lt;a href=&quot;#lib_dir-2&quot;&gt;lib_dir/2&lt;/a&gt;&lt;/code&gt; 和标志 &lt;code&gt;-code_path_choice&lt;/code&gt; 也是实验性的。</target>
        </trans-unit>
        <trans-unit id="0fc1d82ce90810c32581e8a0920c335e0c517632" translate="yes" xml:space="preserve">
          <source>The support for loading of code from archive files is experimental. The only purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The &lt;code&gt;-code_path_choice&lt;/code&gt; flag is also experimental.</source>
          <target state="translated">从存档文件加载代码的支持是实验性的。在准备就绪之前将其释放的唯一目的是获得早期反馈。在将来的版本中，可以更改文件格式，语义，接口等。该 &lt;code&gt;-code_path_choice&lt;/code&gt; 标志也是实验。</target>
        </trans-unit>
        <trans-unit id="e2394cc20beed2954b20caec09868b8789fdcf8c" translate="yes" xml:space="preserve">
          <source>The support for sequential tracing provided by Trace Tool Builder includes the following:</source>
          <target state="translated">Trace Tool Builder 提供的顺序跟踪支持包括以下内容。</target>
        </trans-unit>
        <trans-unit id="6228d25d9b25f4927da788e40437ce4f4ff23407" translate="yes" xml:space="preserve">
          <source>The symbols &lt;code&gt;'-&amp;gt;'&lt;/code&gt;, and &lt;code&gt;':'&lt;/code&gt; have to be treated in a special way, as they are meta symbols of the grammar notation, as well as terminal symbols of the Yecc grammar.</source>
          <target state="translated">符号 &lt;code&gt;'-&amp;gt;'&lt;/code&gt; 和 &lt;code&gt;':'&lt;/code&gt; 必须以特殊方式处理，因为它们既是语法符号的元符号，又是Yecc语法的末尾符号。</target>
        </trans-unit>
        <trans-unit id="b5b1fca95a16b28d8128e58b5512a0179363f6cf" translate="yes" xml:space="preserve">
          <source>The symbols in front of the application names are intended to describe the status of the application. There are error and warning symbols to signalize that there is something which needs attention. The tick symbol means that the application is included or derived and no problem has been detected. The cross symbol means that the application is excluded or available and no problem has been detected. Applications with error symbols are listed first in each category and are followed by the warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">应用程序名称前的符号旨在描述应用程序的状态。还有错误和警告符号,表示有需要注意的地方。勾号表示应用程序被包含或派生,并且没有发现问题。十字符号表示应用程序被排除或可用,并且没有发现问题。每类应用中首先列出有错误符号的应用,后面是警告,最后是正常的应用(打勾和交叉)。</target>
        </trans-unit>
        <trans-unit id="4ff1d477dc7a2e1cb7c0f348638a12a2059b2005" translate="yes" xml:space="preserve">
          <source>The symbols in front of the module names are intended to describe the status of the module. There are error and and warning symbols to signalize that there is something that needs attention. The tick symbol means that the module is included or derived and no problem has been detected. The cross symbol means that the module is excluded or available and no problem has been detected. Modules with error symbols are listed first in each category and are followed by warnings and the normal ones (ticks and crosses) at the end.</source>
          <target state="translated">模块名称前面的符号是用来描述模块的状态。有错误符号和警告符号,表示有需要注意的地方。勾号表示该模块被包含或派生,没有发现问题。十字符号表示该模块被排除或可用,没有发现问题。带有错误符号的模块在每个类别中首先列出,后面是警告,最后是正常的警告(tick和cross)。</target>
        </trans-unit>
        <trans-unit id="9cf67be71d81d661199fd8c3ef66c9bc2a23e743" translate="yes" xml:space="preserve">
          <source>The synchronous request &lt;code&gt;alloc()&lt;/code&gt; is implemented using &lt;code&gt;gen_server:call/2&lt;/code&gt;:</source>
          <target state="translated">同步请求 &lt;code&gt;alloc()&lt;/code&gt; 使用 &lt;code&gt;gen_server:call/2&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="63eb54580b86c06f3268ea4e7b5bcac96de253d8" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material.</source>
          <target state="translated">PCRE支持的正则表达式的语法和语义将在下面的章节中详细介绍。Perl的正则表达式在它自己的文档中也有介绍,一般的正则表达式在很多书中都有介绍,有些书中还有大量的例子。Jeffrey Friedl的《掌握正则表达式》(O'Reilly出版)对正则表达式的介绍非常详细。这篇关于PCRE正则表达式的描述是作为参考资料。</target>
        </trans-unit>
        <trans-unit id="ac7e6289b406769100c4fe1cdd3bffd156db1884" translate="yes" xml:space="preserve">
          <source>The syntax highlighting can be activated from the Erlang menu. There are four different alternatives:</source>
          <target state="translated">语法高亮可以从Erlang菜单中激活。有四种不同的选择。</target>
        </trans-unit>
        <trans-unit id="817a7b6234953ff285a5cf26b3d3913052cb1f96" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows (requires a list within the groups list):</source>
          <target state="translated">Erlang shell中的语法如下(需要在group列表中加入一个列表)。</target>
        </trans-unit>
        <trans-unit id="c11a6d8aa6d68bd5c6fc23a6b8b784283b982fbc" translate="yes" xml:space="preserve">
          <source>The syntax in the Erlang shell is as follows:</source>
          <target state="translated">Erlang shell中的语法如下。</target>
        </trans-unit>
        <trans-unit id="21b1becf4be6592870e0896862b9b302a4959623" translate="yes" xml:space="preserve">
          <source>The syntax of  &lt;strong id=&quot;variable&quot;&gt;variables&lt;/strong&gt; is simple:</source>
          <target state="translated">&lt;strong id=&quot;variable&quot;&gt;变量&lt;/strong&gt;的语法 很简单：</target>
        </trans-unit>
        <trans-unit id="f3c5861c6322d86304cb4290ee33a8caf450460f" translate="yes" xml:space="preserve">
          <source>The syntax of Erlang tokens allow the use of the full ISO-8859-1 (Latin-1) character set. This is noticeable in the following ways:</source>
          <target state="translated">Erlang tokens的语法允许使用完整的ISO-8859-1(Latin-1)字符集。这在以下几个方面很明显。</target>
        </trans-unit>
        <trans-unit id="dc8d5f699e53e1bdc1770774109fbc1b5599f479" translate="yes" xml:space="preserve">
          <source>The system call failed to add the event object to the poll set.</source>
          <target state="translated">系统调用失败,未能将事件对象添加到投票集。</target>
        </trans-unit>
        <trans-unit id="401fca03bc6c302beb7da6e4fb8eca70f288ed7b" translate="yes" xml:space="preserve">
          <source>The system can become inconsistent as a result of a power failure. The UNIX feature &lt;code&gt;fsck&lt;/code&gt; can possibly repair the file system, but there is no guarantee that the file content is consistent.</source>
          <target state="translated">由于电源故障，系统可能会变得不一致。UNIX功能 &lt;code&gt;fsck&lt;/code&gt; 可能可以修复文件系统，但是不能保证文件内容是一致的。</target>
        </trans-unit>
        <trans-unit id="11ac012ee2a6049d1c81dbfe5e5bcc868023bccc" translate="yes" xml:space="preserve">
          <source>The system configuration files for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;cp3@cave&lt;/code&gt; are identical, except for the list of mandatory nodes, which is to be &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; for &lt;code&gt;cp2@cave&lt;/code&gt; and &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; for &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cp2@cave&lt;/code&gt; 和 &lt;code&gt;cp3@cave&lt;/code&gt; 的系统配置文件是相同的，除了必需节点的列表，对于 &lt;code&gt;cp2@cave&lt;/code&gt; 和 &lt;code&gt;[cp1@cave, cp2@cave]&lt;/code&gt; cp1 @ cave &lt;code&gt;[cp1@cave, cp3@cave]&lt;/code&gt; ，它们是[cp1 @ cave，cp3 @ cave]。对于 &lt;code&gt;cp3@cave&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88a86df323fb5ec0c1b444523d82be4cff548c59" translate="yes" xml:space="preserve">
          <source>The system configuration is to be called &lt;code&gt;Name.config&lt;/code&gt; and Erlang is to be started with the command-line argument &lt;code&gt;-config Name&lt;/code&gt;. For details, see the &lt;code&gt;config(4)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">系统配置将称为 &lt;code&gt;Name.config&lt;/code&gt; ,而Erlang将使用命令行参数 &lt;code&gt;-config Name&lt;/code&gt; 来启动。有关详细信息，请参见内核中的 &lt;code&gt;config(4)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9f6cd0cc01a1dae027af31ac2b3320efd5d91c8a" translate="yes" xml:space="preserve">
          <source>The system events are as follows:</source>
          <target state="translated">系统事件如下:</target>
        </trans-unit>
        <trans-unit id="40222a7fb3caf074645df66a48dca922ad535e5b" translate="yes" xml:space="preserve">
          <source>The system has run out of memory. &amp;lt;A&amp;gt; is the allocator that failed to allocate memory, &amp;lt;N&amp;gt; is the number of bytes that &amp;lt;A&amp;gt; tried to allocate, and &amp;lt;T&amp;gt; is the memory block type that the memory was needed for. The most common case is that a process stores huge amounts of data. In this case &amp;lt;T&amp;gt; is most often &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;old_heap&lt;/code&gt;, &lt;code&gt;heap_frag&lt;/code&gt;, or &lt;code&gt;binary&lt;/code&gt;. For more information on allocators, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统内存不足。&amp;lt;A&amp;gt;是分配内存失败的分配器，&amp;lt;N&amp;gt;是&amp;lt;A&amp;gt;尝试分配的字节数，而&amp;lt;T&amp;gt;是需要内存的内存块类型。最常见的情况是一个进程存储大量数据。在这种情况下，&amp;lt;T&amp;gt;通常是 &lt;code&gt;heap&lt;/code&gt; ， &lt;code&gt;old_heap&lt;/code&gt; ， &lt;code&gt;heap_frag&lt;/code&gt; 或 &lt;code&gt;binary&lt;/code&gt; 。有关分配器的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6876d9a2709d42d9bf8117946f6bf8730f5ef93a" translate="yes" xml:space="preserve">
          <source>The system information should be stored in a file called &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">系统信息应存储在名为 &lt;code&gt;standard.conf&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="b6783eebca0127687dc6f7166b232d99095419a8" translate="yes" xml:space="preserve">
          <source>The system is delivered as a Windows Installer executable. Get it from http://www.erlang.org/download.html</source>
          <target state="translated">该系统以Windows安装程序可执行文件的形式交付。从 http://www.erlang.org/download.html 获取。</target>
        </trans-unit>
        <trans-unit id="bd0ed26a1f271e06db89ef0fba3d2b075b59188d" translate="yes" xml:space="preserve">
          <source>The system is restarted &lt;strong&gt;inside&lt;/strong&gt; the running Erlang node, which means that the emulator is not restarted. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system is booted again in the same way as initially started. The same &lt;code&gt;BootArgs&lt;/code&gt; are used again.</source>
          <target state="translated">系统将&lt;strong&gt;在&lt;/strong&gt;正在运行的Erlang节点&lt;strong&gt;内&lt;/strong&gt;重新启动，这意味着模拟器不会重新启动。顺利重新启动所有应用程序，卸载所有代码并关闭所有端口，然后以与最初启动相同的方式再次引导系统。再次使用相同的 &lt;code&gt;BootArgs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a035d0281caa4cfae8d815a43e248cd4f5e42d" translate="yes" xml:space="preserve">
          <source>The system keeps information about which versions are old and permanent in the files &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt;.</source>
          <target state="translated">系统在文件 &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; 和 &lt;code&gt;$ROOT/releases/start_erl.data&lt;/code&gt; 保留有关哪个版本旧且永久的信息。</target>
        </trans-unit>
        <trans-unit id="6da0e848ff2fa7a0109efc8207e6e2b2e7ad33b9" translate="yes" xml:space="preserve">
          <source>The system must be configured using only one system configuration file, called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">必须仅使用一个名为 &lt;code&gt;sys.config&lt;/code&gt; 的系统配置文件来配置系统。</target>
        </trans-unit>
        <trans-unit id="534f8510b4ab2486a116f82477cc86a51046615f" translate="yes" xml:space="preserve">
          <source>The system settings page is rather incomplete.</source>
          <target state="translated">系统设置页面比较不完整。</target>
        </trans-unit>
        <trans-unit id="b9d981657e3a5548cb7241507be1ea948d7f1448" translate="yes" xml:space="preserve">
          <source>The system tracer only receives those trace events that occur locally within the Erlang node. To get the whole picture of a sequential trace, involving processes on many Erlang nodes, the output from the system tracer on each involved node must be merged (offline).</source>
          <target state="translated">系统跟踪器只接收那些发生在本地的Erlang节点的跟踪事件。为了得到一个连续跟踪的全貌,涉及到许多Erlang节点上的进程,系统跟踪器在每个涉及到的节点上的输出必须被合并(离线)。</target>
        </trans-unit>
        <trans-unit id="d708a25f112a938c386e67dff885572e579436bd" translate="yes" xml:space="preserve">
          <source>The system version of the node from which the dump originates</source>
          <target state="translated">源于转储的节点的系统版本。</target>
        </trans-unit>
        <trans-unit id="bc82ebf34afcabbe0cf21d28525ebd613647d5a2" translate="yes" xml:space="preserve">
          <source>The system window consists of four main pages (tabs):</source>
          <target state="translated">系统窗口由四个主要页面(标签)组成。</target>
        </trans-unit>
        <trans-unit id="b7bde4446c570b77fe2a6f9c4779d3be956d8d0b" translate="yes" xml:space="preserve">
          <source>The system window is started with the function &lt;code&gt;reltool:start/1&lt;/code&gt;. At startup the tool will process all &lt;code&gt;beam&lt;/code&gt; files and &lt;code&gt;app&lt;/code&gt; files in order to find out dependencies between applications and their modules. Once all this information has been derived, it will be possible to explore the tool.</source>
          <target state="translated">使用功能 &lt;code&gt;reltool:start/1&lt;/code&gt; 启动系统窗口。在启动时，该工具将处理所有 &lt;code&gt;beam&lt;/code&gt; 文件和 &lt;code&gt;app&lt;/code&gt; 文件，以找出应用程序及其模块之间的依赖关系。一旦获得所有这些信息，便有可能探索该工具。</target>
        </trans-unit>
        <trans-unit id="041698f829edd5b26d5d0d6979109c4827078e80" translate="yes" xml:space="preserve">
          <source>The system writes the crash dump in the current directory of the emulator or in the file pointed out by the environment variable (whatever that means on the current operating system) &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt;. For a crash dump to be written, a writable file system must be mounted.</source>
          <target state="translated">系统将故障转储写入仿真器的当前目录或环境变量指出的文件中（无论在当前操作系统上是什么） &lt;code&gt;ERL_CRASH_DUMP&lt;/code&gt; 。要写入故障转储，必须安装可写文件系统。</target>
        </trans-unit>
        <trans-unit id="279b6ca3b37adc0893d23faefa9739dedcc3dbfa" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;Tab&lt;/code&gt; must have an index on position &lt;code&gt;Pos&lt;/code&gt;.</source>
          <target state="translated">表格 &lt;code&gt;Tab&lt;/code&gt; 必须在位置 &lt;code&gt;Pos&lt;/code&gt; 上具有索引。</target>
        </trans-unit>
        <trans-unit id="3dc16fbae2468b67b551f7fca9afb369e0f25872" translate="yes" xml:space="preserve">
          <source>The table access rights.</source>
          <target state="translated">表的访问权限。</target>
        </trans-unit>
        <trans-unit id="4c50c3a237a03f8cc2707518e27535b691ad5345" translate="yes" xml:space="preserve">
          <source>The table below summarizes the diameter application's compliance with RFC 6733. Since the diameter application isn't a Diameter node on its own, compliance is strictly the responsibility of the user in many cases, diameter providing the means for the user to be compliant rather than being compliant on its own.</source>
          <target state="translated">下表总结了直径应用对RFC 6733的合规性。由于diameter应用本身并不是Diameter节点,所以在很多情况下,合规性严格来说是用户的责任,diameter为用户提供了合规的手段,而不是自己合规。</target>
        </trans-unit>
        <trans-unit id="25afd1e5876ef9e8eeb6a3459a04948d4b88d14d" translate="yes" xml:space="preserve">
          <source>The table content is placed in a &lt;code&gt;.DCD&lt;/code&gt; file on the disc. When the &lt;code&gt;Mnesia&lt;/code&gt; system is started, the RAM table is initially loaded with data from its &lt;code&gt;.DCD&lt;/code&gt; file.</source>
          <target state="translated">表内容放置在光盘上的 &lt;code&gt;.DCD&lt;/code&gt; 文件中。当 &lt;code&gt;Mnesia&lt;/code&gt; 系统启动时，RAM表最初会加载来自其 &lt;code&gt;.DCD&lt;/code&gt; 文件的数据。</target>
        </trans-unit>
        <trans-unit id="1a0aa2d29620215b66b862b74a258da9f0952597" translate="yes" xml:space="preserve">
          <source>The table identifier.</source>
          <target state="translated">表的标识符。</target>
        </trans-unit>
        <trans-unit id="d6e8f6600b6898b285183c9a2efcd8e9919e547e" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;bag&lt;/code&gt; table, which can have many objects, but only one instance of each object, per key.</source>
          <target state="translated">该表是一个 &lt;code&gt;bag&lt;/code&gt; 表，每个键可以有许多对象，但每个对象只能有一个实例。</target>
        </trans-unit>
        <trans-unit id="1326636cb8d9d2c6e8abd48a67ecc64dc60e8dbf" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;duplicate_bag&lt;/code&gt; table, which can have many objects, including multiple copies of the same object, per key.</source>
          <target state="translated">该表是一个 &lt;code&gt;duplicate_bag&lt;/code&gt; 表，每个键可以有许多对象，包括同一对象的多个副本。</target>
        </trans-unit>
        <trans-unit id="f70ade515d71247538e9584965be02630fd1a515" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;ordered_set&lt;/code&gt; table: one key, one object, ordered in Erlang term order, which is the order implied by the &amp;lt; and &amp;gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the &lt;code&gt;ordered_set&lt;/code&gt; tables regard keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt;, not only when they match. This means that to an &lt;code&gt;ordered_set&lt;/code&gt; table, &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; and &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; are regarded as equal. This also means that the key used to lookup an element not necessarily &lt;strong&gt;matches&lt;/strong&gt; the key in the returned elements, if &lt;code&gt;float()&lt;/code&gt;'s and &lt;code&gt;integer()&lt;/code&gt;'s are mixed in keys of a table.</source>
          <target state="translated">该表是 &lt;code&gt;ordered_set&lt;/code&gt; 表：一个键，一个对象，按照Erlang术语顺序（即&amp;lt;和&amp;gt;运算符所隐含的顺序）进行排序。这种类型的表在某些情况下的行为与其他类型的表有些不同。最值得注意的是，在 &lt;code&gt;ordered_set&lt;/code&gt; 表把钥匙作为平等的，当他们&lt;strong&gt;比较平等的&lt;/strong&gt;，而不是只有当它们匹配。这意味着对于 &lt;code&gt;ordered_set&lt;/code&gt; 表， &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; 被视为相等。这也意味着，如果 &lt;code&gt;float()&lt;/code&gt; 和 &lt;code&gt;integer()&lt;/code&gt; 在一起，则用于查找元素的键不一定&lt;strong&gt;与&lt;/strong&gt;返回的元素&lt;strong&gt;中&lt;/strong&gt;的键&lt;strong&gt;匹配&lt;/strong&gt;。混合在表的键中。</target>
        </trans-unit>
        <trans-unit id="272d7513098b30b16e878b3eb48399c3327cbbea" translate="yes" xml:space="preserve">
          <source>The table is a &lt;code&gt;set&lt;/code&gt; table: one key, one object, no order among objects. This is the default table type.</source>
          <target state="translated">该表是一个 &lt;code&gt;set&lt;/code&gt; 表：一个键，一个对象，对象之间没有顺序。这是默认表类型。</target>
        </trans-unit>
        <trans-unit id="b9f8a5943e8075893eb3b3474ba785f08fed2473" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;match/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;match/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="9881ec6398c8615af13073d22ceceab6e1d017fd" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;match_object/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;match_object/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;match_object/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;match_object/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="e2da56b6127d8f8b1f1475a198ead6fa8576cef3" translate="yes" xml:space="preserve">
          <source>The table is always to be protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; before calling &lt;code&gt;select/3&lt;/code&gt;, otherwise errors can occur when calling &lt;code&gt;select/1&lt;/code&gt;.</source>
          <target state="translated">在调用 &lt;code&gt;select/3&lt;/code&gt; 之前，始终使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 保护该表，否则在调用 &lt;code&gt;select/1&lt;/code&gt; 时可能会发生错误。</target>
        </trans-unit>
        <trans-unit id="a15b4f96977744e9f06d4a053061f2ae406c3cc5" translate="yes" xml:space="preserve">
          <source>The table is read or written in chunks of &lt;code&gt;?CHARS_PER_REC&lt;/code&gt;, overwriting when necessary. The implementation is clearly not efficient, it is just working.</source>
          <target state="translated">在 &lt;code&gt;?CHARS_PER_REC&lt;/code&gt; 的块中读取或写入表，必要时覆盖。实施显然效率不高，只是有效。</target>
        </trans-unit>
        <trans-unit id="216abe432d30c693518496ed41d4537b67851e03" translate="yes" xml:space="preserve">
          <source>The table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. Option &lt;code&gt;n_objects&lt;/code&gt; determines the number of objects returned (the third argument of &lt;code&gt;select/3&lt;/code&gt;); the default is to return &lt;code&gt;100&lt;/code&gt; objects at a time. The &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; (the second argument of &lt;code&gt;select/3&lt;/code&gt;) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 遍历该表。选项 &lt;code&gt;n_objects&lt;/code&gt; 确定返回的对象数（ &lt;code&gt;select/3&lt;/code&gt; 的第三个参数）；默认值是一次返回 &lt;code&gt;100&lt;/code&gt; 个对象。的 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; （第二个参数 &lt;code&gt;select/3&lt;/code&gt; 是由QLC组装）：简单过滤器被转换成等效的匹配规格而更复杂的过滤器必须被应用到的所有对象通过返回 &lt;code&gt;select/3&lt;/code&gt; 给出一个匹配规范的所有对象相匹配。</target>
        </trans-unit>
        <trans-unit id="3e9b781613899199f74480c8df4e129f831967a1" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 一次遍历一个表。</target>
        </trans-unit>
        <trans-unit id="7b596d446b0a8770a2196be90fa1f23b7bdccfe0" translate="yes" xml:space="preserve">
          <source>The table is traversed one key at a time by calling &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 一次遍历一个表。</target>
        </trans-unit>
        <trans-unit id="e8716b30387dd883800492663d7d3d90e4516d46" translate="yes" xml:space="preserve">
          <source>The table may be used as an ordinary Mnesia table, using the Mnesia API internally in the application at the same time as it is visible through SNMP.</source>
          <target state="translated">该表可以作为普通的Mnesia表使用,在应用程序内部使用Mnesia API,同时通过SNMP可见。</target>
        </trans-unit>
        <trans-unit id="3d172554a6c6306bf28a607a5a2963fa7455c502" translate="yes" xml:space="preserve">
          <source>The table must be created in Mnesia before the manager can use it. The table must be declared as type &lt;code&gt;snmp&lt;/code&gt;. This makes the table ordered in accordance with the lexicographical ordering rules of SNMP. The name of the Mnesia table must be identical to the SNMP table name. The types of the INDEX fields in the corresponding SNMP table must be specified.</source>
          <target state="translated">该表必须在Mnesia中创建，管理员才能使用它。该表必须声明为 &lt;code&gt;snmp&lt;/code&gt; 类型。这使得表按照SNMP的字典顺序规则进行排序。Mnesia表的名称必须与SNMP表名称相同。必须指定相应SNMP表中INDEX字段的类型。</target>
        </trans-unit>
        <trans-unit id="75b5a69a501aab4ff4e7aeebea0d27ed7fcb4181" translate="yes" xml:space="preserve">
          <source>The table name, regardless of if it is a &lt;code&gt;named_table&lt;/code&gt; or not.</source>
          <target state="translated">表名，无论它是否是 &lt;code&gt;named_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="905054fe1aefc5725eea1173de784dd765e8936b" translate="yes" xml:space="preserve">
          <source>The table name.</source>
          <target state="translated">表名:</target>
        </trans-unit>
        <trans-unit id="aba015ed958a70d6fa81d83ffe73faad038149fe" translate="yes" xml:space="preserve">
          <source>The table property &lt;code&gt;frag_properties&lt;/code&gt; can be read with the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt;. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers &lt;code&gt;Mnesia&lt;/code&gt; to regard the table as fragmented. The fragmentation properties are as follows:</source>
          <target state="translated">可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_properties)&lt;/a&gt;&lt;/code&gt; 读取表属性 &lt;code&gt;frag_properties&lt;/code&gt; 。碎片属性是带有Arity 2的已标记元组的列表。默认情况下，该列表为空，但是当它为非空时，它将触发 &lt;code&gt;Mnesia&lt;/code&gt; 将表视为碎片。碎片属性如下：</target>
        </trans-unit>
        <trans-unit id="d01afc3037ddbf804c41230f3010100787c86042" translate="yes" xml:space="preserve">
          <source>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function.</source>
          <target state="translated">表的副本可以从RAM中备份,也可以从光盘中备份,如果用这个功能转储到那里的话。</target>
        </trans-unit>
        <trans-unit id="015f395b52e0bf9602a397e1f420732c71594a61" translate="yes" xml:space="preserve">
          <source>The table type is not &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">表类型未 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e38c104619f1b370bd6dfa294f10929d5f26c0d" translate="yes" xml:space="preserve">
          <source>The table type, that is, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, &lt;code&gt;dublicate_bag&lt;/code&gt;, or &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">表格类型，即 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ， &lt;code&gt;dublicate_bag&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2206ddd6a97bccbdb41e1737af06cd4da0bcb9" translate="yes" xml:space="preserve">
          <source>The table type.</source>
          <target state="translated">表格类型:</target>
        </trans-unit>
        <trans-unit id="d1da328209adecc0d90374bccf49a5ac8565208f" translate="yes" xml:space="preserve">
          <source>The table-related events that can occur are as follows:</source>
          <target state="translated">可能发生的与表有关的事件如下:</target>
        </trans-unit>
        <trans-unit id="6b7e8b80ac770e54ad2093b66bc38848a1574359" translate="yes" xml:space="preserve">
          <source>The tables are backed up to external media using backup module &lt;code&gt;BackupMod&lt;/code&gt;. Tables with the local contents property are backed up as they exist on the current node. &lt;code&gt;BackupMod&lt;/code&gt; is the default backup callback module obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;. For information about the exact callback interface (the &lt;code&gt;mnesia_backup behavior&lt;/code&gt;), see the User's Guide.</source>
          <target state="translated">使用备份模块 &lt;code&gt;BackupMod&lt;/code&gt; 将表备份到外部介质。具有本地内容属性的表将被备份，因为它们存在于当前节点上。 &lt;code&gt;BackupMod&lt;/code&gt; 是 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 获得的默认备份回调模块。有关确切的回调接口（ &lt;code&gt;mnesia_backup behavior&lt;/code&gt; ）的信息，请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="cf13625217c16a91aadb6ca3932c666df7c246ce" translate="yes" xml:space="preserve">
          <source>The tag for the messages that are sent to the error logger in the Erlang runtime system</source>
          <target state="translated">发送给Erlang运行时系统中错误记录器的消息的标签。</target>
        </trans-unit>
        <trans-unit id="dea673760fa272778aeb2296bada6c28ed936886" translate="yes" xml:space="preserve">
          <source>The tags, their arguments and the contents of each corresponding section are as follows. Each section can occur multiple times unless otherwise specified. The order in which sections are specified is unimportant.</source>
          <target state="translated">標籤、標籤的參數及每一節的內容如下。除非另有说明,否则每个章节可以出现多次。指定章节的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="043e9fad0f693d524a84cb1e4b574f9675842439" translate="yes" xml:space="preserve">
          <source>The tail variables &lt;code&gt;RestDgram&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; bind to binaries, as all tail variables do. Both can bind to empty binaries.</source>
          <target state="translated">尾变量 &lt;code&gt;RestDgram&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 绑定到二进制文件，就像所有尾变量一样。两者都可以绑定到空二进制文件。</target>
        </trans-unit>
        <trans-unit id="7e9693ae2473d33274921bc96471864fb339cde4" translate="yes" xml:space="preserve">
          <source>The target data must exist in a configuration file. The connection can be associated with &lt;code&gt;Name&lt;/code&gt; and/or the returned &lt;code&gt;Handle&lt;/code&gt;. To allocate a name for the target, use one of the following alternatives:</source>
          <target state="translated">目标数据必须存在于配置文件中。该连接可以与 &lt;code&gt;Name&lt;/code&gt; 和/或返回的 &lt;code&gt;Handle&lt;/code&gt; 关联。要为目标分配名称，请使用以下替代方法之一：</target>
        </trans-unit>
        <trans-unit id="bba902f624a3f363faa2c1c1baf548942d9ee3b6" translate="yes" xml:space="preserve">
          <source>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, &quot;\\r\\n&quot; has been removed.</source>
          <target state="translated">telnet行尾的字符,从FTP协议的定义中,CRLF例如&quot;\\r\\n &quot;已被删除。</target>
        </trans-unit>
        <trans-unit id="85e11e994e429cc2b8651f58111eb62a63c0aeb2" translate="yes" xml:space="preserve">
          <source>The template describes how the formatted string is composed by combining different data values from the log event. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information about this.</source>
          <target state="translated">该模板描述了如何通过组合来自日志事件的不同数据值来构成格式化的字符串。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 类型的描述。</target>
        </trans-unit>
        <trans-unit id="eb1a8be6676238f92f5d9b5d87374d91e2e26ce8" translate="yes" xml:space="preserve">
          <source>The template is a list of atoms, atom lists, tuples and strings. The atoms &lt;code&gt;level&lt;/code&gt; or &lt;code&gt;msg&lt;/code&gt;, are treated as placeholders for the severity level and the log message, respectively. Other atoms or atom lists are interpreted as placeholders for metadata, where atoms are expected to match top level keys, and atom lists represent paths to sub keys when the metadata is a nested map. For example the list &lt;code&gt;[key1,key2]&lt;/code&gt; is replaced by the value of the &lt;code&gt;key2&lt;/code&gt; field in the nested map below. The atom &lt;code&gt;key1&lt;/code&gt; on its own is replaced by the complete value of the &lt;code&gt;key1&lt;/code&gt; field. The values are converted to strings.</source>
          <target state="translated">模板是原子列表，原子列表，元组和字符串。原子 &lt;code&gt;level&lt;/code&gt; 或 &lt;code&gt;msg&lt;/code&gt; 分别被视为严重性级别和日志消息的占位符。其他原子或原子列表被解释为元数据的占位符，其中原子应与顶级键匹配，并且原子列表表示当元数据是嵌套映射时子键的路径。例如，列表 &lt;code&gt;[key1,key2]&lt;/code&gt; 被下面的嵌套映射中的 &lt;code&gt;key2&lt;/code&gt; 字段的值替换。 &lt;code&gt;key1&lt;/code&gt; 的原子key1将替换为 &lt;code&gt;key1&lt;/code&gt; 字段的完整值。值将转换为字符串。</target>
        </trans-unit>
        <trans-unit id="96e28f12366708f6b889216805c88be5b281bf16" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;define&lt;/code&gt; introduces a constant that is used to replace the name &lt;code&gt;Constant&lt;/code&gt; with &lt;code&gt;Value&lt;/code&gt;, wherever it is found in the test specification. This replacement occurs during an initial iteration through the test specification. Constants can be used anywhere in the test specification, for example, in any lists and tuples, and even in strings and inside the value part of other constant definitions. A constant can also be part of a node name, but that is the only place where a constant can be part of an atom.</source>
          <target state="translated">术语&amp;ldquo; &lt;code&gt;define&lt;/code&gt; 引入了一个常量，该常量用于在测试规范中的任何位置用&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 替换名称&amp;ldquo; &lt;code&gt;Constant&lt;/code&gt; 。这种替换发生在通过测试规范的初始迭代期间。常量可以在测试规范的任何地方使用，例如，在任何列表和元组中，甚至在字符串中以及在其他常量定义的值部分内部都可以使用。常量也可以是节点名称的一部分，但这是常量可以是原子的一部分的唯一位置。</target>
        </trans-unit>
        <trans-unit id="b33125cbeb164cf4f6a823b4bcb06baf40cb7cda" translate="yes" xml:space="preserve">
          <source>The term &lt;code&gt;specs&lt;/code&gt; can be used to nest specifications, that is, have one specification include other specifications, which in turn include others, and so no</source>
          <target state="translated">术语&amp;ldquo; &lt;code&gt;specs&lt;/code&gt; 可用于嵌套规范，即，一个规范包括其他规范，而其他规范又包括其他规范，因此没有</target>
        </trans-unit>
        <trans-unit id="de1d039344650bb5818e83c555d5196b81ddbd6e" translate="yes" xml:space="preserve">
          <source>The term representing a collection of annotations. It is either a &lt;code&gt;location()&lt;/code&gt; or a list of key-value pairs.</source>
          <target state="translated">表示注释集合的术语。它可以是 &lt;code&gt;location()&lt;/code&gt; 或键值对列表。</target>
        </trans-unit>
        <trans-unit id="206bdfd6f6a1886654062cc692aecc040226c259" translate="yes" xml:space="preserve">
          <source>The terms &lt;code&gt;incl_dirs_r&lt;/code&gt; and &lt;code&gt;excl_dirs_r&lt;/code&gt; tell &lt;code&gt;Common Test&lt;/code&gt; to search the specified directories recursively and include or exclude any module found during the search. The terms &lt;code&gt;incl_dirs&lt;/code&gt; and &lt;code&gt;excl_dirs&lt;/code&gt; result in a non-recursive search for modules (that is, only modules found in the specified directories are included or excluded).</source>
          <target state="translated">术语 &lt;code&gt;incl_dirs_r&lt;/code&gt; 和 &lt;code&gt;excl_dirs_r&lt;/code&gt; 告诉 &lt;code&gt;Common Test&lt;/code&gt; 递归搜索指定的目录，并包括或排除在搜索过程中找到的任何模块。术语 &lt;code&gt;incl_dirs&lt;/code&gt; 和 &lt;code&gt;excl_dirs&lt;/code&gt; 导致对模块的非递归搜索（即，仅包括或排除在指定目录中找到的模块）。</target>
        </trans-unit>
        <trans-unit id="9ddcad5286af6cdd21c133d5d7ddb5de84e979bf" translate="yes" xml:space="preserve">
          <source>The test case can also be marked as failed without executing it by returning a tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; from &lt;code&gt;init_per_testcase&lt;/code&gt;.</source>
          <target state="translated">还可以通过从 &lt;code&gt;init_per_testcase&lt;/code&gt; 返回一个元组 &lt;code&gt;{fail,Reason}&lt;/code&gt; 来将测试用例标记为失败而不执行它。</target>
        </trans-unit>
        <trans-unit id="e8af161d95302d88592feab6a61159ca646e5862" translate="yes" xml:space="preserve">
          <source>The test case function argument &lt;code&gt;Config&lt;/code&gt; is not to be confused with the information that can be retrieved from the configuration files (using &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt;). The test case argument &lt;code&gt;Config&lt;/code&gt; is to be used for runtime configuration of the test suite and the test cases, while configuration files are to contain data related to the SUT. These two types of configuration data are handled differently.</source>
          <target state="translated">不要将测试用例函数的参数 &lt;code&gt;Config&lt;/code&gt; 与可以从配置文件中检索到的信息（使用 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1/2&lt;/a&gt;&lt;/code&gt; ）相混淆。测试用例参数 &lt;code&gt;Config&lt;/code&gt; 将用于测试套件和测试用例的运行时配置，而配置文件将包含与SUT相关的数据。这两种类型的配置数据的处理方式不同。</target>
        </trans-unit>
        <trans-unit id="22d7a935338112ce920c6d20731f07d69ad88ede" translate="yes" xml:space="preserve">
          <source>The test case function takes one argument, &lt;code&gt;Config&lt;/code&gt;, which contains configuration information such as &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt;. (For details about these, see section &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt;. The value of &lt;code&gt;Config&lt;/code&gt; at the time of the call, is the same as the return value from &lt;code&gt;init_per_testcase&lt;/code&gt;, mentioned earlier.</source>
          <target state="translated">测试用例函数采用一个参数 &lt;code&gt;Config&lt;/code&gt; ，该参数包含配置信息，例如 &lt;code&gt;data_dir&lt;/code&gt; 和 &lt;code&gt;priv_dir&lt;/code&gt; 。（有关这些的详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#data_priv_dir&quot;&gt;Data and Private Directories&lt;/a&gt;&lt;/code&gt; 。调用时 &lt;code&gt;Config&lt;/code&gt; 的值与 &lt;code&gt;init_per_testcase&lt;/code&gt; 提到的init_per_testcase的返回值相同。</target>
        </trans-unit>
        <trans-unit id="f3d78685ce4bc3a852ca4f95b85dea262a2dbfd5" translate="yes" xml:space="preserve">
          <source>The test case function.</source>
          <target state="translated">测试案例功能。</target>
        </trans-unit>
        <trans-unit id="772472b0e7495bb1b3ea5fe4354a4abec00b3983" translate="yes" xml:space="preserve">
          <source>The test case group information function, &lt;code&gt;group(GroupName)&lt;/code&gt;, serves the same purpose as the suite- and test case information functions previously described. However, the scope for the group information function, is all test cases and subgroups in the group in question (&lt;code&gt;GroupName&lt;/code&gt;).</source>
          <target state="translated">测试用例组信息功能 &lt;code&gt;group(GroupName)&lt;/code&gt; 的作用与前述的套件和测试用例信息功能相同。但是，组信息功能的范围是相关组（ &lt;code&gt;GroupName&lt;/code&gt; ）中的所有测试用例和子组。</target>
        </trans-unit>
        <trans-unit id="0d2f40a449aa01ec3c8d9cd4d1b80e618a045844" translate="yes" xml:space="preserve">
          <source>The test case group information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of a test case group (that is, its test cases and subgroups). Properties set by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; override properties with the same key that have been set previously by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例组信息功能。应该返回一个标记元组的列表，该列表指定了与测试用例组（即其测试用例和子组）的执行相关的各种属性。由 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 设置的属性将覆盖先前由 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 设置的相同键的属性。</target>
        </trans-unit>
        <trans-unit id="7fc2d22e0d7f34017553a5d0de008034c64289ba" translate="yes" xml:space="preserve">
          <source>The test case information function. It is supposed to return a list of tagged tuples that specify various properties related to the execution of this particular test case. Properties set by &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; override properties set previously for the test case by &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例信息功能。应该返回一个加标签的元组列表，该列表指定了与此特定测试用例的执行相关的各种属性。由 &lt;code&gt;&lt;a href=&quot;#Module:Testcase-0&quot;&gt;Testcase/0&lt;/a&gt;&lt;/code&gt; 设置的属性会覆盖先前由 &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 为测试用例设置的属性。</target>
        </trans-unit>
        <trans-unit id="c528968b61f60ab84b8bb693468a7bbe033dbb46" translate="yes" xml:space="preserve">
          <source>The test case is implemented as follows:</source>
          <target state="translated">测试用例的实现方式如下。</target>
        </trans-unit>
        <trans-unit id="561ea1ed4002a2f665fd14f2b18b980f0debbc51" translate="yes" xml:space="preserve">
          <source>The test case is skipped in the following two cases:</source>
          <target state="translated">在以下两种情况下,测试用例被跳过。</target>
        </trans-unit>
        <trans-unit id="acb7aee40da2324bbced996f9d61c0d108e566ea" translate="yes" xml:space="preserve">
          <source>The test cases verify, by parsing a log file, that our SUT has performed a successful restart and that no unexpected errors are printed.</source>
          <target state="translated">测试用例通过解析日志文件来验证我们的SUT是否已经成功重启,是否有意外的错误被打印出来。</target>
        </trans-unit>
        <trans-unit id="efc4c3530fced19d9cbc7b2225463ba3c8ff70fc" translate="yes" xml:space="preserve">
          <source>The test compares the following encoder/decoders:</source>
          <target state="translated">该测试比较了以下编码器/解码器。</target>
        </trans-unit>
        <trans-unit id="8c3ccb28e1c0e973d6192fea8f8c8d2cd0b4ea0a" translate="yes" xml:space="preserve">
          <source>The test now fails with &lt;code&gt;{badmatch,24}&lt;/code&gt; because the atom &lt;code&gt;toy_table&lt;/code&gt; does not match the number returned for an unnamed table. So, the problem is found, the table is to be named, and the arguments supplied by the test program do not include &lt;code&gt;named_table&lt;/code&gt;. We rewrite the start function:</source>
          <target state="translated">现在，测试失败并显示 &lt;code&gt;{badmatch,24}&lt;/code&gt; ,因为原子 &lt;code&gt;toy_table&lt;/code&gt; 与未命名表返回的数字不匹配。因此，发现了问题，表将被命名，并且测试程序提供的参数不包括 &lt;code&gt;named_table&lt;/code&gt; 。我们重写start函数：</target>
        </trans-unit>
        <trans-unit id="3bf97f87b41a6f29d2b30317c0ec60daf7647ab1" translate="yes" xml:space="preserve">
          <source>The test program runs 10000 decodes on the value, resulting in an output with the elapsed time in microseconds for the total number of decodes.</source>
          <target state="translated">测试程序对该值运行10000次解码,结果输出总解码次数的经过时间,单位为微秒。</target>
        </trans-unit>
        <trans-unit id="3633648c5d3cca8dc486b6dee36d903c368bcf6f" translate="yes" xml:space="preserve">
          <source>The test specification uses the same mechanism for specifying test case groups through names and paths, as explained in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt;, with the addition of element &lt;code&gt;GroupSpec&lt;/code&gt;.</source>
          <target state="translated">测试规范使用相同的机制通过名称和路径指定测试用例组，如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#group_execution&quot;&gt;Test Case Group Execution&lt;/a&gt;&lt;/code&gt; 一节中所述，并添加了元素 &lt;code&gt;GroupSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784058b40fd83e13e1f3df9bc88ef815cead679e" translate="yes" xml:space="preserve">
          <source>The test specifications used as input to &lt;code&gt;Common Test&lt;/code&gt; Master are fully compatible with the specifications used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The syntax is described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">用作 &lt;code&gt;Common Test&lt;/code&gt; Master的输入的测试规范与用作常规 &lt;code&gt;Common Test&lt;/code&gt; 服务器的输入的规范完全兼容。语法在&amp;ldquo;运行 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 和分析结果&amp;rdquo; 部分的&amp;ldquo; 测试规范 &amp;rdquo;部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="15500e2662eb6cf2096b1c33acff5c731c7b2d5b" translate="yes" xml:space="preserve">
          <source>The test suite information function. Returns a list of tagged tuples specifying various properties related to the execution of this test suite (common for all test cases in the suite).</source>
          <target state="translated">测试套件信息函数。Returns a list of tagged tuples specifing various properties related to the execution of this test suite (common for all test cases in the suite).</target>
        </trans-unit>
        <trans-unit id="ca4bd482d9cff3e45eb13e9917fb381a5f26152b" translate="yes" xml:space="preserve">
          <source>The test suite module must conform to a &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; specified by the &lt;code&gt;Common Test&lt;/code&gt; test server. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试套件模块必须符合 &lt;code&gt;Common Test&lt;/code&gt; 测试服务器指定的 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback interface&lt;/a&gt;&lt;/code&gt; 。有关详细信息，请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#intro&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="bd0f930877592ca670db8a085bb70953a2a40661" translate="yes" xml:space="preserve">
          <source>The test suites overview page includes a link to the Unexpected I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt;, as well as captured system error- and progress reports, which cannot be associated with particular test cases and therefore cannot be written to individual test case log files. This occurs, for example, if a log printout is made from an external process (not a test case process), &lt;strong&gt;or&lt;/strong&gt; if an error- or progress report comes in, during a short interval while &lt;code&gt;Common Test&lt;/code&gt; is not executing a test case or configuration function, &lt;strong&gt;or&lt;/strong&gt; while &lt;code&gt;Common Test&lt;/code&gt; is currently executing a parallel test case group.</source>
          <target state="translated">测试套件概述页面包含指向意外I / O日志的链接。在此日志中， &lt;code&gt;Common Test&lt;/code&gt; 保存了使用 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 生成的打印输出，以及捕获的系统错误和进度报告，不能与特定的测试用例相关联，因此不能写入单个测试用例日志文件。例如，如果在 &lt;code&gt;Common Test&lt;/code&gt; 未执行测试用例或配置的短暂间隔内，是从外部流程（不是测试用例流程）打印日志，&lt;strong&gt;或者&lt;/strong&gt;出现了错误或进度报告，则会发生这种情况功能，&lt;strong&gt;或者&lt;/strong&gt;当 &lt;code&gt;Common Test&lt;/code&gt; 当前正在执行并行测试用例组时。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8134f6c45a2f73ed264b68d4ba70993d25134c43" translate="yes" xml:space="preserve">
          <source>The tests can be read as documentation, typically showing both examples of correct and incorrect usage, along with the expected consequences.</source>
          <target state="translated">测试可以作为文档来阅读,通常会展示正确和不正确使用的例子,以及预期的后果。</target>
        </trans-unit>
        <trans-unit id="ab59e3293af2eeab2e6a44396959211db748141a" translate="yes" xml:space="preserve">
          <source>The tests will be released into &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt;. After releasing the tests you have to install the tests on the build machine. You supply the same xcomp file as to &lt;code&gt;./otp_build&lt;/code&gt; in (9).</source>
          <target state="translated">测试将发布到 &lt;code&gt;$ERL_TOP/release/tests&lt;/code&gt; 。发布测试之后，您必须在构建计算机上安装测试。您提供与（9）中的 &lt;code&gt;./otp_build&lt;/code&gt; 相同的xcomp文件。</target>
        </trans-unit>
        <trans-unit id="6461764795f9a7e6a1ca8fecef822585f15dd414" translate="yes" xml:space="preserve">
          <source>The text encoding config.</source>
          <target state="translated">文本编码配置。</target>
        </trans-unit>
        <trans-unit id="0912732fbe8b51c591e00170193eac6690100280" translate="yes" xml:space="preserve">
          <source>The text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt;, which is part of the source code, contains information about all OTP versions from OTP 17.0 up to the current OTP version. Each line contains information about application versions that are part of a specific OTP version, and has the following format:</source>
          <target state="translated">作为源代码一部分的文本文件 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/otp_versions.table&lt;/code&gt; 包含有关从OTP 17.0到当前OTP版本的所有OTP版本的信息。每行包含有关属于特定OTP版本的应用程序版本的信息，并具有以下格式：</target>
        </trans-unit>
        <trans-unit id="f468d3e883b219b9301214ec34fa66d1174c9bd6" translate="yes" xml:space="preserve">
          <source>The text given to a &lt;code&gt;?Q(Text)&lt;/code&gt; macro can be either a single string, or a list of strings. The latter is useful when you need to split a long expression over multiple lines, e.g.:</source>
          <target state="translated">提供给 &lt;code&gt;?Q(Text)&lt;/code&gt; 宏的文本可以是单个字符串，也可以是字符串列表。当您需要将长表达式拆分成多行时，后者非常有用，例如：</target>
        </trans-unit>
        <trans-unit id="02aabeed8f889ebc3fe270b684693102faf40262" translate="yes" xml:space="preserve">
          <source>The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</source>
          <target state="translated">与子表达式相匹配的文本(由正则表达式中的括号标记)被插入到找到它的结果列表中。这意味着,如果将整个正则表达式是一个单一的子表达式的拆分结果进行连接(如上一个例子),其结果总是原始字符串。</target>
        </trans-unit>
        <trans-unit id="7f15d959ef8fc520df7e2a55f83ecd2a324cb0e0" translate="yes" xml:space="preserve">
          <source>The third argument is &lt;code&gt;Vsn&lt;/code&gt; or &lt;code&gt;{down,Vsn}&lt;/code&gt;, as described for &lt;code&gt;gen_server:code_change/3&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第三个参数是 &lt;code&gt;Vsn&lt;/code&gt; 或 &lt;code&gt;{down,Vsn}&lt;/code&gt; ，作为用于描述 &lt;code&gt;gen_server:code_change/3&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;#code_change&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98495365dd14291e5d0887711f1c5c3436964748" translate="yes" xml:space="preserve">
          <source>The third argument is an integer that is used to identify a particular instance of a C node.</source>
          <target state="translated">第三个参数是一个整数,用来标识C节点的一个特定实例。</target>
        </trans-unit>
        <trans-unit id="b22885d6c6999fdcc81a99f8b75e55f5d786c841" translate="yes" xml:space="preserve">
          <source>The third argument is the full node name.</source>
          <target state="translated">第三个参数是完整的节点名称。</target>
        </trans-unit>
        <trans-unit id="365807a93bdba62a0a00761a03b6e541034bb449" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;Code&lt;/code&gt;, is a list of digits, which is the correct unlock code that is passed to callback function &lt;code&gt;init/1&lt;/code&gt;.</source>
          <target state="translated">第三个参数， &lt;code&gt;Code&lt;/code&gt; ，是数字的列表，这是传递到回调函数正确的解锁码 &lt;code&gt;init/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b4235e17037973516e425fe018a785d1dc11753" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;[]&lt;/code&gt;, is a term that is passed as is to the callback function &lt;code&gt;init&lt;/code&gt;. Here, &lt;code&gt;init&lt;/code&gt; does not need any indata and ignores the argument.</source>
          <target state="translated">第三个参数 &lt;code&gt;[]&lt;/code&gt; 是直接传递给回调函数 &lt;code&gt;init&lt;/code&gt; 的术语。在此， &lt;code&gt;init&lt;/code&gt; 不需要任何indata并忽略该参数。</target>
        </trans-unit>
        <trans-unit id="2a25200e085552c647a791d385625d025a3908db" translate="yes" xml:space="preserve">
          <source>The third component is a term providing additional information about the cause of the error.</source>
          <target state="translated">第三个组成部分是一个术语,提供有关错误原因的额外信息。</target>
        </trans-unit>
        <trans-unit id="263e38347244b9c29c16011be163dc8c74039614" translate="yes" xml:space="preserve">
          <source>The third element of the &lt;code&gt;update&lt;/code&gt; instruction is a tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;, which says that the affected processes are to do a state transformation before loading the new version of the module. This is done by the processes calling the callback function &lt;code&gt;code_change&lt;/code&gt; (see the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in STDLIB). The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to the function:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 指令的第三个元素是元组 &lt;code&gt;{advanced,Extra}&lt;/code&gt; ，它表示受影响的进程将在加载模块的新版本之前进行状态转换。这是通过调用回调函数 &lt;code&gt;code_change&lt;/code&gt; 的进程完成的（请参阅STDLIB中的 &lt;code&gt;gen_server(3)&lt;/code&gt; 手册页）。术语 &lt;code&gt;Extra&lt;/code&gt; （在这种情况下为 &lt;code&gt;[]&lt;/code&gt; ）按原样传递给该函数：</target>
        </trans-unit>
        <trans-unit id="ab1e993eaa153cf69b806d94010676be4ba79b9d" translate="yes" xml:space="preserve">
          <source>The third instruction, &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;, works as follows:</source>
          <target state="translated">第三条指令 &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 的工作方式如下：</target>
        </trans-unit>
        <trans-unit id="0c296204e008ff6b192a1e6549228a85ab543274" translate="yes" xml:space="preserve">
          <source>The third is the maximum value since the emulator was started.</source>
          <target state="translated">第三个是仿真器启动后的最大值。</target>
        </trans-unit>
        <trans-unit id="53980cbfc9a30778a14bd5b2052c49935bce4336" translate="yes" xml:space="preserve">
          <source>The threads and states are subject to change without any prior notice.</source>
          <target state="translated">线路和状态如有变更,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="110848e2d40c2615a11026b769bd376100abd56b" translate="yes" xml:space="preserve">
          <source>The threads for long running I/O work. See &lt;code&gt;erl +SDio&lt;/code&gt; for more details.</source>
          <target state="translated">长时间运行的I / O工作的线程。有关更多详细信息，请参见 &lt;code&gt;erl +SDio&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86c3f72d097c7761a31ae09180cc6b2d4d48d019" translate="yes" xml:space="preserve">
          <source>The threads for long running cpu intensive work. See &lt;code&gt;erl +SDcpu&lt;/code&gt; for more details.</source>
          <target state="translated">长时间运行cpu的线程需要大量工作。有关更多详细信息，请参见 &lt;code&gt;erl +SDcpu&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aece34de50ec637e00271fb64aadf70ca0063d4f" translate="yes" xml:space="preserve">
          <source>The three Erlang (&lt;code&gt;.erl&lt;/code&gt;) files in the messenger example are individually compiled into object code file (&lt;code&gt;.beam&lt;/code&gt;). The Erlang system loads and links these files into the system when they are referred to during execution of the code. In this case, they are simply put in our current working directory (that is, the place you have done &quot;cd&quot; to). There are ways of putting the &lt;code&gt;.beam&lt;/code&gt; files in other directories.</source>
          <target state="translated">Messenger示例中的三个Erlang（ &lt;code&gt;.erl&lt;/code&gt; ）文件分别编译为目标代码文件（ &lt;code&gt;.beam&lt;/code&gt; ）。当在代码执行期间引用这些文件时，Erlang系统将这些文件加载​​并链接到系统中。在这种情况下，它们只是放在我们当前的工作目录中（即您完成&amp;ldquo; cd&amp;rdquo;操作的位置）。有几种方法可以将 &lt;code&gt;.beam&lt;/code&gt; 文件放在其他目录中。</target>
        </trans-unit>
        <trans-unit id="3179e67fe382f9002d115e1d41e6ed750c972cbf" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">阈值,占系统内存的百分比,指在设置相应的报警之前可以分配多少系统内存。默认值为0.80(80%)。</target>
        </trans-unit>
        <trans-unit id="abb964e16a15aea3574dff337699e7babb0b88a4" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set. The default is 0.05 (5%).</source>
          <target state="translated">在设置相应的报警之前,一个Erlang进程可以分配多少系统内存的阈值,占系统内存的百分比。默认值是0.05(5%)。</target>
        </trans-unit>
        <trans-unit id="e98007a7e215201117e788dbb3276465ac6d78e0" translate="yes" xml:space="preserve">
          <source>The threshold, as percentage of total disk space, for how much disk can be utilized before the &lt;code&gt;disk_almost_full&lt;/code&gt; alarm is set. The default is 0.80 (80%).</source>
          <target state="translated">在设置 &lt;code&gt;disk_almost_full&lt;/code&gt; 警报之前，可以使用多少磁盘的阈值（占总磁盘空间的百分比）。默认值为0.80（80％）。</target>
        </trans-unit>
        <trans-unit id="feab1aae2bdfc2e74927bee2d91bb36426d8246c" translate="yes" xml:space="preserve">
          <source>The time for calculating the length of a list is proportional to the length of the list, as opposed to &lt;code&gt;tuple_size/1&lt;/code&gt;, &lt;code&gt;byte_size/1&lt;/code&gt;, and &lt;code&gt;bit_size/1&lt;/code&gt;, which all execute in constant time.</source>
          <target state="translated">计算列表长度的时间与列表的长度成正比，与 &lt;code&gt;tuple_size/1&lt;/code&gt; ， &lt;code&gt;byte_size/1&lt;/code&gt; 和 &lt;code&gt;bit_size/1&lt;/code&gt; 相反，它们都在恒定的时间内执行。</target>
        </trans-unit>
        <trans-unit id="9fd990e3b9e2b09e602b014e1bf744386f4c5083" translate="yes" xml:space="preserve">
          <source>The time for file operations in the linked in driver distributes itself as 1 % for open, 11 % for write and 87 % for close. All data is probably buffered in the operating system until the close.</source>
          <target state="translated">link in驱动中文件操作的时间分布为:打开1%,写入11%,关闭87%。所有的数据可能都在操作系统中缓冲,直到关闭。</target>
        </trans-unit>
        <trans-unit id="9a190b1ab4466c628fefcec59c8cb2184c9a131f" translate="yes" xml:space="preserve">
          <source>The time functions &lt;code&gt;local_time/0&lt;/code&gt; and &lt;code&gt;universal_time/0&lt;/code&gt; in this module both return date and time. The is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs &lt;code&gt;date/0&lt;/code&gt; and &lt;code&gt;time/0&lt;/code&gt;, and their use is strongly discouraged if a reliable date/time stamp is required.</source>
          <target state="translated">该模块中的时间函数 &lt;code&gt;local_time/0&lt;/code&gt; 和 &lt;code&gt;universal_time/0&lt;/code&gt; 都返回日期和时间。这是因为日期和时间的单独功能可能导致日期/时间组合错开24小时。如果其中一个功能在午夜之前调用，而另一个功能在午夜之后调用，则会发生这种情况。此问题也适用于Erlang BIF &lt;code&gt;date/0&lt;/code&gt; 和 &lt;code&gt;time/0&lt;/code&gt; ，如果需要可靠的日期/时间戳，强烈建议不要使用它们。</target>
        </trans-unit>
        <trans-unit id="69208e9c32fc9f7e1bfe894a2034c5bf8bcec375" translate="yes" xml:space="preserve">
          <source>The time in seconds the web server waits between each chunk of data from the script. If the CGI script does not deliver any data before the timeout, the connection to the client is closed. Default is &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">Web服务器在脚本的每个数据块之间等待的时间（以秒为单位）。如果CGI脚本在超时之前未传送任何数据，则将关闭与客户端的连接。默认值为 &lt;code&gt;15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83fde948bd1a784c99ccd55cd88c7ae69cfaa7fb" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic disk space check. The default is 30 minutes.</source>
          <target state="translated">定期检查磁盘空间的时间间隔,以分钟为单位。默认为30分钟。</target>
        </trans-unit>
        <trans-unit id="f648e7e2912e2b6d60327d6a0acc64bb170e218b" translate="yes" xml:space="preserve">
          <source>The time interval, in minutes, for the periodic memory check. The default is one minute.</source>
          <target state="translated">定期检查内存的时间间隔,以分钟为单位。默认为一分钟。</target>
        </trans-unit>
        <trans-unit id="6dc4a14921776a9a6e79ea069562a5ef16a83ecc" translate="yes" xml:space="preserve">
          <source>The time is specified as a fraction, in percent, of a full time-slice that a port is allowed to execute before it is to surrender the CPU to other runnable ports or processes. Valid range is &lt;code&gt;[1, 100]&lt;/code&gt;. The scheduling time-slice is not an exact entity, but can usually be approximated to about 1 millisecond.</source>
          <target state="translated">将时间指定为允许端口在将CPU交还给其他可运行端口或进程之前执行的完整时间片段的百分比（以百分比为单位）。有效范围是 &lt;code&gt;[1, 100]&lt;/code&gt; 。调度时间片不是确切的实体，但是通常可以大约为1毫秒。</target>
        </trans-unit>
        <trans-unit id="68613cc82c2c14fbfd127a4e01a552399427b53f" translate="yes" xml:space="preserve">
          <source>The time of the least number of consecutive &lt;code&gt;MTTI&lt;/code&gt;s to cover &lt;code&gt;TransitionPeriod&lt;/code&gt; seconds following the call to &lt;code&gt;set_net_ticktime/2&lt;/code&gt; (that is, ((&lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; milliseconds).</source>
          <target state="translated">调用 &lt;code&gt;set_net_ticktime/2&lt;/code&gt; 之后，覆盖 &lt;code&gt;TransitionPeriod&lt;/code&gt; 秒的最少连续 &lt;code&gt;MTTI&lt;/code&gt; 的时间（即（（（ &lt;code&gt;TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI&lt;/code&gt; 毫秒）。</target>
        </trans-unit>
        <trans-unit id="6e174adfced39af8e0e284588941d85b0bfefb31" translate="yes" xml:space="preserve">
          <source>The time offset can change at any time without limitations. That is, Erlang system time can perform time warps both forwards and backwards at &lt;strong&gt;any&lt;/strong&gt; time. As we align Erlang system time with OS system time by changing the time offset, we can enable a time correction that tries to adjust the frequency of the Erlang monotonic clock to be as correct as possible. This makes time measurements using Erlang monotonic time more accurate and precise.</source>
          <target state="translated">时间偏移量可以随时更改，没有限制。也就是说，Erlang系统时间可以在&lt;strong&gt;任何&lt;/strong&gt;时候向前和向后执行时间扭曲。通过更改时间偏移将Erlang系统时间与OS系统时间对齐时，我们可以启用时间校正，尝试将Erlang单调时钟的频率调整为尽可能正确。这使得使用Erlang单调时间的时间测量更加准确和精确。</target>
        </trans-unit>
        <trans-unit id="d2d5aace605853ec8fe0539020e963801c0f8996" translate="yes" xml:space="preserve">
          <source>The time offset is determined at runtime system start and does not change later. This is the default behavior, but not because it is the best mode (which it is not). It is default &lt;strong&gt;only&lt;/strong&gt; because this is how the runtime system behaved until ERTS 7.0. Ensure that your Erlang code that can execute during a time warp is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; before enabling other modes.</source>
          <target state="translated">时间偏移是在运行系统启动时确定的，以后不会更改。这是默认行为，但不是因为它是最佳模式（不是）。这是默认&lt;strong&gt;只&lt;/strong&gt;因为这是运行系统表现如何，直到ERTS 7.0。在启用其他模式之前，请确保可以在时间扭曲期间执行的Erlang代码是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a05290e0120252e64339359ca4738dbe7f2ecf8" translate="yes" xml:space="preserve">
          <source>The time offset is final. This either because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, or because the time offset have been finalized when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">时间偏移是最终的。这是因为 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; ，或者是因为在使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 时已确定了时间偏移。</target>
        </trans-unit>
        <trans-unit id="75246e26b9078dfc246576a8981834ffa66ca0f1" translate="yes" xml:space="preserve">
          <source>The time offset is preliminary, and will be changed and finalized later. The preliminary time offset is used during the preliminary phase of the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">时间偏移是初步的，将在以后更改和确定。初步时间偏移用于 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 的初步阶段。</target>
        </trans-unit>
        <trans-unit id="a542b4a11973e3e77034a41b121ba9735a608c2b" translate="yes" xml:space="preserve">
          <source>The time offset is volatile. That is, it can change at any time. This is because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">时间偏移是易失的。也就是说，它可以随时更改。这是因为使用了 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe4b21df9a3383d5eec3e415625b8f307797fe41" translate="yes" xml:space="preserve">
          <source>The time offset may or may not change during operation depending on the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used.</source>
          <target state="translated">时间偏移量可能会或可能不会在操作期间更改，具体取决于所使用的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5747e4d4272d9517822c11117ba6680478fe811f" translate="yes" xml:space="preserve">
          <source>The time offset, either a string or an integer, to be used when formatting the timestamp.</source>
          <target state="translated">时间偏移,可以是字符串或整数,在格式化时间戳时使用。</target>
        </trans-unit>
        <trans-unit id="01e05d873bba0338059375e3eba7a363e13a9238" translate="yes" xml:space="preserve">
          <source>The time to start the Erlang node, in seconds. Defaults to 3 seconds. If the node is not pingable within this time, the result &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">启动Erlang节点的时间，以秒为单位。默认为3秒。如果该节点在此时间内不可ping &lt;code&gt;{error, boot_timeout, NodeName}&lt;/code&gt; 则返回结果{error，boot_timeout，NodeName}。</target>
        </trans-unit>
        <trans-unit id="c2b0569acb74ea5c562c3c099098eac517911fa3" translate="yes" xml:space="preserve">
          <source>The time to wait for the node until it calls the internal callback function informing master about a successful startup. Defaults to 1 second. In case of a timed out message, the result &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">等待节点直到它调用内部回调函数通知主设备成功启动的时间。默认为1秒。如果消息超时 &lt;code&gt;{error, init_timeout, NodeName}&lt;/code&gt; 则返回结果{error，init_timeout，NodeName}。</target>
        </trans-unit>
        <trans-unit id="6b1ed69df7a8c67ce8c0a0d212b6e1372ea7bd21" translate="yes" xml:space="preserve">
          <source>The time to wait until the node stops to run &lt;code&gt;StartupFunctions&lt;/code&gt;. Defaults to 1 second. If this time-out occurs, the result &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; is returned.</source>
          <target state="translated">等待节点停止运行 &lt;code&gt;StartupFunctions&lt;/code&gt; 的时间。默认为1秒。如果发生此超时，将返回结果 &lt;code&gt;{error, startup_timeout, NodeName}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa9c4628387e5d0232143d2f5ae73813eebb7d09" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中返回的时间类型取决于在 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 设置的时间类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="025c3e1a1b5155e5b0e031d4135009cedb0e5183" translate="yes" xml:space="preserve">
          <source>The time type set in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; depends on the time type set in &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; as follows:</source>
          <target state="translated">在 &lt;code&gt;atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;ctime&lt;/code&gt; 中设置的时间类型取决于在 &lt;code&gt;Opts :: {time, Type}&lt;/code&gt; 设置的时间类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="3e4f9d85f1388b8c9748c712e4d020e326e2e9ee" translate="yes" xml:space="preserve">
          <source>The time unit is the same as returned by &lt;code&gt;os:perf_counter/0&lt;/code&gt;. So, to convert it to milliseconds, you can do something like this:</source>
          <target state="translated">时间单位与 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 返回的时间单位相同。因此，要将其转换为毫秒，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="12219f11b7eb31ef4590154a3caff4c692e2fc9c" translate="yes" xml:space="preserve">
          <source>The time unit of &lt;code&gt;Time&lt;/code&gt;. The default is &lt;code&gt;second&lt;/code&gt;. If some other unit is given (&lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, or &lt;code&gt;nanosecond&lt;/code&gt;), the formatted string includes a fraction of a second.</source>
          <target state="translated">的时间单位 &lt;code&gt;Time&lt;/code&gt; 。默认值为 &lt;code&gt;second&lt;/code&gt; 。如果给定其他单位（ &lt;code&gt;millisecond&lt;/code&gt; ， &lt;code&gt;microsecond&lt;/code&gt; 或 &lt;code&gt;nanosecond&lt;/code&gt; ），则格式化的字符串包括一秒的分数。</target>
        </trans-unit>
        <trans-unit id="1430c59740c5ce36e77e21d493e646f47e818719" translate="yes" xml:space="preserve">
          <source>The time unit of the return value. The default is &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">返回值的时间单位。默认值为 &lt;code&gt;second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6064d2834424e42c0c9064187c8cad80d5a77e73" translate="yes" xml:space="preserve">
          <source>The time warp made when finalizing the time offset can only be done forwards without encountering problems. This implies that the user must ensure that OS system time is set to a time earlier or equal to actual POSIX time before starting the Erlang runtime system.</source>
          <target state="translated">在最终确定时间偏移时所做的时间翘曲只能向前进行,而不会遇到问题。这意味着用户在启动Erlang运行系统之前,必须确保操作系统系统时间被设置为早于或等于实际POSIX时间。</target>
        </trans-unit>
        <trans-unit id="d4fbb252f5f519e910d0858637bda3afb5fe08b3" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS.</source>
          <target state="translated">时区和夏令时校正取决于底层操作系统。</target>
        </trans-unit>
        <trans-unit id="46decb898c0ad74d50df552bed6180379c34d8f6" translate="yes" xml:space="preserve">
          <source>The time zone and Daylight Saving Time correction depend on the underlying OS. Example:</source>
          <target state="translated">时区和夏令时校正取决于基础操作系统。例如</target>
        </trans-unit>
        <trans-unit id="c1ff4d23080563c54d4def9701098918387b1c59" translate="yes" xml:space="preserve">
          <source>The time-out (&lt;code&gt;after 5000&lt;/code&gt;) is started when &lt;code&gt;receive&lt;/code&gt; is entered. The time-out is canceled if &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is received. If &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; is not received, the actions following the time-out are done after 5000 milliseconds. &lt;code&gt;after&lt;/code&gt; must be last in the &lt;code&gt;receive&lt;/code&gt;, that is, preceded by all other message reception specifications in the &lt;code&gt;receive&lt;/code&gt;. It is also possible to call a function that returned an integer for the time-out:</source>
          <target state="translated">输入 &lt;code&gt;receive&lt;/code&gt; 时开始超时（ &lt;code&gt;after 5000&lt;/code&gt; ）。如果收到 &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; ,则超时将被取消。如果未收到 &lt;code&gt;{ping,Ping_PID}&lt;/code&gt; ，则超时后的操作将在5000毫秒后执行。 &lt;code&gt;after&lt;/code&gt; 必须排在最后的 &lt;code&gt;receive&lt;/code&gt; ，也就是说，所有其他消息接待规格之前在 &lt;code&gt;receive&lt;/code&gt; 。也可以调用返回超时整数的函数：</target>
        </trans-unit>
        <trans-unit id="a74551537c5a43771b2d27e385232c7f56d26101" translate="yes" xml:space="preserve">
          <source>The time-out is set in:</source>
          <target state="translated">超时的设置在。</target>
        </trans-unit>
        <trans-unit id="b43eb0e0eaef9c040d6d8272e488450d475f41d0" translate="yes" xml:space="preserve">
          <source>The time-out values that can be returned have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">可以返回的超时值具有与 &lt;code&gt;gen_server&lt;/code&gt; 相同的语义。如果发生超时， &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 称为 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23098336c20c6b0d05b70cb1a61cba6bfe7c35df" translate="yes" xml:space="preserve">
          <source>The time-outs are applied as follows:</source>
          <target state="translated">超时工作按以下方式进行:</target>
        </trans-unit>
        <trans-unit id="a92d7be64c5181c10f9b9787e69692d9bd980a7b" translate="yes" xml:space="preserve">
          <source>The time-outs are not exact, but are &lt;strong&gt;at least&lt;/strong&gt; as long as requested.</source>
          <target state="translated">超时时间不精确，但&lt;strong&gt;至少要&lt;/strong&gt;长一些。</target>
        </trans-unit>
        <trans-unit id="a5997cb057fe175060411534263631407871803d" translate="yes" xml:space="preserve">
          <source>The timeout time can have the values: &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">超时时间的值可以是： &lt;code&gt;plain | integer() &amp;gt;= 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e975fa79f9358d6848c00dddda11ae68d145e5e9" translate="yes" xml:space="preserve">
          <source>The timeout time is in milliseconds. A value of 0 (zero) means that the proxy process will exit directly after the reply has been delivered.</source>
          <target state="translated">超时时间的单位是毫秒。值为0(0)时,表示代理进程将在回复发送后直接退出。</target>
        </trans-unit>
        <trans-unit id="6942299da0c7028fdc30f81f96ae8da61dd1bd71" translate="yes" xml:space="preserve">
          <source>The timeout value in a &lt;code&gt;receive..after&lt;/code&gt; expression is evaluated to something else than an integer or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;receive..after&lt;/code&gt; 表达式中的超时值将计算为除整数或 &lt;code&gt;infinity&lt;/code&gt; 之外的其他值。</target>
        </trans-unit>
        <trans-unit id="a58b363626052caadeef7377d180027acba06268" translate="yes" xml:space="preserve">
          <source>The timeout values that can be returned by the callback functions have the same semantics as in a &lt;code&gt;gen_server&lt;/code&gt;. If the time-out occurs, &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; is called as &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt;.</source>
          <target state="translated">回调函数可以返回的超时值具有与 &lt;code&gt;gen_server&lt;/code&gt; 相同的语义。如果发生超时， &lt;code&gt;&lt;a href=&quot;#Module:handle_msg-2&quot;&gt;handle_msg/2&lt;/a&gt;&lt;/code&gt; 称为 &lt;code&gt;handle_msg(timeout, State)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="746fc091a3bbb9211a083b1f5ae06872c6f4470d" translate="yes" xml:space="preserve">
          <source>The timer associated with &lt;code&gt;Timeout&lt;/code&gt; only supervises IP resolution of &lt;code&gt;Addr&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Timeout&lt;/code&gt; 相关的计时器仅监督 &lt;code&gt;Addr&lt;/code&gt; 的 IP分辨率。</target>
        </trans-unit>
        <trans-unit id="09b399a5a75126e8cb452f47bf0a1a5174ce3ebb" translate="yes" xml:space="preserve">
          <source>The timer created using &lt;code&gt;dist_util:start_timer/1&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;dist_util:start_timer/1&lt;/code&gt; 创建的计时器。</target>
        </trans-unit>
        <trans-unit id="4e1cbb1460f78d41a3f7701791a14cffbd170fdb" translate="yes" xml:space="preserve">
          <source>The timer for a state time-out is automatically cancelled when the state machine changes states. You can restart a state time-out by setting it to a new time, which cancels the running timer and starts a new. This implies that you can cancel a state time-out by restarting it with time &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">当状态机更改状态时，将自动取消状态超时计时器。您可以通过将状态超时设置为新的时间来重新启动它，这会取消正在运行的计时器并重新开始。这意味着您可以通过以time &lt;code&gt;infinity&lt;/code&gt; 重启状态来取消状态超时。</target>
        </trans-unit>
        <trans-unit id="64045eba1ed6044b87952089dc11046d257dec70" translate="yes" xml:space="preserve">
          <source>The timer is cancelled when a reply is received.</source>
          <target state="translated">当收到回复时,定时器被取消。</target>
        </trans-unit>
        <trans-unit id="3e5d9243b241f9d1ac98de61c38151d7c0aed4f0" translate="yes" xml:space="preserve">
          <source>The timer is started with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;, so any trace patterns must be set up in advance. &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; always sets up all patterns before invoking &lt;code&gt;ttb:p/2&lt;/code&gt;.</source>
          <target state="translated">计时器以 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 开头，因此必须预先设置任何跟踪模式。 &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 始终在调用 &lt;code&gt;ttb:p/2&lt;/code&gt; 之前设置所有模式。</target>
        </trans-unit>
        <trans-unit id="2045d1e31e58946973b89bfa19e30a90c88aef6e" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in a critical path, and can do other things while waiting for the result of this operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process is blocked until the operation has been performed.</source>
          <target state="translated">可以将管理计时器的计时器服务与另一个调度程序放在同一位置，而不是在其上执行调用过程的调度程序。如果是这样，与计时器服务的通信要比其位于本地的时间长得多。如果调用过程处于关键路径中，并且在等待此操作的结果时可以执行其他操作，则需要使用选项 &lt;code&gt;{async, true}&lt;/code&gt; 。如果使用选项 &lt;code&gt;{async, false}&lt;/code&gt; ，则调用过程将被阻塞，直到执行该操作为止。</target>
        </trans-unit>
        <trans-unit id="ea274128cf86d631de77306142f2359eec7a59d8" translate="yes" xml:space="preserve">
          <source>The timer service that manages the timer can be co-located with another scheduler than the scheduler that the calling process is executing on. If so, communication with the timer service takes much longer time than if it is located locally. If the calling process is in critical path, and can do other things while waiting for the result of this operation, or is not interested in the result of the operation, you want to use option &lt;code&gt;{async, true}&lt;/code&gt;. If using option &lt;code&gt;{async, false}&lt;/code&gt;, the calling process blocks until the operation has been performed.</source>
          <target state="translated">可以将管理计时器的计时器服务与另一个调度程序放在同一位置，而不是在其上执行调用过程的调度程序。如果是这样，与计时器服务的通信要比其位于本地的时间长得多。如果调用进程处于关键路径中，并且可以在等待此操作的结果时执行其他操作，或者对该操作的结果不感兴趣，则可以使用选项 &lt;code&gt;{async, true}&lt;/code&gt; 。如果使用选项 &lt;code&gt;{async, false}&lt;/code&gt; ，则调用过程将阻塞，直到执行该操作为止。</target>
        </trans-unit>
        <trans-unit id="01c4aedfbe422c954419af25bc2a44ca29efec29" translate="yes" xml:space="preserve">
          <source>The title bar shows the name of the currently loaded crashdump.</source>
          <target state="translated">标题栏显示的是当前加载的crashdump的名称。</target>
        </trans-unit>
        <trans-unit id="ab7219cf5f8f02500259c90d49cef81093f63f21" translate="yes" xml:space="preserve">
          <source>The token's text.</source>
          <target state="translated">令牌的文字。</target>
        </trans-unit>
        <trans-unit id="6e8012793487b53f45a7c5a13441809363cbd8df" translate="yes" xml:space="preserve">
          <source>The tokenization succeeded.</source>
          <target state="translated">标记化成功了。</target>
        </trans-unit>
        <trans-unit id="e263b7ae6b2b75806ba8e04c9ad5e6232730c3db" translate="yes" xml:space="preserve">
          <source>The tokenizer &lt;code&gt;Function&lt;/code&gt; is either a fun or a tuple &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt;. The call &lt;code&gt;apply(Function, Args)&lt;/code&gt; or &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; is executed whenever a new token is needed. This, for example, makes it possible to parse from a file, token by token.</source>
          <target state="translated">标记器 &lt;code&gt;Function&lt;/code&gt; 可以是一个乐趣，也可以是一个元组 &lt;code&gt;{Mod, Tokenizer}&lt;/code&gt; 。每当需要新令牌时，都会执行调用 &lt;code&gt;apply(Function, Args)&lt;/code&gt; 或 &lt;code&gt;apply({Mod, Tokenizer}, Args)&lt;/code&gt; 。例如，这使得从文件中逐个令牌解析成为可能。</target>
        </trans-unit>
        <trans-unit id="eecca73e115331e619af23f47c2166b9740b978b" translate="yes" xml:space="preserve">
          <source>The tokenizer used above has to be implemented so as to return one of the following:</source>
          <target state="translated">上面使用的tokenizer必须被实现,以便返回以下之一。</target>
        </trans-unit>
        <trans-unit id="9fe8d55f2a73cae0cc9b243cca2beb4f78cc27a7" translate="yes" xml:space="preserve">
          <source>The tool contain four things:</source>
          <target state="translated">该工具包含四样东西。</target>
        </trans-unit>
        <trans-unit id="fdec03acdbb06629e6819b263973cb293a015233" translate="yes" xml:space="preserve">
          <source>The tool is a textual based tool that asks some questions and generates &lt;code&gt;sys.config&lt;/code&gt; and &lt;code&gt;*.conf&lt;/code&gt; files.</source>
          <target state="translated">该工具是基于文本的工具，它会询问一些问题并生成 &lt;code&gt;sys.config&lt;/code&gt; 和 &lt;code&gt;*.conf&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2cceab8c0f08bcd5eba3c48a52f4f32cc7451571" translate="yes" xml:space="preserve">
          <source>The tool makes it easy to dynamically extend an SNMP agent in run-time. MIBs can be loaded and unloaded at any time. It is also easy to change the implementation of an MIB in run-time, without having to recompile the MIB. The MIB implementation is clearly separated from the agent.</source>
          <target state="translated">该工具可以很容易地在运行时动态扩展SNMP代理。MIB可以在任何时候被加载和卸载。在运行时也很容易改变MIB的实现,而无需重新编译MIB。MIB的实现与代理明确分离。</target>
        </trans-unit>
        <trans-unit id="c57eb5d97f3d1b93c6dc787ae451b8dff86780d1" translate="yes" xml:space="preserve">
          <source>The tool requires Erlang release 4.7 or later.</source>
          <target state="translated">该工具需要 Erlang 4.7 或更高版本。</target>
        </trans-unit>
        <trans-unit id="4074bd4d79edc126504be2941fab21e73161d7fa" translate="yes" xml:space="preserve">
          <source>The tool uses an installed Erlang/OTP system as input. &lt;code&gt;root_dir&lt;/code&gt; is the root directory of the analysed system and it defaults to the system executing Reltool. Applications may also be located outside &lt;code&gt;root_dir&lt;/code&gt;. &lt;code&gt;lib_dirs&lt;/code&gt; defines library directories where additional applications may reside and it defaults to the directories listed by the operating system environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. See the module &lt;code&gt;code&lt;/code&gt; for more info.</source>
          <target state="translated">该工具使用已安装的Erlang / OTP系统作为输入。 &lt;code&gt;root_dir&lt;/code&gt; 是被分析系统的根目录，默认为执行Reltool的系统。应用程序也可能位于 &lt;code&gt;root_dir&lt;/code&gt; 之外。 &lt;code&gt;lib_dirs&lt;/code&gt; 定义了其他应用程序可能驻留的库目录，并且默认为操作系统环境变量 &lt;code&gt;ERL_LIBS&lt;/code&gt; 列出的目录。有关更多信息，请参见模块 &lt;code&gt;code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ed25be45c8a83c834fb6f6c553fb74ad08b92fe" translate="yes" xml:space="preserve">
          <source>The tool(s) are located in the example/meas directory.</source>
          <target state="translated">该工具位于example/meas目录中。</target>
        </trans-unit>
        <trans-unit id="32614a53fcfaa9dead51313db65f2664ea439d19" translate="yes" xml:space="preserve">
          <source>The toolkit allows different kinds of sub-agents at the same time. Accordingly, different MIBs can have different &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt; mechanisms.</source>
          <target state="translated">该工具包允许同时使用不同种类的子代理。因此，不同的MIB可以具有不同的 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 机制。</target>
        </trans-unit>
        <trans-unit id="13a0a8edd61587bef6f837bb6b651cc3f7feb62a" translate="yes" xml:space="preserve">
          <source>The toolkit provides the following:</source>
          <target state="translated">该工具包提供了以下内容:</target>
        </trans-unit>
        <trans-unit id="faaee45e85eb745fc476496ed2d34dbbfaf2f6f6" translate="yes" xml:space="preserve">
          <source>The toolkit supports the use of different types of sub-agents, but not the construction of sub-agents.</source>
          <target state="translated">该工具包支持使用不同类型的子代理,但不支持子代理的构建。</target>
        </trans-unit>
        <trans-unit id="5eca4fd89becaf65e9a29ecebed7de54b42d7b29" translate="yes" xml:space="preserve">
          <source>The tools are further described in &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该工具进一步描述 &lt;code&gt;&lt;a href=&quot;#profiling_tools&quot;&gt;Tools&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ae2ecc76d77c89a869d00df8f45f0ef79d0325" translate="yes" xml:space="preserve">
          <source>The top directories &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are treated differently from other files. All other files are by default copied to the target system. The &lt;code&gt;releases&lt;/code&gt; directory contains generated &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, and &lt;code&gt;boot&lt;/code&gt; files. The &lt;code&gt;lib&lt;/code&gt; directory contains the applications. Which applications are included and if they should be customized (archived, stripped from debug info etc.) is specified with various configuration parameters. The files in the &lt;code&gt;bin&lt;/code&gt; directory are copied from the &lt;code&gt;erts-vsn/bin&lt;/code&gt; directory, but only those files that were originally included in the &lt;code&gt;bin&lt;/code&gt; directory of the source system.</source>
          <target state="translated">顶级目录 &lt;code&gt;bin&lt;/code&gt; ， &lt;code&gt;releases&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 与其他文件不同。默认情况下，所有其他文件都复制到目标系统。该 &lt;code&gt;releases&lt;/code&gt; 目录包含生成的 &lt;code&gt;rel&lt;/code&gt; ， &lt;code&gt;script&lt;/code&gt; 和 &lt;code&gt;boot&lt;/code&gt; 文件。该 &lt;code&gt;lib&lt;/code&gt; 目录中包含的应用程序。使用各种配置参数指定了包括哪些应用程序以及是否应对其进行定制（已归档，已从调试信息中删除等）。 &lt;code&gt;bin&lt;/code&gt; 目录中的文件是从 &lt;code&gt;erts-vsn/bin&lt;/code&gt; bin目录中复制的，但是只有那些最初包含在 &lt;code&gt;bin&lt;/code&gt; 中的文件 源系统的目录。</target>
        </trans-unit>
        <trans-unit id="ccc5aad2efbe05e6d9003238cc37f069c3a6a12a" translate="yes" xml:space="preserve">
          <source>The top-level OTP MIB is called &lt;code&gt;OTP-REG&lt;/code&gt; and it is included in the SASL application. All other OTP MIBs import some objects from this MIB.</source>
          <target state="translated">顶级OTP MIB称为 &lt;code&gt;OTP-REG&lt;/code&gt; ，它包含在SASL应用程序中。所有其他OTP MIB都从该MIB导入一些对象。</target>
        </trans-unit>
        <trans-unit id="84531a2a9183b1d9855e02a467fa0f45db6199b5" translate="yes" xml:space="preserve">
          <source>The total amount of memory available to the Erlang emulator, allocated and free. May or may not be equal to the amount of memory configured in the system.</source>
          <target state="translated">Erlang模拟器可用的内存总量,分配的和空闲的。可能等于也可能不等于系统中配置的内存量。</target>
        </trans-unit>
        <trans-unit id="21349daddbe9f78057ffe41633d03aeff5b4dfff" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for ETS tables. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为ETS表分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="95625ce6b2bc15c6368f74e2c9f00e33024f644c" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for Erlang code. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为Erlang代码分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="92570f02d253003fe52d361898384d0a6cc00fde" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for atoms. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前为原子分配的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="cc60a6cee6312a43f557d00bfccf3deeac83faed" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for binaries. This memory is part of the memory presented as &lt;code&gt;system&lt;/code&gt; memory.</source>
          <target state="translated">当前分配给二进制文件的内存总量。该内存是作为 &lt;code&gt;system&lt;/code&gt; 内存提供的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="14e4c7529d5fddaff839bbeef6fdabaf59af1c55" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the Erlang processes.</source>
          <target state="translated">当前为Erlang进程分配的内存总量。</target>
        </trans-unit>
        <trans-unit id="a35fa37b02db12b38c932bf76bd09f88b68c5aa2" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated for the emulator that is not directly related to any Erlang process. Memory presented as &lt;code&gt;processes&lt;/code&gt; is not included in this memory. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of what memory is part of this type.</source>
          <target state="translated">当前为模拟器分配的与任何Erlang进程没有直接关系的内存总量。作为 &lt;code&gt;processes&lt;/code&gt; 显示的内存不包含在此内存中。 &lt;code&gt;instrument(3)&lt;/code&gt; 可以用来更详细地分类该类型的内存。</target>
        </trans-unit>
        <trans-unit id="215b071b6a42f1da89b3697d1f496f661d6aa206" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently allocated. This is the same as the sum of the memory size for &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">当前分配的内存总量。这与 &lt;code&gt;processes&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; 的内存大小总和相同。</target>
        </trans-unit>
        <trans-unit id="a938e56ba158faaa85844dc2539f443bb5a124d9" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used by the Erlang processes. This is part of the memory presented as &lt;code&gt;processes&lt;/code&gt; memory.</source>
          <target state="translated">Erlang进程当前使用的内存总量。这是作为 &lt;code&gt;processes&lt;/code&gt; 内存呈现的一部分内存。</target>
        </trans-unit>
        <trans-unit id="cdab624b2930e224876509f0c625e5e845b4ff1f" translate="yes" xml:space="preserve">
          <source>The total amount of memory currently used for atoms. This memory is part of the memory presented as &lt;code&gt;atom&lt;/code&gt; memory.</source>
          <target state="translated">当前用于原子的内存总量。此内存是表示为 &lt;code&gt;atom&lt;/code&gt; 内存的内存的一部分。</target>
        </trans-unit>
        <trans-unit id="a4493719e0d656453847edcf986d8ecdd8e5d76e" translate="yes" xml:space="preserve">
          <source>The total memory used by this process. This includes call stack, heap, and internal structures. Same as &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此过程使用的总内存。这包括调用堆栈，堆和内部结构。与 &lt;code&gt;&lt;a href=&quot;erlang#process_info-2&quot;&gt;erlang:process_info(Pid,memory)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="87ecdfb27347e35b213d203586b4706d6725a207" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated, equivalent to &lt;code&gt;c:memory(total)&lt;/code&gt;.</source>
          <target state="translated">分配的字节总数，等于 &lt;code&gt;c:memory(total)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4aacb9a69b73478d5cf380558cf1c9d0f0a175d" translate="yes" xml:space="preserve">
          <source>The total number of bytes, including field &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">字节总数，包括字段 &lt;code&gt;Size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ade9bc9096e43152fdc50c7d93977a724953c2a8" translate="yes" xml:space="preserve">
          <source>The total number of items in all wrap log files.</source>
          <target state="translated">所有包装日志文件中的项目总数。</target>
        </trans-unit>
        <trans-unit id="e26f652c13c599e84a51a316ff52e72ae6c6a549" translate="yes" xml:space="preserve">
          <source>The total run-time of all threads in the system. This is what you get if you call &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt;</source>
          <target state="translated">系统中所有线程的总运行时间。如果调用 &lt;code&gt;msacc:stats(total_runtime,Stats).&lt;/code&gt; 这就是您得到的。</target>
        </trans-unit>
        <trans-unit id="1a21c70804496cb28140caf8b69b9295c32be2b1" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual heap in the process before doing a garbage collection.</source>
          <target state="translated">在做垃圾回收之前,进程中允许虚拟堆中的二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="d53cdb49b3477b983e3f0debbb9d2b84b083cc6a" translate="yes" xml:space="preserve">
          <source>The total size of binaries allowed in the virtual old heap in the process before doing a garbage collection.</source>
          <target state="translated">在做垃圾回收之前,进程中允许虚拟旧堆中的二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="ebb9f6115c8a24e5086416d9ee44573eb18624a0" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process heap.</source>
          <target state="translated">从进程堆引用的唯一离堆二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="0b0eb863d44dbd5b8e589949207744e47251159f" translate="yes" xml:space="preserve">
          <source>The total size of unique off-heap binaries referenced from the process old heap.</source>
          <target state="translated">进程旧堆引用的唯一离堆二进制文件的总大小。</target>
        </trans-unit>
        <trans-unit id="32449a2d53f2b352b6abd6b8f47cee02d2cabee9" translate="yes" xml:space="preserve">
          <source>The total space required is the result calculated from the information above, plus 1 more byte for a version identifier.</source>
          <target state="translated">所需的总空间是由上述信息计算出来的结果,再加一个字节作为版本标识符。</target>
        </trans-unit>
        <trans-unit id="bd7a2f2d43f93a16c0153ab5248fa17162eed576" translate="yes" xml:space="preserve">
          <source>The total system memory reported under UNIX is the number of physical pages of memory times the page size, and the available memory is the number of available physical pages times the page size. This is a reasonable measure as swapping should be avoided anyway, but the task of defining total memory and available memory is difficult because of virtual memory and swapping.</source>
          <target state="translated">UNIX下报告的系统总内存是内存的物理页数乘以页数,可用内存是可用物理页数乘以页数。这是一个合理的衡量标准,因为无论如何都应该避免交换,但由于虚拟内存和交换,定义总内存和可用内存的任务是困难的。</target>
        </trans-unit>
        <trans-unit id="933816d7250e3513ec4007a083bc6d450febc23e" translate="yes" xml:space="preserve">
          <source>The trace &lt;code&gt;Events&lt;/code&gt; that are hosted by the &lt;code&gt;Collector&lt;/code&gt; may be stored to file and later be loaded by selecting &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; entries in the &lt;code&gt;Viewers&lt;/code&gt;&lt;code&gt;File&lt;/code&gt; menu or via the &lt;code&gt;et_collector&lt;/code&gt; API.</source>
          <target state="translated">可以将 &lt;code&gt;Collector&lt;/code&gt; 托管的跟踪 &lt;code&gt;Events&lt;/code&gt; 存储到文件中，然后通过在 &lt;code&gt;Viewers&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 菜单中选择 &lt;code&gt;save&lt;/code&gt; 和 &lt;code&gt;load&lt;/code&gt; 条目或通过 &lt;code&gt;et_collector&lt;/code&gt; API来加载。</target>
        </trans-unit>
        <trans-unit id="451f68a1cb2620369fda9754c56e9d6942f0eb42" translate="yes" xml:space="preserve">
          <source>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</source>
          <target state="translated">跟踪控制字是一个32位无符号整数,用于通用的跟踪控制。跟踪控制字可以在跟踪匹配规范和BIF中进行测试和设置。只有在跟踪时才允许调用。</target>
        </trans-unit>
        <trans-unit id="c3874cc2a63c677a77b05397368808af525c7352" translate="yes" xml:space="preserve">
          <source>The trace message is passed as the second argument (&lt;code&gt;Trace&lt;/code&gt;). The possible values of &lt;code&gt;Trace&lt;/code&gt; are the following:</source>
          <target state="translated">跟踪消息作为第二个参数（ &lt;code&gt;Trace&lt;/code&gt; ）传递。 &lt;code&gt;Trace&lt;/code&gt; 的可能值如下：</target>
        </trans-unit>
        <trans-unit id="57fe6c1b5e0592fa7721c5593926798fe2d07b25" translate="yes" xml:space="preserve">
          <source>The trace token contains a component called &lt;code&gt;serial&lt;/code&gt;. It consists of two integers, &lt;code&gt;Previous&lt;/code&gt; and &lt;code&gt;Current&lt;/code&gt;. The purpose is to uniquely identify each traced event within a trace sequence, as well as to order the messages chronologically and in the different branches, if any.</source>
          <target state="translated">跟踪令牌包含一个名为 &lt;code&gt;serial&lt;/code&gt; 的组件。它由两个整数组成，即 &lt;code&gt;Previous&lt;/code&gt; 和 &lt;code&gt;Current&lt;/code&gt; 。目的是唯一地标识跟踪序列中的每个跟踪事件，以及按时间顺序并在不同分支（如果有）中对消息进行排序。</target>
        </trans-unit>
        <trans-unit id="ff16088c10d9e1f1e816f51d73d899ab7bb112e4" translate="yes" xml:space="preserve">
          <source>The trace token of a process is set each time the process matches a message in a receive statement, according to the trace token carried by the received message, empty or not.</source>
          <target state="translated">进程每次在接收语句中匹配消息时,都会根据接收到的消息所携带的跟踪令牌设置进程的跟踪令牌,无论是否为空。</target>
        </trans-unit>
        <trans-unit id="252314f7c0c5e289f2fcfda50b4df8414eb39ecb" translate="yes" xml:space="preserve">
          <source>The trace token with &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt; is then passed along with the message.</source>
          <target state="translated">然后将带有 &lt;code&gt;tprev&lt;/code&gt; 和 &lt;code&gt;tcurr&lt;/code&gt; 的跟踪令牌与消息一起传递。</target>
        </trans-unit>
        <trans-unit id="04a1f28d66267b53ccd9a52f89433c7d9b1ac837" translate="yes" xml:space="preserve">
          <source>The tracing process receives the &lt;strong&gt;trace messages&lt;/strong&gt; described in the following list. &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the traced process in which the traced event has occurred. The third tuple element is the message tag.</source>
          <target state="translated">跟踪过程接收以下列表中描述的&lt;strong&gt;跟踪消息&lt;/strong&gt;。 &lt;code&gt;Pid&lt;/code&gt; 是发生跟踪事件的跟踪进程的进程标识符。第三个元组元素是消息标签。</target>
        </trans-unit>
        <trans-unit id="b59d7a5b365a7b486e7d3f659201ca1fdb7e58e1" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables.</source>
          <target state="translated">事务处理程序确保一个放在事务内部的Fun在对表执行一系列操作时,不会干扰其他事务中嵌入的操作。</target>
        </trans-unit>
        <trans-unit id="70062fd2b1013f2420ee7dc801bcf2c7a5b9ebce" translate="yes" xml:space="preserve">
          <source>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node.</source>
          <target state="translated">事务处理程序确保事务中的所有操作在所有节点上原子性地成功执行,或者事务失败而对任何节点没有永久影响。</target>
        </trans-unit>
        <trans-unit id="b86538eb6924e406301e4e0cc389da5c07adc8a0" translate="yes" xml:space="preserve">
          <source>The transaction sender is a process (one per connection), which handle all transaction sending, if so configured (see &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">事务发送方是一个进程（每个连接一个），它处理所有事务发送（如果已配置）（请参阅 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="713f769ddf2bd92a6f2c46e6fb622ca19e8a8704" translate="yes" xml:space="preserve">
          <source>The transformation is done _after_ the actual decode has been done.</source>
          <target state="translated">转换是在实际解码完成后进行的。</target>
        </trans-unit>
        <trans-unit id="8ea5cd69dbba346421c19ed7295d3d9115fee3a0" translate="yes" xml:space="preserve">
          <source>The transformation module</source>
          <target state="translated">转换模块</target>
        </trans-unit>
        <trans-unit id="d3b5dbd701325ece1005f2efa209fdb4382b77de" translate="yes" xml:space="preserve">
          <source>The transient mode is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">过渡模式几乎没有实际用途，因为当监视树终止时，原因被设置为 &lt;code&gt;shutdown&lt;/code&gt; ，而不是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279a8ee545cd6d6b2240b842b45553a898172100" translate="yes" xml:space="preserve">
          <source>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply is always very straightforward, but the translation from a v2 MIB to a v1 reply is somewhat more complicated. There is one data type in SMIv2, called &lt;code&gt;Counter64&lt;/code&gt;, that an SNMPv1 manager cannot decode correctly. Therefore, an agent may never send a &lt;code&gt;Counter64&lt;/code&gt; object to an SNMPv1 manager. The common practice in these situations is to simple ignore any &lt;code&gt;Counter64&lt;/code&gt; objects, when sending a reply or a trap to an SNMPv1 manager. For example, if an SNMPv1 manager tries to GET an object of type &lt;code&gt;Counter64&lt;/code&gt;, he will get a &lt;code&gt;noSuchName&lt;/code&gt; error, while an SNMPv2 manager would get a correct value.</source>
          <target state="translated">从SMIv1 MIB到SNMPv2c或SNMPv3答复的转换始终非常简单，但是从v2 MIB到v1答复的转换有些复杂。 SMIv2中有一种称为 &lt;code&gt;Counter64&lt;/code&gt; 的数据类型，SNMPv1管理器无法正确解码。因此，代理可能永远不会将 &lt;code&gt;Counter64&lt;/code&gt; 对象发送到SNMPv1管理器。在这些情况下，通常的做法是在向SNMPv1管理器发送答复或陷阱时简单地忽略任何 &lt;code&gt;Counter64&lt;/code&gt; 对象。例如，如果SNMPv1管理器尝试获取 &lt;code&gt;Counter64&lt;/code&gt; 类型的对象，则将获得 &lt;code&gt;noSuchName&lt;/code&gt; 错误，而SNMPv2管理器将获取正确的值。</target>
        </trans-unit>
        <trans-unit id="d1002669f8eb3c39bdb5b7b84f078a3d57742186" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">通过两个&amp;ldquo;伪函数&amp;rdquo; &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 可以访问从funs到匹配规范的转换。</target>
        </trans-unit>
        <trans-unit id="44fa72e8417ca847548609a0551ee3e367444c94" translate="yes" xml:space="preserve">
          <source>The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions.</source>
          <target state="translated">从funs到匹配规格的翻译是在编译时完成的,所以使用这些伪函数不会影响运行时性能。</target>
        </trans-unit>
        <trans-unit id="2cc78b834cad87c9de51c585d4cf589e52c474cd" translate="yes" xml:space="preserve">
          <source>The transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; allows the user to implement their own methods. Ready support is provided for TCP, TCP/TLS, and SCTP, but not DTLS/SCTP.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 记录的传输接口允许用户实现自己的方法。为TCP，TCP / TLS和SCTP提供了就绪支持，但没有提供DTLS / SCTP。</target>
        </trans-unit>
        <trans-unit id="e689615a4328c7bb2be0d06728d745d0225ff3fd" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{hwaddr,_}&lt;/code&gt; is not returned on Solaris, as the hardware address historically belongs to the link layer and only the superuser can read such addresses.</source>
          <target state="translated">在Solaris上不返回元组 &lt;code&gt;{hwaddr,_}&lt;/code&gt; ，因为硬件地址在历史上属于链接层，并且只有超级用户才能读取此类地址。</target>
        </trans-unit>
        <trans-unit id="734c3a9accbed59c68b041ca30504d986c5e8330" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt; in &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">元组 &lt;code&gt;{nodedown_reason, Reason}&lt;/code&gt; 包含在 &lt;code&gt;nodedown&lt;/code&gt; 消息的 &lt;code&gt;InfoList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3f43f11b1eaa009f61e78aef8e72ca0bfe4ae132" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{table, Tab, detailed}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c413d0bf6ec66eace53dd4e7a39e8c1f75c0b563" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{table, Tab, simple}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93c35c8a52aab9fd8efd803c8922b473482b1bda" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">保留元组格式仅是为了向后兼容。首选地图； &lt;code&gt;&lt;a href=&quot;#child_spec&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 查看更多详细信息。</target>
        </trans-unit>
        <trans-unit id="2050463a23b37d880e27e3e31bb499a655c1dd4d" translate="yes" xml:space="preserve">
          <source>The tuple format is kept for backward compatibility only. A map is preferred; see more details &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">保留元组格式仅是为了向后兼容。首选地图； &lt;code&gt;&lt;a href=&quot;#sup_flags&quot;&gt;above&lt;/a&gt;&lt;/code&gt; 查看更多详细信息。</target>
        </trans-unit>
        <trans-unit id="3c70d1de1443033613ebef26319653a179cc6b15" translate="yes" xml:space="preserve">
          <source>The tuple returned from one &lt;code&gt;setelement/3&lt;/code&gt; call must only be used in the subsequent call to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">从一个返回的元组 &lt;code&gt;setelement/3&lt;/code&gt; 呼叫必须只在到随后调用中使用 &lt;code&gt;setelement/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4ff128add1588c52d8394da93cf96f601027206" translate="yes" xml:space="preserve">
          <source>The tuples &lt;code&gt;{addr,Addr}&lt;/code&gt;, &lt;code&gt;{netmask,_}&lt;/code&gt;, and &lt;code&gt;{broadaddr,_}&lt;/code&gt; are repeated in the result list if the interface has multiple addresses. If you come across an interface with multiple &lt;code&gt;{flag,_}&lt;/code&gt; or &lt;code&gt;{hwaddr,_}&lt;/code&gt; tuples, you have a strange interface or possibly a bug in this function. The tuple &lt;code&gt;{flag,_}&lt;/code&gt; is mandatory, all others are optional.</source>
          <target state="translated">如果接口具有多个地址，则在结果列表中重复元组 &lt;code&gt;{addr,Addr}&lt;/code&gt; ， &lt;code&gt;{netmask,_}&lt;/code&gt; 和 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 。如果遇到带有多个 &lt;code&gt;{flag,_}&lt;/code&gt; 或 &lt;code&gt;{hwaddr,_}&lt;/code&gt; 元组的接口，那么您的接口可能很奇怪，或者此功能可能有错误。元组 &lt;code&gt;{flag,_}&lt;/code&gt; 是必需的，所有其他都是可选的。</target>
        </trans-unit>
        <trans-unit id="c792192eae5af5df8655eee98e78f1050f5569af" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; give different possibilities and restrictions, with one common goal: to handle all possible combinations of events and states.</source>
          <target state="translated">两种 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 提供了不同的可能性和限制，其一个共同目标是：处理事件和状态的所有可能组合。</target>
        </trans-unit>
        <trans-unit id="0298b22c480eceedcea59bf7361f3f9da67e49ce" translate="yes" xml:space="preserve">
          <source>The two flag values can be combined with bitwise OR. The resource type name is local to the calling module. Argument &lt;code&gt;module_str&lt;/code&gt; is not (yet) used and must be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;dtor&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if no destructor is needed.</source>
          <target state="translated">这两个标志值可以与按位OR组合。资源类型名称在调用模块本地。参数 &lt;code&gt;module_str&lt;/code&gt; 没有（还）使用，必须为 &lt;code&gt;NULL&lt;/code&gt; 。如果不需要析构函数，则 &lt;code&gt;dtor&lt;/code&gt; 可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12cd5775794850530c69243a0b35a79255f52a0" translate="yes" xml:space="preserve">
          <source>The two following &lt;code&gt;setelement/3&lt;/code&gt; calls modify the tuple in place.</source>
          <target state="translated">接下来的两个 &lt;code&gt;setelement/3&lt;/code&gt; 调用在适当位置修改了元组。</target>
        </trans-unit>
        <trans-unit id="65274f8639b74e1c1addc358f6c4f02af0256408" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;until_newline/3&lt;/code&gt; and &lt;code&gt;until_enough/3&lt;/code&gt; are helpers used together with function &lt;code&gt;get_until/5&lt;/code&gt; to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; (inefficiently):</source>
          <target state="translated">这两个函数 &lt;code&gt;until_newline/3&lt;/code&gt; 和 &lt;code&gt;until_enough/3&lt;/code&gt; 是与函数 &lt;code&gt;get_until/5&lt;/code&gt; 一起使用的 &lt;code&gt;get_chars&lt;/code&gt; ， &lt;code&gt;get_line&lt;/code&gt; （无效地）实现get_chars和get_line：</target>
        </trans-unit>
        <trans-unit id="66b4872540376e34796f1ec9e420e0053c6366ad" translate="yes" xml:space="preserve">
          <source>The two functions for reloading drivers are to be used together with corresponding load functions to support the two different behaviors concerning open ports:</source>
          <target state="translated">这两个用于重装驱动程序的函数要和相应的加载函数一起使用,以支持关于开放端口的两种不同行为。</target>
        </trans-unit>
        <trans-unit id="9c0c4d47161e2b26102273194fa251a585e05de6" translate="yes" xml:space="preserve">
          <source>The two index search functions described here are automatically started when searching tables with &lt;code&gt;qlc&lt;/code&gt; list comprehensions and also when using the low-level &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; functions.</source>
          <target state="translated">当使用 &lt;code&gt;qlc&lt;/code&gt; 列表理解搜索表时以及使用低级 &lt;code&gt;mnesia:[dirty_]match_object&lt;/code&gt; 函数时，将自动启动此处描述的两个索引搜索功能。</target>
        </trans-unit>
        <trans-unit id="246d94548a4e439a2a10c8f1eb4458a0f48f069d" translate="yes" xml:space="preserve">
          <source>The two main interfaces for running tests with &lt;code&gt;Common Test&lt;/code&gt; are an executable program named &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; and the Erlang module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_run&lt;/code&gt; is compiled for the underlying operating system (for example, Unix/Linux or Windows) during the build of the Erlang/OTP system, and is installed automatically with other executable programs in the top level &lt;code&gt;bin&lt;/code&gt; directory of Erlang/OTP. The &lt;code&gt;ct&lt;/code&gt; interface functions can be called from the Erlang shell, or from any Erlang function, on any supported platform.</source>
          <target state="translated">使用 &lt;code&gt;Common Test&lt;/code&gt; 运行测试的两个主要接口是名为 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 的可执行程序和Erlang模块 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ct_run&lt;/code&gt; 在构建Erlang / OTP系统期间针对基础操作系统（例如Unix / Linux或Windows）进行编译，并与其他可执行程序一起自动安装在Erlang / OTP的顶级 &lt;code&gt;bin&lt;/code&gt; 目录中。在 &lt;code&gt;ct&lt;/code&gt; 接口功能可以从Erlang shell的调用，也可以从任何Erlang的功能，在任何支持的平台。</target>
        </trans-unit>
        <trans-unit id="1eed66d650bf2a2472423671355f16a5f1ae975a" translate="yes" xml:space="preserve">
          <source>The two major components of the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; tool is a graphical sequence chart viewer (&lt;code&gt;et_viewer&lt;/code&gt;) and its backing storage (&lt;code&gt;et_collector&lt;/code&gt;). One &lt;code&gt;Collector&lt;/code&gt; may be used as backing storage for several simultaneous &lt;code&gt;Viewers&lt;/code&gt; where each one may display a different view of the same trace data.</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 工具的两个主要组件是图形序列图查看器（ &lt;code&gt;et_viewer&lt;/code&gt; ）及其后备存储（ &lt;code&gt;et_collector&lt;/code&gt; ）。一个 &lt;code&gt;Collector&lt;/code&gt; 可以用作多个同时 &lt;code&gt;Viewers&lt;/code&gt; 备份存储，其中每个查看器可以显示相同跟踪数据的不同视图。</target>
        </trans-unit>
        <trans-unit id="b0b98c5ee144a7e629e6a186d5b34f7dc5bb41d7" translate="yes" xml:space="preserve">
          <source>The two occurrences of &lt;code&gt;N&lt;/code&gt; are not related. The compiler will complain that the &lt;code&gt;N&lt;/code&gt; in the size field is unbound.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 的两次出现无关。编译器将抱怨size字段中的 &lt;code&gt;N&lt;/code&gt; 未绑定。</target>
        </trans-unit>
        <trans-unit id="8c1e49fb3411cc8e5831e0be0f58277a39603aae" translate="yes" xml:space="preserve">
          <source>The two parts of the &lt;code&gt;convert&lt;/code&gt; function are called its clauses. As shown, &lt;code&gt;miles&lt;/code&gt; is not part of either of the clauses. The Erlang system cannot &lt;strong&gt;match&lt;/strong&gt; either of the clauses so an error message &lt;code&gt;function_clause&lt;/code&gt; is returned. The shell formats the error message nicely, but the error tuple is saved in the shell's history list and can be output by the shell command &lt;code&gt;v/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 函数的两个部分称为其子句。如图所示， &lt;code&gt;miles&lt;/code&gt; 数不是任何条款的一部分。Erlang系统无法&lt;strong&gt;匹配&lt;/strong&gt;任何一个子句，因此将返回错误消息 &lt;code&gt;function_clause&lt;/code&gt; 。Shell很好地格式化了错误消息，但是错误元组保存在Shell的历史记录列表中，并且可以由Shell命令 &lt;code&gt;v/1&lt;/code&gt; 输出：</target>
        </trans-unit>
        <trans-unit id="ef209651a9fdf27bee622b273ceb5f16c1a1ba01" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;BIT STRING&lt;/code&gt; can be used to model information that is made up of arbitrary length series of bits. It is intended to be used for selection of flags, not for binary files.</source>
          <target state="translated">&lt;code&gt;BIT STRING&lt;/code&gt; 类型可用于对由任意长度的位系列组成的信息进行建模。它旨在用于选择标志，而不用于二进制文件。</target>
        </trans-unit>
        <trans-unit id="ae16e6086ff80fdbd8c4ef671e6092d385270bd3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;CHOICE&lt;/code&gt; is a space saver and is similar to the concept of a 'union' in C.</source>
          <target state="translated">&lt;code&gt;CHOICE&lt;/code&gt; 类型可节省空间，类似于C语言中&amp;ldquo;联合&amp;rdquo;的概念。</target>
        </trans-unit>
        <trans-unit id="965f2c85137cbf54f06adf43202eea3af0164d29" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;ENUMERATED&lt;/code&gt; can be used when the value you want to describe can only take one of a set of predefined values. Example:</source>
          <target state="translated">当您要描述的值只能采用一组预定义值之一时，可以使用 &lt;code&gt;ENUMERATED&lt;/code&gt; 类型。例：</target>
        </trans-unit>
        <trans-unit id="c0ca634710fd8cc8e3767efb8dc71dc3f784baaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;EXTERNAL&lt;/code&gt; had a slightly different associated type before 1994. X.691 states that encoding must follow the older associated type. So, generated encode/decode functions convert values of the newer format to the older format before encoding. This implies that it is allowed to use &lt;code&gt;EXTERNAL&lt;/code&gt; type values of either format for encoding. Decoded values are always returned in the newer format.</source>
          <target state="translated">在1994年之前，类型 &lt;code&gt;EXTERNAL&lt;/code&gt; 的关联类型略有不同。X.691声明编码必须遵循旧的关联类型。因此，生成的编码/解码函数在编码之前将较新格式的值转换为较旧格式。这意味着允许使用两种格式的 &lt;code&gt;EXTERNAL&lt;/code&gt; 类型值进行编码。解码后的值始终以较新的格式返回。</target>
        </trans-unit>
        <trans-unit id="b96d9ad7628789a455a00e354d8f85bc83f8dcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;MACRO&lt;/code&gt; is not supported. It is no longer part of the ASN.1 standard.</source>
          <target state="translated">不支持 &lt;code&gt;MACRO&lt;/code&gt; 类型。它不再是ASN.1标准的一部分。</target>
        </trans-unit>
        <trans-unit id="aa57b7a761159ee02439dd9f7a7248614deec258" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;NULL&lt;/code&gt; is suitable where supply and recognition of a value is important but the actual value is not.</source>
          <target state="translated">在提供和识别值很重要而实际值不重要的情况下， &lt;code&gt;NULL&lt;/code&gt; 类型适用。</target>
        </trans-unit>
        <trans-unit id="8f171db85c218b70d6addcc8e6fc151a7cbbadd9" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is used whenever a unique identity is required. An ASN.1 module, a transfer syntax, and so on, is identified with an &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. Assume the following example:</source>
          <target state="translated">只要需要唯一 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 就使用对象标识类型。ASN.1模块，传输语法等由 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 标识。假设以下示例：</target>
        </trans-unit>
        <trans-unit id="9360300fbf341e9ae2dadc1fc262f79e78fb2fc1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TimeOut&lt;/code&gt; has the default value &lt;code&gt;infinity&lt;/code&gt;, so for instance:</source>
          <target state="translated">类型 &lt;code&gt;TimeOut&lt;/code&gt; 具有默认值 &lt;code&gt;infinity&lt;/code&gt; ，因此例如：</target>
        </trans-unit>
        <trans-unit id="25b9026ac150bd3535441298ee5fe811ce22b776" translate="yes" xml:space="preserve">
          <source>The type a port has when it is opened, but not bound to any file descriptor.</source>
          <target state="translated">端口打开时的类型,但不与任何文件描述符绑定。</target>
        </trans-unit>
        <trans-unit id="92d522e36d256191ae801d58140abe1b10a81a7f" translate="yes" xml:space="preserve">
          <source>The type checking in the SEQUENCE construct is non-strict (i.e. subtypes may be specified). The reason for this is that some standard MIBs use this.</source>
          <target state="translated">SEQUENCE构造中的类型检查是非严格的(即可以指定子类型)。这样做的原因是一些标准的MIB使用了这一点。</target>
        </trans-unit>
        <trans-unit id="1be2df477daeda02d0883ed07f5157d20b6857d8" translate="yes" xml:space="preserve">
          <source>The type definition for a child specification is as follows:</source>
          <target state="translated">子规范的类型定义如下:</target>
        </trans-unit>
        <trans-unit id="a191726a17db26ad276e59c3d2dbd9a5d58a79fa" translate="yes" xml:space="preserve">
          <source>The type definition of a child specification is as follows:</source>
          <target state="translated">子规范的类型定义如下:</target>
        </trans-unit>
        <trans-unit id="6def97965eb0171fce707fed1d80f680f68afe44" translate="yes" xml:space="preserve">
          <source>The type name is the atom &lt;code&gt;my_struct_type&lt;/code&gt;, followed by parentheses. &lt;code&gt;Type&lt;/code&gt; is a type as defined in the previous section. A current restriction is that &lt;code&gt;Type&lt;/code&gt; can contain only predefined types, or user-defined types which are either of the following:</source>
          <target state="translated">类型名称是原子 &lt;code&gt;my_struct_type&lt;/code&gt; ，后跟括号。 &lt;code&gt;Type&lt;/code&gt; 是上一节中定义的类型。当前的限制是 &lt;code&gt;Type&lt;/code&gt; 只能包含预定义类型或以下两种用户定义的类型：</target>
        </trans-unit>
        <trans-unit id="309c924e1cd088d894f3ed5124531ce4037037e9" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55a401f10752570792b382f21d74eedbc9c46cc7" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;Agent Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88149033eb0717d0b52143637014a89740d11a73" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#system_information&quot;&gt;System Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e5d162e866719ba45f57bb291d7dab0d1fc5d64" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Val&lt;/code&gt; depends on the value of &lt;code&gt;Tag&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 的类型取决于 &lt;code&gt;Tag&lt;/code&gt; 的值，有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#manager_information&quot;&gt;Manager Information&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="329ae914482ca32cea66526a39a0dbcd107a797e" translate="yes" xml:space="preserve">
          <source>The type of the AVP as specified in the dictionary file in question (or one it inherits). Possible types are &lt;code&gt;undefined&lt;/code&gt; and the Diameter types: &lt;code&gt;OctetString&lt;/code&gt;, &lt;code&gt;Integer32&lt;/code&gt;, &lt;code&gt;Integer64&lt;/code&gt;, &lt;code&gt;Unsigned32&lt;/code&gt;, &lt;code&gt;Unsigned64&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, &lt;code&gt;Float64&lt;/code&gt;, &lt;code&gt;Grouped&lt;/code&gt;, &lt;code&gt;Enumerated&lt;/code&gt;, &lt;code&gt;Address&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;UTF8String&lt;/code&gt;, &lt;code&gt;DiameterIdentity&lt;/code&gt;, &lt;code&gt;DiameterURI&lt;/code&gt;, &lt;code&gt;IPFilterRule&lt;/code&gt; and &lt;code&gt;QoSFilterRule&lt;/code&gt;.</source>
          <target state="translated">在相关字典文件（或它继承的字典文件）中指定的AVP类型。可能的类型是 &lt;code&gt;undefined&lt;/code&gt; 和Diameter类型： &lt;code&gt;OctetString&lt;/code&gt; ， &lt;code&gt;Integer32&lt;/code&gt; ， &lt;code&gt;Integer64&lt;/code&gt; ， &lt;code&gt;Unsigned32&lt;/code&gt; ， &lt;code&gt;Unsigned64&lt;/code&gt; ， &lt;code&gt;Float32&lt;/code&gt; ， &lt;code&gt;Float64&lt;/code&gt; ， &lt;code&gt;Grouped&lt;/code&gt; ， &lt;code&gt;Enumerated&lt;/code&gt; ， &lt;code&gt;Address&lt;/code&gt; ， &lt;code&gt;Time&lt;/code&gt; ， &lt;code&gt;UTF8String&lt;/code&gt; ， &lt;code&gt;DiameterIdentity&lt;/code&gt; ， &lt;code&gt;DiameterURI&lt;/code&gt; ， &lt;code&gt;IPFilterRule&lt;/code&gt; 和 &lt;code&gt;QoSFilterRule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">文件的类型。</target>
        </trans-unit>
        <trans-unit id="4a0aaded2e1891fac9206e8409a5f01261f2d116" translate="yes" xml:space="preserve">
          <source>The type tag of a syntax tree node may also be used as a primary tag by the &lt;code&gt;erl_parse&lt;/code&gt; representation; in that case, the selector functions for that node type &lt;strong&gt;must&lt;/strong&gt; handle both the abstract syntax tree and the &lt;code&gt;erl_parse&lt;/code&gt; form. The function &lt;code&gt;type(T)&lt;/code&gt; should return the correct type tag regardless of the representation of &lt;code&gt;T&lt;/code&gt;, so that the user sees no difference between &lt;code&gt;erl_syntax&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt; nodes.</source>
          <target state="translated">语法树节点的类型标签也可以通过 &lt;code&gt;erl_parse&lt;/code&gt; 表示用作主要标签；在这种情况下，该节点类型的选择器函数&lt;strong&gt;必须同时&lt;/strong&gt;处理抽象语法树和 &lt;code&gt;erl_parse&lt;/code&gt; 形式。无论 &lt;code&gt;T&lt;/code&gt; 的表示形式如何，函数 &lt;code&gt;type(T)&lt;/code&gt; 都应返回正确的类型标记，以便用户看不到 &lt;code&gt;erl_syntax&lt;/code&gt; 和 &lt;code&gt;erl_parse&lt;/code&gt; 节点之间的区别。</target>
        </trans-unit>
        <trans-unit id="fe3202d206f4f93d7d4689f53e891b3fc4e897bc" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt; have been removed from the standard since 1994. It is recommended not to use these types any more. They can, however, exist in some old ASN.1 modules. The idea with this type was to leave a &quot;hole&quot; in a definition where it was possible to put unspecified data of any kind, even non-ASN.1 data.</source>
          <target state="translated">自1994年以来已将 &lt;code&gt;ANY&lt;/code&gt; 和 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 类型从标准中删除。建议不要再使用这些类型。但是，它们可以存在于某些旧的ASN.1模块中。这种类型的想法是在定义中留下&amp;ldquo;漏洞&amp;rdquo;，在其中可以放置任何类型的未指定数据，甚至是非ASN.1数据。</target>
        </trans-unit>
        <trans-unit id="7d97ad7fc3d758f8f7503253b112a82e8b959c1f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;EXTERNAL&lt;/code&gt;, &lt;code&gt;EMBEDDED PDV&lt;/code&gt;, and &lt;code&gt;CHARACTER STRING&lt;/code&gt; are used in presentation layer negotiation. They are encoded according to their associated type, see X.680.</source>
          <target state="translated">表示层协商中使用 &lt;code&gt;EXTERNAL&lt;/code&gt; ， &lt;code&gt;EMBEDDED PDV&lt;/code&gt; 和 &lt;code&gt;CHARACTER STRING&lt;/code&gt; 类型。它们根据其关联的类型进行编码，请参阅X.680。</target>
        </trans-unit>
        <trans-unit id="31206f08c9e0b285f83486faa623acb15de23275" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt; correspond to the concept of an array in several programming languages. The Erlang syntax for both types is straightforward, for example:</source>
          <target state="translated">&lt;code&gt;SET OF&lt;/code&gt; 和 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 类型对应于几种编程语言中的数组概念。两种类型的Erlang语法都很简单，例如：</target>
        </trans-unit>
        <trans-unit id="b29412cfed4840e6735cd1786ded80d86e51e8fe" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; specifies encoding/decoding of the &lt;strong&gt;Unicode Transformation Format&lt;/strong&gt;s UTF-8, UTF-16, and UTF-32, respectively.</source>
          <target state="translated">类型 &lt;code&gt;utf8&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 分别指定&lt;strong&gt;Unicode转换格式&lt;/strong&gt;的UTF-8，UTF-16和UTF-32的编码/解码。</target>
        </trans-unit>
        <trans-unit id="397ab02499d0458aff045535e75d83bc31f4cbeb" translate="yes" xml:space="preserve">
          <source>The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt;, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.</source>
          <target state="translated">这些类型用于实现集合必须满足的各种条件。例如，考虑两组R和S的相对乘积，并回想一下，如果R是与Y的二元关系，而S是来自Y的二元关系，则定义R和S的相对积。实现该相对关系的函数产品， &lt;code&gt;&lt;a href=&quot;#relative_product-2&quot;&gt;relative_product/2&lt;/a&gt;&lt;/code&gt; ，通过将[{A，B}]与第一个参数的类型（例如Arg1说）和[{C，D}]与第二个参数的类型（例如Arg2说）进行匹配来检查参数是否表示二进制关系。 [{A，B}]与Arg1类型匹配的事实将被解释为Arg1，代表从X到Y的二进制关系，其中X被定义为Set中的某个元素x的所有Set Set（x）。这是A，并且类似地表示Y。以相同的方式，将Arg2解释为表示从W到Z的二进制关系。最后检查B是否匹配C，这足以确保W等于Y。 set单独处理：其类型['_']与任何无序集合的类型匹配。</target>
        </trans-unit>
        <trans-unit id="92a2f2f4039eb9cab39f41c392f86d30d282c1cf" translate="yes" xml:space="preserve">
          <source>The types of errors that may occur can be divide into the following categories.</source>
          <target state="translated">可能出现的错误类型可分为以下几类。</target>
        </trans-unit>
        <trans-unit id="ccc80a70996f3fb5f7ac83b02a6f6f55b6b8c98c" translate="yes" xml:space="preserve">
          <source>The types of record fields can be specified in the declaration of the record. The syntax for this is as follows:</source>
          <target state="translated">记录字段的类型可以在记录的声明中指定。其语法如下:</target>
        </trans-unit>
        <trans-unit id="015a6a68261fd2baee3f181670e406ef25582853" translate="yes" xml:space="preserve">
          <source>The typical round-trip of a message can be viewed as follows. Firstly we view the call flow on the originating side:</source>
          <target state="translated">一个消息的典型往返可以这样来看。首先我们查看发信端的呼叫流程。</target>
        </trans-unit>
        <trans-unit id="a092e2bd3b4745048655568b0b490cb79d98d82c" translate="yes" xml:space="preserve">
          <source>The unit of measurement is memory words. There exists both a 32-bit and a 64-bit implementation. A word is therefore 4 bytes or 8 bytes, respectively.</source>
          <target state="translated">计量单位是内存字。有32位和64位两种实现方式。因此,一个字分别是4个字节或8个字节。</target>
        </trans-unit>
        <trans-unit id="d78579febd40e018de674b923ab2dd8480cc6d1a" translate="yes" xml:space="preserve">
          <source>The unit size is given as &lt;code&gt;unit:IntegerLiteral&lt;/code&gt;. The allowed range is 1-256. It is multiplied by the &lt;code&gt;Size&lt;/code&gt; specifier to give the effective size of the segment. The unit size specifies the alignment for binary segments without size.</source>
          <target state="translated">单位大小以 &lt;code&gt;unit:IntegerLiteral&lt;/code&gt; 的形式给出。允许的范围是1-256。乘以 &lt;code&gt;Size&lt;/code&gt; 说明符即可得出段的有效大小。单位大小指定没有大小的二进制段的对齐方式。</target>
        </trans-unit>
        <trans-unit id="5ee4d7b5711971b4db427f1d7dcb1848a313bcc2" translate="yes" xml:space="preserve">
          <source>The unload request is registered, but other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still hold the driver. Notice that the term &lt;code&gt;pending_process&lt;/code&gt; can refer to the running process; there can be more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; in the same process.</source>
          <target state="translated">卸载请求已注册，但其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 仍保留驱动程序。注意，术语&amp;ldquo; &lt;code&gt;pending_process&lt;/code&gt; &amp;rdquo;可以指代正在运行的进程。同一过程中可以有多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92c5b2b8040b8ecbc28851e51c3e75943648293" translate="yes" xml:space="preserve">
          <source>The unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver in question while in progress.</source>
          <target state="translated">卸载/加载是作为一个原子操作来完成的,在进行中会阻止系统中的所有进程使用相关驱动。</target>
        </trans-unit>
        <trans-unit id="b2bb7ad491dec5db9c49126bb51367d385e40bcc" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt64&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt64&lt;/code&gt; are always 64 bits wide. They were introduced in ERTS 5.7.4.</source>
          <target state="translated">无符号整数数据类型 &lt;code&gt;ErlDrvUInt64&lt;/code&gt; 和有符号整数数据类型 &lt;code&gt;ErlDrvSInt64&lt;/code&gt; 始终为64位宽。它们是在ERTS 5.7.4中引入的。</target>
        </trans-unit>
        <trans-unit id="06cd090adf77b790656c62fa3caa0f561db0b42b" translate="yes" xml:space="preserve">
          <source>The unsigned integer data type &lt;code&gt;ErlDrvUInt&lt;/code&gt; and the signed integer data type &lt;code&gt;ErlDrvSInt&lt;/code&gt; are 64 bits wide on a 64-bit runtime system and 32 bits wide on a 32-bit runtime system. They were introduced in ERTS 5.6 and replaced some of the &lt;code&gt;int&lt;/code&gt; arguments in the list above.</source>
          <target state="translated">在64位运行时系统中，无符号整数数据类型 &lt;code&gt;ErlDrvUInt&lt;/code&gt; 和有符号整数数据类型 &lt;code&gt;ErlDrvSInt&lt;/code&gt; 为64位宽，在32位运行时系统中为32位宽。它们是在ERTS 5.6中引入的，并替换了上面列表中的一些 &lt;code&gt;int&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="d4dbe8cb85a6484b8db2e5ddc4f7e81602e6c250" translate="yes" xml:space="preserve">
          <source>The unsigned integer value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="634b3eb0cccf55ffe20b68558982833221c90d25" translate="yes" xml:space="preserve">
          <source>The unsleeping reader may notice that the ACC times for &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; and &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; is not equal between the paragraphs above, even though it is easy to believe that &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is just a passthrough function.</source>
          <target state="translated">熟睡中的读者可能会注意到 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 和 &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 的ACC时间在以上各段之间并不相等，尽管很容易相信 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 只是一个传递函数。</target>
        </trans-unit>
        <trans-unit id="53c140ed888506c0fa3ce30e4732a3ab8d9bef72" translate="yes" xml:space="preserve">
          <source>The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if the request is acknowledged, the upgrade to tls is performed.</source>
          <target state="translated">升级分两个阶段进行:首先询问服务器是否允许升级。第二,如果请求被确认,则升级到tls。</target>
        </trans-unit>
        <trans-unit id="f1abe4219b1176145faaf51a5d5248cfe9c5cdbb" translate="yes" xml:space="preserve">
          <source>The upgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;upgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">然后可以使用 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 评估升级脚本。建议改用 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; ，但是此函数（ &lt;code&gt;upgrade_script&lt;/code&gt; ）对检查脚本的内容很有用。</target>
        </trans-unit>
        <trans-unit id="66b6bbe8cee241bbe5ef7774f674afa0a63f5765" translate="yes" xml:space="preserve">
          <source>The upgrade was refused by the LDAP server. The &lt;code&gt;ResponseFromServer&lt;/code&gt; is an atom delivered byt the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is still un-encrypted.</source>
          <target state="translated">LDAP服务器拒绝升级。该 &lt;code&gt;ResponseFromServer&lt;/code&gt; 是BYT LDAP服务器递送的原子在部分RFC 2830的连接的2.3不受影响解释的，所以还是未加密。</target>
        </trans-unit>
        <trans-unit id="24e4c40c9265bed4ba5b9b42f433f1e4b84ab6f0" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the allocated block size histograms. Defaults to 128.</source>
          <target state="translated">分配的块大小直方图中第一个区间的上界。默认值为128。</target>
        </trans-unit>
        <trans-unit id="cbc1809e93754ae11d777adddcabee5582e3ea4f" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval in the free block size histograms. Defaults to 512.</source>
          <target state="translated">自由块大小直方图中第一个区间的上界。默认值为512。</target>
        </trans-unit>
        <trans-unit id="49138c2017ae769df1dbe3fdeaaab6a9e2775cc2" translate="yes" xml:space="preserve">
          <source>The upper bound of the first interval is provided by the function that returned the histogram, and the last interval has no upper bound.</source>
          <target state="translated">第一个区间的上界由返回直方图的函数提供,最后一个区间没有上界。</target>
        </trans-unit>
        <trans-unit id="0dc8cf3ce6b3c8880a720af10de4f0e69e030978" translate="yes" xml:space="preserve">
          <source>The uppercase escapes match the inverse sets of characters. Notice that \d matches only decimal digits, while \w matches any Unicode digit, any Unicode letter, and underscore. Notice also that &lt;code&gt;ucp&lt;/code&gt; affects \b and \B, as they are defined in terms of \w and \W. Matching these sequences is noticeably slower when &lt;code&gt;ucp&lt;/code&gt; is set.</source>
          <target state="translated">大写转义符与字符的相反集合匹配。请注意，\ d仅匹配十进制数字，而\ w匹配任何Unicode数字，任何Unicode字母和下划线。还要注意， &lt;code&gt;ucp&lt;/code&gt; 影响\ b和\ B，因为它们是根据\ w和\ W定义的。设置 &lt;code&gt;ucp&lt;/code&gt; 时，匹配这些序列的速度明显较慢。</target>
        </trans-unit>
        <trans-unit id="b043a2c5698c1e7d1fd873979502125e49e702d8" translate="yes" xml:space="preserve">
          <source>The use and effect of the actions are as follows:</source>
          <target state="translated">这些行动的用途和效果如下:</target>
        </trans-unit>
        <trans-unit id="ea64d7717e78cf5f593ec4e6046b9c45fcf5ca9f" translate="yes" xml:space="preserve">
          <source>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is only a block of memory allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. A handle (&quot;safe pointer&quot;) to this memory block can then be returned to Erlang by the use of &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;. The term returned by &lt;code&gt;enif_make_resource&lt;/code&gt; is opaque in nature. It can be stored and passed between processes, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; and get back a pointer to the memory block, which is guaranteed to still be valid. A resource object is not deallocated until the last handle term is garbage collected by the VM and the resource is released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; (not necessarily in that order).</source>
          <target state="translated">使用资源对象是从NIF返回指向本机数据结构的指针的安全方法。资源对象只是使用 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 分配的内存块。然后，可以使用 &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 将指向该内存块的句柄（&amp;ldquo;安全指针&amp;rdquo;）返回给Erlang 。 &lt;code&gt;enif_make_resource&lt;/code&gt; 返回的术语实际上是不透明的。可以在进程之间存储和传递它，但真正的最终用途是将其作为参数传递回NIF。然后，NIF可以调用 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 并返回指向该内存块的指针，该指针仍然有效。直到最后一个句柄项被VM垃圾回收并且使用以下命令释放资源后，才释放资源对象： &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; （不一定按此顺序）。</target>
        </trans-unit>
        <trans-unit id="abd42e11d00d705e28195f82bd49864a0d14541e" translate="yes" xml:space="preserve">
          <source>The use of the match operator is particularly useful for pulling apart Erlang terms and creating new ones.</source>
          <target state="translated">匹配操作符的使用对于拆分Erlang术语和创建新的术语特别有用。</target>
        </trans-unit>
        <trans-unit id="9361a4a5f036e16a92bbb4fe0af3e2c751d37ab7" translate="yes" xml:space="preserve">
          <source>The use of this option has always been discouraged. As from R14A, it is an error to use it.</source>
          <target state="translated">一直不鼓励使用该选项。从R14A开始,使用该选项是一种错误。</target>
        </trans-unit>
        <trans-unit id="7051fa8cce86b7e9e63652f268c7db87c6180ee0" translate="yes" xml:space="preserve">
          <source>The used memory for all ETS tables.</source>
          <target state="translated">所有ETS表的使用内存。</target>
        </trans-unit>
        <trans-unit id="8f9be74fa1ece2bebb8a5ba0433d42158ebba618" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;otptest&lt;/code&gt;, which has bash as default shell, uses the &lt;code&gt;ssh:shell/1&lt;/code&gt; client to connect to the &lt;strong&gt;openssh&lt;/strong&gt; daemon running on a host called &lt;strong&gt;tarlop&lt;/strong&gt;:</source>
          <target state="translated">拥有 &lt;code&gt;otptest&lt;/code&gt; 作为默认shell 的用户otptest使用 &lt;code&gt;ssh:shell/1&lt;/code&gt; 客户端连接到在名为&lt;strong&gt;tarlop&lt;/strong&gt;的主机上运行的&lt;strong&gt;openssh&lt;/strong&gt;守护程序：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d301c340a5de16be3a33995e9e04d1a25c73f970" translate="yes" xml:space="preserve">
          <source>The user can include this AVP as required.</source>
          <target state="translated">用户可以根据需要加入这个AVP。</target>
        </trans-unit>
        <trans-unit id="b476a06d8305252521da860471bca0c708d1246d" translate="yes" xml:space="preserve">
          <source>The user can provide a test specification including (for &lt;code&gt;Common Test&lt;/code&gt;) unrecognizable terms. If this is desired, use flag &lt;code&gt;-allow_user_terms&lt;/code&gt; when starting tests with &lt;code&gt;ct_run&lt;/code&gt;. This forces &lt;code&gt;Common Test&lt;/code&gt; to ignore unrecognizable terms. In this mode, &lt;code&gt;Common Test&lt;/code&gt; is not able to check the specification for errors as efficiently as if the scanner runs in default mode. If &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; is used for starting the tests, the relaxed scanner mode is enabled by tuple &lt;code&gt;{allow_user_terms,true}&lt;/code&gt;.</source>
          <target state="translated">用户可以提供测试规范，包括（对于 &lt;code&gt;Common Test&lt;/code&gt; ）无法识别的术语。如果 &lt;code&gt;-allow_user_terms&lt;/code&gt; 在使用ct_run启动测试时使用标志 &lt;code&gt;ct_run&lt;/code&gt; 。这迫使 &lt;code&gt;Common Test&lt;/code&gt; 忽略无法识别的术语。在这种模式下， &lt;code&gt;Common Test&lt;/code&gt; 无法像在默认模式下运行扫描程序那样高效地检查规范中的错误。如果使用 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 启动测试，则元组 &lt;code&gt;{allow_user_terms,true}&lt;/code&gt; 启用宽松的扫描器模式。</target>
        </trans-unit>
        <trans-unit id="aec8dfaf1d2231e245fe0cd75a270293f3d428b2" translate="yes" xml:space="preserve">
          <source>The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; when starting Erlang.</source>
          <target state="translated">用户可以请求通过外壳程序和格式化功能在字符串的启发式检测中被认为可打印的一系列字符。这是通过在启动Erlang时提供 &lt;code&gt;+pc &amp;lt;range&amp;gt;&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="5ae2400e1fce55a0b4d9b7318948b8627b3d6a40" translate="yes" xml:space="preserve">
          <source>The user can specify a specific group path with parameter &lt;code&gt;group_names_or_paths&lt;/code&gt;. With this type of specification execution of unwanted groups (in otherwise matching paths), and/or the execution of subgroups can be avoided. The command line syntax of the group path is a list of group names in the path, for example:</source>
          <target state="translated">用户可以使用参数 &lt;code&gt;group_names_or_paths&lt;/code&gt; 指定特定的组路径。通过这种类型的规范，可以避免执行不需要的组（在其他匹配路径中）和/或执行子组。组路径的命令行语法是路径中组名称的列表，例如：</target>
        </trans-unit>
        <trans-unit id="0130ad65a7625b17e035e835fe6eaf0679e0f246" translate="yes" xml:space="preserve">
          <source>The user can specify configuration data on a different format than key-value tuples in a text file, as described so far. The data can, for example, be read from any files, fetched from the web over HTTP, or requested from a user-specific process. To support this, &lt;code&gt;Common Test&lt;/code&gt; provides a callback module plugin mechanism to handle configuration data.</source>
          <target state="translated">到目前为止，用户可以使用与文本文件中的键值元组不同的格式来指定配置数据。例如，可以从任何文件中读取数据，通过HTTP从Web上获取数据，或从特定于用户的进程中请求数据。为此， &lt;code&gt;Common Test&lt;/code&gt; 提供了一个回调模块插件机制来处理配置数据。</target>
        </trans-unit>
        <trans-unit id="660461224293f1991c368482cebc005aee961e52" translate="yes" xml:space="preserve">
          <source>The user configures diameter with the identifiers to send at capabilities exchange, along with corresponding dictionaries defining the messages of the applications.</source>
          <target state="translated">用户在能力交换时配置直径与要发送的标识符,以及相应的字典,定义应用的消息。</target>
        </trans-unit>
        <trans-unit id="b475ffe342e790093cd964ba6cc829f6bd45785f" translate="yes" xml:space="preserve">
          <source>The user constructs application-specific messages, but diameter provides failed AVPs in message callbacks. Failed component AVPs are grouped within the relevant Grouped AVPs.</source>
          <target state="translated">用户构建特定的应用程序消息,但直径在消息回调中提供失败的AVP。失败的组件AVPs被归入相关的Grouped AVPs中。</target>
        </trans-unit>
        <trans-unit id="3591203b72caf861e6110120cbe93c01af2b88a2" translate="yes" xml:space="preserve">
          <source>The user decides whether or not to process a request locally in the request callback from diameter.</source>
          <target state="translated">用户在来自直径的请求回调中决定是否在本地处理一个请求。</target>
        </trans-unit>
        <trans-unit id="3464961bd356a69bfcff6ac160a461e76a93d25f" translate="yes" xml:space="preserve">
          <source>The user has explicitly cancelled the wait (megaco:cancel/2).</source>
          <target state="translated">用户明确取消了等待(megaco:cancel/2)。</target>
        </trans-unit>
        <trans-unit id="d18a93e929b37cd21f4c79e7536ff6532ff0f893" translate="yes" xml:space="preserve">
          <source>The user has logged off (the &quot;logoff&quot; message is removed).</source>
          <target state="translated">用户已经注销(&quot;注销 &quot;信息被删除)。</target>
        </trans-unit>
        <trans-unit id="66d08744fcbef8850f22e132fcee2b95959ddf93" translate="yes" xml:space="preserve">
          <source>The user keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用户密钥目录可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="ddf02e29035334a18d18c5e1b94c79095367bd56" translate="yes" xml:space="preserve">
          <source>The user may (for special purposes) create additional nodes with other type tags, using the &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">用户可以使用 &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; 函数（出于特殊目的）使用其他类型的标签创建其他节点。</target>
        </trans-unit>
        <trans-unit id="5ee238ea123b1d44a60398d5285952819fc3ede9" translate="yes" xml:space="preserve">
          <source>The user should implement a scanner that segments the input text, and turns it into one or more lists of tokens. Each token should be a tuple containing information about syntactic category, position in the text (e.g. line number), and the actual terminal symbol found in the text: &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt;.</source>
          <target state="translated">用户应实现一种扫描器，该扫描器可以对输入文本进行分段，并将其转换为一个或多个令牌列表。每个令牌应该是一个元组，其中包含有关语法类别，文本中的位置（例如，行号）以及在文本中找到的实际终端符号的信息： &lt;code&gt;{Category, LineNumber, Symbol}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9c7796fd10aeef2e76370d88ff426dec7a02695" translate="yes" xml:space="preserve">
          <source>The user tag is provided to the user probes triggered by calls top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; as well as probes in the efile_driver. In the future, user tags might be added to more probes.</source>
          <target state="translated">该用户标签提供给通过调用top &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; 触发的用户探针，以及efile_driver中的探针。将来，用户标签可能会添加到更多探针中。</target>
        </trans-unit>
        <trans-unit id="935cfbe6393df2b605ae54a72dfb24e180f2b45e" translate="yes" xml:space="preserve">
          <source>The user timetrap function can be used for two things as follows:</source>
          <target state="translated">用户计时功能可用于以下两个方面。</target>
        </trans-unit>
        <trans-unit id="2f2130a51941a7dd2f7d9af37266ecb1c20f0d79" translate="yes" xml:space="preserve">
          <source>The user timetrap function can return a time value after a delay. The effective timetrap time is then the delay time &lt;strong&gt;plus&lt;/strong&gt; the returned time.</source>
          <target state="translated">用户时间陷阱功能可以在延迟后返回时间值。那么，有效的时间陷阱时间就是延迟时间&lt;strong&gt;加上&lt;/strong&gt;返回的时间。</target>
        </trans-unit>
        <trans-unit id="b5ee7bda12decc24125202f276f6922f07234b3a" translate="yes" xml:space="preserve">
          <source>The user(s) register their agents.</source>
          <target state="translated">用户注册其代理人。</target>
        </trans-unit>
        <trans-unit id="1d94abedc5a45d3a00396f6b9115ee0199e9b2d1" translate="yes" xml:space="preserve">
          <source>The user-defined CPU topology can also be set by passing command-line argument &lt;code&gt;+sct&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">还可以通过将命令行参数 &lt;code&gt;+sct&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 来设置用户定义的CPU拓扑。</target>
        </trans-unit>
        <trans-unit id="3eac153a48412697b04bd3f7c3679f6e2cb43d77" translate="yes" xml:space="preserve">
          <source>The user-specific handler can be written to handle special configuration file formats. The parameter can be either file names or configuration strings (the empty list is valid).</source>
          <target state="translated">可以编写用户专用的处理程序来处理特殊的配置文件格式。参数可以是文件名或配置字符串(空列表有效)。</target>
        </trans-unit>
        <trans-unit id="070ed6c048e93f78c36ea8f0ccfec711d97f3991" translate="yes" xml:space="preserve">
          <source>The user/operator can specify the order at will, and maybe a different execution order is sometimes more relevant or efficient.</source>
          <target state="translated">用户/操作者可以随意指定顺序,也许不同的执行顺序有时更有针对性或效率。</target>
        </trans-unit>
        <trans-unit id="816667b752baf90b5891d2f5483693ef98e188ca" translate="yes" xml:space="preserve">
          <source>The username used for authentication.</source>
          <target state="translated">用于认证的用户名。</target>
        </trans-unit>
        <trans-unit id="32f031cef47e0932c6309630147b6b75921f94b2" translate="yes" xml:space="preserve">
          <source>The utilities are also suitable to use in system testing on large systems, where other tools have too much impact on the system performance. Some primitive support for sequential tracing is also included, see the &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">该实用程序还适用于在大型系统上进行系统测试，而其他工具对系统性能的影响太大。还包括对顺序跟踪的一些原始支持，请参阅 &lt;code&gt;&lt;a href=&quot;#advanced&quot;&gt;advanced topics&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="1b998cc802660cc78a04365f6fb84a62e62e8e56" translate="yes" xml:space="preserve">
          <source>The utility &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">实用程序 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 提供了一个备用编译接口。</target>
        </trans-unit>
        <trans-unit id="88c9fe090556e5d2d20b460fae9afd89cea9e45c" translate="yes" xml:space="preserve">
          <source>The utility function &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; can be used to easily transform a string of text into a &lt;code&gt;par&lt;/code&gt; representation by splitting it into words.</source>
          <target state="translated">实用程序函数 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 可用于将文本字符串拆分为单词，从而轻松地将其转换为 &lt;code&gt;par&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="fd02acb46e123ade0af1cb132c81a7c98e6cbd55" translate="yes" xml:space="preserve">
          <source>The utility module &lt;code&gt;msacc(3)&lt;/code&gt; can be used to more easily analyse these statistics.</source>
          <target state="translated">实用程序模块 &lt;code&gt;msacc(3)&lt;/code&gt; 可用于更轻松地分析这些统计信息。</target>
        </trans-unit>
        <trans-unit id="86003c423491838636e87b46780a42310a82d73b" translate="yes" xml:space="preserve">
          <source>The valid configuration parameters are as follows:</source>
          <target state="translated">有效的配置参数如下。</target>
        </trans-unit>
        <trans-unit id="1fb94796638387a4f1cb0c6ac15343b38548969a" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. See the &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; function for more info on the &lt;code&gt;Validate&lt;/code&gt; fun.</source>
          <target state="translated">验证乐趣 &lt;code&gt;Validate&lt;/code&gt; 允许对 &lt;code&gt;DateAndTime&lt;/code&gt; 参数进行更&amp;ldquo;灵活&amp;rdquo;的验证。每当发现数据不遵循RFC2579时，都会调用此乐趣以允许更&amp;ldquo;宽松&amp;rdquo;的验证。有关 &lt;code&gt;Validate&lt;/code&gt; 乐趣的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#vdat&quot;&gt;validate_date_and_time/2&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="60c703f2c6b10b3e79aabc8eaf2dfdc52607c370" translate="yes" xml:space="preserve">
          <source>The validation fun, &lt;code&gt;Validate&lt;/code&gt;, allows for a more &quot;flexible&quot; validation of the &lt;code&gt;DateAndTime&lt;/code&gt; argument. Whenever the data is found to not follow RFC2579, the fun is called to allow a more &quot;lax&quot; validation. The input to the validation fun looks like this:</source>
          <target state="translated">验证乐趣 &lt;code&gt;Validate&lt;/code&gt; 允许对 &lt;code&gt;DateAndTime&lt;/code&gt; 参数进行更&amp;ldquo;灵活&amp;rdquo;的验证。每当发现数据不遵循RFC2579时，都会调用此乐趣以允许更多&amp;ldquo;宽松&amp;rdquo;的验证。验证乐趣的输入如下所示：</target>
        </trans-unit>
        <trans-unit id="58a5e20ed6c2d29e3e861f7702b4763df798e9a1" translate="yes" xml:space="preserve">
          <source>The validity of the options is &lt;strong&gt;not&lt;/strong&gt; checked by the HTTP client they are assumed to be correct and passed on to ssl application and inet driver, which may reject them if they are not correct.</source>
          <target state="translated">HTTP客户端&lt;strong&gt;未&lt;/strong&gt;检查选项的有效性，并认为这些选项是正确的，并传递给ssl应用程序和inet驱动程序，如果它们不正确，它们可能会拒绝它们。</target>
        </trans-unit>
        <trans-unit id="247d880cbbfe17329068c2a487e83b52be0b8fd0" translate="yes" xml:space="preserve">
          <source>The validity period of the certificate.</source>
          <target state="translated">证书的有效期;</target>
        </trans-unit>
        <trans-unit id="de095b0c0154458957667b823417f32d9c762772" translate="yes" xml:space="preserve">
          <source>The value (in seconds) must be in the range 10 &amp;lt; X &amp;lt;= 65535.</source>
          <target state="translated">值（以秒为单位）必须在10 &amp;lt;X &amp;lt;= 65535的范围内。</target>
        </trans-unit>
        <trans-unit id="c7d9f4f2d7422b47b5c88e4d58854e12adae49bd" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;-1&lt;/code&gt; in any field means &quot;unknown&quot;, and in most cases it means that the dump was truncated somewhere around this field.</source>
          <target state="translated">在任何字段中的值 &lt;code&gt;-1&lt;/code&gt; 表示&amp;ldquo;未知&amp;rdquo;，并且在大多数情况下，它意味着转储在该字段周围的某个地方被截断了。</target>
        </trans-unit>
        <trans-unit id="ebb9639bd59b81ac3f0302e2ea6264dd43e978a9" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;random&lt;/code&gt; will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version.</source>
          <target state="translated">值 &lt;code&gt;random&lt;/code&gt; 将导致在每次连接尝试时创建一个随机字符串。这使得恶意对等方很难找到ssh软件的品牌和版本。</target>
        </trans-unit>
        <trans-unit id="59cae5c48ebf4d4c60edc8af8c6900b2f10cdd93" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; will make a random string with at least &lt;code&gt;Nmin&lt;/code&gt; characters and at most &lt;code&gt;Nmax&lt;/code&gt; characters.</source>
          <target state="translated">值 &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; 将构成一个随机字符串，其中至少包含 &lt;code&gt;Nmin&lt;/code&gt; 个字符，最多包含 &lt;code&gt;Nmax&lt;/code&gt; 个字符。</target>
        </trans-unit>
        <trans-unit id="cc2e81fd931d300e3783349335314abc90033f4a" translate="yes" xml:space="preserve">
          <source>The value associated with key &lt;code&gt;alpha&lt;/code&gt; is fetched for both arguments using the &lt;code&gt;:=&lt;/code&gt; operator. The other keys in the map are ignored, only the key &lt;code&gt;alpha&lt;/code&gt; is required and checked for.</source>
          <target state="translated">使用 &lt;code&gt;:=&lt;/code&gt; 运算符为两个参数都获取与键 &lt;code&gt;alpha&lt;/code&gt; 关联的值。映射中的其他键将被忽略，仅需要键 &lt;code&gt;alpha&lt;/code&gt; 并进行检查。</target>
        </trans-unit>
        <trans-unit id="86b0b34c5895cd8049a0c1760924204afc238fc1" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">与此过滤器关联的值被过滤器用来对源自例如特定功能区域的日志事件进行分组。有关如何使用此字段的说明，请参见 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9b31d1fc7f3b413bcae938dfe03589bb5285a5" translate="yes" xml:space="preserve">
          <source>The value defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">该值默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73cc3165471e18765106ff9988f4618f4de5f7c9" translate="yes" xml:space="preserve">
          <source>The value defined here can be used in several ways. It can, for example, be used as the value in some &lt;code&gt;DEFAULT&lt;/code&gt; component:</source>
          <target state="translated">此处定义的值可以通过多种方式使用。例如，它可以用作某些 &lt;code&gt;DEFAULT&lt;/code&gt; 组件中的值：</target>
        </trans-unit>
        <trans-unit id="00cedad00d133d50963e34c659f0ef80545f6ee4" translate="yes" xml:space="preserve">
          <source>The value denotes a regular expression (see module &lt;code&gt;re&lt;/code&gt;). Tidying will only be applied to those regular files whose names match this pattern. The default value is &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt;, which matches normal Erlang source file names.</source>
          <target state="translated">该值表示一个正则表达式（请参阅模块 &lt;code&gt;re&lt;/code&gt; ）。整理仅适用于名称与此模式匹配的常规文件。默认值为 &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt; ，它与普通的Erlang源文件名匹配。</target>
        </trans-unit>
        <trans-unit id="a7fc7c904bc65fe1f04425c2c4301dd4dfba43f3" translate="yes" xml:space="preserve">
          <source>The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.</source>
          <target state="translated">该值具有RFC 6733的8.8节所要求的形式。Ident应该是包含返回值的消息将从其发送的对等体的Origin-Host。</target>
        </trans-unit>
        <trans-unit id="565bd9ff9980988d34e45f60f24a9df4493a532c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">如果该过程的呼叫保存未处于活动状态，则该值为 &lt;code&gt;false&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt; ）。如果激活了通话保存功能，则返回一个列表，其中最后一个元素是最近通话的元素。</target>
        </trans-unit>
        <trans-unit id="fca5756bcf0742c5fb8a83c510ae9ce36b623343" translate="yes" xml:space="preserve">
          <source>The value is a &lt;code&gt;boolean()&lt;/code&gt;. The value &lt;code&gt;true&lt;/code&gt; will make the client accept any unknown Host Key without any user interaction. The value &lt;code&gt;false&lt;/code&gt; preserves the default behaviour of asking the user on stdio.</source>
          <target state="translated">该值为 &lt;code&gt;boolean()&lt;/code&gt; 。值 &lt;code&gt;true&lt;/code&gt; 将使客户端无需任何用户交互即可接受任何未知的主机密钥。值 &lt;code&gt;false&lt;/code&gt; 保留在stdio上询问用户的默认行为。</target>
        </trans-unit>
        <trans-unit id="4b03c47ccab46f2579d8f24abc755f87cc416f2a" translate="yes" xml:space="preserve">
          <source>The value is a list of pairs, associating tuples &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; with tuples &lt;code&gt;{NewModule, NewName}&lt;/code&gt;, specifying renamings of calls to remote functions. By default, the value is the empty list.</source>
          <target state="translated">该值是成对的列表，将元组 &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; 与元组 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; ，指定对远程函数的调用重命名。默认情况下，该值为空列表。</target>
        </trans-unit>
        <trans-unit id="1df1db1ba1c8748b25a7c5b626dd8804fd835229" translate="yes" xml:space="preserve">
          <source>The value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; section 9.1.</source>
          <target state="translated">该值由协议级别响应中的sftp错误代码形成，如 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; 部分9.1中所定义。</target>
        </trans-unit>
        <trans-unit id="bd41f86d28c143add491ec9132e29dfc8b19621e" translate="yes" xml:space="preserve">
          <source>The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use &lt;code&gt;atom()&lt;/code&gt;s or &lt;code&gt;string()&lt;/code&gt;s to specify the subpatterns to be returned. For example, consider the regular expression:</source>
          <target state="translated">值列表是要返回的子模式的索引列表，其中索引0表示所有模式，而索引1表示正则表达式中的第一个显式捕获子模式，依此类推。在正则表达式中使用命名的捕获子模式（请参见下文）时，可以使用 &lt;code&gt;atom()&lt;/code&gt; 或 &lt;code&gt;string()&lt;/code&gt; 来指定要返回的子模式。例如，考虑正则表达式：</target>
        </trans-unit>
        <trans-unit id="c81f48007ff0ed091ec4764a41dbf0e172a8f0bb" translate="yes" xml:space="preserve">
          <source>The value must be a function with arity 1, returning &lt;code&gt;{Format,Args}&lt;/code&gt;, and it will be called with a report as only argument.</source>
          <target state="translated">该值必须是具有Arity 1的函数，返回 &lt;code&gt;{Format,Args}&lt;/code&gt; ，并且将使用报告作为唯一参数来调用它。</target>
        </trans-unit>
        <trans-unit id="e234819107a6b5dcfa3fe173976c85b1ea1b28f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值与编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值相同；否则，运行时系统将拒绝加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="116150239ed1360f1b36349687371da72b694bcd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值可能不同于编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="78be37cd91f4cf995f8b06a4daace135c812602c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="0b2195f8068d2a10ede4ea4cc9fcbf6ff4d98d21" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="b118746e3fc7bb9edb78696fb5442fd44cb5a3e1" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Misc&lt;/code&gt; varies for different types of processes, for example:</source>
          <target state="translated">&lt;code&gt;Misc&lt;/code&gt; 的值因不同类型的过程而异，例如：</target>
        </trans-unit>
        <trans-unit id="8dae040f4f2546c55f00cef77a0cb74993dea2c6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 的值乘以单位将得出位数。 &lt;code&gt;binary&lt;/code&gt; 类型的段的大小必须被8整除。</target>
        </trans-unit>
        <trans-unit id="780ca2b28783a99a4c631093f06c672e54bdfc8a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; specifies the size of the segment in units (see below). The default value depends on the type (see below):</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 的值指定段的大小（以单位为单位）（请参见下文）。默认值取决于类型（请参见下文）：</target>
        </trans-unit>
        <trans-unit id="b1854e31941d7fbfcb3749a7e6c4457829e3447d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;State&lt;/code&gt; varies for different types of processes, as follows:</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 的价值因不同类型的过程而异，如下所示：</target>
        </trans-unit>
        <trans-unit id="67326e380fdef2e7ca1cffaffc1a499d8945109f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;engine_id&lt;/code&gt; is a string, which should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;engine_id&lt;/code&gt; 的值是一个字符串，应具有非常特定的结构。有关详细信息，请参见RFC 2271/2571。</target>
        </trans-unit>
        <trans-unit id="67a488abfbc3355615ef1fdf9842c10e39f374ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;file&lt;/code&gt; overrides the value of &lt;code&gt;file&lt;/code&gt; as defined in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">值 &lt;code&gt;file&lt;/code&gt; 覆盖的值 &lt;code&gt;file&lt;/code&gt; 中的定义， &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="ce398bd65bb25721ffa1a8a7e0185e8682912540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;intAgentTransports&lt;/code&gt; is a list of &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuples, where &lt;code&gt;Domain&lt;/code&gt; is either &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is the address in the domain. &lt;code&gt;Addr&lt;/code&gt; can be specified either as an &lt;code&gt;IpAddr&lt;/code&gt; or as an &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; tuple. &lt;code&gt;IpAddr&lt;/code&gt; is either a regular Erlang/OTP &lt;code&gt;ip_address()&lt;/code&gt; or a traditional SNMP integer list and &lt;code&gt;IpPort&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;intAgentTransports&lt;/code&gt; 的值是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Domain&lt;/code&gt; 是 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; ，而 &lt;code&gt;Addr&lt;/code&gt; 是域中的地址。可以将 &lt;code&gt;Addr&lt;/code&gt; 指定为 &lt;code&gt;IpAddr&lt;/code&gt; 或 &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; 元组。 &lt;code&gt;IpAddr&lt;/code&gt; 是常规的Erlang / OTP &lt;code&gt;ip_address()&lt;/code&gt; 或传统的SNMP整数列表，而 &lt;code&gt;IpPort&lt;/code&gt; 是整数。</target>
        </trans-unit>
        <trans-unit id="fa552c79540af3ff0c608c82bebe09aa87d449b9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;parent_value&lt;/code&gt; is the value returned by &lt;code&gt;ParentFun&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if there is no &lt;code&gt;ParentFun&lt;/code&gt;. &lt;code&gt;ParentFun&lt;/code&gt; is called once just before the call of &lt;code&gt;PreFun&lt;/code&gt; in the context of the process calling &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">值 &lt;code&gt;parent_value&lt;/code&gt; 是返回的值 &lt;code&gt;ParentFun&lt;/code&gt; ，或者 &lt;code&gt;undefined&lt;/code&gt; 如果没有 &lt;code&gt;ParentFun&lt;/code&gt; 。在调用 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; 的进程的上下文中，仅在 &lt;code&gt;ParentFun&lt;/code&gt; 调用之前调用一次 &lt;code&gt;PreFun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="403588e32c3c599137f65e61edac93c0adc811e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;snmpEngineID&lt;/code&gt; is a string, which for a deployed agent should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;snmpEngineID&lt;/code&gt; 的值是一个字符串，对于已部署的代理，该字符串应具有非常特定的结构。有关详细信息，请参见RFC 2271/2571。</target>
        </trans-unit>
        <trans-unit id="39576763fb2878e58995adcb19edf7b1f8b5b52e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;stop_fun&lt;/code&gt; is a nullary fun that deletes the cursor if called from the parent, or &lt;code&gt;undefined&lt;/code&gt; if there is no cursor.</source>
          <target state="translated">&lt;code&gt;stop_fun&lt;/code&gt; 的值是一个无效游标，如果从父级调用该游标，则删除游标；如果没有游标，则 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbda166cbb0a64342130a713cafa3ff8a579278c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;tc_group_properties&lt;/code&gt; is a list of status tuples, each with the key &lt;code&gt;ok&lt;/code&gt;, &lt;code&gt;skipped&lt;/code&gt;, and &lt;code&gt;failed&lt;/code&gt;. The value of a status tuple is a list with names of test cases that have been executed with the corresponding status as result.</source>
          <target state="translated">&lt;code&gt;tc_group_properties&lt;/code&gt; 的值是状态元组的列表，每个元组具有键 &lt;code&gt;ok&lt;/code&gt; ， &lt;code&gt;skipped&lt;/code&gt; 和 &lt;code&gt;failed&lt;/code&gt; 。状态元组的值是一个列表，其中列出了已用相应状态作为结果执行的测试用例的名称。</target>
        </trans-unit>
        <trans-unit id="c90e20096422723556a7637012d02aa52ba6cd06" translate="yes" xml:space="preserve">
          <source>The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 检索配置参数的值。</target>
        </trans-unit>
        <trans-unit id="0e674f5f0ae9761a28b0e34a6e1578f6940f7307" translate="yes" xml:space="preserve">
          <source>The value of a field in a record can be an instance of a record. Retrieval of nested data can be done stepwise, or in a single step, as shown in the following example:</source>
          <target state="translated">记录中字段的值可以是记录的一个实例。嵌套数据的检索可以逐步进行,也可以一步到位,如下例所示。</target>
        </trans-unit>
        <trans-unit id="090fd2fb5e0fd0eb93688d1bfcea8e341fe24db7" translate="yes" xml:space="preserve">
          <source>The value of option &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; is to be &lt;code&gt;'=:='&lt;/code&gt; if the table considers two keys equal if they match, and to be &lt;code&gt;'=='&lt;/code&gt; if two keys are equal if they compare equal. Defaults to &lt;code&gt;'=:='&lt;/code&gt;.</source>
          <target state="translated">选项的值 &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; 是成为 &lt;code&gt;'=:='&lt;/code&gt; 如果表认为两个密钥相等，如果它们匹配，并为 &lt;code&gt;'=='&lt;/code&gt; 如果两个密钥相等，当它们相等比较。默认为 &lt;code&gt;'=:='&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b5f4463cd58d2c1d9f4f3e85881555f2a7d602d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;Parserfile&lt;/code&gt; option stripped of the &lt;code&gt;.erl&lt;/code&gt; extension is used by Yecc as the module name of the generated parser file.</source>
          <target state="translated">所述的值 &lt;code&gt;Parserfile&lt;/code&gt; 剥去的选项 &lt;code&gt;.erl&lt;/code&gt; 扩展用于通过Yecc作为生成的分析器文件的模块名称。</target>
        </trans-unit>
        <trans-unit id="2c64d7956fe51b588938aacaa6f88fb7a9310598" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;closure&lt;/code&gt; operator (the &lt;code&gt;digraph&lt;/code&gt; representation) is represented by the atom &lt;code&gt;'closure()'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; 运算符的值（ &lt;code&gt;digraph&lt;/code&gt; 表示）由原子 &lt;code&gt;'closure()'&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="22be0277bd691cf393301070a38cd39e17abb844" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;mod&lt;/code&gt; key of the including application must be set to &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; as usual is the application callback module. &lt;code&gt;StartArgs&lt;/code&gt; is a term provided as argument to the callback function &lt;code&gt;Module:start/2&lt;/code&gt;:</source>
          <target state="translated">必须将包含应用程序的 &lt;code&gt;mod&lt;/code&gt; 密钥的值设置为 &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt; ，其中照常， &lt;code&gt;Module&lt;/code&gt; 是应用程序回调模块。 &lt;code&gt;StartArgs&lt;/code&gt; 是作为回调函数 &lt;code&gt;Module:start/2&lt;/code&gt; 的参数提供的术语：</target>
        </trans-unit>
        <trans-unit id="e1d24fa6cc650f3b91539b4d964f2dd68411a599" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 时间单位的值或多或少没有给您有关时间质量值的信息。它为时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 设置了限制，但没有提供有关时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 的信息。本 &lt;code&gt;native&lt;/code&gt; 时间单位的分辨率和时间值的分辨率可能会有很大差异。</target>
        </trans-unit>
        <trans-unit id="75115f0cbc11f2e0c976711bd383faef47f72f73" translate="yes" xml:space="preserve">
          <source>The value of the Kernel configuration parameter &lt;code&gt;logger&lt;/code&gt; is a list of tuples. It is possible to write the term on the command line when starting an erlang node, but as the term grows, a better approach is to use the system configuration file. See the &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; manual page for more information about this file.</source>
          <target state="translated">内核配置参数 &lt;code&gt;logger&lt;/code&gt; 的值是一个元组列表。启动erlang节点时可以在命令行上写该术语，但是随着该术语的增长，更好的方法是使用系统配置文件。有关此文件的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="4ed44d3d955ffacf489b8abf33f5d265d4032122" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;offset&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="3c25e0afe475bdf7bd456a401767e588d0dff287" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;time_designator&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fcf4c591c4a3e4e565b4ce6c5bc397552958d5be" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on application level.</source>
          <target state="translated">该参数的值会覆盖应用层的同名参数。</target>
        </trans-unit>
        <trans-unit id="5f26c290284005b85aff4a14161e0e2b51659761" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on system level.</source>
          <target state="translated">该参数的值会覆盖系统级的同名参数。</target>
        </trans-unit>
        <trans-unit id="afeb557b1f15dc186755d5f00deaf5e3432d37f3" translate="yes" xml:space="preserve">
          <source>The value range stated at the top of this function description is technically correct, but &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically.</source>
          <target state="translated">从功能上讲，此函数说明顶部的值范围在技术上是正确的，但 &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; 是对生成数字的统计分布的更好描述。除了从不返回精确的0.0，这在统计上是不可能观察到的。</target>
        </trans-unit>
        <trans-unit id="de293b0684a913e1bf7ebfb80ee4f6ab7675b8bf" translate="yes" xml:space="preserve">
          <source>The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, at the time the diameter application was started.</source>
          <target state="translated">返回的值是自19680120T031408Z开始可以应用的秒数，该值可以在开始应用直径 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 被编码为Diameter Time（）。</target>
        </trans-unit>
        <trans-unit id="a55ba7f90cd067fd29a372ba9492df0943f53a10" translate="yes" xml:space="preserve">
          <source>The value specifies a list of source files to be merged with the file being compiled; cf. &lt;code&gt;merge_files/4&lt;/code&gt;.</source>
          <target state="translated">该值指定要与正在编译的文件合并的源文件的列表。cf. &lt;code&gt;merge_files/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f03a18e612b75547971d666854d8f1114a5bb61" translate="yes" xml:space="preserve">
          <source>The values encoded in the fields of generated records depends on the type and number of times the AVP can occur. In particular, an AVP which is specified as occurring exactly once is encoded as a value of the AVP's type while an AVP with any other specification is encoded as a list of values of the AVP's type. The AVP's type is as specified in the AVP definition, the RFC 6733 types being described below.</source>
          <target state="translated">生成的记录字段中的编码值取决于AVP的类型和出现的次数。特别是,被指定为准确出现一次的AVP被编码为AVP的类型值,而具有任何其他规格的AVP被编码为AVP的类型值列表。AVP的类型是在AVP定义中指定的,RFC 6733类型如下所述。</target>
        </trans-unit>
        <trans-unit id="28cbef0507c54b3b51d13679291493de8c4ec6f1" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file and the values in a system configuration file can be overridden directly from the command line:</source>
          <target state="translated">在的值 &lt;code&gt;.app&lt;/code&gt; 文件，并在系统配置文件中的值可以直接从命令行来覆盖：</target>
        </trans-unit>
        <trans-unit id="25131865afbeb61db1691607b17034d98faf548c" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file can be overridden by values in a &lt;strong&gt;system configuration file&lt;/strong&gt;. This is a file that contains configuration parameters for relevant applications:</source>
          <target state="translated">在的值 &lt;code&gt;.app&lt;/code&gt; 文件可以由值在被覆盖&lt;strong&gt;的系统配置文件&lt;/strong&gt;。这是一个文件，其中包含相关应用程序的配置参数：</target>
        </trans-unit>
        <trans-unit id="626a57e5be3f05ed3f7f8f360fb873aeecee8e88" translate="yes" xml:space="preserve">
          <source>The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is &lt;code&gt;index&lt;/code&gt;, the tuple &lt;code&gt;{-1,0}&lt;/code&gt; is returned for values with no corresponding subpattern in the regular expression, but for the other types (&lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;), the values are the empty binary or list, respectively.</source>
          <target state="translated">值列表可以指定正则表达式中不存在的索引或名称，在这种情况下，返回值取决于类型。如果类型为 &lt;code&gt;index&lt;/code&gt; ，则对于正则表达式中没有对应子模式的值，返回元组 &lt;code&gt;{-1,0}&lt;/code&gt; ，但对于其他类型（ &lt;code&gt;binary&lt;/code&gt; 和 &lt;code&gt;list&lt;/code&gt; ），则分别返回空的二进制或列表。</target>
        </trans-unit>
        <trans-unit id="863d5cefc2b644473a83e6d5a4a11ff192199273" translate="yes" xml:space="preserve">
          <source>The values of each ASN.1 type have their own representation in Erlang, as described in the following sections. Users must provide these values for encoding according to the representation, as shown in the following example:</source>
          <target state="translated">每个ASN.1类型的值在Erlang中都有自己的表示方式,在下面的章节中描述。用户必须根据表示法提供这些值进行编码,如下例所示。</target>
        </trans-unit>
        <trans-unit id="3cda52f885cae0f363921f91bfa5571c49510a4d" translate="yes" xml:space="preserve">
          <source>The values of the largest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">最大多块载波大小（ &lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt; ）的值</target>
        </trans-unit>
        <trans-unit id="dcd3ad0ab905a987c601beb85b07dfe07ff7ed75" translate="yes" xml:space="preserve">
          <source>The values of the previously listed thresholds can be specified by the user. This way, a handler can be configured to, for example, not drop or flush messages unless the message queue length of the handler process grows extremely large. Notice that large amounts of memory can be required for the node under such circumstances. Another example of user configuration is when, for performance reasons, the client processes must never be blocked by synchronous log requests. It is possible, perhaps, that dropping or flushing events is still acceptable, since it does not affect the performance of the client processes sending the log events.</source>
          <target state="translated">前面列出的阈值可以由用户指定。这样,可以将处理程序配置为,例如,除非处理程序进程的消息队列长度增长得非常大,否则不会丢弃或刷新消息。注意,在这种情况下,节点可能需要大量的内存。另一个用户配置的例子是,出于性能考虑,客户端进程决不能被同步日志请求阻塞。也许,丢弃或刷新事件仍然是可以接受的,因为它不会影响发送日志事件的客户端进程的性能。</target>
        </trans-unit>
        <trans-unit id="20d445c310ac867e11827b280d08f4096d3c3c12" translate="yes" xml:space="preserve">
          <source>The values stored when &lt;code&gt;put&lt;/code&gt; is evaluated within the scope of a &lt;code&gt;catch&lt;/code&gt; are not retracted if a &lt;code&gt;throw&lt;/code&gt; is evaluated, or if an error occurs.</source>
          <target state="translated">当存储的值 &lt;code&gt;put&lt;/code&gt; 被一个的范围内评价 &lt;code&gt;catch&lt;/code&gt; 如果不缩回 &lt;code&gt;throw&lt;/code&gt; 被评估，或者如果发生错误。</target>
        </trans-unit>
        <trans-unit id="f0e48d6dd38ad6c9102722d33252c5ae65615ba8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;$ERL_TOP&lt;/code&gt; will be mentioned a lot of times. It refers to the top directory in the source tree. More information about &lt;code&gt;$ERL_TOP&lt;/code&gt; can be found in the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; section below. If you are building in git you probably want to take a look at the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section below before proceeding.</source>
          <target state="translated">变量 &lt;code&gt;$ERL_TOP&lt;/code&gt; 将被多次提及。它引用源树中的顶层目录。有关 &lt;code&gt;$ERL_TOP&lt;/code&gt; 更多信息 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; 下面的make和$ ERL_TOP部分。如果您正在使用git进行 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 在继续操作之前，可能要先阅读下面的&amp;ldquo; 在Git中构建&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b71a4a47f8b57681eb67d0f149cf4d7c4811e3e6" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$$'&lt;/code&gt; expands to a list of the values of all bound variables in order (that is, &lt;code&gt;['$1','$2', ...]&lt;/code&gt;).</source>
          <target state="translated">变量 &lt;code&gt;'$$'&lt;/code&gt; 按顺序扩展到所有绑定变量的值的列表（即 &lt;code&gt;['$1','$2', ...]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e92c9812c408c5ff3803c9050d025112ca40670" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$_'&lt;/code&gt; expands to the whole &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; term.</source>
          <target state="translated">变量 &lt;code&gt;'$_'&lt;/code&gt; 扩展为整个 &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; 词。</target>
        </trans-unit>
        <trans-unit id="223547b0ee006d68fdeafe7dbabcdb4195ccc06b" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;Bin&lt;/code&gt; must contain a whole number of bytes, because the &lt;code&gt;binary&lt;/code&gt; type defaults to &lt;code&gt;unit:8&lt;/code&gt;. A &lt;code&gt;badarg&lt;/code&gt; exception is generated if &lt;code&gt;Bin&lt;/code&gt; consist of, for example, 17 bits.</source>
          <target state="translated">变量 &lt;code&gt;Bin&lt;/code&gt; 必须包含整数个字节，因为 &lt;code&gt;binary&lt;/code&gt; 类型默认为 &lt;code&gt;unit:8&lt;/code&gt; 。甲 &lt;code&gt;badarg&lt;/code&gt; 如果产生异常 &lt;code&gt;Bin&lt;/code&gt; 组成的，例如，17位。</target>
        </trans-unit>
        <trans-unit id="b327cd3ab139aaaeb5479b3a8cd2e03a44cba9d4" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the bit string comprehensions.</source>
          <target state="translated">生成器模式中的变量,函数子句中的影子变量,围绕位串理解。</target>
        </trans-unit>
        <trans-unit id="ba7b76fc37dd4760f96fd86e277ce66335f21492" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the list comprehensions.</source>
          <target state="translated">生成器模式中的变量,函数子句中的影子变量,围绕列表理解。</target>
        </trans-unit>
        <trans-unit id="c3cbd2f6779e41d23e6821f5cc806aa75af8d5cf" translate="yes" xml:space="preserve">
          <source>The variables in the specified test system configuration files are imported for the test.</source>
          <target state="translated">指定的测试系统配置文件中的变量被导入测试。</target>
        </trans-unit>
        <trans-unit id="16b31340c6df5777f901eec1b8dd72202ecc99a3" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;iodata()&lt;/code&gt; that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</source>
          <target state="translated">&lt;code&gt;iodata()&lt;/code&gt; 的变体，它使用当前的实现（通常是二进制文件，但不依赖于它）提供最少的数据复制。</target>
        </trans-unit>
        <trans-unit id="7db0c9c9f81aaee69d11da93235542d480ff9436" translate="yes" xml:space="preserve">
          <source>The variants &lt;code&gt;http_bin&lt;/code&gt; and &lt;code&gt;httph_bin&lt;/code&gt; return strings (&lt;code&gt;HttpString&lt;/code&gt;) as binaries instead of lists.</source>
          <target state="translated">变体 &lt;code&gt;http_bin&lt;/code&gt; 和 &lt;code&gt;httph_bin&lt;/code&gt; 返回字符串（ &lt;code&gt;HttpString&lt;/code&gt; ）作为二进制文件而不是列表。</target>
        </trans-unit>
        <trans-unit id="386d7a023ddb83a55d49c04d2e00b77bbc947fdc" translate="yes" xml:space="preserve">
          <source>The verb name comes from the observation that it can be used for a pattern-based if-then-else block:</source>
          <target state="translated">动词名称来自于观察,它可以用于基于模式的if-then-else块。</target>
        </trans-unit>
        <trans-unit id="e53a018823f7d0826b490411f9a345448e7e805f" translate="yes" xml:space="preserve">
          <source>The verbs described above provide four different &quot;strengths&quot; of control when subsequent matching fails:</source>
          <target state="translated">上述动词在后续匹配失败时提供了四种不同的控制 &quot;力度&quot;。</target>
        </trans-unit>
        <trans-unit id="f2b992bf8000e459ed5b0cdc131fc96ec8dcdccf" translate="yes" xml:space="preserve">
          <source>The verification fun is called during the X509-path validation when an error or an extension unknown to the SSL application is encountered. It is also called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. It differentiates between the peer certificate and the CA certificates by using &lt;code&gt;valid_peer&lt;/code&gt; or &lt;code&gt;valid&lt;/code&gt; as second argument to the verification fun. See the &lt;code&gt;public_key User's Guide&lt;/code&gt; for definition of &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; and &lt;code&gt;#'Extension'{}&lt;/code&gt;.</source>
          <target state="translated">当遇到错误或SSL应用程序未知的扩展名时，将在X509路径验证期间调用验证乐趣。当路径验证认为证书有效时，也将调用此方法，以允许访问用户应用程序路径中的每个证书。通过使用 &lt;code&gt;valid_peer&lt;/code&gt; 或 &lt;code&gt;valid&lt;/code&gt; 作为验证功能的第二个参数，它区分对等证书和CA证书。有关 &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; 和 &lt;code&gt;#'Extension'{}&lt;/code&gt; 的定义，请参见 &lt;code&gt;public_key User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1de90c0b2842f11f7973bd5edddedba51c5c85c5" translate="yes" xml:space="preserve">
          <source>The verification fun is to be defined as follows:</source>
          <target state="translated">核查乐趣的定义如下:</target>
        </trans-unit>
        <trans-unit id="a7587f36555080700643b0019cdfdef45f4827cd" translate="yes" xml:space="preserve">
          <source>The version is defined by the module attribute &lt;code&gt;vsn&lt;/code&gt;, if any. There is no such attribute in &lt;code&gt;ch3&lt;/code&gt;, so in this case the version is the checksum (a huge integer) of the beam file, an uninteresting value, which is ignored.</source>
          <target state="translated">版本由模块属性 &lt;code&gt;vsn&lt;/code&gt; （如果有）定义。 &lt;code&gt;ch3&lt;/code&gt; 中没有这样的属性，因此在这种情况下，版本是波束文件的校验和（一个巨大的整数），一个无意义的值，将被忽略。</target>
        </trans-unit>
        <trans-unit id="b6440cebe392d666b5024e49f82c9929c9694517" translate="yes" xml:space="preserve">
          <source>The version numbers differ in your system. Whenever one of the applications included in the script is upgraded, change the script.</source>
          <target state="translated">您的系统中的版本号不同。每当脚本中包含的一个应用程序升级时,请更改脚本。</target>
        </trans-unit>
        <trans-unit id="81ee8706973e7d65b914ed727a2144141d282b58" translate="yes" xml:space="preserve">
          <source>The version of an application specified in the &lt;code&gt;.rel&lt;/code&gt; file is to be the same as the version specified in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">在指定的应用程序的版本 &lt;code&gt;.rel&lt;/code&gt; 文件将是相同的指定的版本 &lt;code&gt;.app&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d2168251640676c1f75844920669340f83623b6f" translate="yes" xml:space="preserve">
          <source>The version of net-if provided by this application makes no use of this data, with one exception: Any tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; may be used by the agent and is therefor &lt;strong&gt;reserved&lt;/strong&gt;.</source>
          <target state="translated">此应用程序提供的net-if版本不使用此数据，但有一个例外：代理可以使用任何包含原子 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 的元组，因此&lt;strong&gt;保留&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="35ae167373b6abecea965d3976c2d1e8cb0f8001" translate="yes" xml:space="preserve">
          <source>The version of the application. In an installed system there may exist several versions of an application. The &lt;code&gt;vsn&lt;/code&gt; parameter controls which version of the application will be chosen.</source>
          <target state="translated">应用程序的版本。在已安装的系统中，可能存在一个应用程序的多个版本。所述 &lt;code&gt;vsn&lt;/code&gt; 该应用程序的版本将被选择的参数的控制。</target>
        </trans-unit>
        <trans-unit id="0f6691af69660ac2dbeef6458e54f6b092b02a7f" translate="yes" xml:space="preserve">
          <source>The version scheme was changed as of OTP 17.0. This implies that application versions used prior to OTP 17.0 do not adhere to this version scheme. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; is included at the end of this section</source>
          <target state="translated">从OTP 17.0开始，版本方案已更改。这意味着在OTP 17.0之前使用的应用程序版本不遵循该版本方案。本节末尾包含 &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71667a4b4c466db83cfa8dccda4dd2b33a602563" translate="yes" xml:space="preserve">
          <source>The versions are defined in following RFCs</source>
          <target state="translated">这些版本在以下RFC中定义</target>
        </trans-unit>
        <trans-unit id="b4892e73c1831bf8a3d6b46b7aa415cf267e8507" translate="yes" xml:space="preserve">
          <source>The viewed trace data is normally collected from Erlang trace ports or files.</source>
          <target state="translated">所查看的跟踪数据通常是从 Erlang 跟踪端口或文件中收集的。</target>
        </trans-unit>
        <trans-unit id="4c8e60b869b23fc7c125b17fff74830d66f135c3" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_NET_RAW&lt;/code&gt;.</source>
          <target state="translated">虚拟机还需要提升的特权，这些特权可以以超级用户身份运行或（对于Linux）具有 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 能力。</target>
        </trans-unit>
        <trans-unit id="cc464fdb800c73159385639322d0fc6141087504" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; according to the documentation for &lt;code&gt;setns(2)&lt;/code&gt;. However, during testing also &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; and &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; have proven to be necessary.</source>
          <target state="translated">根据 &lt;code&gt;setns(2)&lt;/code&gt; 的文档，虚拟机还需要提升的特权，以超级用户身份运行或（对于Linux）以 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 能力运行。但是，在测试过程中， &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; 和 &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; 也被证明是必需的。</target>
        </trans-unit>
        <trans-unit id="006ddc155b00e369e7d44f1b15919a8110bdd467" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows and MacOS X.</source>
          <target state="translated">虚拟机在处理文件名时,就像使用UTF-8编码(或其他系统特定的Unicode编码)一样。这是强制执行Unicode编码的操作系统(即Windows和MacOS X)的默认设置。</target>
        </trans-unit>
        <trans-unit id="c517daaf8ca72cb9652e4e1b82ea25a6ea34e353" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using the ISO Latin-1 encoding, disallowing Unicode characters with code points &amp;gt; 255.</source>
          <target state="translated">虚拟机使用文件名，就像使用ISO Latin-1编码对文件名进行编码一样，不允许代码点&amp;gt; 255的Unicode字符。</target>
        </trans-unit>
        <trans-unit id="13ed31f912a0c3756dff51206169f32f13717017" translate="yes" xml:space="preserve">
          <source>The wanted string encoding is specified by &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt;. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from &lt;code&gt;*was&lt;/code&gt;. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from &lt;code&gt;*result&lt;/code&gt;. Both &lt;code&gt;was&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;*result&lt;/code&gt; can differ from &lt;code&gt;want&lt;/code&gt; if &lt;code&gt;want&lt;/code&gt; is a bitwise OR'd combination like &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; or if &lt;code&gt;*result&lt;/code&gt; turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</source>
          <target state="translated">所需的字符串编码由 &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt; 指定。可以从 &lt;code&gt;*was&lt;/code&gt; 获得二进制格式（Latin-1或UTF-8）中使用的原始编码。可以从 &lt;code&gt;*result&lt;/code&gt; 获得结果字符串的编码（7位ASCII，Latin-1或UTF-8）。无论 &lt;code&gt;was&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 可以为 &lt;code&gt;NULL&lt;/code&gt; 。 &lt;code&gt;*result&lt;/code&gt; 可以从不同 &lt;code&gt;want&lt;/code&gt; 如果 &lt;code&gt;want&lt;/code&gt; 是按位或运算等的组合 &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; 或者如果 &lt;code&gt;*result&lt;/code&gt; 证明是纯的7位ASCII码（同时兼容的Latin-1和UTF-8）。</target>
        </trans-unit>
        <trans-unit id="018d5b3762ed16f8137ce9fdaea1d65522f0b4e2" translate="yes" xml:space="preserve">
          <source>The warning for the first clause says that the creation of a sub binary cannot be delayed, because it will be returned. The warning for the second clause says that a sub binary will not be created (yet).</source>
          <target state="translated">第一个子句的警告说,子二进制的创建不能被延迟,因为它将被返回。第二个子句的警告是说,子二进制的创建不会(还没有)。</target>
        </trans-unit>
        <trans-unit id="5ce61e8b18d0497bc2e9762acc6fdf3697ac3b7b" translate="yes" xml:space="preserve">
          <source>The warning is given if the number of shift/reduce conflicts differs from 2, or if there are reduce/reduce conflicts.</source>
          <target state="translated">如果移位/缩位冲突的数量与2不同,或者存在缩位/缩位冲突,则发出警告。</target>
        </trans-unit>
        <trans-unit id="eac3dbbed6bc0bb402c42ed8978c9b0740688aad" translate="yes" xml:space="preserve">
          <source>The warning message will look like this:</source>
          <target state="translated">警告信息会是这样的。</target>
        </trans-unit>
        <trans-unit id="40ff587868921130f6eb1c6a720b2933f27272e9" translate="yes" xml:space="preserve">
          <source>The warnings detected include:</source>
          <target state="translated">检测到的警告包括:</target>
        </trans-unit>
        <trans-unit id="57441a0a1920375468fcb3cda7b741895e7ab716" translate="yes" xml:space="preserve">
          <source>The warnings look as follows:</source>
          <target state="translated">警告内容如下:</target>
        </trans-unit>
        <trans-unit id="3bcce3258cf3577717dad6c74c35c711e27cd4cd" translate="yes" xml:space="preserve">
          <source>The way EUnit represents tests and test sets as data is flexible, powerful, and concise. This section describes the representation in detail.</source>
          <target state="translated">EUnit 将测试和测试集表示为数据的方式灵活、强大、简洁。本节将详细介绍这种表示方式。</target>
        </trans-unit>
        <trans-unit id="965b7339512f62c1c68183166bad964a056729e8" translate="yes" xml:space="preserve">
          <source>The web-based GUI, Virtual Test Server (VTS), is started with the &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program. From the GUI, you can load configuration files and select directories, suites, and cases to run. You can also state the configuration files, directories, suites, and cases on the command line when starting the web-based GUI.</source>
          <target state="translated">基于Web的GUI虚拟测试服务器（VTS）是使用 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 程序启动的。从GUI，您可以加载配置文件并选择要运行的目录，套件和案例。启动基于Web的GUI时，还可以在命令行上声明配置文件，目录，套件和案例。</target>
        </trans-unit>
        <trans-unit id="6550d3349d235f242c72f62c04f437d2ce48c34b" translate="yes" xml:space="preserve">
          <source>The well-known quick sort routine can be written as follows:</source>
          <target state="translated">著名的快速排序例程可以写成如下。</target>
        </trans-unit>
        <trans-unit id="1daf9c055686d26205a86325249ab61a258c6aa6" translate="yes" xml:space="preserve">
          <source>The whole list comprehension must be given to the function &lt;code&gt;qlc:q/1&lt;/code&gt;.</source>
          <target state="translated">整个列表理解必须赋予函数 &lt;code&gt;qlc:q/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a700c9c164740d8193a70ef5191bc6f87818b7c6" translate="yes" xml:space="preserve">
          <source>The whole original data chunk attempted to be sent.</source>
          <target state="translated">整个原始数据块尝试发送。</target>
        </trans-unit>
        <trans-unit id="3f50dc8a9a7232f081e9d82f5c58d1d5ab88774d" translate="yes" xml:space="preserve">
          <source>The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">通配符字符串看起来就像一个普通的文件名,除了以下的 &quot;通配符字符 &quot;会以一种特殊的方式解释。</target>
        </trans-unit>
        <trans-unit id="445ca2425df9850fe9ecf76a693661ab20880f20" translate="yes" xml:space="preserve">
          <source>The window is divided into the following five parts:</source>
          <target state="translated">窗口分为以下五个部分。</target>
        </trans-unit>
        <trans-unit id="3c5d5fc6a6c1a668ddf6252dfa60f0a768f4fd44" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;LINE&lt;/code&gt; in this section represents an integer, and denotes the number of the line in the source file where the construction occurred. Several instances of &lt;code&gt;LINE&lt;/code&gt; in the same construction can denote different lines.</source>
          <target state="translated">本节中的单词 &lt;code&gt;LINE&lt;/code&gt; 表示整数，并表示源文件中发生构造的行号。同一构造中 &lt;code&gt;LINE&lt;/code&gt; 的多个实例可以表示不同的线。</target>
        </trans-unit>
        <trans-unit id="eade7caf0a719386f3ed9bf0405c428ad15ea3eb" translate="yes" xml:space="preserve">
          <source>The workflow is as follows:</source>
          <target state="translated">工作流程如下:</target>
        </trans-unit>
        <trans-unit id="c9930007b7ab7effc4f3827d9e45f7224f2de6c3" translate="yes" xml:space="preserve">
          <source>The working directory for the Erlang emulator. Must be on a local drive (no network drives are mounted when a service starts). Default working directory for services is &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt;. Debug log files will be placed in this directory.</source>
          <target state="translated">Erlang仿真器的工作目录。必须在本地驱动器上（服务启动时未安装网络驱动器）。服务的默认工作目录为 &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt; 。调试日志文件将放置在此目录中。</target>
        </trans-unit>
        <trans-unit id="256bb673e1707d94ab2537efadaa95bffde4c53b" translate="yes" xml:space="preserve">
          <source>The written string is always &lt;code&gt;NULL&lt;/code&gt;-terminated, unless buffer &lt;code&gt;size&lt;/code&gt; is &amp;lt; &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">除非缓冲区 &lt;code&gt;size&lt;/code&gt; 小于 &lt;code&gt;1&lt;/code&gt; ，否则写入的字符串始终以 &lt;code&gt;NULL&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="8f7a1436c802ad678039fa82fd904d4269922bbb" translate="yes" xml:space="preserve">
          <source>The wxWidgets-3.1 version should also work if 2.8 compatibility is enabled, add &lt;code&gt;--enable-compat28&lt;/code&gt; to configure commands below.</source>
          <target state="translated">如果启用了2.8兼容性，则wxWidgets-3.1版本也应该工作，请添加 &lt;code&gt;--enable-compat28&lt;/code&gt; 来配置以下命令。</target>
        </trans-unit>
        <trans-unit id="8a53a91ff254f2bc93279dc81109c603e90d0d26" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec.</source>
          <target state="translated">xmerl_xpath模块处理整个XPath 1.0规范。</target>
        </trans-unit>
        <trans-unit id="119bf8dc786018631b7988a88beda339c2ba800b" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec. XPath expressions typically occur in XML attributes and are used to address parts of an XML document. The grammar is defined in &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt;. The core functions are defined in &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt;.</source>
          <target state="translated">xmerl_xpath模块处理整个XPath 1.0规范。XPath表达式通常出现在XML属性中，并用于寻址XML文档的某些部分。语法在 &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt; 中定义。核心功能在 &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="f0a5d4ec5e9af18ded993eb6992af6fcaadb42e4" translate="yes" xml:space="preserve">
          <source>The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported.</source>
          <target state="translated">zip模块支持6.1以下的压缩包版本。但是,不支持密码保护和Zip64。</target>
        </trans-unit>
        <trans-unit id="f89ec6f488689cc3f3700cb5183e203d59254205" translate="yes" xml:space="preserve">
          <source>The | operator can also be used to add a head to a list:</source>
          <target state="translated">操作符&quot;|&quot;也可以用来在列表中添加一个头部。</target>
        </trans-unit>
        <trans-unit id="40fe3907425ba07df22ef0d6959c2d137d54e469" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;m1&lt;/code&gt; is cover compiled in test run &lt;code&gt;s2&lt;/code&gt;, but not shown in the coverage log. Instead, if &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; is called after both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; test runs are completed, the accumulated result for &lt;code&gt;m1&lt;/code&gt; is available in the cross cover log for test run &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">然后，在测试运行 &lt;code&gt;s2&lt;/code&gt; 中对 &lt;code&gt;m1&lt;/code&gt; 进行覆盖编译，但未在coverage日志中显示。相反，如果在 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 测试运行均完成之后调用 &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; ,则在 &lt;code&gt;m1&lt;/code&gt; 的累积结果可在测试运行 &lt;code&gt;s1&lt;/code&gt; 的跨封面日志中找到。</target>
        </trans-unit>
        <trans-unit id="a8047a09730147dedb7e9d78a5e192ccf03ab6c4" translate="yes" xml:space="preserve">
          <source>Then go to the cross host system and setup the erlang installed in (4) or (5) to be in your &lt;code&gt;$PATH&lt;/code&gt;. Then go to what previously was &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; and issue the following command.</source>
          <target state="translated">然后转到跨主机系统，并将（4）或（5）中安装的erlang设置为 &lt;code&gt;$PATH&lt;/code&gt; 。然后转到以前的 &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; 并发出以下命令。</target>
        </trans-unit>
        <trans-unit id="d8c63d4c24a80d8a897066cde6b4458486a7ca80" translate="yes" xml:space="preserve">
          <source>Then one column per state is printed with a the percentage of time this thread spent in the state out of it's own real-time. After the thread specific time, the accumulated time for each type of thread is printed in a similar format.</source>
          <target state="translated">然后每一个状态打印一列,写着这个线程在该状态下花费的时间占自己实时时间的百分比。在具体的线程时间之后,以类似的格式打印出各类线程的累计时间。</target>
        </trans-unit>
        <trans-unit id="58043576d5fe13fa1a246436e2e8c6ef745d143f" translate="yes" xml:space="preserve">
          <source>Then proceed as follows:</source>
          <target state="translated">然后按以下步骤进行:</target>
        </trans-unit>
        <trans-unit id="7d9412fbd0462825f974f875c15e384433c2ca1a" translate="yes" xml:space="preserve">
          <source>Then read the trace file and create the raw profile data with &lt;code&gt;fprof:profile()&lt;/code&gt;, or perhaps &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; for non-default filename.</source>
          <target state="translated">然后读取跟踪文件，并使用 &lt;code&gt;fprof:profile()&lt;/code&gt; 或使用 &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; 非默认文件名的原始配置文件数据。</target>
        </trans-unit>
        <trans-unit id="5663aeb9e710685d724afdba3fc67379b487af35" translate="yes" xml:space="preserve">
          <source>Then the compact text version without indentation and with short keywords:</source>
          <target state="translated">然后是无缩进、有短关键词的精简版文本。</target>
        </trans-unit>
        <trans-unit id="139ac9c79449e95e5f9e070852b997046b48832a" translate="yes" xml:space="preserve">
          <source>Then the compact version without indentation and with short keywords:</source>
          <target state="translated">然后是无缩进、有短关键词的精简版。</target>
        </trans-unit>
        <trans-unit id="641d01dad066a8551404d7310477baa1cb6f8772" translate="yes" xml:space="preserve">
          <source>Then the new event handler &lt;code&gt;Handler2&lt;/code&gt; is added and initiated by calling &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Module2&lt;/code&gt; is the callback module of &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module1:terminate/2&lt;/code&gt;. This makes it possible to transfer information from &lt;code&gt;Handler1&lt;/code&gt; to &lt;code&gt;Handler2&lt;/code&gt;.</source>
          <target state="translated">然后，通过调用 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 添加和启动新的事件处理程序 &lt;code&gt;Handler2&lt;/code&gt; ，其中 &lt;code&gt;Module2&lt;/code&gt; 是 &lt;code&gt;Handler2&lt;/code&gt; 的回调模块，而 &lt;code&gt;Term&lt;/code&gt; 是 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 的返回值。这使得可以将信息从 &lt;code&gt;Handler1&lt;/code&gt; 传输到 &lt;code&gt;Handler2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c562a001db2c4ae28ac1742e8925ddf8af7163" translate="yes" xml:space="preserve">
          <source>Then the sublists are sorted and the results are combined.</source>
          <target state="translated">然后对子列表进行排序,并对结果进行合并。</target>
        </trans-unit>
        <trans-unit id="73b24c998d871947414c80ba0ded68c358316e6c" translate="yes" xml:space="preserve">
          <source>Then we continue with the call flow on the destination side:</source>
          <target state="translated">然后我们继续在目的端进行呼叫流转。</target>
        </trans-unit>
        <trans-unit id="b5acd2104208de4c3faf2546e133d8d457c2a417" translate="yes" xml:space="preserve">
          <source>Then you can add your favorite application my_app to the new PLT:</source>
          <target state="translated">然后你可以将你喜欢的应用程序my_app添加到新的PLT中。</target>
        </trans-unit>
        <trans-unit id="d31669bbfe7c81803e33f753695ac857feb8b190" translate="yes" xml:space="preserve">
          <source>Then you can proceed as follows:</source>
          <target state="translated">那么你可以进行如下操作。</target>
        </trans-unit>
        <trans-unit id="78475e203a352f84ea57f7b84f34d9e978f720ec" translate="yes" xml:space="preserve">
          <source>Then you can run it through the export_simple/2 function:</source>
          <target state="translated">然后你可以通过export_simple/2函数运行它。</target>
        </trans-unit>
        <trans-unit id="7e9e10c047b34e0b14a433931956d6784d8af0a2" translate="yes" xml:space="preserve">
          <source>Then you send events to the &lt;code&gt;Collector&lt;/code&gt; with the function &lt;code&gt;et_collector:report_event/6&lt;/code&gt; like this:</source>
          <target state="translated">然后使用函数 &lt;code&gt;et_collector:report_event/6&lt;/code&gt; 将事件发送到 &lt;code&gt;Collector&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="32ec0c3065e7c7e83edd0f5ba55760ca9ae6826d" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and specify type &lt;code&gt;{file,File}&lt;/code&gt;.:</source>
          <target state="translated">然后，添加一个新的处理程序，将其打印到文件中。您可以使用处理程序模块 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; ，并指定类型 &lt;code&gt;{file,File}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6ff57f64121d7cfa622102225ba9e153cee5fdd8" translate="yes" xml:space="preserve">
          <source>Then, all loaded modules are listed. The following fields exist:</source>
          <target state="translated">然后,列出所有加载的模块。存在以下字段:</target>
        </trans-unit>
        <trans-unit id="37285406a539aba18b235f1780c7ea66141aed2d" translate="yes" xml:space="preserve">
          <source>Then, an &lt;strong&gt;application specification&lt;/strong&gt; is needed, which is put in an &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt;. Among other things, this file specifies which modules the application consists of and the name of the callback module.</source>
          <target state="translated">然后，需要一个&lt;strong&gt;应用程序规范&lt;/strong&gt;，该&lt;strong&gt;规范&lt;/strong&gt;被放在 &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt; 。除其他外，该文件指定应用程序包含哪些模块以及回调模块的名称。</target>
        </trans-unit>
        <trans-unit id="6b038b9a866b08fa7aa12d5de74309b996761d25" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;strong&gt;system event&lt;/strong&gt; to be logged or traced, the following function is to be called.</source>
          <target state="translated">然后，对于要记录或跟踪的每个&lt;strong&gt;系统事件&lt;/strong&gt;，将调用以下函数。</target>
        </trans-unit>
        <trans-unit id="b2b275200d1a22a2d00f625e244ca1c19bb04f51" translate="yes" xml:space="preserve">
          <source>Then, for the primary application and each included application in top-down, left-to-right order, the application master calls &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; for each phase defined for the primary application, in that order. If a phase is not defined for an included application, the function is not called for this phase and application.</source>
          <target state="translated">然后，对于主应用程序和每个包含的应用程序，按从上到下的顺序（从左到右），应用程序主控器按该顺序为为主应用程序定义的每个阶段调用 &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; 。如果未为包含的应用程序定义阶段，则不会为该阶段和应用程序调用该函数。</target>
        </trans-unit>
        <trans-unit id="9bce82c8d0395aa60449fa59c5a8cfb50a252f9b" translate="yes" xml:space="preserve">
          <source>Then, you can use the &lt;code&gt;?Q(Text)&lt;/code&gt; macros in your code to create ASTs or match on existing ASTs. For example:</source>
          <target state="translated">然后，您可以在代码中使用 &lt;code&gt;?Q(Text)&lt;/code&gt; 宏来创建AST或与现有AST匹配。例如：</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="54025678c0a48ad36d078ae7c486444ea8302d6e" translate="yes" xml:space="preserve">
          <source>There are 146097 days in a 400 year period.</source>
          <target state="translated">400年中有146097天。</target>
        </trans-unit>
        <trans-unit id="4922e83fd8840f5a8507bbf756cb975adb85c4c4" translate="yes" xml:space="preserve">
          <source>There are 1461 days in a 4 year period.</source>
          <target state="translated">4年内有1461天。</target>
        </trans-unit>
        <trans-unit id="a006b5eea15a1aff01c844f4450c0802ffc7c5a3" translate="yes" xml:space="preserve">
          <source>There are 3 categories of events: &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;internal&lt;/code&gt;.</source>
          <target state="translated">事件分为3类： &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;internal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2631fe7788bb799ec0d53ee0b2da8319a05517e4" translate="yes" xml:space="preserve">
          <source>There are 3 types of timeout events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">状态机可以使用相应的 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 为其自身生成3种超时事件。</target>
        </trans-unit>
        <trans-unit id="32e2588a4d8a20d2c12320bd314f5979f4fc80b1" translate="yes" xml:space="preserve">
          <source>There are 365 days in an ordinary year.</source>
          <target state="translated">普通一年有365天。</target>
        </trans-unit>
        <trans-unit id="d970b2470b79eb6a87c891f0b7f5a8f224ef200c" translate="yes" xml:space="preserve">
          <source>There are 36524 days in a 100 year period.</source>
          <target state="translated">100年内有36524天。</target>
        </trans-unit>
        <trans-unit id="dd3485b6c23bf0750711aa938792fc3cb9795cf2" translate="yes" xml:space="preserve">
          <source>There are 366 days in a leap year.</source>
          <target state="translated">闰年有366天。</target>
        </trans-unit>
        <trans-unit id="e5fe64c83f46614adbd1fbe2801f7f2ef313c16d" translate="yes" xml:space="preserve">
          <source>There are 719528 days between Jan 1, 0 and Jan 1, 1970.</source>
          <target state="translated">0年1月1日到1970年1月1日之间有719528天。</target>
        </trans-unit>
        <trans-unit id="f35333b685e5533111f684a33ff4796d2d156cad" translate="yes" xml:space="preserve">
          <source>There are 86400 seconds in a day.</source>
          <target state="translated">一天有86400秒。</target>
        </trans-unit>
        <trans-unit id="180512e757bce690ec3e5179e5aff8954ea8a216" translate="yes" xml:space="preserve">
          <source>There are a few other shells available, but in all examples below we assume that you use bash.</source>
          <target state="translated">还有一些其他的shell,但是在下面的所有例子中,我们假设你使用bash。</target>
        </trans-unit>
        <trans-unit id="1edf8f04e2a157900339e6be967c14131457929f" translate="yes" xml:space="preserve">
          <source>There are a number of BIFs for type conversions.</source>
          <target state="translated">类型转换的BIF有很多。</target>
        </trans-unit>
        <trans-unit id="242b6cdf7d5bf2f5010f113ba9575096eca5ab25" translate="yes" xml:space="preserve">
          <source>There are a number of configuration parameter's that control the operation of the transaction sender. In principle, a message with everything stored (ack's and request's) is sent from the process when:</source>
          <target state="translated">有许多配置参数控制事务发送者的操作。原则上,当以下情况发生时,进程会发送一条包含所有存储内容(ACK和请求)的消息:</target>
        </trans-unit>
        <trans-unit id="14ebd1b2612f7ab9a04862c2c58993cbe8294ef0" translate="yes" xml:space="preserve">
          <source>There are also Erlang plugins for other code editors &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt; Atom &lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; and &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">也有用于其他代码编辑器&lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim（vim-erlang）&lt;/a&gt;，&lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt;Atom&lt;/a&gt;，&lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse（ErlIDE）&lt;/a&gt;和&lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA的&lt;/a&gt; Erlang插件。</target>
        </trans-unit>
        <trans-unit id="3ab85aacb25c2dac1de9193bd4c1c96c59434beb" translate="yes" xml:space="preserve">
          <source>There are also buttons to clear the contents of each window.</source>
          <target state="translated">还有一些按钮可以清除每个窗口的内容。</target>
        </trans-unit>
        <trans-unit id="a0e9837f18730715ec49993436d5ae3ed6b58962" translate="yes" xml:space="preserve">
          <source>There are also corresponding trace client types that can read the Erlang trace data format from such files or ports. The &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; function makes use of these Erlang trace clients and redirects the trace data to the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">还有相应的跟踪客户端类型，可以从此类文件或端口读取Erlang跟踪数据格式。该 &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; 功能使得使用这些二郎跟踪客户和重定向跟踪数据的 &lt;code&gt;Collector&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c99ca7c6f5a9145961cb429767668ca00d8aa464" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x&lt;/code&gt; use a dynamic buffer.</source>
          <target state="translated">也有使用动态缓冲区的编码功能。使用它们来编码数据通常更方便。所有的编码功能都有两个版本。以 &lt;code&gt;ei_x&lt;/code&gt; 开头的用户使用动态缓冲区。</target>
        </trans-unit>
        <trans-unit id="7c973e8a6ad46963c3452623094e6dbd1de252e5" translate="yes" xml:space="preserve">
          <source>There are also existing functions in the API that reads from various sources and calls &lt;code&gt;et_collector:report/2&lt;/code&gt;:</source>
          <target state="translated">API中还存在一些从各种来源读取并调用 &lt;code&gt;et_collector:report/2&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="6b0b6ca2d317b12bcab295cfefa25fba1f494f42" translate="yes" xml:space="preserve">
          <source>There are also several open source tools outside of Erlang/OTP that can be used to help profiling. Some of them are:</source>
          <target state="translated">在Erlang/OTP之外,还有一些开源工具可以用来帮助进行剖析。其中一些工具是:</target>
        </trans-unit>
        <trans-unit id="142cde2c5e7c063e8b6e633dcb4d8f992d4a63a0" translate="yes" xml:space="preserve">
          <source>There are also some tools that can be used to get a view of the whole system with more or less overhead.</source>
          <target state="translated">还有一些工具可以用来获取整个系统的视图,开销或多或少。</target>
        </trans-unit>
        <trans-unit id="d345e5c9462888e4d0e72da3171fd099f28666f6" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt; 模块中，还有一些有用的函数可用于SNMP消息的编码和解码。</target>
        </trans-unit>
        <trans-unit id="d2c12c548107750b36f7254260f1588ab2784f00" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;snmp_pdus&lt;/code&gt; 模块中，还有一些有用的函数可用于SNMP消息的编码和解码。</target>
        </trans-unit>
        <trans-unit id="fc4b5b08a6ea2fb2b0f10fe9a664d0767cb557d8" translate="yes" xml:space="preserve">
          <source>There are also two optional functions that may be exported:</source>
          <target state="translated">还有两个可选函数可以导出。</target>
        </trans-unit>
        <trans-unit id="02924d8e6964e4587d120c6a611e73172eec6d8f" translate="yes" xml:space="preserve">
          <source>There are also unary set operators:</source>
          <target state="translated">还有单利集运算符。</target>
        </trans-unit>
        <trans-unit id="18a4256a63577ca8fbaba2b8f665cf1ca462e6b4" translate="yes" xml:space="preserve">
          <source>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</source>
          <target state="translated">使用多个表复制的原因基本上有两个:容错和速度。请注意,表复制为这两个系统要求提供了一个解决方案。</target>
        </trans-unit>
        <trans-unit id="efcb011fbe2418732f8e84878ff0611edcbe6375" translate="yes" xml:space="preserve">
          <source>There are basically two ways to avoid copying a binary that is sent to a driver:</source>
          <target state="translated">基本上有两种方法可以避免复制发送到驱动程序的二进制。</target>
        </trans-unit>
        <trans-unit id="427d1b12162110ab82e9ecb95a1e779c90521928" translate="yes" xml:space="preserve">
          <source>There are different ways to run the mstone1 tool, e.g. with or without the use of drivers, with &lt;strong&gt;only&lt;/strong&gt; flex-empowered configs.</source>
          <target state="translated">有多种方法可以运行mstone1工具，例如，使用或不使用驱动程序，&lt;strong&gt;仅使用&lt;/strong&gt; flex-empowered配置。</target>
        </trans-unit>
        <trans-unit id="83886161e156439b88f864a15f0682e914bef032" translate="yes" xml:space="preserve">
          <source>There are errors in the module.</source>
          <target state="translated">模块中存在错误。</target>
        </trans-unit>
        <trans-unit id="9f2059c62b05489c060b2ff7738b1e0f09fb659b" translate="yes" xml:space="preserve">
          <source>There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern, as described in the previous section.)</source>
          <target state="translated">有五个捕获子串,但只有一个在匹配后被设置。解决这个问题的另一种方法是使用 &quot;分支重置 &quot;子模式,如上一节所述)。</target>
        </trans-unit>
        <trans-unit id="33595bb67b93a0d4d29156619db2bde17172f1a9" translate="yes" xml:space="preserve">
          <source>There are five kinds of atomic literals, which are represented in the same way in patterns, expressions, and guards:</source>
          <target state="translated">原子识字有五种,它们在模式、表达式和卫士中的表现方式是一样的。</target>
        </trans-unit>
        <trans-unit id="51d0a41716062d2a82d15d8d350dc23a6b9ec6b3" translate="yes" xml:space="preserve">
          <source>There are five lists exchanged in the connection setup. Three of them are also divided in two directions, to and from the server.</source>
          <target state="translated">连接设置中共有五个列表交换。其中有三个也是分两个方向,到服务器和从服务器。</target>
        </trans-unit>
        <trans-unit id="cf8e92c428bfd92f9fbf9d5334e7e6eb53e744e5" translate="yes" xml:space="preserve">
          <source>There are five other standard MIBs, which also may be loaded into the agent. These MIBs are:</source>
          <target state="translated">还有五个标准的MIB,也可以加载到代理中。这些MIBs是:</target>
        </trans-unit>
        <trans-unit id="152329e6587feacf4160245f8023f9e4b43d1b9a" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the &lt;code&gt;Application dependencies&lt;/code&gt; page. If the application is used by other applications, these are listed under &lt;code&gt;Used by&lt;/code&gt;. If the application requires other applications be started before it can be started, these are listed under &lt;code&gt;Required&lt;/code&gt;. These applications are listed in the &lt;code&gt;applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application includes other applications, these are listed under &lt;code&gt;Included&lt;/code&gt;. These applications are listed in the &lt;code&gt;included_applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application uses other applications, these are listed under &lt;code&gt;Uses&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Application dependencies&lt;/code&gt; 页面上有四类应用程序。如果该应用程序被其他应用程序使用，则这些应用程序将在&amp;ldquo; &lt;code&gt;Used by&lt;/code&gt; 。如果该应用程序需要先启动其他应用程序，然后才能启动，则这些应用程序将在&amp;ldquo; &lt;code&gt;Required&lt;/code&gt; 。这些应用程序在 &lt;code&gt;applications&lt;/code&gt; &lt;code&gt;app&lt;/code&gt; 文件的应用程序部分中列出。如果该应用程序包括其他应用程序，则这些应用程序将在 &lt;code&gt;Included&lt;/code&gt; 下列出。这些应用程序在 &lt;code&gt;app&lt;/code&gt; 文件的 &lt;code&gt;included_applications&lt;/code&gt; 部分中列出。如果该应用程序使用其他应用程序，则这些应用程序将在&amp;ldquo; &lt;code&gt;Uses&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d82c54f7bd20fbaa9331c2a4418fb92d7a4c19" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the applications page. &lt;code&gt;Included&lt;/code&gt; contains applications that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains applications that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains applications that either are used directly by explicitly included applications or by other derived applications. &lt;code&gt;Available&lt;/code&gt; contains the remaining applications.</source>
          <target state="translated">应用程序页面上有四类应用程序。 &lt;code&gt;Included&lt;/code&gt; 包含显式包含的应用程序。 &lt;code&gt;Excluded&lt;/code&gt; 包含明确排除的应用程序。 &lt;code&gt;Derived&lt;/code&gt; 包含直接由显式包含的应用程序或其他派生应用程序直接使用的应用程序。 &lt;code&gt;Available&lt;/code&gt; 包含剩余的应用程序。</target>
        </trans-unit>
        <trans-unit id="b68efc29dbc075cb27e8313dd48ca56abcbcbd47" translate="yes" xml:space="preserve">
          <source>There are four categories of modules on the modules page. &lt;code&gt;Included&lt;/code&gt; contains modules that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains modules that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains modules that either are used directly by explicitly included modules or by other derived modules. &lt;code&gt;Available&lt;/code&gt; contains the remaining modules.</source>
          <target state="translated">&amp;ldquo;模块&amp;rdquo;页面上有四类模块。 &lt;code&gt;Included&lt;/code&gt; 包含明确包含的模块。 &lt;code&gt;Excluded&lt;/code&gt; 包含明确排除的模块。 &lt;code&gt;Derived&lt;/code&gt; 包含的模块可以由显式包含的模块直接使用，也可以由其他派生模块直接使用。 &lt;code&gt;Available&lt;/code&gt; 包含剩余的模块。</target>
        </trans-unit>
        <trans-unit id="c2b0337aead7f70c27290d4535794d260d389da6" translate="yes" xml:space="preserve">
          <source>There are four different encodings present during the handling of URIs:</source>
          <target state="translated">在处理URI的过程中,有四种不同的编码存在。</target>
        </trans-unit>
        <trans-unit id="413ab333b189c985048445074e9603bae2ba9723" translate="yes" xml:space="preserve">
          <source>There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions.</source>
          <target state="translated">有四种条件:对子模式的引用,对递归的引用,一种叫做DEFINE的伪条件,以及断言。</target>
        </trans-unit>
        <trans-unit id="afecc58bc3779a5734aaac232e18d7916a22144d" translate="yes" xml:space="preserve">
          <source>There are function clauses, if clauses, case clauses, and catch clauses.</source>
          <target state="translated">有功能子句、if子句、大小写子句和捕捉子句。</target>
        </trans-unit>
        <trans-unit id="72251a5ed304e5df93ccf96c6a4cfa369e458578" translate="yes" xml:space="preserve">
          <source>There are however attacks that are not detected by those checks. Suppose a bad guy has succeded with a DNS infection. Then the client could belive it is connecting to one host but ends up at another but evil one. Though it is evil, it could have a perfectly legal certificate! The certificate has a valid signature, it is not revoked, the certificate chain is not faked and has a trusted root and so on.</source>
          <target state="translated">然而,也有一些攻击是这些检查所检测不到的。假设一个坏人成功地感染了DNS。那么客户端可能会相信它正在连接到一个主机,但最终在另一个邪恶的主机。虽然它是邪恶的,但它可能有一个完全合法的证书! 证书有一个有效的签名,它没有被撤销,证书链没有伪造,有一个可信的根等等。</target>
        </trans-unit>
        <trans-unit id="3713f84d148979b203b3befe641b4b77769eb559" translate="yes" xml:space="preserve">
          <source>There are limitations to when you can execute time warp unsafe code using this mode. If it is possible to use time warp safe code only, it is &lt;strong&gt;much&lt;/strong&gt; better to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">使用此模式可以执行时间扭曲不安全代码的时间有所限制。如果能够只使用时间隧道安全的代码，它是&lt;strong&gt;多少&lt;/strong&gt;，最好使用 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 来代替。</target>
        </trans-unit>
        <trans-unit id="cd4bd83b271a665a5b58936e70ef38dadf1155ad" translate="yes" xml:space="preserve">
          <source>There are limitations with this transaction mechanism. If complex dependencies exist between variables, for example between &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;day&lt;/code&gt;, another mechanism is needed. Setting the date to 'Feb 31' can be avoided by a somewhat more generic transaction mechanism. You can continue and find more and more complex situations and construct an N-phase set-mechanism. This toolkit only contains a trivial mechanism.</source>
          <target state="translated">这种交易机制有局限性。如果变量之间存在复杂的依赖关系，例如在 &lt;code&gt;month&lt;/code&gt; 和 &lt;code&gt;day&lt;/code&gt; 之间，则需要另一种机制。通过某种更通用的交易机制可以避免将日期设置为&amp;ldquo; 2月31日&amp;rdquo;。您可以继续查找越来越复杂的情况，并构建N相设定机制。该工具包仅包含一个简单的机制。</target>
        </trans-unit>
        <trans-unit id="439879eaa90ceaba58052efe3928a2c96e71eaa0" translate="yes" xml:space="preserve">
          <source>There are many different ways of writing back references to named subpatterns. The .NET syntax &lt;code&gt;\k{name}&lt;/code&gt; and the Perl syntax &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt; are supported, as is the Python syntax &lt;code&gt;(?P=name)&lt;/code&gt;. The unified back reference syntax in Perl 5.10, in which \g can be used for both numeric and named references, is also supported. The previous example can be rewritten in the following ways:</source>
          <target state="translated">有许多种写回对命名子模式的引用的方法。支持.NET语法 &lt;code&gt;\k{name}&lt;/code&gt; 和Perl语法 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'name'&lt;/code&gt; 也支持Python语法 &lt;code&gt;(?P=name)&lt;/code&gt; 。还支持Perl 5.10中的统一反向引用语法，其中\ g可以用于数字引用和命名引用。可以通过以下方式重写前面的示例：</target>
        </trans-unit>
        <trans-unit id="ed05625b139b4d644de6d7f67ce1fa7c2638ef57" translate="yes" xml:space="preserve">
          <source>There are many kinds of test suites. Some concentrate on calling every function or command (in the documented way) in a certain interface. Some others do the same, but use all kinds of illegal parameters, and verify that the server stays alive and rejects the requests with reasonable error codes. Some test suites simulate an application (typically consisting of a few modules of an application), some try to do tricky requests in general, and some test suites even test internal functions with help of special Load Modules on target.</source>
          <target state="translated">测试套件有很多种类。有些集中在调用某个接口中的每一个函数或命令(以记录的方式)。其他一些测试套件也是这样做的,但是使用了各种非法参数,并验证服务器是否还活着,用合理的错误代码拒绝请求。一些测试套件模拟一个应用程序(通常由应用程序的几个模块组成),一些测试套件尝试做一些棘手的请求,一些测试套件甚至借助目标上的特殊负载模块来测试内部功能。</target>
        </trans-unit>
        <trans-unit id="7c87c0f774843afd2689dfb3a9a1edad461eb107" translate="yes" xml:space="preserve">
          <source>There are many other BIFs such as &lt;code&gt;trunc&lt;/code&gt;. Only a few BIFs can be used in guards, and you cannot use functions you have defined yourself in guards. (see &lt;code&gt;Guard Sequences&lt;/code&gt;) (For advanced readers: This is to ensure that guards do not have side effects.) Let us play with a few of these functions in the shell:</source>
          <target state="translated">还有许多其他BIF，例如 &lt;code&gt;trunc&lt;/code&gt; 。保护中只能使用几个BIF，并且不能使用在保护中定义了自己的功能。（请参阅 &lt;code&gt;Guard Sequences&lt;/code&gt; ）（对于高级读者：这是为了确保Guard不会产生副作用。）让我们在Shell中使用其中一些功能：</target>
        </trans-unit>
        <trans-unit id="7ad50dd0c2f864512dffbc3444e8c2dbdeaa7fbe" translate="yes" xml:space="preserve">
          <source>There are many very useful functions in the &lt;code&gt;lists&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;lists&lt;/code&gt; 模块中有许多非常有用的功能。</target>
        </trans-unit>
        <trans-unit id="ebf4e0ad405ef3fed32697182bdabfe322f69cbb" translate="yes" xml:space="preserve">
          <source>There are more efficient ways to create tables manually, i.e. to use the module &lt;code&gt;snmp_index&lt;/code&gt;.</source>
          <target state="translated">有许多手动创建表的有效方法，即使用模块 &lt;code&gt;snmp_index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd92c71af502e8043671a8043ed8709a47495a40" translate="yes" xml:space="preserve">
          <source>There are more specific state-transition actions that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt;return value&lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible state transition actions:</source>
          <target state="translated">在回调函数返回之后，回调函数可以命令 &lt;code&gt;gen_statem&lt;/code&gt; 引擎执行更具体的状态转换操作。这些都是通过返回的列表指挥 &lt;code&gt;actions&lt;/code&gt; 的 &lt;code&gt;return value&lt;/code&gt; 从 &lt;code&gt;callback function&lt;/code&gt; 。这些是可能的状态转换操作：</target>
        </trans-unit>
        <trans-unit id="b36a2cfd042d4aa3ef25491b61074f01870dd914" translate="yes" xml:space="preserve">
          <source>There are no errors in the module.</source>
          <target state="translated">该模块没有错误。</target>
        </trans-unit>
        <trans-unit id="cf5c5dc136c77b62a5f73ee583f29675f0867a0a" translate="yes" xml:space="preserve">
          <source>There are no good and explicit ways to declare dependencies, so it can be difficult to see and understand these in test suite code and in test logs.</source>
          <target state="translated">没有很好的和明确的方法来声明依赖关系,所以在测试套件代码和测试日志中很难看到和理解这些。</target>
        </trans-unit>
        <trans-unit id="79dc22722039d0f06f11ce0ecbb4a728b9b8c1f7" translate="yes" xml:space="preserve">
          <source>There are no restrictions on the number of bits in the tail.</source>
          <target state="translated">对尾部的位数没有限制。</target>
        </trans-unit>
        <trans-unit id="9e0f9557377e4510903384f151fd0ecbad27b195" translate="yes" xml:space="preserve">
          <source>There are obvious dependencies between the listed functions. The server cannot be configured if it has not first been started, a client connot be connectd until the server is properly configured, and so on. If we want to have one test case for each function, we might be tempted to try to always run the test cases in the stated order and carry possible data (identities, handles, and so on) between the cases and therefore introduce dependencies between them.</source>
          <target state="translated">所列功能之间存在明显的依赖关系。如果服务器没有首先被启动,就无法配置,客户端在服务器被正确配置之前不能被连接,等等。如果我们希望每个函数都有一个测试用例,我们可能会尝试总是按照规定的顺序运行测试用例,并在用例之间携带可能的数据(身份、句柄等),因此在它们之间引入依赖关系。</target>
        </trans-unit>
        <trans-unit id="8523e884f51973cbccd87b9cb2dffcddaeb778e9" translate="yes" xml:space="preserve">
          <source>There are often sufficient means to work around the need for test case dependencies. Generally, the problem is related to the state of the System Under Test (SUT). The action of one test case can change the system state. For some other test case to run properly, this new state must be known.</source>
          <target state="translated">通常有足够的手段来解决测试用例依赖性的需求。一般来说,这个问题与被测系统(SUT)的状态有关。一个测试用例的动作可以改变系统状态。为了使其他一些测试用例能够正常运行,必须知道这个新的状态。</target>
        </trans-unit>
        <trans-unit id="e108f06d2e6b2fe834e0d25027b8927df7aa555e" translate="yes" xml:space="preserve">
          <source>There are other types of runtime systems that can be built as well using the similar steps just described.</source>
          <target state="translated">还有其他类型的运行时系统也可以使用刚才描述的类似步骤来构建。</target>
        </trans-unit>
        <trans-unit id="e163c970efe377af5c8f879ce7a54392863fd666" translate="yes" xml:space="preserve">
          <source>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</source>
          <target state="translated">有几种算法可以将碎片表中的记录均匀地分布在一个节点池上。没有一种是最好的,这取决于应用需求。下面的情况例子需要注意一些。</target>
        </trans-unit>
        <trans-unit id="3da498f3aa13476c3eb92930717e01466d88d04f" translate="yes" xml:space="preserve">
          <source>There are several error cases which may prevent an answer from being received and passed to a &lt;code&gt;handle_answer/4&lt;/code&gt; callback:</source>
          <target state="translated">有几种错误情况可能会阻止接收答案并将其传递到 &lt;code&gt;handle_answer/4&lt;/code&gt; 回调：</target>
        </trans-unit>
        <trans-unit id="d5e18c76899cc79f203e980d3f385f0b37cfdefe" translate="yes" xml:space="preserve">
          <source>There are several implementations provided with the agent: &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt;, &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; and &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt;.</source>
          <target state="translated">代理提供了几种实现： &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt; ， &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; 和 &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3ff816ccd8ec855be66bcf7ca689d7727faafd3" translate="yes" xml:space="preserve">
          <source>There are several occasions when &lt;code&gt;Mnesia&lt;/code&gt; can detect that the network has been partitioned because of a communication failure, for example:</source>
          <target state="translated">在多种情况下， &lt;code&gt;Mnesia&lt;/code&gt; 可以检测到由于通信故障而导致网络已分区，例如：</target>
        </trans-unit>
        <trans-unit id="7c57bfac8bb05da0f5a10e7726d24981a1293333" translate="yes" xml:space="preserve">
          <source>There are several other process flags, see &lt;code&gt;erlang(3)&lt;/code&gt;. Changing the default behaviour of a process in this way is usually not done in standard user programs, but is left to the supervisory programs in OTP. However, the ping pong program is modified to illustrate exit trapping.</source>
          <target state="translated">还有其他几个进程标志，请参见 &lt;code&gt;erlang(3)&lt;/code&gt; 。以这种方式更改过程的默认行为通常不在标准用户程序中完成，而是留给OTP中的监视程序。但是，对乒乓程序进行了修改以说明出口陷阱。</target>
        </trans-unit>
        <trans-unit id="4e75da42e192bf5430b68298e12cdc636289e3c2" translate="yes" xml:space="preserve">
          <source>There are several ways to send a binary created with &lt;code&gt;driver_alloc_binary()&lt;/code&gt;:</source>
          <target state="translated">有多种方法可以发送使用 &lt;code&gt;driver_alloc_binary()&lt;/code&gt; 创建的二进制文件：</target>
        </trans-unit>
        <trans-unit id="75f05fa20e3e2427a955f3a2446bd3c23ed22b34" translate="yes" xml:space="preserve">
          <source>There are several ways to write a metavariable in your quoted code:</source>
          <target state="translated">有几种方法可以在你引用的代码中写一个元变量。</target>
        </trans-unit>
        <trans-unit id="f82aa827e8118fb053e3d4c4658ad116b8c399af" translate="yes" xml:space="preserve">
          <source>There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows:</source>
          <target state="translated">Windows注册表中有六个入口点,即顶层键。在本模块中,它们的缩写如下:</target>
        </trans-unit>
        <trans-unit id="70680607de60b05f98568bdca23a84c98a7353e4" translate="yes" xml:space="preserve">
          <source>There are some new data types in SNMPv2 that are useful in SNMPv1 as well. In the STANDARD-MIB, three data types are defined, &lt;code&gt;RowStatus&lt;/code&gt;, &lt;code&gt;TruthValue&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. These data types are originally defined as textual conventions in SNMPv2-TC (RFC1903).</source>
          <target state="translated">SNMPv2中有一些新数据类型在SNMPv1中也很有用。在STANDARD-MIB中，定义了三种数据类型： &lt;code&gt;RowStatus&lt;/code&gt; ， &lt;code&gt;TruthValue&lt;/code&gt; 和 &lt;code&gt;DateAndTime&lt;/code&gt; 。这些数据类型最初在SNMPv2-TC（RFC1903）中定义为文本约定。</target>
        </trans-unit>
        <trans-unit id="6d7f436b6808fb57326aab28c43cc3d495d3886b" translate="yes" xml:space="preserve">
          <source>There are three built-in trace patterns: &lt;code&gt;exception_trace&lt;/code&gt;, &lt;code&gt;caller_trace&lt;/code&gt; and &lt;code&gt;caller_exception_trace&lt;/code&gt; (or &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;cx&lt;/code&gt; respectively). Exception trace sets a trace which will show function names, parameters, return values and exceptions thrown from functions. Caller traces display function names, parameters and information about which function called it. An example using a built-in alias:</source>
          <target state="translated">共有三种内置跟踪模式： &lt;code&gt;exception_trace&lt;/code&gt; ， &lt;code&gt;caller_trace&lt;/code&gt; 和 &lt;code&gt;caller_exception_trace&lt;/code&gt; （或分别为 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;cx&lt;/code&gt; ）。异常跟踪设置一个跟踪，该跟踪将显示函数名称，参数，返回值和从函数引发的异常。调用者跟踪显示函数名称，参数以及有关哪个函数调用它的信息。使用内置别名的示例：</target>
        </trans-unit>
        <trans-unit id="ce6e977a031f0f78d9783247027132e2871000ad" translate="yes" xml:space="preserve">
          <source>There are three entities: department, employee, and project.</source>
          <target state="translated">有三个实体:部门、员工、项目。</target>
        </trans-unit>
        <trans-unit id="b95942457dca44926353518936009aaa1a127415" translate="yes" xml:space="preserve">
          <source>There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; is subpattern index 1, &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; is subpattern index 2, and &lt;code&gt;(..d)&lt;/code&gt; is subpattern index 3. When matched against the following string:</source>
          <target state="translated">共有三个明确捕获的子模式，其中括号的位置确定结果的顺序，因此 &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; 是子模式索引1， &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; 是子模式索引2，而 &lt;code&gt;(..d)&lt;/code&gt; 是子模式索引3。与以下字符串匹配时：</target>
        </trans-unit>
        <trans-unit id="b9d8071a7cab5fe6bb06cfbf16feb00bf5b9bf05" translate="yes" xml:space="preserve">
          <source>There are three kinds of configuration:</source>
          <target state="translated">有三种配置。</target>
        </trans-unit>
        <trans-unit id="6f596c95045c35d0f6872618b7a800aff23b78f1" translate="yes" xml:space="preserve">
          <source>There are three main reasons for using this mapping:</source>
          <target state="translated">使用这种图谱的原因主要有三个。</target>
        </trans-unit>
        <trans-unit id="21dcf13609dda19f86b7a0c362b1f37accd05aea" translate="yes" xml:space="preserve">
          <source>There are three relationships between these entities:</source>
          <target state="translated">这些实体之间有三种关系。</target>
        </trans-unit>
        <trans-unit id="a6f8a9d2ff844ea14957c3bca79e832dabec9620" translate="yes" xml:space="preserve">
          <source>There are to be no circular dependencies among the applications.</source>
          <target state="translated">各个应用程序之间不存在循环依赖关系。</target>
        </trans-unit>
        <trans-unit id="a76c3a9ace292c2e0f4031bfd80c3c9f908baded" translate="yes" xml:space="preserve">
          <source>There are to be no duplicated modules, that is, modules with the same name but belonging to different applications.</source>
          <target state="translated">不得有重复的模块,即名称相同但属于不同应用的模块。</target>
        </trans-unit>
        <trans-unit id="b018774fca4517707ee8766e662ecc9fb5f61fbf" translate="yes" xml:space="preserve">
          <source>There are to be no undefined applications, that is, dependencies to applications that are not included in the release. (Key &lt;code&gt;applications&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file).</source>
          <target state="translated">不得有未定义的应用程序，也就是说，对发行版中未包含的应用程序的依赖性。（ &lt;code&gt;.app&lt;/code&gt; 文件中的关键 &lt;code&gt;applications&lt;/code&gt; 程序）。</target>
        </trans-unit>
        <trans-unit id="8657af51c1708a2f767083749fec728b2f15dd21" translate="yes" xml:space="preserve">
          <source>There are two Elisp modules included in this tool package for Emacs. There is erlang.el that defines the actual erlang mode and there is erlang-start.el that makes some nice initializations.</source>
          <target state="translated">这个Emacs的工具包中包含了两个Elisp模块,其中有一个是erlang.el,它定义了实际的erlang模式,还有一个是erlang-start.el,它做了一些不错的初始化。其中erlang.el定义了实际的erlang模式,还有erlang-start.el做了一些漂亮的初始化。</target>
        </trans-unit>
        <trans-unit id="4650ca14e027a543e950b128c780c1aff1d2ced2" translate="yes" xml:space="preserve">
          <source>There are two alternatives for &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 有两种选择：</target>
        </trans-unit>
        <trans-unit id="e8bf9361085b975630319d83556ce12329f9229c" translate="yes" xml:space="preserve">
          <source>There are two basic ways to use the binary encodings: With package related name and termination id transformation (the 'native' encoding config) or without. This transformation converts package related names and termination id's to a more convenient internal form (equivalent with the decoded text message).</source>
          <target state="translated">有两种基本的方式来使用二进制编码。使用与包相关的名称和终止ID转换(&quot;原生 &quot;编码配置)或不使用。这种转换将包相关名称和终止ID转换为更方便的内部形式(相当于解码后的文本消息)。</target>
        </trans-unit>
        <trans-unit id="dd1db3d75a354d15737e7ae7563e82290092028f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Dependencies&lt;/code&gt; 页面上有两类模块。如果该模块被其他模块使用，则这些 &lt;code&gt;Modules using this&lt;/code&gt; 将在&amp;ldquo; 使用此模块&amp;rdquo;下列出。如果模块使用其他模块，则这些模块将在&amp;ldquo; &lt;code&gt;Used modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887d7e8bf421025bcb8d521eeed1d2552d08027f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Module dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Module dependencies&lt;/code&gt; 页面上有两类模块。如果该模块被其他模块使用，则这些 &lt;code&gt;Modules using this&lt;/code&gt; 将在&amp;ldquo; 使用此模块&amp;rdquo;下列出。如果模块使用其他模块，则这些模块将在&amp;ldquo; &lt;code&gt;Used modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="599878b5a82e164996281429b80e489ea9c477d5" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">与仅使用普通端口的 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 中的示例相比，在C端使用Erl_Interface有两个区别：</target>
        </trans-unit>
        <trans-unit id="23c004d4c8512a14978a320110e39b1a0ff94575" translate="yes" xml:space="preserve">
          <source>There are two different measurement tools:</source>
          <target state="translated">有两种不同的测量工具。</target>
        </trans-unit>
        <trans-unit id="a94aa96b73c7ee440863f41a5aef58bc994511af" translate="yes" xml:space="preserve">
          <source>There are two implementations available:</source>
          <target state="translated">有两种实现方式。</target>
        </trans-unit>
        <trans-unit id="6b217d8aaa3bcdc7db2e259b15d48c394ea4df29" translate="yes" xml:space="preserve">
          <source>There are two kinds of variables: predefined variables and user variables.  &lt;strong id=&quot;predefined_variable&quot;&gt;Predefined variables&lt;/strong&gt; hold set up module data, and cannot be assigned to but only used in queries.  &lt;strong id=&quot;user_variable&quot;&gt;User variables&lt;/strong&gt; on the other hand can be assigned to, and are typically used for temporary results while evaluating a query, and for keeping results of queries for use in subsequent queries. The predefined variables are (variables marked with (*) are available in &lt;code&gt;functions&lt;/code&gt; mode only):</source>
          <target state="translated">变量有两种：预定义变量和用户变量。 &lt;strong id=&quot;predefined_variable&quot;&gt;预定义变量&lt;/strong&gt;保存设置的模块数据，不能分配给&lt;strong id=&quot;predefined_variable&quot;&gt;变量&lt;/strong&gt;，而只能在查询中使用。 另一方面，&lt;strong id=&quot;user_variable&quot;&gt;用户变量&lt;/strong&gt;可以分配给&lt;strong id=&quot;user_variable&quot;&gt;用户变量&lt;/strong&gt;，通常用于评估查询时的临时结果，并保留查询结果以用于后续查询。预定义的变量为（标有（*）的变量仅在 &lt;code&gt;functions&lt;/code&gt; 模式下可用）：</target>
        </trans-unit>
        <trans-unit id="51e96249f31fef90280598a64efcee667d150bd9" translate="yes" xml:space="preserve">
          <source>There are two known shortcomings in xmerl:</source>
          <target state="translated">xmerl有两个已知的缺点。</target>
        </trans-unit>
        <trans-unit id="cc0e3ffc28ca1f923c575a2ec112ffd273f7f33c" translate="yes" xml:space="preserve">
          <source>There are two options for handling syntax errors (that is when an unexpected event is received when the digit map evaluator is expecting some other event). The unexpected events may either be ignored or rejected. The latter means that the evaluation is aborted and an error is returned.</source>
          <target state="translated">有两种处理语法错误的方法(即当数字图评估器期待其他事件时收到意外事件时)。意外事件可以被忽略或拒绝。后者意味着评估被中止,并返回一个错误。</target>
        </trans-unit>
        <trans-unit id="e7ea701d75f10ddf239c1c9acff7a8b7f85969f9" translate="yes" xml:space="preserve">
          <source>There are two reasons why &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; are not to be used: they are not efficient, and they prevent the use of key &lt;code&gt;'$end_of_table'&lt;/code&gt;, as this atom is used to indicate the end of the table. If possible, use functions &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; for traversing tables.</source>
          <target state="translated">为何不使用 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 的原因有两个：它们效率不高，并且由于使用了这个原子来指示表的结尾，因此它们阻止了键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 使用。如果可能，请使用 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt; 函数，并 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 遍历表。</target>
        </trans-unit>
        <trans-unit id="80545dc051cca46852b43329d06d54cf9d266b54" translate="yes" xml:space="preserve">
          <source>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</source>
          <target state="translated">在使用这个函数而不是读取记录、进行运算和书写记录时,有两个显著的区别。</target>
        </trans-unit>
        <trans-unit id="7dad1bd4e1026419dc7de0c5664baefca6532877" translate="yes" xml:space="preserve">
          <source>There are two special cases for the timeout value &lt;code&gt;ExprT&lt;/code&gt;:</source>
          <target state="translated">超时值 &lt;code&gt;ExprT&lt;/code&gt; 有两种特殊情况：</target>
        </trans-unit>
        <trans-unit id="c56d561a526dd7ff6bad858caa6d005781753b5c" translate="yes" xml:space="preserve">
          <source>There are two types of numeric literals, &lt;strong&gt;integers&lt;/strong&gt; and &lt;strong&gt;floats&lt;/strong&gt;. Besides the conventional notation, there are two Erlang-specific notations:</source>
          <target state="translated">数字文字有两种类型，&lt;strong&gt;整数&lt;/strong&gt;和&lt;strong&gt;浮点数&lt;/strong&gt;。除了传统的符号外，还有两种特定于Erlang的符号：</target>
        </trans-unit>
        <trans-unit id="a3c927021e9667cac0b76e4d583b237c1b874a0a" translate="yes" xml:space="preserve">
          <source>There are two types of unique integers both created using the &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF:</source>
          <target state="translated">有两种类型的唯一整数都使用 &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF创建：</target>
        </trans-unit>
        <trans-unit id="adcec4978d9685360563b69cc57cc9c6d0c475d9" translate="yes" xml:space="preserve">
          <source>There are two versions of the &lt;code&gt;server_transfer&lt;/code&gt; function: one with four arguments (&lt;code&gt;server_transfer/4&lt;/code&gt;) and one with five (&lt;code&gt;server_transfer/5&lt;/code&gt;). These are regarded by Erlang as two separate functions.</source>
          <target state="translated">&lt;code&gt;server_transfer&lt;/code&gt; 函数有两个版本：一个带有四个参数（ &lt;code&gt;server_transfer/4&lt;/code&gt; ），另一个带有五个参数（ &lt;code&gt;server_transfer/5&lt;/code&gt; ）。这些被Erlang视为两个独立的功能。</target>
        </trans-unit>
        <trans-unit id="1b723932d3f965d03f997c2929d90177ac53f1a0" translate="yes" xml:space="preserve">
          <source>There are two ways of shutting down an &lt;code&gt;ssh&lt;/code&gt; daemon, see &lt;strong&gt;Step 5a&lt;/strong&gt; and &lt;strong&gt;Step 5b&lt;/strong&gt;.</source>
          <target state="translated">关闭 &lt;code&gt;ssh&lt;/code&gt; 守护程序有两种方法，请参见&lt;strong&gt;步骤5a&lt;/strong&gt;和&lt;strong&gt;步骤5b&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="67a5f230cec8e69ad074e79327cb344b91c01c42" translate="yes" xml:space="preserve">
          <source>There are two ways to handle the different megaco encoding versions. Either using &lt;strong&gt;dynamic version detection&lt;/strong&gt; (only valid for for incoming messages) or by &lt;strong&gt;explicit version&lt;/strong&gt; setting in the connection info.</source>
          <target state="translated">有两种方法可以处理不同的megaco编码版本。使用&lt;strong&gt;动态版本检测&lt;/strong&gt;（仅对传入消息有效）或通过连接信息中的&lt;strong&gt;显式版本&lt;/strong&gt;设置。</target>
        </trans-unit>
        <trans-unit id="d9e65fcf80d23dd2690fb225a26bd4c0425947c3" translate="yes" xml:space="preserve">
          <source>There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching.</source>
          <target state="translated">有两种方法可以在PCRE处理的模式中包含注释。在这两种情况下,注释的开始不能在字符类中,也不能在任何其他相关字符序列的中间,如(? 或子模式名称或数字。组成注释的字符在模式匹配中不发挥作用。</target>
        </trans-unit>
        <trans-unit id="d20c200558da5edbf4cd1004014da1b7247909e5" translate="yes" xml:space="preserve">
          <source>There are two ways to set a timeout for the underlying ssh connection:</source>
          <target state="translated">有两种方法可以设置底层ssh连接的超时。</target>
        </trans-unit>
        <trans-unit id="f355209178288a170c04f2c9a20a04655a8e5d7d" translate="yes" xml:space="preserve">
          <source>There are two ways to start a restricted shell session:</source>
          <target state="translated">有两种方法可以启动限制性shell会话。</target>
        </trans-unit>
        <trans-unit id="6b5c659495ea0b68ab11f6dd415042864496550c" translate="yes" xml:space="preserve">
          <source>There are various reasons for using multi-file compilation:</source>
          <target state="translated">使用多文件编译有各种原因。</target>
        </trans-unit>
        <trans-unit id="a4bd267d265d01937064d3e1fb0e66e780b2cf5c" translate="yes" xml:space="preserve">
          <source>There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;:</source>
          <target state="translated">同一子模式可以有多个反向引用。如果一个子模式没有在特定的匹配中使用过,那么对它的任何反向引用总是失败的。例如,以下模式如果开始匹配 &quot;a &quot;而不是 &quot;bc&quot;,则总是失败。</target>
        </trans-unit>
        <trans-unit id="23ffd59215d348fa8988a623fd249aee7018b927" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first parameter has to be an integer() and the last a string().</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过4个,所以第一个参数必须是整数(),最后一个参数必须是字符串()。</target>
        </trans-unit>
        <trans-unit id="1112d47dc0a89deb75a8a7d00a4b483aae845be6" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first three parameters has to be integer()'s and the last three string()'s.</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过四个,所以前三个参数必须是整数()的,后三个字符串()的。</target>
        </trans-unit>
        <trans-unit id="abdb1ae11dc35da6f7877497944147afcc093ef4" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first two parameters has to be integer()'s and the last two string()'s.</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过四个,所以前两个参数必须是整数()的,后两个是字符串()的。</target>
        </trans-unit>
        <trans-unit id="a9363b97aec7cf5ddf082ad0d169c592d9050f71" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary pattern. A binary pattern can occur wherever patterns are allowed, including inside other patterns. Binary patterns cannot be nested. The pattern &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; matches a zero length binary.</source>
          <target state="translated">二进制模式中可以有零个或多个段。二进制模式可以在任何允许的模式下发生，包括在其他模式内部。二进制模式不能嵌套。模式 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 匹配零长度的二进制。</target>
        </trans-unit>
        <trans-unit id="e406e24fdab0c44cf1156b1456ae80afb50bb754" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary to be constructed. The expression &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; constructs a zero length binary.</source>
          <target state="translated">要构造的二进制文件中可以有零个或多个段。表达式 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 构造一个零长度的二进制。</target>
        </trans-unit>
        <trans-unit id="92428ad0a4bfb32617492b37faa92496b8ccd220" translate="yes" xml:space="preserve">
          <source>There exist a number of other &lt;code&gt;spawn&lt;/code&gt; BIFs, for example, &lt;code&gt;spawn/4&lt;/code&gt; for spawning a process at another node.</source>
          <target state="translated">存在许多其他的 &lt;code&gt;spawn&lt;/code&gt; BIF，例如，用于在另一个节点 &lt;code&gt;spawn/4&lt;/code&gt; 进程的spawn / 4。</target>
        </trans-unit>
        <trans-unit id="0bf1452fa6d696c476949e9f9eb92d75ee28307f" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate maps.</source>
          <target state="translated">存在一些BIF来操作地图。</target>
        </trans-unit>
        <trans-unit id="5a19838f7ca93f30ce58e7113784f915faaff575" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate tuples.</source>
          <target state="translated">存在一些BIF来操作元组。</target>
        </trans-unit>
        <trans-unit id="d71ba36f320e1a48ef1d206a22dd1cb9d13cc9ef" translate="yes" xml:space="preserve">
          <source>There is &lt;strong&gt;no&lt;/strong&gt; automatic mechanism for avoiding priority inversion, such as priority inheritance or priority ceilings. When using priorities, take this into account and handle such scenarios by yourself.</source>
          <target state="translated">有&lt;strong&gt;没有&lt;/strong&gt;用于避免优先级反转，如优先级继承或优先天花板自动机构。使用优先级时，请考虑到这一点并自己处理此类情况。</target>
        </trans-unit>
        <trans-unit id="ea2c52d8c1115defbbd414994b65799bf1261e4f" translate="yes" xml:space="preserve">
          <source>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community string to a &lt;code&gt;contextEngineID&lt;/code&gt; and &lt;code&gt;contextName&lt;/code&gt;. Thus, each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always uniquely identifies a context.</source>
          <target state="translated">有一个MIB，即SNMP-COMMUNITY-MIB，它将社区字符串映射到 &lt;code&gt;contextEngineID&lt;/code&gt; 和 &lt;code&gt;contextName&lt;/code&gt; 。因此，每个消息（SNMPv1，SNMPv2c或SNMPv3消息）始终唯一地标识上下文。</target>
        </trans-unit>
        <trans-unit id="9ade9e507a62a79d9f797b73458450166ab26545" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 定义了默认的主机名匹配过程，在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 定义了与协议相关的变体。默认过程在 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 中实现。客户端可以使用选项列表来挂钩修改后的规则。</target>
        </trans-unit>
        <trans-unit id="d57b5d67847213c70927a42448b10614ec369aea" translate="yes" xml:space="preserve">
          <source>There is a scaling problem with this database.</source>
          <target state="translated">这个数据库有一个缩放问题。</target>
        </trans-unit>
        <trans-unit id="2622c0a39c247fb494769606e0e52cccfb438701" translate="yes" xml:space="preserve">
          <source>There is a set of standard MIBs, which are used to control and configure an SNMP agent. All of these MIBs, with the exception of the optional SNMP-PROXY-MIB (which is only used for proxy agents), are implemented in this agent. Further, it is configurable which of these MIBs are actually loaded, and thus made visible to SNMP managers. For example, in a non-secure environment, it might be a good idea to not make MIBs that define access control visible. Note, the data the MIBs define is used internally in the agent, even if the MIBs not are loaded. This chapter describes these standard MIBs, and some aspects of their implementation.</source>
          <target state="translated">有一组标准MIB,用于控制和配置SNMP代理。除了可选的SNMP-PROXY-MIB(仅用于代理代理代理),所有这些MIB都在该代理中实现。此外,可以配置这些MIB中的哪些MIB被实际加载,从而使SNMP管理器可见。例如,在一个非安全的环境中,不使定义访问控制的MIB可见可能是一个好主意。注意,即使没有加载MIBs,MIBs定义的数据也会在代理中内部使用。本章介绍了这些标准MIB,以及它们实现的一些方面。</target>
        </trans-unit>
        <trans-unit id="245adc1cc09d9e8cf3fbaea30fefe11a104de911" translate="yes" xml:space="preserve">
          <source>There is a severe performance penalty in using &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; after any modifying operation is done on that table in the same transaction. That is, avoid using &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;mnesia:select&lt;/code&gt; in the same transaction.</source>
          <target state="translated">在同一事务中对该表执行任何修改操作后，使用 &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; 严重影响性能。也就是说，避免在同一事务中的 &lt;code&gt;mnesia:select&lt;/code&gt; 之前使用 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e3a6368bd3434309374ec5b9d503fef73c80480" translate="yes" xml:space="preserve">
          <source>There is a special case for this field. When the &lt;code&gt;max_retries&lt;/code&gt; has the value &lt;code&gt;infinity_restartable&lt;/code&gt;, it means that the timer is restartable as long as some external event occurs (e.g. receipt of a pending message for instance). But the timer will never be restarted &quot;by itself&quot;, i.e. when the timer expires (whatever the timeout time), so does the timer. Whenever the timer is restarted, the timeout time will be calculated in the usual way! Also, as mentioned above, beware the consequences of setting the value to &lt;code&gt;infinity&lt;/code&gt; if &lt;strong&gt;incr&lt;/strong&gt; has been set to an negative value.</source>
          <target state="translated">此字段有一个特殊情况。当 &lt;code&gt;max_retries&lt;/code&gt; 的值是 &lt;code&gt;infinity_restartable&lt;/code&gt; 时，这意味着只要发生​​某些外部事件（例如，接收到待处理的消息），计时器就可以重新启动。但是计时器永远不会&amp;ldquo;自行&amp;rdquo;重新启动，即计时器到期（无论超时时间如何），计时器也不会重新启动。每当定时器重启时，超时时间将以通常的方式计算！另外，如上所述，请注意如果将&lt;strong&gt;incr&lt;/strong&gt;设置为负值，则将值设置为 &lt;code&gt;infinity&lt;/code&gt; 的后果。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="447c2e61ea99ad24abf33df5c7d87ca6d434b459" translate="yes" xml:space="preserve">
          <source>There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom &lt;code&gt;default&lt;/code&gt; instead of the name.</source>
          <target state="translated">还有一个&amp;ldquo;默认&amp;rdquo;值，它具有空字符串作为名称。使用原子 &lt;code&gt;default&lt;/code&gt; 而不是name进行读写。</target>
        </trans-unit>
        <trans-unit id="2f4ba43d3ad9541719761e12f97fd9eb701de696" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory (e.g. VxWorks). The output on other systems is however still valid, although sparse.</source>
          <target state="translated">还有一个与系统相关的内存数据的接口 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 。结果高度依赖于底层操作系统，并且该接口主要针对没有虚拟内存的系统（例如VxWorks）。尽管稀疏，但其他系统上的输出仍然有效。</target>
        </trans-unit>
        <trans-unit id="7c9bc41f259857156ea8f5d5261fcd25f2b407e3" translate="yes" xml:space="preserve">
          <source>There is also a module &lt;code&gt;make&lt;/code&gt;, which provides a set of functions similar to the UNIX type Make functions, see the &lt;code&gt;make(3)&lt;/code&gt; manual page in Tools.</source>
          <target state="translated">还有一个模块 &lt;code&gt;make&lt;/code&gt; ，它提供了一组类似于UNIX类型的Make函数的功能，请参见Tools中的 &lt;code&gt;make(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="0dad695a19ca238ba2a763d955fb786b98d2dc49" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; ，还有一个服务器启动选项 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; ，可用于自动使服务器休眠。</target>
        </trans-unit>
        <trans-unit id="f24b3a3437fd8a632ab4bcd78a41f42013e20b72" translate="yes" xml:space="preserve">
          <source>There is also a type test BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt;.</source>
          <target state="translated">还有一个类型测试BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daa23f797927415980ee4810932d3c90b6953794" translate="yes" xml:space="preserve">
          <source>There is also an API to block or unblock users manually. This API can also list blocked users or users who have been authenticated within a configurable amount of time.</source>
          <target state="translated">还有一个API可以手动阻止或解除阻止用户。这个API还可以列出被封杀的用户或在可配置的时间内被认证的用户。</target>
        </trans-unit>
        <trans-unit id="7110ad7a4f42b784159bbbf21bed3303346edd8d" translate="yes" xml:space="preserve">
          <source>There is also function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels.</source>
          <target state="translated">还有一个函数 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 返回所有标志（按位或：在一起），这些标志对应于要求在分发通道上对数据进行严格排序的功能。</target>
        </trans-unit>
        <trans-unit id="6fa8c8dbb4f5b93ed951ec7e3ddcfaace3c9a8bb" translate="yes" xml:space="preserve">
          <source>There is also the single sequence \N, which matches a non-newline character. This is the same as the &quot;.&quot; metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set. Perl also uses \N to match characters by name, but PCRE does not support this.</source>
          <target state="translated">还有一个单个序列\ N，它与非换行符匹配。这与&amp;ldquo;。&amp;rdquo;相同。未设置 &lt;code&gt;dotall&lt;/code&gt; 时的元字符。Perl还使用\ N来按名称匹配字符，但是PCRE不支持此功能。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
