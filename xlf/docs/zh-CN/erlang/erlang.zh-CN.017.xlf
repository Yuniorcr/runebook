<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">fun是一个函数对象。通过fun可以创建一个匿名函数,并将函数本身--而不是它的名字--作为参数传递给其他函数。</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">错误的参数数量会带来乐趣。 &lt;code&gt;F&lt;/code&gt; 描述了乐趣和参数。</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">趣指成趣表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="4fc6c3b004a9c28596e264b75abedbe106e6b063" translate="yes" xml:space="preserve">
          <source>A fun that takes the socket info and returns a &lt;code&gt;boolean()&lt;/code&gt; (&lt;code&gt;true&lt;/code&gt; if the socket sould be included and &lt;code&gt;false&lt;/code&gt; if should not).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25c37b8117f77137d7a7610d86f37adc3dd7d32" translate="yes" xml:space="preserve">
          <source>A fun which converts a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report() &lt;/a&gt;&lt;/code&gt; to a format string and arguments, or directly to a string. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">有以下签名的趣味。</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以在套件，组和测试用例信息函数中将函数（ &lt;code&gt;fun/0&lt;/code&gt; 或 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; （MFA）元组）指定为时间陷阱值，并作为函数 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">函数断点是一组行断点,在指定的函数中每个子句的第一行都有一个。</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">一个函数可以有很多参数。让我们使用将两个数字相乘的函数来扩展模块 &lt;code&gt;tut1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">符合这些功能的功能。有关详细信息，请参见 &lt;code&gt;supervisor(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">函数约束Fc是约束 &lt;code&gt;C_1, ..., C_k&lt;/code&gt; 的非空序列，并且Rep（Fc）= &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">独占解码的功能,用户在配置文件中决定其名称。</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">测试套件中的一项功能，旨在用于在被测系统（SUT）和/或 &lt;code&gt;Common Test&lt;/code&gt; 主机节点上设置，清理和/或验证状态和环境，以便测试用例（或一组测试用例）可以正确执行。</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">测试套件中的一个函数，它返回属性列表（由 &lt;code&gt;Common Test&lt;/code&gt; 服务器读取），该属性列表描述了在套件中执行测试用例的条件。</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 模块中的一个函数将用于启动该过程。有几个功能可用，例如， &lt;code&gt;spawn_link/3,4&lt;/code&gt; 用于异步启动， &lt;code&gt;start_link/3,4,5&lt;/code&gt; 用于同步启动。</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">使用 &lt;code&gt;M:F&lt;/code&gt; 语法调用函数，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;F&lt;/code&gt; 是原子或表达式。</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">命名为A功能 &lt;code&gt;f&lt;/code&gt; 在模块 &lt;code&gt;m&lt;/code&gt; ，并与元数 &lt;code&gt;N&lt;/code&gt; 经常表示为 &lt;code&gt;m:f/N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">在某个时间点，未明确记录为线程安全的函数可以在运行时系统中具有线程安全的实现。但是，此类实现可以随时更改为线程&lt;strong&gt;不安全的&lt;/strong&gt;实现，&lt;strong&gt;而无需任何通知&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">可以将一个参数的函数指定为输出。排序或合并输入的结果将以非空的二进制或术语可变长度列表列表（取决于格式）收集。一次调用一个列表的输出函数，并假定它返回一个新的输出函数。任何其他返回值将立即作为当前调用的值返回到sort或merge函数。每个输出函数仅被调用一次。当某些输出函数应用于所有结果或发生错误时，将使用参数 &lt;code&gt;close&lt;/code&gt; 调用最后一个函数，并将回复作为当前调用的值返回到sort或merge函数。</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">功能说明可以重载。也就是说，它可以有几种类型，以分号（ &lt;code&gt;;&lt;/code&gt; ）分隔：</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">如果有一个结构 &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; 可以向数据库添加一个家庭的函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">一个打算被追踪的函数。</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">函数类型Ft是以下之一:</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">使用 &lt;code&gt;is_set_ok&lt;/code&gt; 调用的函数将再次调用，如果没有错误，则使用 &lt;code&gt;set&lt;/code&gt; ;如果发生错误，则使用 &lt;code&gt;undo&lt;/code&gt; 再次调用。这样，可以在 &lt;code&gt;is_set_ok&lt;/code&gt; 操作中保留资源，在 &lt;code&gt;undo&lt;/code&gt; 操作中释放资源，或在 &lt;code&gt;set&lt;/code&gt; 操作中使其成为永久资源。</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">名称以 &lt;code&gt;..._test()&lt;/code&gt; 结尾的函数被EUnit识别为简单的测试函数-它不带参数，并且执行成功（返回EUnit会丢弃的任意值），或者通过抛出某种例外（或不终止，在这种情况下将在一段时间后终止）。</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">名称以 &lt;code&gt;..._test_()&lt;/code&gt; 结尾的函数（请注意最后的下划线）被EUnit识别为&lt;strong&gt;测试生成器&lt;/strong&gt;函数。测试生成器返回由EUnit执行的一&lt;strong&gt;组测试&lt;/strong&gt;的&lt;strong&gt;表示&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">系统消息的功能接口。</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">一个功能对象(fun)被称为。</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">一个功能性、可扩展的数组。其表示方法未见记载,如有变更,恕不另行通知。请注意,数组不能直接进行平等比较。</target>
        </trans-unit>
        <trans-unit id="e1e00f7b7a96013a7ac2150829df3b65546f70ca" translate="yes" xml:space="preserve">
          <source>A general address format on the form &lt;code&gt;{Family, Destination}&lt;/code&gt; where &lt;code&gt;Family&lt;/code&gt; is an atom such as &lt;code&gt;local&lt;/code&gt; and the format of &lt;code&gt;Destination&lt;/code&gt; depends on &lt;code&gt;Family&lt;/code&gt;, and is a complete address (for example an IP address including port number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">一般平衡集迭代器。</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">总的平衡集。</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">一般平衡树迭代器。</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">一般平衡的树。</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">一个通用的函数，用于使用格式说明符和一组对应的参数来创建Erlang术语，这与 &lt;code&gt;printf()&lt;/code&gt; 的工作方式非常相似。</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">用于从注册表中检索任何类型的对象的一般功能。</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">生成的错误是代码本身调用 &lt;code&gt;exit/1&lt;/code&gt; 或 &lt;code&gt;throw/1&lt;/code&gt; 时。请注意，此处未将模拟的运行时错误表示为生成的错误。</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">一个通用的漂亮打印机库。</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">一个通用的漂亮打印机库。本模块使用了John Hughes算法的严格风格的上下文传递实现,在 &quot;The design of a Pretty-printing Library &quot;中描述。段落式格式化、空文档、浮动文档和空字符串是我自己在算法中添加的。</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">一个通用的单对象比较和交换操作。</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">使用此模块实现的通用状态机进程（ &lt;code&gt;gen_statem&lt;/code&gt; ）具有一组标准的接口功能，并包括用于跟踪和错误报告的功能。它也适合OTP监管树。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17deb413c89fd01affc6582636308eea7c33a228" translate="yes" xml:space="preserve">
          <source>A generic state machine server process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">与定义的全局组 &lt;code&gt;PublishType&lt;/code&gt; 等于 &lt;code&gt;hidden&lt;/code&gt; 被说成是一个隐藏的全局组。隐藏全局组中的所有节点都是隐藏节点，无论它们是否以命令行标记 &lt;code&gt;-hidden&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">一个全球性的名称注册设施。</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">Erlang节点的全局跟踪标志，使用标志 &lt;code&gt;timestamp&lt;/code&gt; 将所有跟踪时间戳记为CPU时间，而不是挂钟时间。也就是说，如果启用了 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 或 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ， &lt;code&gt;cpu_timestamp&lt;/code&gt; 使用cpu_timestamp。仅允许使用 &lt;code&gt;PidPortSpec==all&lt;/code&gt; 。如果主机操作系统不支持高分辨率的CPU时间测量，则使用 &lt;code&gt;badarg&lt;/code&gt; 退出 &lt;code&gt;trace/3&lt;/code&gt; 。请注意，大多数操作系统不会跨内核同步此值，因此请做好准备，以使使用此选项时时间似乎倒退。</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释这些参考文献的好书是Dubuisson：ASN.1-异构系统之间的通信，可从 &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; 免费下载。</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">有效编程的一个好的开始是知道不同数据类型和操作需要多少内存。Erlang数据类型和其他项目消耗多少内存取决于实现方式，但是下表显示了OTP 19.0中 &lt;code&gt;erts-8.0&lt;/code&gt; 系统的一些数据。</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">检查是否需要更多IO轮询线程的一种好方法是使用 &lt;code&gt;microstate accounting&lt;/code&gt; 并查看IO轮询线程的负载。如果该值很高，则最好添加更多线程。</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">解析列表表达式的语法(有空的关联代码)。</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">嵌套在并行组下的组开始与先前（并行）测试用例并行执行（无论嵌套组具有什么属性）。但是，由于测试用例永远不会与同一组的 &lt;code&gt;init_per_group/2&lt;/code&gt; 或 &lt;code&gt;end_per_group/2&lt;/code&gt; 并行执行，因此只有在嵌套组完成后才产生前一组中剩余的并行用例。</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">在一个事务中可以调用一组函数或进程。一个事务可以包括从DBMS中读取、写入或删除数据的语句。许多这样的事务可以并发运行,程序员不需要明确地同步操作数据的进程。</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">可以使用通用名称访问一组进程。例如，如果有一个名为 &lt;code&gt;foobar&lt;/code&gt; 的组，则可以有一组进程（可以位于不同的节点上），这些进程都是该组 &lt;code&gt;foobar&lt;/code&gt; 成员。没有特殊功能可以向群组发送消息。取而代之的是，应使用 &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; 函数编写客户端函数，以确定哪些进程是该组的成员。然后，可以将邮件发送给一个或多个组成员。</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">以（？|开头的组会重置每个替代项中的捕获括号数字（请参见 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 部分）。每个分支开头的断言会检查下一个UTF-8字符，以获取其编码使用1、2、3，或4个字节，然后按适当数量的组捕获字符的各个字节。</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">保护G是保护测试 &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; 和Rep（G）= &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; 的非空序列。</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">保护序列Gs是保护序列 &lt;code&gt;G_1; ...; G_k&lt;/code&gt; 和Rep（Gs）= &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; 。如果保护序列为空，则Rep（Gs）= &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">警卫测试Gt是以下之一。</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">驱动程序特定数据的句柄,传递给驱动程序回调。它是一个指针,通常会被类型转换为驱动中的特定指针。</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">必须导出一个处理程序回调模块。</target>
        </trans-unit>
        <trans-unit id="678e5d07b0fa73bdf7fd807616029bb8f1f11655" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt; logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; 删除处理程序。记录器调用 &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; ，并从配置数据库中删除处理程序的配置。</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">一个处理程序被定义为至少输出以下回调函数的模块。</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">隐藏节点是以命令行标记 &lt;code&gt;-hidden&lt;/code&gt; 开头的节点。隐藏节点和其他节点之间的连接不是可传递的，必须显式设置它们。另外，隐藏节点也不会显示在由 &lt;code&gt;nodes()&lt;/code&gt; 返回的节点列表中。而是必须使用 &lt;code&gt;nodes(hidden)&lt;/code&gt; 或 &lt;code&gt;nodes(connected)&lt;/code&gt; 。例如，这意味着未将隐藏节点添加到 &lt;code&gt;global&lt;/code&gt; 跟踪的节点集中。</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">一个块大小的直方图,其中每个区间的上界是它之前的两倍。</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">挂钩函数（参见 &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; 类型）被传递给当前的语法树节点，上下文和延续。可以使用诸如 &lt;code&gt;get_ctxt_user/1&lt;/code&gt; 和 &lt;code&gt;set_ctxt_user/2&lt;/code&gt; 之类的函数来检查和操作上下文。挂钩必须返回&amp;ldquo;文档&amp;rdquo;数据结构（请参见 &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; ）；这可以通过应用延续函数来部分或全部构建。例如，以下是一个琐碎的钩子：</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 重新分类和重新安排在I / O绑定和CPU绑定之间切换的作业，以便始终在正确的脏调度程序类型上执行该作业。有关更多信息，请参见 &lt;code&gt;erl(1)&lt;/code&gt; 命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="da4d22f9cc705b47b11f5556a6a98d52ebdf94f6" translate="yes" xml:space="preserve">
          <source>A key for des3 is a list of three iolists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bc46bb25920857aea5ff4cc78f13c35d6caf0e" translate="yes" xml:space="preserve">
          <source>A key to an entry in the session cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">更大的缓冲区限制允许进程在分发过程中缓冲更多的外发消息。当达到缓冲区限制时,发送进程将被暂停,直到缓冲区大小缩小。缓冲区限制是针对每个分发通道的。较高的限制可以提供较低的延迟和较高的吞吐量,但代价是较高的内存使用量。</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">如果只有一个条目并且 &lt;code&gt;InfoList&lt;/code&gt; 为空，则可以省略术语 &lt;code&gt;CpuTopology&lt;/code&gt; 的级别。</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">一个不能启动或停止的库应用程序,不需要任何应用程序回调模块。</target>
        </trans-unit>
        <trans-unit id="95d53ac43bdcd275e024568761344b42b310394a" translate="yes" xml:space="preserve">
          <source>A lightweight lookup in the table was the most important feature, but we also wanted to improve modifications of the table. The process table is modified when a new process is spawned, i.e. a new pointer is inserted into the table, and when a process terminates, i.e. a pointer is deleted in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">在 &quot;查看模块 &quot;窗口或 &quot;附加进程 &quot;窗口中显示模块时,也可以通过双击行来创建(和删除)行断点。</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">在模块的某一行创建断点。</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; 将 &lt;code&gt;channel&lt;/code&gt; 线路级别的呼叫分析写入文件：</target>
        </trans-unit>
        <trans-unit id="71f85c48df8221b4058723c56c5fee97655b5db6" translate="yes" xml:space="preserve">
          <source>A line with &lt;code&gt;//&lt;/code&gt; is also a comment. It is recommended to only use this style of comments in files that define implementations of instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c244651147c5c8032fa00f6a8115a6bb5b8002" translate="yes" xml:space="preserve">
          <source>A link between &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">可以通过调用BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; 来删除链接。</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">崩溃时,本地进程和远程进程之间存在链接。</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">链接断开。 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 包含链接进程的pid，而 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 包含退出原因。</target>
        </trans-unit>
        <trans-unit id="ff85adc5284cadbc93a39945b54d30501de96451" translate="yes" xml:space="preserve">
          <source>A link or monitor to a remote process was broken because a connection between the nodes could not be established or was severed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">从某个目录执行的所有运行的链接都写在名为 &lt;code&gt;all_runs.html&lt;/code&gt; 的日志中，而所有测试（最新结果）的直接链接都写在顶级 &lt;code&gt;index.html&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">列表推导返回一个列表，其中的元素是对生成器列表元素和位字符串生成器元素的每种组合求值 &lt;code&gt;Expr&lt;/code&gt; 的结果，对于这些组合，所有过滤器均为真。</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">一个清单的理解。</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">列表是一种具有可变项数的复合数据类型。</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">必须指定一个列表，其中包含元素的数量，包括尾部，这是 &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 之前的最后一项。</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">可能包含错误指示的 &quot;ActionReply &quot;记录列表。</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">可以提供 &lt;code&gt;UpdateOp&lt;/code&gt; 的列表以在对象内执行许多更新操作。按照列表中指定的顺序执行操作。如果相同的计数器位置在列表中出现多次，则相应的计数器将因此多次更新，每次都是基于先前的结果。返回值是每个更新操作的新计数器值的列表，其顺序与操作列表中的顺序相同。如果指定了一个空列表，则不进行任何更新，并返回一个空列表。如果功能失败，则不会进行任何更新。</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">&lt;code&gt;{Name, Memory}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Name&lt;/code&gt; 是一个片段 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Memory&lt;/code&gt; 是它占用的内存量</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">&lt;code&gt;{Name, Size}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Name&lt;/code&gt; 是片段 &lt;code&gt;Name&lt;/code&gt; ，而 &lt;code&gt;Size&lt;/code&gt; 是其中包含的记录数</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">可以提供 &lt;code&gt;{Pos,Value}&lt;/code&gt; 列表来更新同一对象中的许多元素。如果同一位置在列表中出现多次，则写入列表中的最后一个值。如果列表为空或功能失败，则不进行任何更新。在其他进程永远看不到任何中间结果的意义上，该函数也是原子的。</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">&lt;strong&gt;版本升级说明的&lt;/strong&gt;列表，请参阅 &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; 。建议仅使用高级说明。创建 &lt;code&gt;relup&lt;/code&gt; 文件时，这些工具会由 &lt;code&gt;systools&lt;/code&gt; 自动转换为低级指令。</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">DER编码的证书列表,按信任顺序排列,以对等证书结束。</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">可以通过以下函数获得活动检查点的列表。</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; 模块中提供了所有有效的Erlang Top配置参数的列表。</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">备用词典模块的列表，可使用这些词典模块来对相关应用程序的词典未定义的AVP进行编码/解码。在解码时，此类AVP表示为已解码消息或分组AVP 的 &lt;code&gt;'AVP'&lt;/code&gt; 字段中的diameter_avp记录，这是成功解码设置记录值字段的AVP的第一个备用项。在编码时， &lt;code&gt;'AVP'&lt;/code&gt; 列表中的值可以作为AVP名称/值2元组传递，并且没有替代定义此类元组的AVP是一种编码错误。</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">应用程序依赖的应用程序版本的列表。这种应用程序版本的一个示例是 &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; 。指定为运行时依赖项的应用程序版本是最低要求。也就是说，比依赖关系中指定的版本更大的应用程序版本可以满足要求。有关如何比较应用程序版本的信息，请参阅《系统原理用户指南》中的&amp;ldquo; &lt;code&gt;Versions&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">版本中包含的应用程序包含的应用程序列表。该列表必须是在应用程序资源文件（ &lt;code&gt;Application.app&lt;/code&gt; ）中指定的包括的应用程序的子集，并覆盖此值。缺省值为与应用程序资源文件中的值相同。</target>
        </trans-unit>
        <trans-unit id="7501d56e7513156f76383768c05bf058cd48248a" translate="yes" xml:space="preserve">
          <source>A list of arbitrary socket options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">对应于 &lt;code&gt;BIT STRING&lt;/code&gt; 定义中 &lt;code&gt;NamedBitList&lt;/code&gt; 中原子的原子列表。甲 &lt;code&gt;BIT STRING&lt;/code&gt; 用符号名总是解码以在下面的示例中所示的格式：</target>
        </trans-unit>
        <trans-unit id="dad15913daed65e8f5cbb546acf62e2eac396099" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt; enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">二进制列表。将此数据类型与 &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 一起使用非常有用。</target>
        </trans-unit>
        <trans-unit id="cc21ad3fb691b61137a500e7fa67b8eec7cc2074" translate="yes" xml:space="preserve">
          <source>A list of cipher suites that should be supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">在节点启动后，将执行选项 &lt;code&gt;Startup&lt;/code&gt; 中指定的功能列表。注意，所有使用的模块都应存在于 &lt;code&gt;Host&lt;/code&gt; 的代码路径中。</target>
        </trans-unit>
        <trans-unit id="33ed581a843666d74741e3c3b88fa9be23335a3f" translate="yes" xml:space="preserve">
          <source>A list of identifiers for all the processes, ports and NIF resources, that are monitoring the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8da2df3aade9466893560d8879580f6ac7224df" translate="yes" xml:space="preserve">
          <source>A list of integers sets the generator's internal state directly, after algorithm-dependent checks of the value and masking to the proper word size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">一个包含从配置函数传递给测试用例的运行时配置数据的键值元组列表(即属性列表)。</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">低级版本升级说明列表，请参阅 &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; 。它包含来自各个应用程序升级文件的发行升级说明（高级指令转换为低级指令），其顺序与启动脚本中的顺序相同。</target>
        </trans-unit>
        <trans-unit id="07cd63bd8b8a5bee2676cad933dc31cee7b4f8e9" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。空列表等效于 &lt;code&gt;true&lt;/code&gt; 。有关匹配规格的说明，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="139fe9d39aad421da9b537eadc3c0d0b13b2c1fe" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。匹配在列表 &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; 。 &lt;code&gt;Node&lt;/code&gt; 是发送方的节点名称。 &lt;code&gt;Sender&lt;/code&gt; 是发件人的进程或端口标识，如果发件人未知，则为 &lt;code&gt;undefined&lt;/code&gt; 的原子（远程发件人就是这种情况）。 &lt;code&gt;Msg&lt;/code&gt; 是消息项。可以使用保护功能 &lt;code&gt;self/0&lt;/code&gt; 访问接收过程的pid 。空列表与 &lt;code&gt;true&lt;/code&gt; 相同。有关更多信息，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="d87f996d594a00d6035f5f5ee9ddba88e768355e" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt; Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。匹配在列表 &lt;code&gt;[Receiver, Msg]&lt;/code&gt; 。 &lt;code&gt;Receiver&lt;/code&gt; 是接收方的进程或端口标识， &lt;code&gt;Msg&lt;/code&gt; 是消息项。发送进程的PID可以与保护功能进行访问 &lt;code&gt;self/0&lt;/code&gt; 。空列表与 &lt;code&gt;true&lt;/code&gt; 相同。有关更多信息，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">该进程处于活动状态的监视器列表（由 &lt;code&gt;monitor/2&lt;/code&gt; 开头）。对于具有过程标识符的本地过程监视器或远程过程监视器，该列表包括：</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">节点名称(原子)的列表,即组节点。</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">节点名称列表,当前与本地节点同步的组节点。</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">节点名称的列表,即目前没有连接的组节点。</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">节点名称的列表,即本地节点未能同步的组节点。</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则返回一个对象列表和一个延续，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 匹配其他对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">pid列表，指定已订阅 &lt;code&gt;nodeup&lt;/code&gt; 和 &lt;code&gt;nodedown&lt;/code&gt; 消息的进程。</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">监视进程的进程标识符列表（使用 &lt;code&gt;monitor/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">应用程序的启动阶段和相应的启动参数的列表。如果存在此密钥，则除了通常调用 &lt;code&gt;Module:start/2&lt;/code&gt; 之外，应用程序主控 &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; 为每个由 &lt;code&gt;start_phases&lt;/code&gt; 定义的启动阶段调用Module：start_phase（Phase，Type，PhaseArgs）。仅在此扩展的启动过程之后， &lt;code&gt;application:start(Application)&lt;/code&gt; 才返回。</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">匹配标记中的字符列表。</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">不存在的节点列表。</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">服务器不存在的节点列表。</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">服务器在发送任何回复前终止的节点列表。</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">扫描程序生成的令牌列表应以解析器正在寻找的特殊 &lt;code&gt;end_of_input&lt;/code&gt; 元组结尾。该元组的格式应为 &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; ，其中 &lt;code&gt;Endsymbol&lt;/code&gt; 是与语法规则的所有终端和非终端类别区分开的标识符。该 &lt;code&gt;Endsymbol&lt;/code&gt; 可以在语法文件中声明（见下文）。</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">元组列表，其中包含各个调度程序的结果以及汇总的平均值。 &lt;code&gt;Util&lt;/code&gt; 是调度程序的利用率，它是介于0.0和1.0之间的浮点值。 &lt;code&gt;Percent&lt;/code&gt; 与以百分比表示的更易理解的字符串的利用率相同。</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">以 &lt;code&gt;FuncCallCount&lt;/code&gt; 降序排列的元组列表，每个元组用于模块中的每个函数。</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">元组的列表，一个用于除了每个模块 &lt;code&gt;cprof&lt;/code&gt; ，以递减 &lt;code&gt;ModCallCount&lt;/code&gt; 顺序。</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">一个表示列表 &lt;code&gt;t&lt;/code&gt; 的尾元素的列表。</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">名单排序如下:</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">尾部为列表的列表有时称为&lt;strong&gt;适当列表&lt;/strong&gt;。允许有一个尾部不是列表的列表，例如 &lt;code&gt;[a|b]&lt;/code&gt; 。但是，这种类型的列表几乎没有实际用途。</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">具有与 &lt;code&gt;Cols&lt;/code&gt; 列表一样多的元素的列表每个元素可以是：</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">具有与 &lt;code&gt;Cols&lt;/code&gt; 列表一样多的元素的列表，其中每个元素是对应列的值。每个元素可以是：</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">如果未指定Unicode转换修饰符，则整数&amp;gt; 255的列表将被视为错误：</target>
        </trans-unit>
        <trans-unit id="56ba062b97d1eab0e07bd7682980396fa3439b42" translate="yes" xml:space="preserve">
          <source>A list, empty or not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">一个包含所有被解释模块名称的列表框。</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">侦听传输的信息呈现方式略有不同，因为同一 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 可能存在多个接受的连接。由具有单个客户端连接的服务器返回的 &lt;code&gt;transport&lt;/code&gt; 信息可能如下所示。</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字 &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">字面数据字符</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">可以写一个文字字符串来代替元素。</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已加载的NIF库与已加载它的Erlang模块实例相关。如果模块已升级，则新模块实例需要加载自己的NIF库（或选择不加载）。但是，新模块实例可以选择加载与旧代码完全相同的NIF库。共享动态库意味着也共享库定义的静态数据。为了避免模块实例之间意外共享静态数据，每个Erlang模块版本都可以保留自己的私有数据。可以在加载NIF库时设置此私有数据，并稍后通过调用 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">日志文件可以通过授予期权不同的值被打开不止一次 &lt;code&gt;name&lt;/code&gt; 或通过分发不同节点上的日志时使用相同的文件。模块 &lt;code&gt;disk_log&lt;/code&gt; 的用户要确保对一个文件的写访问权限不超过一个磁盘日志进程，否则该文件可能会损坏。</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">一个特定测试用例的日志文件。也叫测试用例日志文件。</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">逻辑错误是指一个程序没有按照预期的方式运行,但没有崩溃。例如,当点击图形用户界面中的一个按钮时,没有任何事情发生。</target>
        </trans-unit>
        <trans-unit id="874913df600124a6285f4364c4fbf70b34e930c1" translate="yes" xml:space="preserve">
          <source>A long line can be broken into shorter lines by a placing a &lt;code&gt;\&lt;/code&gt; before the newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">较长的请求队列可能会导致用户察觉到延迟，因为较早的请求可能需要很长时间才能完成。HTTP / 1.1规范建议每个服务器限制两个持久连接，这是选项 &lt;code&gt;max_sessions&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">宏 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 被 &lt;code&gt;Replacement&lt;/code&gt; 替换，其中所有来自宏定义的变量 &lt;code&gt;Var&lt;/code&gt; 都被替换为对应的参数 &lt;code&gt;Arg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">如果至少有一个带参数的 &lt;code&gt;Func&lt;/code&gt; 定义，但是没有N个参数 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 带有（可能为空）参数列表的宏？Func（Arg1，...，ArgN）会导致错误消息。</target>
        </trans-unit>
        <trans-unit id="b1a7684d730263c657e047ab83e0ed99db2901a8" translate="yes" xml:space="preserve">
          <source>A macro can also be invoked from within another macro. For example, &lt;code&gt;move_deallocate_return/2&lt;/code&gt; avoids repeating code by invoking &lt;code&gt;$deallocate_return()&lt;/code&gt; as a macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">宏定义可以放在模块的属性和函数声明中的任何位置,但定义必须在使用宏之前。</target>
        </trans-unit>
        <trans-unit id="98be1362f60e2ee14c3e74a98f904123979eba5e" translate="yes" xml:space="preserve">
          <source>A macro definition whose name and arity matches a family of specific instructions is assumed to be the implementation of that instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba3e72543889c84d73759d1071163c5b4427577" translate="yes" xml:space="preserve">
          <source>A macro definitions must start at the beginning of the line (no spaces allowed), the opening curly bracket must be on the same line, and the finishing curly bracket must be at the beginning of a line. It is recommended that the macro body is properly indented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">在生成服务器进程时,也会用到一个宏。</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">宏的定义如下:</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">宏的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">管理员生成命令并接收来自代理的通知。一个系统中通常只有几个管理器。</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">包含有关特定线程信息的映射。映射中的百分比可以是运行时或实时的，具体取决于是否从 &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 请求 &lt;code&gt;runtime&lt;/code&gt; 或 &lt;code&gt;realtime&lt;/code&gt; 。 &lt;code&gt;system&lt;/code&gt; 是此特定线程在系统总时间中所占的百分比。</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">一张地图,包含了不同的微观状态核算状态以及在其中花费的微秒数。</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">包含不同微状态会计状态的地图。映射中的每个值都包含另一个映射，以及该线程在特定状态下所花费的时间百分比。 &lt;code&gt;system&lt;/code&gt; 时间百分比和该特定 &lt;code&gt;thread&lt;/code&gt; 的时间都属于映射。</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">地图是一种复合数据类型,其键值关联的数量可变。</target>
        </trans-unit>
        <trans-unit id="d505ce33814e76ba28c2120be515c6067e3749b3" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt; enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">一种地图迭代器是环境的寿命期间只有用 &lt;code&gt;env&lt;/code&gt; ，该 &lt;code&gt;map&lt;/code&gt; 属于。必须通过调用 &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; 销毁迭代器：</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">必须使用键-值对 &lt;code&gt;N&lt;/code&gt; 的数量指定映射。键值对必须按以下顺序在 &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; 之前： &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; 。不允许重复的密钥。</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">匹配规范可以打开或关闭顺序跟踪。该函数返回一个匹配规范，这将导通顺序追踪具有指定 &lt;code&gt;Flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'receive'&lt;/code&gt; 跟踪的匹配规范可以使用所有保护和主体函数，但 &lt;code&gt;caller&lt;/code&gt; ， &lt;code&gt;is_seq_trace&lt;/code&gt; ， &lt;code&gt;get_seq_token&lt;/code&gt; ， &lt;code&gt;set_seq_token&lt;/code&gt; ， &lt;code&gt;enable_trace&lt;/code&gt; ， &lt;code&gt;disable_trace&lt;/code&gt; ， &lt;code&gt;trace&lt;/code&gt; ， &lt;code&gt;silent&lt;/code&gt; 和 &lt;code&gt;process_dump&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 跟踪的匹配规范可以使用除 &lt;code&gt;caller&lt;/code&gt; 以外的所有保护和主体功能。</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">&lt;code&gt;ets(3)&lt;/code&gt; 中使用的匹配规范可以在以下&lt;strong&gt;非正式&lt;/strong&gt;语法中进行描述：</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">可以在以下&lt;strong&gt;非正式&lt;/strong&gt;语法中描述用于跟踪的匹配规范：</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">匹配规格,见上文。</target>
        </trans-unit>
        <trans-unit id="abb2961d578d0b3c60f269fc6add18fea6c7cde0" translate="yes" xml:space="preserve">
          <source>A match specifications with excessive nesting will cause a &lt;code&gt;&lt;a href=&quot;#ets_failures&quot;&gt;system_limit&lt;/a&gt;&lt;/code&gt; error exception to be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">字符串 &quot;aaaa &quot;的匹配总是失败,但每次回溯发生之前都会进行调用(在本例中,10次)。</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">内存段分配器。其他分配器使用它来分配内存段，并且仅在具有 &lt;code&gt;mmap&lt;/code&gt; 系统调用的系统上可用。被释放的内存段在销毁之前会在段缓存中保留一段时间。分配段后，将尽可能使用缓存的段，而不是创建新的段。这样可以减少进行系统调用的次数。</target>
        </trans-unit>
        <trans-unit id="12c52bcf9d23dfb0dbc1111b21b3e77c0d64c7e0" translate="yes" xml:space="preserve">
          <source>A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22559646ed04a3865a223cef10ef45e28e857451" translate="yes" xml:space="preserve">
          <source>A middlebox which terminates a TLS connection MUST behave as a compliant TLS server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">一个最小的NIF库的例子如下。</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">最低限度的Windows NT安装与网络需要250MB,额外的130MB用于交换文件。</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">行为不当的过滤器将被移除。</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">一个模块属性由一个标签和一个值组成。</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">模块也可以用来表示测试集。请参阅下面&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 下的 &lt;code&gt;ModuleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">一个模块可以由它的模块名(原子)或文件名来指定。</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">模块可以导出某些类型，以声明允许其他模块将它们称为&lt;strong&gt;远程类型&lt;/strong&gt;。该声明具有以下形式：</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">一个模块可以使用Erlang webserver API模块序列中前一个模块生成的数据,也可以生成数据供连续的Erlang Web Server API模块使用。之所以能够做到这一点,是因为有一个内部的键值元组列表,被称为交互数据。</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">一个模块包含一个 &lt;code&gt;-on_load function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">一个模块声明由一系列形式组成,这些形式可以是函数声明,也可以是属性。</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">实现 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 行为的模块。该模块的信息功能将在交付的各个阶段被调用。</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">一个模块不止一次包含在 &lt;code&gt;Modules&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">指定为一个模块 &lt;code&gt;transport_module&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 必须实现这里记录的接口。该接口包括一个函数，直径用于启动传输过程；消息接口，用于与传输过程与启动它的过程（即其父进程）进行通信。</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">可以通过调用 &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; 删除监视器。</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">为创建一个监视器 &lt;code&gt;unloaded_only&lt;/code&gt; 的行为完全是一个为创建 &lt;code&gt;unloaded&lt;/code&gt; 除了 &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; 从不发送消息，但显示器，而不是持续直到司机&lt;strong&gt;真的&lt;/strong&gt;被卸载。</target>
        </trans-unit>
        <trans-unit id="1f4b0ba77513970218ad1a2b88d07cb4eef5317e" translate="yes" xml:space="preserve">
          <source>A monitor from &lt;code&gt;To&lt;/code&gt; to &lt;code&gt;Result&lt;/code&gt; was set up on the node where &lt;code&gt;Result&lt;/code&gt; resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcac2207e183cb309e308e8c36f24d54ce1572c" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang运行时系统提供的单调增加的时间。从某个未指定的时间点开始，Erlang单调时间增加。要检索它，请调用 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">操作系统提供的单调增加的时间。尽管不是完全正确，但此时间不会跳跃并且具有相对稳定的频率。但是，如果系统挂起，则操作系统单调时间停止的情况并不罕见。该时间通常会增加，因为某些未指定的时间点未连接到 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 。并非所有操作系统都必须提供这种类型的时间。</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">一个更复杂的例子,有两个四核处理器,每个处理器在自己的NUMA节点上。逻辑处理器的排序有点奇怪。这是为了给标识符列表一个更好的例子。</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">对这一过程的状态进行更详细的内部表述。</target>
        </trans-unit>
        <trans-unit id="2c7b4f8b72fc3001a39709ba6f707df737f50704" translate="yes" xml:space="preserve">
          <source>A more explicit way to cancel a timer is to use a &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; on the form &lt;code&gt; {TimeoutType, cancel} &lt;/code&gt; which is a feature introduced in OTP 22.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">更精确的MIB规范语言</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">此格式处理程序的一个更完善的版本是Observer应用程序的目录 &lt;code&gt;src&lt;/code&gt; 中包含的 &lt;code&gt;multitrace.erl&lt;/code&gt; 模块中的 &lt;code&gt;handle_gc/4&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">一个多语言的SNMP管理器。</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">一个与从配置文件中读取的数据值相关联的名称(一个Erlang原子)。</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">通过require语句或对 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 的调用（例如 &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; )引入的配置数据的名称和关联。</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">由创建它们的函数名称构建的名称。</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">数据名称必须在套件中使用 &lt;code&gt;require&lt;/code&gt; 分配（请参见上面的示例）。将此名称作为参数 &lt;code&gt;SnmpAppConfName&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ct_snmp&lt;/code&gt; 为某些 &lt;code&gt;SNMP&lt;/code&gt; 应用程序配置参数（例如，参数 &lt;code&gt;config&lt;/code&gt; 的 &lt;code&gt;{verbosity,trace}&lt;/code&gt; ）指定默认值。这组默认值与用户指定的参数合并。用户值将覆盖 &lt;code&gt;ct_snmp&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">这个动词总是需要一个名字。在一个模式中可以有任意多的(*MARK)实例,它们的名字不一定是唯一的。</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">在返回之前进行 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 本机功能会降低VM的响应能力，并可能导致其他奇怪的行为。这种奇怪的行为包括但不限于极端的内存使用情况以及调度程序之间的不良负载平衡。在Erlang / OTP发行版之间，由于冗长的工作而可能发生的奇怪行为也可能有所不同。</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">执行本机功能作为VM的本机代码的直接扩展。执行不是在安全的环境中进行的。VM &lt;strong&gt;无法&lt;/strong&gt;提供执行Erlang代码时提供的相同服务，例如抢先式调度或内存保护。如果本机功能运行不正常，则整个VM都会出现异常。</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">一个原生函数如果崩溃,会使整个虚拟机崩溃。</target>
        </trans-unit>
        <trans-unit id="1b2752eee15054c7525aaed65d65bee26e41c9b7" translate="yes" xml:space="preserve">
          <source>A native function that crashes will crash the whole VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">一个原生的有符号的64位整数类型。</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">本机无符号64位整数类型。</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">如果 &lt;code&gt;WindowBits&lt;/code&gt; 值为负，则zlib将忽略流中的zlib标头（和校验和）。请注意，zlib源仅将此作为未记录的功能提及。</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">负长度可以用来提取二进制末尾的字节。</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">消极的反应可以如下:</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">负值会导致运行时系统终止无限期等待，直到完全写入故障转储文件为止。这是如果选项默认 &lt;code&gt;-heart&lt;/code&gt; 是&lt;strong&gt;不会&lt;/strong&gt;传递到 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">例如,网络接口过滤器可以在测试期间使用或用于负载调节。</target>
        </trans-unit>
        <trans-unit id="0081be6ade151701784fff921945a2cc10ab3867" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;&lt;a href=&quot;snmp_config#agent_ni_req_limit&quot;&gt;req_limit&lt;/a&gt;&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">网络接口过滤器可以例如在测试期间使用或用于负载调节。如果预期用途是负载调节，则另请参见 &lt;code&gt;req_limit&lt;/code&gt; 和函数 &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">创建新的 &lt;code&gt;person&lt;/code&gt; 记录，如下所示：</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">在制作发行包之前，生成了一个新的引导脚本，没有设置 &lt;code&gt;local&lt;/code&gt; 选项。在发行包中，所有应用程序目录均位于 &lt;code&gt;lib&lt;/code&gt; 下。您不知道发行软件包的安装位置，因此不允许使用硬编码的绝对路径。</target>
        </trans-unit>
        <trans-unit id="207531ae5013e77eabff64456ffa724e18f8f181" translate="yes" xml:space="preserve">
          <source>A new config file format was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">现在添加了一个新的接口 &lt;code&gt;delete/1&lt;/code&gt; 来处理当进程要放弃索引表（即构建一个全新表）时的情况。任何使用瞬态snmp索引的应用程序都必须进行修改才能处理。</target>
        </trans-unit>
        <trans-unit id="f3852a09c1ed59005d5821e005f965364a5620d8" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt; on the node &lt;code&gt;Node&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;Module:Function&lt;/code&gt; 应用于 &lt;code&gt;Args&lt;/code&gt; 可以启动一个新过程。同时监视该过程。返回进程标识符和监视器的引用。否则像 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">一条新记录已被写入。 &lt;code&gt;NewRecord&lt;/code&gt; 包含新记录值，而 &lt;code&gt;OldRecords&lt;/code&gt; 包含执行操作之前的记录。请注意，新内容取决于表类型。</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">一条新记录已被写入。 &lt;code&gt;NewRecord&lt;/code&gt; 包含新的记录值。</target>
        </trans-unit>
        <trans-unit id="45c9322699414697ef1b7c8765e8214aef90bc96" translate="yes" xml:space="preserve">
          <source>A new tuple with the tag &lt;code&gt;available_memory&lt;/code&gt; will be added to the result when this value is provided by the kernel. The &lt;code&gt;available_memory&lt;/code&gt; value informs about the amount memory that is available for use if there is an increased memory need. This value is not based on a calculation of the other provided values and should give a better value of the amount of memory that actually is available than calculating a value based on the other values reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">现在必须创建 &lt;code&gt;ch_app.app&lt;/code&gt; 文件的新版本，并在该版本中进行更新：</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">也可以通过以下列五个序列之一开始模式字符串来指定换行约定。</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">在没有HiPE支持的非SMP模拟器中,一个新生成的Erlang进程会使用309个字的内存(SMP支持和HiPE支持都会增加这个大小)。(SMP支持和HiPE支持都会增加这个字数。)字数的大小可以如下所示。</target>
        </trans-unit>
        <trans-unit id="1297f35b745c72bd20c54efe3dd92735d746a15b" translate="yes" xml:space="preserve">
          <source>A newly started erlang shell shows that no &lt;code&gt;'ssh-dss'&lt;/code&gt; is present in the &lt;code&gt;public_key&lt;/code&gt; entry:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">一个不错的功能是，包含节点信息的测试规范仍可以用作常规 &lt;code&gt;Common Test&lt;/code&gt; 服务器的输入（如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 一节中所述）。结果是，执行了任何指定在与所讨论的 &lt;code&gt;Common Test&lt;/code&gt; 节点同名的节点上运行的测试（如果从 &lt;code&gt;ct_run&lt;/code&gt; 程序启动，则通常为 &lt;code&gt;ct@somehost&lt;/code&gt; ）。当然，也总是执行没有显式节点关联的测试。</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">节点可能崩溃（可能是有故障的节点，因此已被跟踪）。使用 &lt;code&gt;resume&lt;/code&gt; 可在节点返回时自动在节点上继续跟踪。然后，启动 &lt;code&gt;Runtime_Tools&lt;/code&gt; 时，发生故障的节点将尝试重新连接到跟踪控制节点。这意味着 &lt;code&gt;Runtime_Tools&lt;/code&gt; 必须包含在其他节点的启动链中（如果没有，您仍然可以通过手动启动 &lt;code&gt;Runtime_Tools&lt;/code&gt; ，即通过RPC调用来恢复跟踪）。</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">节点通过EPMD(在其他主机)获取另一个节点的端口号,发起连接请求。</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map_expr&lt;/code&gt; 类型的节点是且仅当它没有参数且没有字段时，才是叶节点。类型为 &lt;code&gt;map_type&lt;/code&gt; 的节点是且仅当它没有字段（ &lt;code&gt;any_size&lt;/code&gt; ）时，才是叶节点。当且仅当其Arity为零时， &lt;code&gt;tuple&lt;/code&gt; 类型的节点才是叶节点。类型为 &lt;code&gt;tuple_type&lt;/code&gt; 的节点是且仅当它没有任何元素时才是叶节点（ &lt;code&gt;any_size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">在Windows上运行的节点只能启动其所在主机上的从属节点。</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">以这种方式启动的节点完全可以使用TLS作为分发协议。</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">以这种方式启动的节点将只能通过IPv6使用SSL/TLS分发与其他节点通信。</target>
        </trans-unit>
        <trans-unit id="943b5fd70c0828774c26840cbeb96989a96b92f2" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using TLS distribution over IPv6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">以命令行标志 &lt;code&gt;-hidden&lt;/code&gt; （请参见 &lt;code&gt;erl(1)&lt;/code&gt; ）开头的节点被称为&lt;strong&gt;隐藏&lt;/strong&gt;节点。隐藏节点会建立与不属于同一全局组的节点的隐藏连接，但会建立与属于同一全局组的节点的普通（可见）连接。</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">节点通过关闭节点注册时建立的与EPMD的TCP连接来解除自己在EPMD中的注册。</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">长节点名的节点不能与短节点名的节点通信。</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">名称为 &lt;code&gt;Name@Host&lt;/code&gt; 节点已存在。</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">函数的非本地返回。如果在 &lt;code&gt;catch&lt;/code&gt; 中求值，则 &lt;code&gt;catch&lt;/code&gt; 返回值 &lt;code&gt;Any&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">可以在语法规则的左侧（= &lt;code&gt;lhs&lt;/code&gt; 或 &lt;code&gt;head&lt;/code&gt; ）使用非终止类别。它也可以出现在规则的右侧。</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">语法树的非空列表 &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; 。这等效于传递 &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">语法树列表的非空列表 &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; ，等效于传递 &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">普通文件实际上是一个过程，因此可以用作I / O设备（请参阅 &lt;code&gt;io&lt;/code&gt; ）。因此，在将数据写入普通文件时，将数据发送到文件过程会复制所有不是二进制文件的数据。因此，建议以二进制模式打开文件并写入二进制文件。如果在另一个节点上打开文件，或者文件服务器作为另一个节点的文件服务器的从属服务器运行，则还会复制二进制文件。</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">运行OTP的嵌入式Windows NT需要正常安装Windows NT 4.0和Service Pack 4或更高版本。</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">一个普通的调度器线程。</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">一个显着的返回值是 &lt;code&gt;{error, closed}&lt;/code&gt; 指示套接字已关闭。</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">一个告诉类型的哪一部分要被解码的符号。</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">告知信息结构中哪些部分要被排除在解码之外的符号。</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">警告提示：如果将远程函数的名称传递给内置函数 &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;spawn&lt;/code&gt; &lt;strong&gt;，&lt;/strong&gt;则Igor无法做任何事情，&lt;strong&gt;除非&lt;/strong&gt;在调用中明确声明了模块和函数的名称，例如 &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; 。在所有其他情况下，Igor都不会更改此类调用，并警告用户可能需要手动编辑。</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通知过滤器是实现 &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; 行为的模块。使用以下功能添加/删除过滤器： &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">一个空函数值(即,一个接受零参数的fun)。例子。</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">一个数字(从0开始),表示该函数中该fun的数量。</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须存在许多对象，SSH应用程序才能正常工作。默认情况下，选择对象存储在文件中。默认名称，路径和文件格式与 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 相同。可以使用OpenSSH 的 &lt;code&gt;ssh-keygen&lt;/code&gt; 程序生成密钥。请参阅《 &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba15943266d8f4ba14bfaf35d8549aabc72bd73a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Those objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">对申请的单线描述;</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一次性计时器，即通过评估函数 &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; 中的任何一个函数创建的计时器均未链接到任何过程。因此，仅在达到超时或通过调用 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 显式删除该计时器时，才将其删除。</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">数据包是由定界符字节终止的行，默认为latin-1换行符。分隔符字节包含在返回的数据包中，除非根据选项 &lt;code&gt;line_length&lt;/code&gt; 截断了该行。</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一对 &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; ，其中 &lt;code&gt;LineNumber&lt;/code&gt; 是一个非负整数，而 &lt;code&gt;SimpleTest&lt;/code&gt; 是另一个简单的测试对象。 &lt;code&gt;LineNumber&lt;/code&gt; 应该指示测试的源行。通常只通过 &lt;code&gt;?_test(...)&lt;/code&gt; 宏来创建这样的对。请参阅 &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">并行测试用例具有专用I / O服务器作为其组长。（有关组长概念的描述，请参阅 &lt;code&gt;ERTS&lt;/code&gt; ）。中央I / O服务器进程处理常规测试用例和配置功能的输出，在并行组执行期间不响应I / O消息。了解这一点很重要，以避免出现某些陷阱，如下所示：</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">参数化类型将被视为嵌入式类型。每次引用这种类型时，都会定义其实例。因此，在下面的例子中有名的记录 &lt;code&gt;'Seq_b'&lt;/code&gt; 在生成 &lt;code&gt;.hrl&lt;/code&gt; 文件，并且用于保持值：</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">一个括号内的子模式(包括断言)</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">一个将趣味语法转化为匹配规范的解析转换。</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">部分交付失败。在Erlang / SCTP绑定的当前实现中，此事件在内部转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">可以选择一种模式来缩小剖析范围。例如,可以选择一个特定的模块,并且只对该模块中执行的代码进行剖析。</target>
        </trans-unit>
        <trans-unit id="387373efa88307dec031353d353693de37d89f74" translate="yes" xml:space="preserve">
          <source>A pattern for an instruction consists of its name, followed by a pattern for each of its operands. The operand patterns are separated by spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">模式的结构与术语相同,但可以包含非绑定变量。</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">模式是一个术语,可以包含。</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">与某条记录相匹配的模式,其创建方式与创建记录的方式相同。</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">启动连接时不需要对等体的DiameterIdentity:身份标识在能力交换时接收,此时如果身份标识有异议,可以拒绝连接。</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">任何数据类型的数据都称为&lt;strong&gt;术语&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">指向要在创建的线程中执行的函数的指针。</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">一个指向线程标识符变量的指针。</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">一个指向整数的指针。该整数用于传递输入和输出大小(见下文)。</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">指向输出缓冲区的指针。</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">一个指向另一个端口结构的指针,它既可以是这个端口接受连接的监听端口,也可以反过来。伙伴关系 &quot;总是双向的。</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">指向 &lt;code&gt;func&lt;/code&gt; 函数的参数的指针。</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">指向 &lt;code&gt;t&lt;/code&gt; 内容的指针。</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">指向实现NIF的函数的指针。</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">指向要使用的线程选项的指针或 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">可以将 port 设置为使用二进制文件而不是字节列表。这样就不需要发明任何编码/解码方案。Erl_Interface 函数用于解压二进制文件,并将其转换为一个类似于 Erlang 术语的结构。这样的结构可以用不同的方式进行操作,转换为Erlang外部格式,并发送给Erlang。</target>
        </trans-unit>
        <trans-unit id="7a9af688d21b53184095c38ddf61f01deed4f70c" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt; driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt; driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt; driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">端口数据锁被引用计数，当引用计数达到零时，它将被销毁。创建锁时，仿真器至少会增加一次参考计数，一旦与锁关联的端口终止，模拟器就会将其递减。当排队异步作业时，仿真器还会增加引用计数，而在调用异步作业时，模拟器也会减少引用计数。而且，驾驶员有责任确保在驾驶员最后一次使用锁之前，参考计数不为零。可以分别通过 &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; 读取，递增和递减引用计数。</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">移植驱动程序是一个链接在一起的驱动程序,它可以作为一个端口从 Erlang 程序中访问。它是一个共享库 (在 UNIX 中是 SO,在 Windows 中是 DLL),具有特殊的入口点。Erlang 运行时系统会在驱动程序启动和数据被发送到 port 时调用这些入口点。端口驱动程序也可以向 Erlang 发送数据。</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">一个端口标识符标识一个 Erlang 端口。</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">一个端口标识符指入一个端口表和一个节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">端口标识符。与端口ID术语（ &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 的实例）相比， &lt;code&gt;ErlNifPort&lt;/code&gt; 是自包含的，并且不受任何 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; 约束。 &lt;code&gt;ErlNifPort&lt;/code&gt; 是不透明的类型。</target>
        </trans-unit>
        <trans-unit id="ea470bfa2ec4cfaf642ebb2fc7a49f8233c8c023" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">一个连接到监听套接字的端口。这个端口的作用不大,在这个套接字上不做任何数据泵送,但当人们想在这个端口上做接受时,可以读取数据。</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">正整数或 &lt;code&gt;infinity&lt;/code&gt; ，默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">正整数或原子 &lt;code&gt;undefined_serial&lt;/code&gt; （如果未发送消息）。</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">一个正整数，表示从此格式化程序返回的字符串可以具有的绝对最大大小。如果格式化的字符串较长，则可能会被 &lt;code&gt;chars_limit&lt;/code&gt; 或 &lt;code&gt;depth&lt;/code&gt; 限制后，将被截断。</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">一个正整数，表示此格式化程序将打印术语的最大深度。传递给此格式化程序的格式化字符串将被重写。格式控件〜p和〜w分别替换为〜P和〜W，并且该值用作深度参数。有关详细信息，请参见STDLIB中的 &lt;code&gt;io:format/2,3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0c5f0649daa5aaf66aa8692a46961fb52172dd0" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt; io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">一个正整数，表示与调用 &lt;code&gt;io_lib:format/3&lt;/code&gt; 时使用的名称相同的选项的值。此值限制为每个日志事件打印的字符总数。请注意，这是一个软限制。有关硬截断限制，请参见选项 &lt;code&gt;max_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">一个正整数,默认为1。</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">系统的 &lt;code&gt;sequential_tracer&lt;/code&gt; 可能输出可能是这样的：</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">定义了谓词 &lt;code&gt;Big(X)&lt;/code&gt; ，如果其参数大于10 ，则为 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">谓词是返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的函数。 &lt;code&gt;any&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，如果有一个术语 &lt;code&gt;X&lt;/code&gt; 在列表中，使得 &lt;code&gt;P(X)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">前缀是可选的,但可用于在不同Diameter应用中类似命名的消息和AVP所产生的记录和常量名称之间进行混淆。</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">先前加载的模块包含从未完成的 &lt;code&gt;-on_load&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">如果在一个节点上启动了一个复制表，则可能会出现问题，但是 &lt;code&gt;Mnesia&lt;/code&gt; 推断出另一个（远程）副本比本地节点上存在的副本更新，并且初始化过程不会继续进行。在这种情况下，对 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; 的调用将挂起调用方，直到远程节点已从其本地磁盘初始化该表并且该节点已通过网络将该表复制到了本地节点。</target>
        </trans-unit>
        <trans-unit id="6f4802cb3c2b14a3f4d0a0759994b3bcff8bf5ac" translate="yes" xml:space="preserve">
          <source>A process bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process bound environments between NIF calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">完成调用后，将立即调度调用 &lt;code&gt;spawn&lt;/code&gt; ， &lt;code&gt;spawn_link&lt;/code&gt; ， &lt;code&gt;spawn_monitor&lt;/code&gt; 或 &lt;code&gt;spawn_opt&lt;/code&gt; 的进程。当使用较高的已修改计时级别时，呼叫者在安排好时间后还会睡眠一会儿。</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果进程收到退出信号的原因是 &lt;code&gt;normal&lt;/code&gt; 退出，退出原因也可能是其他原因，请参见 &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">进程还可以调用函数 &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; 。这将导致退出信号，退出原因 &lt;code&gt;Reason&lt;/code&gt; 被发送到 &lt;code&gt;Pid&lt;/code&gt; ，但不影响调用过程。</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">进程可以通过调用来设置退出信号陷阱。</target>
        </trans-unit>
        <trans-unit id="49077ba72c45965099e62393fc4505d1bc5f8e7a" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt; erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">一个进程可以被多个进程挂起，并且可以被单个进程多次挂起。挂起的进程直到其挂起计数达到零时才离开挂起状态。挂起的计数 &lt;code&gt;Suspendee&lt;/code&gt; 时减小 &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; 由相同的过程称为调用 &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; 。当进程终止时，由该进程获取的其他进程上所有增加的挂起计数将自动减少。</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">一个进程可以通过调用以下BIF来终止自己。</target>
        </trans-unit>
        <trans-unit id="b321553d2b5e342e2d1b929ffc0921e013068c69" translate="yes" xml:space="preserve">
          <source>A process created due to a spawn request that has been abandoned may communicate with its parent as any other process. It is &lt;strong&gt;only&lt;/strong&gt; the direct effects on the parent of the actual spawn request, that will be canceled by abandoning a spawn request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">进程通过调用 &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; 修复表。该表将保持固定状态，直到进程通过调用 &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; 释放该表，或者直到该进程终止。</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">进程标识符（pid）。与pid术语（ &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 的实例）相反， &lt;code&gt;ErlNifPid&lt;/code&gt; 是自包含的，并且不受任何 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; 约束。 &lt;code&gt;ErlNifPid&lt;/code&gt; 是不透明的类型。</target>
        </trans-unit>
        <trans-unit id="ba9734ec123feb8eec22b585c124792c0472e055" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type. It can be copied, moved in memory, forgotten, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">如 &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 中的过程标识符。表示创建乐趣的过程。</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">进程标识符指入一个进程表和一个节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">进程标识符pid标识一个进程。</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">监督树中的进程应该与它的父进程以相同的理由终止。</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">通过调用 &lt;code&gt;spawn&lt;/code&gt; 创建一个进程：</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">的方法被说成&lt;strong&gt;使用&lt;/strong&gt;一个模块 &lt;code&gt;Mod&lt;/code&gt; 如果 &lt;code&gt;Mod&lt;/code&gt; 在列出 &lt;code&gt;Modules&lt;/code&gt; 用于启动过程中的子规范的一部分，见 &lt;code&gt;supervisor(3)&lt;/code&gt; 。在 &lt;code&gt;gen_event&lt;/code&gt; 的情况下，如果 &lt;code&gt;Mod&lt;/code&gt; 是已安装的事件处理程序，则说事件管理器进程使用 &lt;code&gt;Mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">如果退出原因是原子 &lt;code&gt;normal&lt;/code&gt; ，则称该过程&lt;strong&gt;正常&lt;/strong&gt;终止。没有更多代码可执行的进程将正常终止。</target>
        </trans-unit>
        <trans-unit id="fb8a0c82e2b3e6de1b3a292697b7dd18d1ac9e70" translate="yes" xml:space="preserve">
          <source>A process may join multiple groups. It may join the same group multiple times. It is only allowed to join processes running on local node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5476607e3cda2543b898df9573ff320bd9b1b5a4" translate="yes" xml:space="preserve">
          <source>A process must complete the sending of a fragmented message before it can start sending any other message on the same distribution channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262937e9bbf32c8d0ea317c09244f8bdfd384e14" translate="yes" xml:space="preserve">
          <source>A process spawn is represented as multiple information transfers. At least one spawn request and one spawn reply. The actual amount of information transfers depends on what type of spawn it is and may also change in future implementations. Note that this is more or less an internal protocol that you are peeking at. The spawn request will be represented as a tuple with the first element containing the atom &lt;code&gt;spawn_request&lt;/code&gt;, but this is more or less all that you can depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">使用这些函数之一启动的进程会存储监督树中进程所需的信息(例如,关于祖先和初始调用)。</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">当没有其他事情要做时，进程终止，也就是说，它调用的最后一个函数只是返回而不会调用另一个函数。进程终止的另一种方法是调用 &lt;code&gt;exit/1&lt;/code&gt; 。 &lt;code&gt;exit/1&lt;/code&gt; 的参数具有特殊含义，稍后将进行讨论。在此示例中，完成 &lt;code&gt;exit(normal)&lt;/code&gt; 的操作与退出要调用的函数的进程的效果相同。</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">发生运行时错误时 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 进程将以退出原因{Reason，Stack}终止。请参阅 &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">当组节点连接或断开连接时，已订阅的进程将分别收到消息 &lt;code&gt;{nodeup, Node}&lt;/code&gt; 和 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">数据寿命短的进程很少或永远不会被完全清除，也就是说，旧堆主要包含垃圾。为确保偶尔进行全扫，请将 &lt;code&gt;Number&lt;/code&gt; 设置为适当的值，例如10或20。</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">终止的过程会发出&lt;strong&gt;退出信号&lt;/strong&gt;，其&lt;strong&gt;退出原因&lt;/strong&gt;说明发生了什么错误。通常，有关错误的一些信息会打印到终端上。</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">如果名称在该进程的子规范的&amp;ldquo; &lt;code&gt;Modules&lt;/code&gt; 中列出，则该进程将使用模块。</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">遇到运行时错误（例如，被零除，不匹配，尝试调用不存在的函数等）的进程将退出，并显示错误，即&lt;strong&gt;异常&lt;/strong&gt;退出。一个执行 &lt;code&gt;exit(Reason)&lt;/code&gt; 的进程，其中 &lt;code&gt;Reason&lt;/code&gt; 是除原子 &lt;code&gt;normal&lt;/code&gt; 之外的任何Erlang术语，也有异常的退出。</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">执行 &lt;code&gt;exit(normal)&lt;/code&gt; 或干脆要用完的事情的进程将具有&lt;strong&gt;正常&lt;/strong&gt;退出。</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">进程绑定的环境包含了调用Erlang进程的瞬时信息。这个环境只在提供它作为参数的线程中有效,直到NIF返回。因此,在NIF调用之间存储进程绑定环境的指针是无用和危险的。</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">一种程序开发技术，&lt;strong&gt;在&lt;/strong&gt;实现应该通过这些测试的代码&lt;strong&gt;之前&lt;/strong&gt;，您要连续编写测试。通过让单元测试确定程序何时&amp;ldquo;完成&amp;rdquo;，这可以帮助您专注于解决正确的问题，而不用进行比必要的复杂的实现：如果程序满足其规范，则无需继续添加功能。</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">一个程序无论在哪个数据位置都能工作。无论数据是驻留在本地节点还是远程节点上,都没有区别。</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">如果只能从Shell运行代码，则编程语言没有太大用处。这是一个小的Erlang程序。使用适当的文本编辑器将其输入到名为 &lt;code&gt;tut.erl&lt;/code&gt; 的文件中。文件名 &lt;code&gt;tut.erl&lt;/code&gt; 很重要，而且它与您启动 &lt;code&gt;erl&lt;/code&gt; 的目录位于同一目录中。如果幸运的话，您的编辑器提供了一种Erlang模式，可以使您轻松轻松地很好地输入和格式化代码（请参阅 &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; 工具用户指南》中的Emacs的Erlang模式），但是如果没有它，则可以很好地进行管理。这是要输入的代码：</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">当主管开始或重新开始一个儿童时,会发出一份进度报告。进度报告包含以下项目:</target>
        </trans-unit>
        <trans-unit id="7a2323a209e1a22ed12fa10ec6f9c3cae4a441ed" translate="yes" xml:space="preserve">
          <source>A proper list of arguments to use in the call to the entry point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5b72e9976f09f432e0a687f016f57f9a5aece" translate="yes" xml:space="preserve">
          <source>A proper list of spawn options to use when spawning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">上面 &lt;code&gt;tos&lt;/code&gt; 的与协议无关的等效项。设置优先级也意味着要设置 &lt;code&gt;tos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">使用提供的用户名和密码的代理授权头被添加到请求中。</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已为该会话请求了伪终端。 &lt;code&gt;Terminal&lt;/code&gt; 是TERM环境变量值的值，即 &lt;code&gt;vt100&lt;/code&gt; 。零尺寸参数必须忽略。字符/行尺寸会覆盖像素尺寸（非零时）。像素尺寸是指窗口的可绘制区域。 &lt;code&gt;Opcode&lt;/code&gt; 在 &lt;code&gt;TerminalModes&lt;/code&gt; 列表是助记符名称，表示为小写二郎原子，所述 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 的第8章它也可以是一个 &lt;code&gt;Opcode&lt;/code&gt; ，如果助记符名称没有在RFC列出。示例： &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; 。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="1fc5e44171b910f411dd9eff54be6144ce19b764" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section/8&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">修饰词Q是下列之一。</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">查询句柄的评估顺序如下。</target>
        </trans-unit>
        <trans-unit id="0e8baf0d28cdf7d93d387dd8846b5f6b10083008" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on a particular platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">原始选项请求 &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; 可用于获取有关仿真器不（明确）支持的套接字选项的信息。使用原始套接字选项使代码不可移植，但允许Erlang程序员利用当前平台上存在的异常功能。</target>
        </trans-unit>
        <trans-unit id="3ebff0e214120dc5d32ac8a4a0637ce5cce89676" translate="yes" xml:space="preserve">
          <source>A read event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_input&lt;/code&gt; notification message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于初次使用的用户，建议的起点是 &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; 数据类型和函数 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="eb56dddcb8b70cd19ebdc2bcc639e335bb693c26" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">记录的定义可以放在一个模块的属性和函数声明中的任何地方,但定义必须在记录的任何使用之前出现。</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">记录定义包括记录的名称，然后是记录的字段名称。记录和字段名称必须是原子。可以为每个字段提供一个可选的默认值。如果未提供默认值，则使用 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">一条记录可能已通过 &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; 删除。 &lt;code&gt;OldRecord&lt;/code&gt; 包含旧记录的值，如应用程序作为参数所述。请注意，如果类型为 &lt;code&gt;bag&lt;/code&gt; ，则具有相同键的其他记录可以保留在表中。</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">记录是用于存储固定数量的元素的数据结构。它具有命名字段，并且类似于C中的结构。但是，记录不是真正的数据类型。而是在编译过程中将记录表达式转换为元组表达式。因此，除非采取特殊措施，否则外壳无法理解记录表达式。有关详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">记录是用于存储固定数量的元素的数据结构。它具有命名字段，类似于C中的结构。在编译过程中，记录表达式会转换为元组表达式。因此，除非采取特殊措施，否则外壳无法理解记录表达式。有关详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">记录的定义是:</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">描述员工的记录可以如下所示:</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">引用是在Erlang运行时系统中唯一的术语，通过调用 &lt;code&gt;make_ref/0&lt;/code&gt; 创建。</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">引用指入节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="f5a40d0612040493ede164c97573dfd19a4e473a" translate="yes" xml:space="preserve">
          <source>A reference that uniquely identifies the (select) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">一个注册名称;</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">发生了已注册的发送操作，并且 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 包含发送者的pid。该消息在 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">发生注册的发送操作。 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 包含发送者的pid。</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">关闭先前使用 &lt;code&gt;ei_reg_open()&lt;/code&gt; 创建的注册表，并释放其中包含的所有对象。</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">一个基于正则表达式的Erlang词汇分析生成器,类似于lex或flex。</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">正则表达式是一种从左到右与主题字符串匹配的模式。大多数字符在模式中代表自己,并与主题中的相应字符相匹配。作为一个微不足道的例子,下面的模式匹配了主题字符串中与自己相同的部分。</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">如果X的每个元素x的x R x是X，则X中的关系R是&lt;strong&gt;自反的&lt;/strong&gt;，如果x R y表示y R x 是&lt;strong&gt;对称的&lt;/strong&gt;，并且x R y和y R z表示x R z 是可&lt;strong&gt;传递的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">如果集合中的&lt;strong&gt;关系&lt;/strong&gt;是自反的，对称的和可传递的，则它是&lt;strong&gt;等价关系&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">适合电信应用的关系/对象混合数据模型。</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">释放包还可以包含:</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">一个发布包总是要包含:</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">发行升级文件， &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">一个发布的应用必须遵循一定的结构。</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">relup脚本只能有一个 &lt;code&gt;restart_emulator&lt;/code&gt; 指令，并且必须始终将其放在最后。如果relup由 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成，则会自动确保。</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">不能使用远程Erlang文件服务器。运行Erlang节点的计算机必须能够访问文件系统(直接或通过NFS)。</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">远程执行会由于信号而剧烈终止。然后可以接收到此消息。有关有效字符串值的详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 第6.10节，其中显示了这些信号的特殊情况。</target>
        </trans-unit>
        <trans-unit id="9c596892eeac26bffdaa259eeeee428644ec4341" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-6.10&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">如果存在来自X上Y的任何pid，端口，引用或funs（Erlang数据类型），或者X和Y已连接，则远程节点Y必须为节点X已知。节点同时/曾经知道的最大远程节点数受节点名称可用的 &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; 限制。除节点名称原子外，所有与远程节点有关的数据都将被垃圾收集。</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">使用此功能发送的回复在 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug输出中不可见。</target>
        </trans-unit>
        <trans-unit id="968b931f26a7eb0a1ce8e38bc2b4799ef2fd705f" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt; logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">格式化程序使用报告回调将报告表单上的日志消息转换为格式字符串和参数。可以在日志事件的元数据中指定报告回调。如果元数据中不存在报告回调，则 &lt;code&gt;logger_formatter&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; 作为默认回调。</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">二进制中一部分（或范围）的表示。 &lt;code&gt;Start&lt;/code&gt; 是 &lt;code&gt;binary()&lt;/code&gt; 从零开始的偏移量，而 &lt;code&gt;Length&lt;/code&gt; 是该部分的长度。作为此模块中功能的输入，允许使用反向 &lt;code&gt;Length&lt;/code&gt; 规格，并以负的Length构造，以便二进制文件的一部分从 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; 开始，且长度为 &lt;code&gt;Length&lt;/code&gt; 。这对于将二进制文件的最后 &lt;code&gt;N&lt;/code&gt; 个字节引用为 &lt;code&gt;{size(Binary), -N}&lt;/code&gt; 很有用。此模块中的函数始终返回具有正 &lt;code&gt;Length&lt;/code&gt; 的 &lt;code&gt;part()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1aa5116d3fb4b00376ef8dcd3fa6e2ce235d63" translate="yes" xml:space="preserve">
          <source>A representation of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">pretty-printer当前上下文的表示。可以在钩子函数中访问。</target>
        </trans-unit>
        <trans-unit id="e2faa414df8b457497c58bbac25134eed33ca746" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt; send_request/2 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060acb73f9bf52d61dfcf27189e091e2a0ff80f3" translate="yes" xml:space="preserve">
          <source>A request handle, see &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt; send_request/3 &lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">对 http://your.server.org/cgi-bin/example/httpd_example:yahoo 的请求将引用 httpd_example:yahoo/3,如果该请求不存在,httpd_example:yahoo/2 和 http://your.server.org/cgi-bin/example/other:yahoo 将不允许执行。</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">在收到响应DPR的DPA后终止传输过程的请求。运输过程应退出。 &lt;code&gt;Pid&lt;/code&gt; 是父进程的pid（）。</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">如果在任何配置文件中都找不到必需的变量，则还可以为其指定默认值。要指定默认值，请将格式为 &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; 的元组添加到测试用例信息列表（列表中的位置无关）。</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">如果在调用 &lt;code&gt;binary_to_term&lt;/code&gt; 时资源对象仍然处于活动状态，则可以使用 &lt;code&gt;term_to_binary&lt;/code&gt; 序列化资源术语，然后完全重新创建资源术语。如果已释放资源对象， &lt;code&gt;binary_to_term&lt;/code&gt; 从binary_to_term返回一个&lt;strong&gt;过时的&lt;/strong&gt;资源术语。 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 将返回false为过时资源方面。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">一个要管理的资源由一个管理对象来表示,它驻留在MIB中。在SNMP MIB中,被管理对象是:</target>
        </trans-unit>
        <trans-unit id="8e4eb7e095c0c09d5767bd5279f5cdff3096b732" translate="yes" xml:space="preserve">
          <source>A restricted set of &lt;code&gt;&lt;a href=&quot;#type-spawn_option&quot;&gt;spawn options&lt;/a&gt;&lt;/code&gt;. Most notably &lt;code&gt;monitor&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; part of these options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 将返回的错误原因转换为可读的字符串。</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">一个基本的DNS客户端。</target>
        </trans-unit>
        <trans-unit id="59d2054b44ad5d0ec1cf63133801ae0786ec3996" translate="yes" xml:space="preserve">
          <source>A rule is recognized by its right-pointer arrow: &lt;code&gt;=&amp;gt;&lt;/code&gt;. To the left of the arrow is one or more instruction patterns, separated by &lt;code&gt;|&lt;/code&gt;. To the right of the arrow is zero or more instructions, separated by &lt;code&gt;|&lt;/code&gt;. If the instructions from the BEAM code matches the instruction patterns on the left side, they will be replaced with instructions on the right side (or removed if there are no instructions on the right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab6d0ea4f0599f5b342196442f9968fded07ef" translate="yes" xml:space="preserve">
          <source>A run queue has four queues for processes of different priority and one queue for ports. The scheduler thread associated with the run queue switch evenly between execution of processes and execution of ports while both processes and ports exist in the queue. This is not completely true, but not important for this discussion. A port that is in a run queue also has a queue of tasks to execute. Each task corresponds to an in- or outgoing signal. When the port is selected for execution each task will be executed in sequence. The run queue locks not only protected the queues of ports, but also the queues of port tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">也可以通过调用 &lt;code&gt;erlang:error(Reason)&lt;/code&gt; 或 &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; 来模拟运行时错误。</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">运行时错误是类 &lt;code&gt;error&lt;/code&gt; 异常的别称。</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">运行时错误是指发生崩溃。一个例子是当一个运算符被应用到错误类型的参数时。Erlang编程语言具有处理运行时错误的内置功能。</target>
        </trans-unit>
        <trans-unit id="fe2de4d023b6ff93a7868d6e63e1e0f0f608db09" translate="yes" xml:space="preserve">
          <source>A runtime error occurred which raised and error exception while applying the function, and the applied function did not catch the exception. The error reason &lt;code&gt;ErrorReason&lt;/code&gt; indicates the type of error that occurred. &lt;code&gt;StackTrace&lt;/code&gt; is formatted as when caught in a &lt;code&gt;try/catch&lt;/code&gt; construct. The &lt;code&gt;StackTrace&lt;/code&gt; is limited to the applied function and functions called by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">一个运行时系统锁分析工具。</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">反斜杠的第二种用法是以可见的方式对模式中的非打印字符进行编码。除了终止模式的二进制零之外,非打印字符的出现没有限制。当通过文本编辑准备一个模式时,使用以下转义序列之一往往比它所代表的二进制字符更容易。</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">指定配置文件的第二种方法是将环境变量 &lt;code&gt;ERL_INETRC&lt;/code&gt; 设置为文件的全名。示例（重击）：</target>
        </trans-unit>
        <trans-unit id="7c03bbcb91f237153974d54fa53f5db174271fa2" translate="yes" xml:space="preserve">
          <source>A seed value for the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">&lt;code&gt;utf16&lt;/code&gt; 类型的段可以匹配二进制文件中的2或4个字节。如果匹配位置的二进制文件不包含Unicode代码点的合法UTF-16编码，则匹配失败。（请参阅RFC-2781或Unicode标准。）</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">&lt;code&gt;utf32&lt;/code&gt; 类型的段可以匹配二进制文件中的4个字节，就像 &lt;code&gt;integer&lt;/code&gt; 段匹配32位一样。如果结果整数超出上述合法范围，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">如果匹配位置的二进制文件包含有效的UTF-8序列，则 &lt;code&gt;utf8&lt;/code&gt; 类型的段将匹配二进制文件中的1-4个字节。（请参阅RFC-3629或Unicode标准。）</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">对于任何 &lt;code&gt;gen_*&lt;/code&gt; 行为，不能从 &lt;code&gt;gen_statem&lt;/code&gt; 行为使用选择性接收，因为receive语句位于 &lt;code&gt;gen_*&lt;/code&gt; 引擎本身内。之所以必须存在，是因为所有与 &lt;code&gt;sys&lt;/code&gt; 兼容的行为都必须响应系统消息，并因此在其引擎接收循环中执行此操作，从而将非系统消息传递给回调模块。</target>
        </trans-unit>
        <trans-unit id="0745a97f08a27b99c095a4208fa9ad69e20c8725" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behaviour (or from any &lt;code&gt;gen_*&lt;/code&gt; behaviour), as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviours must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the &lt;strong&gt;callback module&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">序列组可以具有子组。这样的子组可以具有任何属性，即，它们也不必是序列。如果希望子组的状态影响上述级别的顺序 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 中返回{return_group_result，Status}，如编写测试套件中的 &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; 一节中所述。失败的子组（ &lt;code&gt;Status == failed&lt;/code&gt; ）导致序列的执行失败，就像测试用例一样。</target>
        </trans-unit>
        <trans-unit id="93d62b825639ee7da64906b6efb6ddcaeabea4e9" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0188d5cbf054170629f3b385114881c263276f" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;code&gt;Len&lt;/code&gt; big-endian unsigned integers (4 bytes each, so &lt;code&gt;N'&lt;/code&gt; = 4 * &lt;code&gt;Len&lt;/code&gt;), but is to be regarded as uninterpreted data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例序列被定义为具有 &lt;code&gt;sequence&lt;/code&gt; 属性的测试用例组。测试用例组通过测试套件中的功能 &lt;code&gt;groups/0&lt;/code&gt; 定义（有关详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 一节）。</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">服务器（守护程序）以 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; 启动。启动守护程序时，可能使用 &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; 选项声明了可能的通道处理程序（子系统）。</target>
        </trans-unit>
        <trans-unit id="c393c06211d748a66541912f6034dffb6bc6e68b" translate="yes" xml:space="preserve">
          <source>A server (daemon) will use the user name &lt;code&gt;foo&lt;/code&gt;, and a client will use the name &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">服务器仅在 &lt;code&gt;verify_peer&lt;/code&gt; 模式下进行x509路径验证，因为它随后向客户端发送证书请求（如果verify选项为 &lt;code&gt;verify_none&lt;/code&gt; ,则不会发送此消息）。然后，您还可以指定选项 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e1655ac106f00ec7e87a3349502f0ed6e2829f5" translate="yes" xml:space="preserve">
          <source>A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">一台服务器如果收到的请求刚好够多,永远不会闲置,那么它的CPU利用率就会达到100%。如果服务器多收到50%的请求,它的得分仍然是100%。如果用前面所示的百分比公式计算系统负载,负载将从80%增加到87%。</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">一个服务器或客户端通道进程可以选择通过发送关闭事件来关闭他们的会话。</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">客户端使用 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; 请求服务器端子系统（通道）服务器。</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">服务定义了本地实现的Diameter节点，指定了在能力交换期间要通告的能力。使用 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 将传输添加到服务中。</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">服务必须为其打算支持的每个Diameter应用程序配置一个元组。对于传出请求，相关的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; ，而对于传入请求，消息头中的应用程序标识符确定应用程序，该标识符在应用程序的 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; 文件中指定。</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">以 &lt;code&gt;stand_alone&lt;/code&gt; 形式启动的服务，也就是说，该服务不是作为 &lt;code&gt;Inets&lt;/code&gt; 应用程序的一部分启动的，失去了所有OTP应用程序的优势，例如软升级。该 &lt;code&gt;stand_alone&lt;/code&gt; -service被链接到启动它的过程。通常，某些监督功能仍然存在，并且从某种意义上讲，呼叫过程成为最高主管。</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">不使用共享对等方的服务将始终将空列表作为 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调的第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">读取内部格式化的包盘日志的服务。</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数关闭以这种方式打开的会话。</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">在强连接的组件之间的一组调用是一个排序列表，没有 &lt;code&gt;ComponentCall&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">一组调用由排序列表表示，没有 &lt;code&gt;call()&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">一组常量由一个排序列表表示，没有 &lt;code&gt;constant()&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="b8184ec1b26baabe0df7138952aceaf16df4b13b" translate="yes" xml:space="preserve">
          <source>A set of functions is provided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">提供了一组功能，用于发送和接收要存储在远程文件中的文件的连续部分。有关发送，请参见 &lt;code&gt;send_chunk_start/2&lt;/code&gt; ， &lt;code&gt;send_chunk/2&lt;/code&gt; 和 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 。有关接收，请参见 &lt;code&gt;recv_chunk_start/2&lt;/code&gt; 和 &lt;code&gt;recv_chunk/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数调用由排序列表表示，没有 &lt;code&gt;CallAt&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数和函数调用由排序列表表示，没有 &lt;code&gt;AllLines&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数由一个排序列表表示，没有 &lt;code&gt;DefineAt&lt;/code&gt; 重复项。</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">一组强连接的组件是一个排序列表，没有 &lt;code&gt;Component&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将创建一组表。函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 创建所需的数据库表。 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; 中说明了 &lt;code&gt;ArgList&lt;/code&gt; 可用的选项。</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">一组共享配置功能和执行属性的测试用例。执行属性指定了测试用例组中的测试用例是以随机顺序、并行还是顺序执行,以及测试用例组的执行是否会被重复。测试用例组也可以嵌套。也就是说,一个组除了测试用例之外,还可以包含子组。</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 和 &lt;code&gt;report_warnings&lt;/code&gt; 的简写形式。</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return_errors&lt;/code&gt; 和 &lt;code&gt;return_warnings&lt;/code&gt; 的简写形式。</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">可以使用以下信息向远程进程/服务传递信号。有些系统不支持信号,在这种情况下,它们会忽略这个消息。目前还没有产生这个事件的功能,因为所提到的信号是在操作系统级别的,而不是由Erlang程序产生的东西。</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">一个有符号的64位整数类型,用于表示时间。</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">一个有符号的64位整数类型,用于表示时间。</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">一个有符号整数类型，其大小为 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1024fdaa70807f16fbbe54892e86672633b5e291" translate="yes" xml:space="preserve">
          <source>A significant number of middleboxes misbehave when a TLS 1.3 connection is negotiated. Implementations can increase the chance of making connections through those middleboxes by making the TLS 1.3 handshake more like a TLS 1.2 handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">类似于模块属性的语法被用于指定类型和函数规格。</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">一个简单的调用计数分析工具,使用断点对运行时性能影响最小。</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">使用 &lt;code&gt;connect_init&lt;/code&gt; API的简单Erlang SCTP客户端：</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">可以实现一个简单的配置处理驱动,向外部服务器索取配置数据,具体如下。</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">一个简单的分布式代理可以在没有子代理的情况下进行管理。仪表功能可以使用分布式Erlang与应用程序的其他部分进行通信。然而,如果产生过多不必要的流量,可以在每个节点上使用一个子代理。子代理处理每个传入的SNMP请求,而不是每个变量。因此,网络流量是最小的。</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">一个简单的例子,说明如何使用SNMP开发工具包的管理器组件。</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">一个简单的例子,说明如何使用新管理器编写代理测试用例。</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">一个简单的例子。单个四核处理器可以描述如下。</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">一个打印到终端的简单处理程序可以实现如下。</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">一个简单的交互式配置工具。可以生成简单的配置文件,但更复杂的配置仍需手动编辑。</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">一个简单的解决方案是使用 &lt;code&gt;name&lt;/code&gt; 字段作为键而不是 &lt;code&gt;idno&lt;/code&gt; 字段，但是如果名称不是唯一的，那将会引起问题。一个更通用的解决方案是创建第二个表，该表的 &lt;code&gt;name&lt;/code&gt; 为key， &lt;code&gt;idno&lt;/code&gt; 为数据，即对与 &lt;code&gt;name&lt;/code&gt; 字段有关的表进行索引（反转）。显然，第二张表必须与主表保持一致。Mnesia可以为您做到这一点，但是与使用Mnesia所涉及的开销相比，家庭酿造索引表可以非常有效。</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">一个简单的方法是发出以下命令。</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">一个简单的方法是发出这些命令。</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">输入中应包含单个 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">单个原子表示模块名称，并且等效于 &lt;code&gt;{module, ModuleName}&lt;/code&gt; 。通常在调用 &lt;code&gt;eunit:test(some_module)&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;driver_output_binary()&lt;/code&gt; 发送单个二进制文件。</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">随以下 &lt;code&gt;Request&lt;/code&gt; 一行（如前例所示）：</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">单个字符串表示文件或目录的路径，并分别等效于 &lt;code&gt;{file, Path}&lt;/code&gt; 或 &lt;code&gt;{dir, Path}&lt;/code&gt; ，具体取决于 &lt;code&gt;Path&lt;/code&gt; 在文件系统中所指的是什么。</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">包含在测试套件中的单个测试。测试用例是作为测试套件模块中的一个函数来实现的。</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">可以明确识别单个定义明确的测试。执行时，测试用例要么&lt;strong&gt;通过&lt;/strong&gt;要么&lt;strong&gt;失败&lt;/strong&gt;；测试报告应准确确定哪些测试用例失败。</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">当需要使用受支持但已禁用的算法时，添加一种算法可能会很有用。一个例子是 &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; ，如今它非常不安全，因此被禁用。但是，它仍然受支持并且可以使用。</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">骨架是一段可以插入缓冲区的预写代码。Erlang模式带有一组预定义的框架。可以从名为 &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; 的命令的Erlang菜单中访问骨架，因为骨架是使用标准Emacs软件包&amp;ldquo; tempo&amp;rdquo;定义的。以下是可用骨架的简要说明：</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">采用的程序简述;</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">说明倾倒原因的口号</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">可以实现一个回显N个字节的小型 &lt;code&gt;ssh&lt;/code&gt; 子系统，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">关于每个失败的测试案例的一个小说明。</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">存在少量的&quot;-&quot;标志,现在实际上是仿真器标志,请看下面的说明。</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">对返回的字符数的软限制。当达到字符数时，其余结构将替换为&amp;ldquo; &lt;code&gt;...&lt;/code&gt; &amp;rdquo;。 &lt;code&gt;CharsLimit&lt;/code&gt; 默认为-1，这意味着返回的字符数没有限制。</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">&lt;code&gt;{Node, Count}&lt;/code&gt; 元组的排序列表，以递增的 &lt;code&gt;Count&lt;/code&gt; 顺序排序。 &lt;code&gt;Count&lt;/code&gt; 是此碎片表在每个 &lt;code&gt;Node&lt;/code&gt; 上托管的副本总数。该列表始​​终至少包含 &lt;code&gt;node_pool&lt;/code&gt; 中的所有节点。不属于 &lt;code&gt;node_pool&lt;/code&gt; 的节点即使其 &lt;code&gt;Count&lt;/code&gt; 较低，也会放在列表的最后。</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">用空格分隔的字符串，指定要执行的程序。第二个字段通常是命令名称，例如 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1636d9fe46ac8e8fc16a7c4f98f7781df515d1ba" translate="yes" xml:space="preserve">
          <source>A spawn reply message will be sent to the caller regardless of whether the operation succeeds or not. If the call to &lt;code&gt;spawn_request()&lt;/code&gt; returns without raising an exception and the &lt;code&gt;reply&lt;/code&gt; option is set to &lt;code&gt;yes&lt;/code&gt;, the caller is guaranteed to be delivered either a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;#spawn_request_error_message&quot;&gt;&lt;i&gt;error message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;reply&lt;/code&gt; option is by default set to &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d70a605fe0829e66ec6bd35120d29d1093a9d34" translate="yes" xml:space="preserve">
          <source>A spawn request can be abandoned by calling &lt;code&gt;&lt;a href=&quot;#spawn_request_abandon-1&quot;&gt;spawn_request_abandon/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db8ca18baf39ee044af1edfffece3234114b4cf" translate="yes" xml:space="preserve">
          <source>A spawn request can only be successfully abandoned until the spawn request has completed. When a spawn request has been successfully abandoned, the caller will not be effected by future direct effects of the spawn request itself. For example, it will not receive a spawn reply message. The request is however not withdrawn, so a new process may or may not be created due to the request. If a new process is created after the spawn request was abandoned, no monitors nor links will be set up to the caller of &lt;code&gt;spawn_request_abandon/1&lt;/code&gt; due to the spawn request. If the spawn request included the &lt;code&gt;link&lt;/code&gt; option, the process created due to this request will be sent an exit signal from its parent with the exit reason &lt;code&gt;abandoned&lt;/code&gt; when it is detected that the spawn operation has succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">由（？后跟数字&amp;gt; 0和右括号组成的特殊项目是给定数字子模式的递归子例程调用，如果该子模式在该子模式内发生（如果不是，则为非递归子例程调用。 ，特殊项目（？R）或（？0）是整个正则表达式的递归调用。</target>
        </trans-unit>
        <trans-unit id="61cc845c2afb7bd85647ca3d1e06f065258da29c" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 调用的特殊例程。对于Erlang驱动程序，它的工作原理类似于&amp;ldquo; ioctl&amp;rdquo;。指定给 &lt;code&gt;port_control/3&lt;/code&gt; 的数据到达 &lt;code&gt;buf&lt;/code&gt; 和 &lt;code&gt;len&lt;/code&gt; 。驱动程序可以使用 &lt;code&gt;*rbuf&lt;/code&gt; 和 &lt;code&gt;rlen&lt;/code&gt; 将数据发送回去。</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">错误的一种特殊类型是找不到实际无效的整数或字节，但是尾随的 &lt;code&gt;binary()&lt;/code&gt; 包含的字节太少而无法解码最后一个字符。如果从文件中分块读取字节或以其他方式在非UTF字符边界上分割二进制文件，则可能发生此错误。一个 &lt;code&gt;incomplete&lt;/code&gt; 那么行会返回，而不是 &lt;code&gt;error&lt;/code&gt; 的元组。它由与 &lt;code&gt;error&lt;/code&gt; 元组相同的部分组成，但是标签是 &lt;code&gt;incomplete&lt;/code&gt; 而不是 &lt;code&gt;error&lt;/code&gt; ，并且最后一个元素始终保证是由（到目前为止）有效UTF字符的第一部分组成的二进制文件。</target>
        </trans-unit>
        <trans-unit id="3916fb4d3122880bb80b867dc9d2527f278db29f" translate="yes" xml:space="preserve">
          <source>A specific instruction can have at most 6 operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb0a5535ecc63bd01763b04dca57f5130132dad" translate="yes" xml:space="preserve">
          <source>A specific instruction is defined by first giving its name followed by the types for each operand. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">使用 &lt;code&gt;-spec&lt;/code&gt; 属性给出功能的规范（或合同）。通用格式如下：</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">状态更改会取消 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; ,并且此类型的任何新过渡选项都属于新状态。</target>
        </trans-unit>
        <trans-unit id="c48da406465f6ed9b4beb63690dac21a0092fc89" translate="yes" xml:space="preserve">
          <source>A stateful session ticket is a database reference to internal state information. A stateless session ticket is a self-encrypted binary that contains both cryptographic keying material and state data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">状态，&lt;strong&gt;处于活动状态&lt;/strong&gt;或非&lt;strong&gt;活动状态&lt;/strong&gt;。无效的断点将被忽略。</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">粘性锁是指在首次获取锁的事务终止后,仍然保持在一个节点上的锁。为了说明这一点,假设执行以下事务。</target>
        </trans-unit>
        <trans-unit id="167c0844b749b5b3dade41e2fb760895a3da7567" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt; erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">包含OTP发行版号的字符串（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">包含正则表达式的字符串</target>
        </trans-unit>
        <trans-unit id="6a30a94b91175e13eab64a9eaaf574ffd247249b" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt; erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">包含运行时系统版本号的字符串（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; 返回的版本号相同）。</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">一个字符串，其中包含特定操作系统上使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码的环境变量名称的有效字符。请注意，尤其不允许使用空字符（整数值零）和 &lt;code&gt;$=&lt;/code&gt; 字符。但是，请注意，并非所有无效字符都必定会导致primitiv操作失败，但可能会产生无效结果。</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">一个字符串，其中包含特定操作系统上使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码的环境变量值的有效字符。请注意，明确不允许使用空字符（整数值零）。但是，请注意，并非所有无效字符都必定会导致primitiv操作失败，但可能会产生无效结果。</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">通过下面的调用可以得到一个描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">一个标识创建线程的字符串。它用于在未来计划的调试功能中识别线程。</target>
        </trans-unit>
        <trans-unit id="759a963eafd4f199bcd9d735f8b965dcd00ef19c" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">此模块中的字符串由 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 表示，即代码点列表，带有UTF-8编码的代码点的&lt;strong&gt;二进制文件&lt;/strong&gt;（&lt;strong&gt;UTF-8二进制文件&lt;/strong&gt;）或二者的组合。</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">读取一串非空格字符。如果指定了字段宽度,则读取这个字符数,并删除所有尾部的空白字符。返回一个Erlang字符串(字符列表)。</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">表示原子 &lt;code&gt;t&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">通过下面的调用可以得到一个描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; 的字符串版本。评估查询句柄时，由 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 解释由解析转换创建的乐趣。查询字符串将是一个以句点结尾的单个QLC。</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">一个没有相邻点的字符串。</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">一个存根模块描述符包含模块名称、导出的函数列表和模块属性列表。每个函数由它的名称(包括它的arity),以及它所调用的相应模块和函数来描述。(属性应该总是匹配的。)属性只是用键值对来描述。</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">一个不包含|字符的子模式只是包围选项的一部分,它不是一个只有一个选项的嵌套交替。(*THEN)的效果超越了这样的子模式,延伸到了包围的备选方案。考虑下面的模式,其中A、B等是复杂的模式片段,在这个层次上不包含任何|字符。</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">用名字引用的子模式可以在引用之前或之后出现在模式中。</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">对子模式的子程序调用(递归或其他)。</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">类型的所有语义检查的子集都已实现。例如，严格地讲， &lt;code&gt;TimeTicks&lt;/code&gt; 可能不会被子类化，但是编译器允许这样做（标准MIB必须通过编译器）（仅与SMIv2不同）。</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">&lt;code&gt;utf&lt;/code&gt; 类型的段的成功匹配将导致范围为0..16＃D7FF或16＃E000..16＃10FFFF的整数。如果返回值超出这些范围，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">以千字为单位的有关使用多大堆栈的建议。值&amp;lt;0表示默认大小。</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">可以通过以下示例代码从 &lt;code&gt;ei_cnode&lt;/code&gt; 结构构造一个合适的 &lt;code&gt;erlang_pid&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c330db35fee146e2f49165430e3031752b587566" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be retrieved from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by calling &lt;code&gt;ei_self(cnode_pointer)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">所有运行测试案例的摘要。</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">按其 &lt;code&gt;Origin&lt;/code&gt; 和 &lt;code&gt;Type&lt;/code&gt; 分组的已分配块大小（包括其标题）的摘要。</target>
        </trans-unit>
        <trans-unit id="555b82edcc9a51ba9b0a8648b94fe2cee0f8eb4a" translate="yes" xml:space="preserve">
          <source>A super carrier is large memory area, allocated at VM start, which can be used during runtime to allocate normal carriers from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c019e1f1b48948e812995eacd1c55f50920bdf21" translate="yes" xml:space="preserve">
          <source>A super carrier needs to satisfy two slightly different kinds of allocation requests; multi block carriers (MBC) and single block carriers (SBC). They are both rather large blocks of continious memory, but MBCs and SBCs have different demands on alignment and size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">监理桥假设启动和停止子系统的功能位于一个回调模块中,导出一组预定义的功能。</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">主管可以在上图中使用 &lt;code&gt;strategy&lt;/code&gt; 密钥指定以下&lt;strong&gt;重启策略&lt;/strong&gt;之一：</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">监督者希望在导出预定义函数集的回调模块中指定要监督的子进程的定义。</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">一个SNMP代理的监督员处理</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">监督器负责启动、停止和监控它的子进程。监督者的基本思想是在必要时通过重新启动子进程来保持其活力。</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">当受监管儿童意外终止时,会发出一份监管人报告。监护人报告包含以下内容:</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">具有重启策略 &lt;code&gt;simple_one_for_one&lt;/code&gt; 的管理程序是简化的 &lt;code&gt;one_for_one&lt;/code&gt; 管理程序，其中所有子进程都是动态添加的同一进程的实例。</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">挂起请求被发送到被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程。除非被恢复之前被暂停，否则被 &lt;code&gt;Suspendee&lt;/code&gt; 最终将被暂停。不管 &lt;code&gt;Suspendee&lt;/code&gt; 是否已暂停， &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的调用方都会立即返回。无法从系统中的其他事件推论被 &lt;code&gt;Suspendee&lt;/code&gt; 挂起的时间点。仅保证被 &lt;code&gt;Suspendee&lt;/code&gt; &lt;strong&gt;最终会&lt;/strong&gt;暂停（除非它被恢复）。如果未传递任何 &lt;code&gt;asynchronous&lt;/code&gt; 选项，则将阻止 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的调用方，直到 &lt;code&gt;Suspendee&lt;/code&gt; 挂起为止。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">挂起请求被发送到被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程。处理了挂起请求后，会向此函数的调用方发送一条回复消息。回复的格式为 &lt;code&gt;{ReplyTag, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="aa31c4e6104829ed1e5940c6b760d5e5f8223aa4" translate="yes" xml:space="preserve">
          <source>A symbolic link in the path points above the root of the relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 函数将语法树转换为 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">系统I / O向量，由Unix 上的 &lt;code&gt;writev&lt;/code&gt; 和Win32 上的 &lt;code&gt;WSASend&lt;/code&gt; 使用。在 &lt;code&gt;ErlIOVec&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统I / O向量，由Unix 上的 &lt;code&gt;writev&lt;/code&gt; 和Win32 上的 &lt;code&gt;WSASend&lt;/code&gt; 使用。它在 &lt;code&gt;ErlNifIOVec&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">系统配置文件 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">系统配置源文件 &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="475c3957e8fbb0321adf13488719ce7f864fd2ec" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt; Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">已达到系统限制。有关系统限制的信息，请参见《 &lt;code&gt;Efficiency Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">字符 &quot;3 &quot;后面的标签</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">名为 &lt;code&gt;myTable&lt;/code&gt; 的表有五列。前两个是键（不可访问），该表有三行。该表的检测功能称为 &lt;code&gt;my_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个表标识符，由 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">一个表可能包含内部使用的列，但对管理者而言不可见。这些内部列必须是表中的最后一列。该 &lt;code&gt;set&lt;/code&gt; 操作不会有这种安排的工作，因为有列，代理不知道。通过在 &lt;code&gt;set&lt;/code&gt; 函数中为内部列添加值来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">一个表格对象</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 类型的表每个键具有零个或一个记录，而 &lt;code&gt;bag&lt;/code&gt; 类型的表每个键可以具有任意数量的记录。每个记录的键始终是记录的第一个属性。</target>
        </trans-unit>
        <trans-unit id="a88c8b440b3f81b0c6b1eb623a7b8614ba6ccb2c" translate="yes" xml:space="preserve">
          <source>A table traversal is &lt;strong&gt;safe&lt;/strong&gt; if either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be8a69bc11325d2a87005532e2b29bbd011c378" translate="yes" xml:space="preserve">
          <source>A tag that describes the (select) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">一个不需要在最后反转列表的尾递归函数比体递归函数快,完全不构造任何项的尾递归函数也是如此(例如,一个对列表中所有整数求和的函数)。</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">目标系统可能有多个发行版，但在系统启动时将使用默认的 &lt;code&gt;boot_rel&lt;/code&gt; 发行版。</target>
        </trans-unit>
        <trans-unit id="af9eae26f481905b914e12255a1f498f1501fe7a" translate="yes" xml:space="preserve">
          <source>A task that can be aborted is referred via another data structure from other parts of the system, so that a thread that needs to abort the task can reach it. In order to be sure to safely deallocate a task that is no longer used, we first clear this reference and then use the thread progress functionality in order to make sure no references can exist to the task. Unfortunately, also unmanaged threads might abort tasks. This is very infrequent, but might occur. This could be handled locally for each port, but would require extra information in each port structure which very infrequently would be used. Instead of implementing this in each port, we implemented general functionality that can be used from unmanaged threads to delay thread progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba0e9f6775914dcfade32d5d8265e1ed8ccd90d" translate="yes" xml:space="preserve">
          <source>A temporary process will be created for each callback call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">状态机实现用来存储所需的任何服务器数据的术语。此与 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 本身之间的区别在于，此数据的更改不会导致重试延迟的事件。因此，如果此数据中的更改将更改要处理的事件集，则该数据项将成为状态的一部分。</target>
        </trans-unit>
        <trans-unit id="3c82bdf9ca846d33c59020cff263330ebd6a6321" translate="yes" xml:space="preserve">
          <source>A term of type &lt;code&gt;&lt;a href=&quot;#type-iovec&quot;&gt;iovec()&lt;/a&gt;&lt;/code&gt;, structured according to the Erlang external term format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">一个术语,如果事件处理程序因为错误而被删除。哪个术语取决于错误。</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">一个测试用例可以并行处理到一个或多个目标系统，仪器和流量生成器的多个连接，以执行测试所需的动作。并行处理多个连接是 &lt;code&gt;Common Test&lt;/code&gt; 的主要优势之一，这要归功于Erlang运行时系统中对并发的有效支持， &lt;code&gt;Common Test&lt;/code&gt; 用户可以充分利用它。</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">测试用例失败被指定为运行时错误(崩溃),无论终止的原因是什么。如果你有效地使用Erlang模式匹配,你可以利用这个属性。其结果是简洁和可读的测试用例函数,看起来更像脚本而不是实际的程序。一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">一个测试用例组可以重复一定次数（由整数指定）或无限次（由 &lt;code&gt;forever&lt;/code&gt; 指定）。如果任何或所有情况失败或成功，也就是使用任何属性 &lt;code&gt;repeat_until_any_fail&lt;/code&gt; ， &lt;code&gt;repeat_until_any_ok&lt;/code&gt; ， &lt;code&gt;repeat_until_all_fail&lt;/code&gt; 或 &lt;code&gt;repeat_until_all_ok&lt;/code&gt; ，也可以过早停止重复。如果使用基本的 &lt;code&gt;repeat&lt;/code&gt; 属性，则测试用例的状态与重复操作无关。</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">测试用例组是一组共享配置功能和执行属性的测试用例。测试用例组由功能 &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 根据以下语法定义：</target>
        </trans-unit>
        <trans-unit id="6615fe68020574c9d51502afda77dbb501f32348" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">如果一个测试用例返回给调用者,无论返回值是什么,都被认为是成功的。但是,有几个返回值具有以下特殊意义:</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">测试是通过运行一个或多个测试套件来进行的。一个测试套件由测试用例、配置功能和信息功能组成。测试用例可以分成所谓的测试用例组。一个测试套件是一个Erlang模块,测试用例以Erlang函数的形式实现。测试套件存储在测试目录中。</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">通过将一系列测试对象放在列表中，可以轻松创建测试集。如果 &lt;code&gt;T_1&lt;/code&gt; ，...， &lt;code&gt;T_N&lt;/code&gt; 是单独的测试对象，则 &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; 是由这些对象组成（按该顺序）的测试集。</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">测试套件是包含测试用例的普通Erlang模块。建议模块使用 &lt;code&gt;*_SUITE.erl&lt;/code&gt; 形式的名称。否则， &lt;code&gt;Common Test&lt;/code&gt; 中的目录和自动编译功能将无法找到它（至少默认情况下不会）。</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">一个测试术语还可以指定一个或多个要跳过的测试套件，组或测试用例。跳过的套件，组和案例不会执行，并以 &lt;code&gt;SKIPPED&lt;/code&gt; 的形式显示在HTML日志文件中。</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">描述服务的文本注释。不是必须的,但会在Windows服务管理器中显示为服务描述。</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">在写这篇文章的时候,SystemTap最新发布的版本是1.6版本。Erlang的DTrace支持需要一个MACRO,而这个MACRO是在这个版本之后引入的,所以要么得到一个新的版本,要么自己从git上构建SystemTap(见:)。所以,要么得到一个更新的版本,要么自己从git中构建SystemTap(见:http://sourceware.org/systemtap/getinvolved.html)。</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">第三种选择是从以下地方下载并安装MSYS2:</target>
        </trans-unit>
        <trans-unit id="1d370bfacb3e303ae0b301510d2fd8f9fe73b2f2" translate="yes" xml:space="preserve">
          <source>A third feature is to have the super carrier limit the &lt;strong&gt;maximum&lt;/strong&gt; amount of memory used by the VM. If +MMsco (Super Carrier Only) is set to true, which is default, allocations will only be done from the super carrier. When the super carrier gets full, the VM will fail due to out of memory. If +MMsco is false, allocations will use mmap directly if the super carrier is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52be3095703dc09da3f8d9ef4629a28e6444954" translate="yes" xml:space="preserve">
          <source>A third problem was management of low memory in the halfword emulator. The implementation used a naive linear search structure to hold free segments which would lead to poor performance when fragmentation increased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">第三种用法是阻止来自行为不端的对等方的登录尝试。的 &lt;code&gt;State&lt;/code&gt; 可以将上述用于此目的。返回值 &lt;code&gt;disconnect&lt;/code&gt; 对此很有用。</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">一个线程只能连接一次。多次连接的行为是不确定的，有可能导致模拟器崩溃。如果 &lt;code&gt;exit_value == NULL&lt;/code&gt; ，则忽略终止线程的退出值，否则终止线程的退出值存储在 &lt;code&gt;*exit_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">线程终止后，可以非常快地重用线程标识符。因此，如果自保存线程标识符以来对应于所涉及线程标识符之一的线程已终止，则 &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; 的结果可能不会给出预期的结果。</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;now()&lt;/code&gt; 返回的时间戳。</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">时空扭曲是指时间的向前或向后跳跃。也就是说,时间扭曲前后的时间值之差与实际经过的时间不一致。</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">从 &lt;code&gt;gen_statem&lt;/code&gt; 的前身 &lt;code&gt;gen_fsm&lt;/code&gt; 继承的超时功能是事件超时，即，如果事件到达，计时器将被取消。您会得到一个事件或一个超时，但不会同时发生。</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">超时值为 &lt;code&gt;0&lt;/code&gt; （零）表示禁用了超时。因此，调用最后一个参数为 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;_tmo&lt;/code&gt; 函数与调用不带 &lt;code&gt;_tmo&lt;/code&gt; 后缀的函数是一样的事情。</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">超时（以秒为单位），表示 &lt;code&gt;memsup&lt;/code&gt; 进程应等待内存检查结果的时间。如果超时到期， &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; 通过 &lt;code&gt;error_logger&lt;/code&gt; 发出警告消息&amp;ldquo; OS_MON（memsup）超时&amp;rdquo;，并且任何未决的同步客户端调用都将返回虚拟值。通常，这种情况不应发生。但是，在Linux上有一些情况，当系统负载很重时，从中读取系统数据的伪文件暂时不可用。</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">始终可以通过调用 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 来删除计时器。</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">一个定时器参考。</target>
        </trans-unit>
        <trans-unit id="fb8ee6e4fe82a072a334ccee3c68e3012d95b6b8" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;&lt;a href=&quot;#timestamp-0&quot;&gt; logger:timestamp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; 产生的时间戳。</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">也可以在执行测试用例或配置功能期间动态设置或重置时间陷阱。这是通过调用 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 来完成的。此功能取消当前的时间陷阱并开始一个新的时间陷阱（直到超时或当前功能结束，该时间陷阱一直处于活动状态）。</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种将XSLT样式表应用于XML文档的工具。从 &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; 下载xsltproc 。</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">跟踪端口是指向动态链接的驱动程序的Erlang端口,它可以直接处理跟踪消息,而不需要在Erlang虚拟机中作为消息发送。</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">以这种方式启动的跟踪服务器将仅以格式化的方式在Erlang Shell中显示跟踪消息（即，使用io：format）。有关如何自定义跟踪消息处理程序的描述，请参见 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">一个跟踪标记包含一个标签和一组标志。标签和标志都是在上述两种选择中设置的。</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用将为每个跟踪事件生成严格的单调时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。时间戳将由 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 和单调递增的整数组成。时间戳与 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用将为每个跟踪事件生成严格的单调时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。时间戳将使用 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 。时间戳与 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），用于启用/禁用为每个跟踪事件生成的时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），用于启用/禁用对 &lt;code&gt;seq_trace:print/1&lt;/code&gt; 的显式调用的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f928f7c9e2d7e89a32e5aa2b16d563a9022c4418" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f03f78eba803fb7a7f1c41468a0fa1580e2a31" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on information sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用邮件接收时的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用对邮件发送的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb16a1ee7cb5dc148d050fd7c6dc758d85f029eb" translate="yes" xml:space="preserve">
          <source>A traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to create the generator's initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">一个事务系统可以同时执行两个或更多的进程来操作同一记录。程序员不需要检查更新是否同步;这是由事务处理程序监督的。所有通过事务系统访问数据库的程序都可以被编写成好像它们有对数据的唯一访问权一样。</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">传输既可以覆盖其服务的能力,也可以限制其支持的Diameter应用,所以 &quot;服务=Origin-Host识别的Diameter节点 &quot;不一定是这样。</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">传输过程可以从其父体那里得到以下类型的消息:</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">传输过程必须实现下文所述的消息接口。它应该保留其父体的pid,监控父体,并在父体死亡时终止。它不应该连接到父进程。如果它与对等体的传输连接丢失,它应该退出。</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">传输过程应向其父体发送下列类型的消息:</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">触发动作。到达断点时，触发动作指定该断点是继续为活动状态（&lt;strong&gt;enable&lt;/strong&gt;），还是变为不活动状态（&lt;strong&gt;disable&lt;/strong&gt;），或将其删除（&lt;strong&gt;delete&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">一个真正的嵌入式系统必须在系统启动时启动。本节介绍了实现这一目标所需的必要配置。</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">元组 &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; 。所述 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 指定哪些散列算法应被用于计算所述指纹在的呼叫中使用 &lt;code&gt;accept_callback()&lt;/code&gt; 。所述 &lt;code&gt;HashALgoSpec&lt;/code&gt; 或者是一个原子或原子作为第一个参数的列表 &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; 。如果是散列算法名称列表，该 &lt;code&gt;FingerPrint&lt;/code&gt; 在参数 &lt;code&gt;accept_callback()&lt;/code&gt; 将在相同的顺序，在对应的名字指纹列表 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">元组 &lt;code&gt;{Major,Minor}&lt;/code&gt; ,包含ETS表转储文件格式的主要版本和次要版本。此版本字段是从STDLIB 1.5.1开始添加的。使用旧版本转储的文件在此字段中返回 &lt;code&gt;{0,0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">函数调用的元组 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">使用元组 &lt;code&gt;{registered_name,node_name}&lt;/code&gt; 而不是仅使用 &lt;code&gt;registered_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; ，其中 &lt;code&gt;ModuleName&lt;/code&gt; 和 &lt;code&gt;FunctionName&lt;/code&gt; 是原子，引用函数 &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">元组是一种具有固定数量项的复合数据类型。</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">必须使用元素数指定一个元组。（这些元素在 &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; 术语之前。）</target>
        </trans-unit>
        <trans-unit id="694f68c6889d3f88be664ff0fedc1704129e38dd" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">返回大小等于 &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 的元组。元组元素是整数或原子 &lt;code&gt;unbound&lt;/code&gt; 。逻辑处理器标识符以整数表示。所述 &lt;code&gt;N&lt;/code&gt; 元组的第i个元素等于当前用于与标识符等于调度器调度器结合 &lt;code&gt;N&lt;/code&gt; 。例如，如果绑定了调度程序，则 &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; 返回在其上执行调用过程的逻辑处理器的标识符。</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">大小为三的元组，包含：段号， &lt;code&gt;last segment indicator&lt;/code&gt; 以及最后一个&amp;ldquo; ActionReply&amp;rdquo;记录列表，可能包含错误指示。当然，这仅在答复被分段的情况下才可能。</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则将返回绑定的元组和延续，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 匹配其他对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则将返回应用匹配规范和延续的结果的元组，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 匹配更多对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">使用Erlang的外部格式传递的元组。</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">一个元素为 &lt;code&gt;T&lt;/code&gt; 类型的元组。</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">一个包含字符串和编译选项的元组。</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">位串元素的类型说明符列表TSL是类型说明符 &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; ，并且Rep（TSL）= &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">典型的(压缩)用法如下。</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">典型的 &lt;code&gt;.erlang&lt;/code&gt; 文件包含一组搜索路径，例如：</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">使用 &lt;code&gt;ct_property_test&lt;/code&gt; 的典型 &lt;code&gt;Common Test&lt;/code&gt; 测试套件的组织方式如下：</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">一个典型的错误原因是:</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">一个典型的错误原因。</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">在Unix上，典型的实现是执行 &lt;code&gt;close((int)event)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">一个典型的操作可以包括以下步骤:</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">当应用程序在磁盘驻留表上执行的更新数量超过 &lt;code&gt;Mnesia&lt;/code&gt; 所能处理的数量时，就会发生典型的过载情况。忽略这种过载可能导致磁盘空间用尽的情况（无论存储在磁盘上的表的大小如何）。</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">一个典型的使用这个功能是替代无界尺寸控制序列等 &lt;code&gt;~w&lt;/code&gt; 和 &lt;code&gt;~p&lt;/code&gt; 与深度限定变体 &lt;code&gt;~W&lt;/code&gt; 和 &lt;code&gt;~P&lt;/code&gt; 格式化到文本中，例如，记录器之前。</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">过滤器的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">处理器实例的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">一个有用的调度函数,可以从客户端函数中使用。如果本地节点上存在一个进程,它就返回这样一个进程。否则,它会随机选择一个进程。</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">一个有用的数字。</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">查看列表部分的一个有用的方法是使用&quot;|&quot;。最好的解释是使用shell的一个例子。</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">一个用户定义的身份,代表这个通知发送操作。</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">有用户被阻止访问。</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">一个用户正在被从阻止列表中删除。</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">一个用户是由它的UserMid识别的,它必须是一个合法的Megaco MID。</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">一个用户可以根据Erlang/OTP的应用概念在.config文件中静态配置,也可以通过megaco:start_user/2的参数动态启动,这些配置设置可以在以后通过megaco:update_conn_info/2更新。</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">一个用户可以与其他用户建立若干 &quot;虚拟 &quot;连接。一个MG最多连接到一个MGC,而一个MGC可以连接到任何数量的MG。对于每个连接,用户选择一个传输服务、一个编码方案和一个用户回调模块。</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">用户进程可以订阅 &lt;code&gt;Mnesia&lt;/code&gt; 生成的事件。提供以下两个功能：</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">用户变量用于保存功能图的 &lt;code&gt;digraph&lt;/code&gt; 表示，以用于许多查询。原因是效率。与 &lt;code&gt;=&lt;/code&gt; 运算符相反， &lt;code&gt;:=&lt;/code&gt; 运算符会保存一个值以用于后续分析。在这里可能需要注意的是，查询中的相等子表达式仅被评估一次； &lt;code&gt;=&lt;/code&gt; 不能用于加快速度。</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">每个对象的用户定义的检测功能将被管理对象附加到实际资源。代理在 &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 操作上调用此函数。该函数可以读取一些硬件寄存器，执行计算或执行与概念变量关联的语义所需的任何操作。必须为标量变量和表编写这些函数。它们在关联文件（文本文件）中指定。在此文件中， &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 或每个托管对象的符号名称与Erlang元组 &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; ， &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从函数 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 传递的用户定义参数。它用于 &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">用户感知的字符,由一个或多个码点组成。</target>
        </trans-unit>
        <trans-unit id="b6da77940e722515281bb6aabce021b2bbcff9af" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt; cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt; ssl:tls_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">有效链必须至少具有ROOT和对等证书。根证书既可以作为 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 预先生成的证书，也可以作为根证书生成选项给出。由 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 生成的根证书。有关可用选项，请参见下面的 &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; 。这是 &lt;code&gt;ssl:ssl_option()&lt;/code&gt; 类型的子集。 &lt;code&gt;PrivateKey&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; 返回的内容。</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统具有SMP支持，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统支持脏调度程序线程，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统具有线程支持，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 字段中的值并不表示&lt;strong&gt;不&lt;/strong&gt;存在解码错误。该 &lt;code&gt;errors&lt;/code&gt; 领域也应进行检查。</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">必须为所有变量提供一个值,这些变量在MIB中缺乏默认值。</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">一个值的长度必须至少为1。</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">此类型的值被编码为 &lt;code&gt;open type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">除非先将变量删除，否则无法为其分配新值。由 &lt;code&gt;=&lt;/code&gt; 运算符分配的变量将在查询结束时删除，而由 &lt;code&gt;:=&lt;/code&gt; 运算符分配的变量只能通过调用 &lt;code&gt;forget&lt;/code&gt; 来删除。当需要再次设置模块数据时，没有用户变量。如果调用了需要再次设置模块数据的任何函数，则所有用户变量都将被忽略。</target>
        </trans-unit>
        <trans-unit id="cebe1918886957c15927cc44d43277357c762515" translate="yes" xml:space="preserve">
          <source>A variable definition binds a variable to a Perl variable. It is only meaningful to add a new definition if &lt;strong&gt;beam_makeops&lt;/strong&gt; is updated at the same time to use the variable. A variable definition looks this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">变量是一个表达式。如果一个变量与一个值绑定,那么返回值就是这个值。未绑定的变量只允许在模式中使用。</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">一个不在环境中的变量名会导致错误。</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">这种方法的一种变体是将 &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; 。然后使用例如元组 &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; 对状态进行建模。</target>
        </trans-unit>
        <trans-unit id="bde8699f3ff9312f778d465383636d7d89e8acf7" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;complex state&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20State%20Callback&quot;&gt;&lt;strong&gt;one state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">可以将Web服务器配置为在启动 &lt;code&gt;Inets&lt;/code&gt; 应用程序时启动，或者通过调用 &lt;code&gt;Inets&lt;/code&gt; 应用程序API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; 或 &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; 在运行时动态启动，请参见 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 。配置选项也称为属性，如下所示：</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">单词边界是主题字符串中当前字符和前一个字符都不都匹配\ w或\ W（即，一个匹配\ w而另一个匹配\ W）或该字符的开始或结尾的位置。如果第一个或最后一个字符分别与\ w匹配，则为字符串。在UTF模式下，可以通过设置选项 &lt;code&gt;ucp&lt;/code&gt; 来更改\ w和\ W的含义。完成此操作后，它还会影响\ b和\ B。 PCRE和Perl没有单独的&amp;ldquo;单词开头&amp;rdquo;或&amp;ldquo;单词结尾&amp;rdquo;元序列。但是，\ b后面的所有内容通常确定是哪个。例如，片段\ ba在单词的开头匹配&amp;ldquo; a&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">一个包盘日志文件由许多文件组成,称为索引文件。一个日志文件可以被打开和关闭。此外,还可以单独打开一个索引文件。如果打开了一个不存在的或非内部格式化的文件,将返回一个错误信息。如果文件损坏,不试图修复它,但会返回一条错误信息。</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">包装文件规范用于限制跟踪消耗的磁盘空间。跟踪被写入到数量有限的文件中，每个文件的大小均受限制。实际的文件名是 &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; ，其中 &lt;code&gt;SeqCnt&lt;/code&gt; 计为从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;WrapCnt&lt;/code&gt; 的十进制字符串，然后再从 &lt;code&gt;0&lt;/code&gt; 开始。当写入当前文件的跟踪项的长度大于 &lt;code&gt;WrapSize&lt;/code&gt; 时，将关闭该文件，如果此环绕跟踪中的文件数与 &lt;code&gt;WrapCnt&lt;/code&gt; 一样,则最早的文件将被删除，然后将打开一个新文件成为当前文件。因此，当包装跟踪停止时，最多有 &lt;code&gt;WrapCnt&lt;/code&gt; 跟踪文件的保存大小至少为 &lt;code&gt;WrapSize&lt;/code&gt; （但不大），但最后一个文件可能为空。默认值为 &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; 和 &lt;code&gt;WrapCnt = 8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 的包装函数，该函数创建具有适当 &lt;code&gt;attributes&lt;/code&gt; 集的表（如果不存在现有表）。属性和 &lt;code&gt;TabDef&lt;/code&gt; 被转发到 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; 。例如，如果表要作为 &lt;code&gt;disc_only_copies&lt;/code&gt; 驻留在所有节点上，则调用看起来如下：</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 的包装函数，该函数创建具有适当 &lt;code&gt;attributes&lt;/code&gt; 集的表（如果不存在现有表）。该表仅驻留在本地节点上，并且其存储类型与本地节点上的 &lt;code&gt;schema&lt;/code&gt; 表相同，即 &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; 或 &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fbfb3b2a70e7676f439e216ddfb41c8f42fcb5d" translate="yes" xml:space="preserve">
          <source>A write event was cancelled by &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and is guaranteed not to generate a &lt;code&gt;ready_output&lt;/code&gt; notification message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">对 &lt;code&gt;disc_copies&lt;/code&gt; 表副本的写操作分两个步骤执行。首先，将写操作附加到日志文件，然后在RAM中执行实际操作。</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">zlib流，请参阅 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">答：Cygwin，MSYS或MSYS2是环境，它与任何Unix计算机上的环境都非常相似。几乎就像您在Windows中拥有一台虚拟Unix计算机一样。在给定某些参数的情况下进行配置，然后创建环境环境的gnu-make用来构建系统的makefile。但是，大多数实际的编译器等不是Cygwin / MSYS / MSYS2工具，因此我们编写了几个包装器（Bourne-shell脚本），它们位于 &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; 。它们都进行参数转换和Unix环境中常见的开关，以适合本机Windows工具。当然，最引人注目的是路径，在Cygwin / MSYS / MSYS2中，路径是类似Unix的路径，带有&amp;ldquo;正斜杠&amp;rdquo;（/），并且没有驱动器号。 Cygwin特定命令 &lt;code&gt;cygpath&lt;/code&gt; 在Cygwin环境中用于大多数路径转换。 （在需要时）在相应的MSYS和MSYS2环境中使用其他工具。幸运的是，大多数编译器接受正斜杠而不是反斜杠作为路径分隔符，但是尽管如此，仍然必须正确设置驱动器号等。包装脚本不是通用的，例如cc.sh可以理解并翻译每个可能的gcc选项，并将正确的选项传递给cl.exe。原则是脚本足够强大，可以构建Erlang / OTP，仅此而已。他们可能需要扩展才能应对Erlang开发过程中的更改，这就是我们将它们变成shell脚本而不是Perl脚本的原因之一。我们相信他们更容易理解和改变。</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">答:对于Cygwin,MSYS和MSYS2一样,我们在构建时尽量使用最新的版本。你使用的版本并不重要。我们会尽量将我们在不同的Cygwin/MSYS/MSYS2版本中发现的错误的解决方法加入其中。请帮助我们添加与Cygwin/MSYS/MSYS2相关的新错误的解决方法,一旦你遇到这些错误。也请将错误报告提交给相应的Cygwin、MSYS和/或MSYS2开发者。我们在21中使用的GCC是4.8.1版本(MinGW 32bit)和4.8.5版本(MSYS2 64bit)。我们使用了VC++12.0(即Visual studio 2013)、Sun的JDK 1.6.0_45(32位)和Sun的JDK 1.7.0_1(64位)、NSIS 2.46和Win32 OpenSSL 1.0.2d。请阅读下一节,了解您所需要的详细内容。</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">答:不,永远不会。要保持项目文件的更新,并在VC++图形用户界面中完成OTP构建的所有步骤,这种麻烦根本不值得,甚至不可能。用于Erlang/OTP的VC++项目文件将永远不会发生。</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">答:不,不是,但认为这是一个正确的方向。</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">答：不，结果将是纯Windows二进制文件，据我所知，尚无法制作Cygwin二进制文件。当然，这是合乎需要的，但是动态链接（动态Erlang驱动程序加载）以及Cygwin中的TCP / IP仿真仍然存在一些问题，我敢肯定，这些问题会有所改善，但仍然存在一些问题。解决这些问题可能很容易，也可能很难。我建议您尝试一下，并分享您的经验。如果一个简单的 &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; 可以生成完整的Cygwin二进制文件，那么没有人会更高兴。</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">答:不,很遗憾不是。你仍然需要微软的Visual C++。一个Bourne-shell脚本(cc.sh)包装了Visual C++编译器,并在Cygwin环境中运行它。构建Erlang所需的所有其他工具都是免费/开源的,但不是C编译器。不过Windows SDK足以构建Erlang,你不需要购买Visual C++,只需要下载SDK(SDK版本8.1 ==Visual studio 2013)。</target>
        </trans-unit>
        <trans-unit id="85724e56e3dcb9f76cc960c4345313a7227e07b7" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the WSL environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">答:不,很遗憾我们没有时间帮助解决Cygwin/MSYS/MSYS2相关的用户问题,请阅读相关网站、新闻组和邮件列表。</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">答：好的，我承认，其中一个文件是使用Cygwin或MinGW的GCC编译的，然后使用小型C语言将生成的目标代码转换为兼容MS VC ++的coff。这是因为该特定文件 &lt;code&gt;beam_emu.c&lt;/code&gt; 能够使用GCC标签即值扩展而受益匪浅，该扩展将仿真器性能提高了50％。不幸的是，这确实（尚未）意味着所有OTP都可以使用GCC进行编译。该特定源代码不执行任何系统特定的操作，实际上是因为在Windows上使用GCC对其进行了编译。</target>
        </trans-unit>
        <trans-unit id="81af1c0ed56bada7f1365c496431c92fc23f483c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e36bf356b0e8d7e06efee09f6d96691782df63" translate="yes" xml:space="preserve">
          <source>A: WSL/Ubuntu is the environment, it's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, WSL tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/wsl_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in WSL are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The WSL specific command &lt;code&gt;wslpath&lt;/code&gt; is used for most of the path conversions in a WSL environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2634e5d15aa84185c8c93ac17bc4f970898371" translate="yes" xml:space="preserve">
          <source>A: We use WSL 1 with Ubuntu 18.04. The GCC we used for 23 was version 7.3-win32. We used Visual studio 2019, Sun's JDK 1.8.0_241, NSIS 3.05, Win32 OpenSSL 1.1.1d and wxWidgets-3.1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">答:嗯,不贵,是免费的(就像免费啤酒一样)。只要从微软下载并安装最新的Windows SDK,你需要的所有工具都在那里。附带的调试器(WinDbg)也很好用。我在将Erlang移植到64位Windows时就是用的这个。使用后来的微软编译器的另一个原因是DLL的兼容性。如果虚拟机是用旧的VC++版本编译的,那么使用新版本标准库的DLL可能无法加载。所以我们应该以使用最新的免费SDK和编译器为目标。</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">答:部分原因是它是一个很好的编译器--真的!事实上,在R11版本的后期,已经可以用mingw代替visual C++进行编译了(你可能会在一些脚本和目录中看到它的残余)。事实上,在R11版本的后期,已经可以使用mingw而不是visual C++进行编译了(你可能会在一些脚本和目录中看到残留的痕迹)。不幸的是,Windows的SMP版本的开发破坏了mingw构建,我们选择专注于VC++构建,因为VC++版本的性能更好。mingw构建可能会回来,但只要VC++能提供更好的性能,商业构建将是VC++的。</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">答:是的,我们使用完全相同的构建程序。</target>
        </trans-unit>
        <trans-unit id="c88a17178680779495642b56e9c7d27ea864c737" translate="yes" xml:space="preserve">
          <source>AH(NeedStack, NeedHeap, Live)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be36dfbb5116564a40ed7d5b4cbdf3999ccff9dc" translate="yes" xml:space="preserve">
          <source>API Description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">用于SSL/TLS CRL(证书撤销列表)缓存的API。</target>
        </trans-unit>
        <trans-unit id="01fc1fc29ee3bdfac97c802f999cf7358e251132" translate="yes" xml:space="preserve">
          <source>API for a TLS CRL (Certificate Revocation List) cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Erlang NIF库的API函数。</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Erlang驱动的API函数。</target>
        </trans-unit>
        <trans-unit id="e80b30d77b2cab01b81ccc87fb312659f6e0dd98" translate="yes" xml:space="preserve">
          <source>API functions in the module &lt;code&gt;httpd_conf&lt;/code&gt; was deprecated in favor of standard modules such as &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;filelib&lt;/code&gt;, and &lt;code&gt;erlang&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">用于编写定制化SSH客户端和服务器应用程序的API函数。</target>
        </trans-unit>
        <trans-unit id="de210df0a505b46fa42dc263d10d332cce666788" translate="yes" xml:space="preserve">
          <source>API kept from previous versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">Logger的API模块,这是Erlang/OTP中的标准日志设施。</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">公钥基础设施的API模块。</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM。ARMv5TE(即XScale)处理器应该可以使用。支持big-endian和little-endian模式。</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM:Linux</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">字符&lt;strong&gt; &lt;code&gt;char&lt;/code&gt; 的&lt;/strong&gt; ASCII值或Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">ASN.1 DER编码的实体为Erlang二进制。</target>
        </trans-unit>
        <trans-unit id="5fa4ef6c7f4c743ebd97fa57feafd946e53e8d8c" translate="yes" xml:space="preserve">
          <source>ASN.1 Specifications, Messages, and Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">ASN.1 编译器和编译时支持功能。</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1有原始类型和构造类型。</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1是一种描述分布式计算机系统之间交换的数据结构的正式语言。ASN.1的目的是拥有一种独立于平台和编程语言的符号,以使用一套标准化的规则来表达类型,将定义类型的值转换为字节流。然后,这个字节流可以在任何类型的通信通道上发送。这样,两个用不同编程语言编写的、在不同计算机上运行的、具有不同内部数据表示方式的应用程序就可以交换结构化数据类型的实例。</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1在SNMP中以两种不同的方式使用。SMI是基于ASN.1的,协议中的消息是使用ASN.1定义的。</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">ASN.1本身规定了无限大整数。4.3及以上版本的Erlang系统支持非常大的整数,实际上是无限大的整数。</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">现在接受ASN.1模块 &lt;code&gt;People&lt;/code&gt; ，并且抽象语法树保存在文件 &lt;code&gt;People.asn1db&lt;/code&gt; 中。使用Erlang编译器编译生成的Erlang代码，并将其加载到Erlang运行时系统中。现在在 &lt;code&gt;People&lt;/code&gt; 模块中有一个用于 &lt;code&gt;encode/2&lt;/code&gt; 和 &lt;code&gt;decode/2&lt;/code&gt; 的API ，其名称如下：</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1支持多种字符集。一之间的主要区别 &lt;code&gt;OCTET STRING&lt;/code&gt; 和字符串就是 &lt;code&gt;OCTET STRING&lt;/code&gt; 已没有征收上提供的字节语义。</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">公钥应用ASN.1规范中存在的ASN.1类型。</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1文件。它创建了一个 &lt;code&gt;.erl&lt;/code&gt; ， &lt;code&gt;.hrl&lt;/code&gt; 和 &lt;code&gt;.asn1db&lt;/code&gt; 从文件 &lt;code&gt;.asn1&lt;/code&gt; 文件。此外编译 &lt;code&gt;.erl&lt;/code&gt; 使用Erlang的编译器，除非选项 &lt;code&gt;+noobj&lt;/code&gt; 指定。</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP代码</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">AVP的考虑因素</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">AVP旗帜</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">AVP头</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">AVP发生表</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">AVP值</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">在能力交换期间,在发出的CER或CEA信息中发送的AVP值。可在服务和传输上配置,后者的值优先。具有以下类型之一:</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVP被独立于 &lt;code&gt;avps&lt;/code&gt; 解码为直径_包记录的avps字段中的直径 &lt;code&gt;decode_format&lt;/code&gt; 记录列表。</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">RFC中定义的AVPs是在直径提供的字典中定义的。它们在应用消息中的正确使用是用户的责任。</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">用于构建外发CER/CEA信息的AVP。值优先于有关服务的任何指定值。</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">Aa二进制数字列表（0或1）。接受此格式作为编码功能的输入，如果给出了&lt;strong&gt;legacy_bit_string&lt;/strong&gt;选项，&lt;strong&gt;则将&lt;/strong&gt; &lt;code&gt;BIT STRING&lt;/code&gt; 解码为该格式。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2fc2e3239e8ec3bf7008184c81466440651887a" translate="yes" xml:space="preserve">
          <source>Abandon a previously issued spawn request. &lt;code&gt;ReqId&lt;/code&gt; corresponds to a request identifier previously returned by &lt;code&gt;&lt;a href=&quot;#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; in a call from current process. That is, only the process that has made the request can abandon the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">放弃无载波最小限制。有效的 &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; 是表示块大小限制的正整数。载波中最大的空闲块必须至少为 &lt;code&gt;bytes&lt;/code&gt; 大，以便放弃该载波。默认值为零，但以后可以更改。</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">放弃运营商数量限制。有效的 &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; 是一个正整数，代表每个分配器实例的最大被放弃载波数。默认值为1000，实际上将禁用该限制，但是以后可以更改。</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">放弃运营商利用率限制。有效的 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; 是范围 &lt;code&gt;[0, 100]&lt;/code&gt; 0，100]中的整数，以百分比表示利用率。使用利用率值&amp;gt; 0时，允许分配器实例放弃多块载波。如果传递了 &lt;code&gt;de&lt;/code&gt; （默认启用）而不是 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; ，则使用建议的非零利用率值。选择的值取决于分配器类型，并且可以在ERTS版本之间进行更改。默认为 &lt;code&gt;de&lt;/code&gt; ，但是将来可以更改。</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">可以使用更多标志来启动Erlang仿真器（支持 &lt;code&gt;erl&lt;/code&gt; 支持的任何标志）。</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">异常终止由 &lt;code&gt;Assoc&lt;/code&gt; 指定的关联，而不刷新未发送的数据。插座本身保持打开状态。在此套接字上打开的其他关联仍然有效，并且可以在新的关联中使用该套接字。</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">中止会话</target>
        </trans-unit>
        <trans-unit id="19fdf66eca72538f9393a1351c5653c5dbe6dba0" translate="yes" xml:space="preserve">
          <source>Aborts the connection when it is closed. Discards any data still remaining in the send buffers and sends RST to the peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">在不刷新任何未发送数据的情况下中止当前关联。</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">终止当前正在执行的测试用例。用户必须确定知道当前正在执行的测试用例。因此该函数只有在被测试用例调用(或同步调用)的函数中调用才是安全的。</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">如果一个或多个套件编译失败,则中止测试运行(前面已经说明)。</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">绝对 &lt;code&gt;Time&lt;/code&gt; 值。该 &lt;code&gt;Time&lt;/code&gt; 值被解释为以毫秒为单位的绝对二郎单调的时间。</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">绝对最大高速缓存不合适（以千字节为单位）。如果内存段缓存中的某个段的大小超过了所请求的大小且超过了此参数的值，则该段不会被重用。默认为 &lt;code&gt;4096&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">绝对偏移。</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">绝对单块载波缩减阈值（以千字节为单位）。当缩小 &lt;code&gt;mseg_alloc&lt;/code&gt; 单个块载体中的某个块时，如果未使用的内存量小于此阈值，则该载体将保持不变，否则该载体将被缩小。另请参见 &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">绝对超时时间</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">用于SNMP索引的抽象数据类型</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">抽象的Erlang语法树。</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">FIFO队列的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Erlang编译器注释的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">一个Erlang子句的抽象形式。</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Erlang表达式的抽象形式。</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">一个Erlang形式的抽象形式。</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Erlang类型的抽象形式。</target>
        </trans-unit>
        <trans-unit id="5a9b296f4df7477eb5b5b50aeb9d835778376408" translate="yes" xml:space="preserve">
          <source>Abstract representation of a generator or a bitstring generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492e4e253beefd260963df05d99c417ca4290bfc" translate="yes" xml:space="preserve">
          <source>Abstract representation of a record field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00f2a5860c99ba7cb396e03f0dc272d78b0cc94" translate="yes" xml:space="preserve">
          <source>Abstract representation of a remote function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5c131fe9c0f70e4b39d2d2baddcf228a489a93" translate="yes" xml:space="preserve">
          <source>Abstract representation of an element of a bitstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c262fbcd830c7cce729c33d7fe8e67175762f3" translate="yes" xml:space="preserve">
          <source>Accept a connection on a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4a58616d72eca00517c5490fb42e2012ac253a" translate="yes" xml:space="preserve">
          <source>Accept connections on the listen socket identified by &lt;code&gt;*ctx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">接受连接。</target>
        </trans-unit>
        <trans-unit id="f62959ef635bf54ce8db016df3aaff0dd63a1788" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt; listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt; handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the TLS/DTLS connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">在侦听套接字上接受传入的连接请求。 &lt;code&gt;ListenSocket&lt;/code&gt; 必须是 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 返回的套接字。返回的套接字将传递给 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 以完成握手，即建立SSL / TLS / DTLS连接。</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">在侦听套接字上接受传入的连接请求。 &lt;code&gt;Socket&lt;/code&gt; 必须是从 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 返回的套接字。 &lt;code&gt;Timeout&lt;/code&gt; 以毫秒为单位指定超时值。默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">从由指定标识号标识的侦听套接字接受。使用 &lt;code&gt;uds_control&lt;/code&gt; 例程检索标识号。</target>
        </trans-unit>
        <trans-unit id="376e9046cc5fd2842ce29e30d9b75eab2742e487" translate="yes" xml:space="preserve">
          <source>Access Restrictions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">访问全球注册的名称。</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">必须设置访问权限,使池中所有节点都有相互访问的权限。</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">进入TCP/IP协议。</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">访问http://your.server.org/cgi-bin/17/foo 会导致服务器运行脚本/web/17/cgi-bin/foo。</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">访问http://your.server.org/cgi-bin/foo 会导致服务器运行脚本/web/cgi-bin/foo。</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">如果index.html不存在,访问http://your.server.org/docs/将返回http://your.server.org/docs/index.html或http://your.server.org/docs/welcome.html。</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">访问http://your.server.org/image/foo.gif,将参考文件/ftp/pub/image/foo.gif。</target>
        </trans-unit>
        <trans-unit id="427eed565a2163db52b5b617c51105003a80c4da" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">访问http://your.server.org/~bob/foo.gif将引用文件/home/bob/public/foo.gif。在类似Apache的配置文件中， &lt;code&gt;Re&lt;/code&gt; 与 &lt;code&gt;Replacement&lt;/code&gt; 用一个空格分开，并且由于不需要反斜杠转义，因此相同的示例将变为：</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod:all_keys(ActivityId,Opaque,Tab,LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:delete(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod:delete_object(ActivityId,Opaque,Tab,RecXS,LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:first(ActivityId,Opaque,Tab)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_match_object(ActivityId,Opaque,Tab,Pattern,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_read(ActivityId,Opaque,Tab,SecondaryKey,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:last(ActivityId,Opaque,Tab)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod:lock(ActivityId,Opaque,LockItem,LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod:match_object(ActivityId,Opaque,Tab,Pattern,LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:next(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:prev(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:read(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod:table_info(ActivityId,Opaque,Tab,InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod:write(ActivityId,Opaque,Tab,Rec,LockKind)</target>
        </trans-unit>
        <trans-unit id="21658514a1a49042d074927498970b49e42450f1" translate="yes" xml:space="preserve">
          <source>AccessMode :: write | read,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">从QLC列表理解访问 &lt;code&gt;Mnesia&lt;/code&gt; 表必须始终在事务内完成。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">如果数组没有固定的大小,那么访问超过最后一个设置的条目也会返回默认值。</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">访问未设置的条目会返回默认值。</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">根据良好做法,证书不应使用IP地址作为 &quot;服务器名称&quot;。如果这种情况发生在封闭的网络之外,那将是非常令人惊讶的。</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">根据神话，使用尾部递归函数以反向构建列表，然后调用 &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; 比以身体递归函数以正确顺序构建列表要快；原因是身体递归函数比尾递归函数使用更多的内存。</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">会计AVP表</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">会计助理检察官</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">会计应用推广及要求</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">会计命令代码</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">会计记录</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">会计会话状态机</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">核算是用户的责任:直径不实现这个状态机。</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">会计-实时-所需AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">会计-实时-要求的AVP值</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">会计-记录-编号AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">会计-记录-类型AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">会计-记录-类型AVP值</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">会计-子会议-ID AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">与会计有关的信息和AVPs在所提供的字典中定义。用户有责任正确使用它们。</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">Acct-Application-Id AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">会计临时间隔AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">帐户-多环节-ID AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">帐户-会话-ID AVP</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">这个锁的累计等待时间。这个时间可能大于实际的挂钟时间,它是所有线程的累积时间。Trylock冲突不累计时间。</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">累积多个测试的覆盖结果。请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 精度和精确度</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 准确性和精确度</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">确认端口的启动。</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">TLS握手成功的确认。 &lt;code&gt;Ref&lt;/code&gt; 是在 &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; 消息中收到的reference（），响应是对此发送回复。如果握手失败，则传输必须退出。</target>
        </trans-unit>
        <trans-unit id="f975f613537adf39477a68ad11e1dc4894dd6870" translate="yes" xml:space="preserve">
          <source>Action Mappings</source>
          <target state="translated">动作映射</target>
        </trans-unit>
        <trans-unit id="2440fec108b517d1d709ba90c75d4f7a63c7e81f" translate="yes" xml:space="preserve">
          <source>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...}</source>
          <target state="translated">ActionCall ::={ActionFunction}。| {ActionFunction,ActionTerm,...}。</target>
        </trans-unit>
        <trans-unit id="5590c86022b5bc14c1ea74cf910bca92aa274578" translate="yes" xml:space="preserve">
          <source>ActionFunction ::= &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</source>
          <target state="translated">ActionFunction :: = &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51c493fd8bfe5291ac344e060529e5b42558f385" translate="yes" xml:space="preserve">
          <source>ActionTerm ::= ConditionExpression | ActionCall</source>
          <target state="translated">ActionTerm ::=ConditionExpression | ActionCall</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="89ff6dbfdb936ca69e6587ae4d22e9a120904bf2" translate="yes" xml:space="preserve">
          <source>Actions :: [&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">动作:: [ &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="61334da16104ac9d91a8736e913a8cbee03e40e6" translate="yes" xml:space="preserve">
          <source>Actions are executed in the containing list order.</source>
          <target state="translated">行动按包含的列表顺序执行。</target>
        </trans-unit>
        <trans-unit id="4975204a056c5025b62a4a29c1e32e8f3dc531af" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition options &lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0f3b4c93f31bddb43b327dd452b51df2f0936" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;event_timeout()&lt;/code&gt; in the list.</source>
          <target state="translated">设置 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 动作将覆盖相同类型的所有先前选项，因此包含列表中的最后一个将获胜。例如，最后一个 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; 会覆盖列表中以前的所有 &lt;code&gt;event_timeout()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1964869d062538b54d1a15f6f4171d706fef3d8" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">设置 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 动作将覆盖相同类型的所有先前选项，因此包含列表中的最后一个将获胜。例如，最后一个 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 会覆盖列表中的所有先前的 &lt;code&gt;postpone()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13b1df2d40bde8a02c4921e1004b0065de68e10c" translate="yes" xml:space="preserve">
          <source>Activates a connection to a remote user. When this is done the connection can be used to send messages (with SendMod:send_message/2). The ControlPid is the identifier of a process that controls the connection. That process will be supervised and if it dies, this will be detected and the UserMod:handle_disconnect/2 callback function will be invoked. See the megaco_user module for more info about the callback arguments. The connection may also explicitly be deactivated by invoking megaco:disconnect/2.</source>
          <target state="translated">激活与远程用户的连接。当此操作完成后,该连接可以用来发送消息(使用SendMod:send_message/2)。ControlPid是控制连接的进程的标识符。这个进程将被监督,如果它死了,将被检测到并调用 UserMod:handle_disconnect/2 回调函数。关于回调参数的更多信息,请参见 megaco_user 模块。连接也可以通过调用megaco:disconnect/2显式地被停用。</target>
        </trans-unit>
        <trans-unit id="f69ba29b1f84217c9d2ca2dc152317da71e06308" translate="yes" xml:space="preserve">
          <source>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt;. The default value of the backup callback module &lt;code&gt;BackupMod&lt;/code&gt; is obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;.</source>
          <target state="translated">以最大程度的冗余度激活一个覆盖所有Mnesia表（包括架构）的新检查点，并使用 &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt; 执行备份。备份回调模块 &lt;code&gt;BackupMod&lt;/code&gt; 的默认值由 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="0574212bd6baf73e32ac9c415b72677146bade9b" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates on all &lt;code&gt;Mnesia&lt;/code&gt; tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">在调试级别激活所有事件。在此级别上， &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序开始订阅所有 &lt;code&gt;Mnesia&lt;/code&gt; 表上的更新。该级别仅用于调试小型玩具系统，因为会生成许多大型事件。</target>
        </trans-unit>
        <trans-unit id="1473502b15ef43d2fc312f7968ec2627f8afe701" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">激活调试层的所有事件,在这个层面,Mnesia事件处理程序开始订阅所有Mnesia表的更新。在这个级别,Mnesia事件处理程序开始订阅所有Mnesia表的更新。这个级别只用于调试小型玩具系统,因为会产生许多大型事件。</target>
        </trans-unit>
        <trans-unit id="a11fef95fdd152ac782e603cddf000bf9537358d" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus full trace of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">在详细级别激活所有事件以及所有调试事件的完整跟踪。这些调试事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到Mnesia事件处理程序。在此调试级别，Mnesia事件处理程序开始订阅模式表中的更新。</target>
        </trans-unit>
        <trans-unit id="d10f11346b4f9c94838ab97da164ecb5b326c009" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus traces of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler. On this debug level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">在详细级别激活所有事件以及所有调试事件的跟踪。这些调试事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序。在此调试级别， &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序开始订阅模式表中的更新。</target>
        </trans-unit>
        <trans-unit id="6ded0de3f180c32378392899db72b086ca5f1741" translate="yes" xml:space="preserve">
          <source>Activates read data buffering. If &lt;code&gt;read/2&lt;/code&gt; calls are for significantly less than &lt;code&gt;Size&lt;/code&gt; bytes, read operations to the operating system are still performed for blocks of &lt;code&gt;Size&lt;/code&gt; bytes. The extra data is buffered and returned in subsequent &lt;code&gt;read/2&lt;/code&gt; calls, giving a performance gain as the number of operating system calls is reduced.</source>
          <target state="translated">激活读取数据缓冲。如果 &lt;code&gt;read/2&lt;/code&gt; 调用的字节数明显少于 &lt;code&gt;Size&lt;/code&gt; 字节，则仍对 &lt;code&gt;Size&lt;/code&gt; 字节块执行对操作系统的读取操作。多余的数据被缓冲并在随后的 &lt;code&gt;read/2&lt;/code&gt; 调用中返回，随着操作系统调用数量的减少，性能得到提高。</target>
        </trans-unit>
        <trans-unit id="eb6a9b28d658257a2883ec371985ebb9360570ed" translate="yes" xml:space="preserve">
          <source>Activates the fragmentation properties of an existing table. &lt;code&gt;FragProps&lt;/code&gt; is either to contain &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; or be empty.</source>
          <target state="translated">激活现有表的碎片属性。 &lt;code&gt;FragProps&lt;/code&gt; 要么包含 &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; 要么为空。</target>
        </trans-unit>
        <trans-unit id="532f0aa046ec26e3e6682e682916731e989482e8" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler.</source>
          <target state="translated">激活重要调试事件的跟踪。这些事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到Mnesia事件处理程序。</target>
        </trans-unit>
        <trans-unit id="e0f95d91404d34111854383ce61fa17d9871d976" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler.</source>
          <target state="translated">激活重要调试事件的跟踪。这些事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 订阅这些事件。事件总是发送到 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序。</target>
        </trans-unit>
        <trans-unit id="7f2c331b898e66e4e4d774932df99c6432852c98" translate="yes" xml:space="preserve">
          <source>Activates/deactivates tracing by changing the current trace pattern.</source>
          <target state="translated">通过改变当前的跟踪模式来激活/停用跟踪。</target>
        </trans-unit>
        <trans-unit id="29f45195e4be19fb8b96702dcdd15944ea37fdad" translate="yes" xml:space="preserve">
          <source>Active breakpoints are displayed in red and inactive breakpoints in blue.</source>
          <target state="translated">活动的断点显示为红色,不活动的断点显示为蓝色。</target>
        </trans-unit>
        <trans-unit id="2ec1ddc09f5f20f205f66ac493ee50b1fd7b2567" translate="yes" xml:space="preserve">
          <source>Activity Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a903c4b66a2fb224f4d96a51df759ac9a67bfc6d" translate="yes" xml:space="preserve">
          <source>Activity concept and various access contexts</source>
          <target state="translated">活动概念和各种访问环境</target>
        </trans-unit>
        <trans-unit id="713a8072ef62aa0b1fde6095af47e4a910316756" translate="yes" xml:space="preserve">
          <source>Actual protocol version.</source>
          <target state="translated">当前的协议版本。</target>
        </trans-unit>
        <trans-unit id="c3e87cfb1bb3f9be88098c653af2df64757bc8b0" translate="yes" xml:space="preserve">
          <source>Actual ticket age shall be less than the ticket lifetime (stateless session tickets contain the servers timestamp when the ticket was issued).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91282b72e27e9203f0008e0bb427b78168c9ee89" translate="yes" xml:space="preserve">
          <source>Add 'makensis.exe' to your path environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134344cda8fb9734c656b66e40554d208ac6e58b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;-ct_hooks&lt;/code&gt; as an argument to &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;. To add multiple CTHs using this method, append them to each other using the keyword &lt;code&gt;and&lt;/code&gt;, that is, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;-ct_hooks&lt;/code&gt; 作为参数 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 。要添加使用该方法的多个CTHS，它们附加到彼此使用关键字 &lt;code&gt;and&lt;/code&gt; ，即， &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c736205df679d1eb6863a5f647010553ce017bf9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03f5ebcb056f1a256b52c0c938b58b71f342864" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Incr&lt;/code&gt; to counter at index &lt;code&gt;Ix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8718d4f36d948a3675c6bdc12db7b8c27966873" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;return_trace&lt;/code&gt; message if the function is of arity 3:</source>
          <target state="translated">如果该函数属于同类3，请添加 &lt;code&gt;return_trace&lt;/code&gt; 消息：</target>
        </trans-unit>
        <trans-unit id="dcfe51c34611d10c0d112932679c857d2a6476fa" translate="yes" xml:space="preserve">
          <source>Add a filter to the specified handler.</source>
          <target state="translated">为指定的处理程序添加一个过滤器。</target>
        </trans-unit>
        <trans-unit id="95b618e55bafddbb2a2984de23f6ce57bb36d2c0" translate="yes" xml:space="preserve">
          <source>Add a handler that prints &lt;code&gt;debug&lt;/code&gt; log events to a file, while the default handler prints only up to &lt;code&gt;notice&lt;/code&gt; level events to standard out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988a7e297bf981c7e71c06b09b7717bd00d611be" translate="yes" xml:space="preserve">
          <source>Add a handler with the given configuration.</source>
          <target state="translated">添加一个给定配置的处理程序。</target>
        </trans-unit>
        <trans-unit id="07e4c199b9f19567f7bbd64299d17b2cc8c094ac" translate="yes" xml:space="preserve">
          <source>Add a primary filter to Logger.</source>
          <target state="translated">为记录仪添加一个主过滤器。</target>
        </trans-unit>
        <trans-unit id="1970f7a8e650aa5473c699a8c07cc9a162ef1004" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the primary nameserver to use for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">添加要用于 &lt;code&gt;inet_res(3)&lt;/code&gt; 的主名称服务器的地址（如果不是默认端口，则为端口）。</target>
        </trans-unit>
        <trans-unit id="1cfc1bd9fd579f7622617b9af78a944445ba8847" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the secondary nameserver for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;inet_res(3)&lt;/code&gt; 添加辅助名称服务器的地址（如果不是默认端口，则为端口）。</target>
        </trans-unit>
        <trans-unit id="d8a12963c05fa3aec6cf7012ff1f7fc0a2d99e08" translate="yes" xml:space="preserve">
          <source>Add an entry. The entry must not exist.</source>
          <target state="translated">增加一个条目。该条目必须不存在。</target>
        </trans-unit>
        <trans-unit id="6652a41804b950794ec5752c7d6fd942b05025cf" translate="yes" xml:space="preserve">
          <source>Add file and line number to log entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e310729251dbd2e2aab36a457e446b150b20e5e" translate="yes" xml:space="preserve">
          <source>Add host entry to the hosts table.</source>
          <target state="translated">在主机表中添加主机条目。</target>
        </trans-unit>
        <trans-unit id="064eb4472489455e1a24510aa444bd6d5e585d65" translate="yes" xml:space="preserve">
          <source>Add javac &lt;strong&gt;LAST&lt;/strong&gt; to your path environment in bash, in my case this means:</source>
          <target state="translated">在bash中将javac &lt;strong&gt;LAST&lt;/strong&gt;添加到您的路径环境中，在我的情况下，这意味着：</target>
        </trans-unit>
        <trans-unit id="246e6fb32e5a050387dbde2f21177185267ea2d6" translate="yes" xml:space="preserve">
          <source>Add javac to your path environment, in my case this means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0bb0d661a36f1c95bc663da03400bb07c43351" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">添加或更新指定处理程序的配置数据。如果给定的 &lt;code&gt;Key&lt;/code&gt; 已经存在，则其关联的值将更改为 &lt;code&gt;Value&lt;/code&gt; 。如果不存在，它将被添加。</target>
        </trans-unit>
        <trans-unit id="7bc4a78cb8fcc809731f59f9c373269672f429fa" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e23ac8cf9bd396ad94605da91fe04cfdf9b6acd" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">添加或更新Logger的主要配置数据。如果给定的 &lt;code&gt;Key&lt;/code&gt; 已经存在，则其关联的值将更改为 &lt;code&gt;Value&lt;/code&gt; 。如果不存在，它将被添加。</target>
        </trans-unit>
        <trans-unit id="21e8ff5c385c237ae3065c84dd8d4d8e0844640c" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to the given value. If it does not exist, it will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f218791abec296d536eef9aee8fee9c4907e8" translate="yes" xml:space="preserve">
          <source>Add search domains for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;inet_res(3)&lt;/code&gt; 添加搜索域。</target>
        </trans-unit>
        <trans-unit id="1ed69d0e5ae060c18a4527cc0780a8f4a4070ca5" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt; Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1016b584a0c08284e356371e0b67d2c6544a4a" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将标签 &lt;code&gt;ct_hooks&lt;/code&gt; 添加到您的 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62bfcf8bed94dcc27f1ebd702bd7df63f5908679" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将标签 &lt;code&gt;ct_hooks&lt;/code&gt; 添加到对 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 的调用中。</target>
        </trans-unit>
        <trans-unit id="bb8bd196c7c5b5791600663f12d69529068e2cf5" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;{scanner, flex}&lt;/code&gt; (or similar) directive to an Erlang system config file for the megaco app (see &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; chapter for details).</source>
          <target state="translated">将 &lt;code&gt;{scanner, flex}&lt;/code&gt; （或类似）指令添加到megaco应用程序的Erlang系统配置文件中（有关详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; 章节）。</target>
        </trans-unit>
        <trans-unit id="a2012ba10173073b8d6e03fc90ee362531d7db30" translate="yes" xml:space="preserve">
          <source>Add the applications Crypto, Public Key, and SSL with their current version numbers after the STDLIB application.</source>
          <target state="translated">在STDLIB应用程序后添加应用程序Crypto、Public Key和SSL及其当前版本号。</target>
        </trans-unit>
        <trans-unit id="3f47e924c15f0cebe23f7a60a12208b6f3fe188b" translate="yes" xml:space="preserve">
          <source>Add the engine to OpenSSL's internal list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1eaff143827738e997da2b572220e89eec79fb" translate="yes" xml:space="preserve">
          <source>Add the filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf34fb9a5fda73afda9f1d571b702839ff2f58b3" translate="yes" xml:space="preserve">
          <source>Add the following directive to the module:</source>
          <target state="translated">在模块中添加以下指令:</target>
        </trans-unit>
        <trans-unit id="497564ebabd956c895ba8a4ea1a4bb25e8ed7093" translate="yes" xml:space="preserve">
          <source>Add transport capability to a service.</source>
          <target state="translated">为服务增加运输能力。</target>
        </trans-unit>
        <trans-unit id="ae43487688376dc95ae859ba01f32a0ade700fa9" translate="yes" xml:space="preserve">
          <source>Add-On Application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34d04c7e63a5b637ab5047d8987b49d86783a46" translate="yes" xml:space="preserve">
          <source>Added in OTP 23.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83212da8655f0855cd75f303dd85d4cf0dc4e2d" translate="yes" xml:space="preserve">
          <source>Adding Own Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a12811718bf0eb0d5f20cc44584c455597c9de0" translate="yes" xml:space="preserve">
          <source>Adding Patches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1377afcaa6077fc60c3ef67a50fc7f61a7ad112" translate="yes" xml:space="preserve">
          <source>Adding Records and Relationships to Database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ba7777616ece673914dfbc3af9096a68b87e29" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using &lt;code&gt;add_module&lt;/code&gt;.</source>
          <target state="translated">添加应用程序意味着使用 &lt;code&gt;add_module&lt;/code&gt; 加载 &lt;code&gt;.app&lt;/code&gt; 文件中由 &lt;code&gt;modules&lt;/code&gt; 键定义的模块。</target>
        </trans-unit>
        <trans-unit id="19baa62e86ec3c161512eb728cf268b6e381fb8a" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using a number of &lt;code&gt;add_module&lt;/code&gt; instructions, and then the application is started.</source>
          <target state="translated">添加应用程序意味着使用许多 &lt;code&gt;add_module&lt;/code&gt; 指令加载由 &lt;code&gt;.app&lt;/code&gt; 文件中的 &lt;code&gt;modules&lt;/code&gt; 键定义的模块，然后启动该应用程序。</target>
        </trans-unit>
        <trans-unit id="6dd28665b92c3d1eafe29d80d8f4b9041dfdeca0" translate="yes" xml:space="preserve">
          <source>Adding and Deleting Child Processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2fed64edcf79517387cddb884610573fd90ba1" translate="yes" xml:space="preserve">
          <source>Adding patches</source>
          <target state="translated">添加补丁</target>
        </trans-unit>
        <trans-unit id="9aa3df6db85161c52e69b8f34d6e3268949dc0a1" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;fop&lt;/code&gt; script (in &lt;code&gt;$FOP_HOME&lt;/code&gt;) to your &lt;code&gt;$PATH&lt;/code&gt;, either by adding &lt;code&gt;$FOP_HOME&lt;/code&gt; to &lt;code&gt;$PATH&lt;/code&gt;, or by copying the &lt;code&gt;fop&lt;/code&gt; script to a directory already in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;fop&lt;/code&gt; 脚本（在 &lt;code&gt;$FOP_HOME&lt;/code&gt; ）到您的 &lt;code&gt;$PATH&lt;/code&gt; ，通过添加 &lt;code&gt;$FOP_HOME&lt;/code&gt; 至 &lt;code&gt;$PATH&lt;/code&gt; ，或者通过复制 &lt;code&gt;fop&lt;/code&gt; 你已经脚本目录 &lt;code&gt;$PATH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38751bf8e4b616e26910db8b22c357a8c20a53f2" translate="yes" xml:space="preserve">
          <source>Adding the location of your installation of &lt;code&gt;fop&lt;/code&gt; in &lt;code&gt;$FOP_HOME&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;$FOP_HOME&lt;/code&gt; 添加安装 &lt;code&gt;fop&lt;/code&gt; 的位置。</target>
        </trans-unit>
        <trans-unit id="ab0b27d891b1318285ee4899ad6b140de6e4ed3b" translate="yes" xml:space="preserve">
          <source>Additional information and links of interest for Erlang programmers can be found on the Erlang Open Source site &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt;.</source>
          <target state="translated">Erlang程序员感兴趣的其他信息和链接可以在Erlang开源站点&lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org上找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afdeb8447e9059c599becedc9101b844f957850" translate="yes" xml:space="preserve">
          <source>Additionally, values that can be encoded are limited by way of their encoding as four octets as required by RFC 6733 with the required extension from RFC 2030. In particular, only values between &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; and &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (both inclusive) can be encoded.</source>
          <target state="translated">此外，可编码的值通过RFC 6733要求的四个八位字节进行编码，并具有RFC 2030要求的扩展名。特别是，只有 &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; 和 &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; （包括两者）可以进行编码。</target>
        </trans-unit>
        <trans-unit id="cb4f94d5cabe0fc39f4035959e69499b50e9e3b2" translate="yes" xml:space="preserve">
          <source>Address-to-name translation in a protocol-independant manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fda4b3ec4ffdc7738f6833bc3191a5b59bbcea" translate="yes" xml:space="preserve">
          <source>Addresses as inputs to functions can be either a string or a tuple. For example, the IP address 150.236.20.73 can be passed to &lt;code&gt;gethostbyaddr/1&lt;/code&gt;, either as string &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; or as tuple &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt;.</source>
          <target state="translated">作为函数输入的地址可以是字符串或元组。例如，可以将IP地址150.236.20.73 作为字符串 &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; 或作为元组 &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt; 150，236，20，73 }传递给 &lt;code&gt;gethostbyaddr/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ffba73db48bc15c7ed64cbfce1198067c6f6ff" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt; ip_address() &lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt; local_address(). &lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919ffc168cee16019d09aa5279148893d8d24a34" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">从套接字API函数返回的除 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 之外的地址。特别参见 &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; 该 &lt;code&gt;unspec&lt;/code&gt; 家庭对应AF_UNSPEC，如果对方没有套接字地址可能发生。在 &lt;code&gt;undefined&lt;/code&gt; 家庭只能发生在一个地址族的VM不承认万一。</target>
        </trans-unit>
        <trans-unit id="e5d78a2b44c9f8c46bb6a05a403783dea60e8b77" translate="yes" xml:space="preserve">
          <source>Addresses to the test plant or other instruments</source>
          <target state="translated">试验厂或其他仪器的地址</target>
        </trans-unit>
        <trans-unit id="e2dc16d39802f8e13757680f2285e270d512d4d0" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. If &lt;code&gt;Dir&lt;/code&gt; exists, it is removed from the old position in the code path.</source>
          <target state="translated">将 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径的开头。如果 &lt;code&gt;Dir&lt;/code&gt; 存在，则将其从代码路径中的旧位置删除。</target>
        </trans-unit>
        <trans-unit id="926f262a813d5bf3968371cfef08e827663b2a16" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the code path. The directory is added as the last directory in the new path. If &lt;code&gt;Dir&lt;/code&gt; already exists in the path, it is not added.</source>
          <target state="translated">将 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径。该目录被添加为新路径中的最后一个目录。如果路径中已经存在 &lt;code&gt;Dir&lt;/code&gt; ，则不会添加。</target>
        </trans-unit>
        <trans-unit id="ca41b9b5a14be7cc19bac8bafe3b381efcc40caa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the list of directories to be searched when including a file. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">包含文件时，将 &lt;code&gt;Dir&lt;/code&gt; 添加到要搜索的目录列表中。当遇到 &lt;code&gt;-include&lt;/code&gt; 或 &lt;code&gt;-include_lib&lt;/code&gt; 指令时，编译器会在以下目录中搜索头文件：</target>
        </trans-unit>
        <trans-unit id="5307e57c8c5d61db386c45a450b3023f9b59e82e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;IncludeDir&lt;/code&gt; to the search-path for &lt;code&gt;.asn1db&lt;/code&gt; and &lt;code&gt;ASN.1&lt;/code&gt; source files. The compiler tries to open an &lt;code&gt;.asn1db&lt;/code&gt; file when a module imports definitions from another &lt;code&gt;ASN.1&lt;/code&gt; module. If no &lt;code&gt;.asn1db&lt;/code&gt; file is found, the &lt;code&gt;ASN.1&lt;/code&gt; source file is parsed. Several &lt;code&gt;{i, IncludeDir}&lt;/code&gt; can be given.</source>
          <target state="translated">将 &lt;code&gt;IncludeDir&lt;/code&gt; 添加到 &lt;code&gt;.asn1db&lt;/code&gt; 和 &lt;code&gt;ASN.1&lt;/code&gt; 源文件的搜索路径。当模块从另一个 &lt;code&gt;ASN.1&lt;/code&gt; 模块导入定义时，编译器将尝试打开 &lt;code&gt;.asn1db&lt;/code&gt; 文件。如果未找到 &lt;code&gt;.asn1db&lt;/code&gt; 文件，则将分析 &lt;code&gt;ASN.1&lt;/code&gt; 源文件。可以给出几个 &lt;code&gt;{i, IncludeDir}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="595c4b05c70f5ee3afd4c0ee71bd2a9507a8d8e9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and store this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">将&amp;ldquo; &lt;code&gt;Increment&lt;/code&gt; 添加到与&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 关联的值并存储该值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则 &lt;code&gt;Increment&lt;/code&gt; 存储为第一个值。</target>
        </trans-unit>
        <trans-unit id="9cf5a5933a7780d09616786318d8b162063b8502" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and stores this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">将&amp;ldquo; &lt;code&gt;Increment&lt;/code&gt; 添加到与&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 关联的值并存储该值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则 &lt;code&gt;Increment&lt;/code&gt; 存储为第一个值。</target>
        </trans-unit>
        <trans-unit id="608d4ac3b1f40dea43a70f3ee04cd69ef181057c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;Slave&lt;/code&gt; node to the list of allowed slave hosts.</source>
          <target state="translated">将一个 &lt;code&gt;Slave&lt;/code&gt; 节点添加到允许的从主机列表中。</target>
        </trans-unit>
        <trans-unit id="c8419b1c93b9fd6c91cbede4425bbc8634cca3f1" translate="yes" xml:space="preserve">
          <source>Adds a USM security data (user) to the agent config. Equivalent to one line in the &lt;code&gt;usm.conf&lt;/code&gt; file.</source>
          <target state="translated">将USM安全数据（用户）添加到代理配置。相当于 &lt;code&gt;usm.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="608718b6fe3ec7101404f6c3f283054c442dd2b4" translate="yes" xml:space="preserve">
          <source>Adds a access definition to the agent config. Equivalent to one vacmAccess-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将访问定义添加到代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmAccess行。</target>
        </trans-unit>
        <trans-unit id="56be82c63eeffefdb9fecc96c8582dde485169c1" translate="yes" xml:space="preserve">
          <source>Adds a comment to the zip archive.</source>
          <target state="translated">在压缩包中添加注释。</target>
        </trans-unit>
        <trans-unit id="43e098c039b116cd95896a1756a343c44df7c071" translate="yes" xml:space="preserve">
          <source>Adds a community to the agent config. Equivalent to one line in the &lt;code&gt;community.conf&lt;/code&gt; file.</source>
          <target state="translated">将社区添加到代理配置。等效于 &lt;code&gt;community.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="45955c71ab38b246ddf99aa7e08be1cf306c82b3" translate="yes" xml:space="preserve">
          <source>Adds a context to the agent config. Equivalent to one line in the &lt;code&gt;context.conf&lt;/code&gt; file.</source>
          <target state="translated">将上下文添加到代理配置。等效于 &lt;code&gt;context.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="6c32cf7ccbd49be4e1811292b2c307f4eba42f61" translate="yes" xml:space="preserve">
          <source>Adds a driver entry to the list of drivers known by Erlang. The &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; function of parameter &lt;code&gt;de&lt;/code&gt; is called.</source>
          <target state="translated">将驱动程序条目添加到Erlang已知的驱动程序列表中。调用参数 &lt;code&gt;de&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="d07970fe182b9d81897e40e78d3b14e7a4e7a0d7" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将文件添加到已由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 打开以进行写入的tar文件中。</target>
        </trans-unit>
        <trans-unit id="b2fca474d01b00ce9ba861cfe769df64577ac35b" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;. This function accepts the same options as &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将文件添加到已由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 打开以进行写入的tar文件中。此函数接受与 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt; 相同的选项。</target>
        </trans-unit>
        <trans-unit id="5eccbecba42ae4288806c579ad8b8fbf3b51a728" translate="yes" xml:space="preserve">
          <source>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</source>
          <target state="translated">将一个片段添加到一个片段表中。其中一个旧片段中的所有记录都被重述,其中约一半记录被移到新的(最后)片段中。所有在外键中引用这个表的其他碎片表,都会自动得到一个新的碎片。此外,它们的记录也会以与主表相同的方式进行动态重洗。</target>
        </trans-unit>
        <trans-unit id="d84d2fb93ae834309e6167a0b3e43d9fab2545e1" translate="yes" xml:space="preserve">
          <source>Adds a host key to the set of trusted host keys.</source>
          <target state="translated">将一个主机密钥添加到受信任的主机密钥集合中。</target>
        </trans-unit>
        <trans-unit id="2d77c18b4124fe87017036ce4362ca94cf644272" translate="yes" xml:space="preserve">
          <source>Adds a module and its &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The module will not be member of any application. Returns the name of the module.</source>
          <target state="translated">将模块及其 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 添加到外部 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。该模块将不是任何应用程序的成员。返回模块的名称。</target>
        </trans-unit>
        <trans-unit id="32c8a7869e19433d754f5fcd1913f72de6ee2803" translate="yes" xml:space="preserve">
          <source>Adds a new &lt;code&gt;Key&lt;/code&gt; to the process dictionary, associated with the value &lt;code&gt;Val&lt;/code&gt;, and returns &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;Key&lt;/code&gt; exists, the old value is deleted and replaced by &lt;code&gt;Val&lt;/code&gt;, and the function returns the old value. Example:</source>
          <target state="translated">向流程字典添加一个与值 &lt;code&gt;Val&lt;/code&gt; 关联的新 &lt;code&gt;Key&lt;/code&gt; ，并返回 &lt;code&gt;undefined&lt;/code&gt; 。如果 &lt;code&gt;Key&lt;/code&gt; 存在，则将旧值删除并替换为 &lt;code&gt;Val&lt;/code&gt; ，并且该函数将返回旧值。例：</target>
        </trans-unit>
        <trans-unit id="72a77907fe15211efb4ac1705211f4a6082a3750" translate="yes" xml:space="preserve">
          <source>Adds a new event handler in the same way as &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;, but also supervises the connection between the event handler and the calling process.</source>
          <target state="translated">以与 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 相同的方式添加新的事件处理程序，但还监督事件处理程序和调用进程之间的连接。</target>
        </trans-unit>
        <trans-unit id="e9446fd51850eeb6666eac3dc67fdb3d82b72082" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to event manager &lt;code&gt;EventMgrRef&lt;/code&gt;. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initiate the event handler and its internal state.</source>
          <target state="translated">向事件管理器 &lt;code&gt;EventMgrRef&lt;/code&gt; 添加新的事件处理程序。事件管理器调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 来初始化事件处理程序及其内部状态。</target>
        </trans-unit>
        <trans-unit id="be923232cecb872d45d1007a0378c8bbbe25c6cc" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to the error logger. The event handler must be implemented as a &lt;code&gt;gen_event&lt;/code&gt; callback module, see &lt;code&gt;gen_event(3)&lt;/code&gt;.</source>
          <target state="translated">将新的事件处理程序添加到错误记录器。事件处理程序必须实现为 &lt;code&gt;gen_event&lt;/code&gt; 回调模块，请参见 &lt;code&gt;gen_event(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346f98f933f954790f0ea34b8324039679ac74dd" translate="yes" xml:space="preserve">
          <source>Adds a node to &lt;code&gt;node_pool&lt;/code&gt;. The new node pool affects the list returned from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将一个节点添加到 &lt;code&gt;node_pool&lt;/code&gt; 。新的节点池会影响从函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 返回的列表。</target>
        </trans-unit>
        <trans-unit id="35b3eb9263608d380a272fe1f7c6c1eafd65bf84" translate="yes" xml:space="preserve">
          <source>Adds a notify definition to the agent config. Equivalent to one line in the &lt;code&gt;notify.conf&lt;/code&gt; file.</source>
          <target state="translated">将通知定义添加到代理配置。相当于 &lt;code&gt;notify.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="13890bf5b34b3baf9845e8775db87c295022c6ec" translate="yes" xml:space="preserve">
          <source>Adds a phony target for each dependency.</source>
          <target state="translated">为每个依赖关系添加一个假造的目标。</target>
        </trans-unit>
        <trans-unit id="07656b9ba19395d09fa6add9f69eacc86c1efcdf" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt; enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b1ac0ca171003684f30d397e314620318042ec" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">添加对从 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 获得的资源对象 &lt;code&gt;obj&lt;/code&gt; 的引用。在 &lt;code&gt;enif_keep_resource&lt;/code&gt; 对象之前，必须先通过调用 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 来平衡对对象的每次enif_keep_resource调用。</target>
        </trans-unit>
        <trans-unit id="ac2aa5a6a26bf2accad0209a44849095d34310fd" translate="yes" xml:space="preserve">
          <source>Adds a release, the applications of the release, the modules of the applications, and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The applications will be members of the release, and the modules will be members of the applications. The default is to use the base name of the directory as release name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the release.</source>
          <target state="translated">将版本，版本的应用程序，应用程序的模块以及 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。这些应用程序将是发行版的成员，而模块将成为应用程序的成员。缺省值是使用目录的基本名称作为发行版名称，但是可以用 &lt;code&gt;name&lt;/code&gt; 选项覆盖。返回发布的名称。</target>
        </trans-unit>
        <trans-unit id="5963e0eadddadc6570ac86b11276f6f4e83b3156" translate="yes" xml:space="preserve">
          <source>Adds a security to group definition to the agent config. Equivalent to one vacmSecurityToGroup-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将安全性添加到组定义中的代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmSecurityToGroup-line 。</target>
        </trans-unit>
        <trans-unit id="d4f785833568b0e86ada1e532e1405f500e20a42" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; for a more complete description.</source>
          <target state="translated">在每个分配的块中添加一个小标签，其中包含有关其内容和分配人的基本信息。请参阅 &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; 以获取更完整的描述。</target>
        </trans-unit>
        <trans-unit id="0dfd9dbecdeed6491e670fb60727a24505e80431" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the &lt;code&gt;instrument&lt;/code&gt; module to inspect this information.</source>
          <target state="translated">在每个分配的块中添加一个小标签，其中包含有关其内容和分配人的基本信息。使用 &lt;code&gt;instrument&lt;/code&gt; 模块检查此信息。</target>
        </trans-unit>
        <trans-unit id="e4864b206394f8b2d7b76e4230a5c12a58cc9d0e" translate="yes" xml:space="preserve">
          <source>Adds a target address definition to the agent config. Equivalent to one line in the &lt;code&gt;target_addr.conf&lt;/code&gt; file.</source>
          <target state="translated">将目标地址定义添加到代理配置。等效于 &lt;code&gt;target_addr.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="82b2d6b8384860d53fc589e045f4515d51086799" translate="yes" xml:space="preserve">
          <source>Adds a target parameter definition to the agent config. Equivalent to one line in the &lt;code&gt;target_params.conf&lt;/code&gt; file.</source>
          <target state="translated">将目标参数定义添加到代理配置。等效于 &lt;code&gt;target_params.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="5794b16429f3c188c00edeb3043c4596518ea624" translate="yes" xml:space="preserve">
          <source>Adds a view tree family definition to the agent config. Equivalent to one vacmViewTreeFamily-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将视图树系列定义添加到代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmViewTreeFamily行。</target>
        </trans-unit>
        <trans-unit id="10d0b1e780ad0788836f31276e65ce6efb15e764" translate="yes" xml:space="preserve">
          <source>Adds an application, the modules of the application and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The modules will be members of the application. The default is to use the base name of the directory with the version removed as application name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the application.</source>
          <target state="translated">将应用程序，应用程序的模块和 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。这些模块将成为该应用程序的成员。缺省设置是使用目录的基本名称，而将版本删除为应用程序名称，但是 &lt;code&gt;name&lt;/code&gt; 选项可以覆盖该名称。返回应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="110ffd01521ffa85d725f633c684562720f4ba39" translate="yes" xml:space="preserve">
          <source>Adds binding &lt;code&gt;Name=Value&lt;/code&gt; to &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">将Binding &lt;code&gt;Name=Value&lt;/code&gt; 添加到 &lt;code&gt;BindingStruct&lt;/code&gt; 。返回更新的绑定结构。</target>
        </trans-unit>
        <trans-unit id="166b6b5a44b378b7ef528300e6dd1ab66edcbe83" translate="yes" xml:space="preserve">
          <source>Adds nodes to current cover test. Notice that this only works if cover support is active.</source>
          <target state="translated">将节点添加到当前的覆盖测试中。请注意,只有在盖板支持激活的情况下,此功能才会生效。</target>
        </trans-unit>
        <trans-unit id="ebbd57f6aab385f9f5cefe84013bbde0f94bd2a8" translate="yes" xml:space="preserve">
          <source>Adds optional capabilities and sends a &lt;code&gt;hello&lt;/code&gt; message to the server and waits for the return.</source>
          <target state="translated">添加可选功能，并向服务器发送 &lt;code&gt;hello&lt;/code&gt; 消息，并等待返回。</target>
        </trans-unit>
        <trans-unit id="f4e867c0e696fbab1087c9d79da2f2d90aa8bb6f" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. &lt;code&gt;Bindings&lt;/code&gt; specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</source>
          <target state="translated">在语法树中的节点上添加或更新注释。 &lt;code&gt;Bindings&lt;/code&gt; 指定顶级节点环境中的一组绑定变量。以下注释会受到影响：</target>
        </trans-unit>
        <trans-unit id="b3ac712b8a650dd6e42451afed1ca538238431c7" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. Equivalent to &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; where the top-level environment &lt;code&gt;Bindings&lt;/code&gt; is taken from the annotation &lt;code&gt;{env, Bindings}&lt;/code&gt; on the root node of &lt;code&gt;Tree&lt;/code&gt;. An exception is thrown if no such annotation should exist.</source>
          <target state="translated">在语法树中的节点上添加或更新注释。等效于 &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; ，其中顶级环境 &lt;code&gt;Bindings&lt;/code&gt; 来自 &lt;code&gt;Tree&lt;/code&gt; 根节点上的注释 &lt;code&gt;{env, Bindings}&lt;/code&gt; 。如果不存在这样的注释，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="7bbf9ca1c736db15763a8239f95f4d5c1b66558d" translate="yes" xml:space="preserve">
          <source>Adds the directories in &lt;code&gt;Dirs&lt;/code&gt; to the end of the code path. If a &lt;code&gt;Dir&lt;/code&gt; exists, it is not added.</source>
          <target state="translated">将 &lt;code&gt;Dirs&lt;/code&gt; 中的目录添加到代码路径的末尾。如果 &lt;code&gt;Dir&lt;/code&gt; 存在，则不添加。</target>
        </trans-unit>
        <trans-unit id="c8d419cc2314f6341b04eb8bad24bf2f277d7f87" translate="yes" xml:space="preserve">
          <source>Adds the modules found in the given directory and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The default is not to examine subdirectories, but if the option &lt;code&gt;recurse&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, modules are searched for in subdirectories on all levels as well as in the given directory. Returns a sorted list of the names of the added modules.</source>
          <target state="translated">将在给定目录中找到的模块和 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。缺省情况是不检查子目录，但是如果 &lt;code&gt;recurse&lt;/code&gt; 选项的值为 &lt;code&gt;true&lt;/code&gt; ，则在所有级别以及给定目录的子目录中搜索模块。返回添加模块名称的排序列表。</target>
        </trans-unit>
        <trans-unit id="34d712dcc34471fdb6acaa22554dc0975d1f5dc6" translate="yes" xml:space="preserve">
          <source>Adds the registered name of the process. This can be useful when tracing on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">添加进程的注册名称。当在许多节点上进行跟踪时,这很有用,因为使用该名称的进程将在所有被跟踪的节点上进行跟踪。</target>
        </trans-unit>
        <trans-unit id="6bbf14dbe70908fe6ce0549e066a68aa359629b3" translate="yes" xml:space="preserve">
          <source>Adds the selected process and all processes below, right of it, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">将选定的进程及其下面的所有进程添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡中。</target>
        </trans-unit>
        <trans-unit id="3fcbc67018c8db0d7d54f40db7c26439211fb94f" translate="yes" xml:space="preserve">
          <source>Adds the selected process identifier to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the process resides on.</source>
          <target state="translated">将选定的进程标识符添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡以及该进程所在的节点。</target>
        </trans-unit>
        <trans-unit id="31b3e1e7afc7441a8de7e4b30d8d409a2bd10a0f" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt; code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aebb82fdca9aa95c0538fef0af13a3b616d5fe2" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt;code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">将指定目录添加到代码路径的开头，类似于 &lt;code&gt;code:add_pathsa/1&lt;/code&gt; 。请注意，给定目录的顺序将在结果路径中颠倒。</target>
        </trans-unit>
        <trans-unit id="0a1c883186e0d00a77adaf41f013ddc82c811398" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the end of the code path, similar to &lt;code&gt;code:add_pathsz/1&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">将指定的目录添加到代码路径的末尾，类似于 &lt;code&gt;code:add_pathsz/1&lt;/code&gt; ; 参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d2e0e96fcba01247b2f834ed2a0365db181f6d4" translate="yes" xml:space="preserve">
          <source>Adds the specified primary filters.</source>
          <target state="translated">添加指定的主过滤器。</target>
        </trans-unit>
        <trans-unit id="d613e82163d56d8326249e8169f52e84f75a04cb" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of compress extensions.</source>
          <target state="translated">将这些扩展添加到压缩扩展列表中。</target>
        </trans-unit>
        <trans-unit id="25822e567273ecdc04d1dd713da5a9ee0671d675" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of uncompress extensions.</source>
          <target state="translated">将这些扩展添加到解压扩展列表中。</target>
        </trans-unit>
        <trans-unit id="2f502d97e1ab810c3754afd45a8594c92efa30f8" translate="yes" xml:space="preserve">
          <source>Adds to &lt;code&gt;Forms&lt;/code&gt; the code for the standard pre-defined functions (such as &lt;code&gt;module_info/0&lt;/code&gt;) that are to be included in every module.</source>
          <target state="translated">将要包含在每个模块中的标准预定义功能（例如 &lt;code&gt;module_info/0&lt;/code&gt; ）的代码添加到 &lt;code&gt;Forms&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="bb8f1512f2d702beeef48e8c7223a0b1dde1e4a0" translate="yes" xml:space="preserve">
          <source>Adjust the process(&quot;beam&quot;) reference to your beam version and attach the script to a running &quot;beam&quot; instance:</source>
          <target state="translated">调整process(&quot;beam&quot;)对你的beam版本的引用,并将脚本附加到一个正在运行的 &quot;beam &quot;实例上。</target>
        </trans-unit>
        <trans-unit id="c57f256463601b2a2c62f254f5126bfecb16a4d2" translate="yes" xml:space="preserve">
          <source>Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes.</source>
          <target state="translated">调整SSH流控窗口。这要由客户端和服务器端的通道进程来完成。</target>
        </trans-unit>
        <trans-unit id="980e8823b26ab3a416e4eec330a78a5f567d8a4d" translate="yes" xml:space="preserve">
          <source>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">仅影响SSL-3.0和TLS-1.0连接。用于更改BEAST缓解策略以与旧版软件互操作。默认为 &lt;code&gt;one_n_minus_one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6004ea02cc23d09682422b618c26d349782aa93" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. If set to &lt;code&gt;false&lt;/code&gt;, it disables the block cipher padding check to be able to interoperate with legacy software.</source>
          <target state="translated">仅影响TLS-1.0连接。如果设置为 &lt;code&gt;false&lt;/code&gt; ，它将禁用块密码填充检查，以便能够与旧版软件互操作。</target>
        </trans-unit>
        <trans-unit id="debeed9026878cefb793f6e84d87d4b3c12ed8e6" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6ffc59171bd18b8e61a3e781dab573deabf10a" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt;, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. &lt;strong&gt;On all other platforms, this option is silently discarded.&lt;/strong&gt;</source>
          <target state="translated">仅影响Windows上的外部程序的端口。如果提供了此选项，则使用标志 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 打开端口程序的标准输入和标准输出句柄，以便端口程序可以（并且必须）在其标准句柄上执行重叠的I / O。对于简单的端口程序，通常不是这种情况，但是对于经验丰富的Windows程序员来说，这是一种有价值的选择。&lt;strong&gt;在所有其他平台上，此选项将被静默丢弃。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf4fb0d4263b60ac21dc80f51c2dec3dcfb5747e" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. &lt;code&gt;stderr_to_stdout&lt;/code&gt; and &lt;code&gt;nouse_stdio&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">影响到外部程序的端口。执行的程序将其标准错误文件重定向到其标准输出文件。 &lt;code&gt;stderr_to_stdout&lt;/code&gt; 和 &lt;code&gt;nouse_stdio&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="1e538da53759cfec60cd8a151505e38fb92a9633" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089&quot;&gt;all terms&lt;/a&gt;&lt;/code&gt; referenced by the root-set have been copied, the collector scans the &lt;strong&gt;to space&lt;/strong&gt; and copies all terms that these terms reference. When scanning, the collector steps through each term on the &lt;strong&gt;to space&lt;/strong&gt; and any term still referencing the &lt;strong&gt;from space&lt;/strong&gt; is copied over to the &lt;strong&gt;to space&lt;/strong&gt;. Some terms contain non-term data (the payload of a on heap binary for instance). When encountered by the collector, these values are simply skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c066b0f9a1e6496e99cead0881b8f872728f45" translate="yes" xml:space="preserve">
          <source>After LTTng is properly installed on the system Erlang/OTP can be built with LTTng support.</source>
          <target state="translated">在系统上正确安装LTTng后,就可以用LTTng支持构建Erlang/OTP。</target>
        </trans-unit>
        <trans-unit id="093311043e9bea9fbc9705d1e98f8e3acfd08364" translate="yes" xml:space="preserve">
          <source>After STDLIB 3.4 (OTP 20.0) compiled match specifications have an external representation as a node specific reference to the original compiled match specification. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result &lt;strong&gt;may or may not&lt;/strong&gt; be a valid compiled match specification depending on if the original compiled match specification was still alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1facbcf11ae5793aa1bc80ef16d286aebd0fc34d" translate="yes" xml:space="preserve">
          <source>After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">在0之后,最多读取两个八位数。如果少于两个数字,则只使用现有的数字。因此,序列 \0\x\015指定了两个二进制零,后面是一个CR字符(代码值13)。如果后面的模式字符本身是一个八进制数字,请确保在初始零之后提供两个数字。</target>
        </trans-unit>
        <trans-unit id="ec54f9531929f3cd1ca22e8febfcaf52fc58636a" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; it contains the number of bytes padded. Otherwise 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d732389ea2448ab3a2fa3d0a36ca3e321f1eb8c8" translate="yes" xml:space="preserve">
          <source>After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:</source>
          <target state="translated">在部分匹配或匹配失败后,会返回整个匹配过程中最后遇到的名字,例如。</target>
        </trans-unit>
        <trans-unit id="5fc9546102b17d8235883e41d7c9f9c95505b3d1" translate="yes" xml:space="preserve">
          <source>After a succesful incoming authentication, a new process runs as the just authenticated user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46c18eae1ac24b22616197a0acee7d1074a413c" translate="yes" xml:space="preserve">
          <source>After a successful authentication an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ee0e3703c2647b03b1406f234f9cc3d123429d" translate="yes" xml:space="preserve">
          <source>After adding more records to the &lt;code&gt;Company&lt;/code&gt; database, the result can be the following records:</source>
          <target state="translated">在将更多记录添加到 &lt;code&gt;Company&lt;/code&gt; 数据库后，结果可能是以下记录：</target>
        </trans-unit>
        <trans-unit id="93fdc04d975de9f436b576b59d005bc9bf8bf315" translate="yes" xml:space="preserve">
          <source>After all name servers have been tried, there is a timeout before the name servers are tried again. This is to prevent the server from answering the query with what's in the servfail cache, &lt;code&gt;inet_res(3)&lt;/code&gt;. Defaults to 1500 milli seconds .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22669be288b8402f937e20a5b4c0d8be02ada8ae" translate="yes" xml:space="preserve">
          <source>After an analysis, you can inspect this information. In the &lt;strong&gt;PLT&lt;/strong&gt; menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in &lt;code&gt;EDoc&lt;/code&gt; format.</source>
          <target state="translated">经过分析，您可以检查此信息。在&lt;strong&gt;PLT&lt;/strong&gt;菜单中，您可以选择搜索PLT或检查整个PLT的内容。该信息以 &lt;code&gt;EDoc&lt;/code&gt; 格式显示。</target>
        </trans-unit>
        <trans-unit id="6ef9c0c6bbe4e27c696f859b427107c4e849d03c" translate="yes" xml:space="preserve">
          <source>After any post hook has been executed for all installed CTHs, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; is called if the testcase failed or was skipped, respectively. You cannot affect the outcome of the tests any further at this point.</source>
          <target state="translated">在对所有已安装的CTH执行任何发布挂钩之后，如果测试用例失败或被跳过，则分别调用 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; 。您现在不能再影响测试结果了。</target>
        </trans-unit>
        <trans-unit id="f056750b4e33f30fb9d5942f6265a2d4f346b9dc" translate="yes" xml:space="preserve">
          <source>After at least one tab-character, the line added is to contain the full name of the named pipe where &lt;code&gt;syslogd&lt;/code&gt; writes its information. The path must be the same as for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The filename must be &lt;code&gt;syslog.otp&lt;/code&gt;.</source>
          <target state="translated">在至少一个制表符之后，添加的行将包含 &lt;code&gt;syslogd&lt;/code&gt; 写入其信息的命名管道的全名。该路径必须与 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 文件的路径相同。文件名必须是 &lt;code&gt;syslog.otp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ce4ab81087082fd95156bdaf8c2e0786410e8e3" translate="yes" xml:space="preserve">
          <source>After completing all the normal building steps described above a debug enabled runtime system can be built. To do this you have to change directory to &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and execute:</source>
          <target state="translated">完成上述所有正常构建步骤后，即可构建启用调试的运行时系统。为此，您必须将目录更改为 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 并执行：</target>
        </trans-unit>
        <trans-unit id="9cd742cd300933dfb65e0a535f4d15de36d37f01" translate="yes" xml:space="preserve">
          <source>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">在解码一个消息后,为了让用户能够正确的操作,各种用户回调函数被调用。关于回调参数的更多信息,请参见megaco_user模块。</target>
        </trans-unit>
        <trans-unit id="dc240b1130d5df1612bf5772e5400cd74e1cad80" translate="yes" xml:space="preserve">
          <source>After flag fields for atom cache references, another half byte flag field is located with the following format:</source>
          <target state="translated">在原子缓存引用的标志字段之后,还有一个半字节的标志字段,其格式如下。</target>
        </trans-unit>
        <trans-unit id="8aca18c81b4ecc6e98bd69677c9d22a41d1f8407" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use &lt;code&gt;erl_connect()&lt;/code&gt;. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">初始化后，建立与Erlang节点的连接。要指定要连接的Erlang节点，请使用 &lt;code&gt;erl_connect()&lt;/code&gt; 。下面的示例设置连接并生成有效的套接字文件描述符：</target>
        </trans-unit>
        <trans-unit id="d230e040d4a295e72e3f66c85d88ac7727295ab3" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use the &lt;code&gt;ei_connect_*()&lt;/code&gt; family of functions. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71297d463c83eda2a6c9154b983ee09e837036ff" translate="yes" xml:space="preserve">
          <source>After installation you can access the documentation by</source>
          <target state="translated">安装后,您可以通过以下方式访问文档</target>
        </trans-unit>
        <trans-unit id="6b0c5270a184c48e498da3c725b4712069c50f99" translate="yes" xml:space="preserve">
          <source>After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</source>
          <target state="translated">在匹配了所有六位数字后,又未能匹配到 &quot;foo&quot;,匹配器的正常操作是只用五位数字再试一次匹配项 \d+,然后用四位,以此类推,最终失败。&quot;原子分组&quot;(这个术语取自Jeffrey Friedl的书)提供了指定子模式一旦匹配后,就不能再这样重新评估的方法。</target>
        </trans-unit>
        <trans-unit id="ae043d6d909deeb13bd861dc2fdf16fc111c0f4f" translate="yes" xml:space="preserve">
          <source>After reading the &lt;code&gt;erts_alloc(3)&lt;/code&gt; documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. &lt;code&gt;mbcs&lt;/code&gt; and &lt;code&gt;sbcs&lt;/code&gt; denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</source>
          <target state="translated">阅读了 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 文档后，返回的信息或多或少地说明了问题，但是有些事情值得解释。呼叫计数由两个值表示，第一个值是千兆呼叫，第二个值是呼叫。 &lt;code&gt;mbcs&lt;/code&gt; 和 &lt;code&gt;sbcs&lt;/code&gt; 分别表示多块载波和单块载波。大小以字节为单位。如果未显示尺寸，则为一定数量。大小和数量通常由三个值表示：</target>
        </trans-unit>
        <trans-unit id="90a4520417596de12836632d1f1ef59e2dcef82d" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;ei_connect#ei_accept&quot;&gt; ei_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9095c6393c06f16504fcb2b9e560f38a38a063b" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">注册名称后，使用 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; 等待传入连接。</target>
        </trans-unit>
        <trans-unit id="d3c38468398c9f7ba65583a0574f32622bbcf3f0" translate="yes" xml:space="preserve">
          <source>After sending the message &lt;code&gt;pong&lt;/code&gt; to the process &quot;ping&quot;, &quot;pong&quot; calls the &lt;code&gt;pong&lt;/code&gt; function again, which causes it to get back to the &lt;code&gt;receive&lt;/code&gt; again and wait for another message.</source>
          <target state="translated">在将消息 &lt;code&gt;pong&lt;/code&gt; 发送到进程&amp;ldquo; ping&amp;rdquo;之后，&amp;ldquo; pong&amp;rdquo; 再次调用 &lt;code&gt;pong&lt;/code&gt; 函数，这使它再次返回到 &lt;code&gt;receive&lt;/code&gt; 并等待另一条消息。</target>
        </trans-unit>
        <trans-unit id="e36306045d856ed44b3178bdde7ee2e0ace1e9c1" translate="yes" xml:space="preserve">
          <source>After setting the dictionary the inflate operation should be retried without new input.</source>
          <target state="translated">在设置字典后,膨胀操作应该在没有新输入的情况下重新尝试。</target>
        </trans-unit>
        <trans-unit id="46b2484894cf1b418bcc258ea3f4b87e3bcd685f" translate="yes" xml:space="preserve">
          <source>After testing that the client process exists:</source>
          <target state="translated">在测试客户进程存在后。</target>
        </trans-unit>
        <trans-unit id="22756028dc88f951673801206c8f0149ec02c1b4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;Flags&lt;/code&gt; field follow the &lt;code&gt;AtomCacheRefs&lt;/code&gt;. The first &lt;code&gt;AtomCacheRef&lt;/code&gt; is the one corresponding to &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Higher indices follow in sequence up to index &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Flags&lt;/code&gt; 字段之后，跟随 &lt;code&gt;AtomCacheRefs&lt;/code&gt; 。第一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 是与 &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0 对应的一个。更高的索引依次到索引 &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca4e4c96c0a14c7be226e5bd7489709c72d0c43" translate="yes" xml:space="preserve">
          <source>After the application specifications have been updated, the instructions in the script are evaluated and the function returns &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; if successful. &lt;code&gt;OtherVsn&lt;/code&gt; and &lt;code&gt;Descr&lt;/code&gt; are the version (&lt;code&gt;UpFromVsn&lt;/code&gt; or &lt;code&gt;Vsn&lt;/code&gt;) and description (&lt;code&gt;Descr1&lt;/code&gt; or &lt;code&gt;Descr2&lt;/code&gt;) as specified in the script.</source>
          <target state="translated">更新应用程序规范后，将评估脚本中的指令，如果成功 &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; 函数将返回{ok，OtherVsn，Descr}。 &lt;code&gt;OtherVsn&lt;/code&gt; 和 &lt;code&gt;Descr&lt;/code&gt; 是版本（ &lt;code&gt;UpFromVsn&lt;/code&gt; 或 &lt;code&gt;Vsn&lt;/code&gt; ）和说明（ &lt;code&gt;Descr1&lt;/code&gt; 或 &lt;code&gt;Descr2&lt;/code&gt; 如在脚本中指定）。</target>
        </trans-unit>
        <trans-unit id="0d4f7a31773a30c9ab44ee914a380f7ad8d9358d" translate="yes" xml:space="preserve">
          <source>After the change, 5 lines are presented as follows:</source>
          <target state="translated">改造后,5条线呈现如下。</target>
        </trans-unit>
        <trans-unit id="2c691aee72f4af2559c4df9a131c0a55a89cadf0" translate="yes" xml:space="preserve">
          <source>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter &lt;code&gt;schema_location&lt;/code&gt; is set.</source>
          <target state="translated">删除数据库后，仍然可以将Mnesia作为无盘节点启动。这取决于如何设置配置参数 &lt;code&gt;schema_location&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5839b9af149f08b9df4808444dfa4c5b3879065" translate="yes" xml:space="preserve">
          <source>After the handshake is performed, the user process receives messages with the tickets sent by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4298986c5c1910d7ad391031923615fdac4c6079" translate="yes" xml:space="preserve">
          <source>After the header word has been copied a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; is destructively placed in it pointing to the term in the &lt;strong&gt;to space&lt;/strong&gt;. Any other term that points to the already moved term will &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125&quot;&gt;see this move marker&lt;/a&gt;&lt;/code&gt; and copy the referring pointer instead. For example, if the have the following Erlang code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e458fe2735510f2a3f94986ee2e1c2798b1558" translate="yes" xml:space="preserve">
          <source>After the insertion of the employee named &lt;code&gt;klacke&lt;/code&gt;, the database has the following records:</source>
          <target state="translated">插入名为 &lt;code&gt;klacke&lt;/code&gt; 的员工后，数据库具有以下记录：</target>
        </trans-unit>
        <trans-unit id="014d2e6e6b7efad4c0429a37b959bc880d48f38c" translate="yes" xml:space="preserve">
          <source>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</source>
          <target state="translated">安装完成后,应用控制器对所有正在运行的应用进行新旧配置参数的比较,并调用回调函数。</target>
        </trans-unit>
        <trans-unit id="8b5bb17b2c511826d46800999f421579e3ca514c" translate="yes" xml:space="preserve">
          <source>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</source>
          <target state="translated">还原操作后,注册表的全部内容被标记为未修改。请注意,这包括任何在还原前被修改且未被还原覆盖的对象。</target>
        </trans-unit>
        <trans-unit id="c4f3acb2fc60165a466769fee1869d300231ddf6" translate="yes" xml:space="preserve">
          <source>After the rootsymbol declaration comes an optional declaration of the &lt;code&gt;end_of_input&lt;/code&gt; symbol that your scanner is expected to use. For example:</source>
          <target state="translated">在rootsymbol声明后的是一个可选的声明 &lt;code&gt;end_of_input&lt;/code&gt; 符号您的扫描仪，预计使用。例如：</target>
        </trans-unit>
        <trans-unit id="2770f0bd427f63fd51d60a2a398782f6d81807ca" translate="yes" xml:space="preserve">
          <source>After the successful build it's time to patch. The source tree directory, the directory of the installation and the applications to patch are given as arguments to &lt;code&gt;otp_patch_apply&lt;/code&gt;. The dependencies of each application are validated against the applications in the installation and the other applications given as arguments. If a dependency error is detected, the script will be aborted.</source>
          <target state="translated">成功构建之后，就该进行修补了。源树目录，安装目录和要修补的应用程序作为 &lt;code&gt;otp_patch_apply&lt;/code&gt; 的参数给出。对照安装中的应用程序和作为参数给出的其他应用程序验证每个应用程序的依赖性。如果检测到依赖性错误，则脚本将被中止。</target>
        </trans-unit>
        <trans-unit id="59c978cfe3812d62d5db4509ebca4d4c5513e4b6" translate="yes" xml:space="preserve">
          <source>After the system has been cross built you can build and install the documentation the same way as after a native build of the system. See the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; section in the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document for information on how to build the documentation.</source>
          <target state="translated">跨系统构建之后，您可以按照本机构建后的相同方式构建和安装文档。请参阅 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 文档中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; 部分，以获取有关如何构建文档的信息。</target>
        </trans-unit>
        <trans-unit id="0aad644b2254828a652fc4d00f391c4ee2e9798e" translate="yes" xml:space="preserve">
          <source>After these steps, the intermediate data structure, an &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;, is fully normalized. The last step is applying &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; that converts the intermediate structure into a valid canonical URI string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3f9b5771b4280d0c55a70767959a27ea46eb52" translate="yes" xml:space="preserve">
          <source>After this is compiled and the file &lt;code&gt;tut19.beam&lt;/code&gt; is copied to the necessary directories, the following is seen on (pong@kosken):</source>
          <target state="translated">编译完成并将文件 &lt;code&gt;tut19.beam&lt;/code&gt; 复制到必要的目录后，在（pong @ kosken）上可以看到以下内容：</target>
        </trans-unit>
        <trans-unit id="c6e5f33003aed8582bf379cb6df791e38f259eef" translate="yes" xml:space="preserve">
          <source>After thread progress, commit the staging area by assigning &lt;code&gt;the_staging_code_index&lt;/code&gt; to &lt;code&gt;the_active_code_index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0717a39ec07e9aad70e9e475eae5bb9f752c8e1" translate="yes" xml:space="preserve">
          <source>Again, the &lt;code&gt;relup&lt;/code&gt; file is created manually. Either from scratch or by editing a generated version. Load all code for &lt;code&gt;ch_app&lt;/code&gt; first, and also load the application specification, before &lt;code&gt;prim_sup&lt;/code&gt; is updated. When downgrading, &lt;code&gt;prim_sup&lt;/code&gt; is to updated first, before the code for &lt;code&gt;ch_app&lt;/code&gt; and its application specification are unloaded.</source>
          <target state="translated">同样， &lt;code&gt;relup&lt;/code&gt; 文件是手动创建的。从头开始或通过编辑生成的版本。在更新 &lt;code&gt;prim_sup&lt;/code&gt; 之前，首先加载 &lt;code&gt;ch_app&lt;/code&gt; 的所有代码，并加载应用程序规范。降级的情况下， &lt;code&gt;prim_sup&lt;/code&gt; 是首先更新，代码之前 &lt;code&gt;ch_app&lt;/code&gt; 及其应用规范被卸载。</target>
        </trans-unit>
        <trans-unit id="1b5e61e0895721c0ebf450f07d288833226aa589" translate="yes" xml:space="preserve">
          <source>Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:</source>
          <target state="translated">同样,这在Perl中也能用,但在PCRE中就不行了,原因也一样。当深层递归匹配过一个字符后,就不能再输入匹配一个空字符串。解决的办法是将两种情况分开,将奇数和偶数的情况作为上层的备选方案写出来。</target>
        </trans-unit>
        <trans-unit id="3b2767e308e62a98e4db59a3a9f824fa516512cb" translate="yes" xml:space="preserve">
          <source>Agent configuration:</source>
          <target state="translated">代理配置。</target>
        </trans-unit>
        <trans-unit id="3ec3b79e0abd28ca38f812dac049f7131b92ea23" translate="yes" xml:space="preserve">
          <source>Agent semantics</source>
          <target state="translated">代理人语义</target>
        </trans-unit>
        <trans-unit id="292ef3c4e0286769b6dbb07a9c3a55d1d989a61e" translate="yes" xml:space="preserve">
          <source>Agent specific config options and types:</source>
          <target state="translated">代理商特定的配置选项和类型。</target>
        </trans-unit>
        <trans-unit id="9183ce25ce4e057cce5e3b5d3d28a86f4aa93b15" translate="yes" xml:space="preserve">
          <source>Agents to be accessed by the manager needs to be registered by a user. Once registered, they can be accessed by all registered users.</source>
          <target state="translated">经理要访问的代理需要用户注册。一旦注册,所有注册用户都可以访问它们。</target>
        </trans-unit>
        <trans-unit id="b321e7cb00697b98b1069def622912b90e34756e" translate="yes" xml:space="preserve">
          <source>Aho &amp;amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</source>
          <target state="translated">Aho＆Johnson：&amp;ldquo; LR解析&amp;rdquo;，ACM计算调查，第1卷。1974年6：2。</target>
        </trans-unit>
        <trans-unit id="8314c1bccd7fbe31d59f08ffd330d112f0923137" translate="yes" xml:space="preserve">
          <source>Aim for finding bugs. Write whatever test that has the highest probability of finding a bug, now or in the future. Concentrate more on the critical parts. Bugs in critical subsystems are much more expensive than others.</source>
          <target state="translated">以找到bug为目标。不管是现在还是将来,只要是发现bug的概率最高的测试都要写。更多地集中在关键部分。关键子系统的bug比其他子系统的bug要贵得多。</target>
        </trans-unit>
        <trans-unit id="2e73e04c930e7b3b6a12e1613006c2d06e333b4f" translate="yes" xml:space="preserve">
          <source>Aim for functionality testing rather than implementation details. Implementation details change quite often, and the test suites are to be long lived. Implementation details often differ on different platforms and versions. If implementation details must be tested, try to factor them out into separate test cases. These test cases can later be rewritten or skipped.</source>
          <target state="translated">瞄准功能测试而不是实现细节。实现细节经常变化,测试套件要长期存在。在不同的平台和版本上,实现细节往往不同。如果必须对实现细节进行测试,尽量将其分解成单独的测试用例。这些测试用例以后可以重写或跳过。</target>
        </trans-unit>
        <trans-unit id="5204c24c2356e334c01209b09953d29e8b1c732c" translate="yes" xml:space="preserve">
          <source>Alarm handling</source>
          <target state="translated">报警处理</target>
        </trans-unit>
        <trans-unit id="07994d0d2fea2b8ccddc2fe4a57609e0e8cf0605" translate="yes" xml:space="preserve">
          <source>Alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">报警,即BEL字符(十六进制07)</target>
        </trans-unit>
        <trans-unit id="44b68bd3aa7ebc745c49072e3fc9224605032491" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is either of the alarms specified above.</source>
          <target state="translated">警报将报告给SASL警报处理程序，请参阅 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 。要设置警报，将 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; ，其中&amp;ldquo; &lt;code&gt;Alarm&lt;/code&gt; 是上面指定的警报之一。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
