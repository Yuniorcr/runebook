<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="51bb3389ce8effbbb1e7082b3ae1de9569a30494" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此选项指定的算法将是服务器在TLS-1.2中引入的签名算法协商中接受的算法。如果请求了客户证书，该算法也将提供给客户。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4e6804a383e502432af39ff151c1928a9f75f02" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#type-client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此选项指定的算法将是服务器在TLS-1.2中引入的签名算法协商中接受的算法。如果请求了客户证书，该算法也将提供给客户。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b2fe8210e9b69a3cc07735de1a6330b93954baa" translate="yes" xml:space="preserve">
          <source>The algoritm for modifications works like this:</source>
          <target state="translated">修改的算法是这样的。</target>
        </trans-unit>
        <trans-unit id="24adcb7d68961d8f0a870550a960cd9eb67c1117" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier &lt;strong&gt;owns&lt;/strong&gt; it.</source>
          <target state="translated">创建载体的分配器实例&lt;strong&gt;拥有&lt;/strong&gt;它。</target>
        </trans-unit>
        <trans-unit id="653b6f4757ea27c31c0c448ccd9f5fac52d31c8d" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier is called its &lt;strong&gt;owner&lt;/strong&gt;. Ownership never changes.</source>
          <target state="translated">创建载体的分配器实例称为其&lt;strong&gt;所有者&lt;/strong&gt;。所有权永远不变。</target>
        </trans-unit>
        <trans-unit id="21d1f0815a6d444af90bd4312ec8e5903fa532a8" translate="yes" xml:space="preserve">
          <source>The allocator instance that has the responsibility to perform deallocations in a carrier is called its &lt;strong&gt;employer&lt;/strong&gt;. The employer may also perform allocations if the carrier is not in the pool. Employment may change when a carrier is fetched from or inserted into the pool.</source>
          <target state="translated">负责在承运人中执行重新分配的分配器实例称为其&lt;strong&gt;雇主&lt;/strong&gt;。如果承运人不在集合中，则雇主也可以执行分配。从池中取出载具或将载具插入池中后，就业可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="ecacc86ad4cc59e19da91bbb213a08cf8976a29a" translate="yes" xml:space="preserve">
          <source>The allocator instance that uses a carrier &lt;strong&gt;employs&lt;/strong&gt; it.</source>
          <target state="translated">使用载体的分配器例如&lt;strong&gt;使用&lt;/strong&gt;它。</target>
        </trans-unit>
        <trans-unit id="10574335a609a1059aa012db0f86b9ea475e61d4" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Defaults to all &lt;code&gt;alloc_util&lt;/code&gt; allocators.</source>
          <target state="translated">将搜索的分配器类型。默认为所有 &lt;code&gt;alloc_util&lt;/code&gt; 分配器。</target>
        </trans-unit>
        <trans-unit id="c7aaf2a06a430d8ee61ee710cc5151971b25f4ab" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Note that blocks can move freely between allocator types, so restricting the search to certain allocators may return unexpected types (e.g. process heaps when searching binary_alloc), or hide blocks that were migrated out.</source>
          <target state="translated">要搜索的分配器类型。请注意,块可以在分配器类型之间自由移动,所以限制搜索某些分配器可能会返回意想不到的类型(例如搜索binary_alloc时的进程堆),或者隐藏被迁移出去的块。</target>
        </trans-unit>
        <trans-unit id="f12057feba7f44e75f727b96980ea9629634e93c" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt; mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">可以将表的允许 &lt;code&gt;AccessMode&lt;/code&gt; 定义为 &lt;code&gt;read_only&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 。可以在运行时使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt; mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; 进行切换。 &lt;code&gt;read_only&lt;/code&gt; 表和 &lt;code&gt;local_content&lt;/code&gt; 表始终在本地加载，因为无需从其他节点复制该表。如果已将其他表从其他节点上的活动副本远程加载，或者如果正在运行的 &lt;code&gt;Mnesia&lt;/code&gt; 已决定将该表已加载到其他节点，则主要从其他节点的活动副本远程加载其他表。</target>
        </trans-unit>
        <trans-unit id="f7ed9195c9091feda9cc03849f91a3d0e1313381" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">允许 &lt;code&gt;AccessMode&lt;/code&gt; 一个表可以被定义为 &lt;code&gt;read_only&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 。可以在运行时使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; 进行切换。 &lt;code&gt;read_only&lt;/code&gt; 表和 &lt;code&gt;local_content&lt;/code&gt; 表始终在本地加载，因为无需从其他节点复制该表。如果其他表已从其他节点上的活动副本中进行了远程装载，或者如果运行的 &lt;code&gt;Mnesia&lt;/code&gt; 已决定将该表已经在那里进行了装载，则主要从其他节点上的活动副本进行远程装载。</target>
        </trans-unit>
        <trans-unit id="c9cd2b75bdb0d580c661ccb5efbc7ebe47d4aa8f" translate="yes" xml:space="preserve">
          <source>The allowed range is 1..256. Defaults to 1 for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt;, and to 8 for &lt;code&gt;binary&lt;/code&gt;. No unit specifier must be given for the types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;.</source>
          <target state="translated">允许的范围是1..256。默认为1为 &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ，和 &lt;code&gt;bitstring&lt;/code&gt; ，并以8为 &lt;code&gt;binary&lt;/code&gt; 。无需为 &lt;code&gt;utf8&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 类型提供单位说明符。</target>
        </trans-unit>
        <trans-unit id="ad89fe4bac55bef5e612143241645e3f39f837c7" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;Operation&lt;/code&gt; are:</source>
          <target state="translated">允许的 &lt;code&gt;Operation&lt;/code&gt; 值为：</target>
        </trans-unit>
        <trans-unit id="91eabbe1745620d58dbabfc6b149c475cb3f775e" translate="yes" xml:space="preserve">
          <source>The amount of dirty CPU schedulers is limited by the amount of normal schedulers in order to limit the effect on processes executing on ordinary schedulers. If the amount of dirty CPU schedulers was allowed to be unlimited, dirty CPU bound jobs would potentially starve normal jobs.</source>
          <target state="translated">dirty CPU调度器的数量受到普通调度器数量的限制,以限制对普通调度器上执行的进程的影响。如果允许脏CPU调度器的数量不受限制,脏CPU绑定的作业将有可能饿死普通作业。</target>
        </trans-unit>
        <trans-unit id="27a9761aa8b41fe03707985ac819ffa2294674b4" translate="yes" xml:space="preserve">
          <source>The amount of dirty IO schedulers is not limited by the amount of normal schedulers &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt;. This since only I/O bound work is expected to execute on dirty I/O schedulers. If the user should schedule CPU bound jobs on dirty I/O schedulers, these jobs might starve ordinary jobs executing on ordinary schedulers.</source>
          <target state="translated">脏IO调度程序的数量不受正常调度程序 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt; 。这是因为仅预期在受约束的I / O调度程序上执行I / O绑定的工作。如果用户应在肮脏的I / O调度程序上调度CPU绑定的作业，则这些作业可能会饿死在普通调度程序上执行的普通作业。</target>
        </trans-unit>
        <trans-unit id="664e7e56a2225929620ef872c0ebcd0c6fb9c4c1" translate="yes" xml:space="preserve">
          <source>The amount of free memory available to the Erlang emulator for allocation.</source>
          <target state="translated">可供Erlang模拟器分配的可用内存量。</target>
        </trans-unit>
        <trans-unit id="856f5380158f6d7ba56eebb6ae41011bd9432d40" translate="yes" xml:space="preserve">
          <source>The amount of memory available to the whole operating system. This may well be equal to &lt;code&gt;total_memory&lt;/code&gt; but not necessarily.</source>
          <target state="translated">整个操作系统可用的内存量。这很可能等于 &lt;code&gt;total_memory&lt;/code&gt; ,但不一定。</target>
        </trans-unit>
        <trans-unit id="177a7f5e407b489cea8a1c26cd218274ba08f36c" translate="yes" xml:space="preserve">
          <source>The amount of memory the system has available for disk swap.</source>
          <target state="translated">系统可用于磁盘交换的内存量。</target>
        </trans-unit>
        <trans-unit id="7656a9402d240df34705d7b544f4dff29a5abe83" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for cached files read from disk.</source>
          <target state="translated">系统用于从磁盘读取缓存文件的内存量。</target>
        </trans-unit>
        <trans-unit id="eee7cda7742ee86ae7d191faad9371151f0ebd25" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for temporary storing raw disk blocks.</source>
          <target state="translated">系统用于临时存储原始磁盘块的内存量。</target>
        </trans-unit>
        <trans-unit id="1082b666267c1d0a05f9d3fc735ec44903b5cce2" translate="yes" xml:space="preserve">
          <source>The amount of time that passes between a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a link signal sent to a non-existing process triggers an exit signal, which is sent back to where the link signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down.</source>
          <target state="translated">从信号发出到信号到达目的地之间的时间是不确定的,但却是正数。如果接收器已经终止,信号就不会到达,但它可以触发另一个信号。例如,向一个不存在的进程发送的链路信号会触发一个退出信号,该信号被送回链路信号的来源地。当通过分发进行通信时,如果分发通道发生故障,信号可能会丢失。</target>
        </trans-unit>
        <trans-unit id="4519c04c3df5357f9581cfbf162358aa5fec4d97" translate="yes" xml:space="preserve">
          <source>The amount of total amount of memory the system has available for disk swap.</source>
          <target state="translated">系统可用于磁盘交换的内存总量。</target>
        </trans-unit>
        <trans-unit id="acb741068fefaff7489583de212a734f3e2cfa94" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap, in words. This information is usually useless.</source>
          <target state="translated">每个堆上未使用的内存量,以字为单位。这个信息通常是无用的。</target>
        </trans-unit>
        <trans-unit id="784b5a2e886a3960b27831ea309171f77ba1c2b8" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap. This information is usually useless.</source>
          <target state="translated">每个堆上未使用的内存量。这个信息通常是无用的。</target>
        </trans-unit>
        <trans-unit id="eaa8449008b96acfc6b47fd80ac7ade7e1100e51" translate="yes" xml:space="preserve">
          <source>The analysis result can either be for all modules, or for one module. In either case a call count limit can be given to filter out the functions with a call count below the limit. The all modules analysis does &lt;strong&gt;not&lt;/strong&gt; contain the module &lt;code&gt;cprof&lt;/code&gt; itself, it can only be analysed by specifying it as a single module to analyse.</source>
          <target state="translated">分析结果可以是所有模块的，也可以是一个模块的。在任何一种情况下，都可以给出呼叫计数限制以过滤出呼叫计数低于该限制的功能。的所有模块分析并&lt;strong&gt;不&lt;/strong&gt;包含模块 &lt;code&gt;cprof&lt;/code&gt; 本身，它只能通过指定它作为一个单一模块，用于分析进行分析。</target>
        </trans-unit>
        <trans-unit id="665b53498dfc4b5081b2898303b46c4e6c1e3b19" translate="yes" xml:space="preserve">
          <source>The analysis starts from an empty PLT and creates a new one from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. This option only works for BEAM files. To override the default PLT location, use &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">分析从一个空的PLT开始，然后从 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-r&lt;/code&gt; 指定的文件中创建一个新的PLT 。此选项仅适用于BEAM文件。要覆盖默认的PLT位置，请使用 &lt;code&gt;--plt&lt;/code&gt; 或 &lt;code&gt;--output_plt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a17bc48533ec6b4b1d93aa9a618a8199d8ee18c" translate="yes" xml:space="preserve">
          <source>The ancillary data &lt;code&gt;AncData&lt;/code&gt; contains options that for this single message override the default options for the socket, an operation that may not be supported on all platforms, and if so return &lt;code&gt;{error, einval}&lt;/code&gt;. Using more than one of an ancillary data item type may also not be supported. &lt;code&gt;AncData =:= []&lt;/code&gt; is always supported.</source>
          <target state="translated">辅助数据 &lt;code&gt;AncData&lt;/code&gt; 包含用于此单个消息的选项，这些选项会覆盖套接字的默认选项（并非所有平台都支持该操作），如果返回，则返回 &lt;code&gt;{error, einval}&lt;/code&gt; 。也可能不支持使用一种以上的辅助数据项类型。始终支持 &lt;code&gt;AncData =:= []&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdcf511f2d0831631f6fdd22a140605914418760" translate="yes" xml:space="preserve">
          <source>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</source>
          <target state="translated">请求的回答被编码为UDP协议数据单元(PDU)。</target>
        </trans-unit>
        <trans-unit id="2bf1e9025d3f661f3470ed7afc4906eb1f7fc756" translate="yes" xml:space="preserve">
          <source>The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns &lt;code&gt;false&lt;/code&gt;, or collecting the template when all filters return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">通过从左到右评估限定词，在某些过滤器返回 &lt;code&gt;false&lt;/code&gt; 时回溯或在所有过滤器返回 &lt;code&gt;true&lt;/code&gt; 时收集模板来找到答案。</target>
        </trans-unit>
        <trans-unit id="f318a6ba118898a63239c22ec72006a08d5ca687" translate="yes" xml:space="preserve">
          <source>The application can be specified by its name &lt;code&gt;Application&lt;/code&gt;. In this case, the application controller searches the code path for the application resource file &lt;code&gt;Application.app&lt;/code&gt; and loads the specification it contains.</source>
          <target state="translated">可以通过名称 &lt;code&gt;Application&lt;/code&gt; 指定应用程序。在这种情况下，应用程序控制器在代码路径中搜索应用程序资源文件 &lt;code&gt;Application.app&lt;/code&gt; 并加载其包含的规范。</target>
        </trans-unit>
        <trans-unit id="620c94d66204ee923841db86e6b7d75bbdd11ef8" translate="yes" xml:space="preserve">
          <source>The application concept applies both to program structure (processes) and directory structure (modules).</source>
          <target state="translated">应用概念既适用于程序结构(进程),也适用于目录结构(模块)。</target>
        </trans-unit>
        <trans-unit id="f58d25a7007e6f3798c0b59bdfac842192b77950" translate="yes" xml:space="preserve">
          <source>The application controller automatically loads any included applications when loading a primary application, but does not start them. Instead, the top supervisor of the included application must be started by a supervisor in the including application.</source>
          <target state="translated">在加载主应用程序时,应用程序控制器会自动加载任何包含的应用程序,但不会启动它们。相反,必须由包含应用程序中的主管启动包含应用程序的顶层主管。</target>
        </trans-unit>
        <trans-unit id="98f6f34774d04811ed29ee462b6732dccb9d0043" translate="yes" xml:space="preserve">
          <source>The application controller checks the value of the application specification key &lt;code&gt;applications&lt;/code&gt;, to ensure that all applications needed to be started before this application are running. Otherwise, &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; is returned, where &lt;code&gt;App&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">应用程序控制器检查应用程序规范关键 &lt;code&gt;applications&lt;/code&gt; 的值，以确保需要在该应用程序运行之前启动所有应用程序。否则，返回 &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; ，其中 &lt;code&gt;App&lt;/code&gt; 是缺少的应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="f3a71b2d510c249b1ef4dc36fecf08094449baa7" translate="yes" xml:space="preserve">
          <source>The application controller creates an application master for the application</source>
          <target state="translated">应用程序控制器为应用程序创建一个应用程序主站。</target>
        </trans-unit>
        <trans-unit id="83a95923e1f732ae145bb3e38ddb63679bc6a37a" translate="yes" xml:space="preserve">
          <source>The application controller then creates an &lt;strong&gt;application master&lt;/strong&gt; for the application. The application master becomes the group leader of all the processes in the application. I/O is forwarded to the previous group leader, though, this is just a way to identify processes that belong to the application. Used for example to find itself from any process, or, reciprocally, to kill them all when it terminates.</source>
          <target state="translated">然后，应用程序控制器为该应用程序创建一个&lt;strong&gt;应用程序母版&lt;/strong&gt;。应用程序主管将成为应用程序中所有进程的组负责人。I / O被转发给上一个组长，但这只是识别属于该应用程序的进程的一种方式。例如，用于从任何进程中查找自己，或者相反，在进程终止时将其全部杀死。</target>
        </trans-unit>
        <trans-unit id="cb0f6ae5fb0c8a7581cb9e8e067ef2f56d1995bb" translate="yes" xml:space="preserve">
          <source>The application dependencies can be checked using the Erlang shell. Application dependencies are verified among installed applications by &lt;code&gt;otp_patch_apply&lt;/code&gt;, but these are not necessarily those actually loaded. By calling &lt;code&gt;system_information:sanity_check()&lt;/code&gt; one can validate dependencies among applications actually loaded.</source>
          <target state="translated">可以使用Erlang Shell检查应用程序依赖项。 &lt;code&gt;otp_patch_apply&lt;/code&gt; 在已安装的应用程序之间验证了应用程序依赖关系，但不一定是实际加载的依赖关系。通过调用 &lt;code&gt;system_information:sanity_check()&lt;/code&gt; ,可以验证实际加载的应用程序之间的依赖关系。</target>
        </trans-unit>
        <trans-unit id="bb62df0e58b18cc0a3dd6823066bbe7bee60e95d" translate="yes" xml:space="preserve">
          <source>The application is started at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. The application is started as usual. That is, an application master is created and calls the application callback function:</source>
          <target state="translated">该应用程序在 &lt;code&gt;distributed&lt;/code&gt; 配置参数的节点列表中列出的第一个操作节点上启动。该应用程序照常启动。也就是说，将创建一个应用程序主文件并调用应用程序回调函数：</target>
        </trans-unit>
        <trans-unit id="89049fedc72f84958aace187301d7f02b79550e8" translate="yes" xml:space="preserve">
          <source>The application is started by the application master calling:</source>
          <target state="translated">应用程序由应用程序主控调用启动。</target>
        </trans-unit>
        <trans-unit id="bfedb4900bc06eb3b379ebe1429d3cb0e9392954" translate="yes" xml:space="preserve">
          <source>The application is started the normal way at the new node, that is, by the application master calling:</source>
          <target state="translated">应用程序在新的节点正常启动,也就是由应用程序主控调用。</target>
        </trans-unit>
        <trans-unit id="10822e972b13555d1eff4f5137f6287954df0861" translate="yes" xml:space="preserve">
          <source>The application master calls &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; to start the top supervisor.</source>
          <target state="translated">应用程序主控程序调用 &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; 以启动最高主管。</target>
        </trans-unit>
        <trans-unit id="e29776b842b696055e58002f88fb65232061b2ab" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;Module:start/2&lt;/code&gt; as defined by the application specification key &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">应用程序主程序通过调用应用程序规范键 &lt;code&gt;mod&lt;/code&gt; 定义的应用程序回调函数 &lt;code&gt;Module:start/2&lt;/code&gt; 来启动应用程序。</target>
        </trans-unit>
        <trans-unit id="8cabb4f62fd98a4ff2c6678b3ed5fdfd959999a1" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;start/2&lt;/code&gt; in the module, and with the start argument, defined by the &lt;code&gt;mod&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">应用程序主机通过调用模块中的应用程序回调函数 &lt;code&gt;start/2&lt;/code&gt; 并使用 &lt;code&gt;.app&lt;/code&gt; 文件中的 &lt;code&gt;mod&lt;/code&gt; 键定义的start参数来启动应用程序。</target>
        </trans-unit>
        <trans-unit id="13734b250f5eb9d546b03086cf7b41b4dea34d6f" translate="yes" xml:space="preserve">
          <source>The application master stops the application by telling the top supervisor to shut down. The top supervisor tells all its child processes to shut down, and so on; the entire tree is terminated in reversed start order. The application master then calls the application callback function &lt;code&gt;stop/1&lt;/code&gt; in the module defined by the &lt;code&gt;mod&lt;/code&gt; key.</source>
          <target state="translated">应用程序主程序通过告诉最高主管关闭来停止应用程序。最高主管告诉所有子进程关闭，依此类推；整个树以相反的开始顺序终止。然后，应用程序主机在由 &lt;code&gt;mod&lt;/code&gt; 键定义的模块中调用应用程序回调函数 &lt;code&gt;stop/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b526c8807809b1d1a78677dccccf183dc7531782" translate="yes" xml:space="preserve">
          <source>The application master then calls &lt;code&gt;Module:start/2&lt;/code&gt; for the primary application, followed by calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; for each start phase (as defined for the primary application), both for the primary application and for each of its included applications, for which the start phase is defined.</source>
          <target state="translated">然后，应用程序主服务器为主要应用程序调用 &lt;code&gt;Module:start/2&lt;/code&gt; ，然后为主要应用程序及其包含的每个应用程序，为每个启动阶段（为主要应用程序定义）调用 &lt;code&gt;Module:start_phase/3&lt;/code&gt; ，为此定义了开始阶段。</target>
        </trans-unit>
        <trans-unit id="a163c20a5a18b97757a743989413cf19c582f80f" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R10B or later.</source>
          <target state="translated">该应用程序需要 Erlang/OTP R10B 或更高版本。</target>
        </trans-unit>
        <trans-unit id="47de7b9f1554880fd51a51ad6a1c134e4bb1c43b" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13B02 or later.</source>
          <target state="translated">该应用程序需要 Erlang/OTP R13B02 或更新版本。</target>
        </trans-unit>
        <trans-unit id="04c072f323859be092a04c77c0d3a8f3932431a9" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13BB or later. If you use the old &lt;code&gt;GS&lt;/code&gt; based GUI it does suffice with R7B.</source>
          <target state="translated">该应用程序需要Erlang / OTP版本R13BB或更高版本。如果使用旧的基于 &lt;code&gt;GS&lt;/code&gt; 的GUI，R7B就足够了。</target>
        </trans-unit>
        <trans-unit id="705f938ebc82f5cfe9e917670d636ce442e4f982" translate="yes" xml:space="preserve">
          <source>The application resource file is to be called &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in directory &lt;code&gt;ebin&lt;/code&gt; for the application.</source>
          <target state="translated">该应用程序资源文件称为 &lt;code&gt;Application.app&lt;/code&gt; ，其中 &lt;code&gt;Application&lt;/code&gt; 是应用程序名称。该文件位于应用程序的目录 &lt;code&gt;ebin&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8095bda3db4836c710654adeb79de3919a1733c3" translate="yes" xml:space="preserve">
          <source>The application settings page is rather incomplete.</source>
          <target state="translated">应用设置页面比较不完整。</target>
        </trans-unit>
        <trans-unit id="a30b190dbffeb37d7579aa94007cbfaeb029e782" translate="yes" xml:space="preserve">
          <source>The application specification can also be specified directly as a tuple &lt;code&gt;AppSpec&lt;/code&gt;, having the format and contents as described in &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">应用程序规范也可以直接指定为元组 &lt;code&gt;AppSpec&lt;/code&gt; ，其格式和内容如 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="ae0f5edbfbc9e079896bc2aadb1ec402b1e46966" translate="yes" xml:space="preserve">
          <source>The application upgrade file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in the &lt;code&gt;ebin&lt;/code&gt; directory for the application.</source>
          <target state="translated">应用程序升级文件称为 &lt;code&gt;Application.appup&lt;/code&gt; ，其中 &lt;code&gt;Application&lt;/code&gt; 是应用程序名称。该文件位于应用程序的 &lt;code&gt;ebin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="01be2b299856c125d638a3713ccfbcb4f60476f7" translate="yes" xml:space="preserve">
          <source>The application version of the SSL application.</source>
          <target state="translated">SSL应用程序的应用版本。</target>
        </trans-unit>
        <trans-unit id="73e6b27f7140dc43719697a589e7dc915f9cffa1" translate="yes" xml:space="preserve">
          <source>The application window is started by double clicking on an application name. The application window consists of four pages (tabs):</source>
          <target state="translated">双击应用程序名称,即可启动应用程序窗口。申请窗口由四个页面(标签)组成。</target>
        </trans-unit>
        <trans-unit id="c8077f9793de81202aa1676c65a0451a20a5cbbb" translate="yes" xml:space="preserve">
          <source>The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">AVP的与应用程序无关的表示。主要用于需要处理任意直径应用的继电器应用。实现特定Diameter应用程序（为其配置了字典）的服务可以改为处理 &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="e81712f8fd17dfa5b0951414305dbd11e0bfbc67" translate="yes" xml:space="preserve">
          <source>The applications are sorted according to the dependencies between the applications. Where there are no dependencies, the order in the &lt;code&gt;.rel&lt;/code&gt; file is kept.</source>
          <target state="translated">根据应用程序之间的依赖关系对应用程序进行排序。如果没有依赖项，则将保留 &lt;code&gt;.rel&lt;/code&gt; 文件中的顺序。</target>
        </trans-unit>
        <trans-unit id="82097ff09c0ae197dc0287ade0a7e0d61d1b24de" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;exit(ExitReason)&lt;/code&gt; and did not catch this exception. The exit reason &lt;code&gt;ExitReason&lt;/code&gt; equals the argument passed to &lt;code&gt;exit/1&lt;/code&gt;.</source>
          <target state="translated">应用的函数称为 &lt;code&gt;exit(ExitReason)&lt;/code&gt; ，但未捕获此异常。退出原因 &lt;code&gt;ExitReason&lt;/code&gt; 等于传递给 &lt;code&gt;exit/1&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="58807661154d4de0263adc44bf6decafbe204083" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;throw(Value)&lt;/code&gt; and did not catch this exception. The exception reason &lt;code&gt;Value&lt;/code&gt; equals the argument passed to &lt;code&gt;throw/1&lt;/code&gt;.</source>
          <target state="translated">应用的函数称为 &lt;code&gt;throw(Value)&lt;/code&gt; ，但未捕获此异常。异常原因 &lt;code&gt;Value&lt;/code&gt; 等于传递给 &lt;code&gt;throw/1&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="85353072338b2dbf168feea1aabc66961c7a142d" translate="yes" xml:space="preserve">
          <source>The archive must be closed with &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须使用 &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt; 关闭档案。</target>
        </trans-unit>
        <trans-unit id="cd634904a6b19656df55ba94518706b87469aeb9" translate="yes" xml:space="preserve">
          <source>The archive size is limited to 2 GB (32 bits).</source>
          <target state="translated">档案大小限制为2GB(32位)。</target>
        </trans-unit>
        <trans-unit id="cd12ca75aaea91ed2a310f36dcea8f4976e41af5" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;DefaultAgentConfig&lt;/code&gt; is used as default values when this user register agents.</source>
          <target state="translated">该用户注册代理时，参数 &lt;code&gt;DefaultAgentConfig&lt;/code&gt; 用作默认值。</target>
        </trans-unit>
        <trans-unit id="69004e83d19b67fea82f2e443fe9acacd301728c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Extra&lt;/code&gt; is just an opaque data structure passed to the user via the callback functions in the &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt;. Note however that if &lt;code&gt;Extra&lt;/code&gt; has the value &lt;code&gt;extra_undefined&lt;/code&gt; the argument will be ignored (same as if &lt;code&gt;process_received_message/4&lt;/code&gt; had been called). See the documentation for the behaviour of the callback module, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt;, for more info.</source>
          <target state="translated">参数 &lt;code&gt;Extra&lt;/code&gt; 只是通过 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt; 的回调函数传递给用户的不透明数据结构。但是请注意，如果 &lt;code&gt;Extra&lt;/code&gt; 具有 &lt;code&gt;extra_undefined&lt;/code&gt; 值，则将忽略该参数（就像已调用 &lt;code&gt;process_received_message/4&lt;/code&gt; 一样）。有关更多信息，请参阅有关回调模块 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt; 的行为的文档。</target>
        </trans-unit>
        <trans-unit id="f459c21deb16ca0d8a2238ea1bb013af1aa40900" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to read for future connections.</source>
          <target state="translated">参数 &lt;code&gt;Listen&lt;/code&gt; 是最初从 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 回调传递的句柄。 &lt;code&gt;Opts&lt;/code&gt; 参数是可供将来连接阅读的选项列表。</target>
        </trans-unit>
        <trans-unit id="debf3f82b456b10623118b0f8614068c9ab5fae7" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to set on future connections.</source>
          <target state="translated">参数 &lt;code&gt;Listen&lt;/code&gt; 是最初从 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 回调传递的句柄。 &lt;code&gt;Opts&lt;/code&gt; 参数是要在将来的连接上设置的选项的列表。</target>
        </trans-unit>
        <trans-unit id="6f649282c95c4ff27efd3a1061e1c2bdcdf508eb" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. It returns &lt;code&gt;{atomic, TabList}&lt;/code&gt; if successful, or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt; if there is an error. &lt;code&gt;TabList&lt;/code&gt; is a list of the restored tables. Tables that are restored are write-locked during the restore operation. However, regardless of any lock conflict caused by this, applications can continue to do their work during the restore operation.</source>
          <target state="translated">参数 &lt;code&gt;Opaque&lt;/code&gt; 被转发到备份模块。如果成功，则返回 &lt;code&gt;{atomic, TabList}&lt;/code&gt; 如果出错，则返回元组 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 。 &lt;code&gt;TabList&lt;/code&gt; 是已还原表的列表。还原的表在还原操作期间被写锁定。但是，无论由此引起的任何锁冲突，应用程序都可以在还原操作期间继续执行其工作。</target>
        </trans-unit>
        <trans-unit id="dfff5e2db73b8f539cd9908f48d194bda191ddfc" translate="yes" xml:space="preserve">
          <source>The argument can also be a list of modules or filenames, in which case the function tries to interpret each module as specified earlier. The function then always returns &lt;code&gt;ok&lt;/code&gt;, but prints some information to &lt;code&gt;stdout&lt;/code&gt; if a module cannot be interpreted.</source>
          <target state="translated">该参数也可以是模块或文件名的列表，在这种情况下，该函数将尝试按先前指定的方式解释每个模块。然后，该函数始终返回 &lt;code&gt;ok&lt;/code&gt; ，但是如果无法解释模块，则将一些信息 &lt;code&gt;stdout&lt;/code&gt; 到stdout。</target>
        </trans-unit>
        <trans-unit id="f72a488906a1bc4231e746b4ff7b4a8e45eb6fc3" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt;, where the precision is the number of digits written. The default precision is 6 and it cannot be &amp;lt; 2.</source>
          <target state="translated">参数是一个浮点数，写为 &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt; ，其中precision是写入的位数。默认精度为6，并且不能小于2。</target>
        </trans-unit>
        <trans-unit id="93d3f166ed7f071a0cf8c5e27837f3a0c6681247" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]ddd.ddd&lt;/code&gt;, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &amp;lt; 1.</source>
          <target state="translated">该参数是一个浮点数，写为 &lt;code&gt;[-]ddd.ddd&lt;/code&gt; ，其中精度是小数点后的位数。默认精度为6，并且不能小于1。</target>
        </trans-unit>
        <trans-unit id="049df39b974433b181b76b3894315e239a3ad777" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;f&lt;/code&gt;, if it is &amp;gt;= 0.1 and &amp;lt; 10000.0. Otherwise, it is written in the &lt;code&gt;e&lt;/code&gt; format. The precision is the number of significant digits. It defaults to 6 and is not to be &amp;lt; 2. If the absolute value of the float does not allow it to be written in the &lt;code&gt;f&lt;/code&gt; format with the desired number of significant digits, it is also written in the &lt;code&gt;e&lt;/code&gt; format.</source>
          <target state="translated">如果参数&amp;gt; = 0.1且&amp;lt;10000.0，则该参数是写为 &lt;code&gt;f&lt;/code&gt; 的float 。否则，它将以 &lt;code&gt;e&lt;/code&gt; 格式编写。精度是有效位数。它的默认值为6，且不小于2。如果float的绝对值不允许以 &lt;code&gt;f&lt;/code&gt; 格式写入具有所需有效位数的f格式，则它也将以 &lt;code&gt;e&lt;/code&gt; 格式写入。</target>
        </trans-unit>
        <trans-unit id="fd2ce2991cd1ed1c5544565d4bc9f56a7a9da522" translate="yes" xml:space="preserve">
          <source>The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:</source>
          <target state="translated">参数是一个被解释为ASCII码的数字。精确度是字符的打印次数,默认为字段宽度,而字段宽度默认为1。例子:</target>
        </trans-unit>
        <trans-unit id="41417c1b36d7d073dd070139b59528225284b877" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;init_per_suite&lt;/code&gt; is &lt;code&gt;Config&lt;/code&gt;, that is, the same key-value list of runtime configuration data that each test case takes as input argument. &lt;code&gt;init_per_suite&lt;/code&gt; can modify this parameter with information that the test cases need. The possibly modified &lt;code&gt;Config&lt;/code&gt; list is the return value of the function.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 的参数是 &lt;code&gt;Config&lt;/code&gt; ，即每个测试用例作为输入参数的运行时配置数据的相同键值列表。 &lt;code&gt;init_per_suite&lt;/code&gt; 可以使用测试用例所需的信息来修改此参数。可能已修改的 &lt;code&gt;Config&lt;/code&gt; 列表是函数的返回值。</target>
        </trans-unit>
        <trans-unit id="19116289e2a06f46f52b99e7a354d07e181d8263" translate="yes" xml:space="preserve">
          <source>The argument type change is from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">参数类型的改变是从有符号到无符号。这可能会造成问题,例如,如果你只把类型改了个遍,就会出现循环终止条件或错误条件。</target>
        </trans-unit>
        <trans-unit id="518f1110847b76edf7686b0d43ca29a942986a62" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;{local, error_man}&lt;/code&gt; specifies the name. The event manager is then locally registered as &lt;code&gt;error_man&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;{local, error_man}&lt;/code&gt; 指定名称。然后将事件管理器本地注册为 &lt;code&gt;error_man&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0afbf43c606253c8ecf1c39998b54bbb8fa67440" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;FormatArgs&lt;/code&gt; in &lt;code&gt;ct:log/print/pal&lt;/code&gt; are always passed on to the STDLIB function &lt;code&gt;io:format/3&lt;/code&gt; (For details, see the &lt;code&gt;io&lt;/code&gt; manual page).</source>
          <target state="translated">该参数 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;FormatArgs&lt;/code&gt; 在 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 总是传递到STDLIB功能 &lt;code&gt;io:format/3&lt;/code&gt; （详细信息，请参阅 &lt;code&gt;io&lt;/code&gt; 手册页）。</target>
        </trans-unit>
        <trans-unit id="ad2c02ade68b15ea95b904a33d006adc1b1cf304" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SnmpInfo&lt;/code&gt; relates in the following way:</source>
          <target state="translated">参数 &lt;code&gt;Type&lt;/code&gt; 和 &lt;code&gt;SnmpInfo&lt;/code&gt; 通过以下方式关联：</target>
        </trans-unit>
        <trans-unit id="c80eb8b8ff0c248539e0d4f345648274f59f93c8" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt; filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">在将参数提供给可执行文件之前，shell不会对其进行扩展。最值得注意的是，这意味着不会发生文件通配符扩展。要为参数扩展通配符，请使用 &lt;code&gt; filelib:wildcard/1&lt;/code&gt; 。请注意，即使该程序是Unix Shell脚本，也就是最终将调用该Shell，也不会发生通配符扩展，并且该脚本具有不变的参数。在Windows上，通配符扩展始终取决于程序本身，因此这不是问题。</target>
        </trans-unit>
        <trans-unit id="6b287b1ceba326e901144e95b8db2f9f2999be1d" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt;filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">在将参数提供给可执行文件之前，shell不会对其进行扩展。最值得注意的是，这意味着不会发生文件通配符扩展。要为参数扩展通配符，请使用 &lt;code&gt;filelib:wildcard/1&lt;/code&gt; 。请注意，即使该程序是Unix Shell脚本，也就是最终将调用该Shell，也不会发生通配符扩展，并且该脚本具有不变的参数。在Windows上，通配符扩展始终取决于程序本身，因此这不是问题。</target>
        </trans-unit>
        <trans-unit id="522ee4260f97c142662210e82bcb713e534c2aad" translate="yes" xml:space="preserve">
          <source>The arguments can be divided into &lt;strong&gt;emulator flags&lt;/strong&gt;, &lt;strong&gt;flags&lt;/strong&gt;, and &lt;strong&gt;plain arguments&lt;/strong&gt;:</source>
          <target state="translated">参数可以分为&lt;strong&gt;模拟器标志&lt;/strong&gt;，&lt;strong&gt;标志&lt;/strong&gt;和&lt;strong&gt;普通参数&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="f6ed9ef38109b234ba45603e287f33458c0a6ac4" translate="yes" xml:space="preserve">
          <source>The arguments can be of different data types. The following order is defined:</source>
          <target state="translated">参数可以是不同的数据类型。定义的顺序如下:</target>
        </trans-unit>
        <trans-unit id="c8d0f8904d643db2998fe9360557663dfc7593df" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;system_monitor/2&lt;/code&gt; specifies how all system monitoring on the node should be done, not how it should be changed. This means only one process at a time (&lt;code&gt;MonitorPid&lt;/code&gt;) can be the receiver of system monitor messages. Also, the way to clear a specific monitor option is to not include it in the list &lt;code&gt;Options&lt;/code&gt;. All system monitoring will, however, be cleared if the process identified by &lt;code&gt;MonitorPid&lt;/code&gt; terminates.</source>
          <target state="translated">&lt;code&gt;system_monitor/2&lt;/code&gt; 的参数指定如何完成节点上的所有系统监视，而不是更改方式。这意味着一次只能有一个进程（ &lt;code&gt;MonitorPid&lt;/code&gt; ）可以接收系统监视器消息。另外，清除特定监视器选项的方法是不将其包括在&amp;ldquo; &lt;code&gt;Options&lt;/code&gt; &amp;rdquo;列表中。但是，如果 &lt;code&gt;MonitorPid&lt;/code&gt; 标识的过程终止，则将清除所有系统监视。</target>
        </trans-unit>
        <trans-unit id="ffa892e870535324db1c0ec38851cc864f132069" translate="yes" xml:space="preserve">
          <source>The arguments:</source>
          <target state="translated">争论。</target>
        </trans-unit>
        <trans-unit id="a8a87576167815553ae803598fc43fec00d99fc0" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) for the current function.</source>
          <target state="translated">当前函数的arity(参数数)。</target>
        </trans-unit>
        <trans-unit id="f4a92fd68167fdb3dffdde93bfe14f1434196818" translate="yes" xml:space="preserve">
          <source>The arity of the function implementing the fun.</source>
          <target state="translated">实现fun的函数的arity。</target>
        </trans-unit>
        <trans-unit id="2e0c7ead6f817b15595de5c93baf2426dbf01b86" translate="yes" xml:space="preserve">
          <source>The arity of the function must match the number of arguments, else a compilation error occurs.</source>
          <target state="translated">函数的arity必须与参数数相匹配,否则会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="a567fbfc0f0119591979c89645ce71555342bc2e" translate="yes" xml:space="preserve">
          <source>The array length, that is, the function arity. &lt;code&gt;argv[N-1]&lt;/code&gt; thus denotes the Nth argument to the NIF. Notice that the argument &lt;code&gt;argc&lt;/code&gt; allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</source>
          <target state="translated">数组长度，即函数Arity。 &lt;code&gt;argv[N-1]&lt;/code&gt; 因此表示NIF的第N个参数。注意，参数 &lt;code&gt;argc&lt;/code&gt; 允许同一个C函数实现具有不同Arity（但可能具有相同名称）的多个Erlang函数。</target>
        </trans-unit>
        <trans-unit id="415f03b07c8ba3c8c05edaadd6e77c05a2cd0868" translate="yes" xml:space="preserve">
          <source>The array never shrinks automatically. If an index &lt;code&gt;I&lt;/code&gt; has been used to set an entry successfully, all indices in the range [0,&lt;code&gt;I&lt;/code&gt;] stay accessible unless the array size is explicitly changed by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">数组永远不会自动收缩。如果已使用索引 &lt;code&gt;I&lt;/code&gt; 成功设置条目，则除非通过调用 &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; 显式更改了数组大小，否则[0， &lt;code&gt;I&lt;/code&gt; ] 范围内的所有索引都将保持可访问状态。</target>
        </trans-unit>
        <trans-unit id="41821fc2a208b561d81f20833df1e2cf397cd22d" translate="yes" xml:space="preserve">
          <source>The associated code contains &lt;code&gt;pseudo variables&lt;/code&gt;&lt;code&gt;'$1'&lt;/code&gt;, &lt;code&gt;'$2'&lt;/code&gt;, &lt;code&gt;'$3'&lt;/code&gt;, etc. which refer to (are bound to) the values associated previously by the parser with the symbols of the right hand side of the rule. When these symbols are terminal categories, the values are token tuples of the input string (see above).</source>
          <target state="translated">关联的代码包含 &lt;code&gt;pseudo variables&lt;/code&gt; &lt;code&gt;'$1'&lt;/code&gt; ， &lt;code&gt;'$2'&lt;/code&gt; ， &lt;code&gt;'$3'&lt;/code&gt; 等，这些伪变量引用（绑定到）解析器之前与规则右手边的符号关联的值。当这些符号是终端类别时，这些值是输入字符串的令牌元组（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="3898cfb8a11a62ffe2fdba8be9357512d68bb196" translate="yes" xml:space="preserve">
          <source>The associated code may not only be used to build structures associated with phrases, but may also be used for syntactic and semantic tests, printout actions (for example for tracing), etc. during the parsing process. Since tokens contain positional (line number) information, it is possible to produce error messages which contain line numbers. If there is no associated code after the right hand side of the rule, the value &lt;code&gt;'$undefined'&lt;/code&gt; is associated with the phrase.</source>
          <target state="translated">关联的代码不仅可以用于构建与短语关联的结构，而且还可以在语法分析过程中用于语法和语义测试，打印输出操作（例如，用于跟踪）等。由于令牌包含位置（行号）信息，因此可能会产生包含行号的错误消息。如果在规则的右侧之后没有关联的代码，则值 &lt;code&gt;'$undefined'&lt;/code&gt; 与该短语关联。</target>
        </trans-unit>
        <trans-unit id="3ece07e37195ede709e7f03b9006e9af2c0f25d9" translate="yes" xml:space="preserve">
          <source>The association between carrier pool and allocator is very loose. The associations are more or less only there to get names for the amount of carrier pools needed and names of carrier pools that can be easily identified by the &lt;code&gt;:&lt;/code&gt; value.</source>
          <target state="translated">运营商池和分配器之间的关联非常松散。关联或多或少仅在此处获得所需载波池数量的名称以及可以通过 &lt;code&gt;:&lt;/code&gt; 值轻松识别的载波池名称。</target>
        </trans-unit>
        <trans-unit id="6b6e33dc105b7762f1d530b48ab29c546fd13258" translate="yes" xml:space="preserve">
          <source>The association cannot be established (&lt;code&gt;connect/*&lt;/code&gt; failure).</source>
          <target state="translated">无法建立关联（ &lt;code&gt;connect/*&lt;/code&gt; 失败）。</target>
        </trans-unit>
        <trans-unit id="ef9716ac7174f55cae16eacb1845e6a71402ef24" translate="yes" xml:space="preserve">
          <source>The association file &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; for the real implementation looks as follows:</source>
          <target state="translated">实际实现的关联文件 &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="81d1ef649b0dc2cac7a3f4619510067970a6fd77" translate="yes" xml:space="preserve">
          <source>The association file, which contains the names of instrumentation functions for the MIB, should have the suffix &lt;code&gt;.funcs&lt;/code&gt;. If the compiler does not find the association file, it gives a warning message and uses default instrumentation functions. (See &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; for more details).</source>
          <target state="translated">关联文件包含后缀 &lt;code&gt;.funcs&lt;/code&gt; ，该文件包含MIB的检测功能的名称。如果编译器找不到关联文件，它将发出警告消息并使用默认的检测功能。（有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e61865049f08d1e62a4b88bd1b23185c90eb9da" translate="yes" xml:space="preserve">
          <source>The asymetric encryption algorithm used in the server's private-public host key pair. Examples include the well-known RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; and elliptic curve &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt;.</source>
          <target state="translated">服务器的私有-公有主机密钥对中使用的非对称加密算法。示例包括著名 &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt; &lt;code&gt;'ssh-rsa'&lt;/code&gt; 和椭圆曲线'ecdsa-sha2-nistp521'。</target>
        </trans-unit>
        <trans-unit id="1e53d0f60e0c53dc5f649aa03a42efcad9929a69" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">异步线程池大小可以用命令行参数来设置 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。如果异步线程池不可用，则在调用 &lt;code&gt;driver_async&lt;/code&gt; 的线程中进行同步调用。可以通过 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 检索异步线程池中的当前异步线程数。</target>
        </trans-unit>
        <trans-unit id="00b06000d023218a0553695852ada6423beef957" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">异步线程池大小可以用命令行参数来设置 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。如果异步线程池不可用，则在调用 &lt;code&gt;driver_async&lt;/code&gt; 的线程中进行同步调用。可以通过 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 检索异步线程池中的当前异步线程数。</target>
        </trans-unit>
        <trans-unit id="6d949b17e0550064c4ba8e06402f035e12b3129f" translate="yes" xml:space="preserve">
          <source>The asynchronous API for drivers is complicated. First, the work must be prepared. In the example, this is done in &lt;code&gt;output&lt;/code&gt;. We could have used &lt;code&gt;control&lt;/code&gt;, but we want some variation in the examples. In our driver, we allocate a structure that contains anything that is needed for the asynchronous task to do the work. This is done in the main emulator thread. Then the asynchronous function is called from a driver thread, separate from the main emulator thread. Notice that the driver functions are not re-entrant, so they are not to be used. Finally, after the function is completed, the driver callback &lt;code&gt;ready_async&lt;/code&gt; is called from the main emulator thread, this is where we return the result to Erlang. (We cannot return the result from within the asynchronous function, as we cannot call the driver functions.)</source>
          <target state="translated">驱动程序的异步API很复杂。首先，必须做好准备。在示例中，这是在 &lt;code&gt;output&lt;/code&gt; 中完成的。我们本可以使用 &lt;code&gt;control&lt;/code&gt; ，但是我们希望示例中有一些变化。在驱动程序中，我们分配一个结构，该结构包含异步任务完成工作所需的任何内容。这是在主仿真器线程中完成的。然后，从驱动程序线程（与主仿真器线程分开）调用异步函数。注意，驱动程序功能不是可重入的，因此不要使用它们。最后，在函数完成之后，驱动程序回调 &lt;code&gt;ready_async&lt;/code&gt; 是从主仿真器线程调用的，这是我们将结果返回到Erlang的地方。（我们无法从异步函数中返回结果，因为我们无法调用驱动程序函数。）</target>
        </trans-unit>
        <trans-unit id="fb8f8a1d61eec151d7bbdbad482f3278e892dcab" translate="yes" xml:space="preserve">
          <source>The asynchronous request &lt;code&gt;free(Ch)&lt;/code&gt; is implemented using &lt;code&gt;gen_server:cast/2&lt;/code&gt;:</source>
          <target state="translated">异步请求 &lt;code&gt;free(Ch)&lt;/code&gt; 使用 &lt;code&gt;gen_server:cast/2&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="13cb8db4869505cfe3b89f4b66cbde4b8e730e2a" translate="yes" xml:space="preserve">
          <source>The asynchronous version of the driver is in the sample files &lt;code&gt;pg_async.c&lt;/code&gt; and &lt;code&gt;pg_asyng.erl&lt;/code&gt;.</source>
          <target state="translated">该驱动程序的异步版本位于示例文件 &lt;code&gt;pg_async.c&lt;/code&gt; 和 &lt;code&gt;pg_asyng.erl&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="95ad31c862f53147c29592fd7356527c9ffced30" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Behaviour&lt;/code&gt; gives the name of the behaviour, which can be a user-defined behaviour or one of the following OTP standard behaviours:</source>
          <target state="translated">&lt;code&gt;Behaviour&lt;/code&gt; 原子给出行为的名称，该行为可以是用户定义的行为或以下OTP标准行为之一：</target>
        </trans-unit>
        <trans-unit id="8b6c48f50dc1798aeaec7a743fffe7be10b28e3a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Name&lt;/code&gt; is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table.</source>
          <target state="translated">原子 &lt;code&gt;Name&lt;/code&gt; 是表名称。必须在表的所有后续操作中提供表名。该名称也可以由其他进程使用，并且许多进程可以共享一个表。</target>
        </trans-unit>
        <trans-unit id="c510ba5b1215726673e2f72d3059e72c9e136b36" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;activity&lt;/code&gt;</source>
          <target state="translated">原子 &lt;code&gt;activity&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9710032c39f79ee3070e26173f96829389498bd7" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;finished&lt;/code&gt; is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;ping finished&quot; is written to the output. &quot;Ping&quot; then terminates as it has nothing left to do.</source>
          <target state="translated">将 &lt;code&gt;finished&lt;/code&gt; 的原子发送到&amp;ldquo; pong&amp;rdquo;（使其如上所述终止），并将&amp;ldquo; ping完成&amp;rdquo;写入输出。然后，&amp;ldquo; Ping&amp;rdquo;将终止，因为它无事可做。</target>
        </trans-unit>
        <trans-unit id="d82cb2c455d0963906d4919213af14bc97a0dc7e" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;hibernate&lt;/code&gt; in the action list on the last line when entering the &lt;code&gt;{open,_}&lt;/code&gt; state is the only change. If any event arrives in the &lt;code&gt;{open,_},&lt;/code&gt; state, we do not bother to rehibernate, so the server stays awake after any event.</source>
          <target state="translated">进入 &lt;code&gt;{open,_}&lt;/code&gt; 状态时，原子在最后一行的动作列表中处于 &lt;code&gt;hibernate&lt;/code&gt; ，这是唯一的更改。如果任何事件到达 &lt;code&gt;{open,_},&lt;/code&gt; 状态，我们都不会费心重新休眠，因此服务器在发生任何事件后都保持唤醒状态。</target>
        </trans-unit>
        <trans-unit id="356f9715c2aad0ed355593e69081e1f8b8476d8f" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending&lt;/code&gt;, which means that a monitor is to be created whenever a load operation is delayed,</source>
          <target state="translated">原子 &lt;code&gt;pending&lt;/code&gt; ，这意味着每当加载操作延迟时都将创建一个监视器，</target>
        </trans-unit>
        <trans-unit id="161e6641a902cec6d4ca9159bb2b569a7ff90c0a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending_driver&lt;/code&gt;, in which a monitor is created whenever the operation is delayed because of open ports to an otherwise unused driver.</source>
          <target state="translated">原子 &lt;code&gt;pending_driver&lt;/code&gt; ，在该操作中，由于打开了通向其他未使用驱动程序的端口而导致操作延迟时，将在其中创建监视器。</target>
        </trans-unit>
        <trans-unit id="4d60a51c643f2a02e17349df9085c521ad7bd0aa" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;system&lt;/code&gt;</source>
          <target state="translated">原子 &lt;code&gt;system&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42969bfd0b03becb2a706b91287d2fd18b7a8038" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">原子 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c920e9113121f0b04e27b3e131485fc54743c" translate="yes" xml:space="preserve">
          <source>The atomicity and the isolation properties of &lt;code&gt;Mnesia&lt;/code&gt; are lost.</source>
          <target state="translated">失去了 &lt;code&gt;Mnesia&lt;/code&gt; 的原子性和隔离特性。</target>
        </trans-unit>
        <trans-unit id="1f8c1bd67e98ea142e16fbd8328c31a4abe8ce1c" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; 和 &lt;code&gt;little&lt;/code&gt; 原子表示大尾数编码。</target>
        </trans-unit>
        <trans-unit id="eec0aca30bfb32af191c5b7f63bda050342a54ff" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;send&lt;/code&gt;, &lt;code&gt;'receive'&lt;/code&gt;, and &lt;code&gt;timeout&lt;/code&gt; for sends and receives (&lt;code&gt;'receive'&lt;/code&gt; when a message is received and &lt;code&gt;timeout&lt;/code&gt; when a receive times out)</source>
          <target state="translated">原子的 &lt;code&gt;send&lt;/code&gt; ， &lt;code&gt;'receive'&lt;/code&gt; 和send和receive的 &lt;code&gt;timeout&lt;/code&gt; （ &lt;code&gt;'receive'&lt;/code&gt; 消息时为&amp;ldquo; receive&amp;rdquo;，而接收 &lt;code&gt;timeout&lt;/code&gt; 时为超时）</target>
        </trans-unit>
        <trans-unit id="d6808e92018a30d64fa086f0dfa84d2f8448d1ef" translate="yes" xml:space="preserve">
          <source>The attribute OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">属性OID名原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="c9f3b18eb4341c86b8c0684826dff3c42219fcc2" translate="yes" xml:space="preserve">
          <source>The author can choose to put many or few tests into each test case. Some things to keep in mind follows:</source>
          <target state="translated">笔者可以选择在每个测试用例中放入很多或很少的测试。以下是一些需要注意的事项。</target>
        </trans-unit>
        <trans-unit id="badc70f1a60a87b4c3438b8a7de6f4c78b5a65bc" translate="yes" xml:space="preserve">
          <source>The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.</source>
          <target state="translated">自动保存的时间间隔。每当在这个时间段内没有被访问时,表就会被刷新到磁盘上。</target>
        </trans-unit>
        <trans-unit id="c039d5fb00e0ef90ed0ae37b0f2d061a360a486a" translate="yes" xml:space="preserve">
          <source>The autostart feature requires more data to be stored on traced nodes. By default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot; in the currect working directory (cwd) of the traced node. Users can change this behaviour (that is, on diskless nodes) by specifying their own module to handle autostart data storage and retrieval (&lt;code&gt;ttb_autostart_module&lt;/code&gt; environment variable of &lt;code&gt;runtime_tools&lt;/code&gt;). For information about the API, see module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;. The following example shows the default handler:</source>
          <target state="translated">自动启动功能要求将更多数据存储在跟踪的节点上。默认情况下，数据自动存储到被跟踪节点当前工作目录（cwd）中名为&amp;ldquo; ttb_autostart.bin&amp;rdquo;的文件中。用户可以通过指定自己的模块来处理自动启动数据的存储和检索（ &lt;code&gt;ttb_autostart_module&lt;/code&gt; 环境变量 &lt;code&gt;runtime_tools&lt;/code&gt; ）来更改此行为（即在无盘节点上）。有关API的信息，请参见模块 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 。以下示例显示了默认处理程序：</target>
        </trans-unit>
        <trans-unit id="ec0674516ee9bb18698545632ddcef7eb77a1e62" translate="yes" xml:space="preserve">
          <source>The available OID names are as follows:</source>
          <target state="translated">可用的OID名称如下:</target>
        </trans-unit>
        <trans-unit id="270053ab9a2cdd71b431ca1b29230d0131168ac8" translate="yes" xml:space="preserve">
          <source>The available configuration options are as follows:</source>
          <target state="translated">可用的配置选项如下:</target>
        </trans-unit>
        <trans-unit id="5ffd517ca47007c093bb8a7cefdb756ebfdced63" translate="yes" xml:space="preserve">
          <source>The available configuration properties are as follows:</source>
          <target state="translated">可用的配置属性如下。</target>
        </trans-unit>
        <trans-unit id="0d5fbe85b0c98fe746cb7e16c8187e2dfc18521e" translate="yes" xml:space="preserve">
          <source>The average run-time for the schedulers. This is the average amount of time the schedulers did not sleep.</source>
          <target state="translated">调度器的平均运行时间。这是调度器不睡觉的平均时间。</target>
        </trans-unit>
        <trans-unit id="aaf853276797e4d431ffd98c86f3b72f5161ab87" translate="yes" xml:space="preserve">
          <source>The average time spent collecting data in the threads. This should be close to the time which data was collected.</source>
          <target state="translated">线程中收集数据的平均时间。该时间应与收集数据的时间接近。</target>
        </trans-unit>
        <trans-unit id="70cab81b62df4bb768ae5b9f87b1769a35f91166" translate="yes" xml:space="preserve">
          <source>The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">反斜杠字符有很多用途。首先,如果它后面的字符不是数字或字母,它就会取消一个字符可能具有的任何特殊意义。反斜线作为转义字符的这种用法在字符类内部和外部都适用。</target>
        </trans-unit>
        <trans-unit id="dbe5fe5807b426b9440606cd7c73c539d1bcdeff" translate="yes" xml:space="preserve">
          <source>The backup data is divided into two sections. The first section contains information related to the schema. All schema-related items are tuples where the first field equals the atom schema. The second section is the record section. Schema records cannot be mixed with other records and all schema records must be located first in the backup.</source>
          <target state="translated">备份数据分为两部分。第一部分包含与模式相关的信息。所有模式相关的项目都是元组,其中第一个字段等于原子模式。第二部分是记录部分。模式记录不能与其他记录混合,所有模式记录必须在备份中首先定位。</target>
        </trans-unit>
        <trans-unit id="5cb61dbbe8949ce8224db389cdf36c3f301c26b1" translate="yes" xml:space="preserve">
          <source>The base AVPs are defined in the common dictionary provided by diameter. There are common dictionaries for both RFC 3588 and RFC 6733 since the latter made changes to both syntax and semantics.</source>
          <target state="translated">基本的AVPs是在直径提供的通用字典中定义的。RFC 3588和RFC 6733都有通用词典,因为后者对语法和语义都做了修改。</target>
        </trans-unit>
        <trans-unit id="37b6dd9b192c11e194c06eb99987679081a97762" translate="yes" xml:space="preserve">
          <source>The base name of the compiled file</source>
          <target state="translated">编译文件的基本名称</target>
        </trans-unit>
        <trans-unit id="d6fbdeb4864f0e11b719e81c27b780c593542153" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt; deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">窗口大小（历史缓冲区的大小）的以2为底的对数。它的范围是8到15。值越大，压缩效果越好，但会占用内存。如果使用 &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt; deflateInit/2&lt;/a&gt;&lt;/code&gt; ,则默认为15 。负的 &lt;code&gt;WindowBits&lt;/code&gt; 值会抑制流中的zlib标头（和校验和）。请注意，zlib源仅将此作为未记录的功能提及。</target>
        </trans-unit>
        <trans-unit id="13db919a8612a7a4080781ff054af866565ed391" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">窗口大小（历史缓冲区的大小）的以2为底的对数。它的范围是8到15。值越大，压缩效果越好，但会占用内存。如果使用 &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; ,则默认为15 。负的 &lt;code&gt;WindowBits&lt;/code&gt; 值会抑制流中的zlib头（和校验和）。请注意，zlib源仅将此作为未记录的功能提及。</target>
        </trans-unit>
        <trans-unit id="8818564f19c5c56bd354986044623c1ba1d3d72f" translate="yes" xml:space="preserve">
          <source>The basic concept is that of a &lt;strong&gt;MIB view&lt;/strong&gt;. An MIB view is a subset of all the objects implemented by an agent. A manager has access to a certain MIB view, depending on which security parameters are used, in which context the request is made, and which type of request is made.</source>
          <target state="translated">基本概念是&lt;strong&gt;MIB视图的&lt;/strong&gt;概念。MIB视图是由代理实现的所有对象的子集。管理员可以访问特定的MIB视图，具体取决于使用了哪些安全参数，在哪种情况下发出请求以及发出了哪种类型的请求。</target>
        </trans-unit>
        <trans-unit id="4956ca9b4e8f3cd207abf9624e243d3cdb794f4d" translate="yes" xml:space="preserve">
          <source>The basic idea of syntax highlighting is to make the structure of a program clearer. For example, the highlighting will make it easier to spot simple bugs. Have not you ever written a variable in lower-case only? With syntax highlighting a variable will colored while atoms will be shown with the normal text color.</source>
          <target state="translated">语法高亮的基本思想是使程序的结构更加清晰。例如,高亮显示会让人更容易发现简单的错误。你难道没有用小写的变量吗?通过语法高亮,一个变量将被着色,而原子将以正常的文本颜色显示。</target>
        </trans-unit>
        <trans-unit id="5ad538ab434ab340ba09c1c90fc3a4a6dea30af6" translate="yes" xml:space="preserve">
          <source>The basic idea with exclusive decode is to specify which parts of the message you want to exclude from being decoded. These parts remain encoded and are returned in the value structure as binaries. They can be decoded in turn by passing them to a certain &lt;code&gt;decode_part/2&lt;/code&gt; function. The performance gain is high for large messages. You can do an exclusive decode and later one or more decodes of the parts, or a second complete decode instead of two or more complete decodes.</source>
          <target state="translated">互斥解码的基本思想是指定要从解码中排除的消息的哪些部分。这些部分保持编码状态，并以二进制形式在值结构中返回。可以通过将它们传递给某个 &lt;code&gt;decode_part/2&lt;/code&gt; 函数来依次对其进行解码。对于大型邮件，性能提高很高。您可以进行独占解码，然后再进行部分的一个或多个解码，或者执行第二次完整解码，而不是两个或多个完整解码。</target>
        </trans-unit>
        <trans-unit id="d34b055b96b341faab090f12091572854579bc39" translate="yes" xml:space="preserve">
          <source>The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with.</source>
          <target state="translated">原协议中的基本思想依然存在。I/O服务器和客户端用一个单一的、相当简单的协议进行通信,客户端中永远没有服务器的状态存在。任何I/O服务器都可以和任何客户端代码一起使用,客户端代码不需要知道I/O服务器与之通信的I/O设备。</target>
        </trans-unit>
        <trans-unit id="06f35fc40ac6c0c6f620803908f2d0ce6893c711" translate="yes" xml:space="preserve">
          <source>The basic message file</source>
          <target state="translated">基本信息文件</target>
        </trans-unit>
        <trans-unit id="7b96cdbd69bdcaed6a11b07691044f3fc504705b" translate="yes" xml:space="preserve">
          <source>The behavior if a file specified in &lt;code&gt;sys.config&lt;/code&gt; does not exist, or is erroneous, is backwards compatible. Starting the runtime system will fail. Installing a new release version will not fail, but an error message is returned and the erroneous file is ignored.</source>
          <target state="translated">如果 &lt;code&gt;sys.config&lt;/code&gt; 中指定的文件不存在或错误，则该行为是向后兼容的。启动运行系统将失败。安装新发行版将不会失败，但是会返回错误消息，并且错误文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="a86acb8a0f20fdc979242a6b86b6e670d328548d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; This is because &lt;code&gt;write&lt;/code&gt; operations on a &lt;code&gt;Mnesia&lt;/code&gt; table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</source>
          <target state="translated">如果在使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; 遍历表时有任何进程在表上执行写操作，则该行为未定义。这是因为对 &lt;code&gt;Mnesia&lt;/code&gt; 表的 &lt;code&gt;write&lt;/code&gt; 操作可能导致表本身的内部重组。这是一个实现细节，但是请记住，脏函数是低级函数。</target>
        </trans-unit>
        <trans-unit id="1a796a85b7d7280f632e4dcbf6b4a44abe35956e" translate="yes" xml:space="preserve">
          <source>The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(*PRUNE:NAME)的行为与(*MARK:NAME)(*PRUNE)不同。它和(*MARK:NAME)一样,名字会被记住以便传回给调用者。然而,(*SKIP:NAME)只搜索用(*MARK)设置的名字。</target>
        </trans-unit>
        <trans-unit id="47227c0747ba0b82f4e36ef4aee5b965307890ad" translate="yes" xml:space="preserve">
          <source>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(*THEN:NAME)的行为与(*MARK:NAME)(*THEN)不同。它和(*MARK:NAME)一样,记住了名字,以便传回给调用者。然而,(*SKIP:NAME)只搜索用(*MARK)设置的名字。</target>
        </trans-unit>
        <trans-unit id="e44b071bcc39a063eb56d16dfbf4c6bb36987d8b" translate="yes" xml:space="preserve">
          <source>The behavior of a socket with this option set to &lt;code&gt;true&lt;/code&gt; is the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of &lt;code&gt;false&lt;/code&gt;. This policy shift among operating systems to separate IPv6 from IPv4 traffic has evolved, as it gradually proved hard and complicated to get a dual stack implementation correct and secure.</source>
          <target state="translated">将此选项设置为 &lt;code&gt;true&lt;/code&gt; 的套接字的行为是唯一可移植的行为。现在，FreeBSD不推荐使用IPv6时使用所有流量的IPv6的原始想法（您可以使用 &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; 来覆盖推荐的系统默认值），OpenBSD禁止（支持的GENERIC内核），并且在Windows（具有单独的IPv4和IPv6协议栈）。大多数Linux发行版的系统默认值仍为 &lt;code&gt;false&lt;/code&gt; 。逐渐改变了操作系统之间从IPv4流量分离IPv6流量的策略，因为逐渐证明，要正确，安全地实现双堆栈实施是困难而复杂的。</target>
        </trans-unit>
        <trans-unit id="1a4c4b510c91839af2b2d840f0dd22a548ca7548" translate="yes" xml:space="preserve">
          <source>The behavior of dot regarding newlines can be changed. If option &lt;code&gt;dotall&lt;/code&gt; is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it.</source>
          <target state="translated">点关于换行符的行为可以更改。如果设置了 &lt;code&gt;dotall&lt;/code&gt; 选项，则点匹配任何字符，无一例外。如果主题字符串中存在两个字符的序列CRLF，则需要两个点来匹配它。</target>
        </trans-unit>
        <trans-unit id="7965ee081ee817356aeac4f791276c29588e7325" translate="yes" xml:space="preserve">
          <source>The behavior of shell escape can be changed by the STDLIB application variable &lt;code&gt;shell_esc&lt;/code&gt;. The value of the variable can be either &lt;code&gt;jcl&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt;) or &lt;code&gt;abort&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt;). The first option sets &lt;code&gt;^G&lt;/code&gt; to activate &lt;code&gt;JCL&lt;/code&gt; mode (which is also default behavior). The latter sets &lt;code&gt;^G&lt;/code&gt; to terminate the current shell and start a new one. &lt;code&gt;JCL&lt;/code&gt; mode cannot be invoked when &lt;code&gt;shell_esc&lt;/code&gt; is set to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">可以通过STDLIB应用程序变量 &lt;code&gt;shell_esc&lt;/code&gt; 更改shell逃逸的行为。变量的值可以是 &lt;code&gt;jcl&lt;/code&gt; （ &lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt; ）或 &lt;code&gt;abort&lt;/code&gt; （ &lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt; ）。第一个选项将 &lt;code&gt;^G&lt;/code&gt; 设置为激活 &lt;code&gt;JCL&lt;/code&gt; 模式（这也是默认行为）。后者将 &lt;code&gt;^G&lt;/code&gt; 设置为终止当前shell并开始新的shell。当 &lt;code&gt;shell_esc&lt;/code&gt; 设置为 &lt;code&gt;abort&lt;/code&gt; 时，无法调用 &lt;code&gt;JCL&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="9f28c17be27978977c1d4772358e7a511e0dfa71" translate="yes" xml:space="preserve">
          <source>The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.</source>
          <target state="translated">下面将介绍这些动词在重复组、断言和被称为子程序的子模式中的行为(无论是否递归)。</target>
        </trans-unit>
        <trans-unit id="b5f409290159e0122d24e0b32bc792ec356f3f9c" translate="yes" xml:space="preserve">
          <source>The behavior of this function changed radically in &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. To keep some backwards compatability, it is still possible to do:</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 1.6.2中，此功能的行为发生了根本性的变化。为了保持一些向后兼容性，仍然可以这样做：</target>
        </trans-unit>
        <trans-unit id="3cecdaf7589f62bdef0c740b1516c756288d9c79" translate="yes" xml:space="preserve">
          <source>The behavior of this function is undefined if the table is written on while being traversed. The function &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to ensure that no transaction-protected writes are performed during the iteration.</source>
          <target state="translated">如果在遍历表时将其写入，则此函数的行为是不确定的。函数 &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; 可用于确保在迭代过程中不执行受事务保护的写操作。</target>
        </trans-unit>
        <trans-unit id="0ad444f7fffcddf3e1072340ed21b0cb1ac9f4b6" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of posponed messages and other metadata. It receives all process messages, handles the system messages, and calls the callback module with machine specific events.</source>
          <target state="translated">行为引擎持有状态机状态、服务器数据、定时器引用、posponed消息队列和其他元数据。它接收所有的进程消息,处理系统消息,并调用回调模块与机器特定事件。</target>
        </trans-unit>
        <trans-unit id="81091c06f62b758fa79bf459317221a8b60aa4f7" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of postponed messages and other metadata. It receives all process messages, handles the system messages, and calls the &lt;strong&gt;callback module&lt;/strong&gt; with machine specific events.</source>
          <target state="translated">行为引擎保存状态机状态，服务器数据，计时器引用，延迟的消息队列和其他元数据。它接收所有进程消息，处理系统消息，并使用计算机特定事件调用&lt;strong&gt;回调模块&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0880fce4c0b15834624e11a3dadca1d45ea29226" translate="yes" xml:space="preserve">
          <source>The behaviour module is part of Erlang/OTP. To implement a process such as a supervisor, the user only has to implement the callback module which is to export a pre-defined set of functions, the &lt;strong&gt;callback functions&lt;/strong&gt;.</source>
          <target state="translated">行为模块是Erlang / OTP的一部分。为了实现诸如主管的过程，用户仅需实现回调模块，该模块将导出一组预定义的函数，即&lt;strong&gt;回调函数&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f7f12a9631818d9d069082f70af478c5b6e70157" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="translated">基准测试是在一台相对较新的机器上运行的,该机器采用英特尔i7四核处理器,超线程使用8个调度器。</target>
        </trans-unit>
        <trans-unit id="f62e2973e3a88e1a9aafc89e21ac3f85591af54e" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers. On a machine with more communication overhead and/or larger amount of logical processors the speedups are expected to be even larger.</source>
          <target state="translated">基准测试在一台相对较新的机器上运行,该机器采用英特尔i7四核处理器,使用8个调度器进行超线程处理。在具有更多通信开销和/或更多逻辑处理器的机器上,预计速度会更快。</target>
        </trans-unit>
        <trans-unit id="59e8c63ca2b59778b1c251bfe4d9af4a1c121cce" translate="yes" xml:space="preserve">
          <source>The benefit of this is that Megaco handles the starting, holding and the supervision of the driver and port.</source>
          <target state="translated">这样做的好处是,Megaco负责司机和港口的启动、保持和监督。</target>
        </trans-unit>
        <trans-unit id="1929daa6d9f07ef87baa0d2108c05731636b180d" translate="yes" xml:space="preserve">
          <source>The best place is in the &lt;code&gt;sys.config&lt;/code&gt; system configuration file of the release.</source>
          <target state="translated">最佳位置是该版本的 &lt;code&gt;sys.config&lt;/code&gt; 系统配置文件。</target>
        </trans-unit>
        <trans-unit id="d72c83f4147d145bc84c3d37b05a70b520d273ab" translate="yes" xml:space="preserve">
          <source>The binaries do not contain whole bytes (bit strings).</source>
          <target state="translated">二进制文件不包含整个字节(位串)。</target>
        </trans-unit>
        <trans-unit id="2c99eedcea168087b25493bcc8656037a8c03177" translate="yes" xml:space="preserve">
          <source>The binary boot script file &lt;code&gt;Name.boot&lt;/code&gt; is generated from the boot script file &lt;code&gt;Name.script&lt;/code&gt;, using the function &lt;code&gt;systools:script2boot(File)&lt;/code&gt;.</source>
          <target state="translated">二进制的启动脚本文件 &lt;code&gt;Name.boot&lt;/code&gt; 从启动脚本文件中生成 &lt;code&gt;Name.script&lt;/code&gt; ，使用功能 &lt;code&gt;systools:script2boot(File)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c63a3b170852a27feb1e79f6999b69d62a7625a7" translate="yes" xml:space="preserve">
          <source>The binary boot script renamed to &lt;code&gt;start.boot&lt;/code&gt;</source>
          <target state="translated">二进制启动脚本已重命名为 &lt;code&gt;start.boot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdaeab197086e91b2d818626cc54633ed2fa6700" translate="yes" xml:space="preserve">
          <source>The binary executable file must be owned by root, have &lt;code&gt;rwsr-xr-x&lt;/code&gt; file privileges, in particular the &lt;code&gt;setuid&lt;/code&gt; bit of the user must be set.</source>
          <target state="translated">二进制可执行文件必须由root拥有，并具有 &lt;code&gt;rwsr-xr-x&lt;/code&gt; 文件特权，尤其是必须设置用户的 &lt;code&gt;setuid&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="9f05ddacf84bb36fa321e41835d584b6e76e30a8" translate="yes" xml:space="preserve">
          <source>The binary heap works as a large object space for binary terms that are greater than 64 bytes (from now on called off-heap binaries). The binary heap is &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counted&lt;/a&gt;&lt;/code&gt; and a pointer to the off-heap binary is stored on the process heap. To keep track of when to decrement the reference counter of the off-heap binary, a linked list (the MSO - mark and sweep object list) containing funs and externals as well as off-heap binaries is woven through the heap. After a garbage collection is done, the &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299&quot;&gt;MSO list is swept&lt;/a&gt;&lt;/code&gt; and any off-heap binary that does not have a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; written into the header words has its reference &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367&quot;&gt;decremented and is potentially freed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于大于64个字节的二进制项（从现在起称为堆外二进制文件），二进制堆充当较大的对象空间。二进制堆被 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counted&lt;/a&gt;&lt;/code&gt; 并且指向堆外二进制文件的指针存储在进程堆中。为了跟踪何时减少堆外二进制文件的引用计数器，通过堆编织了一个包含乐趣和外部因素以及堆外二进制文件的链接列表（MSO-标记和清除对象列表）。垃圾收集完成后， &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299&quot;&gt;MSO list is swept&lt;/a&gt;&lt;/code&gt; ，所有未在标头字中写入 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; 的堆外二进制文件的引用将 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367&quot;&gt;decremented and is potentially freed&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00fa7003833fa581d83179258571e8a367f39ad2" translate="yes" xml:space="preserve">
          <source>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</source>
          <target state="translated">二进制对象可以被任意数量的ProcBins从任意数量的进程中引用。该对象包含一个引用计数器,用于跟踪引用次数,以便在最后一个引用消失时将其删除。</target>
        </trans-unit>
        <trans-unit id="127151f66b51ac3efe997eb464906c3d0948c0d1" translate="yes" xml:space="preserve">
          <source>The binary object itself, stored outside all process heaps</source>
          <target state="translated">二进制对象本身,存储在所有进程堆之外。</target>
        </trans-unit>
        <trans-unit id="4cf0fde8a2120eccfe9fdc8a249b8de5265ff4ee" translate="yes" xml:space="preserve">
          <source>The binary output file produced by the compiler is read by the agent at MIB load time (see the figure &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt;). The instrumentation is ordinary Erlang code which is loaded explicitly or automatically the first time it is called.</source>
          <target state="translated">代理在MIB加载时读取编译器生成的二进制输出文件（请参见 &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt; ）。该工具是普通的Erlang代码，它将在第一次调用时显式或自动加载。</target>
        </trans-unit>
        <trans-unit id="d082c75a002a09432e39d447b940479e08b9f5e4" translate="yes" xml:space="preserve">
          <source>The bit syntax contains types for handling binary data in the three main encodings. The types are named &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;. The &lt;code&gt;utf16&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; types can be in a big-endian or a little-endian variant:</source>
          <target state="translated">位语法包含三种主要编码中用于处理二进制数据的类型。这些类型分别命名为 &lt;code&gt;utf8&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 。在 &lt;code&gt;utf16&lt;/code&gt; 和 &lt;code&gt;utf32&lt;/code&gt; 类型可以是大端或小端的变体：</target>
        </trans-unit>
        <trans-unit id="7305cb0adee2541b623171c05bf3f3d1ecacd9f6" translate="yes" xml:space="preserve">
          <source>The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;bindings&lt;/code&gt; (see further down), which returns the whole matched object and all known variable bindings, respectively.</source>
          <target state="translated">乐趣的主体用于构造结果值。从表中选择时，通常在这里使用普通的Erlang术语构造来构造一个合适的术语，例如元组括号，列表括号和头部匹配的变量，可能带有偶然的常量。这里也允许使用守卫中允许的任何表达式，但是除 &lt;code&gt;object&lt;/code&gt; 和 &lt;code&gt;bindings&lt;/code&gt; （请参见下文）外，不存在任何特殊功能，它们分别返回整个匹配的对象和所有已知的变量绑定。</target>
        </trans-unit>
        <trans-unit id="e9fdf4a0d35c62b0782bd25eb4544517276991d8" translate="yes" xml:space="preserve">
          <source>The boolean value true specifies that the server will agree to reuse sessions. Setting it to false will result in an empty session table, that is no sessions will be reused. See also option &lt;code&gt;&lt;a href=&quot;#type-server_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">布尔值true指定服务器将同意重用会话。将其设置为false将导致会话表为空，即不会重用任何会话。另请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-server_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ca0de7223fe258efb581336c1e0197d5d0edd2" translate="yes" xml:space="preserve">
          <source>The boot script included in a release package must be generated from the same &lt;code&gt;.rel&lt;/code&gt; file as the release package itself.</source>
          <target state="translated">发行包中包含的引导脚本必须与发行包本身使用相同的 &lt;code&gt;.rel&lt;/code&gt; 文件生成。</target>
        </trans-unit>
        <trans-unit id="ddcf162c693f295280c787fbd8290adee7c45ca3" translate="yes" xml:space="preserve">
          <source>The boot script is stored in a file with extension &lt;code&gt;.script&lt;/code&gt;. The file has the following syntax:</source>
          <target state="translated">引导脚本存储在扩展名为 &lt;code&gt;.script&lt;/code&gt; 的文件中。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="41a09207a22769c0574e34261e0d72dca94a1cd1" translate="yes" xml:space="preserve">
          <source>The branches of an &lt;code&gt;if&lt;/code&gt;-expression are scanned sequentially until a guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; that evaluates to true is found. Then the corresponding &lt;code&gt;Body&lt;/code&gt; (sequence of expressions separated by ',') is evaluated.</source>
          <target state="translated">一个的分支 &lt;code&gt;if&lt;/code&gt; -expression被顺序地扫描，直到保护序列 &lt;code&gt;GuardSeq&lt;/code&gt; 计算结果为true被发现。然后评估相应的 &lt;code&gt;Body&lt;/code&gt; （用&amp;ldquo;，&amp;rdquo;分隔的表达式序列）。</target>
        </trans-unit>
        <trans-unit id="c635f7fb465fc59e43a777e3d06741481d050b03" translate="yes" xml:space="preserve">
          <source>The browser must run as a separate OS process, otherwise VTS hangs.</source>
          <target state="translated">浏览器必须作为一个单独的操作系统进程运行,否则VTS会挂起。</target>
        </trans-unit>
        <trans-unit id="1acf68389c692a738d63487b4a06a4e7162935c1" translate="yes" xml:space="preserve">
          <source>The buffer pointed to by &lt;code&gt;v&lt;/code&gt; must be large enough to hold the return data, that is, it must be a pointer to one of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt;, or &lt;code&gt;void*&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 指向的缓冲区必须足够大以容纳返回数据，也就是说，它必须是分别指向 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;char*&lt;/code&gt; 或 &lt;code&gt;void*&lt;/code&gt; 之一的指针。</target>
        </trans-unit>
        <trans-unit id="eaa6a3f621852e6e7b5c05f1f4dfe807f43eee5b" translate="yes" xml:space="preserve">
          <source>The build system, including cross compilation configuration variables used, may be subject to non backward compatible changes without prior notice. Current cross build system has been tested when cross compiling some Linux/GNU systems, but has only been partly tested for more esoteric platforms. The VxWorks example file is highly dependent on our environment and is here more or less only for internal use.</source>
          <target state="translated">构建系统,包括所使用的交叉编译配置变量,可能会在没有事先通知的情况下发生非向后兼容的变化。目前的交叉编译系统已经在交叉编译一些Linux/GNU系统时进行了测试,但只在更深奥的平台上进行了部分测试。VxWorks 示例文件高度依赖于我们的环境,这里或多或少只供内部使用。</target>
        </trans-unit>
        <trans-unit id="6fef17f4398287d703d6c8738ea77d284a4abce3" translate="yes" xml:space="preserve">
          <source>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like &lt;code&gt;crypto:rand_seed/0&lt;/code&gt;.</source>
          <target state="translated">内置的随机数生成器算法在密码学上不强。如果需要加密强度高的随机数生成器，请使用诸如 &lt;code&gt;crypto:rand_seed/0&lt;/code&gt; 之类的东西。</target>
        </trans-unit>
        <trans-unit id="067acc920ec0fee7fa628aac8051ca95ed671e0c" translate="yes" xml:space="preserve">
          <source>The busy message queue feature can be disabled either by setting the &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver, or by calling this function with &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; as a limit (either low or high). When this feature has been disabled, it cannot be enabled again. When reading the limits, both are &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; if this feature has been disabled.</source>
          <target state="translated">忙消息队列功能可以被禁用或者通过设置 &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 由驾驶员使用，或者通过调用此函数 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 作为极限（低或高）。禁用此功能后，将无法再次启用它。读取限制时，如果已禁用此功能，则两者均为 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33650cf8255f90c21ac81005064a8fbf5483e732" translate="yes" xml:space="preserve">
          <source>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</source>
          <target state="translated">该按钮将带您进入代码覆盖率概览页面。如果您已成功地执行了详细的覆盖率分析,则可在此找到每个模块覆盖率页面的链接。</target>
        </trans-unit>
        <trans-unit id="709ea736382b67af3f9c144683016c97550b6e99" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a code point in the invalid Unicode range.</source>
          <target state="translated">字节被解码为无效Unicode范围内的一个码点。</target>
        </trans-unit>
        <trans-unit id="276396b4a984d3ef578929de68a65d7f15a4afbf" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a too large number.</source>
          <target state="translated">字节被解码成过大的数字。</target>
        </trans-unit>
        <trans-unit id="9be93d248e619868f8b04b5a5303526269804682" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt; crypto app's &lt;/code&gt; 配置参数 &lt;code&gt;rand_cache_size&lt;/code&gt; 将缓存大小从其默认值更改。</target>
        </trans-unit>
        <trans-unit id="953ab7ba3d595c2a841438d3ab4f4c182fb2eff6" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt;crypto app's&lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;crypto app's&lt;/code&gt; 配置参数 &lt;code&gt;rand_cache_size&lt;/code&gt; 将缓存大小从其默认值更改。</target>
        </trans-unit>
        <trans-unit id="bba971c6589524e2b87b07ee118d11ab2b5ec5e2" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:call(Node, Module, Function, Args, infinity)&lt;/code&gt;</source>
          <target state="translated">调用 &lt;code&gt;erpc:call(Node, Module, Function, Args)&lt;/code&gt; 等效于调用 &lt;code&gt;erpc:call(Node, Module, Function, Args, infinity)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ca6b0dafdc23056fe13a565a84397b1490c9ec" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:call(Node,Fun,infinity)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erpc:call(Node,Fun)&lt;/code&gt; 与调用 &lt;code&gt;erpc:call(Node,Fun,infinity)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="e5af71d5240d81c230e56c0fedb791afdbf3e003" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt;. These calls are also equivalent to calling &lt;code&gt;my_multicall(Nodes, Module, Function, Args)&lt;/code&gt; if one disregard performance and failure behavior:</source>
          <target state="translated">调用 &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args)&lt;/code&gt; 等效于调用 &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt; 。如果一个人忽略了性能和故障行为 &lt;code&gt;my_multicall(Nodes, Module, Function, Args)&lt;/code&gt; 这些调用也等效于调用my_multicall（Nodes，Module，Function，Args）：</target>
        </trans-unit>
        <trans-unit id="79b9b9d99c8ecce8485a4983dcd83e4894a6b989" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:multicall(Nodes,Fun, infinity)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erpc:multicall(Nodes,Fun)&lt;/code&gt; 与调用 &lt;code&gt;erpc:multicall(Nodes,Fun, infinity)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27d0b458c6aae29c39ad3c25a6af2742eb4013be" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:receive_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:receive_response(RequestId, infinity)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erpc:receive_response(RequestId)&lt;/code&gt; 等效于调用 &lt;code&gt;erpc:receive_response(RequestId, infinity)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a152c6617bd51e1fb2b711ebf4373faae6094d4" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:wait_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:wait_response(RequestId, 0)&lt;/code&gt;. That is, poll for a response message to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process.</source>
          <target state="translated">调用 &lt;code&gt;erpc:wait_response(RequestId)&lt;/code&gt; 等效于调用 &lt;code&gt;erpc:wait_response(RequestId, 0)&lt;/code&gt; 。即，轮询对先前由呼叫过程发出的 &lt;code&gt;call&lt;/code&gt; 请求的响应消息。</target>
        </trans-unit>
        <trans-unit id="49f53eb411418a4e5fc2e2575c742546457d6c88" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_event:call(EventMgrRef,Handler,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">可以将调用 &lt;code&gt;gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout)&lt;/code&gt; 等效为 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_event:call(EventMgrRef,Handler,Request,Timeout)&lt;/a&gt;&lt;/code&gt; ，而忽略错误处理。</target>
        </trans-unit>
        <trans-unit id="1d937cd40cd03a99573acdf02ba260b024e4d3ab" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_server:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">可以将调用 &lt;code&gt;gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout)&lt;/code&gt; 等效为 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_server:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt; ，而忽略错误处理。</target>
        </trans-unit>
        <trans-unit id="cff8030a297aeb35ab5d6884ca11e4edf2e73f36" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_statem:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">可以将调用 &lt;code&gt;gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)&lt;/code&gt; 等效为 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_statem:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt; ，而忽略错误处理。</target>
        </trans-unit>
        <trans-unit id="2e019f9fcd17a687470aea637478863f5e134cb3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;module_info(Key)&lt;/code&gt;, where &lt;code&gt;Key&lt;/code&gt; is an atom, returns a single piece of information about the module.</source>
          <target state="translated">调用 &lt;code&gt;module_info(Key)&lt;/code&gt; （其中 &lt;code&gt;Key&lt;/code&gt; 是原子）返回有关模块的单条信息。</target>
        </trans-unit>
        <trans-unit id="a72f41bd0ef1a660b71b19854f4a2f611d367c22" translate="yes" xml:space="preserve">
          <source>The call can also fail, for example, if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">例如，如果 &lt;code&gt;gen_statem&lt;/code&gt; 在此函数调用之前或过程中死亡，则调用也可能失败。</target>
        </trans-unit>
        <trans-unit id="8367b12b1eaff6fc40fd96b320d7987c710ba242" translate="yes" xml:space="preserve">
          <source>The call can fail for many reasons, including time-out and the called &lt;code&gt;gen_server&lt;/code&gt; process dying before or during the call.</source>
          <target state="translated">调用可能会由于许多原因而失败，包括超时和调用之前或调用过程中 &lt;code&gt;gen_server&lt;/code&gt; 进程死掉。</target>
        </trans-unit>
        <trans-unit id="4739e34ca18c32d95d687955ecad4a46982e910c" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are paused at their current count.</source>
          <target state="translated">所有匹配的函数,如果有调用计数断点,其调用计数将暂停在当前计数。</target>
        </trans-unit>
        <trans-unit id="52c5d88794b3b9c10b033bc03376b7dc1bc55692" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are set to zero and running.</source>
          <target state="translated">所有匹配的函数的调用计数断点都被设置为零并运行。</target>
        </trans-unit>
        <trans-unit id="fcd429bca91d28345133d5ddfc12f2039568c7e0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">呼叫失败，出现 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常，如果 &lt;code&gt;Map1&lt;/code&gt; 不是地图，或用 &lt;code&gt;{badkey,Key}&lt;/code&gt; 异常，如果没有值与相关 &lt;code&gt;Key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a765e0cc7b8afeedc4b406e029455c41a2e05717" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">呼叫失败，出现 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常，如果 &lt;code&gt;Map1&lt;/code&gt; 不是地图。</target>
        </trans-unit>
        <trans-unit id="3bcc437b0d2af2e5401d95afab2b22b04d0cd309" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; or &lt;code&gt;Map2&lt;/code&gt; is not a map.</source>
          <target state="translated">呼叫失败，出现 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常，如果 &lt;code&gt;Map1&lt;/code&gt; 或 &lt;code&gt;Map2&lt;/code&gt; 是不是一张地图。</target>
        </trans-unit>
        <trans-unit id="e5f8317a62b38be81b80524eaf41aa4ccce539a0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">呼叫失败，出现 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常，如果 &lt;code&gt;Map&lt;/code&gt; 是不是地图，或用 &lt;code&gt;{badkey,Key}&lt;/code&gt; 异常，如果没有值与相关 &lt;code&gt;Key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3d448e3253ce8fb6ba525c95cf4c520a4dd69a" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map.</source>
          <target state="translated">如果 &lt;code&gt;Map&lt;/code&gt; 不是地图，则调用失败，并 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="16f4ecacaaaef2b7ebc1761887fc6a38ffe0b906" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">如果 &lt;code&gt;MapOrIter&lt;/code&gt; 不是地图或有效的迭代器，则调用将失败，并返回 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常 &lt;code&gt;badarg&lt;/code&gt; 如果 &lt;code&gt;Fun&lt;/code&gt; 不是Arity 2的函数，则调用将导致badarg失败。</target>
        </trans-unit>
        <trans-unit id="12f759a8b6547e05c46e411430a759d92783001f" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 3.</source>
          <target state="translated">如果 &lt;code&gt;MapOrIter&lt;/code&gt; 不是地图或有效的迭代器，则调用将失败并返回 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常，如果 &lt;code&gt;Fun&lt;/code&gt; 不是 &lt;code&gt;badarg&lt;/code&gt; 3的函数，则调用将导致badarg失败。</target>
        </trans-unit>
        <trans-unit id="ac940292242acb2f76654b1a0d7f61a1dafc1f65" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pred&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">如果 &lt;code&gt;MapOrIter&lt;/code&gt; 不是地图或有效的迭代器，则调用将失败，并返回 &lt;code&gt;{badmap,Map}&lt;/code&gt; 异常 &lt;code&gt;badarg&lt;/code&gt; 如果 &lt;code&gt;Pred&lt;/code&gt; 不是Arity 2的函数，则调用将导致badarg失败。</target>
        </trans-unit>
        <trans-unit id="2892cf3454075f0053d7bd91a8d8a1dd21669320" translate="yes" xml:space="preserve">
          <source>The call format may be different if a customized prologue file has been included when generating the parser instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt;.</source>
          <target state="translated">如果在生成解析器时包括定制的序言文件而不是默认文件 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; ，则调用格式可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="2e8198892cee32a7b8526bf6bc65cdd83e83fc69" translate="yes" xml:space="preserve">
          <source>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</source>
          <target state="translated">调用给出如下结果,因为第一个显式捕获的子模式是&quot;(abcd)&quot;,与主题中的 &quot;abcd &quot;相匹配,在(零基)位置3,长度为4。</target>
        </trans-unit>
        <trans-unit id="daf666a091f35efff4124fee9f5b0c58cdf83623" translate="yes" xml:space="preserve">
          <source>The call is wrapped in a case statement and will be evaluated only if &lt;code&gt;Level&lt;/code&gt; is equal to or below the configured log level.</source>
          <target state="translated">该调用被包装在case语句中，并且仅在 &lt;code&gt;Level&lt;/code&gt; 等于或低于配置的日志级别时才会被评估。</target>
        </trans-unit>
        <trans-unit id="de78c6fd6e7546e57186f359788dd6c58cc04ff8" translate="yes" xml:space="preserve">
          <source>The call of this function will trigger the callback function UserMod:handle_connect/2 to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">这个函数的调用将触发回调函数UserMod:handle_connect/2被调用。更多关于回调参数的信息请参见megaco_user模块。</target>
        </trans-unit>
        <trans-unit id="f6eff7cd52eb9afdfc9d628f7416b2b3d981918c" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;io:format/2&lt;/code&gt; will never be executed, but a return address will still be pushed to the stack each time &lt;code&gt;loop/0&lt;/code&gt; is called recursively. The correct tail-recursive version of the function looks as follows:</source>
          <target state="translated">永远不会执行对 &lt;code&gt;io:format/2&lt;/code&gt; 的调用，但是每次递归调用 &lt;code&gt;loop/0&lt;/code&gt; 时，返回地址仍将被压入堆栈。该函数的正确尾递归版本如下所示：</target>
        </trans-unit>
        <trans-unit id="69e4234e48da562de4b3fe66e96e15cc38ad9a57" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; must be made &lt;strong&gt;directly&lt;/strong&gt; from the Erlang code of the module that the NIF library belongs to. It returns either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; if loading fails. &lt;code&gt;Reason&lt;/code&gt; is one of the following atoms while &lt;code&gt;Text&lt;/code&gt; is a human readable string that can give more information about the failure:</source>
          <target state="translated">必须&lt;strong&gt;直接&lt;/strong&gt;从NIF库所属的模块的Erlang代码进行对 &lt;code&gt;load_nif/2&lt;/code&gt; 的调用。如果加载失败，则返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; 。 &lt;code&gt;Reason&lt;/code&gt; 是以下原子之一，而 &lt;code&gt;Text&lt;/code&gt; 是人类可读的字符串，可以提供有关失败的更多信息：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65c74848bb8184c1160ce5aeb1b1f12389a01cd3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; was made from the old code of a module that has been upgraded; this is not allowed.</source>
          <target state="translated">对 &lt;code&gt;load_nif/2&lt;/code&gt; 的调用是从已升级模块的旧代码进行的。这是不允许的。</target>
        </trans-unit>
        <trans-unit id="9645f8ce41967acca4649554ceab30271d3386df" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;return_trace&lt;/code&gt; results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a &lt;code&gt;dbg&lt;/code&gt; match specification.</source>
          <target state="translated">函数返回时，对 &lt;code&gt;return_trace&lt;/code&gt; 的调用将导致跟踪消息。它仅适用于触发匹配规范的特定函数调用（并匹配匹配规范的开头/结尾）。到目前为止，这是 &lt;code&gt;dbg&lt;/code&gt; 匹配规范正文中最常见的调用。</target>
        </trans-unit>
        <trans-unit id="92d19c83ca0b80ba803b67a868b3108e7fb7711b" translate="yes" xml:space="preserve">
          <source>The call to the analyze function must be as follows:</source>
          <target state="translated">对 analyze 函数的调用必须如下。</target>
        </trans-unit>
        <trans-unit id="55e6d7779dabe02d283cfb249b485592e929b71e" translate="yes" xml:space="preserve">
          <source>The call will fail with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">此次电话会议将失败，并 &lt;code&gt;{badmap,Map}&lt;/code&gt; 如果异常 &lt;code&gt;Map1&lt;/code&gt; 不是地图。</target>
        </trans-unit>
        <trans-unit id="fa1f952e3b1c0797c615bedda4b65ed54a10a69e" translate="yes" xml:space="preserve">
          <source>The call will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the check. The caller do not need to handle the matching rules in the rfc. The matching will proceed as:</source>
          <target state="translated">呼叫将根据检查结果返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。调用方不需要处理rfc中的匹配规则。匹配将按以下步骤进行：</target>
        </trans-unit>
        <trans-unit id="104de9fe47518d4f0de85d87c6a5c1db2f88d084" translate="yes" xml:space="preserve">
          <source>The call:</source>
          <target state="translated">呼叫。</target>
        </trans-unit>
        <trans-unit id="1514747db293879c8ce291ed88a8dae74c64014f" translate="yes" xml:space="preserve">
          <source>The callback function UserMod:handle_trans_reply/4 is invoked when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">回调函数UserMod:handle_trans_reply/4在回复到达时、请求计时器最终超时或未完成的请求被显式取消时被调用。关于回调参数的更多信息,请参见megaco_user模块。</target>
        </trans-unit>
        <trans-unit id="e40447571e80d72283361f5ca0d8dcdb93fefaa2" translate="yes" xml:space="preserve">
          <source>The callback function handling the &lt;code&gt;stop&lt;/code&gt; request returns a tuple &lt;code&gt;{stop,normal,State1}&lt;/code&gt;, where &lt;code&gt;normal&lt;/code&gt; specifies that it is a normal termination and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;. This causes the &lt;code&gt;gen_server&lt;/code&gt; to call &lt;code&gt;terminate(normal, State1)&lt;/code&gt; and then it terminates gracefully.</source>
          <target state="translated">处理 &lt;code&gt;stop&lt;/code&gt; 请求的回调函数返回一个元组 &lt;code&gt;{stop,normal,State1}&lt;/code&gt; ，其中 &lt;code&gt;normal&lt;/code&gt; 指定它是正常终止，而 &lt;code&gt;State1&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 状态的新值。这将导致 &lt;code&gt;gen_server&lt;/code&gt; 调用 &lt;code&gt;terminate(normal, State1)&lt;/code&gt; ，然后正常终止。</target>
        </trans-unit>
        <trans-unit id="728b1d3be49a797310af6aa94681789dfdda4be1" translate="yes" xml:space="preserve">
          <source>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</source>
          <target state="translated">回调函数在中止文件传输后会清理其使用过的资源,如关闭打开的文件描述符等。如果任何其他回调函数返回错误,该函数不会被调用,因为预计它们已经清理了必要的资源。但是,如果函数失败(崩溃),则会被调用。</target>
        </trans-unit>
        <trans-unit id="109919e956ac7fc9c9c7ca8c3328e95855910a87" translate="yes" xml:space="preserve">
          <source>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</source>
          <target state="translated">当遇到最后一个文件块时,回调函数要关闭文件。当遇到错误时,回调函数要在文件传输中止后进行清理,如关闭打开的文件描述符等。在这两种情况下,将不会再调用任何一个回调函数。</target>
        </trans-unit>
        <trans-unit id="84bacd9fc6215821a0c57cf0a99b64819b895b8b" translate="yes" xml:space="preserve">
          <source>The callback function is to be defined as follows:</source>
          <target state="translated">回调函数的定义如下。</target>
        </trans-unit>
        <trans-unit id="898a8e55f83f4732a3d9a1c55861f5556e256a82" translate="yes" xml:space="preserve">
          <source>The callback function itself did the updates.</source>
          <target state="translated">回调函数自己做了更新。</target>
        </trans-unit>
        <trans-unit id="1d90b6e19e5f31bc52641082a2d815396c2a8af1" translate="yes" xml:space="preserve">
          <source>The callback function to use. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms and &lt;code&gt;Args&lt;/code&gt; is a list of terms. When an OS message &lt;code&gt;Msg&lt;/code&gt; is received, this function is called as &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt;.</source>
          <target state="translated">要使用的回调函数。 &lt;code&gt;Module&lt;/code&gt; 和 &lt;code&gt;Function&lt;/code&gt; 是原子， &lt;code&gt;Args&lt;/code&gt; 是术语列表。收到OS消息 &lt;code&gt;Msg&lt;/code&gt; 时，此函数称为 &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf66fa0dd7df5d0912660af5ccc84e8028f914a6" translate="yes" xml:space="preserve">
          <source>The callback function works as described in &lt;code&gt;os_sup(3)&lt;/code&gt;.</source>
          <target state="translated">回调函数如 &lt;code&gt;os_sup(3)&lt;/code&gt; 中所述工作。</target>
        </trans-unit>
        <trans-unit id="1ea45999ad4acd01ff35ccee071d905b456a15b2" translate="yes" xml:space="preserve">
          <source>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</source>
          <target state="translated">回调函数不能用于允许或禁止执行从编译代码中调用的函数(只能执行从shell提示符下输入的表达式中调用的函数)。</target>
        </trans-unit>
        <trans-unit id="96dd8e426598dea1368d28980aebceed3f1b20a0" translate="yes" xml:space="preserve">
          <source>The callback functions of the module can be specified either directly by the exported function &lt;code&gt;behaviour_info/1&lt;/code&gt;:</source>
          <target state="translated">可以通过导出的函数 &lt;code&gt;behaviour_info/1&lt;/code&gt; 直接指定模块的回调函数：</target>
        </trans-unit>
        <trans-unit id="4c0541a4b27e58b4de7bee93e3d77a109876a92d" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test &lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">测试套件要实现的回调函数都在 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test &lt;/a&gt;&lt;/code&gt; 模块中列出。稍后在本《用户指南》中也会对它们进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="54dd23c9ceb4245139e54c85cd25b72ecec0fba9" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">测试套件要实现的回调函数都在 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 模块中列出。稍后在本《用户指南》中也会对它们进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="85791b6dc548416b6612b724000cfadda018f22a" translate="yes" xml:space="preserve">
          <source>The callback interface is based on that the user sends a fun with the correct signature to the parser.</source>
          <target state="translated">回调接口是基于用户发送一个带有正确签名的fun给解析器。</target>
        </trans-unit>
        <trans-unit id="59e965f4c45d1fd48637f0634a7fe7cb62c0c3bd" translate="yes" xml:space="preserve">
          <source>The callback interface of the transport module contains several functions. Some of which are mandatory while others are only optional:</source>
          <target state="translated">传输模块的回调接口包含几个函数。其中一些函数是强制性的,而另一些则是可选的。</target>
        </trans-unit>
        <trans-unit id="cd251fb009bc0977864cd404e86e72a74db2ce5c" translate="yes" xml:space="preserve">
          <source>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">该回调由中间人进程进行，因此文件传输不受进度回调函数中的代码影响。如果回调崩溃，则FTP连接进程会检测到该回调，然后打印一个信息报告，并继续进行，就像将progress选项设置为 &lt;code&gt;ignore&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="e8e4051d9662c60ffac0c38b92a0a52ef07de6ce" translate="yes" xml:space="preserve">
          <source>The callback mode &lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">回调模式 &lt;code&gt;handle_event_function&lt;/code&gt; 允许使用非原子状态，如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 部分所述，例如，复杂的状态项（如元组）。</target>
        </trans-unit>
        <trans-unit id="b9074f752748f19027b380bf6c6083917557b4d1" translate="yes" xml:space="preserve">
          <source>The callback mode is selected at server start and may be changed with a code upgrade/downgrade.</source>
          <target state="translated">回调模式是在服务器启动时选择的,可以通过代码升级/降级来改变。</target>
        </trans-unit>
        <trans-unit id="a1b667b206213a5b84a8db86f75c2c72599f104c" translate="yes" xml:space="preserve">
          <source>The callback mode is selected by implementing a mandatory callback function &lt;code&gt;Module:callback_mode()&lt;/code&gt; that returns one of the callback modes.</source>
          <target state="translated">通过实现强制性的回调函数 &lt;code&gt;Module:callback_mode()&lt;/code&gt; 来选择回调模式，该函数将返回一种回调模式。</target>
        </trans-unit>
        <trans-unit id="1bae742a256a71cd7955e770e21832abee7463ec" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt; rewrite from &lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 的回调模型与 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 的回调模型不同，但是 &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt; rewrite from &lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; 重写为 &lt;code&gt;gen_statem&lt;/code&gt; 仍然很容易。</target>
        </trans-unit>
        <trans-unit id="ead6e2ff311fd428d1dc6968b3919ecff631ec58" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 的回调模型与 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 的回调模型不同，但是 &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; 重写为 &lt;code&gt;gen_statem&lt;/code&gt; 仍然很容易。</target>
        </trans-unit>
        <trans-unit id="7fd40cbe96a6a7878da940a8badb97c6c9caeb25" translate="yes" xml:space="preserve">
          <source>The callback module contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the callback module with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">回调模块包含实现状态机的功能。发生事件时， &lt;code&gt;gen_statem&lt;/code&gt; 行为引擎会使用事件，当前状态和服务器数据在回调模块中调用一个函数。此函数执行此事件的操作，并返回新的状态和服务器数据，以及行为引擎要执行的操作。</target>
        </trans-unit>
        <trans-unit id="abbecd682f4918a42592a94b71742e36915e1bab" translate="yes" xml:space="preserve">
          <source>The callback module does not have to access real &lt;code&gt;Mnesia&lt;/code&gt; tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</source>
          <target state="translated">回调模块不必访问真正的 &lt;code&gt;Mnesia&lt;/code&gt; 表，只要实现了回调接口，它就可以自由地执行其所需的任何操作。</target>
        </trans-unit>
        <trans-unit id="8eb2d562d838a71a4ba446f4da81f7701d757f5f" translate="yes" xml:space="preserve">
          <source>The callback module for a supervisor starting the server from &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; can look as follows:</source>
          <target state="translated">主管从 &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; 启动服务器的主管的回调模块如下所示：</target>
        </trans-unit>
        <trans-unit id="517a681e26aeb83ed7549fbd52cdab0059ff31b1" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to a file can look as follows:</source>
          <target state="translated">将错误信息写入文件的事件处理程序的回调模块可以如下所示。</target>
        </trans-unit>
        <trans-unit id="c7722a0fd22c0aced7aea92994c66dc97a4d0fdd" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to the terminal can look as follows:</source>
          <target state="translated">事件处理程序向终端写入错误信息的回调模块可以如下所示。</target>
        </trans-unit>
        <trans-unit id="344a5e28ddcbac85a390899bb7eafc0bb7e415bf" translate="yes" xml:space="preserve">
          <source>The callback module implementing the handler is responsible for checking the correctness of configuration strings.</source>
          <target state="translated">实现处理程序的回调模块负责检查配置字符串的正确性。</target>
        </trans-unit>
        <trans-unit id="97f313867ce48aba95bd9c378dbac9f612a9aacd" translate="yes" xml:space="preserve">
          <source>The callback module is used to check that the provided public key is one of the user's pre-stored. In case of the default callback module, the files &lt;code&gt;authorized_keys&lt;/code&gt; and &lt;code&gt;authorized_keys2&lt;/code&gt; are searched in a directory found in the following order:</source>
          <target state="translated">回调模块用于检查提供的公共密钥是否是用户的预存储密钥之一。如果使用默认的回调模块，则按照以下顺序在目录中搜索 &lt;code&gt;authorized_keys&lt;/code&gt; 和 &lt;code&gt;authorized_keys2&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0b0838bae2efd3e8ec52bba36939ac5379dcb0f2" translate="yes" xml:space="preserve">
          <source>The callback module must implement the &lt;code&gt;tftp&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">回调模块必须实现 &lt;code&gt;tftp&lt;/code&gt; 行为，请参见 &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c16c7638772ec54a79c0e6462748feea41441fe" translate="yes" xml:space="preserve">
          <source>The callback module of the socket.</source>
          <target state="translated">socket的回调模块。</target>
        </trans-unit>
        <trans-unit id="8b2bd7c81f3fa7abf6044482ee91de57b2f57d61" translate="yes" xml:space="preserve">
          <source>The callback will be removed if the system reboots.</source>
          <target state="translated">如果系统重启,回调将被删除。</target>
        </trans-unit>
        <trans-unit id="1a547d0b36068b79f0e702e418ab428ce5c3cc09" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throw&lt;/code&gt;s a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="translated">所调用的函数 &lt;code&gt;throw&lt;/code&gt; 的术语与 &lt;code&gt;{'EXIT',_}&lt;/code&gt; &lt;strong&gt;不&lt;/strong&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="f852af73e27bcafb08e2076230e176b0693da4a5" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throws&lt;/code&gt; a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="translated">所调用的函数 &lt;code&gt;throws&lt;/code&gt; 与 &lt;code&gt;{'EXIT', _}&lt;/code&gt; 匹配的术语。</target>
        </trans-unit>
        <trans-unit id="352f667fc05f32e342942fb39e336eda11373186" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;error&lt;/code&gt; exception.</source>
          <target state="translated">调用的函数失败，并显示 &lt;code&gt;error&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="f86af8fc0d6dc4ec61f07ecb92e7902186c04bb2" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;exit&lt;/code&gt; exception.</source>
          <target state="translated">调用的函数失败，并 &lt;code&gt;exit&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="db6c226767131f116119f4a068f6de4330aaa924" translate="yes" xml:space="preserve">
          <source>The called function returns a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="translated">被调用函数返回与 &lt;code&gt;{'EXIT', _}&lt;/code&gt; 相匹配的术语。</target>
        </trans-unit>
        <trans-unit id="dfa82d7675b5e6bd93834e8fd74a124b66bdd5d8" translate="yes" xml:space="preserve">
          <source>The called function returns normally with a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="translated">所调用的函数通常返回的术语与 &lt;code&gt;{'EXIT',_}&lt;/code&gt; &lt;strong&gt;不&lt;/strong&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="55cc105f61cd981bcf32511925e36d658bc51fff" translate="yes" xml:space="preserve">
          <source>The called hook function is to return a (possibly deep) list of characters. Function &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; is useful in a hook.</source>
          <target state="translated">调用的钩子函数将返回一个（可能很深的）字符列表。函数 &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; 在挂钩中很有用。</target>
        </trans-unit>
        <trans-unit id="dd19dd71cdd2bc7e1309239a2dc9ab10df17269d" translate="yes" xml:space="preserve">
          <source>The caller (of the discovery function) will make the needed updates later.</source>
          <target state="translated">(发现函数的)调用者将在以后进行所需的更新。</target>
        </trans-unit>
        <trans-unit id="524e0413b79c29af01dbca40fc74eeea51a2d73c" translate="yes" xml:space="preserve">
          <source>The caller can now make another call to the recv function and now expect data.</source>
          <target state="translated">调用者现在可以再调用recv函数,现在期待数据。</target>
        </trans-unit>
        <trans-unit id="0be52289a60f89b006753632d58c58744da7ef87" translate="yes" xml:space="preserve">
          <source>The caller can then make another call to the recv function and now expect data.</source>
          <target state="translated">然后,调用者可以再调用recv函数,现在就可以期待数据了。</target>
        </trans-unit>
        <trans-unit id="9ead89ef805808ff104ff5c388ca47931019854a" translate="yes" xml:space="preserve">
          <source>The caller can use own extraction and matching rules. This is done with the two options &lt;code&gt;fqdn_fun&lt;/code&gt; and &lt;code&gt;match_fun&lt;/code&gt;.</source>
          <target state="translated">调用方可以使用自己的提取和匹配规则。这是通过 &lt;code&gt;fqdn_fun&lt;/code&gt; 和 &lt;code&gt;match_fun&lt;/code&gt; 这两个选项完成的。</target>
        </trans-unit>
        <trans-unit id="a7fc9c78e44578fd025d978ee708e79b0fa261e4" translate="yes" xml:space="preserve">
          <source>The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while:</source>
          <target state="translated">现在在跟踪输出的 &quot;附加信息 &quot;部分显示了呼叫者的信息,过了一会儿就会显示以下内容。</target>
        </trans-unit>
        <trans-unit id="c55c238696091394e0bd56b82b698a5c47bb3d12" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, &lt;code&gt;pcre_exec()&lt;/code&gt; gives an error return. The limits can also be set by items at the start of the pattern of the following forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的调用者可以设置内部match（）函数被调用的次数以及递归调用的最大深度的限制。提供这些功能是为了捕获具有巨大匹配树的模式引起的失控匹配（典型示例是具有无限重复嵌套的模式），并避免由于过多的递归而耗尽系统堆栈。当达到这些限制之一时， &lt;code&gt;pcre_exec()&lt;/code&gt; 会返回错误。限制还可以通过以下形式的模式开头的项目来设置：</target>
        </trans-unit>
        <trans-unit id="f03c64f9f710de5955e68843c690db2e8c0fc8ca" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;driver_create_port&lt;/code&gt; is allowed to manipulate the newly created port when &lt;code&gt;driver_create_port&lt;/code&gt; has returned. When &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; is used, the creating port is only allowed to manipulate the newly created port until the current driver callback, which was called by the emulator, returns.</source>
          <target state="translated">当 &lt;code&gt;driver_create_port&lt;/code&gt; 返回时，允许 &lt;code&gt;driver_create_port&lt;/code&gt; 的调用方操纵新创建的端口。使用 &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; ，仅允许创建端口操纵新创建的端口，直到返回由模拟器调用的当前驱动程序回调。</target>
        </trans-unit>
        <trans-unit id="621fc2d91134d4db21b3517ae8ac3625fde2ce09" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">此函数的调用者是 &lt;code&gt;net_kernel&lt;/code&gt; 的代表（此进程可以或可以不是注册为 &lt;code&gt;net_kernel&lt;/code&gt; 的进程），并且在本文档中被标识为 &lt;code&gt;Kernel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80825902e9ea39352717e07e7e143bd52944e894" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;. When a connection has been accepted by the acceptor process, it needs to inform &lt;code&gt;Kernel&lt;/code&gt; about the accepted connection. This is done by passing a message on the form:</source>
          <target state="translated">此函数的调用者是 &lt;code&gt;net_kernel&lt;/code&gt; 的代表（此进程可以或可以不是注册为 &lt;code&gt;net_kernel&lt;/code&gt; 的进程），并且在本文档中被标识为 &lt;code&gt;Kernel&lt;/code&gt; 。当接受者进程接受了连接后，需要将已接受的连接通知 &lt;code&gt;Kernel&lt;/code&gt; 。这是通过在表单上传递消息来完成的：</target>
        </trans-unit>
        <trans-unit id="17dc5e2470f7e3eb401d50cfc358de49382160b2" translate="yes" xml:space="preserve">
          <source>The calling NIF must use the return value of &lt;code&gt;enif_schedule_nif&lt;/code&gt; as its own return value.</source>
          <target state="translated">调用NIF必须使用 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 的返回值作为其自己的返回值。</target>
        </trans-unit>
        <trans-unit id="b39ce61a3bf5f9ff14b9a7cd2356d7e2ed9376ab" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is aborted and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果端口正忙，则调用过程不会挂起，而是将port命令中止并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0ba9d7309f260b173565ca438b3eeea1bd4473" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果端口繁忙，则不会暂停调用进程，而是强制执行port命令。如果端口的驱动程序不支持此调用，则调用将失败并显示 &lt;code&gt;notsup&lt;/code&gt; 异常。有关更多信息，请参见驱动程序标志 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="629c5b3b630ae0172907db307b7e38fd8b753106" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果端口繁忙，则不会暂停调用进程，而是强制执行port命令。如果端口的驱动程序不支持此调用，则调用将失败并显示 &lt;code&gt;notsup&lt;/code&gt; 异常。有关更多信息，请参见驱动程序标志 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a1251fc069f821f07a282196dbe91995966e598" translate="yes" xml:space="preserve">
          <source>The calling process subscribes or unsubscribes to node status change messages. A &lt;code&gt;nodeup&lt;/code&gt; message is delivered to all subscribing processes when a new node is connected, and a &lt;code&gt;nodedown&lt;/code&gt; message is delivered when a node is disconnected.</source>
          <target state="translated">调用过程订阅或取消订阅节点状态更改消息。甲 &lt;code&gt;nodeup&lt;/code&gt; 消息被传递到所有订阅方法当新的节点连接，和一个 &lt;code&gt;nodedown&lt;/code&gt; 当节点断开传送消息。</target>
        </trans-unit>
        <trans-unit id="3fd0eba81e7afeb40af7403b8df7ac0d5fe56351" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, &lt;code&gt;application&lt;/code&gt; configuration must be matched by corresponding &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; configuration, of *-Application-Id AVPs in particular.</source>
          <target state="translated">节点通告的功能必须匹配其配置的应用程序。特别是， &lt;code&gt;application&lt;/code&gt; 配置必须与* -Application-Id AVP 的相应 &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; 配置相匹配。</target>
        </trans-unit>
        <trans-unit id="9f7b2ec0f22afdbc01fa422caed0e98c532f9b08" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, setting &lt;code&gt;applications&lt;/code&gt; on a transport typically implies having to set matching *-Application-Id AVPs in a &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; tuple.</source>
          <target state="translated">节点通告的功能必须匹配其配置的应用程序。特别是，在传输上设置 &lt;code&gt;applications&lt;/code&gt; 通常意味着必须在 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; 元组中设置匹配的* -Application-Id AVP 。</target>
        </trans-unit>
        <trans-unit id="172ff57f871dcdd5d0b54942cc29dbee89bb8d9d" translate="yes" xml:space="preserve">
          <source>The capture tuple is built up as follows:</source>
          <target state="translated">捕获元组的建立如下。</target>
        </trans-unit>
        <trans-unit id="734624d49a0e505e194d0a3e203f3707e0a9ce89" translate="yes" xml:space="preserve">
          <source>The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below.</source>
          <target state="translated">截断UTF的情况会被特殊处理,参见下面关于不完整二进制文件的段落。</target>
        </trans-unit>
        <trans-unit id="bf787b1c131df12f5b5608740bbea97ec8c5c67e" translate="yes" xml:space="preserve">
          <source>The cases are executed in a sequence as described in section &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; in section Dependencies Between Test Cases and Suites.</source>
          <target state="translated">用例按测试用例与套件之间的依存关系部分中的 &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; 部分中所述的顺序执行。</target>
        </trans-unit>
        <trans-unit id="a67cf4e28458acef6485593f3479b26ebbee2e4f" translate="yes" xml:space="preserve">
          <source>The cases in the group are executed in random order.</source>
          <target state="translated">组内案件按随机顺序执行。</target>
        </trans-unit>
        <trans-unit id="79326758fa4216db5c43f358f0c9d48cf3066915" translate="yes" xml:space="preserve">
          <source>The center area of the main window contains the information tabs. Each tab displays information about a specific item or a list of items. Select a tab by clicking the tab title.</source>
          <target state="translated">主窗口的中心区域包含信息标签。每个选项卡都显示有关特定项目或项目列表的信息。通过点击标签页标题选择一个标签页。</target>
        </trans-unit>
        <trans-unit id="2e333bd4d7da78b5f5a1e212afc4f6afc672a38c" translate="yes" xml:space="preserve">
          <source>The certificate MUST allow the key to be used for signing with a signature scheme indicated in the client's &quot;signature_algorithms&quot;/&quot;signature_algorithms_cert&quot; extensions</source>
          <target state="translated">证书必须允许密钥被用于使用客户机 &quot;signature_algorithms&quot;/&quot;signature_algorithms_cert &quot;扩展名中指定的签名方案进行签名。</target>
        </trans-unit>
        <trans-unit id="e2b65e59eb08b76012cdc739d366b164e936d686" translate="yes" xml:space="preserve">
          <source>The certificate type MUST be X.509v3, unless explicitly negotiated otherwise</source>
          <target state="translated">证书类型必须是X.509v3,除非另有明确约定。</target>
        </trans-unit>
        <trans-unit id="136170ec67e23d4bdc746cf64630b0fc4f944a3d" translate="yes" xml:space="preserve">
          <source>The certificates MUST be signed using an acceptable signature algorithm</source>
          <target state="translated">证书必须使用可接受的签名算法进行签名。</target>
        </trans-unit>
        <trans-unit id="4592ee81cac18e24ff040ed72913569d66a68da6" translate="yes" xml:space="preserve">
          <source>The certificates attributes are valid.</source>
          <target state="translated">证书的属性是有效的。</target>
        </trans-unit>
        <trans-unit id="a7eaa8135e803f2fb327a77633a52bb48c129b5b" translate="yes" xml:space="preserve">
          <source>The chain consisted only of one self-signed certificate.</source>
          <target state="translated">该链仅由一张自签证书组成。</target>
        </trans-unit>
        <trans-unit id="0e0a9851e387d6b9bd8489d5d8385b78fdd1efbf" translate="yes" xml:space="preserve">
          <source>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</source>
          <target state="translated">只要不删除日志,这个更改就是永久性的。这意味着,日志大小会在重启后被记住。</target>
        </trans-unit>
        <trans-unit id="209a620344bc5ac686ada38b14f368934eb2469b" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">更改将在下一次磁盘空间检查后生效，并且是非持久性的。也就是说，在进程重新启动的情况下，该值将被忘记，并且将使用默认值。请参阅上面的 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7324d42150f9730491b8b6dcf07acbe2a4287488" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">更改将在下一次内存检查后生效，并且是永久性的。也就是说，在进程重新启动的情况下，该值将被忘记，并将使用默认值。请参阅上面的 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8308604a253081056bdf717b82fcf33a719c92f1" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">该更改将在下一次磁盘空间检查期间生效，并且是非持久性的。也就是说，在进程重新启动的情况下，该值将被忘记，并将使用默认值。请参阅上面的 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9ee001de4f9c2acc5f959f9da7fbe9021fe19db" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next periodic memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">该更改将在下一次定期内存检查期间生效，并且是非永久性的。也就是说，在进程重新启动的情况下，该值将被忘记，并将使用默认值。请参阅上面的 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48592559cdd27064407e93ea03790b5d39d21da9" translate="yes" xml:space="preserve">
          <source>The change will take effect for the next memory check and is non-persistent. That is, in the case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">该更改将在下一次内存检查时生效，并且是永久性的。也就是说，在进程重新启动的情况下，该值将被忘记，并将使用默认值。请参阅上面的 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a55eac8fba728a49ba83a1ba16426f587e19122" translate="yes" xml:space="preserve">
          <source>The changes do not affect existing child processes. For example, changing the start function only specifies how the child process is to be restarted, if needed later on.</source>
          <target state="translated">这些改变不会影响现有的子进程。例如,改变启动函数只是指定以后需要时如何重新启动子进程。</target>
        </trans-unit>
        <trans-unit id="17ef826dd60e0b23be9ebb72e959e4616f5a6f10" translate="yes" xml:space="preserve">
          <source>The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果尚未发送关闭消息，则该通道行为会将关闭消息发送到另一端。然后它以 &lt;code&gt;normal&lt;/code&gt; 原因终止通道。</target>
        </trans-unit>
        <trans-unit id="2d0641d9544e5c0fe01329a75590e893fef99690" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Advanced Agent Topics&lt;/strong&gt; describes the more advanced agent related features of the SNMP development tool. The following topics are covered:</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;高级代理程序主题&lt;/strong&gt; &amp;rdquo;一章介绍了SNMP开发工具与代理程序相关的更高级的功能。涵盖以下主题：</target>
        </trans-unit>
        <trans-unit id="2e272ab9ddbed68131c16ba5014e291dc03d4f2d" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Audit Trail Log&lt;/strong&gt; describes the audit trail logging.</source>
          <target state="translated">&lt;strong&gt;审计跟踪日志&lt;/strong&gt;一章介绍了审计跟踪日志。</target>
        </trans-unit>
        <trans-unit id="3f08decf0e83874ab43a9d84e18e36f372618712" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Running the application&lt;/strong&gt; describes how the application is configured and started. The topics include:</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;运行应用程序&lt;/strong&gt; &amp;rdquo;一章介绍了如何配置和启动应用程序。主题包括：</target>
        </trans-unit>
        <trans-unit id="72b08f124553e2dc5540039b611421ca2a1cb7f5" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;The MIB Compiler&lt;/strong&gt; describes the MIB compiler and contains the following topics:</source>
          <target state="translated">&lt;strong&gt;MIB编译器&lt;/strong&gt;一章介绍了MIB编译器，并包含以下主题：</target>
        </trans-unit>
        <trans-unit id="d2d9fc11f8e7828565eb35f14517412a40b0d378" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;?&lt;/code&gt; can be added to the end of an operand to indicate that the operand will not be used every time the instruction is executed. For example:</source>
          <target state="translated">性格 &lt;code&gt;?&lt;/code&gt; 可以添加到操作数的末尾以指示每次执行该指令时将不使用该操作数。例如：</target>
        </trans-unit>
        <trans-unit id="ddb91809478ddb72a376ffa2ae9889076265397b" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;C&lt;/code&gt; determines the type of control sequence to be used. It is the only required field. All of &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Pad&lt;/code&gt;, and &lt;code&gt;Mod&lt;/code&gt; are optional. For example, to use a &lt;code&gt;#&lt;/code&gt; for &lt;code&gt;Pad&lt;/code&gt; but use the default values for &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;, you can write &lt;code&gt;~..#C&lt;/code&gt;.</source>
          <target state="translated">字符 &lt;code&gt;C&lt;/code&gt; 确定要使用的控制序列的类型。这是唯一必填字段。所有的 &lt;code&gt;F&lt;/code&gt; ， &lt;code&gt;P&lt;/code&gt; ， &lt;code&gt;Pad&lt;/code&gt; ，和 &lt;code&gt;Mod&lt;/code&gt; 是可选的。例如，要对 &lt;code&gt;Pad&lt;/code&gt; 使用 &lt;code&gt;#&lt;/code&gt; ，但对 &lt;code&gt;F&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 使用默认值，则可以编写 &lt;code&gt;~..#C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d64a4036522ec8f78050362f7b7c36c9cac056c3" translate="yes" xml:space="preserve">
          <source>The character encoding used in strings and atoms. The only supported encoding is &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; for ISO Latin-1 (8-bit ASCII).</source>
          <target state="translated">字符串和原子中使用的字符编码。唯一受支持的编码是ISO Latin-1（8位ASCII）的 &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d193b1def3415cd7c10a5af19c4d201098e3350" translate="yes" xml:space="preserve">
          <source>The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</source>
          <target state="translated">用于原子的字符编码。 &lt;code&gt;ERLANG_ASCII&lt;/code&gt; 表示7位ASCII。Latin-1和UTF-8是7位ASCII的不同扩展。所有7位ASCII字符都是有效的Latin-1和UTF-8字符。ASCII和Latin-1都用一个字节表示每个字符。UTF-8字符可以包含1-4个字节。请注意，这些常量是位标志，可以与按位或进行组合。</target>
        </trans-unit>
        <trans-unit id="5bce2007ce7233de084f6c74cc17834bdadef1f7" translate="yes" xml:space="preserve">
          <source>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, \w, and \W can appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit. In UTF modes, option &lt;code&gt;ucp&lt;/code&gt; affects the meanings of \d, \s, \w and their uppercase partners, just as it does when they appear outside a character class, as described in section &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; earlier. The escape sequence \b has a different meaning inside a character class; it matches the backspace character. The sequences \B, \N, \R, and \X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</source>
          <target state="translated">字符转义序列\ d，\ D，\ h，\ H，\ p，\ P，\ s，\ S，\ v，\ V，\ w和\ W可以出现在字符类中，并添加他们与班级相匹配的字符。例如，[\ dABCDEF]匹配任何十六进制数字。在UTF模式下，选项 &lt;code&gt;ucp&lt;/code&gt; 会影响\ d，\ s，\ w及其大写伙伴的含义，就像它们出现在字符类之外时一样，如前面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; 一节中所述。转义序列\ b在字符类内部具有不同的含义；它与退格符匹配。字符类中的\ B，\ N，\ R和\ X序列并不特殊。与其他任何无法识别的转义序列一样，它们被视为文字字符&amp;ldquo; B&amp;rdquo;，&amp;ldquo; N&amp;rdquo;，&amp;ldquo; R&amp;rdquo;和&amp;ldquo; X&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="89f86657075f7d2532ecb276650adc58a9119d7f" translate="yes" xml:space="preserve">
          <source>The character used as time designator, that is, the date and time separator. The default is &lt;code&gt;$T&lt;/code&gt;.</source>
          <target state="translated">用作时间指示符的字符，即日期和时间分隔符。默认值是 &lt;code&gt;$T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7d9d6c64abc51b03bd1675467e660789635b1bd" translate="yes" xml:space="preserve">
          <source>The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode).</source>
          <target state="translated">该行中的字符由换行符（或文件末尾）终止。如果I / O设备支持Unicode，则数据可以表示&amp;gt; 255（ &lt;code&gt;latin1&lt;/code&gt; 范围）的代码点。如果将I / O服务器设置为提供二进制文件，则它们将以UTF-8编码（无论I / O设备是否支持Unicode）。</target>
        </trans-unit>
        <trans-unit id="56bc68334532732a987644276bf7e27ba2ed6340" translate="yes" xml:space="preserve">
          <source>The characters in the name (if specified as a list) can only be &amp;gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</source>
          <target state="translated">如果以Unicode文件名转换模式启动Erlang虚拟机，则名称中的字符（如果指定为列表）只能大于255。否则，可执行文件的名称仅限于ISO Latin-1字符集。</target>
        </trans-unit>
        <trans-unit id="4c340bb094927d6516a270b8c7260c59f1b0e9ac" translate="yes" xml:space="preserve">
          <source>The check for calls to undefined functions is an example of a predefined analysis, probably the most useful one. Other examples are the analyses that find unused local functions, or functions that call some given functions. See the &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; functions for a complete list of predefined analyses.</source>
          <target state="translated">检查对未定义函数的调用是预定义分析的一个示例，可能是最有用的分析。其他示例是查找未使用的局部函数或调用某些给定函数的函数的分析。有关预定义分析的完整列表，请参见 &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="b5e1916c5d50a9c907628d5b592b7e3e35726d5e" translate="yes" xml:space="preserve">
          <source>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint.</source>
          <target state="translated">当所涉及的某些表没有固定器时，该检查点将自动停用。当节点出现故障或删除副本时，可能会发生这种情况。通过此功能也可以禁用检查点。 &lt;code&gt;Name&lt;/code&gt; 是活动检查点的名称。</target>
        </trans-unit>
        <trans-unit id="d9393d9861ac13bac497a84046277f971838af74" translate="yes" xml:space="preserve">
          <source>The checks performed before the boot script is generated can be extended with some cross reference checks by specifying option &lt;code&gt;exref&lt;/code&gt;. These checks are performed with the Xref tool. All applications, or the applications specified with &lt;code&gt;{exref,[App]}&lt;/code&gt;, are checked by Xref and warnings are issued for calls to undefined functions.</source>
          <target state="translated">通过指定选项 &lt;code&gt;exref&lt;/code&gt; ,可以使用一些交叉引用检查来扩展在生成引导脚本之前执行的检查。这些检查是使用外部参照工具执行的。所有应用程序或使用 &lt;code&gt;{exref,[App]}&lt;/code&gt; 指定的应用程序均由Xref进行检查，并发出针对未定义函数的调用的警告。</target>
        </trans-unit>
        <trans-unit id="b71574456dfb07437b35ad062527dd44aa7aea5a" translate="yes" xml:space="preserve">
          <source>The child specification for a stopped child process is deleted with the following call:</source>
          <target state="translated">通过以下调用删除停止的子进程的子规范。</target>
        </trans-unit>
        <trans-unit id="67c92024750696ea3d3e50b512e7251afc6c23fc" translate="yes" xml:space="preserve">
          <source>The children of a supervisor are defined as a list of &lt;strong&gt;child specifications&lt;/strong&gt;. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</source>
          <target state="translated">主管的孩子被定义为&lt;strong&gt;孩子规格&lt;/strong&gt;列表。当主管启动时，将根据此列表从左到右依次启动子进程。主管终止时，它首先以相反的启动顺序从右到左终止其子进程。</target>
        </trans-unit>
        <trans-unit id="51bde16b1e029fca3eb55c7bba60557bdc4ece36" translate="yes" xml:space="preserve">
          <source>The choice between stateful or stateless depends on the server requirements as the session tickets are opaque for the clients. Generally, stateful tickets are smaller and the server can guarantee that tickets are only used once. Stateless tickets contain additional data, require less storage on the server side, but they offer different guarantees against anti-replay. See also &lt;code&gt; Anti-Replay Protection in TLS 1.3&lt;/code&gt;</source>
          <target state="translated">有状态还是无状态之间的选择取决于服务器要求，因为会话票证对于客户端来说是不透明的。通常，有状态票证较小，服务器可以保证票证仅使用一次。无状态票证包含其他数据，需要较少的服务器端存储空间，但是它们提供了不同的保证以防重放。另请参阅 &lt;code&gt; Anti-Replay Protection in TLS 1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="814de93894ad7aadf116db8d46dcb0a1a2f6a6fc" translate="yes" xml:space="preserve">
          <source>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</source>
          <target state="translated">配置的选择改变了表格的位置和加载顺序。备选方案如下:</target>
        </trans-unit>
        <trans-unit id="545828e5805f31f0b4dc4f2a83912e6bb6d32eb0" translate="yes" xml:space="preserve">
          <source>The choice of using a chunk or the filesystem is completely up to the language or library. In both cases, the documentation can be added or removed at any moment by stripping the &lt;code&gt;Docs&lt;/code&gt; chunk or by removing the doc/chunks directory.</source>
          <target state="translated">使用块或文件系统的选择完全取决于语言或库。在这两种情况下，都可以通过删除 &lt;code&gt;Docs&lt;/code&gt; 块或删除doc / chunks目录随时添加或删除文档。</target>
        </trans-unit>
        <trans-unit id="cfaabaea33a1559baea30876e0db48c230aa2c6c" translate="yes" xml:space="preserve">
          <source>The chosen solution is instead for tracing to use the technique of replication applied on the data structures for breakpoints. Two generations of breakpoints are kept and indentified by index of 0 and</source>
          <target state="translated">我们选择的解决方案是在断点的数据结构上使用复制技术进行跟踪。两代断点被保留下来,并以0和0为索引进行标识。</target>
        </trans-unit>
        <trans-unit id="92e209681f18120979ec8cf62515a80ebbdd5369" translate="yes" xml:space="preserve">
          <source>The chunk size used by the Erlang fallback to send data. If using the fallback, set this to a value that comfortably fits in the systems memory. Default is 20 MB.</source>
          <target state="translated">Erlang回退用来发送数据的块大小。如果使用回退,请将其设置为一个适合系统内存的值。默认值是20MB。</target>
        </trans-unit>
        <trans-unit id="80fc5d4e3e9d8bfc9a8f58b63d628ca694feebf8" translate="yes" xml:space="preserve">
          <source>The ciphers &lt;code&gt;aes_cbc&lt;/code&gt;, &lt;code&gt;aes_cfb8&lt;/code&gt;, &lt;code&gt;aes_cfb128&lt;/code&gt;, &lt;code&gt;aes_ctr&lt;/code&gt;, &lt;code&gt;aes_ecb&lt;/code&gt;, &lt;code&gt;aes_gcm&lt;/code&gt; and &lt;code&gt;aes_ccm&lt;/code&gt; has no keylength in the &lt;code&gt;Type&lt;/code&gt; as opposed to for example &lt;code&gt;aes_128_ctr&lt;/code&gt;. They adapt to the length of the key provided in the encrypt and decrypt function. Therefor it is impossible to return a valid keylength in the map.</source>
          <target state="translated">的密码 &lt;code&gt;aes_cbc&lt;/code&gt; ， &lt;code&gt;aes_cfb8&lt;/code&gt; ， &lt;code&gt;aes_cfb128&lt;/code&gt; ， &lt;code&gt;aes_ctr&lt;/code&gt; ， &lt;code&gt;aes_ecb&lt;/code&gt; ， &lt;code&gt;aes_gcm&lt;/code&gt; 和 &lt;code&gt;aes_ccm&lt;/code&gt; 具有在没有keylength &lt;code&gt;Type&lt;/code&gt; ，而不是例如 &lt;code&gt;aes_128_ctr&lt;/code&gt; 。它们适应加密和解密功能中提供的密钥长度。因此，不可能在映射中返回有效的密钥长度。</target>
        </trans-unit>
        <trans-unit id="bffd1151a2b3988ada1265de3c714b941ea9eba2" translate="yes" xml:space="preserve">
          <source>The ciphers are:</source>
          <target state="translated">密码器是:</target>
        </trans-unit>
        <trans-unit id="b290d8f7cbf9ebc957458f968fe0fad53d55bb94" translate="yes" xml:space="preserve">
          <source>The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.</source>
          <target state="translated">circumflex和美元元字符是零宽度断言。也就是说,它们测试一个特定的条件是否为真,而不消耗主题字符串中的任何字符。</target>
        </trans-unit>
        <trans-unit id="5669e2ea35917008527e37b5ca4d88fc5112fe65" translate="yes" xml:space="preserve">
          <source>The classic edit-compile-bugfix cycle for Erlang is to edit the source file in an editor, save it to a file and switch to an Erlang shell. In the shell the compilation command is given. Should the compilation fail you have to bring out the editor and locate the correct line.</source>
          <target state="translated">Erlang经典的编辑-编译-bugfix循环是在编辑器中编辑源文件,保存到文件中,然后切换到Erlang shell中。在shell中给出编译命令。如果编译失败,你必须拿出编辑器并找到正确的行。</target>
        </trans-unit>
        <trans-unit id="fadd4266630fc260a3b4ea69de0cd9a6f41365a8" translate="yes" xml:space="preserve">
          <source>The classification of &lt;code&gt;cached_memory&lt;/code&gt; is changed. Also memory marked as reclaimable in the kernel slab allocator will be added to the value presented as &lt;code&gt;cached_memory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cached_memory&lt;/code&gt; 的分类已更改。内核slab分配器中标记为可回收的内存也将添加到显示为 &lt;code&gt;cached_memory&lt;/code&gt; 的值中。</target>
        </trans-unit>
        <trans-unit id="b037a6b9c798a6a67eb72fefb14eec4bbb6f1f1d" translate="yes" xml:space="preserve">
          <source>The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code.</source>
          <target state="translated">客户端自动从新的URI中检索信息,并将其作为结果返回,而不是30X结果代码。</target>
        </trans-unit>
        <trans-unit id="1fbe84685ac1a559531b7c36291fb36841fab94a" translate="yes" xml:space="preserve">
          <source>The client can be stopped using &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; or &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; 或 &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt; 停止客户端。</target>
        </trans-unit>
        <trans-unit id="569ccd940c4f6a817b12bba1b1067ae1a9656ffb" translate="yes" xml:space="preserve">
          <source>The client can choose to accept some path evaluation errors, for example, a web browser can ask the user whether to accept an unknown CA root certificate. The server, if it requests a certificate, does however not accept any path validation errors. It is configurable if the server is to accept or reject an &quot;empty&quot; certificate as response to a certificate request.</source>
          <target state="translated">客户端可以选择接受一些路径评估错误,例如,Web浏览器可以询问用户是否接受未知的CA根证书。但服务器如果请求证书,则不接受任何路径验证错误。可以配置服务器是否接受或拒绝 &quot;空 &quot;证书作为对证书请求的响应。</target>
        </trans-unit>
        <trans-unit id="1e096fcf12a451f0d8ba37109ec7b8520e84ee7a" translate="yes" xml:space="preserve">
          <source>The client checks that the host that presented the public key also possesses the private key of the key-pair. That check is part of the SSH protocol.</source>
          <target state="translated">客户端检查提交公钥的主机是否也拥有密钥对的私钥。这种检查是SSH协议的一部分。</target>
        </trans-unit>
        <trans-unit id="c1b412fb6f7f703ee2ef8dff66ba99951cf7089b" translate="yes" xml:space="preserve">
          <source>The client is any Erlang process wishing to read or write data from/to the I/O device.</source>
          <target state="translated">客户端是任何希望从/向I/O设备读写数据的Erlang进程。</target>
        </trans-unit>
        <trans-unit id="c1f2e8007b5292b585147076187f8ae466cd3c94" translate="yes" xml:space="preserve">
          <source>The client processes has done some illegal operation.</source>
          <target state="translated">客户端进程进行了一些非法操作。</target>
        </trans-unit>
        <trans-unit id="9a26517024410b148cd294e33b877a64e550bcc2" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">客户端远程用户名（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41327174b5c9bc729859a7f6bf3b5c175db7b9d0" translate="yes" xml:space="preserve">
          <source>The client sends an &lt;code&gt;io_request&lt;/code&gt; tuple to the I/O server and the server eventually sends a corresponding &lt;code&gt;io_reply&lt;/code&gt; tuple.</source>
          <target state="translated">客户端将 &lt;code&gt;io_request&lt;/code&gt; 元组发送到I / O服务器，服务器最终将发送相应的 &lt;code&gt;io_reply&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="0f8f061d93662344f07374622d9a9f5570dc6915" translate="yes" xml:space="preserve">
          <source>The client sends the message to the server by:</source>
          <target state="translated">客户端通过以下方式向服务器发送消息。</target>
        </trans-unit>
        <trans-unit id="072bdecf1b9485830f32e0b9aaa2f2cd201b4643" translate="yes" xml:space="preserve">
          <source>The client supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">只要底层机制也支持IPv6,客户端就会支持。</target>
        </trans-unit>
        <trans-unit id="f39527c54a4e7962b71c62198072191bb4f4c11d" translate="yes" xml:space="preserve">
          <source>The client will send a signature_algorithms_cert extension (ClientHello), if TLS version 1.3 or later is used, and the signature_algs_cert option is explicitly specified. By default, only the signature_algs extension is sent.</source>
          <target state="translated">如果使用的是TLS 1.3或更高版本,并且明确指定了signature_algs_cert选项,那么客户端将发送一个签名_algorithms_cert扩展名(ClientHello)。默认情况下,只发送signature_algs扩展名。</target>
        </trans-unit>
        <trans-unit id="5795d28810329b4419d272a646663a21aa527543" translate="yes" xml:space="preserve">
          <source>The client-server model is characterized by a central server and an arbitrary number of clients. The client-server model is used for resource management operations, where several different clients want to share a common resource. The server is responsible for managing this resource.</source>
          <target state="translated">客户机-服务器模式的特点是由一个中心服务器和任意数量的客户机组成。客户机-服务器模型用于资源管理操作,即几个不同的客户机想共享一个共同的资源。服务器负责管理这个资源。</target>
        </trans-unit>
        <trans-unit id="b8d268ee82b336a5c95688dda8482335e48cf69d" translate="yes" xml:space="preserve">
          <source>The clients ip address.</source>
          <target state="translated">客户的IP地址。</target>
        </trans-unit>
        <trans-unit id="a98219544eb3eff51a663b1a744e3bf13062abc6" translate="yes" xml:space="preserve">
          <source>The clock starts ticking when the request is sent.</source>
          <target state="translated">发送请求时,时钟开始滴答作响。</target>
        </trans-unit>
        <trans-unit id="be435ecc0cf1fa1a9c98c5cd0695f7dfa36eec57" translate="yes" xml:space="preserve">
          <source>The clone of the SSL application must enable the use of the SSL code in such an early bootstage as needed to set up the distribution. However, this makes it impossible to soft upgrade the SSL application.</source>
          <target state="translated">SSL应用程序的克隆必须在设置发行版所需的早期启动阶段启用SSL代码的使用。然而,这使得SSL应用程序无法进行软升级。</target>
        </trans-unit>
        <trans-unit id="d756129312a76f266001381d64eeed8865f4919a" translate="yes" xml:space="preserve">
          <source>The code for a module can exist in two variants in a system: &lt;strong&gt;current code&lt;/strong&gt; and &lt;strong&gt;old code&lt;/strong&gt;. When a module is loaded into the system for the first time, the module code becomes 'current' and the global &lt;strong&gt;export table&lt;/strong&gt; is updated with references to all functions exported from the module.</source>
          <target state="translated">模块的代码可以在系统中以两种形式存在：&lt;strong&gt;当前代码&lt;/strong&gt;和&lt;strong&gt;旧代码&lt;/strong&gt;。首次将模块加载到系统中时，模块代码将变为&amp;ldquo;当前&amp;rdquo;，并且全局&lt;strong&gt;导出表&lt;/strong&gt;将参考从模块导出的所有功能进行更新。</target>
        </trans-unit>
        <trans-unit id="e2397fc7367abe891aaddea1acfb84a0e33bbb71" translate="yes" xml:space="preserve">
          <source>The code for the server can be rewritten into a generic part &lt;code&gt;server.erl&lt;/code&gt;:</source>
          <target state="translated">服务器的代码可以重写为通用部分 &lt;code&gt;server.erl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8e4cf743be10d1f78796a8520fbbc62b88613fb4" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;error_handler&lt;/code&gt; is complex. Do not change it without fully understanding the interaction between the error handler, the &lt;code&gt;init&lt;/code&gt; process of the code server, and the I/O mechanism of the code.</source>
          <target state="translated">&lt;code&gt;error_handler&lt;/code&gt; 中的代码很复杂。在没有完全理解错误处理程序，代码服务器的 &lt;code&gt;init&lt;/code&gt; 过程以及代码的I / O机制之间的交互作用之前，请勿对其进行更改。</target>
        </trans-unit>
        <trans-unit id="90cb7656e2a78a30cae10868a6acccf8aa88d091" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;server&lt;/code&gt; can be reused to build many different servers.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 的代码可以重复使用以构建许多不同的服务器。</target>
        </trans-unit>
        <trans-unit id="04225ffb5d1e2cd3c54d5a022ccc010d6c271db5" translate="yes" xml:space="preserve">
          <source>The code is available in &lt;code&gt;pg_sync.c&lt;/code&gt; in the &lt;code&gt;sample&lt;/code&gt; directory of &lt;code&gt;erts&lt;/code&gt;.</source>
          <target state="translated">可以在 &lt;code&gt;erts&lt;/code&gt; &lt;code&gt;sample&lt;/code&gt; 目录的 &lt;code&gt;pg_sync.c&lt;/code&gt; 中找到该代码。</target>
        </trans-unit>
        <trans-unit id="c9264957f8945993653ce298e5c1234e15d08f23" translate="yes" xml:space="preserve">
          <source>The code is explained in the next sections.</source>
          <target state="translated">在接下来的章节中,将对该代码进行解释。</target>
        </trans-unit>
        <trans-unit id="0e3333c77c7ae219d3009900b602e3b49e21c916" translate="yes" xml:space="preserve">
          <source>The code is straightforward: all communication between Erlang and the driver is done with &lt;code&gt;port_control/3&lt;/code&gt;, and the driver returns data back using the &lt;code&gt;rbuf&lt;/code&gt;.</source>
          <target state="translated">代码很简单：Erlang和驱动程序之间的所有通信都通过 &lt;code&gt;port_control/3&lt;/code&gt; 完成，驱动程序使用 &lt;code&gt;rbuf&lt;/code&gt; 返回数据。</target>
        </trans-unit>
        <trans-unit id="f043529a1b5d337526e7bf30093ae19b9989356b" translate="yes" xml:space="preserve">
          <source>The code must return:</source>
          <target state="translated">代码必须返回。</target>
        </trans-unit>
        <trans-unit id="507745f725c946f3bb38fa59ee9580fa6d304cd3" translate="yes" xml:space="preserve">
          <source>The code of a module can exist in two variants in a system: &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;. When a module is loaded into the system for the first time, the code becomes 'current'. If then a new instance of the module is loaded, the code of the previous instance becomes 'old' and the new instance becomes 'current'.</source>
          <target state="translated">模块的代码可以在系统中以两种形式存在：&lt;strong&gt;current&lt;/strong&gt;和&lt;strong&gt;old&lt;/strong&gt;。首次将模块加载到系统中时，代码变为&amp;ldquo;当前&amp;rdquo;。如果然后加载模块的新实例，则先前实例的代码将变为&amp;ldquo;旧&amp;rdquo;，而新实例将变为&amp;ldquo;当前&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="922b2eb4a931c1204aa3e51a063d0b9c833303d1" translate="yes" xml:space="preserve">
          <source>The code path can be extended by using the command-line flags &lt;code&gt;-pa Directories&lt;/code&gt; and &lt;code&gt;-pz Directories&lt;/code&gt;. These add &lt;code&gt;Directories&lt;/code&gt; to the head or the end of the code path, respectively. Example:</source>
          <target state="translated">可以使用命令行标志 &lt;code&gt;-pa Directories&lt;/code&gt; 和 &lt;code&gt;-pz Directories&lt;/code&gt; 扩展代码路径。这些分别将 &lt;code&gt;Directories&lt;/code&gt; 添加到代码路径的开头或结尾。例：</target>
        </trans-unit>
        <trans-unit id="9688469fe16d88facce2f69f4687ce1df4ec41a4" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt; System Principles &lt;/code&gt;.</source>
          <target state="translated">代码服务器根据代码加载策略来加载代码，该策略是&lt;strong&gt;交互式&lt;/strong&gt;（默认）或&lt;strong&gt;嵌入式&lt;/strong&gt;。在交互模式下，在&lt;strong&gt;代码路径中&lt;/strong&gt;搜索&lt;strong&gt;代码&lt;/strong&gt;并在首次引用时加载&lt;strong&gt;代码&lt;/strong&gt;。在嵌入式模式下，根据&lt;strong&gt;启动脚本&lt;/strong&gt;在启动时加载代码。 &lt;code&gt; System Principles &lt;/code&gt; 对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="e7f2de033652fb4852b04d98599da41645cd5418" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt;System Principles&lt;/code&gt;.</source>
          <target state="translated">代码服务器根据代码加载策略来加载代码，该策略是&lt;strong&gt;交互式&lt;/strong&gt;（默认）或&lt;strong&gt;嵌入式&lt;/strong&gt;。在交互模式下，在&lt;strong&gt;代码路径中&lt;/strong&gt;搜索&lt;strong&gt;代码&lt;/strong&gt;并在首次引用时加载&lt;strong&gt;代码&lt;/strong&gt;。在嵌入式模式下，根据&lt;strong&gt;引导脚本&lt;/strong&gt;在启动时加载代码。 &lt;code&gt;System Principles&lt;/code&gt; 对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="8c79fc2d0738d58b971f65c1fecd5a663cbf7ff9" translate="yes" xml:space="preserve">
          <source>The code server module &lt;code&gt;code&lt;/code&gt; contains a number of functions for modifying and checking the search path, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">代码服务器模块 &lt;code&gt;code&lt;/code&gt; 包含许多用于修改和检查搜索路径的功能，请参见内核中的 &lt;code&gt;code(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="33c6dc6ea8623b6f6923c8e2b31c4332f8ba122e" translate="yes" xml:space="preserve">
          <source>The code server uses &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; to find the directory of the current (latest) version of Kernel, and then the subdirectory &lt;code&gt;include&lt;/code&gt; is searched for the file &lt;code&gt;file.hrl&lt;/code&gt;.</source>
          <target state="translated">代码服务器使用 &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; 查找当前（最新）Kernel版本的目录，然后在子目录 &lt;code&gt;include&lt;/code&gt; 中搜索文件 &lt;code&gt;file.hrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="705518a26a45215c147f7cfa28bbb3c76f850d6e" translate="yes" xml:space="preserve">
          <source>The code server uses module &lt;code&gt;erl_prim_loader&lt;/code&gt; in ERTS (possibly through &lt;code&gt;erl_boot_server&lt;/code&gt;) to read code files from archives. However, the functions in &lt;code&gt;erl_prim_loader&lt;/code&gt; can also be used by other applications to read files from archives. For example, the call &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; would list the contents of a directory inside an archive. See &lt;code&gt;erl_prim_loader(3)&lt;/code&gt;.</source>
          <target state="translated">代码服务器使用ERTS中的 &lt;code&gt;erl_prim_loader&lt;/code&gt; 模块（可能通过 &lt;code&gt;erl_boot_server&lt;/code&gt; ）从存档中读取代码文件。但是，其他应用程序也可以使用 &lt;code&gt;erl_prim_loader&lt;/code&gt; 中的函数从存档中读取文件。例如，调用 &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; 将列出存档中目录的内容。参见 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81d555b71a144677a82f4345434092ac25f42ef" translate="yes" xml:space="preserve">
          <source>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</source>
          <target state="translated">创建一个运行该跟踪函数的进程,并将该进程设置为系统跟踪器的代码可以是这样的。</target>
        </trans-unit>
        <trans-unit id="01443bf8a10ddd3106bef27d3577d522575836f5" translate="yes" xml:space="preserve">
          <source>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an &lt;code&gt;AccessContext&lt;/code&gt;. Currently, the following access contexts are supported:</source>
          <target state="translated">在活动内部执行的代码可以包含一系列表操作功能，这些功能在 &lt;code&gt;AccessContext&lt;/code&gt; 中执行。当前，支持以下访问上下文：</target>
        </trans-unit>
        <trans-unit id="84b1eccbd4506c4d8f052231d9e0606cf91a8b80" translate="yes" xml:space="preserve">
          <source>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function &lt;code&gt;transaction/1&lt;/code&gt; returns the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;.</source>
          <target state="translated">在事务内部执行的代码可以由一系列表操作函数组成。如果由于用户错误或某个特定表不可用而导致事务内部出现问题，则整个事务终止，函数 &lt;code&gt;transaction/1&lt;/code&gt; 返回元组 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0cdd80f24fdd34e8443becb251df980268f8ee4" translate="yes" xml:space="preserve">
          <source>The code uses the &lt;code&gt;OTP_RELEASE&lt;/code&gt; macro to conditionally select code depending on release.</source>
          <target state="translated">该代码使用 &lt;code&gt;OTP_RELEASE&lt;/code&gt; 宏根据发行版有条件地选择代码。</target>
        </trans-unit>
        <trans-unit id="30306274860dd65567cf17418a71525ff9fb2984" translate="yes" xml:space="preserve">
          <source>The code write permission &quot;lock&quot; seized in step 1 is the same as used by code loading. This will ensure that only one process at a time can stage new trace settings but it will also prevent concurrent code loading and make sure we see a consistent view of the beam code during the entire sequence.</source>
          <target state="translated">在步骤1中查获的代码写入权限 &quot;锁 &quot;与代码加载所使用的相同。这将确保一次只有一个进程可以阶段性地进行新的跟踪设置,但它也将防止并发代码加载,并确保我们在整个序列中看到一致的梁代码视图。</target>
        </trans-unit>
        <trans-unit id="0b9b7b5c18b986e4dcb6724716523fe3e0859402" translate="yes" xml:space="preserve">
          <source>The codec name is the name of the codec with which all messages in the &lt;code&gt;message_list()&lt;/code&gt; has been encoded.</source>
          <target state="translated">编解码器名称是已使用 &lt;code&gt;message_list()&lt;/code&gt; 中的所有消息进行编码的编解码器的名称。</target>
        </trans-unit>
        <trans-unit id="95a66f00b0729fc83f03c227254f16b97fe36011" translate="yes" xml:space="preserve">
          <source>The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">这些代码被命名为 &lt;code&gt;SSH_FX_*&lt;/code&gt; ，它们被转换为星号的小写字母。例如，错误代码 &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; 将导致 &lt;code&gt;reason()&lt;/code&gt; 为 &lt;code&gt;no_such_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17206be2c27dcf13c38e698754daddf2e853496a" translate="yes" xml:space="preserve">
          <source>The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts.</source>
          <target state="translated">收集器收集跟踪事件,并按照时间戳进行排序。时间戳可以反映实际跟踪数据生成的时间(trace_ts),也可以反映跟踪数据转化为事件记录的时间(event_ts)。如果跟踪数据中缺少时间戳(erlang:trace/4中缺少时间戳选项),trace_ts将被设置为event_ts。</target>
        </trans-unit>
        <trans-unit id="351503ceae71d258dda945d06961ceabf3006742" translate="yes" xml:space="preserve">
          <source>The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid().</source>
          <target state="translated">收集器有一个内置的字典服务。任何术语都可以作为值存储在字典中,并与一个唯一的键绑定。当用现有的键插入新的值时,新的值将覆盖现有的值。进程可以通过使用{subscriber,pid()}作为字典键来订阅字典更新。所有的字典更新将被传播到与模式{{subscriber,'_'},'_'}匹配的订阅者进程,其中第一个'_'被解释为pid()。</target>
        </trans-unit>
        <trans-unit id="aa24630865ec2d27852697992e86dceb8f652e0b" translate="yes" xml:space="preserve">
          <source>The column where the token begins.</source>
          <target state="translated">令牌开始的那一列。</target>
        </trans-unit>
        <trans-unit id="630fd19e25bb44d0c633fc41e9f2c893976f1cf6" translate="yes" xml:space="preserve">
          <source>The columns are: CNT - the number of times the function has been called, ACC - the time spent in the function including called functions, and OWN - the time spent in the function not including called functions.</source>
          <target state="translated">这几栏是:CNT--函数被调用的次数,ACC--包括被调用函数在内的函数所用时间,OWN--不包括被调用函数在内的函数所用时间。</target>
        </trans-unit>
        <trans-unit id="dba186e396734b41173da2352f4bdf8aa2299d12" translate="yes" xml:space="preserve">
          <source>The combined size of message buffers associated with the process.</source>
          <target state="translated">与进程相关的消息缓冲区的总大小。</target>
        </trans-unit>
        <trans-unit id="cd9eaf4fbf041c4980649b3adc6f08d99e41387b" translate="yes" xml:space="preserve">
          <source>The command for starting the emulator. Defaults to &lt;code&gt;erl&lt;/code&gt; in the same directory as the &lt;code&gt;erlc&lt;/code&gt; program itself, or, if it does not exist, &lt;code&gt;erl&lt;/code&gt; in any of the directories specified in environment variable &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">用于启动仿真器的命令。默认为 &lt;code&gt;erl&lt;/code&gt; 在同一目录 &lt;code&gt;erlc&lt;/code&gt; 程序本身，或者，如果不存在的话， &lt;code&gt;erl&lt;/code&gt; 在任何环境变量指定的目录 &lt;code&gt;PATH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6501b3dc9f9f189fcbf95012d0127834e2f9cf" translate="yes" xml:space="preserve">
          <source>The command routine takes three parameters; the handle returned for the port by &lt;code&gt;uds_start&lt;/code&gt;, which is a pointer to the internal port structure, the data buffer, and the length of the data buffer. The buffer is the data sent from Erlang (a list of bytes) converted to an C array (of bytes).</source>
          <target state="translated">该命令例程采用三个参数。 &lt;code&gt;uds_start&lt;/code&gt; 返回的端口句柄，它是指向内部端口结构，数据缓冲区和数据缓冲区长度的指针。缓冲区是从Erlang发送的数据（字节列表），转换为C数组（字节）。</target>
        </trans-unit>
        <trans-unit id="aefc7b65db056c9f7f1b6802b3b0d8045a51356b" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the SSL/TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">用于指定SSL / TLS选项的命令行参数名为 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; ，后跟一对SSL选项及其值。参数 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 可以重复任意次。</target>
        </trans-unit>
        <trans-unit id="feabeafa48780ef513e8f91d43f78fb2ecb53e4a" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">用于指定TLS选项的命令行参数名为 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; ，其后是成对的SSL选项及其值。参数 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 可以重复任意次。</target>
        </trans-unit>
        <trans-unit id="ef15ee0f0b965418b78c604ce208be1ebb9ac987" translate="yes" xml:space="preserve">
          <source>The command-line flag &lt;code&gt;-init_debug&lt;/code&gt; makes the &lt;code&gt;init&lt;/code&gt; process write some debug information while interpreting the boot script:</source>
          <target state="translated">命令行标志 &lt;code&gt;-init_debug&lt;/code&gt; 使 &lt;code&gt;init&lt;/code&gt; 进程在解释启动脚本时写入一些调试信息：</target>
        </trans-unit>
        <trans-unit id="b095d3532fdf5b6b34b9ca43172bd2a70ed42870" translate="yes" xml:space="preserve">
          <source>The commands below are the built-in shell commands that are always available. In most system the commands listed in the &lt;code&gt;&lt;a href=&quot;c&quot;&gt;c(3)&lt;/a&gt;&lt;/code&gt; module are also available in the shell.</source>
          <target state="translated">以下命令是始终可用的内置shell命令。在大多数系统中，外壳程序中也提供了 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;c(3)&lt;/a&gt;&lt;/code&gt; 模块中列出的命令。</target>
        </trans-unit>
        <trans-unit id="06c50b8e09545158899f6b79057dc3ebb405cca8" translate="yes" xml:space="preserve">
          <source>The comment for &lt;code&gt;driver_output_binary&lt;/code&gt; also applies for &lt;code&gt;driver_outputv&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;driver_output_binary&lt;/code&gt; 的注释也适用于 &lt;code&gt;driver_outputv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1280084aa272a9d5d8e48fb9a3f8a4bc2a35a205" translate="yes" xml:space="preserve">
          <source>The comment for the file in the zip archive</source>
          <target state="translated">压缩包中文件的注释</target>
        </trans-unit>
        <trans-unit id="576cdebf96e8a6e4c9f5687b31e5fae369f7ae54" translate="yes" xml:space="preserve">
          <source>The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.</source>
          <target state="translated">常见的I/O协议从一开始就存在于OTP中,但一直没有记录在案,多年来也在不断发展。在Robert Virding的理由附录中,描述了最初的I/O协议。本节介绍当前的I/O协议。</target>
        </trans-unit>
        <trans-unit id="615ef8c10dad53dc0e37ab3cc2865c03f16fe578" translate="yes" xml:space="preserve">
          <source>The communication protocol between sub-agents is the normal message passing which is used in distributed Erlang systems. This implies that sub-agent communication is very efficient compared to SMUX, DPI, AgentX, and similar protocols.</source>
          <target state="translated">子代理之间的通信协议是分布式Erlang系统中使用的普通消息传递。这意味着与SMUX、DPI、AgentX以及类似协议相比,子代理之间的通信非常高效。</target>
        </trans-unit>
        <trans-unit id="95e038ffe06742bd9a3eacaa7f1ab1768afde277" translate="yes" xml:space="preserve">
          <source>The community information should be stored in a file called &lt;code&gt;community.conf&lt;/code&gt;. It must be present if the agent is configured for SNMPv1 or SNMPv2c.</source>
          <target state="translated">社区信息应存储在名为 &lt;code&gt;community.conf&lt;/code&gt; 的文件中。如果为SNMPv1或SNMPv2c配置了代理，则该代理必须存在。</target>
        </trans-unit>
        <trans-unit id="ae1b5318f7be646ee745ed8d6cfbf8aaace9d57c" translate="yes" xml:space="preserve">
          <source>The compilation option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the compiler to have the abstract code stored in the &lt;code&gt;abstract_code&lt;/code&gt; chunk in the Beam file (for debugging purposes).</source>
          <target state="translated">可以将编译选项 &lt;code&gt;debug_info&lt;/code&gt; 指定给编译器，以将抽象代码存储在Beam文件的 &lt;code&gt;abstract_code&lt;/code&gt; 块中（出于调试目的）。</target>
        </trans-unit>
        <trans-unit id="63df141c1104124fe397af774c48987f851c9c8e" translate="yes" xml:space="preserve">
          <source>The compile server can be used to potentially speed up the build of multi-file projects by avoiding to start an Erlang system for each file to compile. Whether it will speed up the build depends on the nature of the project and the build machine.</source>
          <target state="translated">编译服务器可以用来加快多文件项目的编译速度,避免为每个文件启动一个Erlang系统进行编译。它是否能加快编译速度取决于项目的性质和编译机。</target>
        </trans-unit>
        <trans-unit id="992839cad735d18aaa4ef05287e210db80780266" translate="yes" xml:space="preserve">
          <source>The compile time of the emulator running the originating node</source>
          <target state="translated">运行原始节点的仿真器的编译时间。</target>
        </trans-unit>
        <trans-unit id="77923285d15f6d1638ca1085b0ea9ec5d8971d25" translate="yes" xml:space="preserve">
          <source>The compiled files of the imported MIBs must be present in the current directory, or a directory in the current path. The path is supplied with the &lt;code&gt;{i, Path}&lt;/code&gt; option, for example:</source>
          <target state="translated">导入的MIB的编译文件必须存在于当前目录或当前路径中的目录中。路径随 &lt;code&gt;{i, Path}&lt;/code&gt; 选项一起提供，例如：</target>
        </trans-unit>
        <trans-unit id="6fb2caaa7af06a5fa0ebe6a620c35148002139db" translate="yes" xml:space="preserve">
          <source>The compiler also understands that assigning to '_' means that the value will not used. Therefore, the code in the following example will also be optimized:</source>
          <target state="translated">编译器也明白,分配给'_'意味着该值不会被使用。因此,下面例子中的代码也将被优化。</target>
        </trans-unit>
        <trans-unit id="a0aa4f7feea676dc9f8b66e36fffc1af3c1c40f5" translate="yes" xml:space="preserve">
          <source>The compiler and other compile-time functions can also be started from the Erlang shell. Here follows a brief description of the primary functions. For a complete description of each function, see module &lt;code&gt;asn1ct&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">编译器和其他编译时函数也可以从Erlang Shell启动。以下是主要功能的简要说明。有关每个功能的完整说明，请参见《 &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt; 中的模块 &lt;code&gt;asn1ct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd83f86086df5c8234f8a9ae71fc626e0a86c59a" translate="yes" xml:space="preserve">
          <source>The compiler automatically inserts the two special, exported functions into each module:</source>
          <target state="translated">编译器会自动将这两个特殊的、导出的函数插入到每个模块中。</target>
        </trans-unit>
        <trans-unit id="0aa023f79e7e9fc3b1f355a1f8fb5632ee1a7886" translate="yes" xml:space="preserve">
          <source>The compiler can also be accessed from the OS prompt, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">也可以从OS提示符下访问编译器，请参见ERTS中的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="dcd47ca4ce5f90e9af16a0a668c0506b2926c5f4" translate="yes" xml:space="preserve">
          <source>The compiler can also inline various list manipulation functions from the module &lt;code&gt;list&lt;/code&gt; in STDLIB.</source>
          <target state="translated">编译器还可以从STDLIB中的模块 &lt;code&gt;list&lt;/code&gt; 内联各种列表操作功能。</target>
        </trans-unit>
        <trans-unit id="246aeec2b67ad60a1d79d7bfcb202381eb810d23" translate="yes" xml:space="preserve">
          <source>The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, &lt;code&gt;function_clause&lt;/code&gt; exceptions are converted to similar &lt;code&gt;case_clause&lt;/code&gt; exceptions.</source>
          <target state="translated">编译器可以在Erlang模块中进行函数内联。内联意味着将对函数的调用替换为函数主体，并将参数替换为实际值。保留语义，除非内联代码中生成异常。据报道，内联函数在插入内联函数时发生异常。同样， &lt;code&gt;function_clause&lt;/code&gt; 异常将转换为类似的 &lt;code&gt;case_clause&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="ba61e82e2483a5192ba41d5a737c2246810798a9" translate="yes" xml:space="preserve">
          <source>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</source>
          <target state="translated">编译器只有在知道匹配上下文不会被共享的情况下,才能进行这种优化。如果会被共享,那么Erlang的函数属性(也叫引用透明度)就会被破坏。</target>
        </trans-unit>
        <trans-unit id="df9982300695d7d925cce5cf1cdd61f21ef202d8" translate="yes" xml:space="preserve">
          <source>The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler tries to evaluate &lt;code&gt;1/0&lt;/code&gt;, detects that it will cause an exception, and emits a warning. However, the compiler is silent about the similar expression, &lt;code&gt;X/0&lt;/code&gt;, because of the variable in it. Thus, the compiler does not even try to evaluate and therefore it emits no warnings.</source>
          <target state="translated">编译器不会警告不要尝试优化的表达式。例如，编译器尝试评估 &lt;code&gt;1/0&lt;/code&gt; ，检测到它将导致异常，并发出警告。但是，由于其中包含变量，因此编译器对类似表达式 &lt;code&gt;X/0&lt;/code&gt; 保持沉默。因此，编译器甚至不会尝试评估，因此不会发出警告。</target>
        </trans-unit>
        <trans-unit id="326ce5bdd2edeffbb0eff29680c2a35b2a0c7613" translate="yes" xml:space="preserve">
          <source>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</source>
          <target state="translated">编译器会计算出一个变量是否未被使用。以下每个函数都会生成相同的代码。</target>
        </trans-unit>
        <trans-unit id="736c83a9c909e8b6995b93aa5a592a8cfd21644b" translate="yes" xml:space="preserve">
          <source>The compiler generates a &lt;code&gt;decode_part/2&lt;/code&gt; function when exclusive decode is chosen. This function decodes the parts that were left undecoded during the exclusive decode.</source>
          <target state="translated">选择独占解码时，编译器将生成 &lt;code&gt;decode_part/2&lt;/code&gt; 函数。此功能将对在独占解码期间未解码的部分进行解码。</target>
        </trans-unit>
        <trans-unit id="e4f37f01f0c640d21fe0c086a15f5624a101666e" translate="yes" xml:space="preserve">
          <source>The compiler generates the following files:</source>
          <target state="translated">编译器会生成以下文件。</target>
        </trans-unit>
        <trans-unit id="8ae89eb6c8e241efda8fbeedb553bd086502de6d" translate="yes" xml:space="preserve">
          <source>The compiler handles the &lt;code&gt;IMPORT&lt;/code&gt; statement. It is important to import the compiled file and not the ASN.1 (source) file. A MIB must be recompiled to make changes visible to other MIBs importing it.</source>
          <target state="translated">编译器处理 &lt;code&gt;IMPORT&lt;/code&gt; 语句。重要的是导入已编译的文件，而不是ASN.1（源）文件。必须重新编译MIB，以使其他导入它的MIB可以看到更改。</target>
        </trans-unit>
        <trans-unit id="ef890ca9c7e8253725d98c0071846009690a22a4" translate="yes" xml:space="preserve">
          <source>The compiler internally rewrites the latter code into the former.</source>
          <target state="translated">编译器内部将后者的代码改写成前者。</target>
        </trans-unit>
        <trans-unit id="1f2b065f3c16869915d5310d49119f53343cacb9" translate="yes" xml:space="preserve">
          <source>The compiler is located in the module &lt;code&gt;compile&lt;/code&gt; (see the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler).</source>
          <target state="translated">编译器位于模块 &lt;code&gt;compile&lt;/code&gt; 中（请参见Compiler中的 &lt;code&gt;compile(3)&lt;/code&gt; 手册页）。</target>
        </trans-unit>
        <trans-unit id="a6b51b2ed2bc7f46e25bc64dda5c32ec191ce10a" translate="yes" xml:space="preserve">
          <source>The compiler is started by &lt;code&gt;asn1ct:compile/1&lt;/code&gt; with default options, or &lt;code&gt;asn1ct:compile/2&lt;/code&gt; if explicit options are given.</source>
          <target state="translated">编译器由带有默认选项的 &lt;code&gt;asn1ct:compile/1&lt;/code&gt; 启动，如果给出了显式选项， &lt;code&gt;asn1ct:compile/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7898d48c7095ef7080834ae1df25bb02756bfa73" translate="yes" xml:space="preserve">
          <source>The compiler parses the SMI file and associates each table or variable with an instrumentation function (see the figure &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt;). The actual instrumentation functions are not needed at MIB compile time, only their names.</source>
          <target state="translated">编译器解析SMI文件，并将每个表或变量与检测功能相关联（请参见图 &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt; ）。在MIB编译时不需要实际的检测功能，而只需其名称即可。</target>
        </trans-unit>
        <trans-unit id="29ced82347a929ec3d64773bda03ab575e2ebdf7" translate="yes" xml:space="preserve">
          <source>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts &lt;code&gt;Buffer&lt;/code&gt; from a match context to a sub binary (or do nothing if &lt;code&gt;Buffer&lt;/code&gt; is a binary already).</source>
          <target state="translated">编译器删除了第二和第三子句中的子二进制文件，并在第一子句中添加了一条指令，该指令将 &lt;code&gt;Buffer&lt;/code&gt; 从匹配上下文转换为子二进制文件（如果 &lt;code&gt;Buffer&lt;/code&gt; 已经是二进制文件，则不执行任何操作）。</target>
        </trans-unit>
        <trans-unit id="3e19fdc6630343c3d28603ee64052ea9f7070d01" translate="yes" xml:space="preserve">
          <source>The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt;.</source>
          <target state="translated">编译器以二进制形式返回目标代码，而不是创建目标文件。如果成功，编译器将返回 &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c32c93e25c9ed677dd8b2dc76e27b04c3f91ef2" translate="yes" xml:space="preserve">
          <source>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</source>
          <target state="translated">编译器试图避免生成创建一个子二进制的代码,但不久之后又创建一个新的匹配上下文并丢弃子二进制。而不是创建一个子二进制,匹配上下文被保留。</target>
        </trans-unit>
        <trans-unit id="93271cc943214ad52c731246bc1c6f5f502dc5df" translate="yes" xml:space="preserve">
          <source>The compiler understands the module attribute &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; and issues warnings about missing callback functions, for example:</source>
          <target state="translated">编译器了解模块属性 &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; 并发出有关缺少回调函数的警告，例如：</target>
        </trans-unit>
        <trans-unit id="b4e5de69deb63fd9f8e518572799240cd4dbb515" translate="yes" xml:space="preserve">
          <source>The compiler will compress the generated object code, which can be useful for embedded systems.</source>
          <target state="translated">编译器会对生成的对象代码进行压缩,这对嵌入式系统很有用。</target>
        </trans-unit>
        <trans-unit id="9f6ca4a1bcb2bb18eb6fa6ea91946375fe8b63fd" translate="yes" xml:space="preserve">
          <source>The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about &lt;code&gt;bin_opt_info&lt;/code&gt; in the Efficiency Guide.</source>
          <target state="translated">编译器将发出有关二进制匹配优化（成功与否）的信息性警告。有关更多信息，请参见《效率指南》中有关 &lt;code&gt;bin_opt_info&lt;/code&gt; 的部分。</target>
        </trans-unit>
        <trans-unit id="272c69253881a0e58a00b19dd140c32886a5264d" translate="yes" xml:space="preserve">
          <source>The compiler will generate code similar to this:</source>
          <target state="translated">编译器会生成类似这样的代码。</target>
        </trans-unit>
        <trans-unit id="a11970730484c5ef03d8b57a7d8f1200a3e88258" translate="yes" xml:space="preserve">
          <source>The complement message, from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, is only sent if node &lt;code&gt;A&lt;/code&gt; initially sent an old name message and received back a new challenge message from node &lt;code&gt;B&lt;/code&gt;. It contains complementary information missing in the initial old name message from node &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">仅当节点 &lt;code&gt;A&lt;/code&gt; 最初发送旧名称消息并从节点 &lt;code&gt;B&lt;/code&gt; 接收回新质询消息时，才发送从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;B&lt;/code&gt; 的补充消息。它包含来自节点 &lt;code&gt;A&lt;/code&gt; 的初始旧名称消息中缺少的补充信息。</target>
        </trans-unit>
        <trans-unit id="f22d63ebef153d116952bd4b9cdc3d70b1deac48" translate="yes" xml:space="preserve">
          <source>The complete build environment is required while running &lt;code&gt;otp_patch_apply&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;otp_patch_apply&lt;/code&gt; 时需要完整的构建环境。</target>
        </trans-unit>
        <trans-unit id="991eb99483640f8d2cb258dac8893f15f032e622" translate="yes" xml:space="preserve">
          <source>The complete content of the history buffer can be written to a configuration file by calling &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt;. Selected entries from the history can be written by calling &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt;, where &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the history entries to write. Moreover, the history buffer is always dumped to &lt;code&gt;ttb_last_config&lt;/code&gt; when &lt;code&gt;ttb:stop/0,1&lt;/code&gt; is called.</source>
          <target state="translated">可以通过调用 &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt; 将历史记录缓冲区的完整内容写入配置文件。可以通过调用 &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt; 来写入历史记录中的选定条目，其中 &lt;code&gt;NumList&lt;/code&gt; 是指出要写入的历史记录条目的整数列表。此外， &lt;code&gt;ttb_last_config&lt;/code&gt; &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 时，历史记录缓冲区总是转储到ttb_last_config。</target>
        </trans-unit>
        <trans-unit id="06275c17581f810fa4579c2f0ccfc4b29d12ac2f" translate="yes" xml:space="preserve">
          <source>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</source>
          <target state="translated">完整的匹配模式总是给出列表中的第一个返回值,其余的子模式按照它们在正则表达式中出现的顺序添加。</target>
        </trans-unit>
        <trans-unit id="3a13431e36ebb44eb9fa84700a106f85f4b1ac47" translate="yes" xml:space="preserve">
          <source>The complete path to the Erlang emulator. Never use the &lt;code&gt;werl&lt;/code&gt; program for this. Defaults to the &lt;code&gt;erl.exe&lt;/code&gt; in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. When release handling is used, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Erlang仿真器的完整路径。切勿为此使用 &lt;code&gt;werl&lt;/code&gt; 程序。默认为与 &lt;code&gt;erl.exe&lt;/code&gt; 在同一目录中的 &lt;code&gt;erlsrv.exe&lt;/code&gt; 。使用发行版处理时， &lt;code&gt;start_erl.exe&lt;/code&gt; 其设置为类似于start_erl.exe的程序。</target>
        </trans-unit>
        <trans-unit id="4b9e994208ced53dcfba8c8850e25b0dd795cc2c" translate="yes" xml:space="preserve">
          <source>The complete specification for the bit syntax appears in the &lt;code&gt;Reference Manual&lt;/code&gt;.</source>
          <target state="translated">有关位语法的完整规范，请参见《 &lt;code&gt;Reference Manual&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b9f520763856efe6e5a044f5a2e1ee496c05b06" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;A -- B&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;. That is, it becomes very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists.</source>
          <target state="translated">&lt;code&gt;A -- B&lt;/code&gt; 的复杂度与 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 成正比。也就是说，如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 都是长列表，它将变得非常慢。</target>
        </trans-unit>
        <trans-unit id="fab2bbfeb9763c6bdcd0f510a645aceccf277fc7" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;, meaning that it is very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists. (If both lists are long, it is a much better choice to use ordered lists and &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lists:subtract(A, B)&lt;/code&gt; 的复杂度：减（A，B）与 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 成正比，这意味着如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 均为长列表，则速度非常慢。 （如果两个列表都很长，那么最好使用有序列表和 &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fc7384b856b0bd8d7f49596a4fe364f88395e2b" translate="yes" xml:space="preserve">
          <source>The complexity on set operations is bounded by either &lt;strong&gt;O(|S|)&lt;/strong&gt; or &lt;strong&gt;O(|T| * log(|S|))&lt;/strong&gt;, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&amp;gt; 100-200 elements), and repeatedly testing for membership in the current set.</source>
          <target state="translated">集合操作的复杂度受&lt;strong&gt;O（| S |）&lt;/strong&gt;或&lt;strong&gt;O（| T | * log（| S |））的限制&lt;/strong&gt;，其中S是给定的最大集合，取决于哪个对任何特定函数调用最快。对于在几乎相等大小的集合上进行操作，此实现比直接使用有序列表集合慢大约3倍。但是，对于大小非常不同的集合，此解决方案可以任意更快。在实际情况下，通常是10-100倍。此实现特别适合于一次累加几个元素，构建一个大型集合（&amp;gt; 100-200个元素），并反复测试当前集合中的成员资格。</target>
        </trans-unit>
        <trans-unit id="1f0db048fd959939f98a5ab5ffcb76b17f2161e3" translate="yes" xml:space="preserve">
          <source>The component &lt;code&gt;b&lt;/code&gt; is treated as an original component when encoding a message. In this case, as it is not an optional element, it must be encoded.</source>
          <target state="translated">在编码消息时，组件 &lt;code&gt;b&lt;/code&gt; 被视为原始组件。在这种情况下，因为它不是可选元素，所以必须对其进行编码。</target>
        </trans-unit>
        <trans-unit id="95df5a7aa19b0879416444bcc5ff1ff82e16895f" translate="yes" xml:space="preserve">
          <source>The compressed term format is as follows:</source>
          <target state="translated">压缩后的术语格式如下:</target>
        </trans-unit>
        <trans-unit id="3b034a8ca7cf564d2716f7d145e9bf7ce76cd7cc" translate="yes" xml:space="preserve">
          <source>The compression algorithm none (= no compression) is removed so compression is enforced</source>
          <target state="translated">压缩算法none(=无压缩)被删除,所以压缩被强制执行。</target>
        </trans-unit>
        <trans-unit id="1b5cdfaea7fccd1b20390cb4e9325498d3da1b59" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">压缩器和解压缩器必须使用相同的字典（请参阅 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="20f5418f59d5bf2e56046767d3d15b2e506ac3c4" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">压缩程序和解压缩程序必须使用相同的字典（请参阅 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c9ba98b827fef9b660205799a125d38d037fa2c" translate="yes" xml:space="preserve">
          <source>The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is &lt;code&gt;DBL_MIN&lt;/code&gt;, which is 2.0^(-1022).</source>
          <target state="translated">这个概念暗示精确地为零的概率非常低。如此之低，以至于实际上保证该函数永远不会返回零。它可能返回的最小数字是 &lt;code&gt;DBL_MIN&lt;/code&gt; ，它是2.0 ^（-1022）。</target>
        </trans-unit>
        <trans-unit id="943911384cb6e7518951f5974b91a80146819bfa" translate="yes" xml:space="preserve">
          <source>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames if one enables Unicode filename translation (&lt;code&gt;+fnu&lt;/code&gt;) on platforms where this is not the default.</source>
          <target state="translated">如果在未设置为默认值的平台上启用了Unicode文件名转换（ &lt;code&gt;+fnu&lt;/code&gt; ），则可以使用&amp;ldquo;原始文件名&amp;rdquo;的概念来处理编码错误的文件名。</target>
        </trans-unit>
        <trans-unit id="a5e9df0f0bca9d8678a66d1bcb07dea7aeeb1bd0" translate="yes" xml:space="preserve">
          <source>The concept of subtyping can be applied to integers and to other ASN.1 types. The details of subtyping are not explained here; for more information, see X.680. Various syntaxes are allowed when defining a type as an integer:</source>
          <target state="translated">子类型的概念可以应用于整数和其他ASN.1类型。这里不解释子类型化的细节;更多信息请参见X.680。当定义一个类型为整数时,允许使用多种语法。</target>
        </trans-unit>
        <trans-unit id="9ea91819bf64e3ece43df4e073d660a0ac1fb62c" translate="yes" xml:space="preserve">
          <source>The conceptual repository for management information is called the Management Information Base (MIB). It does not hold any data, merely a definition of what data can be accessed. A definition of an MIB is a description of a collection of managed objects.</source>
          <target state="translated">管理信息的概念库称为管理信息库(MIB)。它不保存任何数据,只是对可以访问的数据进行定义。MIB的定义是对管理对象集合的描述。</target>
        </trans-unit>
        <trans-unit id="100c3255ddc27fa6383db8b2a42e843f2130c476" translate="yes" xml:space="preserve">
          <source>The condition can be inverted by using &lt;code&gt;%unless&lt;/code&gt; instead of &lt;code&gt;%if&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;%unless&lt;/code&gt; 代替 &lt;code&gt;%if&lt;/code&gt; 来反转条件：</target>
        </trans-unit>
        <trans-unit id="1f0f7f9a82dfed01500e86c2a2936e52983cbea0" translate="yes" xml:space="preserve">
          <source>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</source>
          <target state="translated">该条件是一个正向的lookahead断言,它匹配一个可选的非字母序列,后面是一个字母。也就是说,它测试主题中是否存在至少一个字母。如果发现了一个字母,则将主体与第一个选项匹配,否则将与第二个选项匹配。这种模式可以匹配 dd-aaa-dd 或 dd-dd-dd 两种形式之一的字符串,其中 aaa 是字母,dd 是数字。</target>
        </trans-unit>
        <trans-unit id="2bb2d4ddfb9fd4340f3bf62302b4368f672d1819" translate="yes" xml:space="preserve">
          <source>The condition is specified by the user as a module name &lt;code&gt;CModule&lt;/code&gt; and a function name &lt;code&gt;CFunction&lt;/code&gt;. When a process reaches the breakpoint, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; is evaluated. If and only if this function call returns &lt;code&gt;true&lt;/code&gt;, the process stops. If the function call returns &lt;code&gt;false&lt;/code&gt;, the breakpoint is silently ignored.</source>
          <target state="translated">用户将条件指定为模块名称 &lt;code&gt;CModule&lt;/code&gt; 和函数名称 &lt;code&gt;CFunction&lt;/code&gt; 。当进程到达断点时，将评估 &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; 。当且仅当此函数调用返回 &lt;code&gt;true&lt;/code&gt; 时，过程才会停止。如果函数调用返回 &lt;code&gt;false&lt;/code&gt; ，则断点将被忽略。</target>
        </trans-unit>
        <trans-unit id="f7986bbea85397da9d57d44bc07228d7fb46c1a2" translate="yes" xml:space="preserve">
          <source>The conditional test is performed by calling &lt;code&gt;Module:Name(Bindings)&lt;/code&gt;, where &lt;code&gt;Bindings&lt;/code&gt; is the current variable bindings. The function must return &lt;code&gt;true&lt;/code&gt; (break) or &lt;code&gt;false&lt;/code&gt; (do not break). To retrieve the value of a variable &lt;code&gt;Var&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 来执行条件测试，其中 &lt;code&gt;Bindings&lt;/code&gt; 是当前变量绑定。该函数必须返回 &lt;code&gt;true&lt;/code&gt; （中断）或 &lt;code&gt;false&lt;/code&gt; （不中断）。要获取变量 &lt;code&gt;Var&lt;/code&gt; 的值，请使用 &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e22cdbb695181f6db56e9e8f9255cb87d1e5c71" translate="yes" xml:space="preserve">
          <source>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</source>
          <target state="translated">范围请求的条件不满足。响应不能作为范围请求处理,而必须作为普通的获取请求处理。</target>
        </trans-unit>
        <trans-unit id="d2a1a0885cb8c3972db243784463cc998671043e" translate="yes" xml:space="preserve">
          <source>The config file &lt;code&gt;ex3.config&lt;/code&gt; has the contents:</source>
          <target state="translated">配置文件 &lt;code&gt;ex3.config&lt;/code&gt; 包含以下内容：</target>
        </trans-unit>
        <trans-unit id="1c7d9b54f9813dcda9a518f9cbb3355ce28a2103" translate="yes" xml:space="preserve">
          <source>The config file directives stored as key-value tuples in an ETS table. Depicted &lt;code&gt;config_db()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">配置文件指令以键值元组的形式存储在ETS表中。函数类型声明中描述的 &lt;code&gt;config_db()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c180f4dced667f5747360888d336f97b780f3ef" translate="yes" xml:space="preserve">
          <source>The configuration can be changed during runtime. This is done with the functions &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">可以在运行时更改配置。这是通过 &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; 和megaco &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt; 函数完成的</target>
        </trans-unit>
        <trans-unit id="6c0742cfd72a2d898508fa85616b5365c6647a68" translate="yes" xml:space="preserve">
          <source>The configuration created by &lt;code&gt;erts_alloc_config&lt;/code&gt; may perform bad, ever horrible, for runtime scenarios that are very different from the ones saved when creating the configuration. You are, therefore, advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the applications run when the configuration was made are changed, or if the load on the applications have changed since the configuration was made. You are also advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the Erlang runtime system used is changed.</source>
          <target state="translated">对于与创建配置时保存的运行时场景非常不同的运行时场景，由 &lt;code&gt;erts_alloc_config&lt;/code&gt; 创建的配置可能执行得很糟糕，甚至令人恐惧。因此，如果在进行配置时运行的应用程序已更改，或者自进行配置以来应用程序的负载已更改，则建议您重新运行 &lt;code&gt;erts_alloc_config&lt;/code&gt; 。如果更改了所使用的Erlang运行时系统，还建议您重新运行 &lt;code&gt;erts_alloc_config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1470d083b0e1db8406286192bd8eb1c282c6bd47" translate="yes" xml:space="preserve">
          <source>The configuration data that can be modified.</source>
          <target state="translated">可以修改的配置数据。</target>
        </trans-unit>
        <trans-unit id="85fc09c0359e30e0ac0453b4dd29606f3be0cecc" translate="yes" xml:space="preserve">
          <source>The configuration file is to be called &lt;code&gt;Name.config&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is any name.</source>
          <target state="translated">该配置文件名为 &lt;code&gt;Name.config&lt;/code&gt; ，其中 &lt;code&gt;Name&lt;/code&gt; 是任何名称。</target>
        </trans-unit>
        <trans-unit id="2e343dc41431506d1bab7a8f1ff51c6eab8fb28a" translate="yes" xml:space="preserve">
          <source>The configuration file must be as for &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配置文件必须与 &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="dea2779e1cbd9f4e936b9d22bec123fd3a929a25" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;community.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件是： &lt;code&gt;community.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c155b3574ab962c920c1adb90ff1fbf8e4d0be7" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;context.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件为： &lt;code&gt;context.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f94cc61e31a7b0de35c335106254d680dc12d2e8" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件是： &lt;code&gt;notify.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a287de08efb6a6960170e4a56df71f4fd0b681e" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">配置文件中读取是： &lt;code&gt;standard.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edf952b8d588b0a93a4ac1f9d47f9ec65e928fc4" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件是： &lt;code&gt;usm.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ac382ba3d28511c043e21b8f905a371edc5d62a" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件是： &lt;code&gt;vacm.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3706f3f0276351526850c287f3491578e144daa" translate="yes" xml:space="preserve">
          <source>The configuration files are described in the SNMP User's Manual.</source>
          <target state="translated">配置文件见SNMP用户手册。</target>
        </trans-unit>
        <trans-unit id="d6aaee960bcbac0afc5716e7f7102e83e8360020" translate="yes" xml:space="preserve">
          <source>The configuration files is to have &lt;code&gt;rw-r--r--&lt;/code&gt; file privileges and be owned by root.</source>
          <target state="translated">配置文件应具有 &lt;code&gt;rw-r--r--&lt;/code&gt; 文件特权，并由root拥有。</target>
        </trans-unit>
        <trans-unit id="7d385331a206f67eef31fa2a51c3328ec0a6039b" translate="yes" xml:space="preserve">
          <source>The configuration files read are: &lt;code&gt;target_addr.conf&lt;/code&gt; and &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">读取的配置文件为： &lt;code&gt;target_addr.conf&lt;/code&gt; 和 &lt;code&gt;target_params.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="042a7891933367b39b8962f8cd2c79595dff050a" translate="yes" xml:space="preserve">
          <source>The configuration for a handler is a map with the following keys:</source>
          <target state="translated">处理机的配置是一个具有以下键的映射。</target>
        </trans-unit>
        <trans-unit id="3a5cc2ceb258634736594f44cf8266aeb733951f" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3) &lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3) &lt;/a&gt;&lt;/code&gt; 手册页中介绍了内置处理程序的配置。</target>
        </trans-unit>
        <trans-unit id="8c1a1fcfff199b6a1287871c07c285d5f0e37425" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; 手册页中介绍了内置处理程序的配置。</target>
        </trans-unit>
        <trans-unit id="3bec465458a3428115fd8e864e0c74437e5202fb" translate="yes" xml:space="preserve">
          <source>The configuration functions &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; execute, like test cases, on dedicated Erlang processes.</source>
          <target state="translated">像测试用例一样，配置函数 &lt;code&gt;init_per_suite&lt;/code&gt; 和 &lt;code&gt;end_per_suite&lt;/code&gt; 在专用的Erlang进程上执行。</target>
        </trans-unit>
        <trans-unit id="ca028bc56c7a5d8a6feb5fb00bb7ad713784158b" translate="yes" xml:space="preserve">
          <source>The configuration functions are optional. The following example is a test suite without configuration functions, including one simple test case, to check that module &lt;code&gt;mymod&lt;/code&gt; exists (that is, can be successfully loaded by the code server):</source>
          <target state="translated">配置功能是可选的。以下示例是一个不带配置功能的测试套件，其中包括一个简单的测试用例，用于检查模块 &lt;code&gt;mymod&lt;/code&gt; 是否存在（即可以由代码服务器成功加载）：</target>
        </trans-unit>
        <trans-unit id="b7ecabb96142aae8632b3c398a0652fea4462151" translate="yes" xml:space="preserve">
          <source>The configuration is created based on information about a number of runtime scenarios. It is obviously impossible to foresee every runtime scenario that can occur. The important scenarios are those that cause maximum or minimum load on specific memory allocators. Load in this context is total size of memory blocks allocated.</source>
          <target state="translated">配置是根据一些运行时场景的信息创建的。显然,不可能预见每一个可能发生的运行时场景,重要的场景是那些对特定内存分配器造成最大或最小负载的场景。重要的场景是那些对特定内存分配器造成最大或最小负载的场景。这里的负载是指分配的内存块的总大小。</target>
        </trans-unit>
        <trans-unit id="a090830d0bfa6e8b71055c052afa6781c7336637" translate="yes" xml:space="preserve">
          <source>The configuration of a &lt;code&gt;Mnesia&lt;/code&gt; system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 系统的配置以架构描述。模式是一个特殊的表，其中包含诸如表名和每个表的存储类型（即，表是否要存储在RAM中，在磁盘上还是在这两者上以及其位置）之类的信息。</target>
        </trans-unit>
        <trans-unit id="eb15a8828aadb5793353d2caed482552687928f9" translate="yes" xml:space="preserve">
          <source>The configuration of how the documentation should be rendered.</source>
          <target state="translated">配置文档的渲染方式。</target>
        </trans-unit>
        <trans-unit id="c9c07741d4c4f9e44d0dbd305d096f7efb62fc4f" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list.</source>
          <target state="translated">服务器的配置是以Erlang属性列表的形式提供的。</target>
        </trans-unit>
        <trans-unit id="50fec7a20842abcc0261e4b0c9e02b04cf3308e0" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list. For backwards compatibility, a configuration file using apache-style configuration directives is supported.</source>
          <target state="translated">服务器的配置是以 Erlang 属性列表的形式提供的。为了向后兼容,支持使用apache式配置指令的配置文件。</target>
        </trans-unit>
        <trans-unit id="42a81cb11873a89bc4dc7fee0b14edc95426ecba" translate="yes" xml:space="preserve">
          <source>The configuration option &lt;code&gt;filter_default&lt;/code&gt; specifies the behaviour if all filter functions return &lt;code&gt;ignore&lt;/code&gt;, or if no filters exist. &lt;code&gt;filter_default&lt;/code&gt; is by default set to &lt;code&gt;log&lt;/code&gt;, meaning that if all existing filters ignore a log event, Logger forwards the event to the handler callback. If &lt;code&gt;filter_default&lt;/code&gt; is set to &lt;code&gt;stop&lt;/code&gt;, Logger discards such events.</source>
          <target state="translated">配置选项 &lt;code&gt;filter_default&lt;/code&gt; 指定如果所有过滤器函数都返回 &lt;code&gt;ignore&lt;/code&gt; 或不存在任何过滤器的行为。 &lt;code&gt;filter_default&lt;/code&gt; 默认情况下设置为 &lt;code&gt;log&lt;/code&gt; ，这意味着如果所有现有过滤器都忽略日志事件，则Logger会将事件转发到处理程序回调。如果将 &lt;code&gt;filter_default&lt;/code&gt; 设置为 &lt;code&gt;stop&lt;/code&gt; ，则Logger会丢弃此类事件。</target>
        </trans-unit>
        <trans-unit id="7cbcc3590c5b004952bd57c5ea409bb2cbc75510" translate="yes" xml:space="preserve">
          <source>The configuration parameter does not exist.</source>
          <target state="translated">配置参数不存在。</target>
        </trans-unit>
        <trans-unit id="81a4addb98ae9327dd483e9ad9426add086cb215" translate="yes" xml:space="preserve">
          <source>The configuration produced by &lt;code&gt;erts_alloc_config&lt;/code&gt; may need to be manually adjusted as already stated. Do not modify the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;; instead, put your modifications in another file and load this file after the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. That is, put the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads your modification file later on the command-line than the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. If a memory allocation parameter appear multiple times, the last version of will be used, i.e., you can override parameters in the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. Doing it this way simplifies things when you want to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">所产生的构造 &lt;code&gt;erts_alloc_config&lt;/code&gt; 可能需要手动调整如已经陈述。不要修改 &lt;code&gt;erts_alloc_config&lt;/code&gt; 生成的文件；而是将您的修改放入另一个文件中，并在 &lt;code&gt;erts_alloc_config&lt;/code&gt; 生成的文件之后加载该文件。也就是说，将 &lt;code&gt;-args_file FileName&lt;/code&gt; 参数（比读取 &lt;code&gt;erts_alloc_config&lt;/code&gt; 生成的配置文件的 &lt;code&gt;-args_file FileName&lt;/code&gt; 参数）晚于命令行。如果内存分配参数多次出现，将使用的最新版本，即，您可以覆盖 &lt;code&gt;erts_alloc_config&lt;/code&gt; 生成的配置文件中的参数。。当您要重新运行 &lt;code&gt;erts_alloc_config&lt;/code&gt; 时，这样做可以简化操作。</target>
        </trans-unit>
        <trans-unit id="213a1cc6b8684b6f32c379587c37729fd6c0d583" translate="yes" xml:space="preserve">
          <source>The configuration string for this driver can be &lt;code&gt;config_server&lt;/code&gt;, if the &lt;code&gt;config_server.erl&lt;/code&gt; module that follows is compiled and exists in the code path during test execution:</source>
          <target state="translated">如果随后的 &lt;code&gt;config_server.erl&lt;/code&gt; 模块已编译并在测试执行期间位于代码路径中，则此驱动程序的配置字符串可以是 &lt;code&gt;config_server&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d419157999767488a1c56645c3a2365b2bbbcd93" translate="yes" xml:space="preserve">
          <source>The configuration term for &lt;code&gt;logger_formatter&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt;, and the following keys can be set as configuration parameters:</source>
          <target state="translated">&lt;code&gt;logger_formatter&lt;/code&gt; 的配置术语是 &lt;code&gt;map&lt;/code&gt; ，可以将以下键设置为配置参数：</target>
        </trans-unit>
        <trans-unit id="712ad0cc82e1a88f726b7f711e243ab197e28193" translate="yes" xml:space="preserve">
          <source>The configure script allows you to customize a number of parameters; type &lt;code&gt;./configure --help&lt;/code&gt; or &lt;code&gt;./configure --help=recursive&lt;/code&gt; for details. &lt;code&gt;./configure --help=recursive&lt;/code&gt; will give help for all &lt;code&gt;configure&lt;/code&gt; scripts in all applications.</source>
          <target state="translated">配置脚本允许您自定义许多参数。键入 &lt;code&gt;./configure --help&lt;/code&gt; 或 &lt;code&gt;./configure --help=recursive&lt;/code&gt; 以获取详细信息。 &lt;code&gt;./configure --help=recursive&lt;/code&gt; 将为所有应用程序中的所有 &lt;code&gt;configure&lt;/code&gt; 脚本提供帮助。</target>
        </trans-unit>
        <trans-unit id="f871702162e9fe05aae1c9e32504517869931c15" translate="yes" xml:space="preserve">
          <source>The configure script is created by the GNU autoconf utility, which checks for system specific features and then creates a number of makefiles.</source>
          <target state="translated">configure脚本是由GNU autoconf工具创建的,它检查系统的具体特性,然后创建一些makefile。</target>
        </trans-unit>
        <trans-unit id="7d4bba926aeb3883bfbd6d00a31923bc874078ac" translate="yes" xml:space="preserve">
          <source>The configure should be skipped and all tests should hopefully pass. For more details about how to use ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</source>
          <target state="translated">应该跳过配置，并希望所有测试都能通过。有关如何使用ts的更多详细信息，请运行 &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f6521bf4e434f67b356b39a99c1ade02b2e892c" translate="yes" xml:space="preserve">
          <source>The connect is done in two steps: first an internal &lt;code&gt;connection setup&lt;/code&gt; and then by calling the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function. The first step could result in an error with &lt;code&gt;Reason = connect_reason()&lt;/code&gt; and the second an error with &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt;:</source>
          <target state="translated">连接分两个步骤完成：首先是内部 &lt;code&gt;connection setup&lt;/code&gt; ，然后是通过调用用户 &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; 回调函数。第一步可能会因 &lt;code&gt;Reason = connect_reason()&lt;/code&gt; 导致错误，而第二步可能因 &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt; 导致错误：</target>
        </trans-unit>
        <trans-unit id="371ea327d46ab20111d8dd7bba591b3794f31f48" translate="yes" xml:space="preserve">
          <source>The connection attempt can be traced by setting a trace level by either using &lt;code&gt;ei_set_tracelevel&lt;/code&gt; or by setting environment variable &lt;code&gt;EI_TRACELEVEL&lt;/code&gt;. The trace levels have the following messages:</source>
          <target state="translated">可以通过使用 &lt;code&gt;ei_set_tracelevel&lt;/code&gt; 或设置环境变量 &lt;code&gt;EI_TRACELEVEL&lt;/code&gt; 设置跟踪级别来跟踪连接尝试。跟踪级别具有以下消息：</target>
        </trans-unit>
        <trans-unit id="cef16d7f5ec818bdeac2287eb2c52b738775d9e3" translate="yes" xml:space="preserve">
          <source>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</source>
          <target state="translated">只要节点是分布式节点,就必须保持与EPMD的连接。当连接关闭时,节点会自动从EPMD中取消注册。</target>
        </trans-unit>
        <trans-unit id="5cbfa81fe3ccd8a5c63ea407c66f04845f8cea33" translate="yes" xml:space="preserve">
          <source>The connection is already encrypted. The connection is not affected.</source>
          <target state="translated">连接已经被加密了。连接不受影响。</target>
        </trans-unit>
        <trans-unit id="759c06525846f46120048a080c3029be1ff31bcc" translate="yes" xml:space="preserve">
          <source>The connection is associated with the process that created it and can only be accessed through it. The reason for this is to preserve the semantics of result sets and transactions when select_count/[2,3] is called or auto_commit is turned off. Attempts to use the connection from another process will fail. This will not effect the connection. On the other hand, if the client process dies the connection will be terminated.</source>
          <target state="translated">该连接与创建它的进程相关联,并且只能通过它来访问。这样做的原因是为了在调用select_count/[2,3]或关闭auto_commit时保留结果集和事务的语义。试图使用其他进程的连接将失败。这不会影响连接。另一方面,如果客户端进程死亡,连接将被终止。</target>
        </trans-unit>
        <trans-unit id="6bd0a40ef6e388c1101ec314a27b945374892947" translate="yes" xml:space="preserve">
          <source>The connection is disallowed for some (unspecified) security reason.</source>
          <target state="translated">由于某种(未说明的)安全原因,该连接被禁止。</target>
        </trans-unit>
        <trans-unit id="f988842124188a5fc24f10cf75663bb95aaa98aa" translate="yes" xml:space="preserve">
          <source>The connection setup failed (after &lt;code&gt;nodeup&lt;/code&gt; messages were sent).</source>
          <target state="translated">连接设置失败（发送 &lt;code&gt;nodeup&lt;/code&gt; 消息后）。</target>
        </trans-unit>
        <trans-unit id="2c2c09cbaff852e46a92c401a3052832960adf16" translate="yes" xml:space="preserve">
          <source>The connection state.</source>
          <target state="translated">连接状态。</target>
        </trans-unit>
        <trans-unit id="21a557db3cf2f1855e12dfec5d40959655ffd926" translate="yes" xml:space="preserve">
          <source>The connection string is to be a connection string for postgres.</source>
          <target state="translated">连接字符串是要成为postgres的连接字符串。</target>
        </trans-unit>
        <trans-unit id="ab4adb70f93fe4eb3a4bc1933285abc2bb9e86ea" translate="yes" xml:space="preserve">
          <source>The connection to &lt;code&gt;Node&lt;/code&gt; was lost or could not be established. The function may or may not be applied.</source>
          <target state="translated">与 &lt;code&gt;Node&lt;/code&gt; 的连接丢失或无法建立。该功能可能适用也可能不适用。</target>
        </trans-unit>
        <trans-unit id="577ebba31469c1b19a854e051f7d7bcd77b95482" translate="yes" xml:space="preserve">
          <source>The connection was closed.</source>
          <target state="translated">连接被关闭。</target>
        </trans-unit>
        <trans-unit id="f85b0a947aa3ee4eeec0e9164d045d949bc237ff" translate="yes" xml:space="preserve">
          <source>The connection was disconnected (forced from the current node).</source>
          <target state="translated">连接被断开(被迫从当前节点断开)。</target>
        </trans-unit>
        <trans-unit id="faa62673d542db68465d9b4076b4c1a13a9c2ef7" translate="yes" xml:space="preserve">
          <source>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, &lt;code&gt;Mnesia&lt;/code&gt; ensures that no inconsistencies occur if Erlang, &lt;code&gt;Mnesia&lt;/code&gt;, or the computer crashes while a write operation is in progress.</source>
          <target state="translated">一致性属性可确保事务始终使DBMS处于一致状态。例如， &lt;code&gt;Mnesia&lt;/code&gt; 确保在进行写入操作时，如果Erlang， &lt;code&gt;Mnesia&lt;/code&gt; 或计算机崩溃，则不会发生任何不一致的情况。</target>
        </trans-unit>
        <trans-unit id="1ddfddbb8f225dd73ee75750b50447169433b54f" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; has value 50 (see &lt;code&gt;ct.hrl&lt;/code&gt;). At this level, all standard I/O gets printed. If a lower verbosity level is set, standard I/O printouts are ignored. Verbosity level 0 effectively turns all logging off (except from printouts made by &lt;code&gt;Common Test&lt;/code&gt; itself).</source>
          <target state="translated">常量 &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; 的值为50（请参见 &lt;code&gt;ct.hrl&lt;/code&gt; ）。在此级别上，将打印所有标准I / O。如果设置了较低的详细级别，则将忽略标准I / O打印输出。级别0会有效地关闭所有注销（ &lt;code&gt;Common Test&lt;/code&gt; 本身所做的打印输出除外）。</target>
        </trans-unit>
        <trans-unit id="44db6a31ddf9435698ec11cd4e92a6b9b7ad2879" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;u$is_bif&lt;/code&gt; will test whether the given operand refers to a BIF. For example:</source>
          <target state="translated">约束 &lt;code&gt;u$is_bif&lt;/code&gt; 将测试给定的操作数是否引用了BIF。例如：</target>
        </trans-unit>
        <trans-unit id="41f1224d66b802b926b2e31ecb1f284682edfb00" translate="yes" xml:space="preserve">
          <source>The construction &lt;code&gt;??Arg&lt;/code&gt;, where &lt;code&gt;Arg&lt;/code&gt; is a macro argument, is expanded to a string containing the tokens of the argument. This is similar to the &lt;code&gt;#arg&lt;/code&gt; stringifying construction in C.</source>
          <target state="translated">构造 &lt;code&gt;??Arg&lt;/code&gt; （其中 &lt;code&gt;Arg&lt;/code&gt; 是一个宏参数）被扩展为包含参数标记的字符串。这类似于C中的 &lt;code&gt;#arg&lt;/code&gt; 字符串化构造。</target>
        </trans-unit>
        <trans-unit id="e122203f3d8b9817a2ea30ffb99c064337701c17" translate="yes" xml:space="preserve">
          <source>The content and meaning of these messages do not need to be interpreted by the process. Instead the following function is to be called:</source>
          <target state="translated">这些消息的内容和意义不需要由进程解释。而是要调用以下函数:</target>
        </trans-unit>
        <trans-unit id="968fd451ababe1d06f33d9607e5b522cbdd869a3" translate="yes" xml:space="preserve">
          <source>The content of these variables are added to the end of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">这些变量的内容添加到 &lt;code&gt;erl&lt;/code&gt; 的命令行末尾。</target>
        </trans-unit>
        <trans-unit id="c18af4769f57f2942d42a8aca949de1aac0af981" translate="yes" xml:space="preserve">
          <source>The content of this file is &lt;strong&gt;only&lt;/strong&gt; valid if the system has been built with 'socket' (esock) support, which is the default.</source>
          <target state="translated">&lt;strong&gt;仅&lt;/strong&gt;当系统使用&amp;ldquo; socket&amp;rdquo;（套接字）（默认）支持构建时，此文件的内容&lt;strong&gt;才&lt;/strong&gt;有效。</target>
        </trans-unit>
        <trans-unit id="16b69fb0bdc6287d140f1bf18649d3746425bdf1" translate="yes" xml:space="preserve">
          <source>The content of this variable is added to the beginning of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">该变量的内容添加到 &lt;code&gt;erl&lt;/code&gt; 命令行的开头。</target>
        </trans-unit>
        <trans-unit id="9a245ccccd6f901e15ebc8675d831502211bf76e" translate="yes" xml:space="preserve">
          <source>The content-length of the document transferred.</source>
          <target state="translated">传送文件的内容长度。</target>
        </trans-unit>
        <trans-unit id="a88162e7d9c808763714e1548a612b2fffddbc1c" translate="yes" xml:space="preserve">
          <source>The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred.</source>
          <target state="translated">内容可以是任何术语,但为了简化跟踪事件的后处理,最好是一个普通的{Key,Value}元组列表。</target>
        </trans-unit>
        <trans-unit id="40ce0e904e227f1f1d80e3e97a8e2fc6da1aa9d8" translate="yes" xml:space="preserve">
          <source>The contents of a &lt;code&gt;Mnesia&lt;/code&gt; table are read into the registry.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 表的内容被读入注册表。</target>
        </trans-unit>
        <trans-unit id="63f1bf049157e992729a0f1938f590c49c434454" translate="yes" xml:space="preserve">
          <source>The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:</source>
          <target state="translated">lookbehind断言的内容是有限制的,它所匹配的所有字符串都必须有一个固定的长度。然而,如果有许多顶层的替代物,它们不一定都有相同的固定长度。因此,下面的内容是允许的。</target>
        </trans-unit>
        <trans-unit id="b15d542467bd5d0c49c3d5fddfb0a1dc700a2884" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file &lt;code&gt;ch_app.app&lt;/code&gt; for a supervision tree application like &lt;code&gt;ch_app&lt;/code&gt; looks as follows:</source>
          <target state="translated">监督树应用程序（例如 &lt;code&gt;ch_app&lt;/code&gt; )的最小 &lt;code&gt;.app&lt;/code&gt; 文件 &lt;code&gt;ch_app.app&lt;/code&gt; 的内容如下所示：</target>
        </trans-unit>
        <trans-unit id="639b540a4a0d636d1f2615d8325b2b0b321bfb43" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file for a library application &lt;code&gt;libapp&lt;/code&gt; looks as follows:</source>
          <target state="translated">库应用程序 &lt;code&gt;libapp&lt;/code&gt; 的最小 &lt;code&gt;.app&lt;/code&gt; 文件的内容如下所示：</target>
        </trans-unit>
        <trans-unit id="19e5034ffd4ea4853bdf97e8c08d5113058028a3" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">注册表的内容可以备份到&amp;ldquo;附近&amp;rdquo; Erlang节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 。您必须提供到Erlang节点的开放连接（请参阅 &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; ）。此外，在启动备份之前，必须在Erlang节点上运行 &lt;code&gt;Mnesia&lt;/code&gt; 3.0或更高版本：</target>
        </trans-unit>
        <trans-unit id="7d3ce5ee568b5e2c08421124a730a9db183b8eb2" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">注册表的内容可以在&amp;ldquo;附近&amp;rdquo; Erlang节点上备份到 &lt;code&gt;Mnesia&lt;/code&gt; 。您必须提供到Erlang节点的开放连接（请参阅 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; ）。此外，在启动备份之前，必须在Erlang节点上运行 &lt;code&gt;Mnesia&lt;/code&gt; 3.0或更高版本：</target>
        </trans-unit>
        <trans-unit id="3b51f4efadaec6a78fd43d4f67f7894facdff63a" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; 的内容在被调用的nif函数返回之前一直有效。如果nif调用返回后 &lt;code&gt;iovec&lt;/code&gt; 应该有效，则可以在 &lt;code&gt;NULL&lt;/code&gt; 环境中调用此函数。如果未提供环境，则 &lt;code&gt;iovec&lt;/code&gt; 拥有向量中的数据，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec &lt;/a&gt;&lt;/code&gt; 显式释放它。</target>
        </trans-unit>
        <trans-unit id="3123b00654d44c25109223170c4027e9b8ae5329" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; 的内容在被调用的nif函数返回之前一直有效。如果nif调用返回后 &lt;code&gt;iovec&lt;/code&gt; 应该有效，则可以在 &lt;code&gt;NULL&lt;/code&gt; 环境中调用此函数。如果未提供环境，则 &lt;code&gt;iovec&lt;/code&gt; 拥有向量中的数据，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt; 显式释放它。</target>
        </trans-unit>
        <trans-unit id="da4fbdeab301fdc5a2057978a62de987cbe0d76f" translate="yes" xml:space="preserve">
          <source>The contents of the configuration file can either be fetched from the history or specified directly as a list of &lt;code&gt;{Mod,Func,Args}&lt;/code&gt;.</source>
          <target state="translated">可以从历史记录中获取配置文件的内容，也可以直接将其指定为 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="1edda41fc99de03ce1cd51669b6fb86e783cb0c4" translate="yes" xml:space="preserve">
          <source>The contents of the source file is displayed in the &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">源文件的内容显示在&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8b2dc86a62154fcfa0997ece50bee44a97b77c" translate="yes" xml:space="preserve">
          <source>The context information should be stored in a file called &lt;code&gt;context.conf&lt;/code&gt;. The default context &lt;code&gt;&quot;&quot;&lt;/code&gt; need not be present.</source>
          <target state="translated">上下文信息应存储在名为 &lt;code&gt;context.conf&lt;/code&gt; 的文件中。默认上下文 &lt;code&gt;&quot;&quot;&lt;/code&gt; 不必存在。</target>
        </trans-unit>
        <trans-unit id="5e9be9c755c53e0d2a6b371cd0fc254f9029ad4a" translate="yes" xml:space="preserve">
          <source>The continuation of a sequence of fragmented messages looks like this:</source>
          <target state="translated">一系列碎片化信息的延续是这样的。</target>
        </trans-unit>
        <trans-unit id="b66a3e2b8c6b44620e15f4c494d018a17436828d" translate="yes" xml:space="preserve">
          <source>The continuation of the first call to the re-entrant input functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">对重入输入函数的第一次调用的继续必须为 &lt;code&gt;[]&lt;/code&gt; 。有关可重入输入方案如何工作的完整说明，请参见Armstrong，Virding和Williams：&amp;ldquo; Erlang中的并行编程&amp;rdquo;，第13章。</target>
        </trans-unit>
        <trans-unit id="bd08931a87a0bff5df1d5b202657eaee82a9ec50" translate="yes" xml:space="preserve">
          <source>The continuation pointer, that is, the return address for the current call. Usually useless for other than runtime system developers. This can be followed by the function into which the CP points, which is the function calling the current function.</source>
          <target state="translated">续航指针,也就是当前调用的返回地址。通常对除运行时系统开发人员以外的其他人员无用。后面可以是CP指向的函数,也就是调用当前函数的函数。</target>
        </trans-unit>
        <trans-unit id="ea909336d43c335fbcba40445c38198c897e80b9" translate="yes" xml:space="preserve">
          <source>The contracts specified with &lt;code&gt;-callback&lt;/code&gt; attributes in behaviour modules can be further refined by adding &lt;code&gt;-spec&lt;/code&gt; attributes in callback modules. This can be useful as &lt;code&gt;-callback&lt;/code&gt; contracts are usually generic. The same callback module with contracts for the callbacks:</source>
          <target state="translated">与指定的合同 &lt;code&gt;-callback&lt;/code&gt; 在行为模块属性可通过加入进一步细化 &lt;code&gt;-spec&lt;/code&gt; 在回调模块属性。这很有用，因为 &lt;code&gt;-callback&lt;/code&gt; 合同通常是通用的。具有回调合同的相同回调模块：</target>
        </trans-unit>
        <trans-unit id="3e6798c48093d78537c9e8593283bd4708fcad75" translate="yes" xml:space="preserve">
          <source>The control codes that we have defined are as follows:</source>
          <target state="translated">我们所定义的控制代码如下:</target>
        </trans-unit>
        <trans-unit id="7099cc27d42d7b0589281942854b91087bea547b" translate="yes" xml:space="preserve">
          <source>The control interface gets a buffer to return its value in, but is free to allocate its own buffer if the provided one is too small. The &lt;code&gt;uds_control&lt;/code&gt; code is as follows:</source>
          <target state="translated">控制接口获得一个缓冲区以返回其值，但是如果提供的缓冲区太小，则可以自由分配自己的缓冲区。的 &lt;code&gt;uds_control&lt;/code&gt; 代码如下：</target>
        </trans-unit>
        <trans-unit id="8a434b940ea607f47b9b9c9664fa9c1e4002f5da" translate="yes" xml:space="preserve">
          <source>The convention is that all modules implementing some web server functionality has the name &lt;code&gt;mod_*&lt;/code&gt;. When configuring the web server, an appropriate selection of these modules is to be present in the module directive. Notice that there are some interaction dependencies to take into account, so the order of the modules cannot be random.</source>
          <target state="translated">约定是，实现某些Web服务器功能的所有模块的名称均为 &lt;code&gt;mod_*&lt;/code&gt; 。配置Web服务器时，模块指令中将适当选择这些模块。请注意，需要考虑一些交互依赖关系，因此模块的顺序不能是随机的。</target>
        </trans-unit>
        <trans-unit id="dcdf44cdd25837172eef411728f5162a4d169998" translate="yes" xml:space="preserve">
          <source>The cookie can also be specified as a list with a single atom element.</source>
          <target state="translated">Cookie也可以用单个原子元素指定为一个列表。</target>
        </trans-unit>
        <trans-unit id="0bba610bff46dca728cdd7bc764ef95f9fb34e4c" translate="yes" xml:space="preserve">
          <source>The cookie extension has two main purposes. It allows the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports. It also allows to offload the server's state to the client. The cookie extension is enabled by default as it is a mandatory extension in RFC8446.</source>
          <target state="translated">Cookie扩展有两个主要目的。它允许服务器强制客户机在其表观网络地址上显示出可到达性(从而提供一种DoS保护措施)。这主要对非连接导向的传输有用。它还允许将服务器的状态卸载给客户端。在RFC8446中,cookie扩展是默认启用的,因为它是一个强制性扩展。</target>
        </trans-unit>
        <trans-unit id="a59a7d0400e25bda45d94942c1696b67b821c833" translate="yes" xml:space="preserve">
          <source>The cookie on the client node is set to &lt;code&gt;Cookie&lt;/code&gt; for this &lt;code&gt;rpc&lt;/code&gt; operation (used to match the server node cookie).</source>
          <target state="translated">对于此 &lt;code&gt;rpc&lt;/code&gt; 操作，客户端节点上的cookie设置为 &lt;code&gt;Cookie&lt;/code&gt; （用于匹配服务器节点cookie）。</target>
        </trans-unit>
        <trans-unit id="6205a4b626543ee584a8b3de17a0bb2edfe3da9f" translate="yes" xml:space="preserve">
          <source>The cookies are never sent in cleartext and the handshake procedure expects the client (called &lt;code&gt;A&lt;/code&gt;) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</source>
          <target state="translated">cookie绝不会以明文形式发送，并且握手过程希望客户端（称为 &lt;code&gt;A&lt;/code&gt; ）成为第一个证明它可以生成足够摘要的客户端。摘要是使用MD5消息摘要算法生成的，挑战应为随机数。</target>
        </trans-unit>
        <trans-unit id="2ecaa6909338c5156841fd64226c00c498a1c90e" translate="yes" xml:space="preserve">
          <source>The cookies are text strings that can be viewed as passwords.</source>
          <target state="translated">Cookie是可以被视为密码的文本字符串。</target>
        </trans-unit>
        <trans-unit id="1a8ed05dd2354fe2176cfcf5ee50be7c3c648bcb" translate="yes" xml:space="preserve">
          <source>The core applications ERTS, Kernel, STDLIB, and SASL never allow real soft upgrade, but require the Erlang emulator to be restarted. This is indicated to the &lt;code&gt;release_handler&lt;/code&gt; by the upgrade instruction &lt;code&gt;restart_new_emulator&lt;/code&gt;. This instruction is always the very first instruction executed, and it restarts the emulator with the new versions of the above mentioned core applications and the old versions of all other applications. When the node is back up, all other upgrade instructions are executed, making sure each application is finally running its new version.</source>
          <target state="translated">核心应用程序ERTS，内核，STDLIB和SASL不允许进行真正的软件升级，但需要重新启动Erlang仿真器。这由升级指令 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指示给 &lt;code&gt;release_handler&lt;/code&gt; 。该指令始终是执行的第一条指令，并使用上述核心应用程序的新版本和所有其他应用程序的旧版本重新启动模拟器。备份节点后，将执行所有其他升级指令，以确保每个应用程序最终都在运行其新版本。</target>
        </trans-unit>
        <trans-unit id="0fa547ec967437cac7e726eba19268112eb4cac1" translate="yes" xml:space="preserve">
          <source>The correct way to write this example is as follows:</source>
          <target state="translated">这个例子的正确写法如下。</target>
        </trans-unit>
        <trans-unit id="ff048cb1599c9ae21644f42bc221284ba85f60d6" translate="yes" xml:space="preserve">
          <source>The correctness of each application is checked as follows:</source>
          <target state="translated">每个申请的正确性检查如下:</target>
        </trans-unit>
        <trans-unit id="551bede0ac40e7793c4662c9c5f268e49a7cfe5a" translate="yes" xml:space="preserve">
          <source>The correctness of time values.</source>
          <target state="translated">时间值的正确性;</target>
        </trans-unit>
        <trans-unit id="b2a787c3a6b18144a9dd01cea8e8539d0c49480c" translate="yes" xml:space="preserve">
          <source>The corresponding Erlang assignments:</source>
          <target state="translated">对应的Erlang任务。</target>
        </trans-unit>
        <trans-unit id="f464085c70da2d1c15ec4fc3d649680a6fc01752" translate="yes" xml:space="preserve">
          <source>The corresponding Mnesia table is specified as follows:</source>
          <target state="translated">相应的Mnesia表具体如下:</target>
        </trans-unit>
        <trans-unit id="355cfe7dcddd0f236158f7c90d39becfb4d1ea88" translate="yes" xml:space="preserve">
          <source>The corresponding SNMP table would have three columns: &lt;code&gt;department&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;telno&lt;/code&gt;.</source>
          <target state="translated">相应的SNMP表将具有三列： &lt;code&gt;department&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;telno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ba81bc06294c512d15b4e936f20c56b7b7af738" translate="yes" xml:space="preserve">
          <source>The corresponding library callback was unsuccessful.</source>
          <target state="translated">对应的库回调不成功。</target>
        </trans-unit>
        <trans-unit id="3ed401667a17ba645dc4af42fafc330362e9b09e" translate="yes" xml:space="preserve">
          <source>The corresponding process or port is traced. The process or port may be a remote process or port (on another Erlang node). The node must be in the list of traced nodes (see &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">跟踪相应的进程或端口。进程或端口可以是远程进程或端口（在另一个Erlang节点上）。该节点必须在被跟踪节点的列表中（请参阅 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7fb4487b624fe2c0e433c8d91bb58ba0e2b99b60" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpCommunityTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">对应的表是SNMP-COMMUNITY-MIB中的 &lt;code&gt;snmpCommunityTable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="536e0673fdce81c6dcbd3b335e2956e57d01fa8e" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpNotifyTable&lt;/code&gt; in the SNMP-NOTIFICATION-MIB.</source>
          <target state="translated">对应的表是SNMP-NOTIFICATION-MIB中的 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6418aba8dde22da1e13b2bb9b3980fe5619feec0" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; in the SNMP-TARGET-MIB.</source>
          <target state="translated">相应的表是 &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 在SNMP-TARGET-MIB。</target>
        </trans-unit>
        <trans-unit id="ffadaae2726db08a3b84abd6faf037b185f11f98" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;usmUserTable&lt;/code&gt; in the SNMP-USER-BASED-SM-MIB.</source>
          <target state="translated">对应的表是SNMP-USER-BASED-SM-MIB中的 &lt;code&gt;usmUserTable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dfdea70a637914fff122f7c22e23e4ca4a56c8f" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; in the SNMP-TARGET-MIB and &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">相应的表是 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 在SNMP-TARGET-MIB和 &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; 在SNMP-群落-MIB。</target>
        </trans-unit>
        <trans-unit id="12ecd355d2a9f8a115a05cf588ffb85e072514b8" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;, &lt;code&gt;vacmAccessTable&lt;/code&gt; and &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">相应的表是SNMP-VIEW-BASED-ACM-MIB 中的 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ， &lt;code&gt;vacmAccessTable&lt;/code&gt; 和 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09299475ac2ec70dc802979c73301c27a76fa68a" translate="yes" xml:space="preserve">
          <source>The corresponding values were as follows:</source>
          <target state="translated">相应的数值如下:</target>
        </trans-unit>
        <trans-unit id="270bee1ebec250d3d9f95f9db65ee55f7e7e584a" translate="yes" xml:space="preserve">
          <source>The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the &lt;code&gt;unique&lt;/code&gt; option, all answers to &lt;code&gt;QH1&lt;/code&gt; would be returned followed by all answers to &lt;code&gt;QH2&lt;/code&gt;. The &lt;code&gt;unique&lt;/code&gt; option keeps the order between the remaining answers.</source>
          <target state="translated">代价是巨大的：每个返回的答案都存储在ETS表中。在返回答案之前，在ETS表中查找该答案以检查它是否已经返回。如果没有 &lt;code&gt;unique&lt;/code&gt; 选项，将返回 &lt;code&gt;QH1&lt;/code&gt; 的所有答案，然后返回 &lt;code&gt;QH2&lt;/code&gt; 的所有答案。该 &lt;code&gt;unique&lt;/code&gt; 选项保持其余的答案之间的顺序。</target>
        </trans-unit>
        <trans-unit id="949377933f7f31ae27260e61d2614522203d38cb" translate="yes" xml:space="preserve">
          <source>The counter is per listening port. Thus, if two daemons are started, one with &lt;code&gt;{max_sessions,N}&lt;/code&gt; and the other with &lt;code&gt;{max_sessions,M}&lt;/code&gt;, in total &lt;code&gt;N+M&lt;/code&gt; connections are accepted for the whole &lt;code&gt;ssh&lt;/code&gt; application.</source>
          <target state="translated">计数器是每个侦听端口。因此，如果启动两个守护程序，一个守护程序使用 &lt;code&gt;{max_sessions,N}&lt;/code&gt; ，另一个守护程序使用 &lt;code&gt;{max_sessions,M}&lt;/code&gt; ，则整个 &lt;code&gt;ssh&lt;/code&gt; 应用程序总共将接受 &lt;code&gt;N+M&lt;/code&gt; 个连接。</target>
        </trans-unit>
        <trans-unit id="672049e9dcd3a0014488ab809e18dd017dc67fc3" translate="yes" xml:space="preserve">
          <source>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</source>
          <target state="translated">崩溃报告中包含了之前存储的信息,如祖先和初始函数,终止原因,以及由于这个进程终止而终止的其他进程的信息。</target>
        </trans-unit>
        <trans-unit id="e9528cde8205383b9d47742f84a963524c2a4c48" translate="yes" xml:space="preserve">
          <source>The crashed node is distributed but has no references to other nodes.</source>
          <target state="translated">崩溃的节点是分布式的,但没有对其他节点的引用。</target>
        </trans-unit>
        <trans-unit id="7beaf4ed3a100b4464262b486f549894f0ca1c0e" translate="yes" xml:space="preserve">
          <source>The crashed node is not distributed.</source>
          <target state="translated">崩溃的节点不分布。</target>
        </trans-unit>
        <trans-unit id="ce14bb9518e3053298709463f31e4be173e33cd1" translate="yes" xml:space="preserve">
          <source>The created digraph has the same type as &lt;code&gt;Digraph&lt;/code&gt;. All vertices and edges have the default &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">创建的有向图与 &lt;code&gt;Digraph&lt;/code&gt; 具有相同的类型。所有顶点和边都有默认 &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c87493c7d1e0ec2480a156b7c0c0a9bef2ce5f3" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">创建的进程应在 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 记录中提供握手所需的回调和其他信息，并使用此记录调用 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e43aa2bf5d37514d385457e53e7dee018f509f4d" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">创建的进程应在 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 记录中提供握手所需的回调和其他信息，并使用此记录调用 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c10988c8597611573efffc7c6d796d8de4ec9158" translate="yes" xml:space="preserve">
          <source>The created supervisor process calls &lt;code&gt;Module:init/1&lt;/code&gt; to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned and all child processes have been started.</source>
          <target state="translated">创建的主管进程将调用 &lt;code&gt;Module:init/1&lt;/code&gt; 来查找有关重启策略，最大重启强度和子进程的信息。为了确保同步启动过程，在返回 &lt;code&gt;Module:init/1&lt;/code&gt; 并启动所有子进程之前，不会返回 &lt;code&gt;start_link/2,3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="524da289676a51a69540a11b458a8fd944a7b7d9" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">当 &lt;code&gt;func&lt;/code&gt; 返回或线程调用 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 时，创建的线程终止。线程的退出值可以从 &lt;code&gt;func&lt;/code&gt; 返回，也可以作为参数传递给 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 。在卸载驱动程序之前，创建线程的驱动程序负责通过 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 加入线程。无法创建&amp;ldquo;分离&amp;rdquo;线程，即不需要连接的线程。</target>
        </trans-unit>
        <trans-unit id="39edf1d66d588998727b714263ec502579dd9e7b" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">当 &lt;code&gt;func&lt;/code&gt; 返回或线程调用 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 时，创建的线程终止。线程的退出值可以从 &lt;code&gt;func&lt;/code&gt; 返回，也可以作为参数传递给 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 。在卸载驱动程序之前，创建线程的驱动程序负责通过 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 加入线程。无法创建&amp;ldquo;分离&amp;rdquo;线程，即不需要连接的线程。</target>
        </trans-unit>
        <trans-unit id="2caf2e3a9d3cd22055ea221541023c0a7f9e5f06" translate="yes" xml:space="preserve">
          <source>The creation number for a listen socket, which is calculated as (the value found in the lock-file + 1) rem 4. This creation value is also written back into the lock file, so that the next invocation of the emulator finds our value in the file.</source>
          <target state="translated">监听套接字的创建号,计算方式为(锁文件中找到的值+1)rem 4。这个创建值也会被写回锁文件中,这样仿真器的下一次调用就能在文件中找到我们的值。</target>
        </trans-unit>
        <trans-unit id="adcdb05ae9295c817de82d7381820b023af67f91" translate="yes" xml:space="preserve">
          <source>The creation number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">创建编号为pid &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f64ba9b5d10763eb9a59dc112c16b79857dd73" translate="yes" xml:space="preserve">
          <source>The creation number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">端口号 &lt;code&gt;t&lt;/code&gt; 中的创建编号。</target>
        </trans-unit>
        <trans-unit id="50c7d8a3f3ea2d88f57c174b641c9f8441bf8c61" translate="yes" xml:space="preserve">
          <source>The creation number in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 中的创建编号。</target>
        </trans-unit>
        <trans-unit id="1597c6b33ee04607a4ecaec944fa0178d3d2dc29" translate="yes" xml:space="preserve">
          <source>The creation of the specification for a target system is performed in two steps. In the first step a complete specification is generated. It will likely contain much more files than you are interested in in your customized target system. In the second step the specification will be filtered according to your filters. There you have the ability to specify filters per application as well as system wide filters. You can also select a &lt;code&gt;profile&lt;/code&gt; for your system. Depending on the &lt;code&gt;profile&lt;/code&gt;, different default filters will be used. There are three different profiles to choose from: &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;standalone&lt;/code&gt;. &lt;code&gt;development&lt;/code&gt; is default. The parameters that are affected by the &lt;code&gt;profile&lt;/code&gt; are: &lt;code&gt;incl_sys_filters&lt;/code&gt;, &lt;code&gt;excl_sys_filters&lt;/code&gt;, &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;.</source>
          <target state="translated">目标系统规范的创建分两个步骤进行。在第一步中，将生成一个完整的规范。它可能包含比您对自定义目标系统感兴趣的文件更多的文件。在第二步中，将根据您的过滤器过滤规格。您可以在其中为每个应用程序指定过滤器以及系统范围的过滤器。您也可以为系统选择一个 &lt;code&gt;profile&lt;/code&gt; 。根据 &lt;code&gt;profile&lt;/code&gt; ，将使用不同的默认过滤器。有三种不同的配置文件可供选择： &lt;code&gt;development&lt;/code&gt; ， &lt;code&gt;embedded&lt;/code&gt; 和 &lt;code&gt;standalone&lt;/code&gt; 。 &lt;code&gt;development&lt;/code&gt; 是默认的。受参数影响的参数 &lt;code&gt;profile&lt;/code&gt; 是： &lt;code&gt;incl_sys_filters&lt;/code&gt; ， &lt;code&gt;excl_sys_filters&lt;/code&gt; ， &lt;code&gt;incl_app_filters&lt;/code&gt; 和 &lt;code&gt;excl_app_filters&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0455f1d04df5058ea9aa40b1a076812ef2243c2" translate="yes" xml:space="preserve">
          <source>The creation time for the dump</source>
          <target state="translated">转储的创建时间</target>
        </trans-unit>
        <trans-unit id="65280108d9a3568933bcafdbf482cccdf0bd7634" translate="yes" xml:space="preserve">
          <source>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</source>
          <target state="translated">交叉覆盖机制允许对多个测试的模块进行覆盖分析。如果一些代码,例如一个库模块,被许多不同的测试所使用,而累积的覆盖结果是可取的,那么这种机制就很有用。</target>
        </trans-unit>
        <trans-unit id="b20f15741df0176d3ffd68b64d6a68cc69323d01" translate="yes" xml:space="preserve">
          <source>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</source>
          <target state="translated">加密应用支持在FIPS模式下使用OpenSSL,在这种情况下,只有对象模块提供的验证算法可以访问,其他通常在OpenSSL中可用的算法(如md5)或在Erlang代码中实现的算法(如SRP)被禁用。在这种情况下,只有对象模块提供的验证算法可以访问,其他通常在OpenSSL中可用的算法(如md5)或在Erlang代码中实现的算法(如SRP)被禁用。</target>
        </trans-unit>
        <trans-unit id="67aa64b8718cdca92f0e4f9624ec881b790bb44a" translate="yes" xml:space="preserve">
          <source>The cryptolib OTP is linked with, usally the one the OS uses, probably OpenSSL,</source>
          <target state="translated">OTP所链接的密码库,通常是操作系统使用的,可能是OpenSSL。</target>
        </trans-unit>
        <trans-unit id="492e509e88f1a8adb3eb77ab3f838d0078ce68f0" translate="yes" xml:space="preserve">
          <source>The current URI implementation provides support for producing and consuming standard URIs. The API is not meant to be directly exposed in a Web browser's address bar where users can basically enter free text. Application designers shall implement proper heuristics to map the input into a parsable URI.</source>
          <target state="translated">目前的URI实现提供了对生产和消费标准URI的支持。该API并不是要直接暴露在Web浏览器的地址栏中,用户基本上可以在那里输入自由文本。应用设计者应实现适当的启发式方法,将输入内容映射成可解析的URI。</target>
        </trans-unit>
        <trans-unit id="0f0da38521cbe8e331fa3581916f1bfca4dc26d7" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send a &quot;demonitor signal&quot; to the monitored entity and ignore any future results of the monitor.</source>
          <target state="translated">当前的行为可以看作是两个组合操作:异步向被监控的实体发送一个 &quot;demonitor信号&quot;,并忽略监控者未来的任何结果。</target>
        </trans-unit>
        <trans-unit id="3c2e4d473b72e94c41373ad9e09ba22c294ebb64" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send an &quot;unlink signal&quot; to the linked entity and ignore any future results of the link.</source>
          <target state="translated">当前的行为可以看作是两个组合操作:异步向被链接的实体发送一个 &quot;解除链接信号&quot;,并忽略未来任何链接的结果。</target>
        </trans-unit>
        <trans-unit id="d5b1d2a40e48d00196c6b21b7ac5dc93cf3228c9" translate="yes" xml:space="preserve">
          <source>The current function of the process. These fields do not always exist.</source>
          <target state="translated">流程的当前功能。这些字段并不总是存在。</target>
        </trans-unit>
        <trans-unit id="976f361d5fa6f84f4966eb0b28babd0491898a1f" translate="yes" xml:space="preserve">
          <source>The current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">目前的实现假设对同一主机、端口组合的请求将使用相同的socket选项。</target>
        </trans-unit>
        <trans-unit id="01444d008abb77ac03ebfb5697a017f621eb7172" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;erts_alloc_config&lt;/code&gt; concentrate on configuration of multi-block carriers. Information gathered when a runtime scenario is saved is mainly current and maximum use of multi-block carriers. If a parameter that change the use of multi-block carriers is changed, a previously generated configuration is invalid and &lt;code&gt;erts_alloc_config&lt;/code&gt; needs to be run again. It is mainly the single block carrier threshold that effects the use of multi-block carriers, but other single-block carrier parameters might as well. If another value of a single block carrier parameter than the default is desired, use the desired value when running &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 的当前实现集中在多块载波的配置上。保存运行时方案时收集的信息主要是当前和最大程度地使用多块载体。如果更改了更改多块载波使用的参数，则先前生成的配置无效， &lt;code&gt;erts_alloc_config&lt;/code&gt; 需要再次运行erts_alloc_config。影响单块载波使用的主要因素是单块载波阈值，但其他单块载波参数也可能会受到影响。如果需要单个块载波参数的值不同于默认值，请在运行 &lt;code&gt;erts_alloc_config&lt;/code&gt; 时使用所需值。</target>
        </trans-unit>
        <trans-unit id="b881e02c8b7eb97ec891648e528239530b927d31" translate="yes" xml:space="preserve">
          <source>The current implementation of Erlang does not care if the connection to the EPMD is broken.</source>
          <target state="translated">目前Erlang的实现并不关心与EPMD的连接是否中断。</target>
        </trans-unit>
        <trans-unit id="5aa015243755c53ad9ba52e113a6e0dd6e7a2f3a" translate="yes" xml:space="preserve">
          <source>The current implementation of persistent terms uses the literal &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;allocator&lt;/a&gt;&lt;/code&gt; also used for literals (constant terms) in BEAM code. By default, 1 GB of virtual address space is reserved for literals in BEAM code and persistent terms. The amount of virtual address space reserved for literals can be changed by using the &lt;code&gt;&lt;a href=&quot;erts_alloc#MIscs&quot;&gt;+MIscs option&lt;/a&gt;&lt;/code&gt; when starting the emulator.</source>
          <target state="translated">持久性术语的当前实现使用文字 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;allocator&lt;/a&gt;&lt;/code&gt; 该分配器也用于BEAM代码中的文字（常数项）。默认情况下，为BEAM代码中的文字和持久性术语保留1 GB的虚拟地址空间。启动仿真器时，可以使用 &lt;code&gt;&lt;a href=&quot;erts_alloc#MIscs&quot;&gt;+MIscs option&lt;/a&gt;&lt;/code&gt; 更改为文字保留的虚拟地址空间量。</target>
        </trans-unit>
        <trans-unit id="7fc5fcd6f03a44ee0e92fb43ab0fad65cf1d2c29" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port program written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">当前的实现会产生一个用C语言编写的端口程序,该程序使用实际的ODBC驱动程序。这个 port 程序连接到 Erlang ODBC 应用程序的默认超时时间为 5000 毫秒。这个超时时间可以通过设置一个特定于应用程序的环境变量 'port_timeout' 来改变,其中包括 ODBC 应用程序的毫秒数。例如 [{odbc,[{port_timeout,60000}]}]将其设置为60秒。</target>
        </trans-unit>
        <trans-unit id="906db1d57b72f269a5be2b6efa0e34d3a4f40e71" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port programm written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">当前的实现会产生一个用 C 语言编写的端口程序,它利用实际的 ODBC 驱动程序。这个 port 程序连接到 Erlang ODBC 应用程序的默认超时时间为 5000 毫秒。这个超时时间可以通过设置一个特定于应用程序的环境变量 'port_timeout' 来改变,其中包括 ODBC 应用程序的毫秒数。例如 [{odbc,[{port_timeout,60000}]}]将其设置为60秒。</target>
        </trans-unit>
        <trans-unit id="a66939d304da82c348947adb4cca67a3063533ce" translate="yes" xml:space="preserve">
          <source>The current implementation uses a pair of Bloom filters to implement the last two mechanisms. Bloom filters are fast, memory-efficient, probabilistic data structures that can tell if an element may be in a set or if it is definitely not in the set.</source>
          <target state="translated">目前的实现使用一对布鲁姆过滤器来实现后两种机制。布卢姆过滤器是一种快速的、节省内存的、概率数据结构,它可以判断一个元素是否可能在一个集合中,或者它是否肯定不在集合中。</target>
        </trans-unit>
        <trans-unit id="4d365424f69367126413adcf57829b464b5f9add" translate="yes" xml:space="preserve">
          <source>The current instruction pointer. This is only of interest for runtime system developers. The function into which the program counter points is the current function of the process.</source>
          <target state="translated">当前的指令指针。这只对运行时系统开发人员有意义。程序计数器指向的函数是进程的当前函数。</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">当前行号。</target>
        </trans-unit>
        <trans-unit id="67653b4ba83e7d00b28af91f8d3fe0dae7dfae29" translate="yes" xml:space="preserve">
          <source>The current local working directory (compare &lt;code&gt;lpwd/1&lt;/code&gt;) is set to the value reported by &lt;code&gt;file:get_cwd/1&lt;/code&gt;, the wanted local directory.</source>
          <target state="translated">当前的本地工作目录（比较 &lt;code&gt;lpwd/1&lt;/code&gt; ）设置为 &lt;code&gt;file:get_cwd/1&lt;/code&gt; 报告的值，该值是所需的本地目录。</target>
        </trans-unit>
        <trans-unit id="0bd1444e43ba871d9585120022333d4590131f8a" translate="yes" xml:space="preserve">
          <source>The current options are:</source>
          <target state="translated">目前的选择是:</target>
        </trans-unit>
        <trans-unit id="5616c509d6bccb6c79f91ec22fce5ea75deae243" translate="yes" xml:space="preserve">
          <source>The current position of the file after the operation is undefined for &lt;code&gt;raw&lt;/code&gt; mode and unchanged for &lt;code&gt;ram&lt;/code&gt; mode.</source>
          <target state="translated">对于 &lt;code&gt;raw&lt;/code&gt; 模式，操作后文件的当前位置是未定义的，对于 &lt;code&gt;ram&lt;/code&gt; 模式，文件的当前位置是未定义的。</target>
        </trans-unit>
        <trans-unit id="51b93308e4fc131191ae4908faed86620396f4d9" translate="yes" xml:space="preserve">
          <source>The current position of the file is undefined after the operation.</source>
          <target state="translated">操作后,文件的当前位置未定义。</target>
        </trans-unit>
        <trans-unit id="a23e8329113f0ad4178af5cd91d27561b0a29cbd" translate="yes" xml:space="preserve">
          <source>The current reference count after the decrement has been performed is returned.</source>
          <target state="translated">返回执行减法后的当前引用数。</target>
        </trans-unit>
        <trans-unit id="24502690d2f3bb086d825806372b93e14c48a509" translate="yes" xml:space="preserve">
          <source>The current reference count after the increment has been performed is returned.</source>
          <target state="translated">返回执行增量后的当前参考数。</target>
        </trans-unit>
        <trans-unit id="9fd7feb388311de9e1a9de0daaa94dc63a945932" translate="yes" xml:space="preserve">
          <source>The current status of the &lt;code&gt;init&lt;/code&gt; process can be inspected. During system startup (initialization), &lt;code&gt;InternalStatus&lt;/code&gt; is &lt;code&gt;starting&lt;/code&gt;, and &lt;code&gt;ProvidedStatus&lt;/code&gt; indicates how far the boot script has been interpreted. Each &lt;code&gt;{progress, Info}&lt;/code&gt; term interpreted in the boot script affects &lt;code&gt;ProvidedStatus&lt;/code&gt;, that is, &lt;code&gt;ProvidedStatus&lt;/code&gt; gets the value of &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">可以检查 &lt;code&gt;init&lt;/code&gt; 过程的当前状态。在系统启动（初始化）期间， &lt;code&gt;InternalStatus&lt;/code&gt; 正在 &lt;code&gt;starting&lt;/code&gt; ， &lt;code&gt;ProvidedStatus&lt;/code&gt; 指示启动脚本已被解释的程度。启动脚本中解释的每个 &lt;code&gt;{progress, Info}&lt;/code&gt; 术语都会影响 &lt;code&gt;ProvidedStatus&lt;/code&gt; ，即 &lt;code&gt;ProvidedStatus&lt;/code&gt; 获取 &lt;code&gt;Info&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="b80e18839956d4be32e5bd88643c826f791ac807" translate="yes" xml:space="preserve">
          <source>The current status, one of the following:</source>
          <target state="translated">目前的状态,有以下几种情况之一:</target>
        </trans-unit>
        <trans-unit id="c7113183a7426c44fe409b00b899d8a41fc5814b" translate="yes" xml:space="preserve">
          <source>The current system access to the file.</source>
          <target state="translated">当前系统对该文件的访问权限。</target>
        </trans-unit>
        <trans-unit id="8ada96b90a0d9236a710ef755016c1b7cca9e74d" translate="yes" xml:space="preserve">
          <source>The current token of a process is set in one of the following two ways:</source>
          <target state="translated">进程的当前令牌有以下两种设置方式之一。</target>
        </trans-unit>
        <trans-unit id="283b878d1d463389e9688a4d3aa6791beee18572" translate="yes" xml:space="preserve">
          <source>The current type/state of the port, which can be one of the values declared above.</source>
          <target state="translated">端口的当前类型/状态,可以是上面声明的数值之一。</target>
        </trans-unit>
        <trans-unit id="d59825d9fb6ddec0b7e1b9ca60e8a4611098dbe2" translate="yes" xml:space="preserve">
          <source>The current version of &lt;code&gt;Mnesia&lt;/code&gt; does not require that the name of the table is the same as the record name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当前版本的 &lt;code&gt;Mnesia&lt;/code&gt; 不需要表 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt; 记录名相同，请参阅记录名与表名。。</target>
        </trans-unit>
        <trans-unit id="8c67d44d5188c140bb3bee7f987dfb33d7ef9f83" translate="yes" xml:space="preserve">
          <source>The current working directory</source>
          <target state="translated">当前工作目录</target>
        </trans-unit>
        <trans-unit id="76bbefce7d446f03b26631d5bb9ced8525a0f785" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This is to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">当前工作目录 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 运行编译器时，，不包含在代码路径中。这是为了避免从当前工作目录加载Beam文件，这些文件可能与编译器或编译器使用的Erlang / OTP系统发生冲突。</target>
        </trans-unit>
        <trans-unit id="61d4a882ed6c30c03ae65ca2d8cd5ad27f2a5741" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">当前工作目录 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 运行编译器时，代码路径中不包含。这样可以避免从当前工作目录加载Beam文件，这些文件可能与编译器或编译器使用的Erlang / OTP系统发生冲突。</target>
        </trans-unit>
        <trans-unit id="2fa5b9ac3977e02e3cf7d97b73ce85358c04959d" translate="yes" xml:space="preserve">
          <source>The currently executing process (that is, the sender) is not alive.</source>
          <target state="translated">当前正在执行的进程(也就是发送者)不是活的。</target>
        </trans-unit>
        <trans-unit id="953e09eadeb4be83fa11df49bf70c92f526cc8f1" translate="yes" xml:space="preserve">
          <source>The daemon is started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; if the node is to be distributed and no running instance is present. If automatically launched environment variables must be used to change the behavior of the daemon; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要分发节点并且不存在正在运行的实例，则该守护程序将通过命令 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 自动启动。如果自动启动，则必须使用环境变量来更改守护程序的行为；请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="0d21e1220084b94119a9a3ad063df2a21e482723" translate="yes" xml:space="preserve">
          <source>The data bytes of the AVP.</source>
          <target state="translated">AVP的数据字节。</target>
        </trans-unit>
        <trans-unit id="f18388ef7ec4c10925540637ae1909f34a929370" translate="yes" xml:space="preserve">
          <source>The data contains errors.</source>
          <target state="translated">数据包含错误。</target>
        </trans-unit>
        <trans-unit id="078b2a841f3b60a68b21c7cb12cdb8e09a9dd362" translate="yes" xml:space="preserve">
          <source>The data delivery order can be relaxed by disabling features that require strict ordering. This is done by passing the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record used when setting up the connection. When relaxed ordering is used, only the order of signals with the same sender/receiver pair has to be preserved. However, note that disabling the features that require strict ordering may have a negative impact on performance, throughput, and/or latency.</source>
          <target state="translated">可以通过禁用要求严格排序的功能来放宽数据传递顺序。这是通过在建立连接时使用的 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 记录的 &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; 字段中传递 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; 来完成的。使用宽松排序时，仅必须保留具有相同发送器/接收器对的信号的顺序。但是，请注意，禁用需要严格排序的功能可能会对性能，吞吐量和/或延迟产生负面影响。</target>
        </trans-unit>
        <trans-unit id="f7a26a04ef322bb19505a5c1dc8d45f5e01e5f3f" translate="yes" xml:space="preserve">
          <source>The data formats defined in sections 4.2 (&quot;Basic AVP Data Formats&quot;) and 4.3 (&quot;Derived AVP Data Formats&quot;) of RFC 6733 are encoded as values of the types defined here. Values are passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; in a request record when sending a request, returned in a resulting answer record and passed to a &lt;code&gt;handle_request/3&lt;/code&gt; callback upon reception of an incoming request.</source>
          <target state="translated">RFC 6733的第4.2节（&amp;ldquo;基本AVP数据格式&amp;rdquo;）和4.3节（&amp;ldquo;派生的AVP数据格式&amp;rdquo;）中定义的数据格式被编码为此处定义的类型的值。值在发送请求时传递到请求记录中的 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 在返回的应答记录中返回，并在接收到传入请求时传递给 &lt;code&gt;handle_request/3&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="fdf833224017bb981586f311e5704bede95ecd92" translate="yes" xml:space="preserve">
          <source>The data in the boot script, fetched from the new application resource file &lt;code&gt;App.app&lt;/code&gt;</source>
          <target state="translated">从新的应用程序资源文件 &lt;code&gt;App.app&lt;/code&gt; 获取的启动脚本中的数据</target>
        </trans-unit>
        <trans-unit id="bf8c73b58d26cdb1cd37eb82749dddb7b4d25b8e" translate="yes" xml:space="preserve">
          <source>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</source>
          <target state="translated">头部的数据是以列表的形式发送的,二进制在列表的尾部是以Erlang二进制的形式发送的。</target>
        </trans-unit>
        <trans-unit id="fe96a6cdbbb26d9c1b8c04531c8c51ed5ebb111d" translate="yes" xml:space="preserve">
          <source>The data is at &lt;code&gt;p&lt;/code&gt;. The length of the bit string is &lt;code&gt;nbits&lt;/code&gt; bits. The first &lt;code&gt;bitoffs&lt;/code&gt; bits of the data at &lt;code&gt;p&lt;/code&gt; are unused. The first byte which is part of the bit string is &lt;code&gt;p[bitoffs/8]&lt;/code&gt;. The &lt;code&gt;bitoffs%8&lt;/code&gt; most significant bits of the first byte &lt;code&gt;p[bitoffs/8]&lt;/code&gt; are unused.</source>
          <target state="translated">数据在 &lt;code&gt;p&lt;/code&gt; 处。位串的长度为 &lt;code&gt;nbits&lt;/code&gt; 位。 &lt;code&gt;p&lt;/code&gt; 处的数据的第一个 &lt;code&gt;bitoffs&lt;/code&gt; 位未使用。作为位串的一部分的第一个字节是 &lt;code&gt;p[bitoffs/8]&lt;/code&gt; 。第一个字节 &lt;code&gt;p[bitoffs/8]&lt;/code&gt; 的 &lt;code&gt;bitoffs%8&lt;/code&gt; 最高有效位未使用。</target>
        </trans-unit>
        <trans-unit id="9e8a427227bcde27fb34708c1f8037df0476db96" translate="yes" xml:space="preserve">
          <source>The data is queued in the port owner process' message queue. Notice that this does not yield to the emulator (as the driver and the emulator run in the same thread).</source>
          <target state="translated">这些数据被排在端口所有者进程的消息队列中。请注意,这并不是向仿真器让步 (因为驱动程序和仿真器在同一个线程中运行)。</target>
        </trans-unit>
        <trans-unit id="5209f4c8cd33cb9b06c7cafb6cfe1d7ba8e19dd5" translate="yes" xml:space="preserve">
          <source>The data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is called.</source>
          <target state="translated">因此，当调用 &lt;code&gt;ei&lt;/code&gt; 函数时，数据位于 &lt;code&gt;buf[*index]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a0aaa71e50e0fe09624f658b5194caa4fc82ffa" translate="yes" xml:space="preserve">
          <source>The data model employed by &lt;code&gt;Mnesia&lt;/code&gt; is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 使用的数据模型是扩展的关系数据模型。数据被组织为一组表，不同数据记录之间的关系可以建模为描述关系的更多表。每个表都包含Erlang记录的实例。记录表示为Erlang元组。</target>
        </trans-unit>
        <trans-unit id="bcffc5bb38e63b17337f4be90db30aa76b246a80" translate="yes" xml:space="preserve">
          <source>The data produced by the lock counters will give an estimate on how well the runtime system will behave from a parallelizable view point for the scenarios tested. This tool was mainly developed to help Erlang runtime developers iron out potential and generic bottlenecks.</source>
          <target state="translated">锁计数器产生的数据将给出一个估计,从可并行的角度来看,运行时系统在测试场景下的表现如何。这个工具的开发主要是为了帮助Erlang运行时开发者熨平潜在的和通用的瓶颈。</target>
        </trans-unit>
        <trans-unit id="2d27f50b0cd05524a7fd478c731d913e31e93736" translate="yes" xml:space="preserve">
          <source>The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice.</source>
          <target state="translated">本模块使用的代表队列的数据被其他模块认为是不透明的。任何假设知道格式的代码都是在薄冰上运行。</target>
        </trans-unit>
        <trans-unit id="53c6baece120e0ea5f4f690528bc1b24d8b68a2f" translate="yes" xml:space="preserve">
          <source>The data structure referring to this single linked list cover two cache lines. One cache line containing information about the head of the list, and one cache line containing information about the tail of the list. This in order to reduce cache line ping ponging of this data structure. The head of the list will only be manipulated by the thread owning the allocator instance, and the tail will be manipulated by other threads inserting deallocation jobs.</source>
          <target state="translated">指向这个单一链接列表的数据结构包括两条缓存线。一条缓存线包含列表头部的信息,一条缓存线包含列表尾部的信息。这样做是为了减少这个数据结构的缓存行pingping。列表头只由拥有分配器实例的线程操作,而尾部将由其他插入deallocation作业的线程操作。</target>
        </trans-unit>
        <trans-unit id="966785b6ae629e19c8bed0b0d3e6ef6f991ec06e" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; in event &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 随附的数据遵循与事件 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; 相同的格式。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="bb604c10fe966845cdde71367a93dbf6cc929795" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as events &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 附带的数据与事件 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; 的格式相同。有关详细信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="3ae9537a2b782dfe6dcee8743658b21ed9b0301d" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt;, is represented as the following erlang record:</source>
          <target state="translated">数据类型 &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt; 表示为以下erlang记录：</target>
        </trans-unit>
        <trans-unit id="feae33cf3d811c301bdaf1550728e179af863677" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;'Validity'&lt;/code&gt;, &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, and &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; are represented as the following Erlang records:</source>
          <target state="translated">数据类型 &lt;code&gt;'Validity'&lt;/code&gt; ， &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 和 &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; 表示为以下Erlang记录：</target>
        </trans-unit>
        <trans-unit id="93bf041facbb4e82a9e8c285ac8447b2c8201746" translate="yes" xml:space="preserve">
          <source>The database can also become inconsistent if configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; is used or if &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; is used.</source>
          <target state="translated">如果使用配置参数 &lt;code&gt;max_wait_for_decision&lt;/code&gt; 或使用 &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; ,则数据库也可能变得不一致。</target>
        </trans-unit>
        <trans-unit id="264b842db8bf0ed81b261f12d4ee28f9ed7af246" translate="yes" xml:space="preserve">
          <source>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs.</source>
          <target state="translated">数据库可以重新配置,表可以在节点之间移动。这些操作不影响用户程序。</target>
        </trans-unit>
        <trans-unit id="7c3e27d69c9e2bbfe084964b4ba1a3ee0b761dd5" translate="yes" xml:space="preserve">
          <source>The database model is as follows:</source>
          <target state="translated">数据库模型如下:</target>
        </trans-unit>
        <trans-unit id="4b5b0c5d2b259e474f8fd1130e7a9869d03ac6fb" translate="yes" xml:space="preserve">
          <source>The date and time when the process was started.</source>
          <target state="translated">进程开始的日期和时间;</target>
        </trans-unit>
        <trans-unit id="fe8362a1d9af54200a42df54d2c52d6145175ad5" translate="yes" xml:space="preserve">
          <source>The debug enabled runtime system features lock violation checking, assert checking and various sanity checks to help a developer ensure correctness. Some of these features can be enabled on a normal beam using appropriate configure options.</source>
          <target state="translated">启用调试的运行时系统具有锁违规检查、断言检查和各种理智检查的功能,以帮助开发人员确保正确性。其中一些功能可以通过适当的配置选项在普通梁上启用。</target>
        </trans-unit>
        <trans-unit id="c6dd12423efe39c011d13a41f3ecdda00e9c96f5" translate="yes" xml:space="preserve">
          <source>The debug information can also be removed from BEAM files using &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt;, and/or &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">还可以使用 &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt; 从BEAM文件中删除调试信息。</target>
        </trans-unit>
        <trans-unit id="9fcf3b68d8f8e511e6ff9331d892546d1029cbf5" translate="yes" xml:space="preserve">
          <source>The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref.</source>
          <target state="translated">调试信息可以加密,以保持源代码的秘密,但仍然可以使用Debugger或Xref等工具。</target>
        </trans-unit>
        <trans-unit id="7fcc7761d46f20ec162261ce0e8d0b6a28d90fe6" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; is set by calling the function &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Level&lt;/code&gt;is one of the following:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 的调试级别是通过调用函数 &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt; 来设置的，其中 &lt;code&gt;Level&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="8f1bdc53b01108885cce2234b4e2d9b39baa8b28" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; itself is also an application parameter, making it possible to start an Erlang system to turn on &lt;code&gt;Mnesia&lt;/code&gt; debug in the initial startup phase by using the following code:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 本身的调试级别也是一个应用程序参数，通过使用以下代码，可以在初始启动阶段启动Erlang系统以打开 &lt;code&gt;Mnesia&lt;/code&gt; 调试：</target>
        </trans-unit>
        <trans-unit id="15f3b5f9fa804bcf46e507eb72dd7777e9dc6ab9" translate="yes" xml:space="preserve">
          <source>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</source>
          <target state="translated">解码和编码函数使用一个缓冲区和缓冲区的索引,索引指向编码和解码的位置。索引更新为指向被编码/解码的术语之后。不检查术语是否适合在缓冲区内。如果编码超出了缓冲区,程序就会崩溃。</target>
        </trans-unit>
        <trans-unit id="bb7a0f41f8f9cd301571e70dc3544c6857e6778d" translate="yes" xml:space="preserve">
          <source>The decode functions return a record as result when decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; or a &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">解码功能在解码 &lt;code&gt;SEQUENCE&lt;/code&gt; 或 &lt;code&gt;SET&lt;/code&gt; 时返回记录作为结果。</target>
        </trans-unit>
        <trans-unit id="cef0dcfb934889d6cf431e5ebf6fd74edf18c281" translate="yes" xml:space="preserve">
          <source>The decoded value of an AVP. Will be &lt;code&gt;undefined&lt;/code&gt; on decode if the data bytes could not be decoded, the AVP is unknown, or if the &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;. The type of a decoded value is as document in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AVP的解码值。如果数据字节无法解码，AVP未知或 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; ，则在解码时将 &lt;code&gt;undefined&lt;/code&gt; 。解码后的值的类型为 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="9dd25b2c0dae34a4ccb0be97da547058ad3ae8fb" translate="yes" xml:space="preserve">
          <source>The decoder returns an atom if the value corresponds to a symbol in the &lt;code&gt;Named Number List&lt;/code&gt;.</source>
          <target state="translated">如果值对应于&amp;ldquo; &lt;code&gt;Named Number List&lt;/code&gt; 的符号，则解码器返回一个原子。</target>
        </trans-unit>
        <trans-unit id="c388aad8aed6c9f2fdd03a9ff95a76e605fea9f6" translate="yes" xml:space="preserve">
          <source>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \s now match the same set of characters.</source>
          <target state="translated">默认的 &quot;空格 &quot;字符是HT (9)、LF (10)、VT (11)、FF (12)、CR (13)和空格 (32)。如果正在进行特定于本地的匹配,空格字符列表可能会有所不同;它们可能会更少或更多。&quot;空格 &quot;过去与不包括VT的\s不同,这是为了Perl的兼容性。然而,Perl在5.18版本时改变了,PCRE在8.34版本时也跟着改变了。&quot;Space &quot;和\s现在匹配同一组字符。</target>
        </trans-unit>
        <trans-unit id="c59d65c8568f18df7ae19973d7555f547a715db3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Collector Filter&lt;/code&gt; converts the raw Erlang trace data format into &lt;code&gt;Event Records&lt;/code&gt;. If you want to perform this differently you can of course write your own &lt;code&gt;Collector Filter&lt;/code&gt; from scratch. But it may probably save you some efforts if you first apply the default filter in &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; before you apply your own conversions of its output.</source>
          <target state="translated">默认的 &lt;code&gt;Collector Filter&lt;/code&gt; 将原始的Erlang跟踪数据格式转换为 &lt;code&gt;Event Records&lt;/code&gt; 。如果您想以不同的方式执行此操作，则当然可以从头开始编写自己的 &lt;code&gt;Collector Filter&lt;/code&gt; 。但是，如果在应用自己的输出转换之前首先在 &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; 中应用默认过滤器，则可能会节省一些工作。</target>
        </trans-unit>
        <trans-unit id="c57652a6dee935467cebeeed4f3fb7d6f7116fee" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Size&lt;/code&gt; depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</source>
          <target state="translated">默认 &lt;code&gt;Size&lt;/code&gt; 取决于类型。对于整数，它是8。对于浮点数，它是64。对于二进制，它是所有二进制。在匹配中，此默认值仅对最后一个元素有效。匹配中的所有其他二进制元素必须具有大小规范。</target>
        </trans-unit>
        <trans-unit id="4dbb7545b0f004e8ef75d97150f80d5c45826ac3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;StatisticsSpec&lt;/code&gt; is:</source>
          <target state="translated">默认的 &lt;code&gt;StatisticsSpec&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="a7491f9d8e8f98f36325638513ac80bfc97bc47c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt; +hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">默认 &lt;code&gt;message_queue_data&lt;/code&gt; 处理标志是通过命令行参数测定 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt; +hmqd&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f1c0b4c022d0f07743e56c51911904bc53375f9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">默认 &lt;code&gt;message_queue_data&lt;/code&gt; 处理标志是通过命令行参数测定 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="572022a6b410479721a7992c7362b7aaff7907d4" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used and the result is returned to the client.</source>
          <target state="translated">使用默认的Erlang评估器,并将结果返回给客户端。</target>
        </trans-unit>
        <trans-unit id="eac2ba828452672a63c684b8e844a11cc19d5eee" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used both for exec and shell requests. The result is returned to the client.</source>
          <target state="translated">默认的Erlang评估器同时用于exec和shell请求。结果会返回给客户端。</target>
        </trans-unit>
        <trans-unit id="88fd0465cd657366b4590ae0f113c518fee5324c" translate="yes" xml:space="preserve">
          <source>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character.</source>
          <target state="translated">Erlang中默认的Unicode编码是以二进制UTF-8为单位,这也是OTP中内置函数和库期望找到二进制Unicode数据的格式。在列表中,Unicode数据被编码为整数,每个整数代表一个字符,并简单地编码为该字符的Unicode码点。</target>
        </trans-unit>
        <trans-unit id="49cebb251d6b0aa1500584bc73027335bd0baea3" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">默认算法是 &lt;code&gt;exrop&lt;/code&gt; （Xoroshiro116 +）。如果需要特定的算法，请确保始终使用 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; 初始化状态。</target>
        </trans-unit>
        <trans-unit id="2258a0b4b5ba55503b1e33ac02535a01630a7012" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exsss&lt;/code&gt; (Xorshift116**). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt; seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">默认算法是 &lt;code&gt;exsss&lt;/code&gt; （Xorshift116 **）。如果需要特定的算法，请确保始终使用 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt; seed/1&lt;/a&gt;&lt;/code&gt; 来初始化状态。</target>
        </trans-unit>
        <trans-unit id="3eb49c55e11d37a2c7f97be97bd91839e01e102b" translate="yes" xml:space="preserve">
          <source>The default behaviour in the two other cases (that is, abnormal exit) above is to:</source>
          <target state="translated">上述其他两种情况(即异常退出)的默认行为是:。</target>
        </trans-unit>
        <trans-unit id="9aad933f8a23be0b8f60b2f0009c014495bcab97" translate="yes" xml:space="preserve">
          <source>The default behaviour is ignore the message. To get a printout for each message with &lt;code&gt;AlwaysDisplay = true&lt;/code&gt;, use for example &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</source>
          <target state="translated">默认行为是忽略该消息。要使用 &lt;code&gt;AlwaysDisplay = true&lt;/code&gt; 来获取每条消息的打印输出，请使用 &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cc443fe9633fb1a0335c43045efe1e002d6805e" translate="yes" xml:space="preserve">
          <source>The default behaviour is to create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">默认行为是在当前目录中创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="26ca635941f675c5f6767b6598533eaee0bb0c9a" translate="yes" xml:space="preserve">
          <source>The default behaviour of a process that receives a normal exit is to ignore the signal.</source>
          <target state="translated">收到正常退出的进程的默认行为是忽略该信号。</target>
        </trans-unit>
        <trans-unit id="47755f34cfe7e278db6d7efc977a211082ce5135" translate="yes" xml:space="preserve">
          <source>The default behaviour when a process receives an exit signal with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, is to terminate and in turn emit exit signals with the same exit reason to its linked processes. An exit signal with reason &lt;code&gt;normal&lt;/code&gt; is ignored.</source>
          <target state="translated">当进程接收到具有非 &lt;code&gt;normal&lt;/code&gt; 退出原因的退出信号时，默认行为是终止并依次向其链接的进程发出具有相同退出原因的退出信号。原因 &lt;code&gt;normal&lt;/code&gt; 的退出信号将被忽略。</target>
        </trans-unit>
        <trans-unit id="9d70ec5c7098a4e4d6ce579440d90f6d0f1a9b44" translate="yes" xml:space="preserve">
          <source>The default boot file is &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt;, but in this case we need to specify a boot file from our target structure, typically &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt;. This is done with the &lt;code&gt;-boot&lt;/code&gt; command line option to &lt;code&gt;erl&lt;/code&gt;</source>
          <target state="translated">默认的引导文件是 &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt; ，但是在这种情况下，我们需要从目标结构中指定一个引导文件，通常是 &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt; 。这是通过 &lt;code&gt;erl&lt;/code&gt; 的 &lt;code&gt;-boot&lt;/code&gt; 命令行选项完成的</target>
        </trans-unit>
        <trans-unit id="8deb6cfc40b154f0f3bc4c292fe3c4c01bead83c" translate="yes" xml:space="preserve">
          <source>The default callback module &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt;, has the following features:</source>
          <target state="translated">默认的回调模块 &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt; 具有以下功能：</target>
        </trans-unit>
        <trans-unit id="1389307405e87741972dcfbd8f36d70ed4c7e741" translate="yes" xml:space="preserve">
          <source>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then &lt;code&gt;noAuthNoPriv&lt;/code&gt;.</source>
          <target state="translated">默认发现处理程序将要求调用者执行其他操作，并且如果安全级别高于 &lt;code&gt;noAuthNoPriv&lt;/code&gt; ，则发现将不起作用。</target>
        </trans-unit>
        <trans-unit id="d22df62b6d0da804bdfcd33682ee76feb0f23fda" translate="yes" xml:space="preserve">
          <source>The default encoding for Erlang source files is changed from Latin-1 to UTF-8 since Erlang/OTP 17.0.</source>
          <target state="translated">从Erlang/OTP 17.0开始,Erlang源文件的默认编码由Latin-1改为UTF-8。</target>
        </trans-unit>
        <trans-unit id="28a5f2f414a2bcb3dd11d72abe5185c72fab49c5" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt; Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 脚本的I / O服务器的默认编码为 &lt;code&gt;latin1&lt;/code&gt; ，因为脚本在非交互式终端（请参见《 STDLIB用户指南》中 &lt;code&gt; Summary of Options&lt;/code&gt; ）中运行。</target>
        </trans-unit>
        <trans-unit id="b3e3252c03a4fb54a27bf1c1fdc312100673449d" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt;Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 脚本的I / O服务器的默认编码为 &lt;code&gt;latin1&lt;/code&gt; ，因为脚本在非交互式终端（请参阅《 STDLIB用户指南》中 &lt;code&gt;Summary of Options&lt;/code&gt; ）中运行。</target>
        </trans-unit>
        <trans-unit id="5fc4ad3abb12599963d8f41201b9099f8a6fadc8" translate="yes" xml:space="preserve">
          <source>The default encoding. Bytes supplied to the file, that is, &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; are written &quot;as is&quot; on the file. Likewise, bytes read from the file, that is, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; are returned &quot;as is&quot;. If module &lt;code&gt;io(3)&lt;/code&gt; is used for writing, the file can only cope with Unicode characters up to code point 255 (the ISO Latin-1 range).</source>
          <target state="translated">默认编码。提供给文件的字节，即 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; ，按&amp;ldquo;原样&amp;rdquo;写入文件。同样，从文件读取的字节（即 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; )将&amp;ldquo;按原样&amp;rdquo;返回。如果使用模块 &lt;code&gt;io(3)&lt;/code&gt; 进行写入，则该文件只能处理Unicode字符，直到代码点255（ISO Latin-1范围）。</target>
        </trans-unit>
        <trans-unit id="d6c8c72f780ad73f25b213fdc25585528f17513b" translate="yes" xml:space="preserve">
          <source>The default endianness is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">默认字节序为 &lt;code&gt;big&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83550f92d20198e2acab3ad30ef01b3a3ff2580" translate="yes" xml:space="preserve">
          <source>The default fallback behaviour. Template funs should end with:</source>
          <target state="translated">默认的回退行为。模板funs的结尾应该是:</target>
        </trans-unit>
        <trans-unit id="c9d9ffa8dde369b6838c3b5a3754294ebeb88aaa" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; cannot handle an object of type &lt;code&gt;NetworkAddress&lt;/code&gt; as INDEX (SNMPv1 only!). Use &lt;code&gt;IpAddress&lt;/code&gt; instead.</source>
          <target state="translated">默认函数和 &lt;code&gt;snmp_generic&lt;/code&gt; 无法将类型为 &lt;code&gt;NetworkAddress&lt;/code&gt; 的对象处理为INDEX（仅SNMPv1！）。请改用 &lt;code&gt;IpAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cd3d1fa535e347fbd4b38228c48e00bf23af7b2" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. &lt;code&gt;DisplayString&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. This must be checked in an overloaded &lt;code&gt;is_set_ok&lt;/code&gt; function.</source>
          <target state="translated">默认函数和 &lt;code&gt;snmp_generic&lt;/code&gt; 在从OCTET STRING派生的文本约定中不检查每个OCTET的范围，例如 &lt;code&gt;DisplayString&lt;/code&gt; 和 &lt;code&gt;DateAndTime&lt;/code&gt; 。必须在重载的 &lt;code&gt;is_set_ok&lt;/code&gt; 函数中进行检查。</target>
        </trans-unit>
        <trans-unit id="cb7a8decc5695c83a52d57741dd6546a270063e4" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt; logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt; logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">默认处理程序 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt; logger_std_h&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt; logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 具有过载保护机制，该机制使处理程序可以在高负载期间（必须处理大量传入日志请求时）生存并保持响应。该机制的工作原理如下：</target>
        </trans-unit>
        <trans-unit id="93ec2b0bf3246052db6872a9a89f490a6940711d" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">默认处理程序 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 具有过载保护机制，该机制使处理程序可以在高负载期间（必须处理大量传入日志请求时）生存并保持响应。该机制的工作原理如下：</target>
        </trans-unit>
        <trans-unit id="fef3702dc90f570ebd9028951e47041a3eec62af" translate="yes" xml:space="preserve">
          <source>The default initial heap size of 233 words is quite conservative to support Erlang systems with hundreds of thousands or even millions of processes. The garbage collector grows and shrinks the heap as needed.</source>
          <target state="translated">默认的初始堆大小为233字,对于支持有几十万甚至上百万个进程的Erlang系统来说是相当保守的。垃圾回收器会根据需要增长和缩小堆大小。</target>
        </trans-unit>
        <trans-unit id="028f1e913dc597e5f47465aa0038982d46d84b7c" translate="yes" xml:space="preserve">
          <source>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this.</source>
          <target state="translated">通过默认的工具实现,可以将管理端应用与代理端应用同时开发和测试。ASN.1文件一完成,就让MIB编译器生成一个默认的实现,并以此为基础开发管理应用程序。</target>
        </trans-unit>
        <trans-unit id="2bcdc2b092cf0144876d346105d3638a289ddc47" translate="yes" xml:space="preserve">
          <source>The default instrumentation functions are defined in the module &lt;code&gt;snmp_generic&lt;/code&gt;. Refer to the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for details.</source>
          <target state="translated">默认的检测功能在模块 &lt;code&gt;snmp_generic&lt;/code&gt; 中定义。有关详细信息，请参见参考手册的SNMP部分，模块 &lt;code&gt;snmp_generic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f9d2c2e9dd957fcc3258b4a7c7be3758f84afc" translate="yes" xml:space="preserve">
          <source>The default is 30 seconds.</source>
          <target state="translated">默认为30秒。</target>
        </trans-unit>
        <trans-unit id="697dc028cf7853b692477e62b3b0ccd825e45fa0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;integer&lt;/code&gt;. &lt;code&gt;bytes&lt;/code&gt; is a shorthand for &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bits&lt;/code&gt; is a shorthand for &lt;code&gt;bitstring&lt;/code&gt;. See below for more information about the &lt;code&gt;utf&lt;/code&gt; types.</source>
          <target state="translated">默认值为 &lt;code&gt;integer&lt;/code&gt; 。 &lt;code&gt;bytes&lt;/code&gt; 是 &lt;code&gt;binary&lt;/code&gt; 的简写，而 &lt;code&gt;bits&lt;/code&gt; 是 &lt;code&gt;bitstring&lt;/code&gt; 的简写。有关 &lt;code&gt;utf&lt;/code&gt; 类型的更多信息，请参见下文。</target>
        </trans-unit>
        <trans-unit id="6f0b6dd22860df8373214ee0633cf82a9776e5cd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;binary_alloc&lt;/code&gt; and &lt;code&gt;driver_alloc&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; for the other allocator types.</source>
          <target state="translated">对于 &lt;code&gt;binary_alloc&lt;/code&gt; 和 &lt;code&gt;driver_alloc&lt;/code&gt; ，默认值为 &lt;code&gt;true&lt;/code&gt; ；对于其他分配器类型，默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9996cd482af4c98f3ef5c52e911a0d51db398668" translate="yes" xml:space="preserve">
          <source>The default is the process named &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">默认值为名为 &lt;code&gt;logger&lt;/code&gt; 的进程。</target>
        </trans-unit>
        <trans-unit id="f6c6037b1efc7d6b42e5368b46d0f3b99b3ee991" translate="yes" xml:space="preserve">
          <source>The default is to return a sequence of QLCs in a block, but if option &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; is specified, one single QLC is returned.</source>
          <target state="translated">默认值是在一个块中返回一系列QLC，但是如果指定了选项 &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; ，则返回一个QLC。</target>
        </trans-unit>
        <trans-unit id="b873bd22585e6e628d3df8c1732fa1e4731a1722" translate="yes" xml:space="preserve">
          <source>The default is to return a string, but if option &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings.</source>
          <target state="translated">默认值为返回字符串，但是如果指定了选项 &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; ，则将返回抽象代码。在抽象代码中，端口标识符，引用和pid用字符串表示。</target>
        </trans-unit>
        <trans-unit id="6b16165d91c06ae4aeb2706afc9b7a0ac50cd9da" translate="yes" xml:space="preserve">
          <source>The default is to return all elements in lists, but if option &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; is specified, only a limited number of elements are returned.</source>
          <target state="translated">默认值为返回列表中的所有元素，但是如果指定了选项 &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; ，则仅返回有限数量的元素。</target>
        </trans-unit>
        <trans-unit id="cc7b0f890d901ebd92c482f0beb121398b160a73" translate="yes" xml:space="preserve">
          <source>The default is to show all parts of objects and match specifications, but if option &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; is specified, parts of terms below a certain depth are replaced by &lt;code&gt;'...'&lt;/code&gt;.</source>
          <target state="translated">默认值是显示对象的所有部分并匹配规范，但是如果指定了选项 &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; ，则将某个深度以下的术语部分替换为 &lt;code&gt;'...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d031478aad7c792d83bd41e0b1d60d3346429273" translate="yes" xml:space="preserve">
          <source>The default is to sort terms in ascending order, but that can be changed by value &lt;code&gt;descending&lt;/code&gt; or by specifying an ordering function &lt;code&gt;Fun&lt;/code&gt;. An ordering function is antisymmetric, transitive, and total. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; is to return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; comes before &lt;code&gt;B&lt;/code&gt; in the ordering, otherwise &lt;code&gt;false&lt;/code&gt;. An example of a typical ordering function is less than or equal to, &lt;code&gt;=&amp;lt;/2&lt;/code&gt;. Using an ordering function slows down the sort considerably. Functions &lt;code&gt;keysort&lt;/code&gt;, &lt;code&gt;keymerge&lt;/code&gt; and &lt;code&gt;keycheck&lt;/code&gt; do not accept ordering functions.</source>
          <target state="translated">默认设置是按升序对术语进行排序，但是可以通过 &lt;code&gt;descending&lt;/code&gt; 或指定排序函数 &lt;code&gt;Fun&lt;/code&gt; 来更改。排序函数是反对称的，可传递的和总计的。如果 &lt;code&gt;A&lt;/code&gt; 在排序中位于 &lt;code&gt;B&lt;/code&gt; 之前，则 &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。典型排序函数的一个示例是小于或等于 &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 。使用排序功能会大大降低排序速度。函数 &lt;code&gt;keysort&lt;/code&gt; ， &lt;code&gt;keymerge&lt;/code&gt; 和 &lt;code&gt;keycheck&lt;/code&gt; 不接受排序功能。</target>
        </trans-unit>
        <trans-unit id="388c1ebba36e81e6d83c9829202075488730e57f" translate="yes" xml:space="preserve">
          <source>The default list is fetched from the &lt;code&gt;public_key&lt;/code&gt; application.</source>
          <target state="translated">默认列表是从 &lt;code&gt;public_key&lt;/code&gt; 应用程序获取的。</target>
        </trans-unit>
        <trans-unit id="6b3871f80aaa305c511a84fd9b3f91462dfdba6b" translate="yes" xml:space="preserve">
          <source>The default logging behavior of &lt;code&gt;ct_telnet&lt;/code&gt; is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a &lt;code&gt;ct_telnet&lt;/code&gt; function, such as &lt;code&gt;expect/3&lt;/code&gt;. However, &lt;code&gt;ct_telnet&lt;/code&gt; can be configured to use a special purpose event handler, implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;, for logging &lt;strong&gt;all&lt;/strong&gt; Telnet traffic. To use this handler, install a &lt;code&gt;Common Test&lt;/code&gt; hook named &lt;code&gt;cth_conn_log&lt;/code&gt;. Example (using the test suite information function):</source>
          <target state="translated">&lt;code&gt;ct_telnet&lt;/code&gt; 的默认日志记录行为是将有关已执行的操作，命令及其相应结果的信息打印到测试用例HTML日志中。以下内容未打印到HTML日志中： &lt;code&gt;ct_telnet&lt;/code&gt; 函数未明确接收的从Telnet服务器发送的文本字符串，例如Expect &lt;code&gt;expect/3&lt;/code&gt; 。但是，可以将 &lt;code&gt;ct_telnet&lt;/code&gt; 配置为使用在 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 中实现的专用事件处理程序来记录&lt;strong&gt;所有&lt;/strong&gt; Telnet通信。要使用此处理程序，请安装名为 &lt;code&gt;cth_conn_log&lt;/code&gt; 的 &lt;code&gt;Common Test&lt;/code&gt; 挂钩。示例（使用测试套件信息功能）：</target>
        </trans-unit>
        <trans-unit id="2de8d81b3d3a2e14473bb755a7b9ea4746cd308a" translate="yes" xml:space="preserve">
          <source>The default matching handles dns_id and uri_id. In an uri_id the value is tested for equality with a value from the &lt;code&gt;Subject Alternate Name&lt;/code&gt;. If som other kind of matching is needed, use the &lt;code&gt;match_fun&lt;/code&gt; option.</source>
          <target state="translated">默认匹配处理dns_id和uri_id。在uri_id中，将使用&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 的值测试该值是否相等。如果需要其他类型的匹配，请使用 &lt;code&gt;match_fun&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="84111fd78857c9aae8ea5220ba7612eb708e45fa" translate="yes" xml:space="preserve">
          <source>The default matching transformes the ascii values in strings to lowercase before comparing. The &lt;code&gt;match_fun&lt;/code&gt; is however called without any transfomation applied to the strings. The reason is to enable the user to do unforseen handling of the strings where the original format is needed.</source>
          <target state="translated">默认匹配在比较之前将字符串中的ascii值转换为小写。该 &lt;code&gt;match_fun&lt;/code&gt; 然而，被称为不应用于任何字符串transfomation。原因是使用户能够在需要原始格式的地方对字符串进行意外处理。</target>
        </trans-unit>
        <trans-unit id="aa2a84cd90225c7ed3bdea62cdca292d4a45b475" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows and MacOS X enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">默认模式取决于操作系统。Windows和MacOS X强制使用一致的文件名编码，因此VM使用 &lt;code&gt;utf8&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="a989c78863dde3eb5b7dac6806181cf8315faf2c" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows, MacOS X and Android enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">默认模式取决于操作系统。Windows，MacOS X和Android强制使用一致的文件名编码，因此VM使用 &lt;code&gt;utf8&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="953f88f92bc1b24efaf4cf45547f40d0e648b131" translate="yes" xml:space="preserve">
          <source>The default object arity is smaller than &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">默认的对象 &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt; 小于&amp;lt;keypos&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4de77215568172d7d29aabd76eae88688d23f0d0" translate="yes" xml:space="preserve">
          <source>The default options of the &lt;code&gt;erlsrv&lt;/code&gt; program are not sufficient for release handling. The machine started by &lt;code&gt;erlsrv&lt;/code&gt; is be specified as the &lt;code&gt;start_erl&lt;/code&gt; program and the arguments are to contain &lt;code&gt;++&lt;/code&gt; followed by the desired options.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; 程序的默认选项不足以进行发行版处理。由 &lt;code&gt;erlsrv&lt;/code&gt; 启动的机器被指定为 &lt;code&gt;start_erl&lt;/code&gt; 程序，并且参数将包含 &lt;code&gt;++&lt;/code&gt; ,后跟所需的选项。</target>
        </trans-unit>
        <trans-unit id="848dbed2df3f8df742ee9905b38e3696149b703a" translate="yes" xml:space="preserve">
          <source>The default password checking is with the list in the &lt;code&gt;&lt;a href=&quot;ssh#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; option in the SSH daemon. It could be replaced with a &lt;code&gt;&lt;a href=&quot;ssh#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; plugin. The arity four variant (&lt;code&gt;&lt;a href=&quot;ssh#type-pwdfun_4&quot;&gt;pwdfun_4()&lt;/a&gt;&lt;/code&gt;) can also be used for introducing delays after failed password checking attempts. Here is a simple example of such a pwdfun:</source>
          <target state="translated">默认密码检查与SSH守护程序的 &lt;code&gt;&lt;a href=&quot;ssh#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; 选项中的列表一起使用。可以将其替换为 &lt;code&gt;&lt;a href=&quot;ssh#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; 插件。四个 &lt;code&gt;&lt;a href=&quot;ssh#type-pwdfun_4&quot;&gt;pwdfun_4()&lt;/a&gt;&lt;/code&gt; 变体（pwdfun_4（））也可以用于在密码检查尝试失败后引入延迟。这是这种pwdfun的简单示例：</target>
        </trans-unit>
        <trans-unit id="fb1094b520cae2a88d55d90efc05453766135ad7" translate="yes" xml:space="preserve">
          <source>The default set of groups is listed in &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt;. This file may be regenerated like this:</source>
          <target state="translated">默认的组组在 &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt; 中列出。该文件可以这样重新生成：</target>
        </trans-unit>
        <trans-unit id="1a4dcf8371d190ef2c9a9faf32cf8b7eef5d4104" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt; prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">默认的shell提示功能显示节点的名称（如果该节点可以是分布式系统的一部分）和当前命令号。用户可以通过调用 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt; prompt_func/1&lt;/a&gt;&lt;/code&gt; 或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_prompt_func&lt;/code&gt; 来定制提示功能。</target>
        </trans-unit>
        <trans-unit id="8c212e9694a3fd892d150f01a66f923860ff2fc9" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">默认的shell提示功能显示节点的名称（如果该节点可以是分布式系统的一部分）和当前命令号。用户可以通过调用 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; 或通过为STDLIB应用程序设置应用程序配置参数 &lt;code&gt;shell_prompt_func&lt;/code&gt; 来定制提示功能。</target>
        </trans-unit>
        <trans-unit id="00b63ca80d11da692b5651bc33e43d076e3793c3" translate="yes" xml:space="preserve">
          <source>The default signedness is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">默认签名为 &lt;code&gt;unsigned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff776579e06c4767b62b9f485e782cd999a09f7a" translate="yes" xml:space="preserve">
          <source>The default simple handler is called &lt;code&gt;alarm_handler&lt;/code&gt; and it can be exchanged by calling &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; as &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt;. &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; is called. For more details, see &lt;code&gt;gen_event(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">默认的简单处理程序称为 &lt;code&gt;alarm_handler&lt;/code&gt; ，可以通过将 &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; 调用为 &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt; 。 &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; 被调用。有关更多详细信息，请参见STDLIB中的 &lt;code&gt;gen_event(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edd4ef6f5a1e3a142885438b41744f5b5b26e5b7" translate="yes" xml:space="preserve">
          <source>The default socket options are &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt;.</source>
          <target state="translated">默认的套接字选项是 &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b0a75358d0df669ac13a835e5ee193bd00512b1" translate="yes" xml:space="preserve">
          <source>The default standard handler, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, can be replaced by a disk_log handler at startup of the Kernel application. See an example of this below.</source>
          <target state="translated">默认的标准处理程序 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 可以在内核应用程序启动时由disk_log处理程序代替。请参阅下面的示例。</target>
        </trans-unit>
        <trans-unit id="56e59dc663ec3168b6b7eec38a9c17da04f70aec" translate="yes" xml:space="preserve">
          <source>The default start option &lt;code&gt;{dir,Cwd}&lt;/code&gt; (to run all suites in the current working directory) is used if the function is called with an empty list of options.</source>
          <target state="translated">如果使用空选项列表调用该函数，则使用默认的启动选项 &lt;code&gt;{dir,Cwd}&lt;/code&gt; （以运行当前工作目录中的所有套件）。</target>
        </trans-unit>
        <trans-unit id="8472d25153570bd73936053aa35b2f0053ff73f8" translate="yes" xml:space="preserve">
          <source>The default time limit for a test case is 30 minutes, unless a &lt;code&gt;timetrap&lt;/code&gt; is specified either by the suite-, group-, or test case information function. The timetrap time-out value defined by &lt;code&gt;suite/0&lt;/code&gt; is the value that is used for each test case in the suite (and for the configuration functions &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, and &lt;code&gt;end_per_group/2&lt;/code&gt;). A timetrap value defined by &lt;code&gt;group(GroupName)&lt;/code&gt; overrides one defined by &lt;code&gt;suite()&lt;/code&gt; and is used for each test case in group &lt;code&gt;GroupName&lt;/code&gt;, and any of its subgroups. If a timetrap value is defined by &lt;code&gt;group/1&lt;/code&gt; for a subgroup, it overrides that of its higher level groups. Timetrap values set by individual test cases (by the test case information function) override both group- and suite- level timetraps.</source>
          <target state="translated">测试用例的默认时间限制为30分钟，除非 &lt;code&gt;timetrap&lt;/code&gt; ，组或测试用例信息功能指定了时间段。 &lt;code&gt;suite/0&lt;/code&gt; 定义的超时超时值是套件中每个测试用例（以及配置函数 &lt;code&gt;init_per_suite/1&lt;/code&gt; ， &lt;code&gt;end_per_suite/1&lt;/code&gt; ， &lt;code&gt;init_per_group/2&lt;/code&gt; 和 &lt;code&gt;end_per_group/2&lt;/code&gt; ）使用的值。由 &lt;code&gt;group(GroupName)&lt;/code&gt; 定义的一个时间陷阱值将覆盖 &lt;code&gt;suite()&lt;/code&gt; 定义的一个值，并用于 &lt;code&gt;GroupName&lt;/code&gt; 和它的任何子组中的每个测试用例。如果时间间隔值由 &lt;code&gt;group/1&lt;/code&gt; 定义对于子组，它会覆盖其较高级别的组。由单个测试用例（通过测试用例信息功能）设置的时间陷阱值会覆盖组和套件级别的时间陷阱。</target>
        </trans-unit>
        <trans-unit id="b52b358a5f5402f0ac26ce2f8003f427f7c57d17" translate="yes" xml:space="preserve">
          <source>The default time-out is 5000 ms, unless otherwise specified. &lt;code&gt;timeout&lt;/code&gt; defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt;.</source>
          <target state="translated">除非另有说明，否则默认超时为5000毫秒。 &lt;code&gt;timeout&lt;/code&gt; 定义等待进程响应请求的时间。如果该过程没有响应，则该函数将评估 &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51ff8e06cc37d3f5fbc8359b214e014cbb5552d4" translate="yes" xml:space="preserve">
          <source>The default timeout is infinity</source>
          <target state="translated">默认的超时时间是无穷大</target>
        </trans-unit>
        <trans-unit id="517719740380d1d0fe303f5c01cd73d6a4f1b6a9" translate="yes" xml:space="preserve">
          <source>The default type (and currently the only type) of crypto algorithm is &lt;code&gt;des3_cbc&lt;/code&gt;, three rounds of DES. The key string is scrambled using &lt;code&gt;erlang:md5/1&lt;/code&gt; to generate the keys used for &lt;code&gt;des3_cbc&lt;/code&gt;.</source>
          <target state="translated">密码算法的默认类型（目前是唯一类型）是 &lt;code&gt;des3_cbc&lt;/code&gt; ，即三轮DES。使用 &lt;code&gt;erlang:md5/1&lt;/code&gt; 对密钥字符串进行加扰，以生成用于 &lt;code&gt;des3_cbc&lt;/code&gt; 的密钥。</target>
        </trans-unit>
        <trans-unit id="545949e03721db9053ce25eb33d2946d85caf9f1" translate="yes" xml:space="preserve">
          <source>The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; is integer, not float.</source>
          <target state="translated">段的默认类型是整数。即使值是文字，默认类型也不依赖于值。例如， &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; 的默认类型是整数，而不是浮点数。</target>
        </trans-unit>
        <trans-unit id="9c04943ccaa1784066dde4b82fadc56a0e22b6e6" translate="yes" xml:space="preserve">
          <source>The default unit depends on the the type. For &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt; it is 1. For binary it is 8.</source>
          <target state="translated">默认单位取决于类型。对于 &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;bitstring&lt;/code&gt; ,它是1。对于binary，它是8。</target>
        </trans-unit>
        <trans-unit id="55a938cf0dbdbfb06f3894ab3968c86b760e35c4" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If &lt;code&gt;Timeout&lt;/code&gt; is specified and no connection is accepted within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is returned.</source>
          <target state="translated">为默认值 &lt;code&gt;Timeout&lt;/code&gt; 为 &lt;code&gt;infinity&lt;/code&gt; 。如果指定了 &lt;code&gt;Timeout&lt;/code&gt; 并且在给定时间内未接受任何连接 &lt;code&gt;{error, timeout}&lt;/code&gt; 则返回{错误，超时}。</target>
        </trans-unit>
        <trans-unit id="06729acf2bd67efa6a3b5f8c86f4f2fa259ed112" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79b49abd7127b03f5d3f046367a7810a9be6e9ef" translate="yes" xml:space="preserve">
          <source>The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.</source>
          <target state="translated">这两个限制的默认值是Erlang虚拟机中的10,000,000。请注意,递归限制并不影响虚拟机的堆栈深度,因为PCRE for Erlang的编译方式是匹配函数从不在C栈上进行递归。</target>
        </trans-unit>
        <trans-unit id="2a019fd353ccc57a4984f8ab73e895be35e2ceca" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;code&gt;template&lt;/code&gt; configuration parameter depends on the value of the &lt;code&gt;single_line&lt;/code&gt; and &lt;code&gt;legacy_header&lt;/code&gt; configuration parameters as follows.</source>
          <target state="translated">为默认值 &lt;code&gt;template&lt;/code&gt; 配置参数依赖于值 &lt;code&gt;single_line&lt;/code&gt; 和 &lt;code&gt;legacy_header&lt;/code&gt; 如下配置参数。</target>
        </trans-unit>
        <trans-unit id="0bf6d99215a41e23b30022357e71e9041cbda827" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;0&lt;/code&gt;, which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per &lt;code&gt;READDIR&lt;/code&gt; request is limited to at most the given value.</source>
          <target state="translated">默认值为 &lt;code&gt;0&lt;/code&gt; ，表示没有上限。如果提供的话，每个 &lt;code&gt;READDIR&lt;/code&gt; 请求返回给SFTP客户端的文件名数量最多只能为给定值。</target>
        </trans-unit>
        <trans-unit id="8eb871dd540b5e77da06600e181f72827240ed7e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;262144&lt;/code&gt;</source>
          <target state="translated">默认值为 &lt;code&gt;262144&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9199a189c47e6bb7d92e1a9dbf9ee3c0844e971b" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;{0,infinity}&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;{0,infinity}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4282a5ade1b153ec0ef3ef75770c03f967209ae" translate="yes" xml:space="preserve">
          <source>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</source>
          <target state="translated">默认值是RFC 3539所要求的:改变它将导致非标准行为,只能用于模拟测试期间行为不端的节点。</target>
        </trans-unit>
        <trans-unit id="18ca71fb6a22d28ebdfdacf9ed5fe354e1ec6ffe" translate="yes" xml:space="preserve">
          <source>The default value is the &lt;code&gt;public_key&lt;/code&gt; entry in the list returned by &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">缺省值为 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 返回的列表中的 &lt;code&gt;public_key&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="2af35d2902848146372b486ac1179095a26eda1a" translate="yes" xml:space="preserve">
          <source>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</source>
          <target state="translated">默认值作为未初始化条目的值,一旦数组被创建,就不能更改。</target>
        </trans-unit>
        <trans-unit id="b459379a9db26d1ded876c98cb594522408f4fb6" translate="yes" xml:space="preserve">
          <source>The default value is: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</source>
          <target state="translated">默认值为： &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f42ce984a7a7881db87f25a990a361103af516d" translate="yes" xml:space="preserve">
          <source>The default value of USERDIR is &lt;code&gt;/home/&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#LOCALUSER&quot;&gt;LOCALUSER&lt;/a&gt;&lt;/code&gt;&lt;code&gt;/.ssh&lt;/code&gt;.</source>
          <target state="translated">USERDIR的默认值为 &lt;code&gt;/home/&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#LOCALUSER&quot;&gt;LOCALUSER&lt;/a&gt;&lt;/code&gt; &lt;code&gt;/.ssh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="243fb9da1068fdc22926720a51604f4646125511" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;.</source>
          <target state="translated">此选项的默认值为 &lt;code&gt;{ssh_file, []}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4850f9a420695e6f6e424866c3013c9d0bdbd2e3" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;. See also the manpage of &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">此选项的默认值为 &lt;code&gt;{ssh_file, []}&lt;/code&gt; 。另请参见 &lt;code&gt;ssh_file&lt;/code&gt; 的联机帮助页。</target>
        </trans-unit>
        <trans-unit id="c469af55771eecab0c4f9a0edd001fdb31022bb8" translate="yes" xml:space="preserve">
          <source>The default value of this option shall provide the above mentioned security guarantees and it shall be reasonable for most applications (~353 TB).</source>
          <target state="translated">该选项的默认值应提供上述的安全保证,对于大多数应用来说,它应该是合理的(约353 TB)。</target>
        </trans-unit>
        <trans-unit id="3d73b09c02067144770d80033f5560b2a2552422" translate="yes" xml:space="preserve">
          <source>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; for the behaviour of that module.</source>
          <target state="translated">默认值反映了这样一个事实，即像TCP这样的面向流的传输的传输模块可能无法从消息长度错误中恢复，因为这种传输必须使用消息长度标头将传入的字节流划分为单独的Diameter消息。无效的长度使它无法可靠地重新发现消息边界，这可能导致后续消息失败。有关该模块的行为，请参见 &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="296cd192efc745b8c34964c030037a92790a5853" translate="yes" xml:space="preserve">
          <source>The default value used is normally &lt;code&gt;65536&lt;/code&gt;. However, if the runtime system is able to determine maximum amount of file descriptors that it is allowed to open and this value is larger than &lt;code&gt;65536&lt;/code&gt;, the chosen value will increased to a value larger or equal to the maximum amount of file descriptors that can be opened.</source>
          <target state="translated">使用的默认值通常为 &lt;code&gt;65536&lt;/code&gt; 。但是，如果运行时系统能够确定允许打开的最大文件描述符数量，并且该值大于 &lt;code&gt;65536&lt;/code&gt; ，则所选值将增加到大于或等于最大文件描述符数量的值。开了</target>
        </trans-unit>
        <trans-unit id="5e3d6bd0706de8063989ab67ca84fec01864e172" translate="yes" xml:space="preserve">
          <source>The default values are 1 restart per 5 seconds. This was chosen to be safe for most systems, even with deep supervision hierarchies, but you will probably want to tune the settings for your particular use case.</source>
          <target state="translated">默认值是每5秒重启1次。选择这个值是为了对大多数系统是安全的,即使是深度监督层次结构,但你可能要根据你的特定用例调整设置。</target>
        </trans-unit>
        <trans-unit id="a4e004a8abd563009ef32e5cba1400cabe8dffcb" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;connect&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_connect_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定要 &lt;code&gt;connect&lt;/code&gt; 选项的默认值会受到内核配置参数 &lt;code&gt;inet_default_connect_options&lt;/code&gt; 的影响。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40a15125494e475b38c160cdf12b36e7e3d1c3f9" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;listen&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_listen_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定要 &lt;code&gt;listen&lt;/code&gt; 选项的默认值会受到内核配置参数 &lt;code&gt;inet_default_listen_options&lt;/code&gt; 的影响。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50fa0bf131c13c670fdcc5fdce169d626f359cef" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;originating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 发现选项的默认值为：</target>
        </trans-unit>
        <trans-unit id="9cb324b22317eaf8bd729f045fc4512eed8d2afc" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;terminating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 发现选项的默认值为：</target>
        </trans-unit>
        <trans-unit id="8b5bd661368c7d8e299861344ca3c98352edac6c" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt;. But the send options above, may explicitly be overridden.</source>
          <target state="translated">send选项的默认值由 &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt; 。但是上面的发送选项可能会被明确覆盖。</target>
        </trans-unit>
        <trans-unit id="b0aa1b655582755f5f4811f0eab7ca8a5d9f4319" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by megaco:conn_info(ConnHandle, Item). But the send options above, may explicitly be overridden.</source>
          <target state="translated">发送选项的默认值由megaco:conn_info(ConnHandle,Item)获得。但是上面的发送选项,可以明确地被覆盖。</target>
        </trans-unit>
        <trans-unit id="2ebf5b11205a5dd9778e91c6bfcc585a8fc51478" translate="yes" xml:space="preserve">
          <source>The default verbosity is &lt;code&gt;1&lt;/code&gt;. Verbosity &lt;code&gt;0&lt;/code&gt; can also be selected by option &lt;code&gt;nowarn_format&lt;/code&gt;.</source>
          <target state="translated">默认的详细程度是 &lt;code&gt;1&lt;/code&gt; 。冗长 &lt;code&gt;0&lt;/code&gt; 也可以通过选项选择 &lt;code&gt;nowarn_format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8f7ea1b49fdcb48ab2c2517d37ecba5139e4ff8" translate="yes" xml:space="preserve">
          <source>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate and the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; must be set, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">在两个节点之间建立连接时的默认设置是也立即连接所有其他可见节点。这样，总会有一个完全连接的网络。如果存在具有不同cookie的节点，则此方法可能不合适，必须设置命令行标志 &lt;code&gt;-connect_all false&lt;/code&gt; ，请参见ERTS中的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="3cf210e7ecc7b461b7955d0d98ee29107a5a6b0b" translate="yes" xml:space="preserve">
          <source>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &amp;gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</source>
          <target state="translated">默认值。仅ISO Latin-1范围内的字符可以被认为是可打印的。这意味着代码点大于255的字符从不被认为是可打印的，并且包含此类字符的列表通过工具显示为整数列表，而不是文本字符串。</target>
        </trans-unit>
        <trans-unit id="46e506cdb258a82f462a7f2164d0f42a9f2072f8" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt; unless the driver itself does modifications of these values.</source>
          <target state="translated">除非驱动程序本身对这些值进行修改，否则默认 &lt;code&gt;Low = 4096&lt;/code&gt; 和 &lt;code&gt;High = 8192&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e29513f39a50cabbc123316e69281febedaa0e1c" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt;.</source>
          <target state="translated">默认 &lt;code&gt;Low = 4096&lt;/code&gt; 和 &lt;code&gt;High = 8192&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11fa3688f9aa1dc5e88e515adb5d88b7a205fe35" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since earlier versions of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">自 &lt;code&gt;Erl_Interface&lt;/code&gt; 的早期版本以来， &lt;code&gt;ErlMessage&lt;/code&gt; 的定义已更改。</target>
        </trans-unit>
        <trans-unit id="6fdae1ac6fb499a05429a1e07e8362960f5b8b56" translate="yes" xml:space="preserve">
          <source>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</source>
          <target state="translated">忙碌的调度器的定义是当它没有闲置,没有调度(选择)进程或端口时,也就是。</target>
        </trans-unit>
        <trans-unit id="82ba3b05846ab652707aa41300a0f8920d31d2e5" translate="yes" xml:space="preserve">
          <source>The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</source>
          <target state="translated">服务允许向同一对等体提供多个传输连接的程度,如其在能力交换时由原点-主机确定。</target>
        </trans-unit>
        <trans-unit id="1d3a7346db37c7fe972c4b73fbfa32235de91911" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt; erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">与系统中的其他事件相比，跟踪消息（由 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;seq_trace(3)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt; erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; 生成）的传递在时间轴上错位。如果您知道 &lt;code&gt;Tracee&lt;/code&gt; 在执行过程中已通过某个特定点，并且想知道至少与该事件之前的事件相对应的所有跟踪消息何时到达了跟踪器，请使用 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="995215813ca9fa0e2bcd7a40357169c4691820c6" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">与系统中的其他事件相比，跟踪消息（由 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;seq_trace(3)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; 生成）的传递在时间轴上错位。如果您知道 &lt;code&gt;Tracee&lt;/code&gt; 在执行过程中已通过某个特定点，并且您想知道至少与该事件之前的事件相对应的所有跟踪消息何时到达了跟踪器，请使用 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef74e5139b7ce6e4f98a4baef24c6182968b430c" translate="yes" xml:space="preserve">
          <source>The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the &lt;code&gt;makedep&lt;/code&gt; option.</source>
          <target state="translated">创建依赖关系是正常编译过程的副作用。这意味着还将生成目标文件。该选项将覆盖 &lt;code&gt;makedep&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d1ab3d1ea275bdf26541729c8fac923c58fe1c95" translate="yes" xml:space="preserve">
          <source>The dependency graph windows are launched from the file menu in the system window. The graph depicts all included and derived applications/modules and their dependencies.</source>
          <target state="translated">依赖关系图窗口从系统窗口的文件菜单中启动。该图描述了所有包含和派生的应用程序/模块及其依赖关系。</target>
        </trans-unit>
        <trans-unit id="2a97d6fbaa7c8cc7934aab7b5d9a9bb87b6b518f" translate="yes" xml:space="preserve">
          <source>The described durability feature does not entirely apply to situations where &lt;code&gt;Mnesia&lt;/code&gt; is configured as a &quot;pure&quot; primary memory database.</source>
          <target state="translated">所描述的持久性功能并不完全适用于将 &lt;code&gt;Mnesia&lt;/code&gt; 配置为&amp;ldquo;纯&amp;rdquo;主内存数据库的情况。</target>
        </trans-unit>
        <trans-unit id="c5fd3c33ad96d6f9da0b92a6b9de73850c0f031c" translate="yes" xml:space="preserve">
          <source>The described syntax can also be used in test specifications to change group properties at the time of execution, without having to edit the test suite. For more information, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">所描述的语法也可以在测试规范中使用，以在执行时更改组属性，而无需编辑测试套件。有关更多信息，请参阅&amp;ldquo; 运行测试和分析结果&amp;rdquo; 部分中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="086c0b30f28f757ab34cbfdd1e7d1db76083baee" translate="yes" xml:space="preserve">
          <source>The description is based on &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt;, which is not to be further updated.</source>
          <target state="translated">该描述基于 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt; ，将不再进行更新。</target>
        </trans-unit>
        <trans-unit id="b29537c79e1bc001111fcb298cafeaf2c947455f" translate="yes" xml:space="preserve">
          <source>The descriptions of the options uses the &lt;code&gt;Erlang Type Language&lt;/code&gt; with explaining text.</source>
          <target state="translated">选项的描述使用带有说明文字的 &lt;code&gt;Erlang Type Language&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccde6c91194772388df62e195ba8cf52e9380085" translate="yes" xml:space="preserve">
          <source>The design choice between two or three generations of code access structures is a trade-off between memory consumption and code loading latency.</source>
          <target state="translated">两代或三代代码访问结构的设计选择,是对内存消耗和代码加载延迟的权衡。</target>
        </trans-unit>
        <trans-unit id="45a17206933877eeb5bf9c5379a4ed51695a5147" translate="yes" xml:space="preserve">
          <source>The destination of these log events was configured by &lt;code&gt;SASL configuration parameters&lt;/code&gt;.</source>
          <target state="translated">这些日志事件的目标由 &lt;code&gt;SASL configuration parameters&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1700577536e62effc25b554cb01dfedd3d5fe8bb" translate="yes" xml:space="preserve">
          <source>The details of finding other nodes (that is, talking to &lt;code&gt;epmd&lt;/code&gt; or something similar)</source>
          <target state="translated">查找其他节点的详细信息（即与 &lt;code&gt;epmd&lt;/code&gt; 对话或类似内容）</target>
        </trans-unit>
        <trans-unit id="8904690d17dfc4476f5a61b68a154f7e139b04e4" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要OpenSSL的开发包，包括头文件以及二进制命令程序 &lt;code&gt;openssl&lt;/code&gt; 。至少需要OpenSSL 0.9.8版。阅读更多内容，并从 &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt; 下载。</target>
        </trans-unit>
        <trans-unit id="7d180f092b7b3bd940337d54bfa93d4b66eb9f08" translate="yes" xml:space="preserve">
          <source>The diameter application includes five dictionary modules corresponding to applications defined in section 2.4 of RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; and &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; for the Diameter Common Messages application with application identifier 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (for RFC 3588) and &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; for the Diameter Base Accounting application with application identifier 3 and &lt;code&gt;diameter_gen_relay&lt;/code&gt; the Relay application with application identifier 0xFFFFFFFF.</source>
          <target state="translated">直径应用包括对应于在RFC 6733的2.4部分中定义的应用程序5个字典模块： &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; 和 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 用于与应用程序标识符0的Diameter普通消息应用程序， &lt;code&gt;diameter_gen_accounting&lt;/code&gt; （对于RFC 3588）和 &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; 用于与应用程序标识符3 Diameter基础会计应用和 &lt;code&gt;diameter_gen_relay&lt;/code&gt; 具有应用程序标识符0xFFFFFFFF的中继应用程序。</target>
        </trans-unit>
        <trans-unit id="55ad411fdd3feccef9ab5e2a70e1c6ecf0dda6f6" translate="yes" xml:space="preserve">
          <source>The diameter application is an implementation of the Diameter protocol as defined by RFC 6733. It supports arbitrary Diameter applications by way of a &lt;strong&gt;dictionary&lt;/strong&gt; interface that allows messages and AVPs to be defined and input into diameter as configuration. It has support for all roles defined in the RFC: client, server and agent. This chapter provides a short overview of the application.</source>
          <target state="translated">直径应用程序是RFC 6733定义的Diameter协议的实现。它通过&lt;strong&gt;字典&lt;/strong&gt;接口支持任意Diameter应用程序，该&lt;strong&gt;字典&lt;/strong&gt;接口允许定义消息和AVP并作为配置输入到直径中。它支持RFC中定义的所有角色：客户端，服务器和代理。本章简要介绍了该应用程序。</target>
        </trans-unit>
        <trans-unit id="b44b3ae3e6de975127d9868877e61eebf74c5fa6" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before calling most functions in this module.</source>
          <target state="translated">在调用本模块中的大多数函数之前,必须先启动直径应用。</target>
        </trans-unit>
        <trans-unit id="5970544b2f23768c3400e92a3796dc5f84073d7d" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling &lt;code&gt;start/0&lt;/code&gt; explicitly.</source>
          <target state="translated">开始维修之前，必须先启动直径应用程序。在生产系统中，这通常是通过引导文件而不是通过显式调用 &lt;code&gt;start/0&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="8d87148c3c9af3d9845486aa30c973c1b2043ba3" translate="yes" xml:space="preserve">
          <source>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's &lt;code&gt;peer_up/3&lt;/code&gt; callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</source>
          <target state="translated">直径应用负责与对等方交换CER / CEA。成功完成功能交换后，服务将调用每个相关应用程序模块的 &lt;code&gt;peer_up/3&lt;/code&gt; 回调，此后调用方可以通过传输与对等方交换Diameter消息。除了CER / CEA，该服务还负责处理RFC 3539和DPR / DPA所要求的DWR / DWA。</target>
        </trans-unit>
        <trans-unit id="fb2713bf78bad945032228e7d72a8fff3c2317e0" translate="yes" xml:space="preserve">
          <source>The diameter user does not need to call functions here explicitly when sending and receiving messages using &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; and the callback interface documented in &lt;code&gt;diameter_app(3)&lt;/code&gt;: diameter itself provides encode/decode as a consequence of configuration passed to &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, and the results may differ from those returned by the functions documented here, depending on configuration.</source>
          <target state="translated">直径用户在使用 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 和在 &lt;code&gt;diameter_app(3)&lt;/code&gt; 记录的回调接口发送和接收消息时，无需在此处显式调用函数：直径本身由于传递给 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 的配置而提供了编码/解码2，结果可能与此处记录的功能所返回的结果有所不同，具体取决于配置。</target>
        </trans-unit>
        <trans-unit id="2251e3cdeb76f922995ac0b63ebf88f13a0667db" translate="yes" xml:space="preserve">
          <source>The diameterc utility is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter required to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">diameterc实用程序用于将直径 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 编译为Erlang源。结果源实现了对字典的消息和AVP进行编码和解码所需的接口直径。</target>
        </trans-unit>
        <trans-unit id="a115af3fd2bc7d650329a3a62d8207ca3be6bd75" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt; deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">压缩器选择的字典可以从对inflate函数的调用返回或抛出的Adler值中确定。压缩器和解压缩器必须使用相同的字典（请参阅 &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt; deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a8b611f53150beb161ae68d1baa02e238a69d7fe" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">压缩器选择的字典可以从对inflate函数的调用返回或抛出的Adler值中确定。压缩器和解压缩器必须使用相同的字典（请参阅 &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dc7c7b0117c79bf085087df0d9077cbcde71b86c" translate="yes" xml:space="preserve">
          <source>The dictionary interface documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; provides extensibility, allowing the user to defined new AVPs, commands, and applications. Ready dictionaries are provided for the RFC 6733 common message, base accounting, and relay applications, as well as for RFC 7683, Diameter Overload Indicator Conveyance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 接口（4）中记录的词典接口提供了可扩展性，允许用户定义新的AVP，命令和应用程序。为RFC 6733通用消息，基本记帐和中继应用程序以及RFC 7683（直径超载指示器传输）提供了现成的字典。</target>
        </trans-unit>
        <trans-unit id="569d4e7fc1379c78daae74de968aa2107c8de266" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; on one hand, and &lt;code&gt;ordered_set&lt;/code&gt; on the other, regarding the fact that &lt;code&gt;ordered_set&lt;/code&gt; view keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt; whereas the other table types regard them equal only when they &lt;strong&gt;match&lt;/strong&gt;, holds for &lt;code&gt;lookup_element/3&lt;/code&gt;.</source>
          <target state="translated">之间的差异 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; 和 &lt;code&gt;duplicate_bag&lt;/code&gt; 一方面，和 &lt;code&gt;ordered_set&lt;/code&gt; 有关的事实，另一方面， &lt;code&gt;ordered_set&lt;/code&gt; 视图中的键为相等时，他们&lt;strong&gt;比较相等&lt;/strong&gt;，而其它类型的表把它们只有当他们平等&lt;strong&gt;匹配&lt;/strong&gt;，适用于 &lt;code&gt;lookup_element/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="623ffdc435a2f724f0836bec7cc8ec30bc41c15a" translate="yes" xml:space="preserve">
          <source>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</source>
          <target state="translated">列表作为语义对象(由单个的 &quot;cons &quot;和 &quot;nil &quot;术语组成)与表示列表的各种语法形式之间的区别,起初可能会让人感到困惑。本模块提供的功能既可以精确控制句法表示,也可以用cons和头/尾操作进行简单的组成和解构。</target>
        </trans-unit>
        <trans-unit id="da1728bb07e837f250209bb055d7409170953dd6" translate="yes" xml:space="preserve">
          <source>The difference between the &lt;code&gt;config&lt;/code&gt; terms above is that with &lt;code&gt;ConfigDir&lt;/code&gt;, &lt;code&gt;ConfigBaseNames&lt;/code&gt; is a list of base names, that is, without directory paths. &lt;code&gt;ConfigFiles&lt;/code&gt; must be full names, including paths. For example, the following two terms have the same meaning:</source>
          <target state="translated">上面的 &lt;code&gt;config&lt;/code&gt; 条款之间的区别在于，使用 &lt;code&gt;ConfigDir&lt;/code&gt; 时， &lt;code&gt;ConfigBaseNames&lt;/code&gt; 是基本名称的列表，即没有目录路径。 &lt;code&gt;ConfigFiles&lt;/code&gt; 必须为全名，包括路径。例如，以下两个术语具有相同的含义：</target>
        </trans-unit>
        <trans-unit id="4f869b97b89ad5b7b934ce2b75aa574db5f22948" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is in how they get the modules to check. &lt;code&gt;versions1&lt;/code&gt; uses the app-file and &lt;code&gt;versions2&lt;/code&gt; uses the function &lt;code&gt;application:get_key&lt;/code&gt;.</source>
          <target state="translated">两种功能之间的区别在于它们如何获取模块进行检查。 &lt;code&gt;versions1&lt;/code&gt; 使用应用程序文件，而 &lt;code&gt;versions2&lt;/code&gt; 使用功能 &lt;code&gt;application:get_key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="633f35639fdb5cc1cb10fd8f4689bf3336703581" translate="yes" xml:space="preserve">
          <source>The difference between these functions is the order the table is accessed for &lt;code&gt;ordered_set&lt;/code&gt; tables. For other table types the functions are equivalent.</source>
          <target state="translated">这些函数之间的区别是为 &lt;code&gt;ordered_set&lt;/code&gt; 表访问表的顺序。对于其他表类型，功能是等效的。</target>
        </trans-unit>
        <trans-unit id="293fb4be14373398bacd278126f271ff3f4aab95" translate="yes" xml:space="preserve">
          <source>The difference between using the macros and the exported functions is that macros add location (originator) information to the metadata, and performs lazy evaluation by wrapping the logger call in a case statement, so it is only evaluated if the log level of the event passes the primary log level check.</source>
          <target state="translated">使用宏和导出函数的不同之处在于,宏在元数据中添加了位置(发起者)信息,并通过将记录器调用包装在case语句中执行懒惰评估,因此只有在事件的日志级别通过初级日志级别检查时才会进行评估。</target>
        </trans-unit>
        <trans-unit id="9bd33d3347fbec04e6dd5bced0f65f041be1e03c" translate="yes" xml:space="preserve">
          <source>The difference here is that a check is made for two keys in each map argument. The other keys are ignored.</source>
          <target state="translated">不同的是,每个map参数中的两个键会被检查。其他键会被忽略。</target>
        </trans-unit>
        <trans-unit id="57afc2a6da2d7ad1a93ff6f446c9b773c487ccf9" translate="yes" xml:space="preserve">
          <source>The difference is the same as between &lt;code&gt;=:=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">区别与 &lt;code&gt;=:=&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 之间的区别相同。</target>
        </trans-unit>
        <trans-unit id="a13a50925424597a830fc48487f1c8e6506ee4cb" translate="yes" xml:space="preserve">
          <source>The different &lt;code&gt;&lt;a href=&quot;#Time-Outs&quot;&gt;Time-Outs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;next_event&lt;/a&gt;&lt;/code&gt; actions generate new events with corresponding &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; Event Types and Event Content &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不同的 &lt;code&gt;&lt;a href=&quot;#Time-Outs&quot;&gt;Time-Outs&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;next_event&lt;/a&gt;&lt;/code&gt; 操作将生成具有相应 &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; Event Types and Event Content &lt;/a&gt;&lt;/code&gt; 新事件。</target>
        </trans-unit>
        <trans-unit id="37953effd4c1eb8de7eafd4f2558c81bd077904b" translate="yes" xml:space="preserve">
          <source>The different amounts of memory that are summed are &lt;strong&gt;not&lt;/strong&gt; gathered atomically, which introduces an error in the result.</source>
          <target state="translated">汇总的不同内存量&lt;strong&gt;不是&lt;/strong&gt;原子收集的，这会在结果中引入错误。</target>
        </trans-unit>
        <trans-unit id="63548572b896ecd0cf28068a1070f068efa94f1e" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; to load the MIB, and &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">不同的应用程序使用不同的策略将MIB加载到代理中。一些MIB实现仅是代码，而其他一些则需要服务器。仅代码的MIB实现使用的一种方式是，用户调用 &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; 之类的函数来加载MIB​​，而 &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; 之类的函数来卸载MIB。有关如何加载每个MIB的说明，请参见每个应用程序的手册页。</target>
        </trans-unit>
        <trans-unit id="c8edadae2095be022adc91aad4a672571547faa5" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to load the MIB, and &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">不同的应用程序使用不同的策略将MIB加载到代理中。一些MIB实施仅是代码，而其他一些则需要服务器。仅代码的MIB实现使用的一种方式是，用户调用诸如 &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; 类的函数来加载MIB​​，并 &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; 来卸载该函数。MIB。有关如何加载每个MIB的说明，请参见每个应用程序的手册页。</target>
        </trans-unit>
        <trans-unit id="b79b82512ebbf07ebe9d9f10fb15d9e8e743cedd" translate="yes" xml:space="preserve">
          <source>The different options that can be given to &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以给 &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; 提供不同的选项。</target>
        </trans-unit>
        <trans-unit id="c7a06445034a6453f0f6ebe99a200207183eacb6" translate="yes" xml:space="preserve">
          <source>The different queries are described in section &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt; 一节中介绍了不同的查询。</target>
        </trans-unit>
        <trans-unit id="39eab07bc9f9f2de5d553eb9e3b513aeec95de3f" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">线程可以处于的不同状态。有关详细信息，请参见 &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc4891f4df1692cd0b3f6e8badc0320a795dc5b" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">线程可以处于的不同状态。有关详细信息，请参见 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59070d2c07904f6e20fde995a37ca6d79f115caa" translate="yes" xml:space="preserve">
          <source>The different trace tags that the tracer is called with. Each trace tag is described in detail in &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用跟踪器的不同跟踪标记。每个跟踪标记在 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 中有详细描述。</target>
        </trans-unit>
        <trans-unit id="26366e48ea2a96c9fc5d9a43d23aaffa5017f9cd" translate="yes" xml:space="preserve">
          <source>The different types are as follows:</source>
          <target state="translated">不同的类型如下:</target>
        </trans-unit>
        <trans-unit id="33105c1c6606db02bff579f3c5759de25bdebf48" translate="yes" xml:space="preserve">
          <source>The different types of schedulers handle specific types of jobs. Every job is assigned to a specific scheduler type. Jobs can migrate between different schedulers of the same type, but never between schedulers of different types. This fact has to be taken under consideration when evaluating the result returned.</source>
          <target state="translated">不同类型的调度器处理特定类型的作业。每个作业都被分配到一个特定的调度器类型。作业可以在同一类型的不同调度器之间迁移,但绝不能在不同类型的调度器之间迁移。在评估返回的结果时,必须考虑到这一事实。</target>
        </trans-unit>
        <trans-unit id="1be30a2a4e12fc360bee8dc49ed629e5a73999d2" translate="yes" xml:space="preserve">
          <source>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</source>
          <target state="translated">不同的值之间有以下关系。以大写字母开头的值不属于结果的一部分。</target>
        </trans-unit>
        <trans-unit id="27f3bb8909ba5f23310f5128f455bc5958825585" translate="yes" xml:space="preserve">
          <source>The digraph can be read and modified by the creating process only.</source>
          <target state="translated">数字图只能由创建过程来读取和修改。</target>
        </trans-unit>
        <trans-unit id="5490f515ffc9d05efae42bd4eb4b5cd4c506605c" translate="yes" xml:space="preserve">
          <source>The digraph is to be kept &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该图应保持 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a122eabc0003f4c72a6d838ab9da37d1a4643c2" translate="yes" xml:space="preserve">
          <source>The digraphs managed by this module are stored in &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS tables&lt;/a&gt;&lt;/code&gt;. That implies the following:</source>
          <target state="translated">此模块管理的图被存储在 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS tables&lt;/a&gt;&lt;/code&gt; 。这意味着以下内容：</target>
        </trans-unit>
        <trans-unit id="08c044f6070f82e882ec6b0eabc539f770d3dd32" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-error(Term)&lt;/code&gt; causes a compilation error.</source>
          <target state="translated">指令 &lt;code&gt;-error(Term)&lt;/code&gt; 导致编译错误。</target>
        </trans-unit>
        <trans-unit id="b3797b9e1d8ee2883c9f63d0a42a95ca4d06540e" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-warning(Term)&lt;/code&gt; causes a compilation warning.</source>
          <target state="translated">指令 &lt;code&gt;-warning(Term)&lt;/code&gt; 会引起编译警告。</target>
        </trans-unit>
        <trans-unit id="58617ed5f0889f1d1f3277ea479ef4c02a22c0a7" translate="yes" xml:space="preserve">
          <source>The directories given by the &lt;code&gt;include&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 选项给定的目录</target>
        </trans-unit>
        <trans-unit id="1f52da4640ac6f1c489638d9eafbfb94f7337064" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;-I&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">使用选项 &lt;code&gt;-I&lt;/code&gt; 指定的目录；首先搜索最后指定的目录</target>
        </trans-unit>
        <trans-unit id="071745beb88d646a425661fabb7b2b140020baaf" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;i&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">使用选项 &lt;code&gt;i&lt;/code&gt; 指定的目录；首先搜索最后指定的目录</target>
        </trans-unit>
        <trans-unit id="be6fba73ebc340991bdfb6820c1ebc97ba0e0651" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;Path&lt;/code&gt;does not exist.</source>
          <target state="translated">目录 &lt;code&gt;Path&lt;/code&gt; 不存在。</target>
        </trans-unit>
        <trans-unit id="7bccd89dc32dbb0c503ff0753756340f2c3e005e" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 更改目录。</target>
        </trans-unit>
        <trans-unit id="cdb62f5fdc6e1ffa70960cbc73d316528fae55b5" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用选项 &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 更改目录。</target>
        </trans-unit>
        <trans-unit id="acc2f12b5fc8219c0bfb75133fa338329e4cc3b0" translate="yes" xml:space="preserve">
          <source>The directory does not exist.</source>
          <target state="translated">该目录不存在。</target>
        </trans-unit>
        <trans-unit id="117b6acef024fb182d6e7698c7419f59fe7b75af" translate="yes" xml:space="preserve">
          <source>The directory for (1) back-up copy and (2) Erlang-specific configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">（1）备份副本和（2） &lt;code&gt;syslogd&lt;/code&gt; 特定于Erlang的配置文件的目录</target>
        </trans-unit>
        <trans-unit id="339f3fbc63ee87a760e5d5881f1be19ceac96fd2" translate="yes" xml:space="preserve">
          <source>The directory is not empty.</source>
          <target state="translated">该目录不是空的。</target>
        </trans-unit>
        <trans-unit id="7febdc58b57a39ad1e446e02f6b42469827aa2db" translate="yes" xml:space="preserve">
          <source>The directory listing also contains one &lt;code&gt;.DAT&lt;/code&gt; file, which contains the schema itself, contained in the &lt;code&gt;schema.DAT&lt;/code&gt; file. The &lt;code&gt;DAT&lt;/code&gt; files are indexed files, and it is efficient to insert and search for records in these files with a specific key. The &lt;code&gt;.DAT&lt;/code&gt; files are used for the schema and for &lt;code&gt;disc_only_copies&lt;/code&gt; tables. The &lt;code&gt;Mnesia&lt;/code&gt; data files are currently implemented in the standard library module &lt;code&gt;dets&lt;/code&gt; in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">目录列表还包含一个 &lt;code&gt;.DAT&lt;/code&gt; 文件，该文件包含 &lt;code&gt;schema.DAT&lt;/code&gt; 文件中包含的模式本身。该 &lt;code&gt;DAT&lt;/code&gt; 文件是索引文件，它是有效的插入和搜索与特定键这些文件记录。该 &lt;code&gt;.DAT&lt;/code&gt; 文件被用于模式和 &lt;code&gt;disc_only_copies&lt;/code&gt; 表。在 &lt;code&gt;Mnesia&lt;/code&gt; 的数据文件中的标准库模块目前实施的 &lt;code&gt;dets&lt;/code&gt; 在 &lt;code&gt;STDLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc8511921c9959d184fd92a30bcce8e510e914f" translate="yes" xml:space="preserve">
          <source>The directory structure for the code installed by the release handler from a release package is as follows:</source>
          <target state="translated">发布处理程序从发布包中安装的代码的目录结构如下。</target>
        </trans-unit>
        <trans-unit id="a42562d2ee99aac69e248e9c1d20b489a29d934f" translate="yes" xml:space="preserve">
          <source>The directory to read the application from. This parameter can be used to point out a specific location to fetch the application from. This is useful for instance if the parent directory for some reason is no good as a library directory on system level.</source>
          <target state="translated">要读取应用程序的目录。这个参数可以用来指出一个特定的位置来读取应用程序。例如,当父目录由于某些原因不能作为系统级的库目录时,这个参数就很有用。</target>
        </trans-unit>
        <trans-unit id="d7bfc486e65b60f6f17e8c030cc98aaf1f5887ba" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are put can be chosen explicitly. The default, implied by value &lt;code&gt;&quot;&quot;&lt;/code&gt;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by &lt;code&gt;file:get_cwd()&lt;/code&gt; is used instead. The names of temporary files are derived from the Erlang nodename (&lt;code&gt;node()&lt;/code&gt;), the process identifier of the current Erlang emulator (&lt;code&gt;os:getpid()&lt;/code&gt;), and a unique integer (&lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt;). A typical name is &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt;, where &lt;code&gt;17&lt;/code&gt; is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught &lt;code&gt;EXIT&lt;/code&gt; signal occurs.</source>
          <target state="translated">放置临时文件的目录可以明确选择。默认值（由值 &lt;code&gt;&quot;&quot;&lt;/code&gt; ）是将临时文件与排序后的输出文件放在同一目录中。如果输出是函数（请参见下文），则使用 &lt;code&gt;file:get_cwd()&lt;/code&gt; 返回的目录。临时文件的名称派生自Erlang节点名（ &lt;code&gt;node()&lt;/code&gt; ），当前Erlang仿真器的进程标识符（ &lt;code&gt;os:getpid()&lt;/code&gt; ）和唯一整数（ &lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt; ）。典型的名称是 &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt; ，其中 &lt;code&gt;17&lt;/code&gt; 是序列号。现有文件将被覆盖。除非某些未捕获的 &lt;code&gt;EXIT&lt;/code&gt; ,否则将删除临时文件 信号发生。</target>
        </trans-unit>
        <trans-unit id="26b2546fb62728f487df23d7a64fc6038e2f04cd" translate="yes" xml:space="preserve">
          <source>The directory where the compiler is to place the output files. Defaults to the current working directory.</source>
          <target state="translated">编译器放置输出文件的目录。默认为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="23d4b2c59c247070b6160ec438b2f4a12342bdf0" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the agent.</source>
          <target state="translated">配置文件所在的目录是作为参数给代理的。</target>
        </trans-unit>
        <trans-unit id="f35f2fdf2411bb1709c721e727448cb07cb8e62e" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the manager.</source>
          <target state="translated">配置文件所在的目录是作为参数给管理器的。</target>
        </trans-unit>
        <trans-unit id="57ac9409f64c817119b2a62c56ec2039ee44af45" translate="yes" xml:space="preserve">
          <source>The directory where the module is being compiled</source>
          <target state="translated">模块正在编译的目录</target>
        </trans-unit>
        <trans-unit id="a823ed8e05f4f19f697c128e1d3b1f2bf689cda5" translate="yes" xml:space="preserve">
          <source>The disconnect may either be made explicitly by a call to megaco:disconnect/2 or implicitly when the control process of the connection dies.</source>
          <target state="translated">断开连接可以通过调用megaco:disconnect/2显式进行,也可以在连接的控制进程死亡时隐式进行。</target>
        </trans-unit>
        <trans-unit id="4ffbc4f5819bc4c210bf785d2c507c9b376119c7" translate="yes" xml:space="preserve">
          <source>The discovery module may implement the following callback:</source>
          <target state="translated">发现模块可以实现以下回调。</target>
        </trans-unit>
        <trans-unit id="84d184d395f04b053ca8e8de39c92096a4dfaac1" translate="yes" xml:space="preserve">
          <source>The discovery module needs to implement the same API as the regular &lt;code&gt;EPMD module&lt;/code&gt;. However, instead of communicating with EPMD you can connect to any service to find out connection details of other nodes. A discovery module is enabled by setting &lt;code&gt;-epmd_module&lt;/code&gt; when starting erlang. The discovery module must implement the following callbacks:</source>
          <target state="translated">发现模块需要实现与常规 &lt;code&gt;EPMD module&lt;/code&gt; 相同的API 。但是，无需与EPMD通信，您可以连接到任何服务以查找其他节点的连接详细信息。启动erlang时通过设置 &lt;code&gt;-epmd_module&lt;/code&gt; 来启用发现模块。发现模块必须实现以下回调：</target>
        </trans-unit>
        <trans-unit id="99d7db3ae01fbb644d3dec6e8da4ab75b95c8848" translate="yes" xml:space="preserve">
          <source>The disk log process is not terminated as long as there are owners or users of the log. All owners must close the log, possibly by terminating. Also, any other process, not only the processes that have opened the log anonymously, can decrement the &lt;code&gt;users&lt;/code&gt; counter by closing the log. Attempts to close a log by a process that is not an owner are ignored if there are no users.</source>
          <target state="translated">只要有日志所有者或用户，磁盘日志过程就不会终止。所有所有者必须关闭日志，可能要终止。同样，任何其他进程，不仅是匿名打开日志的进程，都可以通过关闭日志来减少 &lt;code&gt;users&lt;/code&gt; 计数器。如果没有用户，则尝试通过非所有者进程关闭日志的尝试将被忽略。</target>
        </trans-unit>
        <trans-unit id="170e47f1105c3410c9337c315483a1099114bce2" translate="yes" xml:space="preserve">
          <source>The disk space required by Solaris can be minimized by using the Core User support installation. It requires about 80 MB of disk space. This installs only the minimum software required to boot and run Solaris. The disk space can be further reduced by deleting unnecessary individual files. However, unless disk space is a critical resource the effort required and the risks involved cannot be justified.</source>
          <target state="translated">通过使用核心用户支持安装,可以将Solaris所需的磁盘空间降到最低。它需要大约80 MB的磁盘空间。这只安装了启动和运行Solaris所需的最低软件。可以通过删除不必要的单个文件来进一步减少磁盘空间。然而,除非磁盘空间是一个关键资源,否则所需的努力和所涉及的风险是不值得的。</target>
        </trans-unit>
        <trans-unit id="fe0b0c298992c4d4142451f12161d0c1045bd18b" translate="yes" xml:space="preserve">
          <source>The distributed &lt;code&gt;disk_log&lt;/code&gt; feature is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; 分布式 &lt;code&gt;disk_log&lt;/code&gt; 功能，并将在OTP 24中将其删除。</target>
        </trans-unit>
        <trans-unit id="3a6a6e83a54df4db4da031bb114c30e047aae690" translate="yes" xml:space="preserve">
          <source>The distributed disk log feature has been deprecated. This feature has also been scheduled for removal in OTP 24.</source>
          <target state="translated">分布式磁盘日志功能已被废弃。该功能也已计划在OTP 24中取消。</target>
        </trans-unit>
        <trans-unit id="5252445bcfdf0c4e9a0db2f6abd1c5ab396bbcae" translate="yes" xml:space="preserve">
          <source>The distribution does this implicitly when sending messages across node boundaries.</source>
          <target state="translated">分发在跨节点边界发送消息时,会隐性地做到这一点。</target>
        </trans-unit>
        <trans-unit id="54a389857119d0e949a971f667eeb2bc4135d70c" translate="yes" xml:space="preserve">
          <source>The distribution header format is as follows:</source>
          <target state="translated">分发头的格式如下:</target>
        </trans-unit>
        <trans-unit id="ec94c3993a60ce6a0e075478f122164e01b59597" translate="yes" xml:space="preserve">
          <source>The distribution header is sent by the erlang distribution to carry metadata about the coming &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; and potential payload. It is primarily used to handle the atom cache in the Erlang distribution. Since OTP-22 it is also used to fragment large distribution messages into multiple smaller fragments. For more information about how the distribution uses the distribution header, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">分发头由erlang分发发送，以携带有关即将到来的 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; 和潜在有效负载的元数据。它主要用于处理Erlang发行版中的原子缓存。从OTP-22开始，它还用于将大型分发消息分段为多个较小的分段。有关分发如何使用分发标头的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; 文档中 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; 的协议文档。</target>
        </trans-unit>
        <trans-unit id="7207d53f2df6dd951040b5a96c6e6f572abc8fba" translate="yes" xml:space="preserve">
          <source>The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">分发标头仅包含一个原子缓存参考部分，但将来可能包含更多信息。分发标题在外部格式上位于一个或多个Erlang术语之前。有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; 文档中 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; 的协议文档。</target>
        </trans-unit>
        <trans-unit id="c2379df6378023fbabe88db9769e48826a29d56a" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">分发机制是使用TCP / IP套接字实现的。《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 介绍了如何实现替代载体。</target>
        </trans-unit>
        <trans-unit id="62295fb74df53713cac7805be082a69085ad9fa7" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is not backward compatible by default. This flag sets the emulator in compatibility mode with an earlier Erlang/OTP release &lt;code&gt;ReleaseNumber&lt;/code&gt;. The release number must be in the range &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt;. This limits the emulator, making it possible for it to communicate with Erlang nodes (as well as C- and Java nodes) running that earlier release.</source>
          <target state="translated">默认情况下，分发机制不向后兼容。该标志将模拟器设置为与早期Erlang / OTP版本 &lt;code&gt;ReleaseNumber&lt;/code&gt; 兼容的模式。版本号必须在 &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt; 的范围内。这限制了模拟器，使其可以与运行该早期版本的Erlang节点（以及C和Java节点）进行通信。</target>
        </trans-unit>
        <trans-unit id="9cd5b036f8947d038790d0e5bd184b32b79cd32e" translate="yes" xml:space="preserve">
          <source>The distribution module expose an API that &lt;code&gt;net_kernel&lt;/code&gt; call in order to manage connections to other nodes. The module name should have the suffix &lt;code&gt;_dist&lt;/code&gt;.</source>
          <target state="translated">分发模块公开了 &lt;code&gt;net_kernel&lt;/code&gt; 调用的API，以管理与其他节点的连接。模块名称应带有后缀 &lt;code&gt;_dist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9731f94ba0606fc85b916d2adf784a2aceb2f3dc" translate="yes" xml:space="preserve">
          <source>The distribution module for SSL/TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">SSL / TLS的分发模块名为 &lt;code&gt;inet_tls_dist&lt;/code&gt; ,并在命令行上使用选项 &lt;code&gt;-proto_dist&lt;/code&gt; 指定。 &lt;code&gt;-proto_dist&lt;/code&gt; 的参数是不带后缀 &lt;code&gt;_dist&lt;/code&gt; 的模块名称。因此，此分发模块在命令行上通过 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 指定。</target>
        </trans-unit>
        <trans-unit id="b1f0fad23847abdca6666c395577ff14f2547ccd" translate="yes" xml:space="preserve">
          <source>The distribution module for TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">TLS的分发模块名为 &lt;code&gt;inet_tls_dist&lt;/code&gt; ,并在命令行上使用选项 &lt;code&gt;-proto_dist&lt;/code&gt; 指定。 &lt;code&gt;-proto_dist&lt;/code&gt; 的参数是不带后缀 &lt;code&gt;_dist&lt;/code&gt; 的模块名称。因此，在命令行上使用 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 指定了此分发模块。</target>
        </trans-unit>
        <trans-unit id="6aeea032ca4cef8b317244fbb44d9a32ae5f5898" translate="yes" xml:space="preserve">
          <source>The distribution protocol can be divided into four parts:</source>
          <target state="translated">分配协议可以分为四个部分。</target>
        </trans-unit>
        <trans-unit id="ff1a3d4e65478d9f5f71da059cfc38ed2c96b5ba" translate="yes" xml:space="preserve">
          <source>The distribution starts at boot if all the above is specified and an &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; flag is present at the command line.</source>
          <target state="translated">如果指定了以上所有条件，并且命令行中存在 &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; 标志，则该分发将在引导时开始。</target>
        </trans-unit>
        <trans-unit id="1b01c03572e2e4aaafce0356c4411e135ed1f526" translate="yes" xml:space="preserve">
          <source>The document returned by &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; and &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. The type of the returned record depends on the value of the document option passed to the function.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 和 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 返回的文档。返回记录的类型取决于传递给函数的document选项的值。</target>
        </trans-unit>
        <trans-unit id="00d8e9f113e0a458f5df4e4708996df9d6090e13" translate="yes" xml:space="preserve">
          <source>The documentation can be installed either using the &lt;code&gt;install-docs&lt;/code&gt; target, or using the &lt;code&gt;release_docs&lt;/code&gt; target.</source>
          <target state="translated">可以使用 &lt;code&gt;install-docs&lt;/code&gt; 目标或使用 &lt;code&gt;release_docs&lt;/code&gt; 目标来安装文档。</target>
        </trans-unit>
        <trans-unit id="5149c903e3309937ac98a7bf77705046a7abe19b" translate="yes" xml:space="preserve">
          <source>The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</source>
          <target state="translated">美元字符是一个断言,只有当当前的匹配点在主题字符串的末尾,或者紧挨着字符串末尾的换行之前(默认情况下)才为真。但是请注意,它并不匹配换行。如果涉及到一些替代物,Dollar不需要成为模式的最后一个字符,但它要成为它出现的任何分支中的最后一项。Dollar在字符类中没有特殊意义。</target>
        </trans-unit>
        <trans-unit id="0fbbfd153dd0451d5221908c40847d88ba4f1d83" translate="yes" xml:space="preserve">
          <source>The domain of a family is called the &lt;strong&gt;index set&lt;/strong&gt;, and the range is called the &lt;strong&gt;indexed set&lt;/strong&gt;.</source>
          <target state="translated">一个族的域称为&lt;strong&gt;索引集&lt;/strong&gt;，而范围称为&lt;strong&gt;索引集&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5952578f1a7b818cc8da70c30b5eb53cf1931cf6" translate="yes" xml:space="preserve">
          <source>The dot metacharacter</source>
          <target state="translated">点元字符</target>
        </trans-unit>
        <trans-unit id="0c39bb4aef52ace658cb63c48687e207b1ca1ec6" translate="yes" xml:space="preserve">
          <source>The downgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;downgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">然后可以使用 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 评估降级脚本。建议改用 &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; ，但是此函数（ &lt;code&gt;downgrade_script&lt;/code&gt; ）对于检查脚本的内容很有用。</target>
        </trans-unit>
        <trans-unit id="1a9b899e09f583022f6155a633fa34d496d384c3" translate="yes" xml:space="preserve">
          <source>The downside of an enforced transaction recovery decision is that the decision can be incorrect, because of insufficient information about the recovery decisions from the other nodes. This can result in an inconsistent database where &lt;code&gt;Mnesia&lt;/code&gt; has committed the transaction on some nodes but terminated it on others.</source>
          <target state="translated">强制事务恢复决策的不利之处在于该决策可能是错误的，因为其他节点有关恢复决策的信息不足。这可能会导致数据库不一致， &lt;code&gt;Mnesia&lt;/code&gt; 在该数据库上已在某些节点上提交了事务，但在其他节点上终止了该事务。</target>
        </trans-unit>
        <trans-unit id="4bcc2bcf2d8764baa874ccaf0e26026a8ea86d10" translate="yes" xml:space="preserve">
          <source>The drive does not exist.</source>
          <target state="translated">驱动器不存在。</target>
        </trans-unit>
        <trans-unit id="a20548a0f73bb216b4b211c372344d02764897f0" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is not present in the system.</source>
          <target state="translated">驱动程序 &lt;code&gt;Name&lt;/code&gt; 在系统中不存在。</target>
        </trans-unit>
        <trans-unit id="822e4982aaf8b56398bd1a181c2b6889e1c63b93" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">驱动程序 &lt;code&gt;Name&lt;/code&gt; 存在于系统中，但是在此过程中没有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b210ce4bf131d4b12dbe57304824a0514f38f51" translate="yes" xml:space="preserve">
          <source>The driver binary has a field, &lt;code&gt;orig_bytes&lt;/code&gt;, which marks the start of the data in the binary.</source>
          <target state="translated">驱动程序二进制文件具有一个字段 &lt;code&gt;orig_bytes&lt;/code&gt; ，该字段标记二进制文件中数据的开始。</target>
        </trans-unit>
        <trans-unit id="790a2c01c39cd01e89b6ba7ec3e95447572133e7" translate="yes" xml:space="preserve">
          <source>The driver callback functions are called synchronously from the Erlang emulator. If they take too long before completing, they can cause time-outs in the emulator. Use the queue or asynchronous calls if necessary, as the emulator must be responsive.</source>
          <target state="translated">驱动程序的回调函数是由Erlang仿真器同步调用的。如果它们在完成之前耗时过长,可能会导致仿真器超时。如果有必要,请使用队列或异步调用,因为仿真器必须有响应性。</target>
        </trans-unit>
        <trans-unit id="157c45a036de0fa3ddd4ea0c8781ead7513f314e" translate="yes" xml:space="preserve">
          <source>The driver calls back to the emulator, using the API functions declared in &lt;code&gt;erl_driver.h&lt;/code&gt;. They are used for outputting data from the driver, using timers, and so on.</source>
          <target state="translated">驱动程序使用 &lt;code&gt;erl_driver.h&lt;/code&gt; 中声明的API函数回调到仿真器。它们用于从驱动程序，使用计时器等输出数据。</target>
        </trans-unit>
        <trans-unit id="bc789bf203b3722793ad6336ed379ee48dc982f5" translate="yes" xml:space="preserve">
          <source>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver cannot possibly keep open.</source>
          <target state="translated">驱动程序可以退出并向Erlang发出错误信号。这只适用于严重的错误,即驱动程序不可能保持开放。</target>
        </trans-unit>
        <trans-unit id="6e77324ef81504134fd1f1323beb52a29f3e3f65" translate="yes" xml:space="preserve">
          <source>The driver can only be unloaded when there are no open ports using it and no more &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; require it to be loaded.</source>
          <target state="translated">仅当没有开放的端口使用驱动程序并且没有更多的 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 需要加载驱动程序时，才能卸载该驱动程序。</target>
        </trans-unit>
        <trans-unit id="02d2238ddb29e9e347e288bd01312cba05b7f070" translate="yes" xml:space="preserve">
          <source>The driver data types and the functions available to the driver writer are defined in header file &lt;code&gt;erl_driver.h&lt;/code&gt; seated in Erlang's include directory. See the &lt;code&gt;erl_driver&lt;/code&gt; documentation for details of which functions are available.</source>
          <target state="translated">在Erlang的include目录中的头文件 &lt;code&gt;erl_driver.h&lt;/code&gt; 中定义了驱动程序数据类型和驱动程序编写器可用的功能。有关可用功能的详细信息，请参见 &lt;code&gt;erl_driver&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="85f6b3a5e6e8b698b73cc7423736b57c1fc18515" translate="yes" xml:space="preserve">
          <source>The driver entry contains the functions that will be called by the emulator. In this example, only &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;control&lt;/code&gt; are provided:</source>
          <target state="translated">驱动程序条目包含将由仿真器调用的功能。在此示例中，仅提供 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; 和 &lt;code&gt;control&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fbb368d133889289794fdcfad4ea08d3c6807b8d" translate="yes" xml:space="preserve">
          <source>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked-in driver).</source>
          <target state="translated">驱动程序已经把自己变成了永久性的,在这种情况下,它就不能再被这个接口所操纵了(很像一个静态链接的驱动程序)。</target>
        </trans-unit>
        <trans-unit id="66000da869d699cedf77816fe5c89cc8b497a778" translate="yes" xml:space="preserve">
          <source>The driver has requested itself to be permanent, making it behave like an Erlang linked-in driver and can no longer be manipulated with this API.</source>
          <target state="translated">驱动程序已经要求自己成为永久性的,使得它的行为就像一个Erlang链接的驱动程序一样,不能再使用这个API进行操作。</target>
        </trans-unit>
        <trans-unit id="7f5e1b2ebfdf61236b9724f8274637d3ec47df15" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">驱动程序实现控制接口，该接口是当Erlang调用 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 时调用的同步接口。处于 &lt;code&gt;data&lt;/code&gt; 模式时，只有此接口可以控制驱动程序。可以使用以下操作码来调用它：</target>
        </trans-unit>
        <trans-unit id="fb99a228136eba922ef8092328ac0928261c0a09" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">驱动程序实现控制接口，该接口是当Erlang调用 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 时调用的同步接口。处于 &lt;code&gt;data&lt;/code&gt; 模式时，只有此接口可以控制驱动程序。可以使用以下操作码来调用它：</target>
        </trans-unit>
        <trans-unit id="eb42a7455c90c66663b33eefe7d7a842a5468cbc" translate="yes" xml:space="preserve">
          <source>The driver initialization routine is (usually) declared with a macro to make the driver easier to port between different operating systems (and flavors of systems). This is the only routine that must have a well-defined name. All other callbacks are reached through the driver structure. The macro to use is named &lt;code&gt;DRIVER_INIT&lt;/code&gt; and takes the driver name as parameter:</source>
          <target state="translated">（通常）使用宏声明驱动程序初始化例程，以使驱动程序更易于在不同的操作系统（和系统类型）之间移植。这是唯一必须具有明确定义的名称的例程。通过驱动程序结构可以到达所有其他回调。要使用的宏名为 &lt;code&gt;DRIVER_INIT&lt;/code&gt; ，并将驱动程序名称作为参数：</target>
        </trans-unit>
        <trans-unit id="df5c267a32b3ddcfaa0938eb24b89bd6abfd4b02" translate="yes" xml:space="preserve">
          <source>The driver is already loaded with other &lt;code&gt;DriverOptionList&lt;/code&gt; or a different &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; argument.</source>
          <target state="translated">该驱动程序已经加载了其他 &lt;code&gt;DriverOptionList&lt;/code&gt; 或其他&lt;strong&gt;文字&lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="123d2435bbdf7446863fb98cf76173c154e93eaf" translate="yes" xml:space="preserve">
          <source>The driver is loaded by other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, pending_driver}&lt;/code&gt; was specified.</source>
          <target state="translated">当指定选项 &lt;code&gt;{reload, pending_driver}&lt;/code&gt; 时，其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 会加载该驱动程序。</target>
        </trans-unit>
        <trans-unit id="de8f98e94d0922e6ef27e0959b36602f7f443810" translate="yes" xml:space="preserve">
          <source>The driver is loaded with &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt;. If this is successful, or if it is already loaded, it is opened. This will call the &lt;code&gt;start&lt;/code&gt; function in the driver.</source>
          <target state="translated">驱动程序已加载 &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 。如果成功，或者已经加载，则将其打开。这将在驱动程序中调用 &lt;code&gt;start&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="f2356f498f6f6669e3b679a9b55e2c73ebdf7ef2" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt; erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">仅在调用 &lt;code&gt; erl_ddll:unload_driver/1&lt;/code&gt; 或模拟器停止时才卸载驱动程序。</target>
        </trans-unit>
        <trans-unit id="0ebdfd6fd6dc142da610d573bd0e04e4e99b405d" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">仅在调用 &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt; 或模拟器停止时才卸载驱动程序。</target>
        </trans-unit>
        <trans-unit id="aa4be31a9519f969227f921236d7d6aa51f75a8a" translate="yes" xml:space="preserve">
          <source>The driver is synchronous, it uses the synchronous calls of the client library. This is only for simplicity, but not good, as it halts the emulator while waiting for the database. This is improved below with an asynchronous sample driver.</source>
          <target state="translated">驱动程序是同步的,它使用客户端库的同步调用。这只是为了简单,但并不好,因为它在等待数据库的时候会使仿真器停止。下面用一个异步的示例驱动来改进这个问题。</target>
        </trans-unit>
        <trans-unit id="d2846f7d13f5d6eeed6af66056f38ff13c49aabc" translate="yes" xml:space="preserve">
          <source>The driver is to be compiled and linked to a shared library (DLL on Windows). With gcc, this is done with link flags &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fpic&lt;/code&gt;. As we use the &lt;code&gt;ei&lt;/code&gt; library, we should include it too. There are several versions of &lt;code&gt;ei&lt;/code&gt;, compiled for debug or non-debug and multi-threaded or single-threaded. In the makefile for the samples, the &lt;code&gt;obj&lt;/code&gt; directory is used for the &lt;code&gt;ei&lt;/code&gt; library, meaning that we use the non-debug, single-threaded version.</source>
          <target state="translated">该驱动程序将被编译并链接到共享库（Windows上为DLL）。与海湾合作委员会，与链接标志做到这一点 &lt;code&gt;-shared&lt;/code&gt; 和 &lt;code&gt;-fpic&lt;/code&gt; 。在使用 &lt;code&gt;ei&lt;/code&gt; 库时，我们也应该包含它。 &lt;code&gt;ei&lt;/code&gt; 有多种版本，可针对调试或非调试以及多线程或单线程进行编译。在示例的makefile中， &lt;code&gt;obj&lt;/code&gt; 目录用于 &lt;code&gt;ei&lt;/code&gt; 库，这意味着我们使用非调试单线程版本。</target>
        </trans-unit>
        <trans-unit id="8352df0d68d66243c84331cdb4bc76e073f0f8fd" translate="yes" xml:space="preserve">
          <source>The driver is to be provided as a dynamically linked library in an object code format specific for the platform in use, that is, &lt;code&gt;.so&lt;/code&gt; files on most Unix systems and &lt;code&gt;.ddl&lt;/code&gt; files on Windows. An Erlang linked-in driver must provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For more information about Erlang drivers, see &lt;code&gt;erts:erl_driver&lt;/code&gt; .</source>
          <target state="translated">该驱动程序将以一种动态链接库的形式提供，并以特定于所使用平台的目标代码格式提供，即大多数Unix系统上的 &lt;code&gt;.so&lt;/code&gt; 文件和Windows上的 &lt;code&gt;.ddl&lt;/code&gt; 文件。链接到Erlang的驱动程序必须为仿真器提供特定的接口，因此该模块不能用于加载任意动态库。有关Erlang驱动程序的更多信息，请参见 &lt;code&gt;erts:erl_driver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11f7d0670a21cf6663ffe1e7be79926c35deca09" translate="yes" xml:space="preserve">
          <source>The driver is to fail only when in severe error situations, when the driver cannot possibly keep open, for example, buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">仅在严重错误情况下（例如，驱动程序可能无法保持打开状态），缓冲区分配不足而导致驱动程序失败。对于正常错误，更合适的是使用 &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; 发送错误代码。</target>
        </trans-unit>
        <trans-unit id="12952854b617484d4a3a18ae5571038f275167c0" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">驱动程序名称。它必须对应于 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 中使用的原子，以及驱动程序库文件的名称（不带扩展名）。</target>
        </trans-unit>
        <trans-unit id="fc198aad17d226134b089c46b5d58abebda6515e" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">驱动程序名称。它必须对应于 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 中使用的原子以及驱动程序库文件的名称（不带扩展名）。</target>
        </trans-unit>
        <trans-unit id="c745a240a8b09464690a74b0ded828b443277620" translate="yes" xml:space="preserve">
          <source>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</source>
          <target state="translated">由于历史原因,驱动程序名称以字符串列表而不是原子列表的形式返回。</target>
        </trans-unit>
        <trans-unit id="8c90e4dc558838312154093ae7e4d33a042314e8" translate="yes" xml:space="preserve">
          <source>The driver options for a specified driver name need always to be consistent, &lt;strong&gt;even when the driver is reloaded&lt;/strong&gt;, meaning that they are as much a part of the driver as the name.</source>
          <target state="translated">&lt;strong&gt;即使重新加载了驱动程序&lt;/strong&gt;，指定驱动程序名称的驱动程序选项也必须始终保持一致，这意味着它们与名称一样多。</target>
        </trans-unit>
        <trans-unit id="ec7187710cb97de822c20a1794719f5b691ec563" translate="yes" xml:space="preserve">
          <source>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal Erlang message queues). This can be useful if the driver must wait for slow devices, and so on, and wants to yield back to the emulator. The driver queue is implemented as an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">驱动程序队列可用于将仿真器的输出排队到驱动器（从驱动程序到仿真器的数据由仿真器在常规Erlang消息队列中排队）。如果驱动程序必须等待速度较慢的设备等，并且想要让回给仿真器，这将很有用。驱动程序队列实现为 &lt;code&gt;ErlIOVec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267e1ade55aca0a7989f62dc5c3745421b17592a" translate="yes" xml:space="preserve">
          <source>The driver structure contains the driver name and some 15 function pointers, which are called at different times by the emulator.</source>
          <target state="translated">驱动程序结构包含驱动程序名称和大约15个函数指针,这些函数指针在不同的时间被仿真器调用。</target>
        </trans-unit>
        <trans-unit id="777fa5f89808e7871ea95ba4af70a119a6124215" translate="yes" xml:space="preserve">
          <source>The driver structure is filled with the driver name and function pointers. It is returned from the special entry point, declared with the macro &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">驱动程序结构中填充了驱动程序名称和功能指针。它从用宏 &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt; 声明的特殊入口点返回。</target>
        </trans-unit>
        <trans-unit id="ca38a39e87b4ab492f8fbeb01d018493a1577466" translate="yes" xml:space="preserve">
          <source>The driver structure is similar for statically linked-in drivers and dynamically loaded. However, some of the fields are to be left empty (that is, initialized to NULL) in the different types of drivers. The first field (the &lt;code&gt;init&lt;/code&gt; function pointer) is always left blank in a dynamically loaded driver, see line 26. &lt;code&gt;NULL&lt;/code&gt; on line 37 is always to be there, the field is no longer used and is retained for backward compatibility. No timers are used in this driver, why no callback for timers is needed. The &lt;code&gt;outputv&lt;/code&gt; field (line 40) can be used to implement an interface similar to Unix &lt;code&gt;writev&lt;/code&gt; for output. The Erlang runtime system could previously not use &lt;code&gt;outputv&lt;/code&gt; for the distribution, but it can as from ERTS 5.7.2. As this driver was written before ERTS 5.7.2 it does not use the &lt;code&gt;outputv&lt;/code&gt; callback. Using the &lt;code&gt;outputv&lt;/code&gt; callback is preferred, as it reduces copying of data. (We will however use scatter/gather I/O internally in the driver.)</source>
          <target state="translated">对于静态链接的驱动程序和动态加载的驱动程序结构类似。但是，在不同类型的驱动程序中，某些字段将保留为空（即，初始化为NULL）。在动态加载的驱动程序中，第一个字段（ &lt;code&gt;init&lt;/code&gt; 函数指针）始终为空白，请参见第26行。第37 行上的 &lt;code&gt;NULL&lt;/code&gt; 始终存在，不再使用该字段，并且保留该字段是为了向后兼容。在此驱动程序中不使用任何计时器，为什么不需要计时器的回调。所述 &lt;code&gt;outputv&lt;/code&gt; 场（第40行）可以被用于实现类似Unix的接口 &lt;code&gt;writev&lt;/code&gt; 可以获得用于输出。 Erlang运行时系统以前不能使用 &lt;code&gt;outputv&lt;/code&gt; 用于分发，但可以从ERTS 5.7.2开始。由于此驱动程序是在ERTS 5.7.2之前编写的，因此不使用 &lt;code&gt;outputv&lt;/code&gt; 回调。最好使用 &lt;code&gt;outputv&lt;/code&gt; 回调，因为它可以减少数据复制。（但是，我们将在驱动程序内部使用分散/聚集I / O。）</target>
        </trans-unit>
        <trans-unit id="13e83e61fa641454caf4f4f17446cac682b522d1" translate="yes" xml:space="preserve">
          <source>The driver used for Erlang distribution is to implement a reliable, order maintaining, variable length packet-oriented protocol. All error correction, resending and such need to be implemented in the driver or by the underlying communications protocol. If the protocol is stream-oriented (as is the case with both TCP/IP and our streamed Unix domain sockets), some mechanism for packaging is needed. We will use the simple method of having a header of four bytes containing the length of the package in a big-endian 32-bit integer. As Unix domain sockets only can be used between processes on the same machine, we do not need to code the integer in some special endianess, but we will do it anyway because in most situation you need to do it. Unix domain sockets are reliable and order maintaining, so we do not need to implement resends and such in the driver.</source>
          <target state="translated">用于Erlang分发的驱动程序是实现一个可靠的、维持秩序的、面向可变长度包的协议。所有的纠错、重发等都需要在驱动中或由底层通信协议来实现。如果协议是面向流的(如TCP/IP和我们的流式Unix域套接字都是如此),就需要一些打包的机制。我们将使用简单的方法,即有一个由四个字节组成的头,用一个32位的大恩典整数来包含封装的长度。由于Unix域套接字只能在同一台机器上的进程之间使用,所以我们不需要用一些特殊的endianess来编码,但我们还是会这么做,因为在大多数情况下你都需要这么做。Unix域套接字是可靠的,而且是有秩序的,所以我们不需要在驱动中实现重发之类的功能。</target>
        </trans-unit>
        <trans-unit id="885a9c9f85b39e7698683efce0ff5bba88451a67" translate="yes" xml:space="preserve">
          <source>The driver was already loaded by another process or is in use by a living port, or both. The load by you is registered and a corresponding &lt;code&gt;try_unload&lt;/code&gt; is expected sometime in the future.</source>
          <target state="translated">驱动程序已由另一个进程加载，或正在由活动端口使用，或同时被这两个端口使用。您的负载已注册，并且预计将来会出现相应的 &lt;code&gt;try_unload&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="380ea6d015cef2cddc2581f363be87321f771e9f" translate="yes" xml:space="preserve">
          <source>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</source>
          <target state="translated">驱动程序立即被卸载,这意味着驱动程序名称现在可以自由地被其他驱动程序使用,如果底层操作系统允许,驱动程序对象代码所占用的内存现在已经被回收。</target>
        </trans-unit>
        <trans-unit id="e3da2e19322e3c6628d119e07b3e56934634eac8" translate="yes" xml:space="preserve">
          <source>The driver was loaded and is immediately usable.</source>
          <target state="translated">驱动装好了,马上就可以用了。</target>
        </trans-unit>
        <trans-unit id="d864f9d9077463dec755426c28ec5da6f217e91e" translate="yes" xml:space="preserve">
          <source>The driver with the specified name is an Erlang statically linked-in driver, which cannot be manipulated with this API.</source>
          <target state="translated">指定名称的驱动程序是一个Erlang静态链接的驱动程序,不能用这个API进行操作。</target>
        </trans-unit>
        <trans-unit id="75b79644c08326087c431ff0fd0e1f208afbe371" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt; driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">驱动程序 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt; driver_monitor_process&lt;/a&gt;&lt;/code&gt; 器将在调用driver_monitor_process时提供用于存储监视器的内存。数据的地址未存储在驱动程序外部，因此 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 可以用作任何其他数据，可以复制，移动到内存中，遗忘等等。</target>
        </trans-unit>
        <trans-unit id="f1eb9606d6f4220a244d8c3b7748d550c419a79a" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">驱动程序 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt; 器将在调用driver_monitor_process时提供用于存储监视器的内存。数据的地址未存储在驱动程序外部，因此 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 可以用作任何其他数据，可以复制，移动到内存中，遗忘等等。</target>
        </trans-unit>
        <trans-unit id="f4c87103ae153cd308d8f26cfae1b35225c5ea0c" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在以后的驱动程序回调中传递的驱动程序定义的句柄。请注意，此新驱动程序实例未调用 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 。通过 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 创建端口时，通常在 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 创建驱动程序定义的句柄。</target>
        </trans-unit>
        <trans-unit id="4025b3383bc4889c1c9cd923cfef69764fc7fb73" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在以后的驱动程序回调中传递的驱动程序定义的句柄。请注意，此新驱动程序实例未调用 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 。当通过 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 创建端口时，通常在 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 创建驱动程序定义的句柄。</target>
        </trans-unit>
        <trans-unit id="394034fd0da749c1d06ef57ce69c6215ae425eb2" translate="yes" xml:space="preserve">
          <source>The driver-entry structure used by Erlang drivers.</source>
          <target state="translated">Erlang驱动程序使用的驱动程序入口结构。</target>
        </trans-unit>
        <trans-unit id="e67bdfbeb3c1793f1075c60e9dfc86106434ef3f" translate="yes" xml:space="preserve">
          <source>The dump is truncated.</source>
          <target state="translated">转储被截断了。</target>
        </trans-unit>
        <trans-unit id="58fd56942c22b98ca6dfc0e41f2fc24c62b5de4a" translate="yes" xml:space="preserve">
          <source>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</source>
          <target state="translated">转储被截断。在这种情况下,主窗口的状态栏中会显示一个警告。</target>
        </trans-unit>
        <trans-unit id="26da6cb9d5e2b4d506bf3083a6055833ae7a4362" translate="yes" xml:space="preserve">
          <source>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</source>
          <target state="translated">耐久性属性确保事务对DBMS所做的更改是永久性的。一旦事务被提交,对数据库所做的所有更改都是持久的,也就是说,这些更改会被安全地写入磁盘,不会被破坏,也不会消失。</target>
        </trans-unit>
        <trans-unit id="a7aa3c54478ccaa5bbddda8a5fe6086c5ab90507" translate="yes" xml:space="preserve">
          <source>The duration time is specified as &lt;code&gt;HHMMSS&lt;/code&gt;, for example, &lt;code&gt;-duration 012030&lt;/code&gt; or &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</source>
          <target state="translated">持续时间指定为 &lt;code&gt;HHMMSS&lt;/code&gt; ，例如 &lt;code&gt;-duration 012030&lt;/code&gt; 或 &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34138fd668a3a91f262b3c8cc94e10c40614310" translate="yes" xml:space="preserve">
          <source>The dynamic engine is not supported in LibreSSL from version 2.2.1</source>
          <target state="translated">LibreSSL从2.2.1版本开始就不支持动态引擎。</target>
        </trans-unit>
        <trans-unit id="46cf93457fc198c7fc4b11e05da4141275628e59" translate="yes" xml:space="preserve">
          <source>The earlier factorial example can act as a counter-example. It is not tail-recursive, since a multiplication is done on the result of the recursive call to &lt;code&gt;fact(N-1)&lt;/code&gt;.</source>
          <target state="translated">较早的析因示例可以用作反示例。它不是尾递归的，因为对 &lt;code&gt;fact(N-1)&lt;/code&gt; 进行递归调用的结果是乘法。</target>
        </trans-unit>
        <trans-unit id="7471d512bedffa6e5e516b4425ff9cbeaebad94b" translate="yes" xml:space="preserve">
          <source>The easiest path is to mimic the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet_tcp&lt;/code&gt; interfaces, but not much functionality in those modules needs to be implemented. In the example application, only a few of the usual interfaces are implemented, and they are much simplified.</source>
          <target state="translated">最简单的方法是模仿 &lt;code&gt;inet&lt;/code&gt; 和 &lt;code&gt;inet_tcp&lt;/code&gt; 接口，但是这些模块中不需要实现太多功能。在示例应用程序中，仅实现了一些常用接口，并且大大简化了它们。</target>
        </trans-unit>
        <trans-unit id="5a4e2857f3f8ff97859f4357e2a194c2963da6e0" translate="yes" xml:space="preserve">
          <source>The easiest way of using &lt;code&gt;ET&lt;/code&gt;, is to just use it as a graphical tool for displaying message sequence charts. In order to do that you need to first start a &lt;code&gt;Viewer&lt;/code&gt; (which by default starts a &lt;code&gt;Collector&lt;/code&gt;):</source>
          <target state="translated">使用 &lt;code&gt;ET&lt;/code&gt; 的最简单方法是将其用作显示消息序列图的图形工具。为了做到这一点，你需要先启动一个 &lt;code&gt;Viewer&lt;/code&gt; （默认情况下开始 &lt;code&gt;Collector&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3e2ec62c427c4d0d3ce97e74cc8645fe104a328c" translate="yes" xml:space="preserve">
          <source>The easiest way to start Crashdump Viewer is to use shell script &lt;code&gt;cdv&lt;/code&gt; with the full path to the Erlang crashdump as argument. The script is located in directory &lt;code&gt;priv&lt;/code&gt; of the Observer application. This starts the Crashdump Viewer GUI and loads the specified file. If no filename is specified, a file dialog is opened where the file can be selected.</source>
          <target state="translated">启动Crashdump Viewer的最简单方法是将shell脚本 &lt;code&gt;cdv&lt;/code&gt; 与Erlang crashdump的完整路径一起用作参数。该脚本位于Observer应用程序的 &lt;code&gt;priv&lt;/code&gt; 目录中。这将启动Crashdump Viewer GUI并加载指定的文件。如果未指定文件名，则将打开一个文件对话框，可以在其中选择文件。</target>
        </trans-unit>
        <trans-unit id="55d0d417d785ac1626163667303a6253a1c8a917" translate="yes" xml:space="preserve">
          <source>The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.</source>
          <target state="translated">(*THEN)的效果现在只限于内部子模式。在C中失败后,匹配将移至(*FAIL),这将导致整个子模式失败,因为没有更多的替代方案可以尝试。在这种情况下,匹配现在确实回溯到A。</target>
        </trans-unit>
        <trans-unit id="f16407eee4518305b005b9dbecb5884bd7cbf3bc" translate="yes" xml:space="preserve">
          <source>The effect of combining &lt;code&gt;set_on_first_link&lt;/code&gt; with &lt;code&gt;set_on_link&lt;/code&gt; is the same as &lt;code&gt;set_on_first_link&lt;/code&gt; alone. Likewise for &lt;code&gt;set_on_spawn&lt;/code&gt; and &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">合并效果 &lt;code&gt;set_on_first_link&lt;/code&gt; 与 &lt;code&gt;set_on_link&lt;/code&gt; 相同 &lt;code&gt;set_on_first_link&lt;/code&gt; 孤单。同样对于 &lt;code&gt;set_on_spawn&lt;/code&gt; 和 &lt;code&gt;set_on_first_spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb46e1d7474732484a66c32367c6751904b1bed" translate="yes" xml:space="preserve">
          <source>The effect of option &lt;code&gt;cache&lt;/code&gt; is that when generator &lt;code&gt;QH2'&lt;/code&gt; is run the first time, every answer is stored in an ETS table. When the next answer of &lt;code&gt;QH1&lt;/code&gt; is tried, answers to &lt;code&gt;QH2'&lt;/code&gt; are copied from the ETS table, which is very fast. As for option &lt;code&gt;unique&lt;/code&gt; the cost is a possibly substantial amount of RAM memory.</source>
          <target state="translated">选项 &lt;code&gt;cache&lt;/code&gt; 的作用是，当首次运行生成器 &lt;code&gt;QH2'&lt;/code&gt; 时，每个答案都存储在ETS表中。当尝试下一个 &lt;code&gt;QH1&lt;/code&gt; 答案时，将从ETS表中复制 &lt;code&gt;QH2'&lt;/code&gt; 的答案，这非常快。至于 &lt;code&gt;unique&lt;/code&gt; 的选件，成本可能是大量的RAM存储空间。</target>
        </trans-unit>
        <trans-unit id="46af5dbb6ad32f950d071087d55fd5eedd3a2dcc" translate="yes" xml:space="preserve">
          <source>The election process is modified as described in 5.6.4.</source>
          <target state="translated">选举程序按5.6.4所述修改。</target>
        </trans-unit>
        <trans-unit id="cdd607a9ef230a55bb6d74140b011672a2b70ef4" translate="yes" xml:space="preserve">
          <source>The element in position &lt;code&gt;Pos&lt;/code&gt; in &lt;code&gt;Pattern&lt;/code&gt; must be bound. &lt;code&gt;Pos&lt;/code&gt; is an integer (&lt;code&gt;#record.Field&lt;/code&gt;) or an attribute name.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 中位置 &lt;code&gt;Pos&lt;/code&gt; 中的元素必须绑定。 &lt;code&gt;Pos&lt;/code&gt; 是一个整数（ &lt;code&gt;#record.Field&lt;/code&gt; ）或一个属性名称。</target>
        </trans-unit>
        <trans-unit id="c52c7c2c532d8015d87a1ff9dad023e4fb851308" translate="yes" xml:space="preserve">
          <source>The element to update is also the key.</source>
          <target state="translated">要更新的元素也是关键。</target>
        </trans-unit>
        <trans-unit id="133139824edb56fee5c9537204f00d5c8e6d31f2" translate="yes" xml:space="preserve">
          <source>The element to update is not an integer.</source>
          <target state="translated">要更新的元素不是一个整数。</target>
        </trans-unit>
        <trans-unit id="6e2b6d90876d98adc6125d07f13d8d523ed72322" translate="yes" xml:space="preserve">
          <source>The embedded system and all the applications start automatically if the script file shown below is added to directory &lt;code&gt;/etc/rc3.d&lt;/code&gt;. The file must be owned and readable by &lt;code&gt;root&lt;/code&gt;. Its name cannot be arbitrarily assigned; the following name is recommended:</source>
          <target state="translated">如果将以下所示的脚本文件添加到目录 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 中，则嵌入式系统和所有应用程序将自动启动。该文件必须由 &lt;code&gt;root&lt;/code&gt; 拥有并可读。它的名字不能随意分配；建议使用以下名称：</target>
        </trans-unit>
        <trans-unit id="bad88f7a085d192e2f6cec49768a38f2903f8ae0" translate="yes" xml:space="preserve">
          <source>The emulator calls the driver in the following situations:</source>
          <target state="translated">仿真器在以下情况下调用驱动程序。</target>
        </trans-unit>
        <trans-unit id="218b5d9983c658a4cef0aef4b47157f1b19f1a20" translate="yes" xml:space="preserve">
          <source>The emulator has been started with only one scheduler thread.</source>
          <target state="translated">仿真器已经启动,只有一个调度线程。</target>
        </trans-unit>
        <trans-unit id="00ecfc5e261b4531e61f24b2c4f3b8605c732361" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</source>
          <target state="translated">仿真器有一个以上的调度线程,并且没有调度线程被阻塞。也就是说,所有可用的调度器线程都可以调度Erlang进程并执行Erlang代码。</target>
        </trans-unit>
        <trans-unit id="d1335d1e55e250963f0d3ef76a97d106ea1aeeed" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</source>
          <target state="translated">仿真器有一个以上的调度线程,但除了一个调度线程外,其他正常的调度线程都被阻塞了。注意,脏调度器没有被阻塞,可以调度Erlang进程并执行本地代码。</target>
        </trans-unit>
        <trans-unit id="9e09f5c935221131fa5aa069cd7be0f9d773e6f4" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</source>
          <target state="translated">仿真器有一个以上的调度线程,但除了一个调度线程外,所有的调度线程都是阻塞的。也就是说,只有一个调度线程调度Erlang进程并执行Erlang代码。</target>
        </trans-unit>
        <trans-unit id="9414404aaefeb3f5826ea98674c66ad27f121727" translate="yes" xml:space="preserve">
          <source>The emulator probably uses more memory, and because garbage collections occur less frequently, huge binaries can be kept much longer.</source>
          <target state="translated">仿真器可能会使用更多的内存,而且因为垃圾收集发生的频率较低,所以巨大的二进制文件可以保留更多的时间。</target>
        </trans-unit>
        <trans-unit id="8c90a0c569f6e401278d0c92d5efb3209b403c33" translate="yes" xml:space="preserve">
          <source>The emulator refuses to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, as incompatible type changes for the callbacks &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; were introduced in Erlang/OTP R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator, causing it to read random memory and create huge incorrect result blobs.</source>
          <target state="translated">仿真器拒绝加载不使用扩展驱动程序接口的驱动程序，以允许具有64位功能的驱动程序，因为在Erlang / OTP R15B中引入了对回调 &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 不兼容类型更改。用旧类型编写的驱动程序将编译警告，并在被调用时将垃圾大小返回给模拟器，从而导致其读取随机存储器并创建巨大的错误结果Blob。</target>
        </trans-unit>
        <trans-unit id="7a03fbfd7f6822486dc5e29a1dba526a017e4427" translate="yes" xml:space="preserve">
          <source>The emulator restart on Windows NT expects that the system is started using the &lt;code&gt;erlsrv&lt;/code&gt; program (as a service). Furthermore, the release handler expects that the service is named &lt;code&gt;NodeName&lt;/code&gt;_&lt;code&gt;Release&lt;/code&gt;, where &lt;code&gt;NodeName&lt;/code&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;code&gt;Release&lt;/code&gt; is the current release version. The release handler furthermore expects that a program like &lt;code&gt;start_erl.exe&lt;/code&gt; is specified as &quot;machine&quot; to &lt;code&gt;erlsrv&lt;/code&gt;. During upgrading with restart, a new service is registered and started. The new service is set to automatic and the old service is removed when the new release is made permanent.</source>
          <target state="translated">Windows NT上的仿真器重新启动期望使用 &lt;code&gt;erlsrv&lt;/code&gt; 程序（作为服务）启动系统。此外，发布处理程序希望该服务名为 &lt;code&gt;NodeName&lt;/code&gt; _ &lt;code&gt;Release&lt;/code&gt; ，其中 &lt;code&gt;NodeName&lt;/code&gt; 是Erlang节点名称的第一部分（最多但不包括&amp;ldquo; @&amp;rdquo;），而 &lt;code&gt;Release&lt;/code&gt; 是当前的发行版本。发布处理器还预计，等中的程序 &lt;code&gt;start_erl.exe&lt;/code&gt; 被指定为&amp;ldquo;机&amp;rdquo; &lt;code&gt;erlsrv&lt;/code&gt; 。在通过重新启动进行升级的过程中，将注册并启动新服务。将新版本永久化后，新服务将设置为自动，并且旧服务将被删除。</target>
        </trans-unit>
        <trans-unit id="e59343153e5b1fe6b3e23daad5cd40c9373e3696" translate="yes" xml:space="preserve">
          <source>The encoder and decoder can also be run from the shell:</source>
          <target state="translated">编码器和解码器也可以从shell中运行。</target>
        </trans-unit>
        <trans-unit id="5524aa1d01a0ef49a1ac5386a1c63b808ac68425" translate="yes" xml:space="preserve">
          <source>The encoder callback interface is defined by the &lt;code&gt;megaco_encoder&lt;/code&gt; behaviour, see &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">编码器回调接口由 &lt;code&gt;megaco_encoder&lt;/code&gt; 行为定义，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e115c3caf0848d64461367ca5e16e6bd2197d5d0" translate="yes" xml:space="preserve">
          <source>The encoding fails if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 在编码 &lt;code&gt;from_enc&lt;/code&gt; 中不是有效的字符串，则编码失败。</target>
        </trans-unit>
        <trans-unit id="09633aa618d0dc8af3be96ad739582e309ef108d" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">可以通过注释来设置 &lt;code&gt;Filename&lt;/code&gt; 的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="9ac74f2d9e4b6b15103658ee4d9051874ee9e500" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment, as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">可以通过注释设置 &lt;code&gt;Filename&lt;/code&gt; 的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="3d77e867cd506d61a5b722d136e431c9f033298c" translate="yes" xml:space="preserve">
          <source>The encoding of each file can be specified using comments as described in the &lt;code&gt;epp(3)&lt;/code&gt; module.</source>
          <target state="translated">可以使用注释来指定每个文件的编码，如 &lt;code&gt;epp(3)&lt;/code&gt; 模块中所述。</target>
        </trans-unit>
        <trans-unit id="04f41a4c6fb716f1b91e8ba50a1b730e2b5f3a4d" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (&lt;code&gt;ber&lt;/code&gt;), Packed Encoding Rules (&lt;code&gt;per&lt;/code&gt;) aligned, PER unaligned (&lt;code&gt;uper&lt;/code&gt;) and JSON Encoding Rules (&lt;code&gt;jer&lt;/code&gt;). The &lt;code&gt;jer&lt;/code&gt; option can be used by itself to generate a module that only supports encoding/decoding to JER or it can be used as a supplementary option to ber, per and uper. In the latter case a module with for both the main encoding rules and JER will be generated. The exported functions for JER will then be &lt;code&gt;jer_encode(Type, Value)&lt;/code&gt; and &lt;code&gt;jer_decode(Type, Bytes)&lt;/code&gt;.</source>
          <target state="translated">要使用的编码规则。支持的编码规则是基本编码规则（ &lt;code&gt;ber&lt;/code&gt; ），打包编码规则（ &lt;code&gt;per&lt;/code&gt; ）对齐，PER未对齐（ &lt;code&gt;uper&lt;/code&gt; ）和JSON编码规则（ &lt;code&gt;jer&lt;/code&gt; ）。在 &lt;code&gt;jer&lt;/code&gt; 选项可以单独使用，以产生一个模块，其仅支持编码/解码以JER或它可以被用来作为辅助选项误码率，每和UPER。在后一种情况下，将生成一个同时包含主要编码规则和JER的模块。然后，JER的导出函数将是 &lt;code&gt;jer_encode(Type, Value)&lt;/code&gt; 和 &lt;code&gt;jer_decode(Type, Bytes)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e2118a8dc4b068a3e8e22ff922dd1be302891f7" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (BER), Packed Encoding Rules (PER) aligned, and PER unaligned. If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">要使用的编码规则。支持的编码规则是基本编码规则（BER），对齐的压缩编码规则（PER）和未对齐的PER。如果省略了编码规则选项，则 &lt;code&gt;ber&lt;/code&gt; 为默认值。</target>
        </trans-unit>
        <trans-unit id="6f95e0e32837beadf0f93d78df4e27d5991fa179" translate="yes" xml:space="preserve">
          <source>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, must be set explicitly as follows:</source>
          <target state="translated">上面提到的注释所指定的编码适用于脚本本身。然而,I/O服务器的编码必须明确地设置如下。</target>
        </trans-unit>
        <trans-unit id="d1c828e598776df003c2646b5bcedb28e057c204" translate="yes" xml:space="preserve">
          <source>The encoding_config of the megaco_erl_dist_encoder module may be one of these:</source>
          <target state="translated">megaco_erl_dist_encoder模块的encoding_config可以是其中之一。</target>
        </trans-unit>
        <trans-unit id="97065c3a3729efa68679ce76351a30a9cd3dfa65" translate="yes" xml:space="preserve">
          <source>The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server.</source>
          <target state="translated">在将生成的字节流发送到SFTP服务器之前,对生成的字节流进行加密或解密。</target>
        </trans-unit>
        <trans-unit id="f48fa03ddf781f161c43a06b94c0c75681b96550" translate="yes" xml:space="preserve">
          <source>The endianness specification can be either &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, or &lt;code&gt;native&lt;/code&gt;. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is &quot;native&quot; for the CPU that the Erlang machine is run on.</source>
          <target state="translated">字节序规范可以是 &lt;code&gt;big&lt;/code&gt; ， &lt;code&gt;little&lt;/code&gt; 或 &lt;code&gt;native&lt;/code&gt; 。Native-endian表示在加载时将endian解析为big-endian或little-endian，具体取决于运行Erlang机器的CPU的&amp;ldquo;本机&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="60e0f49d56e51cf1a5d46c013c216c0ae5dc1eb9" translate="yes" xml:space="preserve">
          <source>The entire contents of the cache will be deleted.</source>
          <target state="translated">缓存的全部内容将被删除。</target>
        </trans-unit>
        <trans-unit id="a01a496ea7149df2179e8879a105341306c0f911" translate="yes" xml:space="preserve">
          <source>The entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, even when a list of objects is inserted.</source>
          <target state="translated">即使插入了对象列表，也可以保证整个操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="e7a75cc762ec33088a0ac070865ceb613941ab44" translate="yes" xml:space="preserve">
          <source>The entire program is motorcycles2html.erl:</source>
          <target state="translated">整个程序为motorcycles2html.erl。</target>
        </trans-unit>
        <trans-unit id="0ea59e660bb8e967761f1c651703a92fd998d941" translate="yes" xml:space="preserve">
          <source>The entire super carrier implementation is kept in erl_mmap.c. The name suggest that it can be viewed as our own mmap implementation.</source>
          <target state="translated">整个超级载体的实现都保存在 erl_mmap.c 中,从名字上就可以看出它可以看作是我们自己的 mmap 实现。</target>
        </trans-unit>
        <trans-unit id="ac7e661e53cfa83634f92105a4582a374de077bb" translate="yes" xml:space="preserve">
          <source>The entire tar file is compressed, as if it has been run through the &lt;code&gt;gzip&lt;/code&gt; program. To abide to the convention that a compressed tar file is to end in &quot;&lt;code&gt;.tar.gz&lt;/code&gt;&quot; or &quot;&lt;code&gt;.tgz&lt;/code&gt;&quot;, add the appropriate extension.</source>
          <target state="translated">整个tar文件已压缩，就好像它已通过 &lt;code&gt;gzip&lt;/code&gt; 程序运行一样。为了遵守压缩的tar文件以&amp;ldquo; &lt;code&gt;.tar.gz&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;.tgz&lt;/code&gt; &amp;rdquo; 结尾的约定，请添加适当的扩展名。</target>
        </trans-unit>
        <trans-unit id="e1f58ced4a1c7fafa8f4a838e0a3347b18963414" translate="yes" xml:space="preserve">
          <source>The entities involved in this model are the agent, which terminates the management protocol, and the resources, which is to be managed, that is, the actual application entities. The resources should in general have no knowledge of the management protocol used, and the agent should have no knowledge of the managed resources. This implies that a translation mechanism is needed, to translate the management operations to operations on the resources. This translation mechanism is usually called &lt;strong&gt;instrumentation&lt;/strong&gt; and the function that implements it is called &lt;strong&gt;instrumentation function&lt;/strong&gt;. The instrumentation functions are written for each combination of management protocol and resource to be managed. For example, if an application is to be managed by SNMP and HTTP, two sets of instrumentation functions are defined; one that maps SNMP requests to the resources, and one that, for example, generates an HTML page for some resources.</source>
          <target state="translated">此模型中涉及的实体是终止管理协议的代理，以及要管理的资源，即实际的应用程序实体。通常，资源应该不了解所使用的管理协议，而代理也不应该了解所管理的资源。这意味着需要一种转换机制，以将管理操作转换为对资源的操作。这种转换机制通常称为&lt;strong&gt;检测&lt;/strong&gt;功能，而实现该功能的功能称为&lt;strong&gt;检测功能&lt;/strong&gt;。为管理协议和要管理的资源的每种组合编写工具功能。例如，如果一个应用程序要由SNMP和HTTP管理，则定义了两组检测功能；即：一种将SNMP请求映射到资源，另一种例如为某些资源生成HTML页面。</target>
        </trans-unit>
        <trans-unit id="fc41ee140a0e19b3389932dacfd061ee5abd2931" translate="yes" xml:space="preserve">
          <source>The entry format in all files are Erlang terms, separated by a '&lt;strong&gt;.&lt;/strong&gt;' and a &lt;strong&gt;newline&lt;/strong&gt;. In the following sections, the formats of these terms are described. Comments may be specified as ordinary Erlang comments.</source>
          <target state="translated">所有文件中的输入格式均为Erlang术语，以'分隔&lt;strong&gt;。&lt;/strong&gt;和一个&lt;strong&gt;换行符&lt;/strong&gt;。在以下各节中，将描述这些术语的格式。注释可以指定为普通的Erlang注释。</target>
        </trans-unit>
        <trans-unit id="cb54532373ef856c343b0b5dff86075c30ed3fbc" translate="yes" xml:space="preserve">
          <source>The entry point of the process, that is, what function was referenced in the &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt; call that started the process.</source>
          <target state="translated">流程的入口点，即启动流程的 &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;spawn_link&lt;/code&gt; 调用中引用了什么函数。</target>
        </trans-unit>
        <trans-unit id="7f963220ca94e530caaeba1df441378f7d481672" translate="yes" xml:space="preserve">
          <source>The enumerated type is similar to an integer type, when defined with a set of predefined values. The difference is that an enumerated type can only have specified values, whereas an integer can have any value.</source>
          <target state="translated">当用一组预定义的值定义时,枚举类型与整数类型类似。不同的是,枚举型只能有指定的值,而整数型可以有任何值。</target>
        </trans-unit>
        <trans-unit id="a3be6551e42e26d4ead34f786dcb51c0272efaf5" translate="yes" xml:space="preserve">
          <source>The environment can also affect filename interpretation, if Erlang is started with flag &lt;code&gt;+fna&lt;/code&gt; (which is default from Erlang/OTP 17.0).</source>
          <target state="translated">如果Erlang以标志 &lt;code&gt;+fna&lt;/code&gt; （这是Erlang / OTP 17.0的默认值）启动，则环境也会影响文件名的解释。</target>
        </trans-unit>
        <trans-unit id="913d6ab5c0934539b281e92b0bf02bbbfef5d5f9" translate="yes" xml:space="preserve">
          <source>The environment of an Erlang machine started as a service contains two special variables:</source>
          <target state="translated">作为服务启动的Erlang机器的环境包含两个特殊变量。</target>
        </trans-unit>
        <trans-unit id="572b1efce0a6ff1c606a8d7cea991c683d1b2312" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must be &lt;code&gt;NULL&lt;/code&gt; only if calling from a created thread.</source>
          <target state="translated">调用过程的环境。仅当从创建的线程调用时，才必须为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08711127236c0db559a0b4dc910c12dabe3750d5" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must not be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">调用过程的环境。不能为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="933ad549b39351dffb7bbbba0584672a0a00358b" translate="yes" xml:space="preserve">
          <source>The environment of the calling thread (&lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; environment) or &lt;code&gt;NULL&lt;/code&gt; if calling from a custom thread not spawned by ERTS.</source>
          <target state="translated">调用线程的环境（ &lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; 环境）；如果从未由ERTS生成的自定义线程进行调用，则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="679199f710a5ea0668dae02978ff4e536ea45dcb" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">消息术语的环境。可以是分配给 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;NULL&lt;/code&gt; 的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="cdd010a7cf9f07e2e5e5be6548225fb6c23b8fd6" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">消息术语的环境。可以是分配给 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;NULL&lt;/code&gt; 的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="3b7b8c22351117abf032d5f79babc11a6b4db57f" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">消息术语的环境。必须是分配有 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或NULL的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="3da50f98e6b47c2b008dfdf790cd4b0c2b6bf64d" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">消息术语的环境。必须是分配有 &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 或NULL的与进程无关的环境。</target>
        </trans-unit>
        <trans-unit id="2fa8fc26b6ef033d7a364376d908df5f6b781167" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; can be used to indicate which logical cluster a C-node belongs to.</source>
          <target state="translated">环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 可用于指示C节点属于哪个逻辑集群。</target>
        </trans-unit>
        <trans-unit id="e087dc753b87601d38d03f83c1f1759586e203d5" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; can be used to configure the heart time-outs; it can be set in the operating system shell before Erlang is started or be specified at the command line:</source>
          <target state="translated">环境变量 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 可用于配置心跳超时。它可以在启动Erlang之前在操作系统外壳中设置，也可以在命令行中指定：</target>
        </trans-unit>
        <trans-unit id="6dd0dd179f2f7ae89d1e41f5898aa9a98a1d1adc" translate="yes" xml:space="preserve">
          <source>The environment variables can also be used to detect that we are running as a service and make port programs react correctly to the control events generated on logout (see the next section).</source>
          <target state="translated">环境变量也可以用来检测我们是否以服务的形式运行,并使 port 程序对注销时产生的控制事件做出正确的反应 (参见下一节)。</target>
        </trans-unit>
        <trans-unit id="0155a47d2e3d28b9149121cf101f2c0d304723b6" translate="yes" xml:space="preserve">
          <source>The erl scheme is designed to mimic plain CGI, but without the extra overhead. An URL that calls an Erlang &lt;code&gt;erl&lt;/code&gt; function has the following syntax (regular expression):</source>
          <target state="translated">erl方案旨在模仿普通CGI，但没有额外的开销。调用Erlang &lt;code&gt;erl&lt;/code&gt; 函数的URL 具有以下语法（正则表达式）：</target>
        </trans-unit>
        <trans-unit id="9f146c11c8615922912cc793d4380f3827809366" translate="yes" xml:space="preserve">
          <source>The erlang connection process spawned by connect/2, will open a port to a c-process that handles the communication with the database through Microsoft's ODBC API. The erlang port will be kept open for exit signal propagation, if something goes wrong in the c-process and it exits we want know as mush as possible about the reason. The main communication with the c-process is done through sockets. The C-process consists of two threads, the supervisor thread and the database handler thread. The supervisor thread checks for shutdown messages on the supervisor socket and the database handler thread receives requests and sends answers on the database socket. If the database thread seems to hang on some database call, the erlang control process will send a shutdown message on the supervisor socket, in this case the c-process will exit. If the c-process crashes/exits it will bring the erlang-process down too and vice versa i.e. the connection is terminated.</source>
          <target state="translated">由 connect/2 生成的 erlang 连接进程将打开一个端口,通过微软的 ODBC API 处理与数据库的通信。如果c进程出了问题,退出了,我们希望尽可能多的了解原因。与c进程的主要通信是通过套接字完成的。c进程由两个线程组成,即监督线程和数据库处理线程。主管线程在主管套接字上检查是否有挂起消息,数据库处理线程在数据库套接字上接收请求并发送应答。如果数据库线程似乎挂在某个数据库调用上,erlang控制进程会在主管套接字上发送一个关闭消息,在这种情况下,c进程会退出。如果c进程崩溃/退出,会使erlang进程也崩溃,反之亦然,即连接被终止。</target>
        </trans-unit>
        <trans-unit id="df7997d41de6ac2a1785cee171c352d42d04f93c" translate="yes" xml:space="preserve">
          <source>The error behavior differs, see below.</source>
          <target state="translated">错误行为不同,见下文。</target>
        </trans-unit>
        <trans-unit id="011b09627444a05b2b15d34028f40a28dfdddfe0" translate="yes" xml:space="preserve">
          <source>The error descriptor defaults to &lt;code&gt;DefaultED&lt;/code&gt;, but can be overridden with an alternate one by returning &lt;code&gt;{reply,ED}&lt;/code&gt; or &lt;code&gt;{no_reply,ED}&lt;/code&gt; instead of &lt;code&gt;reply&lt;/code&gt; and &lt;code&gt;no_reply&lt;/code&gt; respectively.</source>
          <target state="translated">错误描述符默认为 &lt;code&gt;DefaultED&lt;/code&gt; ，但可以通过返回 &lt;code&gt;{reply,ED}&lt;/code&gt; 或 &lt;code&gt;{no_reply,ED}&lt;/code&gt; 而不是分别为 &lt;code&gt;reply&lt;/code&gt; 和 &lt;code&gt;no_reply&lt;/code&gt; 来替代它。</target>
        </trans-unit>
        <trans-unit id="461fac531aaf141393d180babf97f72d93ada5dc" translate="yes" xml:space="preserve">
          <source>The error handling strategy and possible errors sources are described in the Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">错误处理策略和可能的错误源在《 Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="5d405471c43706742d66ca4dd53edcd35e7ff6cb" translate="yes" xml:space="preserve">
          <source>The error information is handled by Logger, which is part of the Kernel application.</source>
          <target state="translated">错误信息由Kernel应用程序的一部分--Logger处理。</target>
        </trans-unit>
        <trans-unit id="9eb4cd48329bca9a99f8dc4cb317a0559bc9784e" translate="yes" xml:space="preserve">
          <source>The error message will look like this:</source>
          <target state="translated">错误信息会是这样的。</target>
        </trans-unit>
        <trans-unit id="3061a1ab3e6a1d434208df5bfeb44852fc476d18" translate="yes" xml:space="preserve">
          <source>The error report module is configured using the directive &lt;code&gt;error_report_mod&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用伪指令 &lt;code&gt;error_report_mod&lt;/code&gt; 配置错误报告模块，请参见 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69f328c65ecacb1785a10bfaee95a3f42966f16c" translate="yes" xml:space="preserve">
          <source>The error return in the Erlang client (The text as data type 1 and exit_status 255):</source>
          <target state="translated">在Erlang客户端中的错误返回(文本为数据类型1,exit_status 255)。</target>
        </trans-unit>
        <trans-unit id="36a00c6827ff6af3c91907db56029def4bf079b7" translate="yes" xml:space="preserve">
          <source>The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.</source>
          <target state="translated">错误和警告按在表格中遇到的顺序列出。因此,一个文件中的错误可以被分割成不同的错误列表条目。</target>
        </trans-unit>
        <trans-unit id="0e3460fc594164d8bbf96577fb24868bb714be37" translate="yes" xml:space="preserve">
          <source>The errors detected include:</source>
          <target state="translated">检测到的错误包括:</target>
        </trans-unit>
        <trans-unit id="b62e06cf6a78a94894293a2f2fefb7491e659ccc" translate="yes" xml:space="preserve">
          <source>The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.</source>
          <target state="translated">转义符&quot;/o &quot;后面必须有一串八进制数字,用括号括起来。如果不是这样,就会出现错误。这个转义符是最近在Perl中增加的,它提供了一种方法来指定字符代码点为大于0777的八进制数字,并且它还允许毫不含糊地指定八进制数字和反向引用。</target>
        </trans-unit>
        <trans-unit id="e09cca6482e14cefd7789aca27e688d2b8fc2ae0" translate="yes" xml:space="preserve">
          <source>The escape sequence \K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</source>
          <target state="translated">转义序列\K会导致任何之前匹配的字符不被包含在最终的匹配序列中。例如,下面的模式匹配 &quot;foobar&quot;,但报告说它已经匹配了 &quot;bar&quot;。</target>
        </trans-unit>
        <trans-unit id="1fdcd1532b972da832570c4e46f8a01588e3f319" translate="yes" xml:space="preserve">
          <source>The escape sequence \N behaves like a dot, except that it is not affected by option &lt;code&gt;PCRE_DOTALL&lt;/code&gt;. That is, it matches any character except one that signifies the end of a line. Perl also uses \N to match characters by name but PCRE does not support this.</source>
          <target state="translated">转义序列\ N的行为类似于点，但它不受选项 &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 的影响。也就是说，它匹配除表示行尾的字符以外的任何字符。Perl还使用\ N来按名称匹配字符，但是PCRE不支持此功能。</target>
        </trans-unit>
        <trans-unit id="9ac8458115fbc9af33358e4aea3bbde3c0be1319" translate="yes" xml:space="preserve">
          <source>The escape sequences allowed are the same as for Erlang strings:</source>
          <target state="translated">允许的转义序列与Erlang字符串相同。</target>
        </trans-unit>
        <trans-unit id="32812c856e631f3ed1dcd90e3601c5c2b3077c8f" translate="yes" xml:space="preserve">
          <source>The eval scheme can seriously threaten the integrity of the Erlang node housing a web server, for example:</source>
          <target state="translated">例如,评价方案会严重威胁到容纳web服务器的Erlang节点的完整性。</target>
        </trans-unit>
        <trans-unit id="21baa0e66c42986302a436c2cc18ea33ca352672" translate="yes" xml:space="preserve">
          <source>The eval scheme is straight-forward and does not mimic the behavior of plain CGI. An URL that calls an Erlang &lt;code&gt;eval&lt;/code&gt; function has the following syntax:</source>
          <target state="translated">评估方案简单明了，没有模仿普通CGI的行为。调用Erlang &lt;code&gt;eval&lt;/code&gt; 函数的URL 具有以下语法：</target>
        </trans-unit>
        <trans-unit id="10a18f07017de460e02711d1cf0600325f33b7fb" translate="yes" xml:space="preserve">
          <source>The evaluation of the query fails if the &lt;code&gt;qlc&lt;/code&gt; module cannot carry out the chosen join method. Defaults to &lt;code&gt;any&lt;/code&gt;, which means that some fast join method is used if possible.</source>
          <target state="translated">如果 &lt;code&gt;qlc&lt;/code&gt; 模块无法执行所选的联接方法，则查询评估失败。默认为 &lt;code&gt;any&lt;/code&gt; ，这意味着在可能的情况下使用某种快速连接方法。</target>
        </trans-unit>
        <trans-unit id="fa8e9b7cfecc247f7bff705d3a3988485befc88c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed (user) type application expression.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的（用户）类型的应用程序表达式，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4921b565820162e2c60edc6bea683451b957b890" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed &lt;code&gt;file&lt;/code&gt; attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的 &lt;code&gt;file&lt;/code&gt; 属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="618ce4cbe8b9ff30f535342ccae4d3cf10b313ea" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed application expression.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的应用程序表达式，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7fabf51da4bb4e7f1257e9d4dede7a0e536748" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed export attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的导出属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f66579024f348d7bb0f390e794429a5be199446" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function definition.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不能表示格式正确的函数定义，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5406ed8fb8fc38e89372ce85d6f56374209215a4" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function name.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的函数名称，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30e8edf0d9aca5a1873eb5bed65e4d0bd6633e76" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed implicit fun.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的隐式乐趣，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbc54914d2a7b46a8529bdd08a5e3617825c157" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed import attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的导入属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce44851dc662379c8d2493f03d24234da3c175f" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed module attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的模块属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d8a2fbebf4113ef3337fce36bf9fbf369a6379" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record declaration attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的记录声明属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf9e76769c09ba06d5b9bf9c1944e2acfb2dfc1a" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record field specifier.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的记录字段说明 &lt;code&gt;syntax_error&lt;/code&gt; 则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="ea05ee075bf7f2350e2fc6059b34cff5cb33b78c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed type name.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的类型名称，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="363e188710c96a0d0d2f45cbb80bd88dddfe084d" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed wild attribute.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 不代表格式正确的Wild属性，则评估将引发 &lt;code&gt;syntax_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="223a63e0ec00c2810aadc750354eca2f59b6acb8" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not well-formed.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 的 &lt;code&gt;syntax_error&lt;/code&gt; 不正确，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="527c092490ea3417d05959de64ac4673c4e2242c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; represents a record expression that is not well-formed.</source>
          <target state="translated">如果 &lt;code&gt;Node&lt;/code&gt; 表示 &lt;code&gt;syntax_error&lt;/code&gt; 的记录表达式，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="78caee1b9d51c269ecfa277516c192bac800da86" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if an ill-formed Erlang construct is encountered.</source>
          <target state="translated">如果遇到 &lt;code&gt;syntax_error&lt;/code&gt; 不正确的Erlang构造，则评估将引发语法错误。</target>
        </trans-unit>
        <trans-unit id="e360281a65b675290b77c855abb3396feae48026" translate="yes" xml:space="preserve">
          <source>The event &lt;code&gt;user_unblock&lt;/code&gt; is not triggered when a user is removed from the block list explicitly using the &lt;code&gt;unblock_user&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;unblock_user&lt;/code&gt; 函数将用户从阻止列表中明确删除时，不会触发事件 &lt;code&gt;user_unblock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9adf6f3e6bc9d678bcfcbf56c75783efdc79bfe" translate="yes" xml:space="preserve">
          <source>The event handler must be able to handle the events in this module, see section &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">事件处理程序必须能够处理此模块中的事件，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="07fadfa5cd3629d9138971bd824a14ddd43b2990" translate="yes" xml:space="preserve">
          <source>The event handler return values are defined in the description of &lt;code&gt;Module:StateName/3&lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">在 &lt;code&gt;gen_statem&lt;/code&gt; 手册页的 &lt;code&gt;Module:StateName/3&lt;/code&gt; 的描述中定义了事件处理程序的返回值，但这是一个更具可读性的列表：</target>
        </trans-unit>
        <trans-unit id="9b5aab32f54b078cb1c0faaf00cf7eb4a19eec31" translate="yes" xml:space="preserve">
          <source>The event handler terminates abnormally and &lt;code&gt;gen_event&lt;/code&gt; logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">事件处理程序异常终止，并且 &lt;code&gt;gen_event&lt;/code&gt; 记录错误。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7f89716df5f45b5490450ec2ac15b0b43b462e0" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler.</source>
          <target state="translated">该事件由默认的Logger处理程序处理。</target>
        </trans-unit>
        <trans-unit id="2545cd2dda316056d2647ebcf0c0876379df39a7" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler. The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该事件由默认的Logger处理程序处理。日志级别可以更改为错误或信息，请参阅 &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836db6626acc8d2b63d4479e731dd11320410d43" translate="yes" xml:space="preserve">
          <source>The event is handled by:</source>
          <target state="translated">该事件的处理方式是:</target>
        </trans-unit>
        <trans-unit id="670f3a97ec79b1617d1253c86abd242fbfe96cb8" translate="yes" xml:space="preserve">
          <source>The event is made into a message and sent to the event manager. When the event is received, the event manager calls &lt;code&gt;handle_event(Event, State)&lt;/code&gt; for each installed event handler, in the same order as they were added. The function is expected to return a tuple &lt;code&gt;{ok,State1}&lt;/code&gt;, where &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the event handler.</source>
          <target state="translated">该事件将成为消息并发送到事件管理器。接收到事件后，事件管理器将为每个已安装的事件处理程序按添加时的相同顺序调用 &lt;code&gt;handle_event(Event, State)&lt;/code&gt; 。该函数应返回一个元组 &lt;code&gt;{ok,State1}&lt;/code&gt; ，其中 &lt;code&gt;State1&lt;/code&gt; 是事件处理程序状态的新值。</target>
        </trans-unit>
        <trans-unit id="b73ba2f2d96d9d903429f26f68141cab3925fb1c" translate="yes" xml:space="preserve">
          <source>The event is sent to the &lt;code&gt;gen_statem&lt;/code&gt;. When the event is received, the &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt;, or &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt;. &lt;code&gt;StateName&lt;/code&gt; is the name of the current state and &lt;code&gt;NewStateName&lt;/code&gt; is the name of the next state to go to. &lt;code&gt;NewData&lt;/code&gt; is a new value for the server data of the &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;Actions&lt;/code&gt; is a list of actions to be performed by the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">该事件被发送到 &lt;code&gt;gen_statem&lt;/code&gt; 。收到事件后， &lt;code&gt;gen_statem&lt;/code&gt; 调用 &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt; ，该状态应返回一个元组 &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt; 或 &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt; 。 &lt;code&gt;StateName&lt;/code&gt; 是当前状态的名称， &lt;code&gt;NewStateName&lt;/code&gt; 是要转到的下一个状态的名称。 &lt;code&gt;NewData&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 的服务器数据的新值，而 &lt;code&gt;Actions&lt;/code&gt; 是 &lt;code&gt;gen_statem&lt;/code&gt; 引擎要执行的操作的列表。</target>
        </trans-unit>
        <trans-unit id="cfd753f364308c6d8a412367394b65eb5bb6c7da" translate="yes" xml:space="preserve">
          <source>The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">事件管理器调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 来处理请求。</target>
        </trans-unit>
        <trans-unit id="482c8d79933fe33bda06c58901ec825b1db485ea" translate="yes" xml:space="preserve">
          <source>The event manager essentially maintains a list of &lt;code&gt;{Module, State}&lt;/code&gt; pairs, where each &lt;code&gt;Module&lt;/code&gt; is an event handler, and &lt;code&gt;State&lt;/code&gt; is the internal state of that event handler.</source>
          <target state="translated">事件管理器实质上维护 &lt;code&gt;{Module, State}&lt;/code&gt; 对的列表，其中每个 &lt;code&gt;Module&lt;/code&gt; 是事件处理程序，而 &lt;code&gt;State&lt;/code&gt; 是该事件处理程序的内部状态。</target>
        </trans-unit>
        <trans-unit id="76d57c410515c44cc8bc28a8d09b64ef1f2639aa" translate="yes" xml:space="preserve">
          <source>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, it terminates if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent.</source>
          <target state="translated">如果事件管理器是监视树的一部分，并且由其主管命令终止，则终止。即使它&lt;strong&gt;不是&lt;/strong&gt;监督树的一部分，但如果它从其父级收到 &lt;code&gt;'EXIT'&lt;/code&gt; 消息，它也会终止。</target>
        </trans-unit>
        <trans-unit id="c2ce4c38c0aa823b9e5e74e4d8bcd2d1c4f1111f" translate="yes" xml:space="preserve">
          <source>The event tracer framework is made up of four modules:</source>
          <target state="translated">事件追踪框架由四个模块组成。</target>
        </trans-unit>
        <trans-unit id="d0f7cae16de84ad2c9c39b99cb4c031af931d1d5" translate="yes" xml:space="preserve">
          <source>The event types are described in the next sections.</source>
          <target state="translated">事件类型将在下一节描述。</target>
        </trans-unit>
        <trans-unit id="f1782c63eb3688ca0c9af0612dd19da36a393122" translate="yes" xml:space="preserve">
          <source>The events are also documented in &lt;code&gt;ct_event.erl&lt;/code&gt;. This module can serve as an example of what an event handler for the &lt;code&gt;Common Test&lt;/code&gt; event manager can look like.</source>
          <target state="translated">这些事件也记录在 &lt;code&gt;ct_event.erl&lt;/code&gt; 中。该模块可以作为 &lt;code&gt;Common Test&lt;/code&gt; 事件管理器的事件处理程序外观的示例。</target>
        </trans-unit>
        <trans-unit id="6c24f138a33faf79d167906d2c594eb6f61632b5" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt; handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用事件生成过程定义的函数对事件进行格式化（调用 &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt; handle_debug/4)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa54bda16841cabde0c2e6fc00114e179e4c8c7f" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用事件生成过程定义的函数对事件进行格式化（调用 &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed5fedd80749f48dc22eb2ae97b4b16538b4c269" translate="yes" xml:space="preserve">
          <source>The exact error message depends on the actual callback module. The Error message makes the connection to fail, and is returned from e.g ssh:connect/3.</source>
          <target state="translated">确切的错误信息取决于实际的回调模块。错误信息使连接失败,并从例如ssh:connect/3返回。</target>
        </trans-unit>
        <trans-unit id="efa1279652840651c701347ac0d11ff90fe9b0b8" translate="yes" xml:space="preserve">
          <source>The exact set of options and there syntax &lt;strong&gt;may&lt;/strong&gt; be changed without prior notice.</source>
          <target state="translated">选项的确切集合和语法&lt;strong&gt;可能会&lt;/strong&gt;有所更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="e9d4c6263423994284ba2b9c6d7623abbea04412" translate="yes" xml:space="preserve">
          <source>The example &lt;code&gt;Subject&lt;/code&gt; field has one C, two CN and one O part. It is only the CN (Common Name) that is used by hostname verification. The two other (C and O) is not used here even when they contain a domain name like the O part. The C and O parts are defined elsewhere and meaningful only for other functions.</source>
          <target state="translated">示例 &lt;code&gt;Subject&lt;/code&gt; 字段具有一个C，两个CN和一个O部分。主机名验证仅使用CN（通用名）。即使另外两个（C和O）包含域名（如O部分），也不会在此处使用。C和O部分在其他地方定义，仅对其他功能有意义。</target>
        </trans-unit>
        <trans-unit id="53789d2e92c1fda46d0fae07ec08f87e98bdd01d" translate="yes" xml:space="preserve">
          <source>The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.</source>
          <target state="translated">例子中的I/O服务器将字符存储在ETS表中,构成了一个相当粗糙的RAM文件。</target>
        </trans-unit>
        <trans-unit id="3a18dec0331c54c7d131f7f05a54cda624c44be5" translate="yes" xml:space="preserve">
          <source>The example below sets up trace on the exported functions (default) of module &lt;code&gt;snmp_generic&lt;/code&gt; and all functions of module &lt;code&gt;snmp_generic_mnesia&lt;/code&gt;. With return values (which is default) and timestamps in both cases (which is also default):</source>
          <target state="translated">下面的示例对模块 &lt;code&gt;snmp_generic&lt;/code&gt; 的导出函数（默认）和模块snmp_generic_mnesia的所有函数进行设置 &lt;code&gt;snmp_generic_mnesia&lt;/code&gt; 。在两种情况下都带有返回值（这是默认值）和时间戳（这也是默认值）：</target>
        </trans-unit>
        <trans-unit id="40ec67cee0f09e7e1f38061d74546bfcd1432fac" translate="yes" xml:space="preserve">
          <source>The example manager, &lt;code&gt;snmp_ex2_manager&lt;/code&gt;, is a simple example of how to implement an snmp manager using the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">示例管理器 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 是有关如何使用SNMP开发工具包的管理器组件实现snmp管理器的简单示例。</target>
        </trans-unit>
        <trans-unit id="bfa0e44fefc9103dfe63a4cd1030807bc049d616" translate="yes" xml:space="preserve">
          <source>The example servers so far in this chapter print the full internal state in the error log, for example, when killed by an exit signal or because of an internal error. This state contains both the code lock code and which digits that remain to unlock.</source>
          <target state="translated">本章到目前为止的例子服务器在错误日志中打印了完整的内部状态,例如,当被退出信号杀死或因为内部错误时。这个状态既包含了代码锁定码,也包含了哪些还未解锁的数字。</target>
        </trans-unit>
        <trans-unit id="266205b844f4f6e3267e956b4430b205e05dad6e" translate="yes" xml:space="preserve">
          <source>The example showed the background work that the shell performs just to interpret the first command line. Most work is done by &lt;code&gt;erl_eval&lt;/code&gt; and &lt;code&gt;orddict&lt;/code&gt;.</source>
          <target state="translated">该示例显示了shell只是为了解释第一个命令行而执行的后台工作。大多数工作由 &lt;code&gt;erl_eval&lt;/code&gt; 和 &lt;code&gt;orddict&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="8f7ad9497d8d5ee7ec068f8bbaf412b434e2689f" translate="yes" xml:space="preserve">
          <source>The example shown can be found in the toolkit distribution.</source>
          <target state="translated">所示的例子可以在工具包发行版中找到。</target>
        </trans-unit>
        <trans-unit id="396a52ee352a84ef61ae01c6d40809962c1134e8" translate="yes" xml:space="preserve">
          <source>The example shown, &lt;strong&gt;ex2&lt;/strong&gt;, can be found in the toolkit distribution.</source>
          <target state="translated">显示的示例&lt;strong&gt;ex2&lt;/strong&gt;可以在工具包发行版中找到。</target>
        </trans-unit>
        <trans-unit id="ab7c4a3f89e04c623143e7c4c121106db17b0068" translate="yes" xml:space="preserve">
          <source>The example shows some details of how &lt;code&gt;lists:sort/1&lt;/code&gt; works. It used 6047 function calls in the module &lt;code&gt;lists_sort&lt;/code&gt; to complete the work.</source>
          <target state="translated">该示例显示了 &lt;code&gt;lists:sort/1&lt;/code&gt; 工作原理的一些细节。它在 &lt;code&gt;lists_sort&lt;/code&gt; 模块中使用了6047个函数调用来完成工作。</target>
        </trans-unit>
        <trans-unit id="361c007ea7390ae514b7d7274e3225478c75cf81" translate="yes" xml:space="preserve">
          <source>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</source>
          <target state="translated">这个例子指定了两个方向(client2server和server2client)的不同算法,对于密码,但指定了两个方向的mac和压缩的相同算法。kex(密钥交换)是隐式的,但public_key是显式设置的。</target>
        </trans-unit>
        <trans-unit id="c97ac9647ab00e65e37eca74aa7e20c8819a73a3" translate="yes" xml:space="preserve">
          <source>The example specifies that:</source>
          <target state="translated">本例规定:</target>
        </trans-unit>
        <trans-unit id="839951ee6733677e5315d3af4eb38dc5514df04f" translate="yes" xml:space="preserve">
          <source>The example specifies the following:</source>
          <target state="translated">本例规定如下:</target>
        </trans-unit>
        <trans-unit id="5e9468869847362818e3653dadf86b7f55f088d1" translate="yes" xml:space="preserve">
          <source>The example tells us that &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot; was registered on a Monday (since the return value of the first command is 1), and that the &lt;code&gt;calendar&lt;/code&gt; module needed 9 function calls to calculate that.</source>
          <target state="translated">该示例告诉我们，&amp;ldquo; Aktiebolaget LM Ericsson＆Co&amp;rdquo;是在星期一注册的（因为第一个命令的返回值为1），并且 &lt;code&gt;calendar&lt;/code&gt; 模块需要9个函数调用来计算该值。</target>
        </trans-unit>
        <trans-unit id="d3af375b76125b97a165b743095415faf44c0ea3" translate="yes" xml:space="preserve">
          <source>The exception &lt;code&gt;error:badarg&lt;/code&gt; signifies that one or more arguments are of wrong data type, or are otherwise badly formed.</source>
          <target state="translated">异常 &lt;code&gt;error:badarg&lt;/code&gt; 表示一个或多个参数的数据类型错误，或格式错误。</target>
        </trans-unit>
        <trans-unit id="82dc2e396d1267b7791f7b989a0eeae2a1d692a5" translate="yes" xml:space="preserve">
          <source>The exception &lt;code&gt;error:notsup&lt;/code&gt; signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that.</source>
          <target state="translated">异常 &lt;code&gt;error:notsup&lt;/code&gt; 表示该算法是已知的，但当前底层的libcrypto不支持该算法，或者在构建该算法时将其明确禁用。</target>
        </trans-unit>
        <trans-unit id="609a6bc75d839746103bc7db1aad099d08bdaa32" translate="yes" xml:space="preserve">
          <source>The exception is:</source>
          <target state="translated">唯一的例外是:</target>
        </trans-unit>
        <trans-unit id="8702ec4ef9d4d3401c7835a54a81bebc8bc6902d" translate="yes" xml:space="preserve">
          <source>The exception tags are:</source>
          <target state="translated">异常标签是:</target>
        </trans-unit>
        <trans-unit id="4ffa934118cebf3f90cde4787faaae21bba8d06a" translate="yes" xml:space="preserve">
          <source>The exec-option fun is called with the same number of parameters as the arity of the fun, and the result is returned to the client.</source>
          <target state="translated">调用exec-option fun时,参数数与fun的arity相同,结果返回给客户端。</target>
        </trans-unit>
        <trans-unit id="b071e577cae1eeba87f1871188878bd3a2873b58" translate="yes" xml:space="preserve">
          <source>The exec-option has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-4 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">exec-option已经存在了很长时间,但以前没有被记录下来。旧的定义和行为被保留,但如果有冲突,则遵守上面的规则1-4。在新程序中不应该使用旧的和未被记录的样式。</target>
        </trans-unit>
        <trans-unit id="b1895955082bfa77ca24a94c48e11688ebe85d9a" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client.</source>
          <target state="translated">exec-request没有被评估,并向客户端返回一个错误信息。</target>
        </trans-unit>
        <trans-unit id="bdc6ba747c512b08f42f53fa0f4d202112779ea7" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client. Shell-requests are executed according to the value of the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">exec-request不进行评估，并且错误消息返回给客户端。Shell请求根据 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt; 的值执行。</target>
        </trans-unit>
        <trans-unit id="0c24b69b74e8713f113ddc4cb4727d97ca1bd44b" translate="yes" xml:space="preserve">
          <source>The executable name (also known as &lt;code&gt;argv[0]&lt;/code&gt;) is not to be specified in this list. The proper executable name is automatically used as &lt;code&gt;argv[0]&lt;/code&gt;, where applicable.</source>
          <target state="translated">可执行文件名称（也称为 &lt;code&gt;argv[0]&lt;/code&gt; ）不在此列表中指定。适当的可执行文件名称会自动用作 &lt;code&gt;argv[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7703497b2d1d6d7ae666f5086932193209c602a9" translate="yes" xml:space="preserve">
          <source>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</source>
          <target state="translated">当运行时系统决定是否要发送跟踪消息时,匹配表达式的执行情况如下。</target>
        </trans-unit>
        <trans-unit id="f2a8e42abde3dd1496d089519cf10c81e1be53df" translate="yes" xml:space="preserve">
          <source>The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块功能的执行时间取决于对列表进行排序所花费的时间。当不需要排序时，在最坏的情况下，执行时间与输入参数和返回值的大小之和成比例。一些函数在恒定时间内执行： &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa9c12dd4680e897bd4368ab039f91ae858c158b" translate="yes" xml:space="preserve">
          <source>The execution time of this function is affected by the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; table option when the second argument of the function is &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt;. The execution time is much longer when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt; than when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当函数的第二个参数为 &lt;code&gt;size&lt;/code&gt; 或 &lt;code&gt;memory&lt;/code&gt; 时，该函数的执行时间受 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 表选项影响。将 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; 时，与将 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; 时，执行时间要长得多。</target>
        </trans-unit>
        <trans-unit id="d23cabee7bc15b3bbb53bab32c996479b57bf352" translate="yes" xml:space="preserve">
          <source>The execution time of this function is affected by the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; table option. The execution time is much longer when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt; than when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">该功能的执行时间受 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 表选项影响。将 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; 时，与将 &lt;code&gt;decentralized_counters&lt;/code&gt; 选项设置为 &lt;code&gt;false&lt;/code&gt; 时，执行时间要长得多。</target>
        </trans-unit>
        <trans-unit id="420632c27cadb89b2f399b84682c82a68f0a0d31" translate="yes" xml:space="preserve">
          <source>The existing association argument &lt;code&gt;Assoc&lt;/code&gt; can be either a &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; record as returned from, for example, &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, or from a listening socket in active mode. It can also be just the field &lt;code&gt;assoc_id&lt;/code&gt; integer from such a record.</source>
          <target state="translated">现有的关联参数 &lt;code&gt;Assoc&lt;/code&gt; 可以是 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 记录，例如从 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 或活动模式下的侦听套接字返回的记录。它也可以只是来自此类记录的字段 &lt;code&gt;assoc_id&lt;/code&gt; 整数。</target>
        </trans-unit>
        <trans-unit id="2e5a5b15744513cdcf17a46b1eef747c1795c4cb" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt; Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; Errors and Error Handling&lt;/code&gt; 中描述了运行时系统使用的退出原因（例如 &lt;code&gt;badarg&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="78f8f6f791625c1c8fdb334b26d42632cd9d6c18" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt;Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Errors and Error Handling&lt;/code&gt; 中描述了运行时系统使用的退出原因（例如 &lt;code&gt;badarg&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="307cc83b0061e1f27d08d717f7f91193792a0bb2" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">退出值可以稍后由另一个线程通过 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 检索。</target>
        </trans-unit>
        <trans-unit id="d5ae7040a803e376f91e7e700a11833b4ef1676c" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">退出值可以稍后由另一个线程通过 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 检索。</target>
        </trans-unit>
        <trans-unit id="fb2edd7ed5ff8d8687d3a39c97903bcaca3e2655" translate="yes" xml:space="preserve">
          <source>The expanded code for &lt;code&gt;move_deallocate_return&lt;/code&gt; will look this:</source>
          <target state="translated">&lt;code&gt;move_deallocate_return&lt;/code&gt; 的扩展代码将如下所示：</target>
        </trans-unit>
        <trans-unit id="5fde359ee385d3e78714231ab869d10ea4d9e799" translate="yes" xml:space="preserve">
          <source>The exported function &lt;code&gt;f/1&lt;/code&gt; is deprecated. Nothing is said whether &lt;code&gt;f/1&lt;/code&gt; will be removed or not.</source>
          <target state="translated">不推荐使用导出的函数 &lt;code&gt;f/1&lt;/code&gt; 。没有说是否可以删除 &lt;code&gt;f/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e6598c7dcf7a2b613f4f2e9c2f96997e697806" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;Expr&lt;/code&gt; is evaluated and the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result. If a match succeeds and the optional guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;Body&lt;/code&gt; is evaluated.</source>
          <target state="translated">计算表达式 &lt;code&gt;Expr&lt;/code&gt; ，然后将模式 &lt;code&gt;Pattern&lt;/code&gt; 与结果进行顺序匹配。如果匹配成功，并且可选的保护序列 &lt;code&gt;GuardSeq&lt;/code&gt; 为true，则将评估相应的 &lt;code&gt;Body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb08adeb4f1b661f39b36975cfaf70cfc2a2ac3a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; is the list of all elements in &lt;code&gt;T&lt;/code&gt; that are less than &lt;code&gt;Pivot&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 中所有小于 &lt;code&gt;Pivot&lt;/code&gt; 的元素的列表。</target>
        </trans-unit>
        <trans-unit id="a1e90b9cd13dd08f75832cad1c6cf3f69ae835ff" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; is processed by the Erlang preprocessor and returns a list of the record field names. With the record definition &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt;, the expression &lt;code&gt;record_info(fields,foo)&lt;/code&gt; is expanded to the list &lt;code&gt;[x,y,z]&lt;/code&gt;. It is therefore possible for you to provide the attribute names or to use the &lt;code&gt;record_info/2&lt;/code&gt; notation.</source>
          <target state="translated">表达式 &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; 由Erlang预处理程序处理，并返回记录字段名称的列表。使用记录定义 &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt; ，将 &lt;code&gt;record_info(fields,foo)&lt;/code&gt; 表达式扩展到列表 &lt;code&gt;[x,y,z]&lt;/code&gt; 。因此，可以提供属性名称或使用 &lt;code&gt;record_info/2&lt;/code&gt; 表示法。</target>
        </trans-unit>
        <trans-unit id="3552b8886e514fbbee153703d027b2f37ce6a492" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt; file:open/2&lt;/code&gt;).</source>
          <target state="translated">扩展编码仅在磁盘文件（通过功能 &lt;code&gt; file:open/2&lt;/code&gt; ）上受支持。</target>
        </trans-unit>
        <trans-unit id="46c25aa4f264a013c217a6e6c0cd1f11966c0297" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">扩展编码仅在磁盘文件（通过功能 &lt;code&gt;file:open/2&lt;/code&gt; ）上受支持。</target>
        </trans-unit>
        <trans-unit id="414c6b2e2b9fdb04bcc3300cfb9c6af4411d70f4" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt; tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">写入文件页脚的扩展信息，以允许在从文件加载表期间进行更强的验证（如 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt; tab2file/3&lt;/a&gt;&lt;/code&gt; 所指定）。请注意，此函数仅告诉您存在&lt;strong&gt;哪些&lt;/strong&gt;信息，而不告诉文件页脚中的值。该值是一个包含一个或多个原子 &lt;code&gt;object_count&lt;/code&gt; 和 &lt;code&gt;md5sum&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="2a6444a6ceb013adde9ead96d92efa55f0f4c658" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">写入文件页脚的扩展信息，以便在从表加载文件期间进行更强的验证，如对 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 所指定。请注意，此功能只告诉&lt;strong&gt;其&lt;/strong&gt;信息存在，而不是在文件尾的值。该值是一个包含一个或多个原子 &lt;code&gt;object_count&lt;/code&gt; 和 &lt;code&gt;md5sum&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="7699dc7022a8a1b6e975d2c9f7052dbc61739221" translate="yes" xml:space="preserve">
          <source>The extensible agent in this toolkit understands the SNMPv1, SNMPv2c and SNMPv3. Recall that SNMP consists of two separate parts, the MIB definition language (SMI), and the protocol. On the protocol level, the agent can be configured to speak v1, v2c, v3 or any combination of them at the same time, i.e. a v1 request gets an v1 reply, a v2c request gets a v2c reply, and a v3 request gets a v3 reply. On the MIB level, the MIB compiler can compile both SMIv1 and SMIv2 MIBs. Once compiled, any of the formats can be loaded into the agent, regardless of which protocol version the agent is configured to use. This means that the agent translates from v2 notifications to v1 traps, and vice versa. For example, v2 MIBs can be loaded into an agent that speaks v1 only. The procedures for the translation between the two protocols are described in RFC 1908 and RFC 2089.</source>
          <target state="translated">该工具包中的可扩展代理了解SNMPv1、SNMPv2c和SNMPv3。回顾一下,SNMP由两个独立的部分组成,MIB定义语言(SMI)和协议。在协议层面,可以配置代理同时讲v1、v2c、v3或它们的任意组合,即v1请求得到v1回复,v2c请求得到v2c回复,v3请求得到v3回复。在MIB层面,MIB编译器可以同时编译SMIv1和SMIv2 MIB。一旦编译完成,任何一种格式都可以加载到代理中,而不管代理被配置成使用哪个协议版本。这意味着代理可以将v2通知翻译成v1陷阱,反之亦然。例如,v2 MIB可以加载到一个只讲v1的代理中。RFC 1908和RFC 2089中描述了两种协议之间的翻译程序。</target>
        </trans-unit>
        <trans-unit id="57de3f33cd01d18ece5f1f8bac4a92c384bb136f" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process than the Erlang runtime system. In some cases this is not acceptable. Consider, for example, drivers with very hard time requirements. It is therefore possible to write a program in C according to certain principles, and dynamically link it to the Erlang runtime system. This is called a &lt;strong&gt;linked-in driver&lt;/strong&gt;.</source>
          <target state="translated">外部程序位于Erlang运行时系统之外的其他OS进程中。在某些情况下，这是不可接受的。例如，考虑对时间要求非常高的驾驶员。因此，可以根据某些原则用C编写程序，并将其动态链接到Erlang运行时系统。这称为&lt;strong&gt;链接驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="483a7ce8598855903aaac7d43e33a8b6a176d6b3" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process. By default, it reads from standard input (file descriptor 0) and writes to standard output (file descriptor 1). The external program is to terminate when the port is closed.</source>
          <target state="translated">外部程序驻留在另一个操作系统进程中。默认情况下,它从标准输入 (文件描述符 0)读取,并向标准输出 (文件描述符 1)写入。当端口关闭时,外部程序将终止。</target>
        </trans-unit>
        <trans-unit id="222a1e19175406b6aa7a82dcd2394935006c713e" translate="yes" xml:space="preserve">
          <source>The external term format is mainly used in the distribution mechanism of Erlang.</source>
          <target state="translated">外部术语格式主要用于Erlang的发布机制。</target>
        </trans-unit>
        <trans-unit id="474968dd4f560dffd7389aa9ca6143617036ffea" translate="yes" xml:space="preserve">
          <source>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">事实上,(*PRUNE:NAME)记住名字对Erlang程序员来说是没有用的,因为名字不能被检索。</target>
        </trans-unit>
        <trans-unit id="e08d6e43db0948fdcb04ad39ee35684175d7b088" translate="yes" xml:space="preserve">
          <source>The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">事实上,(*THEN:NAME)记住名字对Erlang程序员来说是没有用的,因为名字不能被检索。</target>
        </trans-unit>
        <trans-unit id="a45ac2df0b9d463c5e0e5db641eebadc3836e7a0" translate="yes" xml:space="preserve">
          <source>The factor when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;).</source>
          <target state="translated">计算新计时器时间的因子（ &lt;code&gt;wait_for&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3b32182822028d3d94853cdaecf2932942b85c07" translate="yes" xml:space="preserve">
          <source>The fastest selective decode is when the decoded type is a primitive type and not so deep in the structure of the top type. &lt;code&gt;selected_decode_Window2&lt;/code&gt; decodes a high constructed value, which explains why this operation is relatively slow.</source>
          <target state="translated">最快的选择性解码是当解码的类型是原始类型并且在顶级类型的结构中没有那么深的时候。 &lt;code&gt;selected_decode_Window2&lt;/code&gt; 解码一个较高的构造值，这解释了为什么此操作相对较慢。</target>
        </trans-unit>
        <trans-unit id="e539ae850e97a5a9057ff2bb6d6c8fcc08bab73d" translate="yes" xml:space="preserve">
          <source>The feature was added in Erlang 5.7.5/OTP R13B04.</source>
          <target state="translated">这个功能是在Erlang 5.7.5/OTP R13B04中加入的。</target>
        </trans-unit>
        <trans-unit id="a7d9b7c2c0bd1f2fc3f2c7d85835796c435f8f44" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;ModData&lt;/code&gt; is a list. This list is the list returned from the last call to &lt;code&gt;do/1&lt;/code&gt;.</source>
          <target state="translated">现场 &lt;code&gt;data&lt;/code&gt; 在 &lt;code&gt;ModData&lt;/code&gt; 是一个列表。该列表是上次对 &lt;code&gt;do/1&lt;/code&gt; 的调用返回的列表。</target>
        </trans-unit>
        <trans-unit id="6456be6965c0349e34f864167682f7b31ae172c8" translate="yes" xml:space="preserve">
          <source>The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the &lt;strong&gt;same&lt;/strong&gt; call to &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt;. For example, using &lt;code&gt;T&lt;/code&gt; above:</source>
          <target state="translated">字段宽度指定最大行长。默认值为80。精度指定术语的初始缩进。它默认为在&lt;strong&gt;同一&lt;/strong&gt;调用 &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt; 中此行上打印的字符数。例如，使用上面的 &lt;code&gt;T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="45f234045151c357743a7016e59e80ebbcce1cad" translate="yes" xml:space="preserve">
          <source>The fields can be in any order, not necessarily the same order as in the record definition, and fields can be omitted. Omitted fields get their respective default value instead.</source>
          <target state="translated">字段的顺序可以是任意的,不一定与记录定义中的顺序相同,字段也可以省略。被省略的字段会得到各自的默认值。</target>
        </trans-unit>
        <trans-unit id="08c771e3c02df1bde386f66f03b2e079f068c16e" translate="yes" xml:space="preserve">
          <source>The fields in the structure are as follows:</source>
          <target state="translated">该结构中的字段如下:</target>
        </trans-unit>
        <trans-unit id="4eaa6a16da05e6ff18f84c1ebcd0b7aefc5111a7" translate="yes" xml:space="preserve">
          <source>The fields of record &lt;code&gt;mod&lt;/code&gt; have the following meaning:</source>
          <target state="translated">record &lt;code&gt;mod&lt;/code&gt; 的字段具有以下含义：</target>
        </trans-unit>
        <trans-unit id="e9f5d2712650575f495813aa5945d3da6ac26a56" translate="yes" xml:space="preserve">
          <source>The fields referred to in the pattern can be given in any order.</source>
          <target state="translated">模式中提到的字段可以按任何顺序给出。</target>
        </trans-unit>
        <trans-unit id="08db3122b6c1da4a657ae8cba808796dd5cb6b86" translate="yes" xml:space="preserve">
          <source>The fifth argument is the magic cookie.</source>
          <target state="translated">第五个论点是魔法饼干。</target>
        </trans-unit>
        <trans-unit id="9f962ab964ce6cd051f2dbc6e617195062eacc4f" translate="yes" xml:space="preserve">
          <source>The figures in this section illustrate the steps involved in the development of an SNMP agent.</source>
          <target state="translated">本节中的数字说明了开发SNMP代理的相关步骤。</target>
        </trans-unit>
        <trans-unit id="4cbdd4fa4fa7eb06d2c2cd3f4fc02cfd3c4c58d8" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;FileName&lt;/code&gt; is to be a plain text file and can contain comments and command-line arguments. A comment begins with a &lt;code&gt;#&lt;/code&gt; character and continues until the next end of line character. Backslash (\\) is used as quoting character. All command-line arguments accepted by &lt;code&gt;erl&lt;/code&gt; are allowed, also flag &lt;code&gt;-args_file FileName&lt;/code&gt;. Be careful not to cause circular dependencies between files containing flag &lt;code&gt;-args_file&lt;/code&gt;, though.</source>
          <target state="translated">文件名 &lt;code&gt;FileName&lt;/code&gt; 是纯文本文件，可以包含注释和命令行参数。注释以 &lt;code&gt;#&lt;/code&gt; 字符开头，并一直持续到下一行字符为止。反斜杠（\\）用作引号字符。允许 &lt;code&gt;erl&lt;/code&gt; 接受的所有命令行参数，以及 &lt;code&gt;-args_file FileName&lt;/code&gt; 标志。但是请注意不要在包含标志 &lt;code&gt;-args_file&lt;/code&gt; 的文件之间引起循环依赖。</target>
        </trans-unit>
        <trans-unit id="ef2a4ab9b2cbfd5981924e055242be9d6523c2f1" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;appl.erl&lt;/code&gt; is transferred from the remote to the local host. When the session is opened, the current directory at the remote host is &lt;code&gt;/home/guest&lt;/code&gt;, and &lt;code&gt;/home/fred&lt;/code&gt; at the local host. Before transferring the file, the current local directory is changed to &lt;code&gt;/home/eproj/examples&lt;/code&gt;, and the remote directory is set to &lt;code&gt;/home/guest/appl/examples&lt;/code&gt;.</source>
          <target state="translated">文件 &lt;code&gt;appl.erl&lt;/code&gt; 从远程传输到本地主机。打开会话时，远程主机上的当前目录为 &lt;code&gt;/home/guest&lt;/code&gt; ，本地主机上的 &lt;code&gt;/home/fred&lt;/code&gt; 。传输文件之前，当前本地目录已更改为 &lt;code&gt;/home/eproj/examples&lt;/code&gt; ，远程目录已设置为 &lt;code&gt;/home/guest/appl/examples&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5712e30f3c91d1fa3a6c8c851828ea49909dab0b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;ch_app.appup&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;ch_app.appup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed1f252a17bd502cae6f65b494d7abad29887093" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;foo.DCD&lt;/code&gt; has been created. This file will eventually store all data that is written into the &lt;code&gt;foo&lt;/code&gt; table.</source>
          <target state="translated">文件 &lt;code&gt;foo.DCD&lt;/code&gt; 已创建。该文件最终将存储所有写入 &lt;code&gt;foo&lt;/code&gt; 表的数据。</target>
        </trans-unit>
        <trans-unit id="763e1026cb9b967ac60a197e4f7623ff7204342f" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;macros.tab&lt;/code&gt; contains many useful macros. When implementing new instructions it is good practice to look through &lt;code&gt;macros.tab&lt;/code&gt; to see if any of existing macros can be used rather than re-inventing the wheel.</source>
          <target state="translated">文件 &lt;code&gt;macros.tab&lt;/code&gt; 包含许多有用的宏。实施新指令时，最好查看一下 &lt;code&gt;macros.tab&lt;/code&gt; 以查看是否可以使用任何现有的宏，而不是重新发明轮子。</target>
        </trans-unit>
        <trans-unit id="cef24f2335b5ba7f0dd2cc5fad1d52fb9d3d09b4" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; is a copy of our &lt;code&gt;mysystem.boot&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; 是我们的 &lt;code&gt;mysystem.boot&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="2b8b8152527aa20a7d4a0566192d86d3094913d9" translate="yes" xml:space="preserve">
          <source>The file cannot be found in any of the directories in &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Path&lt;/code&gt; 中的任何目录中找不到该文件。</target>
        </trans-unit>
        <trans-unit id="fc7fabdf332059e44e2eb17eeef692885d373bdb" translate="yes" xml:space="preserve">
          <source>The file cannot be opened.</source>
          <target state="translated">该文件无法打开。</target>
        </trans-unit>
        <trans-unit id="5c7f52d78cf6ae35996fa80363be9f75b4e0bd15" translate="yes" xml:space="preserve">
          <source>The file descriptor &lt;strong&gt;has&lt;/strong&gt; to be a real file descriptor. That is, no other operation should be able to get the same file descriptor until it has been released by the &lt;code&gt;close()&lt;/code&gt; callback.</source>
          <target state="translated">文件描述符&lt;strong&gt;已&lt;/strong&gt;成为一个真正的文件描述符。也就是说，在 &lt;code&gt;close()&lt;/code&gt; 回调将其释放之前，其他任何操作都不能获取相同的文件描述符。</target>
        </trans-unit>
        <trans-unit id="a9a0257416ae53879f4ba75c38e4782504676962" translate="yes" xml:space="preserve">
          <source>The file descriptor of the socket associated with the port.</source>
          <target state="translated">与 port 相关的 socket 的文件描述符。</target>
        </trans-unit>
        <trans-unit id="8273bc28b08e309fc9dd43621c30c7519263c61b" translate="yes" xml:space="preserve">
          <source>The file does not exist.</source>
          <target state="translated">该文件不存在。</target>
        </trans-unit>
        <trans-unit id="56db91f9bccb5529a0d13172d3cd82f3fa8e8d12" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the local host.</source>
          <target state="translated">该文件在本地主机上获得相同的名称。</target>
        </trans-unit>
        <trans-unit id="116b44d8dffe981177c481cc8f3dc87f0f7f4c3e" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the remote host.</source>
          <target state="translated">文件在远程主机上获得相同的名称。</target>
        </trans-unit>
        <trans-unit id="51b34af4a175f2b4aa90381774d3f18723da3b3d" translate="yes" xml:space="preserve">
          <source>The file includes both version 1, 2 and version 3 messages.</source>
          <target state="translated">该文件包括版本1、2和版本3的信息。</target>
        </trans-unit>
        <trans-unit id="9a9625a98d2c47b406a8f7769a6753258132546c" translate="yes" xml:space="preserve">
          <source>The file is a directory and the user is not superuser.</source>
          <target state="translated">文件是一个目录,用户不是超级用户。</target>
        </trans-unit>
        <trans-unit id="b21cd2436d24bafe2e40702865abc3fbecc09148" translate="yes" xml:space="preserve">
          <source>The file is in both these cases then best processed using the &lt;code&gt;io&lt;/code&gt; module, as the functions in that module can handle code points beyond the ISO Latin-1 range.</source>
          <target state="translated">在这两种情况下，都最好使用 &lt;code&gt;io&lt;/code&gt; 模块来处理文件，因为该模块中的功能可以处理超出ISO Latin-1范围的代码点。</target>
        </trans-unit>
        <trans-unit id="b2eb2fd7e69007e3b27fc3504af5f6bbd478142a" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;LocalFile&lt;/code&gt; on the local host.</source>
          <target state="translated">该文件在本地主机上名为 &lt;code&gt;LocalFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1df462cd01acebe1ec004334e0f1a8efe5b7e5b1" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;RemoteFile&lt;/code&gt; on the remote host.</source>
          <target state="translated">该文件在远程主机上名为 &lt;code&gt;RemoteFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03b686e18d29e8b42dc1dbee506d16c2eb2c5609" translate="yes" xml:space="preserve">
          <source>The file is not opened for reading.</source>
          <target state="translated">该文件未被打开阅读。</target>
        </trans-unit>
        <trans-unit id="0285680290f8aeb50ca6b7cbc6c042e3ad3dd657" translate="yes" xml:space="preserve">
          <source>The file is not opened for writing.</source>
          <target state="translated">文件没有打开写。</target>
        </trans-unit>
        <trans-unit id="e4982f438e094effbe19f49bddea5cc4009fdfdb" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. Every write operation to a file opened with &lt;code&gt;append&lt;/code&gt; takes place at the end of the file.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则会创建它。对通过 &lt;code&gt;append&lt;/code&gt; 打开的文件的每个写操作都在文件末尾进行。</target>
        </trans-unit>
        <trans-unit id="6d726a268237e91f14236fd6ff2803260e2e1532" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists and &lt;code&gt;write&lt;/code&gt; is not combined with &lt;code&gt;read&lt;/code&gt;, the file is truncated.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则会创建它。如果该文件存在并且 &lt;code&gt;write&lt;/code&gt; 不能与 &lt;code&gt;read&lt;/code&gt; 组合，则该文件将被截断。</target>
        </trans-unit>
        <trans-unit id="a197a2f03b6e053838765608c827205470531e6d" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists, &lt;code&gt;{error, eexist}&lt;/code&gt; is returned.</source>
          <target state="translated">该文件将打开以进行写入。如果不存在，则创建它。如果文件存在，则返回 &lt;code&gt;{error, eexist}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1abdf85470ebe2b741440d62063d01b5682aba19" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file and &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">该文件以请求的模式打开。 &lt;code&gt;IoDevice&lt;/code&gt; 是对该文件的引用，而 &lt;code&gt;FullName&lt;/code&gt; 是该文件的全名。</target>
        </trans-unit>
        <trans-unit id="7acf8ec21fa42c861a4f88f31a1e3b43a849b057" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file.</source>
          <target state="translated">该文件以请求的模式打开。 &lt;code&gt;IoDevice&lt;/code&gt; 是对该文件的引用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
