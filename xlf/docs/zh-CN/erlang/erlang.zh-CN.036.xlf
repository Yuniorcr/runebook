<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="a53a9f4087442a15c8d05293fde6edfea4bb383c" translate="yes" xml:space="preserve">
          <source>This module implements the command-line interface for running tests and basic functions for &lt;code&gt;Common Test&lt;/code&gt; case issues, such as configuration and logging.</source>
          <target state="translated">该模块实现了用于运行测试的命令行界面以及针对 &lt;code&gt;Common Test&lt;/code&gt; 案例问题（例如配置和日志记录）的基本功能。</target>
        </trans-unit>
        <trans-unit id="c9a16d56697c4875fd3dc95099670093ace6758a" translate="yes" xml:space="preserve">
          <source>This module implements the main API for logging in Erlang/OTP. To create a log event, use the &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; or the log &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">该模块实现用于登录Erlang / OTP的主要API。要创建日志事件，请使用 &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; 或日志 &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="34096d8559e322df745393832ab2c6dfe7da7fb5" translate="yes" xml:space="preserve">
          <source>This module is a &lt;code&gt;gen_event&lt;/code&gt; handler module that can be installed in any &lt;code&gt;gen_event&lt;/code&gt; process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser (&lt;code&gt;rb(3)&lt;/code&gt;) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called &lt;code&gt;index&lt;/code&gt;, and report files &lt;code&gt;1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">该模块是 &lt;code&gt;gen_event&lt;/code&gt; 处理程序模块，可以安装在任何 &lt;code&gt;gen_event&lt;/code&gt; 进程中。它将所有发送到事件管理器的事件记录到磁盘上。每个事件均以二进制形式编写，这使得记录速度非常快。但是，必须使用诸如报告浏览器（ &lt;code&gt;rb(3)&lt;/code&gt; ）之类的工具来读取文件。事件被写入多个文件。使用完所有文件后，第一个文件将被重用和覆盖。目录位置，文件数和每个文件的大小都是可配置的。该目录将包括一个文件调用 &lt;code&gt;index&lt;/code&gt; ，并报告文件 &lt;code&gt;1, 2, ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91f4aea2b0c25de578d81458879b8b8a6606f33f" translate="yes" xml:space="preserve">
          <source>This module is a first step to run property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. A property testing tool like QuickCheck or PropEr is assumed to be installed.</source>
          <target state="translated">该模块是在 &lt;code&gt;Common Test&lt;/code&gt; 框架中运行基于属性的测试的第一步。假定已安装诸如QuickCheck或PropEr之类的属性测试工具。</target>
        </trans-unit>
        <trans-unit id="745e849710741c8126631867ff49314e84421edc" translate="yes" xml:space="preserve">
          <source>This module is a front end to the pretty-printing library module &lt;code&gt;prettypr&lt;/code&gt;, for text formatting of abstract syntax trees defined by the module &lt;code&gt;erl_syntax&lt;/code&gt;.</source>
          <target state="translated">该模块是一个前端的漂亮印刷库模块 &lt;code&gt;prettypr&lt;/code&gt; ，文本由模块定义的抽象语法树的格式 &lt;code&gt;erl_syntax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="771c2457f87cf1d0281342c6af1f3ab5bb5e2564" translate="yes" xml:space="preserve">
          <source>This module is also used by the test module described in the next section.</source>
          <target state="translated">这个模块也被下一节描述的测试模块使用。</target>
        </trans-unit>
        <trans-unit id="029ed3af3c0fa1d9308479815ba39c6258f71e21" translate="yes" xml:space="preserve">
          <source>This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of &lt;code&gt;ordered_set&lt;/code&gt;, see below, access time is proportional to the logarithm of the number of stored objects.)</source>
          <target state="translated">该模块是Erlang内置术语存储BIF的接口。这些提供了在Erlang运行时系统中存储大量数据的能力，并具有对数据的恒定访问时间。（对于 &lt;code&gt;ordered_set&lt;/code&gt; ，请参见下文，访问时间与存储对象数的对数成正比。）</target>
        </trans-unit>
        <trans-unit id="2bf3be01bc933bf9be0bb2caf2dc7622f94a43df" translate="yes" xml:space="preserve">
          <source>This module is deprecated. For a description of the Magic Cookie system, refer to &lt;code&gt;Distributed Erlang&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">该模块已弃用。有关Magic Cookie系统的说明，请参阅《 Erlang参考手册》中的&amp;ldquo; &lt;code&gt;Distributed Erlang&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2a93d2db2466d23d6026908c314c14a83563ca6b" translate="yes" xml:space="preserve">
          <source>This module is mainly intended for internal use within OTP, but it has two functions that are exported for public use.</source>
          <target state="translated">这个模块主要是供OTP内部使用的,但它有两个功能是输出给公众使用的。</target>
        </trans-unit>
        <trans-unit id="1a37f6b1919b03e1a3eef60f562daa64d563a0b3" translate="yes" xml:space="preserve">
          <source>This module is preloaded and contains the code for the &lt;code&gt;init&lt;/code&gt; system process that coordinates the startup of the system. The first function evaluated at startup is &lt;code&gt;boot(BootArgs)&lt;/code&gt;, where &lt;code&gt;BootArgs&lt;/code&gt; is a list of command-line arguments supplied to the Erlang runtime system from the local operating system; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">该模块已预先加载，其中包含用于协调系统启动的 &lt;code&gt;init&lt;/code&gt; 系统进程的代码。启动时评估的第一个函数是 &lt;code&gt;boot(BootArgs)&lt;/code&gt; ，其中 &lt;code&gt;BootArgs&lt;/code&gt; 是从本地操作系统提供给Erlang运行时系统的命令行参数列表；参见 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8550670270cc6c0c154e6b678e3322ac083e01" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling GET requests to regular files. GET requests for parts of files is handled by &lt;code&gt;mod_range&lt;/code&gt;.</source>
          <target state="translated">该模块负责处理对常规文件的GET请求。对部分文件的GET请求由 &lt;code&gt;mod_range&lt;/code&gt; 处理。</target>
        </trans-unit>
        <trans-unit id="539b25aff993fcacaf4286ade9ec0f542cedebde" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling HEAD requests to regular files. HEAD requests for dynamic content is handled by each module responsible for dynamic content.</source>
          <target state="translated">该模块负责处理对普通文件的HEAD请求。动态内容的HEAD请求由负责动态内容的各模块处理。</target>
        </trans-unit>
        <trans-unit id="5ce2d8127480b9b1949b76303752c4240c4a9505" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="translated">该模块是基本的Erlang解析器，它将令牌转换为形式（即顶级构造），表达式或术语的抽象形式。《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 描述了抽象格式。请注意，令牌列表必须以&lt;strong&gt;点&lt;/strong&gt;令牌结尾，以便解析函数可以接受（请参阅 &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt; ）模块。</target>
        </trans-unit>
        <trans-unit id="bc2b019e4ec5090f2acbc77c196c921bcb3de610" translate="yes" xml:space="preserve">
          <source>This module is the default error report module, but can be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块是默认的错误报告模块，但可以显式配置，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84c431043a09432c4f87c8d3c357236a55bbfcb6" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0.</source>
          <target state="translated">这个模块是XML解析器的接口,它处理XML 1.0。</target>
        </trans-unit>
        <trans-unit id="3104bc131d319b6e5efc35816fb7e2161d34e06f" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0. The XML parser is activated through &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; or &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. It returns records of the type defined in xmerl.hrl. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">该模块是XML解析器的接口，它处理XML 1.0。XML解析器通过 &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 或 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 激活。它返回xmerl.hrl中定义的类型的记录。另请参阅有关自定义功能的 &lt;code&gt;tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c37b4a9c779ad7673d2176f38ce64f13f8e8ff9a" translate="yes" xml:space="preserve">
          <source>This module is the main EUnit user interface.</source>
          <target state="translated">该模块是EUnit的主要用户界面。</target>
        </trans-unit>
        <trans-unit id="380eae6ed1f14f5abc43a6827952590fc885d0c2" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块用作 &lt;code&gt;os_sup&lt;/code&gt; 的Windows后端，请参见 &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85cabe69b73c75cfce665849059c6c267e570fc3" translate="yes" xml:space="preserve">
          <source>This module is used by module &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; for managing distributed disk logs. The disk log names are used as group names, which means that some action can be needed to avoid name clashes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 模块使用此模块来管理分布式磁盘日志。磁盘日志名称用作组名称，这意味着可能需要采取一些措施来避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="2facc0dce78b1734ff96c5e2c414eea0b55cfeef" translate="yes" xml:space="preserve">
          <source>This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used.</source>
          <target state="translated">这个模块是由Mnesia应用程序使用的,它是 &quot;按原样 &quot;提供给那些对高效存储Erlang术语感兴趣的用户的。许多应用程序只需要在文件中存储一些术语。Mnesia增加了事务、查询和分发功能。Dets文件的大小不能超过2GB。如果需要更大的表,可以使用Mnesia中的表碎片。</target>
        </trans-unit>
        <trans-unit id="0a4a5f76c2f39ee7d14410f547c13073a7f0ccea" translate="yes" xml:space="preserve">
          <source>This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended.</source>
          <target state="translated">该模块用于检查Erlang代码是否存在非法语法和其他错误。它还对不推荐的编码实践提出警告。</target>
        </trans-unit>
        <trans-unit id="eeb466b5da365f466e8f7e7ccc932ed35a24cf1b" translate="yes" xml:space="preserve">
          <source>This module is used to load all Erlang modules into the system. The start script is also fetched with this low-level loader.</source>
          <target state="translated">这个模块用于将所有的Erlang模块加载到系统中。启动脚本也是通过这个低级加载器获取的。</target>
        </trans-unit>
        <trans-unit id="2290e1725f60788cc5c925cb7d57804f016396a1" translate="yes" xml:space="preserve">
          <source>This module is used to profile a program to find out how the execution time is used. Trace to file is used to minimize runtime performance impact.</source>
          <target state="translated">该模块用于对程序进行剖析,了解执行时间的使用情况。追踪到文件是用来最小化运行时的性能影响。</target>
        </trans-unit>
        <trans-unit id="4c89a4f0fda18575f2da9f933c35be2fd6e70e09" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt;OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该模块用于启动遵循 &lt;code&gt;OTP Design Principles&lt;/code&gt; 流程。具体来说，启动新进程时，OTP标准行为（例如 &lt;code&gt;gen_server&lt;/code&gt; 和 &lt;code&gt;gen_statem&lt;/code&gt; ）将使用此模块中的功能。这些功能还可用于启动&lt;strong&gt;特殊过程&lt;/strong&gt;，即符合OTP设计原则的用户定义过程。有关示例，请参见OTP设计原则中的 &lt;code&gt;sys and proc_lib&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="7f4ab243ee6586ee79497742f5b5a43934de147b" translate="yes" xml:space="preserve">
          <source>This module is usually part of the &lt;code&gt;erl_interface&lt;/code&gt; application, but is currently part of the Mnesia application.</source>
          <target state="translated">该模块通常是 &lt;code&gt;erl_interface&lt;/code&gt; 应用程序的一部分，但当前是Mnesia应用程序的一部分。</target>
        </trans-unit>
        <trans-unit id="1e34649b10e11074b5eecec6992267ea5de9baf9" translate="yes" xml:space="preserve">
          <source>This module maintains a cache of CRLs. CRLs can be added to the cache using the function &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt;, and optionally automatically fetched through HTTP if the following argument is specified:</source>
          <target state="translated">此模块维护CRL的缓存。可以使用 &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt; 函数将 CRL添加到缓存中，如果指定了以下参数，则可以选择通过HTTP自动获取CRL ：</target>
        </trans-unit>
        <trans-unit id="99468bcd97490a51d234dfa1e1aa1f1b75181a01" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块可以将系统的节点划分为&lt;strong&gt;全局组&lt;/strong&gt;。每个全局组都有自己的全局名称空间，请参阅 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ac57e5b97d1c2443f197da3b8016c360ca297b4" translate="yes" xml:space="preserve">
          <source>This module makes it possible to read internally formatted wrap disk logs, see &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;wrap_log_reader&lt;/code&gt; does not interfere with &lt;code&gt;disk_log&lt;/code&gt; activities; there is however a bug in this version of the &lt;code&gt;wrap_log_reader&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块可以读取内部格式化的包装磁盘日志，请参阅 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;wrap_log_reader&lt;/code&gt; 不会干扰 &lt;code&gt;disk_log&lt;/code&gt; 活动；但是，在该版本的 &lt;code&gt;wrap_log_reader&lt;/code&gt; 中存在一个错误，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="989e49030b5db914fe14f640feffac69f14c2c8d" translate="yes" xml:space="preserve">
          <source>This module makes use of a directory where CRLs are stored in files named by the hash of the issuer name.</source>
          <target state="translated">该模块利用一个目录,将CRL存储在以发行商名称的哈希值命名的文件中。</target>
        </trans-unit>
        <trans-unit id="3e4a8e573560a8571cd9ef1e8a9e51dcf07a77f3" translate="yes" xml:space="preserve">
          <source>This module needs to be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要明确配置此模块，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b605512fe66b8682ce8b37c4cf3e4fbe2e01d42" translate="yes" xml:space="preserve">
          <source>This module operates on grapheme clusters. A &lt;strong&gt;grapheme cluster&lt;/strong&gt; is a user-perceived character, which can be represented by several codepoints.</source>
          <target state="translated">该模块在字素簇上运行。字素&lt;strong&gt;簇&lt;/strong&gt;是用户感知的字符，可以由几个代码点表示。</target>
        </trans-unit>
        <trans-unit id="bb1c46b6a237b6087130260dff45a5cc687d6cba" translate="yes" xml:space="preserve">
          <source>This module performs DNS name resolving to recursive name servers.</source>
          <target state="translated">该模块对递归的名称服务器进行DNS名称解析。</target>
        </trans-unit>
        <trans-unit id="4ab7b3a5e783c28b801aa97ce3c793f0d6d021bc" translate="yes" xml:space="preserve">
          <source>This module performs an identity parse transformation of Erlang code. It is included as an example for users who wants to write their own parse transformers. If option &lt;code&gt;{parse_transform,Module}&lt;/code&gt; is passed to the compiler, a user-written function &lt;code&gt;parse_transform/2&lt;/code&gt; is called by the compiler before the code is checked for errors.</source>
          <target state="translated">此模块执行Erlang代码的身份解析转换。它是为想要编写自己的解析转换器的用户提供的示例。如果将选项 &lt;code&gt;{parse_transform,Module}&lt;/code&gt; 传递给编译器，则在检查代码是否存在错误之前，编译器将调用用户编写的函数 &lt;code&gt;parse_transform/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0037900bad0730ea9a030ba4069f75cb17a7f8b" translate="yes" xml:space="preserve">
          <source>This module provides (double-ended) FIFO queues in an efficient manner.</source>
          <target state="translated">该模块以高效的方式提供(双端)FIFO队列。</target>
        </trans-unit>
        <trans-unit id="86963c4e13e1aeb4e47cbb6c0a5df6d5e8a947ad" translate="yes" xml:space="preserve">
          <source>This module provides API functions to send SSH Connection Protocol events to the other side of an SSH channel.</source>
          <target state="translated">该模块提供API函数,用于将SSH连接协议事件发送到SSH通道的另一边。</target>
        </trans-unit>
        <trans-unit id="ce8b320b968902deab02747f5036f5e0f055ee88" translate="yes" xml:space="preserve">
          <source>This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees.</source>
          <target state="translated">这个模块提供了Arne Andersson教授的通用平衡树。与非平衡二叉树相比,这些树没有存储开销,而且其性能比AVL树更好。</target>
        </trans-unit>
        <trans-unit id="781b6c37f92636bd37c09e7bf44c27d67bf8df9d" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. An &lt;code&gt;orddict&lt;/code&gt; is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the &lt;strong&gt;Erlang term order&lt;/strong&gt;.</source>
          <target state="translated">该模块提供了 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 字典。一个 &lt;code&gt;orddict&lt;/code&gt; 是一个字典，其中对一个列表用于存储的键和值的表示。该列表按&lt;strong&gt;Erlang术语中&lt;/strong&gt;的键&lt;strong&gt;排序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="54ac9b6927419ddb4103884312f8097df3f2bb5a" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. The representation of a dictionary is not defined.</source>
          <target state="translated">该模块提供了 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 字典。未定义字典的表示。</target>
        </trans-unit>
        <trans-unit id="393cc80d6eca92a704f69151bc3d7efe95ae4615" translate="yes" xml:space="preserve">
          <source>This module provides a client api to the Lightweight Directory Access Protocol (LDAP).</source>
          <target state="translated">该模块为轻量级目录访问协议(LDAP)提供了一个客户端api。</target>
        </trans-unit>
        <trans-unit id="f62d79bfd7ef0367f3e971c525740d763d760116" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms use the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="translated">该模块提供了伪随机数生成器。该模块包含许多算法。均匀分布算法使用 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; 的xoroshiro116 +和xorshift1024 *算法。正态分布算法在均匀分布算法的基础上使用 &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; 的Ziggurat方法。</target>
        </trans-unit>
        <trans-unit id="f99a3f1888d10fffd183a70ef4c3a34c9ed1aee3" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;code&gt;Mnesia&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt;, and other data structures that provide an iterator style traversal of objects.</source>
          <target state="translated">该模块为 &lt;code&gt;Mnesia&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt; 和其他提供对象迭代器样式遍历的数据结构提供查询接口。</target>
        </trans-unit>
        <trans-unit id="4250319025eafcb7ae410e50274c9a7bdf114b1e" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt;Erlang Reference Manual&lt;/code&gt; and &lt;code&gt;Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="translated">该模块提供了&lt;strong&gt;QLC表&lt;/strong&gt;的查询接口。典型的QLC表是Mnesia，ETS和Dets表。还提供了对用户定义表的支持，请参阅 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 。一个&lt;strong id=&quot;query_list_comprehension&quot;&gt;查询&lt;/strong&gt;使用表示&lt;strong&gt;查询列表综合&lt;/strong&gt;（QLCs）。查询的答案由QLC表中的数据确定，这些数据满足查询的QLC所表示的约束。 QLC与《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 和《 &lt;code&gt;Programming Examples&lt;/code&gt; 所述的普通列表理解类似，不同之处在于，模式中引入的变量不能用于列表表达式中。在没有优化和选项的情况下，例如 &lt;code&gt;cache&lt;/code&gt; 和 &lt;code&gt;unique&lt;/code&gt; （请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 部分，每个没有QLC表的QLC都会得出与相同的普通列表理解相同的答案列表。</target>
        </trans-unit>
        <trans-unit id="047710b1ad9fd2f027b84c9368779228a800a4da" translate="yes" xml:space="preserve">
          <source>This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in 'An efficient and portable pseudo-random number generator', Journal of Applied Statistics. AS183. 1982. Also Byte March 1987.</source>
          <target state="translated">这个模块提供了一个随机数生成器。该方法归功于B.A.Wichmann和I.D.Hill在 &quot;An efficient and portable pseudo-random number generator&quot;,Journal of Applied Statistics.AS183.B.A.Wichmann和I.D.Hill在 &quot;An efficient and portable pseudo-random number generator&quot;,Journal of Applied Statistics.1982.也是Byte 1987年3月。</target>
        </trans-unit>
        <trans-unit id="52aa0232673b318eae9c0f57627c3e65f31b22a8" translate="yes" xml:space="preserve">
          <source>This module provides a set of cryptographic functions.</source>
          <target state="translated">该模块提供了一组加密函数。</target>
        </trans-unit>
        <trans-unit id="2efbf1cf06a7e77fc1af683651fd7cc8b8da3411" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are sent to the &lt;code&gt;error_logger&lt;/code&gt; after a size check. Messages are truncated after 1024 chars. It is provided as an example.</source>
          <target state="translated">该模块提供了一种报告SNMP错误的简单机制。大小检查后，错误将发送到 &lt;code&gt;error_logger&lt;/code&gt; 。消息在1024个字符后被截断。作为示例提供。</target>
        </trans-unit>
        <trans-unit id="096fb2e3550a9bb0e5272f77db40c6b69c2ccf79" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are written to stdout using the &lt;code&gt;io&lt;/code&gt; module. It is provided as an simple example.</source>
          <target state="translated">该模块提供了一种报告SNMP错误的简单机制。使用 &lt;code&gt;io&lt;/code&gt; 模块将错误写入stdout 。它只是一个简单的示例。</target>
        </trans-unit>
        <trans-unit id="1286f91cbc25e7fd94773e366acdb66f0cb92b07" translate="yes" xml:space="preserve">
          <source>This module provides a term storage on file. The stored terms, in this module called &lt;strong&gt;objects&lt;/strong&gt;, are tuples such that one element is defined to be the key. A Dets &lt;strong&gt;table&lt;/strong&gt; is a collection of objects with the key at the same position stored on a file.</source>
          <target state="translated">此模块提供术语存储在文件中。在此模块中称为&lt;strong&gt;对象&lt;/strong&gt;的存储术语是元组，以便将一个元素定义为键。Dets &lt;strong&gt;表&lt;/strong&gt;是对象的集合，其中密钥位于文件中的相同位置。</target>
        </trans-unit>
        <trans-unit id="1620c061e4de1e2d509ff847686aeef840c94ae4" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="translated">本模块提供了一个标签定向图的版本。这里提供的图之所以是非正向图,是因为允许顶点之间有多条边。但是,这里使用的是有向图的习惯定义。</target>
        </trans-unit>
        <trans-unit id="d4cf7ab2f5fd96a0860285a8e510288d8e51d560" translate="yes" xml:space="preserve">
          <source>This module provides access to TCP/IP protocols.</source>
          <target state="translated">本模块提供对TCP/IP协议的访问。</target>
        </trans-unit>
        <trans-unit id="ce4f070d6f9440d796d3f2ff1b4d9fe245970d26" translate="yes" xml:space="preserve">
          <source>This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">该模块提供基于有向图的深度优先遍历的算法。有关有向图的基本功能，请参见 &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="750641c760c68123c0ef647455d03f63c154be54" translate="yes" xml:space="preserve">
          <source>This module provides an API for the zlib library (&lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt;). It is used to compress and decompress data. The data format is described by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块为zlib库（ &lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt; ）提供了API 。它用于压缩和解压缩数据。数据格式由 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt; 描述。</target>
        </trans-unit>
        <trans-unit id="faf120ddebe052c8dc6014a2841d031820c05adf" translate="yes" xml:space="preserve">
          <source>This module provides an Erlang shell.</source>
          <target state="translated">这个模块提供了一个Erlang shell。</target>
        </trans-unit>
        <trans-unit id="ce785837b5ff1a707a464ab7d4098ba53cf3ddeb" translate="yes" xml:space="preserve">
          <source>This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of &lt;strong id=&quot;annotations&quot;&gt;annotations&lt;/strong&gt; as described in the following.</source>
          <target state="translated">该模块提供了一种抽象类型，Erlang编译器及其帮助程序模块使用该抽象类型来保存诸如列，行号和文本之类的数据。数据类型是&lt;strong id=&quot;annotations&quot;&gt;注释&lt;/strong&gt;的集合，如下所述。</target>
        </trans-unit>
        <trans-unit id="c240161f74f286924b1ecba60c9826a37e901d2d" translate="yes" xml:space="preserve">
          <source>This module provides an interface for loading and unloading &lt;strong&gt;Erlang linked-in drivers&lt;/strong&gt; in runtime.</source>
          <target state="translated">该模块提供了一个接口，用于在运行时加载和卸载&lt;strong&gt;Erlang链接的驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0d50e0a3798c5432e0aff3d79f28ece00952d5f8" translate="yes" xml:space="preserve">
          <source>This module provides an interface to a number of mathematical functions.</source>
          <target state="translated">该模块提供了一些数学函数的接口。</target>
        </trans-unit>
        <trans-unit id="b5733344375dbedf0030d51fc4fa5b63269782bb" translate="yes" xml:space="preserve">
          <source>This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks.</source>
          <target state="translated">该模块为BEAM编译器创建的文件(&quot;BEAM文件&quot;)提供一个接口。所使用的格式是 &quot;EA IFF 1985 &quot;交换格式文件标准的变体,将数据分成几块。</target>
        </trans-unit>
        <trans-unit id="4c0abe15371bacb3988f25e8e42f9bd6deaa06d4" translate="yes" xml:space="preserve">
          <source>This module provides an interface to standard Erlang I/O servers. The output functions all return &lt;code&gt;ok&lt;/code&gt; if they are successful, or exit if they are not.</source>
          <target state="translated">该模块提供了到标准Erlang I / O服务器的接口。如果成功，所有输出函数都将返回 &lt;code&gt;ok&lt;/code&gt; ，否则将退出。</target>
        </trans-unit>
        <trans-unit id="bb92749dec61f65e77f765c953d790353efc379f" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the file system.</source>
          <target state="translated">该模块提供了一个文件系统的接口。</target>
        </trans-unit>
        <trans-unit id="0ea2060b34505717f9518e88bbe84cae8d4301f7" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the standard Erlang compiler. It can generate either a new file, which contains the object code, or return a binary, which can be loaded directly.</source>
          <target state="translated">这个模块提供了一个连接标准Erlang编译器的接口,它可以生成一个新的文件,其中包含对象代码,或者返回一个二进制文件,可以直接加载。它可以生成一个新的文件,其中包含对象代码,或者返回一个二进制文件,可以直接加载。</target>
        </trans-unit>
        <trans-unit id="1e596baf52d2a5d67161fc159d66bc7111b7496e" translate="yes" xml:space="preserve">
          <source>This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt;, the Erlang parser, or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块为Erlang表达式提供了解释器。表达式采用 &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt; ，Erlang解析器或 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 返回的抽象语法。</target>
        </trans-unit>
        <trans-unit id="71c532b071cf1e2933fea5e0754fde5565914b25" translate="yes" xml:space="preserve">
          <source>This module provides computation of local and universal time, day of the week, and many time conversion functions.</source>
          <target state="translated">本模块提供了本地时间、通用时间、星期和许多时间转换函数的计算。</target>
        </trans-unit>
        <trans-unit id="f095529d267dab0aeb8e3b8b1364f61d105a9b58" translate="yes" xml:space="preserve">
          <source>This module provides for basic user authentication using textual files, Dets databases, or Mnesia databases.</source>
          <target state="translated">该模块提供了使用文本文件、Dets数据库或Mnesia数据库的基本用户认证。</target>
        </trans-unit>
        <trans-unit id="c9257a7b2b5d2a4ae1e7c3b4a499e70e6fee999d" translate="yes" xml:space="preserve">
          <source>This module provides functions for allocating and deallocating memory.</source>
          <target state="translated">该模块提供了分配和重新分配内存的功能。</target>
        </trans-unit>
        <trans-unit id="d1acd3ec02989ce1863b1f9978f7179ed4f16a75" translate="yes" xml:space="preserve">
          <source>This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like &lt;code&gt;foo.erl&lt;/code&gt;, a long absolute name including a drive designator, a directory name like &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt;, or any variations in between.</source>
          <target state="translated">该模块提供了用于分析和处理文件名的功能。设计这些功能是为了使Erlang代码可以在具有不同文件名格式的许多不同平台上工作。文件名是指可用于表示文件的所有字符串。文件名可以是一个简短的相对名称，如 &lt;code&gt;foo.erl&lt;/code&gt; ，一个绝对的长名称，包括一个驱动器标识符，一个目录名，例如 &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt; ，或之间的任何变体。</target>
        </trans-unit>
        <trans-unit id="ba26786354c2721a7cffffe073a2f1107136ad72" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; through the user-level &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块提供使用SCTP协议与套接字进行通信的功能。该实现假定OS内核通过用户级 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 支持SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6237d5a917a923f45f8684296ea4f397f5ee1fec" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the TCP/IP protocol.</source>
          <target state="translated">该模块提供了使用TCP/IP协议与套接字进行通信的功能。</target>
        </trans-unit>
        <trans-unit id="047ce7d569f63519c312507e77fc10e7a0abdd77" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the UDP protocol.</source>
          <target state="translated">该模块提供了使用UDP协议与套接字进行通信的功能。</target>
        </trans-unit>
        <trans-unit id="4170af0d02bb4471c502310e774e78bff4f783ba" translate="yes" xml:space="preserve">
          <source>This module provides functions for creating and manipulating Erlang terms.</source>
          <target state="translated">该模块提供了创建和操作Erlang术语的功能。</target>
        </trans-unit>
        <trans-unit id="1e4339ab7b3c28859324758d30d70eff072c8031" translate="yes" xml:space="preserve">
          <source>This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master.</source>
          <target state="translated">该模块提供了启动Erlang从属节点的功能。所有由主节点启动的从节点在主节点终止时自动终止。所有在从节点产生的终端输出都会发回主节点。文件I/O是通过主节点完成的。</target>
        </trans-unit>
        <trans-unit id="b46a173f5bc0dfe98e3415de1917b5e2303db97e" translate="yes" xml:space="preserve">
          <source>This module provides functions for string processing.</source>
          <target state="translated">该模块提供了字符串处理的功能。</target>
        </trans-unit>
        <trans-unit id="fb4e067fc4ce218df6cee6a75080152b7287b4b0" translate="yes" xml:space="preserve">
          <source>This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element.</source>
          <target state="translated">本模块提供了对有限集和以集表示的关系的操作。直观地讲,集合是一个元素的集合;每个元素都属于集合,集合包含每个元素。</target>
        </trans-unit>
        <trans-unit id="9b7c8f4236f4ac7c20019baf55ac92c3062eac4e" translate="yes" xml:space="preserve">
          <source>This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application.</source>
          <target state="translated">本模块使用Arne Andersson教授的通用平衡树提供有序集。对于较大的集合,有序集比使用有序列表更有效,但这取决于应用。</target>
        </trans-unit>
        <trans-unit id="ba40f5b3e99d275a596aa07c0dff3f599128accf" translate="yes" xml:space="preserve">
          <source>This module provides per-directory user configurable access control.</source>
          <target state="translated">该模块提供每个目录用户可配置的访问控制。</target>
        </trans-unit>
        <trans-unit id="2c12c2072886f929b57ed6b57be79da289e76ef8" translate="yes" xml:space="preserve">
          <source>This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry.</source>
          <target state="translated">这个模块提供了对Windows注册表的读写访问。它本质上是一个围绕Win32 API调用的端口驱动程序,用于访问注册表。</target>
        </trans-unit>
        <trans-unit id="c778b6bf3c6ceb257250b7ae833621c36f93fd49" translate="yes" xml:space="preserve">
          <source>This module provides some limited support for concurrent access. All updates to single objects are guaranteed to be both &lt;strong&gt;atomic&lt;/strong&gt; and &lt;strong&gt;isolated&lt;/strong&gt;. This means that an updating operation to a single object either succeeds or fails completely without any effect (atomicity) and that no intermediate results of the update can be seen by other processes (isolation). Some functions that update many objects state that they even guarantee atomicity and isolation for the entire operation. In database terms the isolation level can be seen as &quot;serializable&quot;, as if all isolated operations are carried out serially, one after the other in a strict order.</source>
          <target state="translated">该模块为并发访问提供了一些有限的支持。保证对单个对象的所有更新都是&lt;strong&gt;原子的&lt;/strong&gt;和&lt;strong&gt;隔离的&lt;/strong&gt;。这意味着对单个对象的更新操作要么成功要么完全失败，而没有任何影响（原子性），并且其他过程也看不到更新的中间结果（隔离）。一些更新许多对象的函数表示，它们甚至可以保证整个操作的原子性和隔离性。用数据库术语来说，隔离级别可以看作是&amp;ldquo;可序列化的&amp;rdquo;，就好像所有隔离操作都是按顺序执行的，一个接一个地严格执行。</target>
        </trans-unit>
        <trans-unit id="e080461e2e77686f66945fda37287e52c6b43e16" translate="yes" xml:space="preserve">
          <source>This module provides support for communication between distributed Erlang nodes and C-nodes, in a manner that is transparent to Erlang processes.</source>
          <target state="translated">该模块以对Erlang进程透明的方式,为分布式Erlang节点和C节点之间的通信提供支持。</target>
        </trans-unit>
        <trans-unit id="9dd15c5a43f249c41879dce22695542c08e92337" translate="yes" xml:space="preserve">
          <source>This module provides support for registering, looking up, and unregistering names in the &lt;code&gt;global&lt;/code&gt; module. For more information, see &lt;code&gt;kernel:global&lt;/code&gt;.</source>
          <target state="translated">该模块支持在 &lt;code&gt;global&lt;/code&gt; 模块中注册，查找和取消注册名称。有关更多信息，请参见 &lt;code&gt;kernel:global&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acc44f686954a04de29fbc3692f9d04d65486748" translate="yes" xml:space="preserve">
          <source>This module provides support for storing key-value pairs in a table known as a registry, backing up registries to &lt;code&gt;Mnesia&lt;/code&gt; in an atomic manner, and later restoring the contents of a registry from &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">此模块提供支持，以将键值对存储在称为注册表的表中，以原子方式将注册表备份到 &lt;code&gt;Mnesia&lt;/code&gt; ，然后从 &lt;code&gt;Mnesia&lt;/code&gt; 恢复注册表的内容。</target>
        </trans-unit>
        <trans-unit id="c4fb892b992e614adc88b69df82b17ae13945733" translate="yes" xml:space="preserve">
          <source>This module provides the API to an HTTP/1.1 compatible client according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Caching is not supported.</source>
          <target state="translated">该模块根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 向与HTTP / 1.1兼容的客户端提供API 。不支持缓存。</target>
        </trans-unit>
        <trans-unit id="6480b6d56431c3c7e09177c0ce29744efb2ce799" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with miscellaneous utility functions.</source>
          <target state="translated">该模块为Erlang Web服务器API模块程序员提供了杂七杂八的实用功能。</target>
        </trans-unit>
        <trans-unit id="0b8c5916e2632e665c5b2f5f52d5c56b0a93bc00" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with utility functions for generic sockets communication. The appropriate communication mechanism is transparently used, that is, &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;.</source>
          <target state="translated">该模块为Erlang Web服务器API模块编程人员提供了用于通用套接字通信的实用程序功能。透明地使用了适当的通信机制，即 &lt;code&gt;ip_comm&lt;/code&gt; 或 &lt;code&gt;ssl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a178749a79e6fb26e39ef05fff26033dce75ac3" translate="yes" xml:space="preserve">
          <source>This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733.</source>
          <target state="translated">该模块提供了一个接口,用户可以通过该接口实现一个使用RFC 6733中定义的Diameter协议发送和接收消息的Diameter节点。</target>
        </trans-unit>
        <trans-unit id="2290d99631f95e83db0417df2bd64d3d9576bcac" translate="yes" xml:space="preserve">
          <source>This module provides the most basic API to the clients and servers that are part of the &lt;code&gt;Inets&lt;/code&gt; application, such as start and stop.</source>
          <target state="translated">此模块为 &lt;code&gt;Inets&lt;/code&gt; 应用程序中的客户端和服务器提供最基本的API ，例如启动和停止。</target>
        </trans-unit>
        <trans-unit id="c2dc289d587182daff0825395e7477905794ef0d" translate="yes" xml:space="preserve">
          <source>This module provides the parse transformation that makes calls to &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell.</source>
          <target state="translated">该模块提供了解析转换，该转换使对 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 的调用转换为文字匹配规范。当从Erlang shell调用时，它还为相同的功能提供后端。</target>
        </trans-unit>
        <trans-unit id="721a3117429eceb8f061f5e2899bcbfb40bdf110" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;dict&lt;/code&gt; considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有定义的表示形式。一个区别是，当 &lt;code&gt;dict&lt;/code&gt; 认为两个键不匹配时（ &lt;code&gt;=:=&lt;/code&gt; ）是不同的，而当且仅当两个键的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才认为两个键是不同的。</target>
        </trans-unit>
        <trans-unit id="f2cfe02c9b447eb5cee32eb141157e31208af9a7" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; module. One difference is that while this module considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;orddict&lt;/code&gt; considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口。一个区别是，虽然此模块将两个键如果不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，则 &lt;code&gt;orddict&lt;/code&gt; 将且仅当两个键不相等时才将两个键视为不同（ &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="38d6e52db1a80893122e1c828b20e43583ef95f9" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;ordsets&lt;/code&gt; considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有未定义的表示形式。一个区别是，尽管此模块将两个元素不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，而 &lt;code&gt;ordsets&lt;/code&gt; 仅当且仅当它们不相等时才将两个元素视为不同（ &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6fff0aaa0429816efbfd85cd732dd006ea6157aa" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;sets&lt;/code&gt; considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有定义的表示形式。一个区别是，尽管 &lt;code&gt;sets&lt;/code&gt; 将两个元素不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，但是当且仅当两个元素的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将两个元素视为不同。</target>
        </trans-unit>
        <trans-unit id="742e632c6552d16bd6d478a7d1daf12903965f79" translate="yes" xml:space="preserve">
          <source>This module provides useful functions related to time. Unless otherwise stated, time is always measured in &lt;strong&gt;milliseconds&lt;/strong&gt;. All timer functions return immediately, regardless of work done by another process.</source>
          <target state="translated">该模块提供了与时间有关的有用功能。除非另有说明，否则时间始终以&lt;strong&gt;毫秒为单位&lt;/strong&gt;。不管另一个进程完成什么工作，所有计时器功能都会立即返回。</target>
        </trans-unit>
        <trans-unit id="b7d4e83f9e995a297aeebc8e6a32d2dba035f338" translate="yes" xml:space="preserve">
          <source>This module provides utility functions for working with URIs, according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; ，此模块提供了用于处理URI的实用程序功能。</target>
        </trans-unit>
        <trans-unit id="69116d4fbcf6560d1469aa6a1f54ad5b50520175" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_channel.</source>
          <target state="translated">这个模块取代了ssh_channel。</target>
        </trans-unit>
        <trans-unit id="e4595252d25beb7eb4255174f697d15c0830a38f" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_daemon_channel.</source>
          <target state="translated">这个模块取代了ssh_daemon_channel。</target>
        </trans-unit>
        <trans-unit id="8aeeae3a06e268738003ec9e46ac483c94be8f5b" translate="yes" xml:space="preserve">
          <source>This module responses to requests for one or many ranges of a file. This is especially useful when downloading large files, as a broken download can be resumed.</source>
          <target state="translated">该模块响应对一个或多个文件范围的请求。这在下载大文件时特别有用,因为中断的下载可以恢复。</target>
        </trans-unit>
        <trans-unit id="181bfa906d54214c120e83123d1185ab071fc48e" translate="yes" xml:space="preserve">
          <source>This module runs CGI scripts whenever a file of a certain type or HTTP method (see &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;) is requested.</source>
          <target state="translated">每当请求某种类型或HTTP方法的文件（请参阅 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）时，此模块就会运行CGI脚本。</target>
        </trans-unit>
        <trans-unit id="6cf32be7983eb16f31b4b6b42dc9e21cb5289f56" translate="yes" xml:space="preserve">
          <source>This module tokenises and parses most Erlang source code without expanding preprocessor directives and macro applications, as long as these are syntactically &quot;well-behaved&quot;. Because the normal parse trees of the &lt;code&gt;erl_parse&lt;/code&gt; module cannot represent these things (normally, they are expanded by the Erlang preprocessor &lt;code&gt;epp(3)&lt;/code&gt; before the parser sees them), an extended syntax tree is created, using the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">只要在语法上&amp;ldquo;表现良好&amp;rdquo;，此模块就可以在不扩展预处理器指令和宏应用程序的情况下标记和解析大多数Erlang源代码。因为 &lt;code&gt;erl_parse&lt;/code&gt; 模块的普通语法树无法表示这些东西（通常，它们在解析器看到它们之前由Erlang预处理程序 &lt;code&gt;epp(3)&lt;/code&gt; 进行了扩展），所以使用 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 模块创建了扩展语法树。</target>
        </trans-unit>
        <trans-unit id="5da9ff3bf77e5f995d90689278c7a23b1597c8bb" translate="yes" xml:space="preserve">
          <source>This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on.</source>
          <target state="translated">这个模块使用的是当前键。它的工作原理和当前目录很像。从当前键中,可以获取值,可以列出子键,等等。</target>
        </trans-unit>
        <trans-unit id="ba20fa4df70d15689e43b0f44c7517efe1b08358" translate="yes" xml:space="preserve">
          <source>This module uses application &lt;code&gt;SSH&lt;/code&gt;, which provides detailed information about, for example, functions, types, and options.</source>
          <target state="translated">该模块使用应用程序 &lt;code&gt;SSH&lt;/code&gt; ，该应用程序提供有关例如功能，类型和选项的详细信息。</target>
        </trans-unit>
        <trans-unit id="c27440a34997ba37bea9913114676bb50554dcae" translate="yes" xml:space="preserve">
          <source>This module was written for one-to-many style sockets (type &lt;code&gt;seqpacket&lt;/code&gt;). With the addition of &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt;, one-to-one style sockets (type &lt;code&gt;stream&lt;/code&gt;) were introduced.</source>
          <target state="translated">该模块是为一对多样式套接字（类型 &lt;code&gt;seqpacket&lt;/code&gt; ）编写的。加上 &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt; ，引入了一对一样式的套接字（类型 &lt;code&gt;stream&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="606223ff437db337a77e6be8dc6a090de4bc5931" translate="yes" xml:space="preserve">
          <source>This modules contains the interface to the &lt;code&gt;heart&lt;/code&gt; process. &lt;code&gt;heart&lt;/code&gt; sends periodic heartbeats to an external port program, which is also named &lt;code&gt;heart&lt;/code&gt;. The purpose of the &lt;code&gt;heart&lt;/code&gt; port program is to check that the Erlang runtime system it is supervising is still running. If the port program has not received any heartbeats within &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds (defaults to 60 seconds), the system can be rebooted.</source>
          <target state="translated">该模块包含 &lt;code&gt;heart&lt;/code&gt; 过程的接口。 &lt;code&gt;heart&lt;/code&gt; 会定期向外部端口程序发送心跳，该程序也称为 &lt;code&gt;heart&lt;/code&gt; 。 &lt;code&gt;heart&lt;/code&gt; 程序的目的是检查它所监视的Erlang运行时系统是否仍在运行。如果端口程序在 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 秒（默认为60秒）内未收到任何心跳，则可以重新引导系统。</target>
        </trans-unit>
        <trans-unit id="a2f8a20f0be71ce686a1d45af49ce482f6a78d69" translate="yes" xml:space="preserve">
          <source>This must however be done with care, as function &lt;code&gt;{return_trace}&lt;/code&gt; in the match specification destroys tail recursiveness.</source>
          <target state="translated">但是，这必须谨慎进行，因为比赛规范中的函数 &lt;code&gt;{return_trace}&lt;/code&gt; 会破坏尾部递归性。</target>
        </trans-unit>
        <trans-unit id="68582ac86e79db46d57ee06207c511b4a861bfb5" translate="yes" xml:space="preserve">
          <source>This node uses some master nodes to store and fetch release information. All master nodes must be operational whenever release information is written by this node.</source>
          <target state="translated">该节点使用一些主节点来存储和获取发布信息。每当本节点写入发布信息时,所有的主节点都必须运行。</target>
        </trans-unit>
        <trans-unit id="e2b52bf50e58c3cc457e61abee1b9f82215c9813" translate="yes" xml:space="preserve">
          <source>This node.</source>
          <target state="translated">这个节点。</target>
        </trans-unit>
        <trans-unit id="768833241e4c41a51c30053841c9a5be0a33a799" translate="yes" xml:space="preserve">
          <source>This now works as expected:</source>
          <target state="translated">现在可以按预期工作了。</target>
        </trans-unit>
        <trans-unit id="4858903cb179e40729be5206f937b3196b299dba" translate="yes" xml:space="preserve">
          <source>This of course requires your editor to support UTF-8 as well. The same comment is also interpreted by functions like &lt;code&gt;file:consult/1&lt;/code&gt;, the release handler, and so on, so that you can have all text files in your source directories in UTF-8 encoding.</source>
          <target state="translated">当然，这需要您的编辑器也支持UTF-8。相同的注释也由诸如 &lt;code&gt;file:consult/1&lt;/code&gt; ，发行处理程序之类的函数解释，以便您可以将源目录中的所有文本文件都以UTF-8编码进行处理。</target>
        </trans-unit>
        <trans-unit id="dfffe74a9c7d9d5e838ee7506a86798e8b02c78d" translate="yes" xml:space="preserve">
          <source>This off-line utility function can be used to convert the old snmp application config (pre snmp-4.0) to the new snmp agent config (as of snmp-4.0).</source>
          <target state="translated">这个离线实用功能可以用来将旧的snmp应用程序配置(snmp-4.0之前)转换为新的snmp代理配置(从snmp-4.0开始)。</target>
        </trans-unit>
        <trans-unit id="bb2b5100380724d761bb0b871c669f6341e1d19e" translate="yes" xml:space="preserve">
          <source>This only applies if Erlang is started as a distributed node, i.e. if &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is specified. Otherwise, epmd is not started even if &lt;code&gt;-start_epmd true&lt;/code&gt; is given.</source>
          <target state="translated">仅当Erlang作为分布式节点启动时才适用，即，如果指定 &lt;code&gt;-name&lt;/code&gt; 或 &lt;code&gt;-sname&lt;/code&gt; 。否则，即使给定 &lt;code&gt;-start_epmd true&lt;/code&gt; ，也不会启动epmd。</target>
        </trans-unit>
        <trans-unit id="36578cd782b1b1c7c098e80e28d83efcfb473d12" translate="yes" xml:space="preserve">
          <source>This operation is best described with an example.</source>
          <target state="translated">这个操作最好用一个例子来说明。</target>
        </trans-unit>
        <trans-unit id="726740b93f9a38ad69503060d61e78fcfc4ed2e8" translate="yes" xml:space="preserve">
          <source>This operation returns both configuration and state data from the server.</source>
          <target state="translated">该操作同时返回服务器的配置和状态数据。</target>
        </trans-unit>
        <trans-unit id="c28d8949e39a67d4d2b916902211267c2c1b4e17" translate="yes" xml:space="preserve">
          <source>This option and option &lt;code&gt;match_limit&lt;/code&gt; are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</source>
          <target state="translated">此选项和选项 &lt;code&gt;match_limit&lt;/code&gt; 仅在极少数情况下使用。建议在篡改这些限制之前先了解PCRE库的内部。</target>
        </trans-unit>
        <trans-unit id="6f9af6a987f2d3bf6639d97909039e3b4c47dc6a" translate="yes" xml:space="preserve">
          <source>This option augments the host name extraction from URIs and other Reference IDs. It could for example be a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of:</source>
          <target state="translated">这个选项增强了从URI和其他参考ID中提取主机名的功能。例如,它可以是一个非常特殊的、没有标准化的URI。这个选项将一个Reference ID作为参数,并返回以下参数之一:1:</target>
        </trans-unit>
        <trans-unit id="21da80d80de6786a8c35eb55211f1719f7ad6a3e" translate="yes" xml:space="preserve">
          <source>This option can also be used to override the default renaming of calls which use obsolete function names.</source>
          <target state="translated">这个选项也可以用来覆盖使用过时函数名的调用的默认重命名。</target>
        </trans-unit>
        <trans-unit id="cdb004a99221b3f8badd722205d40d87fd8410dc" translate="yes" xml:space="preserve">
          <source>This option can be used for adding members to a distributed disk log. Defaults to &lt;code&gt;[]&lt;/code&gt;, which means that the log is local on the current node.</source>
          <target state="translated">此选项可用于将成员添加到分布式磁盘日志中。默认为 &lt;code&gt;[]&lt;/code&gt; ，这意味着日志在当前节点上是本地的。</target>
        </trans-unit>
        <trans-unit id="23765e948e554b57ee502bc4f444d5a5c23a77a3" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon execute exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case but in the error case.</source>
          <target state="translated">这个选项改变了守护进程执行来自客户端的exec-request的方式。如果返回值中的术语是非字符串类型,则会被格式化为字符串。在ok-case中不加尾部的换行,但在错误的情况下会加。</target>
        </trans-unit>
        <trans-unit id="53106c8ee8480a565ca1694a5aee9779aed8d667" translate="yes" xml:space="preserve">
          <source>This option changes the representation of the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; to use maps (instead of records). This option also suppresses the generation of &lt;code&gt;.hrl&lt;/code&gt; files.</source>
          <target state="translated">此选项将 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 类型的表示形式更改为使用映射（而不是记录）。此选项还禁止生成 &lt;code&gt;.hrl&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="91dab051c90259277cd95566eff3cf880c2a9995" translate="yes" xml:space="preserve">
          <source>This option controls the debug level of &lt;code&gt;wx&lt;/code&gt;. As its name indicates it is only useful for debugging. See &lt;code&gt;wx:debug/1&lt;/code&gt; for more info.</source>
          <target state="translated">此选项控制 &lt;code&gt;wx&lt;/code&gt; 的调试级别。顾名思义，它仅对调试有用。有关更多信息，请参见 &lt;code&gt;wx:debug/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec5e0644c323d96923ea009ec73a058e3e14790" translate="yes" xml:space="preserve">
          <source>This option controls the error handling behavior of Reltool. By default the window processes traps exit, but this behavior can altered by setting &lt;code&gt;trap_exit&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此选项控制Reltool的错误处理行为。默认情况下，窗口进程陷阱退出，但是可以通过将 &lt;code&gt;trap_exit&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 来改变此行为。</target>
        </trans-unit>
        <trans-unit id="c7e73575c5bb05401f153a1b408d8ff447357a91" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;true&lt;/code&gt; for backwards compatibility but we intend to remove the exception behavior in a future release. New code that needs to handle dictionaries manually should always specify &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，此选项默认为 &lt;code&gt;true&lt;/code&gt; ，但是我们打算在以后的版本中删除异常行为。需要手动处理字典的新代码应始终指定 &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24e5307f642c6711e98aa1e1851a0012231dc221" translate="yes" xml:space="preserve">
          <source>This option defines how the manager will handle the sending of response (acknowledgment) to received inform-requests.</source>
          <target state="translated">这个选项定义了管理者如何处理对收到的信息请求的响应(确认)发送。</target>
        </trans-unit>
        <trans-unit id="0b065ec1d28b81abfd2469427265be5e95f2a102" translate="yes" xml:space="preserve">
          <source>This option determines which &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; are to be received (through &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;) along with the data. The only exception is &lt;code&gt;data_io_event&lt;/code&gt;, which enables or disables receiving of &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; ancillary data, not events. By default, all flags except &lt;code&gt;adaptation_layer_event&lt;/code&gt; are enabled, although &lt;code&gt;sctp_data_io_event&lt;/code&gt; and &lt;code&gt;association_event&lt;/code&gt; are used by the driver itself and not exported to the user level.</source>
          <target state="translated">此选项确定要通过数据接收哪些 &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; （通过 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; ）。唯一的例外是 &lt;code&gt;data_io_event&lt;/code&gt; ，它启用或禁用 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 辅助数据而非事件的接收。默认情况下，尽管 &lt;code&gt;sctp_data_io_event&lt;/code&gt; 和 &lt;code&gt;association_event&lt;/code&gt; 由驱动程序本身使用，并且未导出到用户级别，但启用了 &lt;code&gt;adaptation_layer_event&lt;/code&gt; 以外的所有标志。</target>
        </trans-unit>
        <trans-unit id="1f54c1964a5e915a3b9d8124e81def1141091a66" translate="yes" xml:space="preserve">
          <source>This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. &lt;code&gt;run/3&lt;/code&gt; always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</source>
          <target state="translated">就&amp;ldquo;长期运行的BIF&amp;rdquo;而言，此选项绝不会影响Erlang VM的执行。 &lt;code&gt;run/3&lt;/code&gt; 始终以一定的时间间隔将控制权交还给Erlang进程的调度程序，以确保Erlang系统的实时属性。</target>
        </trans-unit>
        <trans-unit id="6af47b199e89cf536046513882864286cab54688" translate="yes" xml:space="preserve">
          <source>This option does not guarantee exclusiveness on file systems not supporting &lt;code&gt;O_EXCL&lt;/code&gt; properly, such as NFS. Do not depend on this option unless you know that the file system supports it (in general, local file systems are safe).</source>
          <target state="translated">此选项不能保证在不正确支持 &lt;code&gt;O_EXCL&lt;/code&gt; 的文件系统（例如NFS）上的排他性。除非您知道文件系统支持此选项，否则不要依赖此选项（通常，本地文件系统是安全的）。</target>
        </trans-unit>
        <trans-unit id="170942e99acf8590a0f93f95af96a97ad9b43a74" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="translated">此选项指导 &lt;code&gt;connect&lt;/code&gt; 功能如何在所连接的服务器提供客户端之前从未见过的主机密钥时如何操作。默认设置是在stdio上向用户询问是否接受或拒绝新的主机密钥。请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; ,以指定记录以前接受的主机密钥的文件 &lt;code&gt;known_hosts&lt;/code&gt; 的路径。另请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 以了解处理密钥的一般方法。</target>
        </trans-unit>
        <trans-unit id="9f681818b307476626695654e1f4af8954537ac9" translate="yes" xml:space="preserve">
          <source>This option implies option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">此选项暗含选项 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b7df27500f11cd0120772f370d99f496bc69623" translate="yes" xml:space="preserve">
          <source>This option indicates weather the request should be resent until the reply is received, &lt;strong&gt;even&lt;/strong&gt; though a pending message has been received.</source>
          <target state="translated">此选项指示&lt;strong&gt;即使&lt;/strong&gt;已收到未决消息，&lt;strong&gt;也&lt;/strong&gt;应重新发送请求，直到收到答复为止。</target>
        </trans-unit>
        <trans-unit id="6ee2dcf0c6730f63f33d0e9b597dde90cc7553c6" translate="yes" xml:space="preserve">
          <source>This option indicates weather the transport module should be told if a message send is a resend or not.</source>
          <target state="translated">这个选项表示是否应该告诉传输模块发送的消息是否为重发。</target>
        </trans-unit>
        <trans-unit id="f41d25f928d777038d78ec54aa87e0b2645ebe41" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; (in either order) results in 2 scheduler threads (50% of 4) and 1 scheduler thread online (25% of 4).</source>
          <target state="translated">此选项与 &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; 设置交互。例如，在配置了8个逻辑核心和8个可用逻辑核心的系统上，选项 &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; （以任意顺序）的组合产生2个调度程序线程（4个的50％）和1个在线调度程序线程（占25％）。</target>
        </trans-unit>
        <trans-unit id="f69d8c25bc614477e7fde4538f00fb8866b22040" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; (in either order) results in 2 dirty CPU scheduler threads (50% of 4) and 1 dirty CPU scheduler thread online (25% of 4).</source>
          <target state="translated">此选项与 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 设置交互。例如，在配置了8个逻辑核心和8个可用逻辑核心的系统上，选项 &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; （以任意顺序）的组合会导致2个脏CPU调度程序线程（4个的50％）和1个肮脏的CPU调度程序线程联机（占25％）。</target>
        </trans-unit>
        <trans-unit id="1b1652a93096a292ea9f23a8fb30440e0918cbec" translate="yes" xml:space="preserve">
          <source>This option is a fast way to test whether a module will compile successfully. This is useful for code generators that want to verify the code that they emit. No code is generated. If warnings are enabled, warnings generated by the &lt;code&gt;erl_lint&lt;/code&gt; module (such as warnings for unused variables and functions) are also returned.</source>
          <target state="translated">此选项是测试模块是否将成功编译的快速方法。这对于想要验证其发出的代码的代码生成器很有用。没有代码生成。如果启用了警告，则还会返回 &lt;code&gt;erl_lint&lt;/code&gt; 模块生成的警告（例如，未使用的变量和函数的警告）。</target>
        </trans-unit>
        <trans-unit id="0bc4c98f53e89f54019044a7876ab12f92896246" translate="yes" xml:space="preserve">
          <source>This option is experimental.</source>
          <target state="translated">这个选项是试验性的。</target>
        </trans-unit>
        <trans-unit id="bebef7a4d11a54b9572f9f20a10693f30204b1e4" translate="yes" xml:space="preserve">
          <source>This option is highly recommended. It makes &lt;code&gt;run_erl&lt;/code&gt; run in the background completely detached from any controlling terminal and the command returns to the caller immediately. Without this option, &lt;code&gt;run_erl&lt;/code&gt; must be started using several tricks in the shell to detach it completely from the terminal in use when starting it. The option must be the first argument to &lt;code&gt;run_erl&lt;/code&gt; on the command line.</source>
          <target state="translated">强烈建议使用此选项。它使 &lt;code&gt;run_erl&lt;/code&gt; 在后台运行，与任何控制终端完全脱离，命令立即返回到调用者。如果没有此选项， &lt;code&gt;run_erl&lt;/code&gt; 必须在外壳中使用几个技巧来启动run_erl，以便在启动时将其与正在使用的终端完全分离。该选项必须是命令行上 &lt;code&gt;run_erl&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="799c0d875ea63318c2c432ae65671fb00f9b1962" translate="yes" xml:space="preserve">
          <source>This option is more useful. Here, reloading is queued if the driver is &lt;strong&gt;not&lt;/strong&gt; loaded by any other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, but the driver has opened ports, in which case &lt;code&gt;{ok, pending_driver}&lt;/code&gt; is returned (a &lt;code&gt;monitor&lt;/code&gt; option is recommended).</source>
          <target state="translated">此选项更有用。在此，如果驱动程序&lt;strong&gt;未&lt;/strong&gt;由任何其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 加载，但驱动程序已打开端口，则重新加载将排队，在这种情况下 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 将返回{ok，ending_driver}（建议使用 &lt;code&gt;monitor&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="25d785f39f2ca30f9744131492e2e56cf2d21d95" translate="yes" xml:space="preserve">
          <source>This option is not allowed on &lt;code&gt;raw&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 文件上不允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="2f286491eda734e921e24014e8a8a1eb9199ffbe" translate="yes" xml:space="preserve">
          <source>This option is not recommended.</source>
          <target state="translated">不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="f578117bb772460a22238ad9cfabbec82d626246" translate="yes" xml:space="preserve">
          <source>This option is only meaningful if option &lt;code&gt;binary&lt;/code&gt; was specified when the socket was created. If option &lt;code&gt;header&lt;/code&gt; is specified, the first &lt;code&gt;Size&lt;/code&gt; number bytes of data received from the socket are elements of a list, and the remaining data is a binary specified as the tail of the same list. For example, if &lt;code&gt;Size == 2&lt;/code&gt;, the data received matches &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt;.</source>
          <target state="translated">仅当创建套接字时指定了 &lt;code&gt;binary&lt;/code&gt; 选项时，此选项才有意义。如果指定了选项 &lt;code&gt;header&lt;/code&gt; ，则从套接字接收的数据的第一个 &lt;code&gt;Size&lt;/code&gt; Number字节是列表的元素，其余数据是指定为同一列表尾部的二进制文件。例如，如果 &lt;code&gt;Size == 2&lt;/code&gt; ，则接收到的数据与 &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6aa3b24e42c5627fceb7d3a4c574f35704adb386" translate="yes" xml:space="preserve">
          <source>This option is only supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;).</source>
          <target state="translated">仅标准外壳程序（ &lt;code&gt;group.erl&lt;/code&gt; ）支持此选项。</target>
        </trans-unit>
        <trans-unit id="b072703d1b18dfc3f9f5977b6079b835f0224f83" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the parameters specific to the peer address specified by &lt;code&gt;address&lt;/code&gt; within the association specified by &lt;code&gt;assoc_id&lt;/code&gt;. Field &lt;code&gt;address&lt;/code&gt; fmust be set by the caller; all other fields are filled in on return. If &lt;code&gt;assoc_id = 0&lt;/code&gt; (default), the &lt;code&gt;address&lt;/code&gt; is automatically translated into the corresponding association ID. This option is rarely used. For the semantics of all fields, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此选项是只读的。它确定参数专用于由指定的网络节点地址 &lt;code&gt;address&lt;/code&gt; 所指定的关联内 &lt;code&gt;assoc_id&lt;/code&gt; 。现场 &lt;code&gt;address&lt;/code&gt; 必须由调用方设置；所有其他字段均在返回时填写。如果 &lt;code&gt;assoc_id = 0&lt;/code&gt; （默认值），该 &lt;code&gt;address&lt;/code&gt; 将自动转换为相应的关联ID。此选项很少使用。有关所有字段的语义，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195222e570592e1300b4b25ab1af9e1c8e8e90bb" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the status of the SCTP association specified by &lt;code&gt;assoc_id&lt;/code&gt;. The following are the possible values of &lt;code&gt;state&lt;/code&gt; (the state designations are mostly self-explanatory):</source>
          <target state="translated">此选项是只读的。它确定由 &lt;code&gt;assoc_id&lt;/code&gt; 指定的SCTP关联的状态。以下是 &lt;code&gt;state&lt;/code&gt; 的可能值（状态名称大多是不言而喻的）：</target>
        </trans-unit>
        <trans-unit id="2a7c2f54502986cac56e74f74f0507e617134fa9" translate="yes" xml:space="preserve">
          <source>This option is removed, it generates a fatal error if used.</source>
          <target state="translated">此选项已被删除,如果使用会产生致命的错误。</target>
        </trans-unit>
        <trans-unit id="0d0dc8c0d9bb7eab4181aa210080e8a3266e279c" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">默认情况下，此选项设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b0aa3e98f799062b3c35a4a811d03b341b1e599" translate="yes" xml:space="preserve">
          <source>This option is supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;), the 'oldshell' (&lt;code&gt;user.erl&lt;/code&gt;), and the file I/O servers.</source>
          <target state="translated">标准外壳程序（ &lt;code&gt;group.erl&lt;/code&gt; ），&amp;ldquo;旧外壳程序&amp;rdquo;（ &lt;code&gt;user.erl&lt;/code&gt; ）和文件I / O服务器均支持此选项。</target>
        </trans-unit>
        <trans-unit id="b3a3a12611755048747534c6172534fba6193da6" translate="yes" xml:space="preserve">
          <source>This option is to be used only while running &lt;code&gt;erts_alloc_config(3)&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt; when using the created configuration.</source>
          <target state="translated">此选项仅在运行 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 时使用，&lt;strong&gt;而&lt;/strong&gt;在使用创建的配置时&lt;strong&gt;不可&lt;/strong&gt;用。</target>
        </trans-unit>
        <trans-unit id="889aee4f7fdaed4924ebd813f97d33cc589d7043" translate="yes" xml:space="preserve">
          <source>This option is typically used when building or modifying a PLT as in:</source>
          <target state="translated">该选项通常在构建或修改PLT时使用,如:。</target>
        </trans-unit>
        <trans-unit id="edf2a03815bd1d16fe28550db84f5fb84528060e" translate="yes" xml:space="preserve">
          <source>This option is used to &lt;strong&gt;reload&lt;/strong&gt; a driver from disk, most often in a code upgrade scenario. Having a &lt;code&gt;reload&lt;/code&gt; option also implies that parameter &lt;code&gt;Path&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; need to be consistent with earlier loads of the driver.</source>
          <target state="translated">此选项通常在代码升级方案中用于从磁盘&lt;strong&gt;重新加载&lt;/strong&gt;驱动程序。有一个 &lt;code&gt;reload&lt;/code&gt; 选项也意味着参数 &lt;code&gt;Path&lt;/code&gt; 并&lt;strong&gt;没有&lt;/strong&gt;需要与驱动程序的早期负荷相一致。</target>
        </trans-unit>
        <trans-unit id="d51f4b2d1bb2d48353207aa92dd60bc3873e9f8f" translate="yes" xml:space="preserve">
          <source>This option should be set to &lt;code&gt;false&lt;/code&gt; since a sufficiently malicious peer can otherwise cause large amounts of memory to be consumed when decoded Diameter messages are passed between processes. The default value is for backwards compatibility.</source>
          <target state="translated">此选项应设置为 &lt;code&gt;false&lt;/code&gt; ,因为当在进程之间传递解码的Diameter消息时，足够恶意的对等方可能导致消耗大量内存。默认值为向后兼容。</target>
        </trans-unit>
        <trans-unit id="57817b80cdc930329e3a4d5793e370393a3211f0" translate="yes" xml:space="preserve">
          <source>This option specifies how basic mib data is stored. This option is used by two parts of the snmp agent: The mib-server and the symbolic-store.</source>
          <target state="translated">这个选项指定了基本mib数据的存储方式。这个选项被snmp代理的两个部分使用。mib服务器和符号存储。</target>
        </trans-unit>
        <trans-unit id="ff5c27e867a6f1798699a8d8412847ef2c9f83ca" translate="yes" xml:space="preserve">
          <source>This option specifies if the user shall be notified of received segment replies or not.</source>
          <target state="translated">这个选项指定了是否要将收到的分段回复通知用户。</target>
        </trans-unit>
        <trans-unit id="e191bd75bc4b33a8992d72798fec2d5cb030668d" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific socket option &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt;, such as in Linux kernel 2.0.30 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">此选项使用特定于Linux的套接字选项 &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt; ，例如在Linux内核2.0.30或更高版本中，因此仅在针对此类操作系统编译运行时系统时才存在。</target>
        </trans-unit>
        <trans-unit id="2b531690e0f1058c69b2d245e35526e30090198c" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific syscall &lt;code&gt;setns()&lt;/code&gt;, such as in Linux kernel 3.0 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">此选项使用特定于Linux的syscall &lt;code&gt;setns()&lt;/code&gt; （例如在Linux内核3.0或更高版本中），因此仅在针对此类操作系统编译运行时系统时才存在。</target>
        </trans-unit>
        <trans-unit id="44252bdcc3d79897b51179b686a1c2db9495ee64" translate="yes" xml:space="preserve">
          <source>This option will be removed in a future release. The return value will always be &lt;code&gt;false&lt;/code&gt;, as the &lt;code&gt;elib_malloc&lt;/code&gt; allocator has been removed.</source>
          <target state="translated">此选项将在以后的版本中删除。返回值将始终为 &lt;code&gt;false&lt;/code&gt; ，因为 &lt;code&gt;elib_malloc&lt;/code&gt; 分配器已被删除。</target>
        </trans-unit>
        <trans-unit id="c0dabdcd13ff03271c7b6e7a946847dbd231dc01" translate="yes" xml:space="preserve">
          <source>This option will use a lot of memory when enabled, which must be reclaimed with &lt;code&gt;lcnt:rt_clear&lt;/code&gt;. Note that it makes no distinction between locks that were destroyed and locks for which counting was disabled, so enabling this option will disable changes to the lock category mask.</source>
          <target state="translated">启用此选项将占用大量内存，必须使用 &lt;code&gt;lcnt:rt_clear&lt;/code&gt; 进行回收。请注意，它在已销毁的锁和禁用计数的锁之间没有区别，因此启用此选项将禁用对锁类别掩码的更改。</target>
        </trans-unit>
        <trans-unit id="63372d9f26162432c70de9dd21cb0a2fa14e443c" translate="yes" xml:space="preserve">
          <source>This package contains modules for handling abstract syntax trees (ASTs) in Erlang, in a way that is compatible with the &quot;abstract format&quot; parse trees of the stdlib module &lt;code&gt;erl_parse&lt;/code&gt;, together with utilities for reading source files, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt;, and doing &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; in Erlang.</source>
          <target state="translated">此软件包包含用于处理Erlang中的抽象语法树（AST）的模块，该模块与stdlib模块 &lt;code&gt;erl_parse&lt;/code&gt; 的&amp;ldquo;抽象格式&amp;rdquo;解析树兼容，并且具有读取源文件的实用工具， &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt; ，并在Erlang中进行 &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa90d46e1988deecd458f84f25660e5efaeb6ec" translate="yes" xml:space="preserve">
          <source>This page presents a summary of values from all allocators underneath it.</source>
          <target state="translated">本页呈现的是其下所有分配器的数值汇总。</target>
        </trans-unit>
        <trans-unit id="239f6919f70832c0fd44ac0346db01f8572c3052" translate="yes" xml:space="preserve">
          <source>This pair of functions are used when open ports to the driver are to be killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; to allow for new driver code to get loaded.</source>
          <target state="translated">当使用 &lt;code&gt;driver_unloaded&lt;/code&gt; 原因终止驱动程序的开放端口以允许加载新的驱动程序代码时，将使用此功能对。</target>
        </trans-unit>
        <trans-unit id="1602bf3b2d8c23237b0a61febcf52e3e006d8036" translate="yes" xml:space="preserve">
          <source>This pair of functions is used when reloading is to be done after the last open port to the driver is closed.</source>
          <target state="translated">这对函数是在最后一个打开的驱动端口关闭后进行重装时使用的。</target>
        </trans-unit>
        <trans-unit id="f14b771e39c5dc99621a28cd9cae451233b4cbb8" translate="yes" xml:space="preserve">
          <source>This parameter contains a list of options that are given to &lt;code&gt;zip:create/3&lt;/code&gt; when application specific files are packaged into an archive. Only a subset of the options are supported. The most useful options in this context are the ones that control which types of files should be compressed. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">当将特定于应用程序的文件打包到归档文件中时，此参数包含 &lt;code&gt;zip:create/3&lt;/code&gt; 的选项列表。仅支持选项的子集。在这种情况下，最有用的选项是控制应压缩哪种类型的文件的选项。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e5c112e068eb199424c98749e9d0931666cadb" translate="yes" xml:space="preserve">
          <source>This parameter controls the application and escript inclusion policy. It defaults to &lt;code&gt;derived&lt;/code&gt; which means that the applications that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting, will only be included if any other (explicitly or implicitly included) application uses it. The value &lt;code&gt;include&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be included. &lt;code&gt;exclude&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be excluded.</source>
          <target state="translated">此参数控制应用程序和脚本包含策略。它默认为 &lt;code&gt;derived&lt;/code&gt; ，这意味着没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序仅在任何其他（显式或隐式包含）应用程序使用它的情况下才包括在内。该值 &lt;code&gt;include&lt;/code&gt; 表示将包括所有没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序和脚本。 &lt;code&gt;exclude&lt;/code&gt; 表示将排除所有没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序和脚本。</target>
        </trans-unit>
        <trans-unit id="43b8b48e3d3e4e5f584a2110e61fc94f1dda52fb" translate="yes" xml:space="preserve">
          <source>This parameter controls the default handling of the &lt;code&gt;app&lt;/code&gt; files when a target system is generated. It defaults to &lt;code&gt;keep&lt;/code&gt; which means that &lt;code&gt;app&lt;/code&gt; files are copied to the target system and their contents are kept as they are. &lt;code&gt;strip&lt;/code&gt; means that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file where the non included modules are removed from the file. &lt;code&gt;all&lt;/code&gt; does also imply that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file, with the difference that all included modules are added to the file. If the application does not have any &lt;code&gt;app&lt;/code&gt; file a file will be created for &lt;code&gt;all&lt;/code&gt; but not for &lt;code&gt;keep&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;.</source>
          <target state="translated">生成目标系统时，此参数控制 &lt;code&gt;app&lt;/code&gt; 文件的默认处理。默认设置为 &lt;code&gt;keep&lt;/code&gt; ，这意味着将 &lt;code&gt;app&lt;/code&gt; 文件复制到目标系统，并将其内容保持原样。 &lt;code&gt;strip&lt;/code&gt; 表示从原始 &lt;code&gt;app&lt;/code&gt; 文件的内容生成了一个新的 &lt;code&gt;app&lt;/code&gt; 程序文件，其中未包含的模块已从文件中删除。 &lt;code&gt;all&lt;/code&gt; 均表示从原始 &lt;code&gt;app&lt;/code&gt; 文件的内容生成了一个新的 &lt;code&gt;app&lt;/code&gt; 程序文件，不同之处在于所有包含的模块均已添加到该文件中。如果该应用程序没有任何 &lt;code&gt;app&lt;/code&gt; 将为 &lt;code&gt;all&lt;/code&gt; 文件创建文件，但不会为 &lt;code&gt;keep&lt;/code&gt; 和 &lt;code&gt;strip&lt;/code&gt; 创建文件。</target>
        </trans-unit>
        <trans-unit id="178517341ccd2e5776c2cccf896941a880130c85" translate="yes" xml:space="preserve">
          <source>This parameter controls the module inclusion policy. It defaults to &lt;code&gt;all&lt;/code&gt; which means that if an application is included (either explicitly or implicitly) all modules in that application will be included. This implies that both modules that exist in the &lt;code&gt;ebin&lt;/code&gt; directory of the application, as well as modules that are named in the &lt;code&gt;app&lt;/code&gt; file will be included. If the parameter is set to &lt;code&gt;ebin&lt;/code&gt;, both modules in the &lt;code&gt;ebin&lt;/code&gt; directory and derived modules are included. If the parameter is set to &lt;code&gt;app&lt;/code&gt;, both modules in the &lt;code&gt;app&lt;/code&gt; file and derived modules are included. &lt;code&gt;derived&lt;/code&gt; means that only modules that are used by other included modules are included. The &lt;code&gt;mod_cond&lt;/code&gt; setting on system level is used as default for all applications.</source>
          <target state="translated">此参数控制模块包含策略。它默认为 &lt;code&gt;all&lt;/code&gt; ，这意味着，如果包含（显式或隐式）应用程序，则将包含该应用程序中的所有模块。这意味着将同时包含应用程序的 &lt;code&gt;ebin&lt;/code&gt; 目录中存在的两个模块以及 &lt;code&gt;app&lt;/code&gt; 文件中命名的模块。如果参数设置为 &lt;code&gt;ebin&lt;/code&gt; ，则将同时包含 &lt;code&gt;ebin&lt;/code&gt; 目录中的模块和派生模块。如果参数设置为 &lt;code&gt;app&lt;/code&gt; ，则将同时包含 &lt;code&gt;app&lt;/code&gt; 文件中的模块和派生模块。 &lt;code&gt;derived&lt;/code&gt; 表示仅包含其他随附模块使用的模块。系统级别的 &lt;code&gt;mod_cond&lt;/code&gt; 设置用作所有应用程序的默认设置。</target>
        </trans-unit>
        <trans-unit id="f35dbde0b2e6b7417fe1079d2c8cb135463fb518" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the &lt;code&gt;erl&lt;/code&gt; executable in the target system should automatically determine where it is installed or if it should use a hardcoded path to the installation. In the latter case the target system must be installed with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be used. If the system is relocatable, the file tree containing the target system can be moved to another location without re-installation. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此参数控制目标系统中的 &lt;code&gt;erl&lt;/code&gt; 可执行文件是否应自动确定其安装位置，或者是否应使用安装的硬编码路径。在后一种情况下，必须先使用 &lt;code&gt;reltool:install/2&lt;/code&gt; 来安装目标系统，然后才能使用它。如果系统可重定位，则可以将包含目标系统的文件树移动到另一个位置，而无需重新安装。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18eec3d4c813ec5a22514b8e2727f74034894ae8" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the module is included or not. By default the &lt;code&gt;mod_cond&lt;/code&gt; parameter on application and system level will be used to control whether the module is included or not. The value of &lt;code&gt;incl_cond&lt;/code&gt; overrides the module inclusion policy. &lt;code&gt;include&lt;/code&gt; implies that the module is included, while &lt;code&gt;exclude&lt;/code&gt; implies that the module is not included. &lt;code&gt;derived&lt;/code&gt; implies that the module is included if it is used by any other included module.</source>
          <target state="translated">此参数控制是否包含模块。默认情况下，应用程序和系统级别的 &lt;code&gt;mod_cond&lt;/code&gt; 参数将用于控制是否包含该模块。 &lt;code&gt;incl_cond&lt;/code&gt; 的值将覆盖模块包含策略。 &lt;code&gt;include&lt;/code&gt; 表示包含该模块，而 &lt;code&gt;exclude&lt;/code&gt; 表示不包含该模块。 &lt;code&gt;derived&lt;/code&gt; 表示如果该模块被任何其他包含的模块使用，则包含该模块。</target>
        </trans-unit>
        <trans-unit id="40145ab28fcdbc933f15879eca2c3243c28ec539" translate="yes" xml:space="preserve">
          <source>This parameter defines the error report type used when messages are sent to error logger using the default callback function. Default is &lt;code&gt;std_error&lt;/code&gt;, which means the events are handled by the standard event handler.</source>
          <target state="translated">此参数定义使用默认的回调函数将消息发送到错误记录器时使用的错误报告类型。默认值为 &lt;code&gt;std_error&lt;/code&gt; ，这意味着事件由标准事件处理程序处理。</target>
        </trans-unit>
        <trans-unit id="d8e1e13f6286b2183d8789f9f0f1c181e848b5c7" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;lib_dir&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">此参数与 &lt;code&gt;lib_dir&lt;/code&gt; 互斥。如果 &lt;code&gt;vsn&lt;/code&gt; 和 &lt;code&gt;lib_dir&lt;/code&gt; 都被省略，则将选择最新版本。</target>
        </trans-unit>
        <trans-unit id="e97c191330c9143719f39676fbf0d64a524888a9" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;vsn&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">该参数与 &lt;code&gt;vsn&lt;/code&gt; 互斥。如果 &lt;code&gt;vsn&lt;/code&gt; 和 &lt;code&gt;lib_dir&lt;/code&gt; 都被省略，则将选择最新版本。</target>
        </trans-unit>
        <trans-unit id="fccea6e9894e7980e5b72b89472e98f04ef2c3ca" translate="yes" xml:space="preserve">
          <source>This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">此参数的类型为 &lt;code&gt;dateTime&lt;/code&gt; ,并符合RFC3339。实现必须支持时区。</target>
        </trans-unit>
        <trans-unit id="950fdba8a7f8faa27a2238104e4fbd9416d168d5" translate="yes" xml:space="preserve">
          <source>This parameter is the name of the driver to be used in subsequent calls to function &lt;code&gt;erlang:open_port&lt;/code&gt; in ERTS. The name can be specified as an &lt;code&gt;iolist()&lt;/code&gt; or an &lt;code&gt;atom()&lt;/code&gt;. The name specified when loading is used to find the object file (with the help of &lt;code&gt;Path&lt;/code&gt; and the system-implied extension suffix, that is, &lt;code&gt;.so&lt;/code&gt;). The name by which the driver identifies itself must also be consistent with this &lt;code&gt;Name&lt;/code&gt; parameter, much as the module name of a Beam file much corresponds to its filename.</source>
          <target state="translated">此参数是在ERTS中对函数 &lt;code&gt;erlang:open_port&lt;/code&gt; 的后续调用中使用的驱动程序的名称。该名称可以指定为 &lt;code&gt;iolist()&lt;/code&gt; 或 &lt;code&gt;atom()&lt;/code&gt; 。加载时指定的名称用于查找目标文件（借助于 &lt;code&gt;Path&lt;/code&gt; 和系统隐含的扩展名后缀 &lt;code&gt;.so&lt;/code&gt; ）。驱动程序用来标识自身的 &lt;code&gt;Name&lt;/code&gt; 也必须与此Name参数保持一致，就像Beam文件的模块名称与其文件名非常对应一样。</target>
        </trans-unit>
        <trans-unit id="44b3acd62887c89fa3ae2ebe622fc74f4ca003b3" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_app_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制哪些特定于应用程序的文件不应包含在目标系统中。在被列入秩序，文件必须以某种过滤器匹配 &lt;code&gt;incl_app_filters&lt;/code&gt; 但不是在任何过滤 &lt;code&gt;excl_app_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f82af56ab8d93da6eddb3eddde55461bf95b47f" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files that should be included. Each file in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应包含哪些应用程序特定文件。应用程序中的每个文件必须至少匹配列出的正则表达式之一才能被包含。此外，文件可能不匹配 &lt;code&gt;excl_app_filters&lt;/code&gt; 中的任何过滤器，以便被包含。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a274c6a75bab058057d8bad1dd9c6f7fc4d783d1" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should be included. Each file in the target system must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt; in order to be included. Which application files should be included is controlled with the parameters &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应在系统中包括哪些文件。目标系统中的每个文件必须至少与列出的正则表达式之一匹配才能被包含。此外，这些文件可能不匹配 &lt;code&gt;excl_sys_filters&lt;/code&gt; 中的任何过滤器以便被包含。应使用参数 &lt;code&gt;incl_app_filters&lt;/code&gt; 和 &lt;code&gt;excl_app_filters&lt;/code&gt; 控制应包含哪些应用程序文件。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="110f1ed95034cf6ba82c260c7d3422382ccf8b06" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_sys_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制系统中的哪些文件不应包含在目标系统中。为了被包含，文件必须与 &lt;code&gt;incl_sys_filters&lt;/code&gt; 中的某些过滤器匹配，但与excl_sys_filters中的任何过滤器 &lt;code&gt;excl_sys_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff17bba9924b137232a805ed2fc26cbf5b146168" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should be included in an archive file (as opposed to being included as a regular directory outside the archive). Each top directory in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应将应用程序中的哪些顶级目录包含在存档文件中（而不是作为存档外部的常规目录包含在内）。应用程序中的每个顶级目录必须至少匹配列出的正则表达式之一才能被包含。此外，文件可能不匹配 &lt;code&gt;excl_app_filters&lt;/code&gt; 中的任何过滤器，以便被包含。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cccf208765941cdf1852be703e61e2a97e335ee" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should not be included in an archive file. In order to be included in the application archive, a top directory must match some filter in &lt;code&gt;incl_archive_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_archive_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制不应将应用程序中的哪些顶级目录包含在归档文件中。为了包含在应用程序归档中，顶层目录必须与 &lt;code&gt;incl_archive_filters&lt;/code&gt; 中的某些过滤器匹配，但与excl_archive_filters中的任何过滤器都 &lt;code&gt;excl_archive_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28343ed29b2c1e141aa76f8b0c8cab09dcd45849" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the Erlang emulator is statically installed at the client node. A node with a static emulator cannot dynamically switch to a new emulator, as the executable files are statically written into memory.</source>
          <target state="translated">这个参数指定了客户端节点是否静态安装了Erlang模拟器,静态安装的节点不能动态切换到新的模拟器,因为可执行文件是静态写入内存的。使用静态仿真器的节点不能动态切换到新的仿真器,因为可执行文件是静态写入内存的。</target>
        </trans-unit>
        <trans-unit id="d50377640826220d17a47ef2e3ec41045600adb8" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这部分是在目标节点上完成的，对于本示例，我们希望该节点作为带有 &lt;code&gt;-heart&lt;/code&gt; 选项的嵌入式系统运行，从而允许节点的自动重启。有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bac7f8bcb72cbf602859c2bbd2ca1accde6e195" translate="yes" xml:space="preserve">
          <source>This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to</source>
          <target state="translated">我们所研究的这个特殊的示例模式包含了嵌套的无限重复,因此,当将该模式应用于不匹配的字符串时,使用占有式量化符来匹配非亲属的字符串是很重要的。例如,当该模式应用于</target>
        </trans-unit>
        <trans-unit id="cafdded1913809a983e1e03ea48bb5d4d797a73a" translate="yes" xml:space="preserve">
          <source>This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split.</source>
          <target state="translated">这个特殊的组符合两个字符序列CR和LF,或者单字符LF(换行,U+000A)、VT(垂直制表符,U+000B)、FF(换行,U+000C)、CR(回车,U+000D)或NEL(下一行,U+0085)中的一个。两个字符的序列被视为一个单元,不能分割。</target>
        </trans-unit>
        <trans-unit id="a1fd9cfe743405ab50e9a660ad376f4821d6a0dd" translate="yes" xml:space="preserve">
          <source>This particular server probably does not use heap memory worth hibernating for. To gain anything from hibernation, your server would have to produce non-insignificant garbage during callback execution, for which this example server can serve as a bad example.</source>
          <target state="translated">这个特定的服务器可能没有使用值得休眠的堆内存。要想从休眠中获得任何好处,你的服务器必须在回调执行过程中产生非重要的垃圾,对此,这个例子服务器可以作为一个糟糕的例子。</target>
        </trans-unit>
        <trans-unit id="dff69f09f8373963a046e44d87eb56b39d18544d" translate="yes" xml:space="preserve">
          <source>This pattern matches &lt;code&gt;a\nb&lt;/code&gt;, as LF is no longer a newline. If more than one of them is present, the last one is used.</source>
          <target state="translated">该模式与 &lt;code&gt;a\nb&lt;/code&gt; 匹配，因为LF不再是换行符。如果存在不止一个，则使用最后一个。</target>
        </trans-unit>
        <trans-unit id="f5f3552b260ce80c8512e7857145bb94d23327e2" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="translated">当用户通过调用 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt; 最终确定时间偏移时，此阶段开始。最终确定只能执行一次。</target>
        </trans-unit>
        <trans-unit id="ac25d4a9fb597e683c9984270c084780c2dc2975" translate="yes" xml:space="preserve">
          <source>This phase starts when the runtime system starts. A preliminary time offset based on current OS system time is determined. This offset is from now on to be fixed during the whole preliminary phase.</source>
          <target state="translated">这个阶段在运行时系统启动时开始。根据当前操作系统的系统时间确定一个初步的时间偏移。从现在起,这个偏移量在整个初始阶段都是固定的。</target>
        </trans-unit>
        <trans-unit id="a659cf785f049a86d756b9c813aaeb6a80c02b1c" translate="yes" xml:space="preserve">
          <source>This port is to represent the result of an accept operation. It is created when one wants to accept from a listen socket, and it is converted to a &lt;code&gt;portTypeCommand&lt;/code&gt; when the accept succeeds.</source>
          <target state="translated">此端口代表接受操作的结果。当一个人想从监听套接字接受时创建它，当接受成功时它被转换成 &lt;code&gt;portTypeCommand&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d46acb6abe2d76532e14cb270ed2c145b67edbb" translate="yes" xml:space="preserve">
          <source>This prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures, such as process identifiers, refs, and funs), and creation of new external function references. None of those resources are garbage collected, so unchecked creation of them can exhaust available memory.</source>
          <target state="translated">这可以防止直接创建新的原子,间接创建新的原子(因为它们被嵌入到某些结构中,如进程标识符、refs和funs),以及创建新的外部函数引用。这些资源都不是垃圾回收的,所以不加控制地创建它们会耗尽可用的内存。</target>
        </trans-unit>
        <trans-unit id="161ffdf8aa7fe91e902cf0c46062cf3c8c9ce913" translate="yes" xml:space="preserve">
          <source>This problem does not exist if all nodes are Erlang nodes.</source>
          <target state="translated">如果所有节点都是Erlang节点,这个问题就不存在。</target>
        </trans-unit>
        <trans-unit id="970e9bfda49ef81fc9970f5d3a17505b795bc146" translate="yes" xml:space="preserve">
          <source>This problem is best solved by using Mnesia instead.</source>
          <target state="translated">这个问题最好用Mnesia来代替解决。</target>
        </trans-unit>
        <trans-unit id="9c05999f98fd47b44ec0f00834f055638c5316ef" translate="yes" xml:space="preserve">
          <source>This process cannot run in multiple instances on the same hardware. OS_Mon must be configured to start &lt;code&gt;os_sup&lt;/code&gt; on one node only if two or more Erlang nodes execute on the same machine.</source>
          <target state="translated">此过程无法在同一硬件上的多个实例中运行。仅当两个或多个Erlang节点在同一台计算机上执行时，才必须将OS_Mon配置为在一个节点上启动 &lt;code&gt;os_sup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb9e5caa10f9724817c37ffd6b5d433a1304dd3" translate="yes" xml:space="preserve">
          <source>This process executes &lt;code&gt;tut15:pong()&lt;/code&gt;. &lt;code&gt;Pong_PID&lt;/code&gt; is the process identity of the &quot;pong&quot; process. The function &lt;code&gt;start&lt;/code&gt; now creates another process &quot;ping&quot;:</source>
          <target state="translated">该过程执行 &lt;code&gt;tut15:pong()&lt;/code&gt; 。 &lt;code&gt;Pong_PID&lt;/code&gt; 是&amp;ldquo; pong&amp;rdquo;进程的进程标识。现在，该函数 &lt;code&gt;start&lt;/code&gt; 会创建另一个进程&amp;ldquo; ping&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="54ffc50690eb1a1de62954626b5c9e0167a4eba5" translate="yes" xml:space="preserve">
          <source>This process executes:</source>
          <target state="translated">这个过程的执行。</target>
        </trans-unit>
        <trans-unit id="327419876abc14c730314a0010b944c17b63d4fa" translate="yes" xml:space="preserve">
          <source>This program aids release handling on Windows systems. The program is to be called by the &lt;code&gt;erlsrv&lt;/code&gt; program, read up the release data file &lt;code&gt;start_erl.data&lt;/code&gt;, and start Erlang. Some options to &lt;code&gt;start_erl&lt;/code&gt; are added and removed by the release handler during upgrade with emulator restart (more specifically option &lt;code&gt;-data&lt;/code&gt;).</source>
          <target state="translated">该程序有助于Windows系统上的发行处理。该程序将由 &lt;code&gt;erlsrv&lt;/code&gt; 程序调用，读取发布数据文件 &lt;code&gt;start_erl.data&lt;/code&gt; ，然后启动Erlang。在模拟器重新启动的升级过程中，释放处理程序会添加和删除 &lt;code&gt;start_erl&lt;/code&gt; 的某些选项（更具体地说，选项 &lt;code&gt;-data&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="670a2482a63126e58239dc332359f8bc1dff0e73" translate="yes" xml:space="preserve">
          <source>This program is called when the machine is started. It can be modified or rewritten to suit a special system. By default, it must be called &lt;code&gt;start&lt;/code&gt; and reside in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. Another start program can be used, by using configuration parameter &lt;code&gt;start_prg&lt;/code&gt; in application SASL.</source>
          <target state="translated">机器启动时将调用该程序。可以对其进行修改或重写以适合特定的系统。默认情况下，它必须称为 &lt;code&gt;start&lt;/code&gt; 并驻留在 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 中。通过在应用程序SASL中使用配置参数 &lt;code&gt;start_prg&lt;/code&gt; ，可以使用另一个启动程序。</target>
        </trans-unit>
        <trans-unit id="4747c1263fbc28b515ca78f638cbd9259a9eb523" translate="yes" xml:space="preserve">
          <source>This program is distributed both in compiled form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\bin) and in source form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\src). The purpose of the source code is to ease customization of the program for local needs, such as cyclic restart detection. There is also a &quot;make&quot;-file, written for the &lt;code&gt;nmake&lt;/code&gt; program distributed with Microsoft Visual C++. This program can, however, be compiled with any Win32 C compiler (possibly with minor modifications).</source>
          <target state="translated">该程序以编译形式（在&amp;lt;Erlang根目录&amp;gt; \\ erts- &amp;lt;版本&amp;gt; \\ bin下）和源代码形式（在&amp;lt;Erlang根目录&amp;gt; \\ erts- &amp;lt;版本&amp;gt; \\ src下）分发。源代码的目的是简化针对本地需求（例如循环重启检测）的程序自定义。还有一个&amp;ldquo; make&amp;rdquo;文件，是为与Microsoft Visual C ++一起分发的 &lt;code&gt;nmake&lt;/code&gt; 程序编写的。但是，该程序可以使用任何Win32 C编译器进行编译（可能需要进行较小的修改）。</target>
        </trans-unit>
        <trans-unit id="5fbfadc49450aec422c508001aa868916550a963" translate="yes" xml:space="preserve">
          <source>This program is to set static parameters and environment variables such as &lt;code&gt;-sname Name&lt;/code&gt; and &lt;code&gt;HEART_COMMAND&lt;/code&gt; to reboot the machine.</source>
          <target state="translated">该程序用于设置静态参数和环境变量（例如 &lt;code&gt;-sname Name&lt;/code&gt; 和 &lt;code&gt;HEART_COMMAND&lt;/code&gt; )以重新引导计算机。</target>
        </trans-unit>
        <trans-unit id="c3f3c1fffec91449fdead388f394beeb915ca247" translate="yes" xml:space="preserve">
          <source>This program is used to attach to a running Erlang runtime system, started with &lt;code&gt;run_erl&lt;/code&gt;.</source>
          <target state="translated">该程序用于附加到以 &lt;code&gt;run_erl&lt;/code&gt; 开头的正在运行的Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="1f003599afc35a270db5f4b7d7b284e4c9e32aee" translate="yes" xml:space="preserve">
          <source>This program is used to start the emulator, but you will not be connected to the shell. &lt;code&gt;to_erl&lt;/code&gt; is used to connect to the Erlang shell.</source>
          <target state="translated">该程序用于启动仿真器，但您不会连接到外壳。 &lt;code&gt;to_erl&lt;/code&gt; 用于连接到Erlang shell。</target>
        </trans-unit>
        <trans-unit id="6687161d9309502a24c4f52312cb9d9b40349c81" translate="yes" xml:space="preserve">
          <source>This program starts the Erlang emulator with parameters &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; set. It reads data about where these files are located from a file named &lt;code&gt;start_erl.data&lt;/code&gt;, which is located in &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt;. Each new release introduces a new data file. This file is automatically generated by the release handler in Erlang.</source>
          <target state="translated">该程序使用参数 &lt;code&gt;-boot&lt;/code&gt; 和 &lt;code&gt;-config&lt;/code&gt; 设置启动Erlang仿真器。它从位于 &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 中的名为 &lt;code&gt;start_erl.data&lt;/code&gt; 的文件读取有关这些文件的位置的数据。每个新版本都会引入一个新的数据文件。该文件由Erlang中的发布处理程序自动生成。</target>
        </trans-unit>
        <trans-unit id="8f257f89dea065885b66a0cd478fca5389333698" translate="yes" xml:space="preserve">
          <source>This property is only valid if &lt;code&gt;auto_ack&lt;/code&gt; is true.</source>
          <target state="translated">仅当 &lt;code&gt;auto_ack&lt;/code&gt; 为true时，此属性才有效。</target>
        </trans-unit>
        <trans-unit id="5810ec17d7cb173c4fccedc7a14810f5d07c123d" translate="yes" xml:space="preserve">
          <source>This puts less load on the filesystem, but much more on the Erlang runtime system.</source>
          <target state="translated">这就减少了文件系统的负载,但却增加了Erlang运行时系统的负载。</target>
        </trans-unit>
        <trans-unit id="fe519e24650180a3fcf221d96e6f790286d56794" translate="yes" xml:space="preserve">
          <source>This query also removes duplicates but the answers are sorted. If there are many answers, temporary files are used. Notice that to get the first unique answer, all answers must be found and sorted. Both alternatives find duplicates by comparing answers, that is, if &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt; are answers found in that order, then &lt;code&gt;A2&lt;/code&gt; is a removed if &lt;code&gt;A1 == A2&lt;/code&gt;.</source>
          <target state="translated">该查询还删除重复项，但对答案进行排序。如果答案很多，则使用临时文件。请注意，要获得第一个唯一答案，必须找到所有答案并进行排序。两种选择都通过比较答案来查找重复项，也就是说，如果 &lt;code&gt;A1&lt;/code&gt; 和 &lt;code&gt;A2&lt;/code&gt; 是按该顺序找到的答案，那么如果 &lt;code&gt;A1 == A2&lt;/code&gt; ，则将 &lt;code&gt;A2&lt;/code&gt; 删除。</target>
        </trans-unit>
        <trans-unit id="c2f6bad75f3fbef13092a6a4222f43094d545fae" translate="yes" xml:space="preserve">
          <source>This query hits the feature of partially bound keys in table type &lt;code&gt;ordered_set&lt;/code&gt;, so that not the whole table needs to be searched, only the part containing keys beginning with &lt;code&gt;0&lt;/code&gt; is looked into.</source>
          <target state="translated">此查询具有表类型 &lt;code&gt;ordered_set&lt;/code&gt; 中部分绑定键的功能，因此不需要搜索整个表，只查找包含以 &lt;code&gt;0&lt;/code&gt; 开头的键的部分。</target>
        </trans-unit>
        <trans-unit id="9e6a7904ebcd7549f287cc377bc5ea8dfe7feaba" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="translated">此随机数生成器在密码学上不强。如果需要强大的加密随机数生成器，请使用 &lt;code&gt;crypto&lt;/code&gt; 模块中的功能之一，例如 &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4aeff4461a7bf1567cdb7c34105213973f7dd8" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_all&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将从 &lt;code&gt;my_all&lt;/code&gt; 应用程序读取 &lt;code&gt;logger&lt;/code&gt; 配置参数，并启动配置的处理程序。配置的内容使用与 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt; 相同的规则。</target>
        </trans-unit>
        <trans-unit id="dd05537434a4630f9db4b01dfd929c70a6829e0d" translate="yes" xml:space="preserve">
          <source>This reads the entire contents of &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; into the specified registry. After the restore, all the objects in the registry are marked as unmodified, so a later backup only affects objects that you have modified since the restore.</source>
          <target state="translated">这 &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 的全部内容读入指定的注册表。还原后，注册表中的所有对象都标记为未修改，因此以后的备份仅影响自还原以来已修改的对象。</target>
        </trans-unit>
        <trans-unit id="13a79d754831b14cd54b94d9e66117a733bf984b" translate="yes" xml:space="preserve">
          <source>This reference manual describes types generated from the types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hiearchy, which makes them kind of hard to read.</source>
          <target state="translated">本参考手册描述了根据 &lt;code&gt;gen_statem&lt;/code&gt; 源代码中的类型生成的类型，因此它们是正确的。但是，生成的描述也反映了hiearchy的类型，这使它们难以阅读。</target>
        </trans-unit>
        <trans-unit id="1c8060b97047d75217dfaa592520c89dd24db028" translate="yes" xml:space="preserve">
          <source>This renders a result similar to the following:</source>
          <target state="translated">这将产生类似于以下的结果。</target>
        </trans-unit>
        <trans-unit id="9f783544c6147fb46866ca14f57f1cf28fd64491" translate="yes" xml:space="preserve">
          <source>This request asks for a complete list of all options supported by the I/O server as well as their current values.</source>
          <target state="translated">该请求要求提供I/O服务器支持的所有选项的完整列表,以及它们的当前值。</target>
        </trans-unit>
        <trans-unit id="c9ef467065f7f3147aa63fa765e54a5cacd5c45f" translate="yes" xml:space="preserve">
          <source>This request is not really used, it is to be regarded as a debug feature.</source>
          <target state="translated">这个要求并没有真正使用,要把它当作一个调试功能。</target>
        </trans-unit>
        <trans-unit id="5ed5461b3e3a2705d00654ef7851baa95f3c5a7b" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt;net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="translated">该请求通过Erlang函数 &lt;code&gt;net_adm:names/1,2&lt;/code&gt; 使用。将打开与EPMD的TCP连接，并发送此请求。</target>
        </trans-unit>
        <trans-unit id="fa4697a836ae0380ae5f8e0e273aa79c5259e1e7" translate="yes" xml:space="preserve">
          <source>This request kills the running EPMD. It is almost never used.</source>
          <target state="translated">这个请求会杀死正在运行的EPMD。几乎从不使用。</target>
        </trans-unit>
        <trans-unit id="c37139085c2a33777870615ebb189dd29f4711b3" translate="yes" xml:space="preserve">
          <source>This results in the following record:</source>
          <target state="translated">这样就有了以下记录:</target>
        </trans-unit>
        <trans-unit id="c6a3367c426977d974ddf7ae39a973d34adfaba6" translate="yes" xml:space="preserve">
          <source>This results in the following records:</source>
          <target state="translated">由此产生了以下记录:</target>
        </trans-unit>
        <trans-unit id="4754bd22d399a2af6e9567cb4368afe4e9a97e68" translate="yes" xml:space="preserve">
          <source>This return value is valid even if option &lt;code&gt;kill_ports&lt;/code&gt; was used, as killing ports can be a process that does not complete immediately. However, the condition is in that case transient. Monitors are always useful to detect when the driver is really unloaded.</source>
          <target state="translated">即使使用选项 &lt;code&gt;kill_ports&lt;/code&gt; ，此返回值也有效，因为终止端口可能是一个不会立即完成的过程。但是，在这种情况下，条件是瞬态的。监视器对于检测何时真正卸载驱动程序总是很有用的。</target>
        </trans-unit>
        <trans-unit id="61bce59fa6b3bc349ada24ae6e1accf7342572aa" translate="yes" xml:space="preserve">
          <source>This returns the driver structure. The macro &lt;code&gt;DRIVER_INIT&lt;/code&gt; defines the only exported function. All the other functions are static, and will not be exported from the library.</source>
          <target state="translated">这将返回驱动程序结构。宏 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 定义了唯一的导出函数。所有其他功能都是静态的，不会从库中导出。</target>
        </trans-unit>
        <trans-unit id="236d4116cd1bd104778ca12a47df3dca542bc4b6" translate="yes" xml:space="preserve">
          <source>This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result.</source>
          <target state="translated">这样就省去了先取一个键值,将新的值追加到存储值列表中,然后存储结果的麻烦。</target>
        </trans-unit>
        <trans-unit id="31f5366cf36758d97de45b416b180fe5021204ef" translate="yes" xml:space="preserve">
          <source>This scenario can occur if the driver code needs replacement during operation of the Erlang emulator. Implementing driver code replacement is a little more tedious than Beam code replacement, as one driver cannot be loaded as both &quot;old&quot; and &quot;new&quot; code. All &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded.</source>
          <target state="translated">如果在Erlang仿真器的操作过程中需要替换驱动程序代码，则会发生这种情况。由于不能同时以&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;代码加载一个驱动程序，因此实现驱动程序代码替换比Beam代码替换更加乏味。必须先关闭驱动程序的所有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; （没有打开的端口），然后才能卸载旧代码和加载新代码。</target>
        </trans-unit>
        <trans-unit id="503f88b8d41295f847befbf0174f96b5e1d17d21" translate="yes" xml:space="preserve">
          <source>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called &quot;dirty operations&quot;. The use of nested transactions is also described. The following topics are included:</source>
          <target state="translated">本节还介绍了锁定功能,包括表锁和粘性锁,以及绕过事务系统以提高速度和减少开销的替代功能。这些函数被称为 &quot;脏操作&quot;。还介绍了嵌套事务的使用。包括以下主题。</target>
        </trans-unit>
        <trans-unit id="ca13c61387c20120a915aa2aba2a70b09cc77ff8" translate="yes" xml:space="preserve">
          <source>This section contains information about all loaded modules.</source>
          <target state="translated">本节包含所有加载模块的信息。</target>
        </trans-unit>
        <trans-unit id="f0afb7bdb78aa30270d4c5341a78528374ecd48c" translate="yes" xml:space="preserve">
          <source>This section contains information about all the ETS tables in the system. The following fields are of interest for each table:</source>
          <target state="translated">本节包含系统中所有ETS表的信息。以下是每个表的相关字段:</target>
        </trans-unit>
        <trans-unit id="c705a253aaab772432302fcb590c6d71895de050" translate="yes" xml:space="preserve">
          <source>This section contains information about all the timers started with the BIFs &lt;code&gt;erlang:start_timer/3&lt;/code&gt; and &lt;code&gt;erlang:send_after/3&lt;/code&gt;. The following fields exist for each timer:</source>
          <target state="translated">本节包含有关所有以 &lt;code&gt;erlang:send_after/3&lt;/code&gt; &lt;code&gt;erlang:start_timer/3&lt;/code&gt; 和erlang：send_after / 3启动的计时器的信息。每个计时器存在以下字段：</target>
        </trans-unit>
        <trans-unit id="e593d062792a79977388f9b736ca5fdb84956c5e" translate="yes" xml:space="preserve">
          <source>This section contains simple introductory examples only. For a full description of the QLC query language, see the &lt;code&gt;qlc&lt;/code&gt; manual page in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">本节仅包含简单的介绍性示例。有关QLC查询语言的完整说明，请参见 &lt;code&gt;STDLIB&lt;/code&gt; 中的 &lt;code&gt;qlc&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="388bc7f1102a9ae9f2581325e4b4730cdd3f0142" translate="yes" xml:space="preserve">
          <source>This section demonstrates how simple it is to write a basic (yet for many module testing purposes, often sufficiently complex) test suite and execute its test cases. This is not necessarily obvious when you read the remaining sections in this User's Guide.</source>
          <target state="translated">本节演示了编写一个基本的(但对于许多模块测试来说,通常是足够复杂的)测试套件并执行其测试用例是多么简单。当您阅读本用户指南的其他章节时,这一点不一定很明显。</target>
        </trans-unit>
        <trans-unit id="e57241c5a98cbdf10642d048108a7272df13ecae" translate="yes" xml:space="preserve">
          <source>This section describes a simple driver for accessing a postgres database using the libpq C client library. Postgres is used because it is free and open source. For information on postgres, see &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本节描述了使用libpq C客户端库访问postgres数据库的简单驱动程序。使用Postgres是因为它是免费的开放源代码。有关postgres的信息，请访问 &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8941b0891a6ff874af251fbb759dca478d13c6f3" translate="yes" xml:space="preserve">
          <source>This section describes examples of how to use the Public Key API. Keys and certificates used in the following sections are generated only for testing the Public Key application.</source>
          <target state="translated">本节介绍了如何使用公钥API的例子。以下各节中使用的密钥和证书仅为测试公钥应用程序而生成。</target>
        </trans-unit>
        <trans-unit id="ba0088de53a90de56e1f80e0ac3933382d74faf7" translate="yes" xml:space="preserve">
          <source>This section describes how an embedded system is started. Four programs are involved and they normally reside in the directory &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. The only exception is the &lt;code&gt;start&lt;/code&gt; program, which can be located anywhere, and is also the only program that must be modified by the user.</source>
          <target state="translated">本节介绍如何启动嵌入式系统。涉及四个程序，它们通常位于目录 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 中。唯一的例外是 &lt;code&gt;start&lt;/code&gt; 程序，该程序可以位于任何地方，也是唯一必须由用户修改的程序。</target>
        </trans-unit>
        <trans-unit id="5dffe6465a9a88971444b067aa33f3c613e2da6a" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang distribution can use TLS to get extra verification and security.</source>
          <target state="translated">本节介绍了Erlang发行版如何使用TLS来获得额外的验证和安全。</target>
        </trans-unit>
        <trans-unit id="7ba1b8e520e730aff5ce60b5891f8456502ebe16" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang runtime system is configured for IP communication. It also explains how you can configure it for your needs by a configuration file. The information is primarily intended for users with special configuration needs or problems. There is normally no need for specific settings for Erlang to function properly on a correctly IP-configured platform.</source>
          <target state="translated">本节介绍了如何为IP通信配置Erlang运行时系统。它还解释了如何通过配置文件来配置它以满足你的需求。这些信息主要是为有特殊配置需求或问题的用户准备的。一般情况下,不需要特殊的设置,Erlang就可以在一个正确配置IP的平台上正常运行。</target>
        </trans-unit>
        <trans-unit id="b9ba9d8ce48a5e18d389572e80e439e457082f15" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install Cygwin, MSYS or MSYS2.</source>
          <target state="translated">本节介绍如何在Windows上构建Erlang仿真器和OTP库。请注意，如果没有Microsoft的开发工具和/或不想安装Cygwin，MSYS或MSYS2，则Windows二进制版本仍然是首选。</target>
        </trans-unit>
        <trans-unit id="23b49078ad714b83061016b41c527ea88a0ef01c" translate="yes" xml:space="preserve">
          <source>This section describes how to build your own driver for Erlang.</source>
          <target state="translated">本节介绍如何为Erlang构建自己的驱动程序。</target>
        </trans-unit>
        <trans-unit id="9ea8a2e527669401063f6aeee8dc65aebcbab675" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative carrier protocol for the Erlang distribution. The distribution is normally carried by TCP/IP. Here is explained a method for replacing TCP/IP with another protocol.</source>
          <target state="translated">本节介绍了如何为Erlang发行版实现一个替代的承载协议。该发行版通常由TCP/IP承载。这里解释了用另一种协议替代TCP/IP的方法。</target>
        </trans-unit>
        <trans-unit id="ef9194590c5bbba89fd68a31ae7705b884e62724" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative discovery mechanism for Erlang distribution. Discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port discovery.</source>
          <target state="translated">本节介绍了如何为Erlang发行版实现另一种发现机制。通常使用DNS和Erlang Port Mapper Daemon(EPMD)进行端口发现。</target>
        </trans-unit>
        <trans-unit id="62a63b1a98e975cb1778e4a9f8ed67fec8fb504f" translate="yes" xml:space="preserve">
          <source>This section describes how to write a Net if process.</source>
          <target state="translated">本节介绍如何编写Net if进程。</target>
        </trans-unit>
        <trans-unit id="a5a2806882d6d1e2d41fb571e953fc2694d49bf3" translate="yes" xml:space="preserve">
          <source>This section describes how to write a process that complies to the OTP design principles, without using a standard behaviour. Such a process is to:</source>
          <target state="translated">本节介绍如何在不使用标准行为的情况下,编写一个符合OTP设计原则的流程。这样的流程是为了:</target>
        </trans-unit>
        <trans-unit id="db110007d4cae55a5cd2784be2448b1464cdeff4" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;Mnesia&lt;/code&gt; transaction system and the transaction properties that make &lt;code&gt;Mnesia&lt;/code&gt; a fault-tolerant, distributed Database Management System (DBMS).</source>
          <target state="translated">本节介绍使 &lt;code&gt;Mnesia&lt;/code&gt; 成为容错分布式数据库管理系统（DBMS）的 &lt;code&gt;Mnesia&lt;/code&gt; 事务处理系统和事务属性。</target>
        </trans-unit>
        <trans-unit id="145559b08f0e7daceea91964fac1205f05f73a6b" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;erl_crash.dump&lt;/code&gt; file generated upon abnormal exit of the Erlang runtime system.</source>
          <target state="translated">本节描述了在Erlang运行时系统异常退出时生成的 &lt;code&gt;erl_crash.dump&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="615a4d70bf1eb0943d565d942619e06723c44a20" translate="yes" xml:space="preserve">
          <source>This section describes the ASN.1 types including their functionality, purpose, and how values are assigned in Erlang.</source>
          <target state="translated">这一节描述了ASN.1类型,包括它们的功能、目的以及在Erlang中如何赋值。</target>
        </trans-unit>
        <trans-unit id="4973acdcae6787712641efb91993666da08e3527" translate="yes" xml:space="preserve">
          <source>This section describes the basic steps when designing a &lt;code&gt;Mnesia&lt;/code&gt; database and the programming constructs that make different solutions available to the programmer. The following topics are included:</source>
          <target state="translated">本节介绍了设计 &lt;code&gt;Mnesia&lt;/code&gt; 数据库时的基本步骤以及为程序员提供不同解决方案的编程结构。包括以下主题：</target>
        </trans-unit>
        <trans-unit id="faf94ee7a5d096d374f74f2312ed2c9e2ebd27de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol introduced in Erlang/OTP R6. This description was previously located in &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; and has more or less been copied and &quot;formatted&quot; here. It has been almost unchanged since 1999, but the handshake has not changed much since then either.</source>
          <target state="translated">本节描述了Erlang / OTP R6中引入的分发握手协议。该描述以前位于 &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; ，在此或多或少已被复制和&amp;ldquo;格式化&amp;rdquo;。自1999年以来，它几乎没有变化，但握手至今也没有太大变化。</target>
        </trans-unit>
        <trans-unit id="d76e009e16bdd01f805b9e968741d4585ed774f4" translate="yes" xml:space="preserve">
          <source>This section describes the functions available for schema management, all which return either of the following tuples:</source>
          <target state="translated">本节介绍了模式管理可用的函数,所有这些函数都返回以下图元组中的任何一个。</target>
        </trans-unit>
        <trans-unit id="6589e4219f2138e744e1d40f56f69ff33d9cd04f" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net if process must be able to receive.</source>
          <target state="translated">本节描述了Net if进程必须能够接收的传入消息。</target>
        </trans-unit>
        <trans-unit id="ba803131ede9177f9bd28303113e3a91a6271ee1" translate="yes" xml:space="preserve">
          <source>This section describes the internal files that are created and maintained by the &lt;code&gt;Mnesia&lt;/code&gt; system. In particular, the workings of the &lt;code&gt;Mnesia&lt;/code&gt; log are described.</source>
          <target state="translated">本节介绍了由 &lt;code&gt;Mnesia&lt;/code&gt; 系统创建和维护的内部文件。特别是描述了 &lt;code&gt;Mnesia&lt;/code&gt; 日志的工作方式。</target>
        </trans-unit>
        <trans-unit id="16c349c9cdb2076b95c930dc72ed84bdd0fd6a91" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Solaris.</source>
          <target state="translated">本节介绍了OTP中与Solaris有关的操作系统特定部分。</target>
        </trans-unit>
        <trans-unit id="35c4d999a1922f58afda1ed0555720ff15b4c949" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Windows NT.</source>
          <target state="translated">本节介绍与Windows NT有关的OTP的操作系统特定部分。</target>
        </trans-unit>
        <trans-unit id="40285644d87303c5462b5e3de0dc15016aecc45b" translate="yes" xml:space="preserve">
          <source>This section describes the output format of the analyse command. See &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本节描述了analyze命令的输出格式。参见 &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56322ae43abba91cc149a5278e951f77e9967920" translate="yes" xml:space="preserve">
          <source>This section describes the rules for constructing binaries using the bit syntax. Unlike when constructing lists or tuples, the construction of a binary can fail with a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">本节介绍使用位语法构造二进制文件的规则。与构造列表或元组时不同，二进制文件的构造可能会因 &lt;code&gt;badarg&lt;/code&gt; 异常而失败。</target>
        </trans-unit>
        <trans-unit id="9c65c0615f3b377f5b341fdeacc78b3636ed30f2" translate="yes" xml:space="preserve">
          <source>This section describes the rules for matching binaries, using the bit syntax.</source>
          <target state="translated">本节介绍了使用位语法匹配二进制文件的规则。</target>
        </trans-unit>
        <trans-unit id="3efdb6c16651b89d1df8757e4dbe192b22b7b9d8" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">本节描述了由 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 转换的稍有不同的匹配规范。</target>
        </trans-unit>
        <trans-unit id="2b3b7f437eda66334d0b64118f5de15fc1fc7fab" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt;compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="translated">本节将Erlang程序的解析树的标准表示形式描述为Erlang术语。这种表示形式称为&lt;strong&gt;抽象格式&lt;/strong&gt;。处理此类解析树的函数为 &lt;code&gt;compile:forms/1,2&lt;/code&gt; 和以下模块中的函数：</target>
        </trans-unit>
        <trans-unit id="2174d2f040729649ef711f3e5635d25b5e2b5fd1" translate="yes" xml:space="preserve">
          <source>This section describes the use of the registry, a simple mechanism for storing key-value pairs in a C-node, as well as backing them up or restoring them from an &lt;code&gt;Mnesia&lt;/code&gt; table on an Erlang node. For more detailed information about the individual API functions, see the &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">本节介绍注册表的使用，注册表是一种简单的机制，用于在C节点中存储键值对，以及备份它们或从Erlang节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 表还原它们。有关各个API函数的更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="6e54bfa17aaa2c2d40ded61fef98685a45ccab20" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the state enter calls, so this example first branches depending on state:</source>
          <target state="translated">本节介绍使用一个 &lt;code&gt;handle_event/4&lt;/code&gt; 函数的示例更改内容。由于状态输入调用，先前使用的根据事件进行第一分支的方法在这里效果不佳，因此此示例根据状态进行第一分支：</target>
        </trans-unit>
        <trans-unit id="62fe5fd22b036a47305b864aea85d4d04ebc8617" translate="yes" xml:space="preserve">
          <source>This section illustrates procedural abstraction. Initially, the following two examples are written as conventional functions.</source>
          <target state="translated">本节说明程序抽象。最初,以下两个例子写成常规函数。</target>
        </trans-unit>
        <trans-unit id="cceb1f5cb17e39dece66daf2562fc578ef8e2eb3" translate="yes" xml:space="preserve">
          <source>This section includes examples of &lt;code&gt;.appup&lt;/code&gt; files for typical cases of upgrades/downgrades done in runtime.</source>
          <target state="translated">本节包括 &lt;code&gt;.appup&lt;/code&gt; 文件的示例，这些示例用于在运行时完成升级/降级的典型情况。</target>
        </trans-unit>
        <trans-unit id="e8307ab1487485b0ab0c191a87d10ed0db502873" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using state enter calls, which deserves a new state diagram:</source>
          <target state="translated">本节包括了大部分提到的修改后的例子,还有一些使用状态输入调用的例子,这值得一个新的状态图。</target>
        </trans-unit>
        <trans-unit id="46836c7cf8344b6ce7b90b07cbf3092bf8c64800" translate="yes" xml:space="preserve">
          <source>This section informs on interoperability, that is, information exchange, between Erlang and other programming languages. The included examples mainly treat interoperability between Erlang and C.</source>
          <target state="translated">本节介绍Erlang和其他编程语言之间的互操作性,即信息交换。本节主要介绍Erlang和C语言之间的互操作性。</target>
        </trans-unit>
        <trans-unit id="89f49f8072fe70dfd2c365690f214b5fdc461dd8" translate="yes" xml:space="preserve">
          <source>This section introduces &lt;code&gt;Mnesia&lt;/code&gt; with an example database. This example is referenced in the following sections, where the example is modified to illustrate various program constructs. This section illustrates the following mandatory procedures through examples:</source>
          <target state="translated">本节介绍 &lt;code&gt;Mnesia&lt;/code&gt; 的示例数据库。以下各节中引用了此示例，其中对示例进行了修改以说明各种程序构造。本节通过示例说明以下强制性步骤：</target>
        </trans-unit>
        <trans-unit id="4b9ffc517c7f7beea672bf3a45f0d5c54e6718e6" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt;Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="translated">本部分是快速入门教程，可帮助您开始使用Erlang。本节中的所有内容都是真实的，但只有部分真实。例如，仅显示语法的最简单形式，而不显示所有深奥形式。另外，用*手册*表示大大简化的零件。这意味着可以在《 Erlang书》或《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 找到有关该主题的更多信息。</target>
        </trans-unit>
        <trans-unit id="7681f5719ebc6c3947920d0c8b79f4d20d935db2" translate="yes" xml:space="preserve">
          <source>This section is about installing an embedded system. The following topics are considered:</source>
          <target state="translated">本节是关于安装嵌入式系统。考虑了以下主题:</target>
        </trans-unit>
        <trans-unit id="e1226c380377fda419e20eb5188c02f21ab8efb4" translate="yes" xml:space="preserve">
          <source>This section is about list functions that &lt;strong&gt;construct&lt;/strong&gt; lists. A tail-recursive function that does not construct a list runs in constant space, while the corresponding body-recursive function uses stack space proportional to the length of the list.</source>
          <target state="translated">本节关于&lt;strong&gt;构造&lt;/strong&gt;列表的列表函数。不构造列表的尾递归函数在恒定空间中运行，而相应的主体递归函数使用与列表长度成比例的堆栈空间。</target>
        </trans-unit>
        <trans-unit id="68c719f00318cfafeb4885e7d19be04a0e723344" translate="yes" xml:space="preserve">
          <source>This section is the Erlang reference manual. It describes the Erlang programming language.</source>
          <target state="translated">本节是Erlang参考手册。它描述了Erlang编程语言。</target>
        </trans-unit>
        <trans-unit id="6ef1c8ac7b879ac21c4bbd932c5c5aba836b3ebe" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;app(4)&lt;/code&gt; and &lt;code&gt;application(3)&lt;/code&gt; manual pages in Kernel.</source>
          <target state="translated">本节将与内核中的 &lt;code&gt;app(4)&lt;/code&gt; 和 &lt;code&gt;application(3)&lt;/code&gt; 手册页一起阅读。</target>
        </trans-unit>
        <trans-unit id="d050299e9360b73cf317b1cb6719eba05c8f8b67" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_event(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本部分将与STDLIB 的 &lt;code&gt;gen_event(3)&lt;/code&gt; 手册页一起阅读，在此详细描述了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="b25498b71adedf6dc2be1b461a7355670bd9865a" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in &lt;code&gt;stdlib&lt;/code&gt;, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本部分将与 &lt;code&gt;stdlib&lt;/code&gt; 中的 &lt;code&gt;gen_server(3)&lt;/code&gt; 手册页一起阅读，其中详细描述了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="e425baa0c9a68eb141d0fd0ffe5193c115033f3e" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_statem(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本节将与STDLIB 的 &lt;code&gt;gen_statem(3)&lt;/code&gt; 手册页一起阅读，在此详细介绍了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="834b2272d947ac4550fa4f7cf0a1b4b54d61e0d3" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;rel(4)&lt;/code&gt;, &lt;code&gt;systools(3)&lt;/code&gt;, and &lt;code&gt;script(4)&lt;/code&gt; manual pages in SASL.</source>
          <target state="translated">本部分将与SASL中的 &lt;code&gt;rel(4)&lt;/code&gt; ， &lt;code&gt;systools(3)&lt;/code&gt; 和 &lt;code&gt;script(4)&lt;/code&gt; 手册页一起阅读。</target>
        </trans-unit>
        <trans-unit id="d930e6096fb887dbfeb97cc96dedbb64de3c9031" translate="yes" xml:space="preserve">
          <source>This section lists a few modules and BIFs to watch out for, not only from a performance point of view.</source>
          <target state="translated">本节列出了一些需要注意的模块和BIF,不仅从性能的角度来看。</target>
        </trans-unit>
        <trans-unit id="302cba4ce6be32265c131b8fff3be15369bb97a8" translate="yes" xml:space="preserve">
          <source>This section lists all funs. The following fields exist for each fun:</source>
          <target state="translated">本节列出了所有fun。每个fun都有以下字段。</target>
        </trans-unit>
        <trans-unit id="7bc1c1a16c9fc6835aa747c430d5753502607fd3" translate="yes" xml:space="preserve">
          <source>This section lists the open ports, their owners, any linked processes, and the name of their driver or external process.</source>
          <target state="translated">这一部分列出了开放的端口、它们的所有者、任何链接的进程,以及它们的驱动程序或外部进程的名称。</target>
        </trans-unit>
        <trans-unit id="251c858a6feb418633832df9c31b24c8b4f5a1b7" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using Native Implemented Functions (NIFs).</source>
          <target state="translated">本节概述了如何使用本机实现的功能（NIF）解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="e7bc2bafdedf8fd30afa495c12130ded7ddd3fc5" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a C node. Notice that a C node is not typically used for solving simple problems like this, a port is sufficient.</source>
          <target state="translated">本节概述了如何使用C节点解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。注意，C节点通常不用于解决诸如此类的简单问题，端口就足够了。</target>
        </trans-unit>
        <trans-unit id="d8b1fe16968a43f36d99fc7c39a89fadb4f26e24" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a linked-in port driver.</source>
          <target state="translated">本节概述了如何使用链接的端口驱动程序解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="6188e756764065c7ce79203e7dc5cecf3ee5f2b4" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a port and Erl_Interface. It is necessary to read the port example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; before reading this section.</source>
          <target state="translated">本节概述了如何使用端口和Erl_Interface 解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。这是必要的阅读端口例如 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 阅读本节之前。</target>
        </trans-unit>
        <trans-unit id="37a17f96d0247a59a445c39970b3c2ce5aa258a2" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in the &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; by using a port.</source>
          <target state="translated">本节概述了如何使用端口解决 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; 示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="909ed75e66d95b03604cc684f38a417f30c36fa4" translate="yes" xml:space="preserve">
          <source>This section outlines the current Unicode support and gives some recipes for working with Unicode data.</source>
          <target state="translated">本节概述了当前的Unicode支持,并给出了一些处理Unicode数据的方法。</target>
        </trans-unit>
        <trans-unit id="f4548220d710b00d84d1083e484e819816bc4647" translate="yes" xml:space="preserve">
          <source>This section presents all the atoms in the system. This is only of interest if one suspects that dynamic generation of atoms can be a problem, otherwise this section can be ignored.</source>
          <target state="translated">本节介绍了系统中所有的原子。只有当人们怀疑原子的动态生成可能是一个问题时,才会对此感兴趣,否则本节可以忽略。</target>
        </trans-unit>
        <trans-unit id="e98a32dcb47ef919db3aef2c03013357cf7c9199" translate="yes" xml:space="preserve">
          <source>This section presents the generic protocol-independent model for use within an OTP-based NE. This model is used by all OAM components and can be used by the applications. The advantage of the model is that it clearly separates the resources from the management protocol. The resources do not need to be aware of which management protocol is used to manage the system. The same resources can therefore be managed with different protocols.</source>
          <target state="translated">本节介绍了在基于OTP的NE中使用的通用协议无关模型。这个模型被所有的OAM组件使用,并且可以被应用程序使用。该模型的优点是它明确地将资源与管理协议分开。资源不需要知道用哪个管理协议来管理系统。因此,相同的资源可以用不同的协议进行管理。</target>
        </trans-unit>
        <trans-unit id="16347e215e685cc8a7eb7375f07fbbb91f2c9603" translate="yes" xml:space="preserve">
          <source>This section provides a brief overview on how to write efficient drivers.</source>
          <target state="translated">本节简要介绍了如何编写高效的驱动程序。</target>
        </trans-unit>
        <trans-unit id="30913964bf9365a1caa81bfa4bb9ad170421d97f" translate="yes" xml:space="preserve">
          <source>This section provides a simplified demonstration of a &lt;code&gt;Mnesia&lt;/code&gt; system startup. The dialogue from the Erlang shell is as follows:</source>
          <target state="translated">本节提供了 &lt;code&gt;Mnesia&lt;/code&gt; 系统启动的简化演示。来自Erlang shell的对话框如下：</target>
        </trans-unit>
        <trans-unit id="ec0f201c25b61d89e7f6c76b13618afc0002a916" translate="yes" xml:space="preserve">
          <source>This section should be read with the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page in STDLIB, where all details about the supervisor behaviour is given.</source>
          <target state="translated">本节应与STDLIB 的 &lt;code&gt;supervisor(3)&lt;/code&gt; 手册页一起阅读，其中提供了有关supervisor行为的所有详细信息。</target>
        </trans-unit>
        <trans-unit id="859dc9ee797ee513900af80c0e4f3984de1a34df" translate="yes" xml:space="preserve">
          <source>This section shows a small example of how to set up client/server connections using the Erlang shell. The returned value of the &lt;code&gt;sslsocket&lt;/code&gt; is abbreviated with &lt;code&gt;[...]&lt;/code&gt; as it can be fairly large and is opaque.</source>
          <target state="translated">本节显示一个小示例，说明如何使用Erlang Shell设置客户端/服务器连接。 &lt;code&gt;sslsocket&lt;/code&gt; 的返回值缩写为 &lt;code&gt;[...]&lt;/code&gt; ,因为它可能相当大且不透明。</target>
        </trans-unit>
        <trans-unit id="1b3f3a6882bc6f1c999e3d6f053e34aa184902fb" translate="yes" xml:space="preserve">
          <source>This section starts with a simple example, showing a generator and a filter:</source>
          <target state="translated">本节从一个简单的例子开始,展示了一个发生器和一个滤波器。</target>
        </trans-unit>
        <trans-unit id="b10755987ebac7d338a7fd1a7c6bbec42a0583a6" translate="yes" xml:space="preserve">
          <source>This section tries to kill the old truths (or semi-truths) that have become myths.</source>
          <target state="translated">这一节试图扼杀那些已经成为神话的旧真理(或半真理)。</target>
        </trans-unit>
        <trans-unit id="4bc790cb1406d976325d74bbdbe32730d66b0176" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, as it explains important concepts, but this was written for an older driver interface so the examples do not work anymore. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">这部分是很久以前写的。它大多数都仍然有效，因为它解释了重要的概念，但这是为较旧的驱动程序界面编写的，因此这些示例不再起作用。鼓励读者阅读 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="b93f78b17719c3a40516be4872cc22d2aa5ee759" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, but some things have changed since then. Some updates have been made to the documentation of the driver presented here, but more can be done and is planned for the future. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">这部分是很久以前写的。大多数内容仍然有效，但此后发生了一些变化。已经对此处提供的驱动程序文档进行了一些更新，但是可以做很多事，并计划在将来进行。鼓励读者阅读 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="3acfdfded91bac52b2d4f66deb3db7bcfef3bb64" translate="yes" xml:space="preserve">
          <source>This sends a request with a specified connection header:</source>
          <target state="translated">这将发送一个带有指定连接头的请求。</target>
        </trans-unit>
        <trans-unit id="a989f27ccbc0cd1a9d3190ceeec551d99b4ccfce" translate="yes" xml:space="preserve">
          <source>This sends an HTTP request over a unix domain socket (experimental):</source>
          <target state="translated">这将通过unix域套接字发送一个HTTP请求(实验性的)。</target>
        </trans-unit>
        <trans-unit id="0367f390c138c4cdab5de93d4dcd533741c91409" translate="yes" xml:space="preserve">
          <source>This server can be started with the Kernel configuration parameter &lt;code&gt;start_boot_server&lt;/code&gt;.</source>
          <target state="translated">可以使用内核配置参数 &lt;code&gt;start_boot_server&lt;/code&gt; 启动该服务器。</target>
        </trans-unit>
        <trans-unit id="9a01d31508a13cbee6fd61e7f30640416fa3e960" translate="yes" xml:space="preserve">
          <source>This server is used to assist diskless Erlang nodes that fetch all Erlang code from another machine.</source>
          <target state="translated">这个服务器用来协助无盘的Erlang节点从另一台机器上获取所有Erlang代码。</target>
        </trans-unit>
        <trans-unit id="6d1e9f0f9d29165296c1877ce900cce295357757" translate="yes" xml:space="preserve">
          <source>This server is used to fetch all code, including the start script, if an Erlang runtime system is started with command-line flag &lt;code&gt;-loader inet&lt;/code&gt;. All hosts specified with command-line flag &lt;code&gt;-hosts Host&lt;/code&gt; must have one instance of this server running.</source>
          <target state="translated">如果使用命令行标志 &lt;code&gt;-loader inet&lt;/code&gt; 启动Erlang运行时系统，则此服务器用于获取所有代码，包括启动脚本。使用命令行标志 &lt;code&gt;-hosts Host&lt;/code&gt; 指定的所有主机主机必须正在运行此服务器的一个实例。</target>
        </trans-unit>
        <trans-unit id="b854dfbf08852692209c2c9428fe6541ba04a2b8" translate="yes" xml:space="preserve">
          <source>This session sets the system_tracer to the same process as the ordinary tracer process (i. e. &amp;lt;0.31.0&amp;gt;) and sets the trace pattern for the function &lt;code&gt;dbg:get_tracer&lt;/code&gt; to one that has the action of setting a sequential token. When the function is called by a traced process (all processes are traced in this case), the process gets &quot;contaminated&quot; by the token and &lt;code&gt;seq_trace&lt;/code&gt; messages are sent both for the server request and the response. The &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; after the call clears the &lt;code&gt;seq_trace&lt;/code&gt; token, why no messages are sent when the answer propagates via the shell to the console port. The output would otherwise have been more noisy.</source>
          <target state="translated">该会话将system_tracer设置为与普通跟踪器进程相同的进程（即&amp;lt;0.31.0&amp;gt;），并将函数 &lt;code&gt;dbg:get_tracer&lt;/code&gt; 的跟踪模式设置为具有设置顺序令牌的动作的跟踪模式。当被跟踪的进程调用该函数（在这种情况下将跟踪所有进程）时，该进程将被令牌&amp;ldquo;污染&amp;rdquo;，并为服务器请求和响应发送 &lt;code&gt;seq_trace&lt;/code&gt; 消息。所述 &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; 在调用之后清除 &lt;code&gt;seq_trace&lt;/code&gt; 令牌，为什么没有消息被发送通过壳到控制台端口答案传播时。否则，输出将更加嘈杂。</target>
        </trans-unit>
        <trans-unit id="7f6dee944ecab0b445c18e6ceefaac7d931ceec9" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; are added first in the PATH.</source>
          <target state="translated">这应该对环境起到最后的作用，并且此后的建造应该很容易。您可以在不使用 &lt;code&gt;eval&lt;/code&gt; 的情况下运行 &lt;code&gt;./otp_build env_win32&lt;/code&gt; ，只是为了查看它的作用，并查看它设置的环境是否正常。如果可能的话，清除路径中的空格（改为使用DOS样式的短名称），将变量 &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt; ， &lt;code&gt;CC&lt;/code&gt; ， &lt;code&gt;CXX&lt;/code&gt; ， &lt;code&gt;AR&lt;/code&gt; 和 &lt;code&gt;RANLIB&lt;/code&gt; 设置为其各自的包装，并将目录 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; 首先添加到PATH中。</target>
        </trans-unit>
        <trans-unit id="d785e08dd7a56c60e1bed8756d1974bdb847eb99" translate="yes" xml:space="preserve">
          <source>This shows another important non-obvious case: a clause guard, even if it's as simple as &lt;code&gt;Y &amp;gt; 0&lt;/code&gt;, always consists of a single disjunction of one or more conjunctions of tests, much like a tuple of tuples. Thus:</source>
          <target state="translated">这显示了另一个重要的非显而易见的情况：子句保护，即使它像 &lt;code&gt;Y &amp;gt; 0&lt;/code&gt; 一样简单，也总是由一个或多个测试连接的单个析取组成，就像一个元组的元组。从而：</target>
        </trans-unit>
        <trans-unit id="1fa8ade625dd050384ebfe47137813125a13ed25" translate="yes" xml:space="preserve">
          <source>This signal will be ignored.</source>
          <target state="translated">此信号将被忽略。</target>
        </trans-unit>
        <trans-unit id="92abfd0b7a6c2f6f6e673410127b459c582c4efd" translate="yes" xml:space="preserve">
          <source>This signal will notify &lt;code&gt;erl_signal_server&lt;/code&gt; when it is received by the Erlang runtime system.</source>
          <target state="translated">当Erlang运行时系统接收到该信号时，它将通知 &lt;code&gt;erl_signal_server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edab6f17da92a0f0da17b2cdabee390180519ab6" translate="yes" xml:space="preserve">
          <source>This signal will use the default signal handler for the operating system.</source>
          <target state="translated">该信号将使用操作系统的默认信号处理器。</target>
        </trans-unit>
        <trans-unit id="da98f38cbd3a5312fa20fb0710bd3343db7b6751" translate="yes" xml:space="preserve">
          <source>This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \X matches one of these clusters.</source>
          <target state="translated">在Unicode中,这个简单的定义被扩展到包括更复杂的复合字符,给每个字符一个词素断裂属性,并创建规则,使用这些属性来定义扩展词素簇的边界。在8.31以后的PCRE版本中,\X与这些簇之一相匹配。</target>
        </trans-unit>
        <trans-unit id="e86121002d76857e44d3ab841a1269a83df96b05" translate="yes" xml:space="preserve">
          <source>This simple standard test, &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt;, a module which, using the &lt;code&gt;snmp_ex2_manager&lt;/code&gt; described in the previous section, implements a simple agent test utility.</source>
          <target state="translated">这个简单的标准测试 &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt; 是一个模块，该模块使用上 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 介绍的snmp_ex2_manager来实现一个简单的代理测试实用程序。</target>
        </trans-unit>
        <trans-unit id="2d0034518115855077790a9986c987efa20b3785" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt;OTP Design Principles&lt;/code&gt;).</source>
          <target state="translated">通过使用OTP中的功能，可以更轻松地解决此类问题，这些功能还提供了动态更新代码的方法，等等（请参阅 &lt;code&gt;OTP Design Principles&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3b6d6c6628faa03b7c6f08bc646ad236cf4da32" translate="yes" xml:space="preserve">
          <source>This specialized decode decodes a subtype of a constructed value and is the fastest method to extract a subvalue. This decode is typically used when you want to inspect, for example, a version number, to be able to decide what to do with the entire value. The result is returned as &lt;code&gt;{ok,Value}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">这种专用解码对构造值的子类型进行解码，并且是提取子值的最快方法。通常，当您要检查版本号以决定如何处理整个值时，通常使用此解码。结果以 &lt;code&gt;{ok,Value}&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 的形式返回。</target>
        </trans-unit>
        <trans-unit id="77e086b8dea4b8bfb5a0597b5900b1d75b0fef9f" translate="yes" xml:space="preserve">
          <source>This starts Erlang in its own window, with fully functioning command-line editing and scrollbars. All flags except &lt;code&gt;-oldshell&lt;/code&gt; work as they do for &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将在具有自己功能的命令行编辑和滚动条窗口中启动Erlang。除 &lt;code&gt;-oldshell&lt;/code&gt; 以外的所有标志都与 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="a43faa1a1676e12b0177f046a812f0d8364ec82d" translate="yes" xml:space="preserve">
          <source>This starts the Erlang runtime system and evaluates the following functions:</source>
          <target state="translated">这将启动Erlang运行时系统并评估以下函数。</target>
        </trans-unit>
        <trans-unit id="8bb8d3378772860a522d3a705d4cc5d40c409e79" translate="yes" xml:space="preserve">
          <source>This state data can be regarded as sensitive, and maybe not what you want in the error log because of some unpredictable event.</source>
          <target state="translated">这个状态数据可以说是敏感的,也许因为一些不可预知的事件,在错误日志中并不是你想要的。</target>
        </trans-unit>
        <trans-unit id="97c14a1eab4a2d73f912f341632799fc7862da43" translate="yes" xml:space="preserve">
          <source>This state transition action can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或将其 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用此状态转换动作。</target>
        </trans-unit>
        <trans-unit id="57901b1493b88f1a72b634f92f65ad89d7517d70" translate="yes" xml:space="preserve">
          <source>This step also implies that the Erlang code in the interface and distribution modules is written in such a way that it can be run in the startup phase. In particular, there can be no calls to the &lt;code&gt;application&lt;/code&gt; module or to any modules not loaded at boot time. That is, only &lt;code&gt;Kernel&lt;/code&gt;, &lt;code&gt;STDLIB&lt;/code&gt;, and the application itself can be used.</source>
          <target state="translated">此步骤还意味着，接口和分发模块中的Erlang代码是以可以在启动阶段运行的方式编写的。特别是，在启动时不能调用 &lt;code&gt;application&lt;/code&gt; 模块或任何未加载的模块。也就是说，只能使用 &lt;code&gt;Kernel&lt;/code&gt; ， &lt;code&gt;STDLIB&lt;/code&gt; 和应用程序本身。</target>
        </trans-unit>
        <trans-unit id="33eaf1a1a2a532c70f7ffcd5caaf8b22d9ff8909" translate="yes" xml:space="preserve">
          <source>This structure is to be used if all clients are running the same type of Erlang machine. If there are clients running different types of Erlang machines, or on different operating systems, the &lt;code&gt;clients&lt;/code&gt; directory can be divided into one subdirectory per type of Erlang machine. Alternatively, one &lt;code&gt;$ROOT&lt;/code&gt; can be set up per type of machine. For each type, some of the directories specified for the &lt;code&gt;$ROOT&lt;/code&gt; directory are to be included:</source>
          <target state="translated">如果所有客户端都在运行相同类型的Erlang计算机，则将使用此结构。如果有客户端在运行不同类型的Erlang计算机，或在不同的操作系统上运行，则可以将 &lt;code&gt;clients&lt;/code&gt; 目录划分为每种Erlang计算机类型的一个子目录。或者，可以为每种类型的机器设置一个 &lt;code&gt;$ROOT&lt;/code&gt; 。对于每种类型，将包括为 &lt;code&gt;$ROOT&lt;/code&gt; 目录指定的一些目录：</target>
        </trans-unit>
        <trans-unit id="ba107d8023d557fe4ebdc08a0485fead425f4a4c" translate="yes" xml:space="preserve">
          <source>This structure is used for all types of ports although some fields are useless for some types. The least memory consuming solution would be to arrange this structure as a union of structures. However, the multiple indirections in the code to access a field in such a structure would clutter the code too much for an example.</source>
          <target state="translated">这个结构适用于所有类型的 port,尽管有些字段对某些类型是无用的。最不消耗内存的解决方案是把这个结构安排成结构的联合。然而,在这样的结构中访问一个字段的代码中,多次的间接访问会使代码过于混乱。</target>
        </trans-unit>
        <trans-unit id="b9c807a7212c0db55e210d6237e55cf572102e59" translate="yes" xml:space="preserve">
          <source>This switches off logging for SSH and Telnet connections.</source>
          <target state="translated">这将关闭SSH和Telnet连接的日志记录。</target>
        </trans-unit>
        <trans-unit id="3c8936eaae5713c5223ec21e20e0d36d26fc0092" translate="yes" xml:space="preserve">
          <source>This switches off logging for all connection types.</source>
          <target state="translated">这将关闭所有连接类型的日志记录。</target>
        </trans-unit>
        <trans-unit id="f56bbb3abc53b0a624950444e1c66ce730f11613" translate="yes" xml:space="preserve">
          <source>This symbol should appear in the lhs of at least one grammar rule. This is the most general syntactic category which the parser ultimately will parse every input string into.</source>
          <target state="translated">这个符号应该出现在至少一条语法规则的lhs中。这是最通用的语法类别,解析器最终会将每个输入字符串解析为这个类别。</target>
        </trans-unit>
        <trans-unit id="a9ad3ed484ba9b2b41f2325fc27244234c66f278" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt;dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="translated">此语法等效于Runtime_Tools中的跟踪模式（请参见 &lt;code&gt;dbg(3)&lt;/code&gt; ）模块中使用的语法。</target>
        </trans-unit>
        <trans-unit id="ee2b2d8d451101694a58799b8409428a148a8058" translate="yes" xml:space="preserve">
          <source>This takes &lt;code&gt;H&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; in all possible ways. The result is the set of all lists &lt;code&gt;[H|T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the set of all possible permutations of &lt;code&gt;L&lt;/code&gt;, with &lt;code&gt;H&lt;/code&gt; removed:</source>
          <target state="translated">这会以所有可能的方式从 &lt;code&gt;L&lt;/code&gt; 夺取 &lt;code&gt;H&lt;/code&gt; 。结果是所有列表 &lt;code&gt;[H|T]&lt;/code&gt; 的集合，其中 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;L&lt;/code&gt; 的所有可能置换的集合，其中 &lt;code&gt;H&lt;/code&gt; 被除去：</target>
        </trans-unit>
        <trans-unit id="618f3633ac8c2cadd4289f1c5621d970e601a5ca" translate="yes" xml:space="preserve">
          <source>This term is the encoding for external funs: &lt;code&gt;fun M:F/A&lt;/code&gt;.</source>
          <target state="translated">该术语是外部的玩意儿编码： &lt;code&gt;fun M:F/A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beb3ae0ca905f496ce783ad12cff60bb9bb87bbd" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 0 of the external format; it has been superseded by &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此术语在外部格式的次要版本0中使用；它已被 &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; 取代。</target>
        </trans-unit>
        <trans-unit id="b517e1702cae7ec8ee019fdb69c857aa5330cfd8" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 1 of the external format.</source>
          <target state="translated">这个词用在外部格式的小版本1中。</target>
        </trans-unit>
        <trans-unit id="0860084b170b958eacacb8679369f69a7b4a4046" translate="yes" xml:space="preserve">
          <source>This term represents a bitstring whose length in bits does not have to be a multiple of 8. The &lt;code&gt;Len&lt;/code&gt; field is an unsigned 4 byte integer (big-endian). The &lt;code&gt;Bits&lt;/code&gt; field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant.</source>
          <target state="translated">该术语表示一个位串，其位长度不必是8的倍数 &lt;code&gt;Len&lt;/code&gt; 字段是一个无符号的4字节整数（big-endian）。所述 &lt;code&gt;Bits&lt;/code&gt; 字段是在最后一个字节用于在数据字段中的比特（1-8）的数量，从最显著位到最低显著计数。</target>
        </trans-unit>
        <trans-unit id="108bbd5cab7129c54f675f7643a23fb10026ce1d" translate="yes" xml:space="preserve">
          <source>This test specification declares that &lt;code&gt;node1@host1&lt;/code&gt; is to be started using the user callback function &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt;, and nodes &lt;code&gt;node1@host2&lt;/code&gt; and &lt;code&gt;node2@host2&lt;/code&gt; are to be started with the default callback module &lt;code&gt;ct_slave&lt;/code&gt;. The specified username and password are used to log on to remote host &lt;code&gt;host2&lt;/code&gt;. Also, function &lt;code&gt;module:function/0&lt;/code&gt; is evaluated on &lt;code&gt;node1@host3&lt;/code&gt;, and the result of this call is printed to the log.</source>
          <target state="translated">该测试规范声明将使用用户回调函数 &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt; 启动 &lt;code&gt;node1@host1&lt;/code&gt; ，并使用默认回调模块 &lt;code&gt;ct_slave&lt;/code&gt; 来启动节点 &lt;code&gt;node1@host2&lt;/code&gt; 和 &lt;code&gt;node2@host2&lt;/code&gt; 。指定的用户名和密码用于登录到远程主机 &lt;code&gt;host2&lt;/code&gt; 。同样，在 &lt;code&gt;node1@host3&lt;/code&gt; 上评估function &lt;code&gt;module:function/0&lt;/code&gt; ，并将此调用的结果打印到日志中。</target>
        </trans-unit>
        <trans-unit id="e29f7e984adbbfe8a53af166b10808cfa43c1c97" translate="yes" xml:space="preserve">
          <source>This tests all object files in the specified directory, as if they had been individually specified using &lt;code&gt;{file, FileName}&lt;/code&gt;.</source>
          <target state="translated">这将测试指定目录中的所有目标文件，就像使用 &lt;code&gt;{file, FileName}&lt;/code&gt; 分别指定了它们一样。</target>
        </trans-unit>
        <trans-unit id="76191fd55833467474b9c8b3bbd30d057e2c02a5" translate="yes" xml:space="preserve">
          <source>This the formatter callback function to be called from handlers. The log event is processed as follows:</source>
          <target state="translated">这是要从处理程序中调用的formatter回调函数。日志事件的处理方法如下。</target>
        </trans-unit>
        <trans-unit id="a753a4a3983a27e7aa021fa6ea24ccc7d272be01" translate="yes" xml:space="preserve">
          <source>This time argument 2 is used, which is the second element in the tuple. If this returns the atom &lt;code&gt;false&lt;/code&gt;, fred is not logged on and the following message is sent:</source>
          <target state="translated">使用此时间参数2，它是元组中的第二个元素。如果返回原子 &lt;code&gt;false&lt;/code&gt; ，则fred不会登录，并发送以下消息：</target>
        </trans-unit>
        <trans-unit id="e6fffaa6a8f0644a7ea4fa7c7c74c76ec90d774c" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">在一般情况下，此时间&lt;strong&gt;不是&lt;/strong&gt;单调增加的时间。有关更多信息，请参见《用户指南》中的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="49beb73df376b7dea84521a1c52301d5531a79e4" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time.</source>
          <target state="translated">此时间&lt;strong&gt;不是&lt;/strong&gt;单调增加的时间。</target>
        </trans-unit>
        <trans-unit id="3748262d456a936f46c1ed22dababf257bb3fa6f" translate="yes" xml:space="preserve">
          <source>This time may or may not be an accurate view of POSIX time, and may or may not align with &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. The runtime system works towards aligning the two system times. Depending on the &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used, this can be achieved by letting Erlang system time perform a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此时间可能是POSIX时间的准确视图，也可能不是，并且可能与 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 不一致。运行时系统致力于使两个系统时间对齐。根据所使用的 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; ，可以通过让Erlang系统时间执行 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="83d87d01faae0b3a7fef0f76f0e3a3892ae23062" translate="yes" xml:space="preserve">
          <source>This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;.</source>
          <target state="translated">这次第一个断言看前面六个字符,检查前三个是数字,然后第二个断言检查前面三个字符是不是 &quot;999&quot;。</target>
        </trans-unit>
        <trans-unit id="14391b08125b325189f3dcbd403d72965af6b345" translate="yes" xml:space="preserve">
          <source>This time, since the shell was not involved, no other work was done in the system during the profiling. If you retry the same example with a freshly started Erlang emulator, but omit the command &lt;code&gt;l(random)&lt;/code&gt;, the analysis will show a lot more function calls done by &lt;code&gt;code_server&lt;/code&gt; and others to automatically load the module &lt;code&gt;random&lt;/code&gt;.</source>
          <target state="translated">这次，由于不涉及外壳，因此在概要分析期间，系统中没有其他工作。如果您使用刚启动的Erlang仿真 &lt;code&gt;code_server&lt;/code&gt; 试相同的示例，但是省略了命令 &lt;code&gt;l(random)&lt;/code&gt; ，则分析将显示code_server和其他人执行的许多函数调用，以自动 &lt;code&gt;random&lt;/code&gt; 加载模块。</target>
        </trans-unit>
        <trans-unit id="22a9f149405034822a960ba22d2e8646cd23a4b4" translate="yes" xml:space="preserve">
          <source>This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use.</source>
          <target state="translated">这一次,先尝试递归的替代方案,并继续递归,直到用完字符,这时递归失败。但这次我们有另一个更高层次的备选方案可以尝试。这就是显著的区别:在前一种情况下,剩余的备选方案是在更深的递归层次上,PCRE无法使用。</target>
        </trans-unit>
        <trans-unit id="c60619daf599e1009f83ff3339a4a66e29dc068d" translate="yes" xml:space="preserve">
          <source>This timer is started when the &lt;strong&gt;first&lt;/strong&gt; reply to an asynchronous request (issued using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; function) arrives. As long as this timer is running, replies will be delivered via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function, with their &quot;arrival number&quot; (see &lt;code&gt;UserReply&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function).</source>
          <target state="translated">当对异步请求的&lt;strong&gt;第一次&lt;/strong&gt;答复（使用 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; 函数发出）到达时，将启动此计时器。只要该定时器正在运行，答复将通过递送 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; 回调函数，与他们的&amp;ldquo;到达号码&amp;rdquo;（见 &lt;code&gt;UserReply&lt;/code&gt; 所述的 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; 回调函数）。</target>
        </trans-unit>
        <trans-unit id="7f582a8bac4499f4041fc098c02442c6d51efa18" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; (e.g. the last of the segment which makes up the reply) is received, but all segments has not yet been received.</source>
          <target state="translated">当接收到由 &lt;code&gt;segmentation complete token&lt;/code&gt; 指示的分段（例如，组成答复的分段的最后一个），但尚未接收到所有分段时，将启动此计时器。</target>
        </trans-unit>
        <trans-unit id="e5f2ade158232a7f92c6ed91597d402fd153194a" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; is received, but all segments has not yet been received.</source>
          <target state="translated">当接收到由 &lt;code&gt;segmentation complete token&lt;/code&gt; 指示的分段但尚未接收到所有分段时，将启动此计时器。</target>
        </trans-unit>
        <trans-unit id="706cbfbf9ab1807332ea2d94bd3ad6011d82aa07" translate="yes" xml:space="preserve">
          <source>This transaction can write the text &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 1000 times to the terminal. However, &lt;code&gt;Mnesia&lt;/code&gt; guarantees that each transaction will eventually run. As a result, &lt;code&gt;Mnesia&lt;/code&gt; is not only deadlock free, but also livelock free.</source>
          <target state="translated">此事务可以将文本 &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 终端1000次。但是， &lt;code&gt;Mnesia&lt;/code&gt; 保证每笔交易将最终运行。结果， &lt;code&gt;Mnesia&lt;/code&gt; 不仅无死锁，而且无活锁。</target>
        </trans-unit>
        <trans-unit id="c15707ecd3d8e52159c361dec50a35ae8f4adf88" translate="yes" xml:space="preserve">
          <source>This transaction returns the list &lt;code&gt;[{foo,1,3}]&lt;/code&gt; if table &lt;code&gt;foo&lt;/code&gt; is of type &lt;code&gt;set&lt;/code&gt;. However, the list &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; is returned if the table is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果表 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;set&lt;/code&gt; 类型 &lt;code&gt;[{foo,1,3}]&lt;/code&gt; 此事务返回列表[{foo，1,3}]。但是，如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ,则返回列表 &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf13712351a4aa96ae94ff06cddb20f5ef75fe11" translate="yes" xml:space="preserve">
          <source>This tries to match &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; or &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; twice. If &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; appears, the function returns &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt;.</source>
          <target state="translated">这会尝试两次匹配 &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 。如果出现 &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; ，该函数将返回 &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53c27958e7fca3ba05175a738c3a146371fd4e49" translate="yes" xml:space="preserve">
          <source>This tuple only exists if &lt;code&gt;Function&lt;/code&gt; can be used with different clocks. &lt;code&gt;ClockId&lt;/code&gt; corresponds to the clock identifier used when calling &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;Function&lt;/code&gt; 可与不同的时钟一起使用时，该元组才存在。 &lt;code&gt;ClockId&lt;/code&gt; 对应于调用 &lt;code&gt;Function&lt;/code&gt; 时使用的时钟标识符。</target>
        </trans-unit>
        <trans-unit id="ceff633d5c12b0ab1b989cd600fd3b0c1f9b57c7" translate="yes" xml:space="preserve">
          <source>This type is assigned in Erlang as follows:</source>
          <target state="translated">这个类型在Erlang中分配如下。</target>
        </trans-unit>
        <trans-unit id="34e89a0a89b0d1a14764e553fc94c9f4fbe45d6d" translate="yes" xml:space="preserve">
          <source>This type is further described in application &lt;code&gt;xmerl&lt;/code&gt;.</source>
          <target state="translated">在应用程序 &lt;code&gt;xmerl&lt;/code&gt; 中进一步描述了这种类型。</target>
        </trans-unit>
        <trans-unit id="6be71fbb0606c9b749f47ff7cbc7a8e0ca516ae1" translate="yes" xml:space="preserve">
          <source>This type of time-out is useful for example to act on inactivity. Let us restart the code sequence if no button is pressed for say 30 seconds:</source>
          <target state="translated">这种类型的超时是很有用的,例如在不活动的情况下。让我们重新开始代码序列,如果30秒内没有按下按钮。</target>
        </trans-unit>
        <trans-unit id="0dd216aebaebb2374c204746cffeb0b8a3bfa66e" translate="yes" xml:space="preserve">
          <source>This utility function is used to create a formatted (pretty printable) string of the error reason received from either:</source>
          <target state="translated">这个实用函数用于创建一个格式化的(漂亮的可打印的)从任何一个收到的错误原因的字符串。</target>
        </trans-unit>
        <trans-unit id="e90f513c2d724696028de83a41a04ca02c00b03d" translate="yes" xml:space="preserve">
          <source>This utility is specific to Windows NT/2000/XP (and later versions of Windows). It allows Erlang emulators to run as services on the Windows system, allowing embedded systems to start without any user needing to log on. The emulator started in this way can be manipulated through the Windows services applet in a manner similar to other services.</source>
          <target state="translated">这个实用程序是专门针对Windows NT/2000/XP(以及更高版本的Windows)的,它允许Erlang仿真器在Windows系统上作为服务运行,允许嵌入式系统在不需要任何用户登录的情况下启动。它允许Erlang仿真器在Windows系统上作为服务运行,允许嵌入式系统在不需要任何用户登录的情况下启动。以这种方式启动的仿真器可以通过Windows服务小程序进行操作,其方式与其他服务类似。</target>
        </trans-unit>
        <trans-unit id="b55cb392aed5fc4d4c203d5436538e3f6a69fde3" translate="yes" xml:space="preserve">
          <source>This validation callback will be executed before any heartbeat is sent to the port program. For the validation to succeed it needs to return with the value &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">该验证回调将在任何心跳发送到端口程序之前执行。为了使验证成功，它需要返回 &lt;code&gt;ok&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3b8b5c1eef6ea78b8a30fd3fe8ec2afd6d40564e" translate="yes" xml:space="preserve">
          <source>This value can also be set through (OS) environment variable &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt;.</source>
          <target state="translated">也可以通过（OS）环境变量 &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt; 设置此值。</target>
        </trans-unit>
        <trans-unit id="58b09f82dfd17c02b5cc9bb38621d7a9dc8cc490" translate="yes" xml:space="preserve">
          <source>This value can be set at startup by passing command-line argument &lt;code&gt;+SDio&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">可以在启动时通过在 &lt;code&gt;erl(1)&lt;/code&gt; 中传递命令行参数 &lt;code&gt;+SDio&lt;/code&gt; 来设置此值。</target>
        </trans-unit>
        <trans-unit id="f2f1511a226b28ee2f7a6351d90cc98e92a8e944" translate="yes" xml:space="preserve">
          <source>This value might wrap due to limitations in the underlying functionality provided by the operating system that is used.</source>
          <target state="translated">由于使用的操作系统提供的底层功能的限制,这个值可能会被包裹。</target>
        </trans-unit>
        <trans-unit id="ae87da20fd16a3057a07a29b3ed216aa69d1b30e" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a disk_log sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">这个值,以毫秒为单位,指定处理程序进行disk_log同步操作的频率,以便将缓冲数据写入磁盘。处理程序会反复尝试这个操作,但是只有当有东西被记录下来的时候才会执行新的同步操作。</target>
        </trans-unit>
        <trans-unit id="562ee5839a71bc34778a37d5ff1caee77199d71c" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a file sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">这个值,以毫秒为单位,指定处理程序进行文件同步操作的频率,以便将缓冲数据写入磁盘。处理程序会反复尝试该操作,但只有在实际记录了某些内容时才会执行新的同步。</target>
        </trans-unit>
        <trans-unit id="8a7dae834a17e1bfd7dcc5067b03add360f4e974" translate="yes" xml:space="preserve">
          <source>This variable sets the maximum size of a crash dump file in bytes. The crash dump will be truncated if this limit is exceeded. If the variable is not set, no size limit is enforced by default. If the variable is set to &lt;code&gt;0&lt;/code&gt;, the runtime system does not even attempt to write a crash dump file.</source>
          <target state="translated">此变量设置故障转储文件的最大大小（以字节为单位）。如果超出此限制，崩溃转储将被截断。如果未设置该变量，则默认情况下不强制大小限制。如果变量设置为 &lt;code&gt;0&lt;/code&gt; ，则运行时系统甚至不会尝试写入故障转储文件。</target>
        </trans-unit>
        <trans-unit id="c8c996bd75b6c1e556e40ae90ed97ed437560b07" translate="yes" xml:space="preserve">
          <source>This variant is kept for compatibility.</source>
          <target state="translated">这个变体是为了兼容性而保留的。</target>
        </trans-unit>
        <trans-unit id="f23ebd696e347931712dab86d1982b0ebcb811ea" translate="yes" xml:space="preserve">
          <source>This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails.</source>
          <target state="translated">这个动词会使匹配成功结束,跳过模式的剩余部分。但是,当它在作为子程序调用的子模式内时,只有该子模式被成功结束。然后在外层继续匹配。如果在正断言中触发了(*ACCEPT),则断言成功;在负断言中,则断言失败。</target>
        </trans-unit>
        <trans-unit id="d08ddef725078632007c7d27f955f2e16c27447f" translate="yes" xml:space="preserve">
          <source>This version encode atoms that can be represented by a latin1 string using latin1 encoding while only atoms that cannot be represented by latin1 are encoded using utf8.</source>
          <target state="translated">这个版本使用latin1编码对可以用latin1字符串表示的原子进行编码,而只有不能用latin1表示的原子使用utf8编码。</target>
        </trans-unit>
        <trans-unit id="d758c1fa288ff4bea6ef5e3e118de5ef6067101b" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;wrap_log_reader&lt;/code&gt; does not detect if &lt;code&gt;disk_log&lt;/code&gt; wraps to a new index file between a call to &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; and the first call to &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt;. If this occurs, the call to &lt;code&gt;chunk()&lt;/code&gt; reads the last logged items in the log file, as the opened index file was truncated by &lt;code&gt;disk_log&lt;/code&gt;.</source>
          <target state="translated">这个版本的 &lt;code&gt;wrap_log_reader&lt;/code&gt; 不会检测 &lt;code&gt;disk_log&lt;/code&gt; 是否在调用 &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; 和第一次调用 &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt; 之间包装到新的索引文件。如果发生这种情况，对调用 &lt;code&gt;chunk()&lt;/code&gt; 的操作将读取日志文件中最后记录的项目，因为打开的索引文件被 &lt;code&gt;disk_log&lt;/code&gt; 截断了。</target>
        </trans-unit>
        <trans-unit id="7892b8b3e220dc2d6df9f4226b75eda81b8a6c0a" translate="yes" xml:space="preserve">
          <source>This version of the stack is compliant with:</source>
          <target state="translated">这个版本的堆栈符合:</target>
        </trans-unit>
        <trans-unit id="240472a34becd16e12bb3376c31742854774737c" translate="yes" xml:space="preserve">
          <source>This version of the stack supports version 1, 2 and 3 as defined by:</source>
          <target state="translated">这个版本的堆栈支持以下定义的版本1、2和3。</target>
        </trans-unit>
        <trans-unit id="12b130ec0f7a537e5f469d318f402ce06f564884" translate="yes" xml:space="preserve">
          <source>This way the decoder will detect which version is used and then use the proper decoder.</source>
          <target state="translated">这样解码器会检测到使用的是哪个版本,然后使用合适的解码器。</target>
        </trans-unit>
        <trans-unit id="1fab39fc6a9980decfad2e7adaa7dbca6690bf5b" translate="yes" xml:space="preserve">
          <source>This weighted scheduler utilization will reach &lt;code&gt;1.0&lt;/code&gt; when schedulers are active the same amount of time as maximum available CPU time. If more schedulers exist than available logical processors, this value may be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">当调度程序处于活动状态的时间与最大可用CPU时间相同时，此加权调度程序利用率将达到 &lt;code&gt;1.0&lt;/code&gt; 。如果存在比可用逻辑处理器更多的调度程序，则此值可能大于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f1c0ecf9835b048ce7fdf3cb11bce5cf430e0d" translate="yes" xml:space="preserve">
          <source>This will be transform into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这将转换为对 &lt;code&gt;my_table&lt;/code&gt; 的一次调用：</target>
        </trans-unit>
        <trans-unit id="5959df48b0bcfac9f4ae84eabd6aeaab1c573506" translate="yes" xml:space="preserve">
          <source>This will be transform into two calls to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这将转换为对 &lt;code&gt;my_table&lt;/code&gt; 的两次调用：</target>
        </trans-unit>
        <trans-unit id="b0938e7a4bcaf966d8f8e1648d8bf77602bdb131" translate="yes" xml:space="preserve">
          <source>This will create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">这将在当前目录中创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="a8c674397ac895af2f7b4229947a7481b00df7c1" translate="yes" xml:space="preserve">
          <source>This will extract the string literal &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; into the variable &lt;code&gt;Foo&lt;/code&gt;. Note the use of the anonymous variable &lt;code&gt;9090&lt;/code&gt; to ignore the line number. To match and also bind a metavariable that must be an integer literal, we can use the convention of ending the integer with a 9, turning it into a Q-prefixed variable on the Erlang level (see the previous section).</source>
          <target state="translated">这会将字符串文字 &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; 提取到变量 &lt;code&gt;Foo&lt;/code&gt; 中。请注意使用匿名变量 &lt;code&gt;9090&lt;/code&gt; 来忽略行号。为了匹配并绑定必须是整数文字的元变量，我们可以使用以下约定：以9结尾的整数，将其转换为Erlang级别上的Q前缀变量（请参见上一节）。</target>
        </trans-unit>
        <trans-unit id="6844398e7182f73065c78df4a613dbb5c67fbf34" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;copy_save&lt;/code&gt; option is enabled; see &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt;.</source>
          <target state="translated">如果启用了 &lt;code&gt;copy_save&lt;/code&gt; 选项，则此操作将失败；参见 &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161516cb1d32cdac4670da18a1c368a544091541" translate="yes" xml:space="preserve">
          <source>This will have the following effect:</source>
          <target state="translated">这将产生以下效果:</target>
        </trans-unit>
        <trans-unit id="741ddd866b7f0cb141911125a2b18ae0245fffe3" translate="yes" xml:space="preserve">
          <source>This will produce a beam.smp.debug executable. The file are installed along side with the normal (opt) version &lt;code&gt;beam.smp&lt;/code&gt;.</source>
          <target state="translated">这将产生beam.smp.debug可执行文件。该文件与常规（opt）版本 &lt;code&gt;beam.smp&lt;/code&gt; 一起安装。</target>
        </trans-unit>
        <trans-unit id="4a278059021fec133659ebfed89d918e76c5e908" translate="yes" xml:space="preserve">
          <source>This will start a &lt;code&gt;Collector&lt;/code&gt;, a &lt;code&gt;Viewer&lt;/code&gt; and also start the tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The &lt;code&gt;Raw Trace Data&lt;/code&gt; is collected by the &lt;code&gt;Collector&lt;/code&gt; and a view of it is displayed on the screen by the &lt;code&gt;Viewer&lt;/code&gt;. You can define your own &quot;views&quot; of the data by implementing your own &lt;code&gt;Filter&lt;/code&gt; functions and register them in the &lt;code&gt;Viewer&lt;/code&gt;.</source>
          <target state="translated">这将启动一个 &lt;code&gt;Collector&lt;/code&gt; ，一个 &lt;code&gt;Viewer&lt;/code&gt; ,并且也开始跟踪 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数调用。的 &lt;code&gt;Raw Trace Data&lt;/code&gt; 是由收集的 &lt;code&gt;Collector&lt;/code&gt; 和它的一个视图显示由在屏幕上 &lt;code&gt;Viewer&lt;/code&gt; 。您可以通过实现自己的 &lt;code&gt;Filter&lt;/code&gt; 函数并将其注册到 &lt;code&gt;Viewer&lt;/code&gt; 中来定义自己的数据&amp;ldquo;视图&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f434217aa97015d51cfaae19becfd875effa6d0a" translate="yes" xml:space="preserve">
          <source>This works even if &lt;code&gt;A&lt;/code&gt; is less than &lt;code&gt;-1.0&lt;/code&gt;, since in that case, &lt;code&gt;math:sqrt/1&lt;/code&gt; is never evaluated.</source>
          <target state="translated">即使 &lt;code&gt;A&lt;/code&gt; 小于 &lt;code&gt;-1.0&lt;/code&gt; ，此方法也有效，因为在这种情况下，永远不会评估 &lt;code&gt;math:sqrt/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3252af803922384f63b13c1da6ba4644d77b472e" translate="yes" xml:space="preserve">
          <source>This works for those codecs that support partial decode of the version, currently &lt;strong&gt;text&lt;/strong&gt;, and ber_bin (&lt;code&gt;megaco_binary_encoder&lt;/code&gt; and &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt;).</source>
          <target state="translated">对于那些支持版本，当前&lt;strong&gt;文本&lt;/strong&gt;和ber_bin（ &lt;code&gt;megaco_binary_encoder&lt;/code&gt; 和 &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt; ）的部分解码的编解码器，此方法适用。</target>
        </trans-unit>
        <trans-unit id="68fb3cd1bc230ff55ec815a8606d4b126de4061a" translate="yes" xml:space="preserve">
          <source>This would give the same result as the earlier examples, namely:</source>
          <target state="translated">这样一来,就会得出与前面的例子相同的结果,即:</target>
        </trans-unit>
        <trans-unit id="f41ff74a32e2f2c5a120967bdd256a9d1fcf2924" translate="yes" xml:space="preserve">
          <source>This yields the following environment for &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">这为 &lt;code&gt;myapp&lt;/code&gt; 产生了以下环境：</target>
        </trans-unit>
        <trans-unit id="8cfb63a03667f91e2dddce0870e2cddb4d2428fc" translate="yes" xml:space="preserve">
          <source>Those that are not part of an identified script are lumped together as &quot;Common&quot;. The following is the current list of scripts:</source>
          <target state="translated">那些不属于已确定的脚本的脚本被归纳为 &quot;通用&quot;。以下是当前的脚本清单。</target>
        </trans-unit>
        <trans-unit id="e0fb7ae92ade7541465dddf7bdde5e485e470cba" translate="yes" xml:space="preserve">
          <source>Those warnings cannot be disabled (except by disabling all warnings).</source>
          <target state="translated">这些警告不能被禁用(除非禁用所有警告)。</target>
        </trans-unit>
        <trans-unit id="c351ee3b38329481117c9035b830002ad412235a" translate="yes" xml:space="preserve">
          <source>Thread identifier.</source>
          <target state="translated">线程标识符。</target>
        </trans-unit>
        <trans-unit id="472d223957fc2ad616dbfe0655959f460d590ae4" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="translated">线程选项结构传递给 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 。存在以下字段：</target>
        </trans-unit>
        <trans-unit id="2d38b72cd000a892fe63ed8ba79ccaabfe4c2e80" translate="yes" xml:space="preserve">
          <source>Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are &amp;lt; 256, but they do work in this mode. The following are the extra escape sequences:</source>
          <target state="translated">提供了三个与字符具有特定属性匹配的转义序列。在8位非UTF-8模式下，这些序列仅限于测试代码点小于256的字符，但它们在此模式下有效。以下是额外的转义序列：</target>
        </trans-unit>
        <trans-unit id="48145c695e12f789bd065e16fe1bba615544dbc8" translate="yes" xml:space="preserve">
          <source>Three network messages to execute the two-phase commit protocol</source>
          <target state="translated">执行两阶段提交协议的三个网络消息。</target>
        </trans-unit>
        <trans-unit id="5b4d080b2f7b28c85cb580a4943bbfa952b77805" translate="yes" xml:space="preserve">
          <source>Three predefined resolve functions exist: &lt;code&gt;random_exit_name/3&lt;/code&gt;, &lt;code&gt;random_notify_name/3&lt;/code&gt;, and &lt;code&gt;notify_all_name/3&lt;/code&gt;. If no &lt;code&gt;Resolve&lt;/code&gt; function is defined, &lt;code&gt;random_exit_name&lt;/code&gt; is used. This means that one of the two registered processes is selected as correct while the other is killed.</source>
          <target state="translated">存在三个预定义的解析函数： &lt;code&gt;random_exit_name/3&lt;/code&gt; ， &lt;code&gt;random_notify_name/3&lt;/code&gt; 和 &lt;code&gt;notify_all_name/3&lt;/code&gt; 。如果未定义 &lt;code&gt;Resolve&lt;/code&gt; 功能，则使用 &lt;code&gt;random_exit_name&lt;/code&gt; 。这意味着两个注册进程中的一个被选择为正确，而另一个被杀死。</target>
        </trans-unit>
        <trans-unit id="789fe986bc68eef06a581bacefa09c9f316ad600" translate="yes" xml:space="preserve">
          <source>Three types of Dets tables exist:</source>
          <target state="translated">存在三种类型的Dets表。</target>
        </trans-unit>
        <trans-unit id="de17dda2df1b0a4a41a2a36ed513ae1a8fa82e62" translate="yes" xml:space="preserve">
          <source>Three types of logs are supported: transfer logs, security logs, and error logs. The de-facto standard Common Logfile Format is used for the transfer and security logging. There are numerous statistics programs available to analyze Common Logfile Format. The Common Logfile Format looks as follows:</source>
          <target state="translated">支持三种类型的日志:传输日志、安全日志和错误日志。传输日志和安全日志使用事实上的标准通用日志文件格式。有许多统计程序可以用来分析通用日志文件格式。通用日志文件格式的样子如下。</target>
        </trans-unit>
        <trans-unit id="6e9b97eab33817fa09e3b807cdad0cad941b514c" translate="yes" xml:space="preserve">
          <source>Three-per-em space</source>
          <target state="translated">三次元空间</target>
        </trans-unit>
        <trans-unit id="353307ebea91bdeb49e95a772ca9672b8b9ff1c9" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">最大文件大小的阈值（以字节为单位）。如果超出限制，传输将中止。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81e689740a1ea2ba496a99261372d7eb5ff76c39" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">最大活动连接数的阈值。如果超出限制，则守护程序拒绝建立新连接。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5d2d9adf32dacfb55f57f6ed9d271632c69577" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</source>
          <target state="translated">最大重试次数的阈值。默认情况下,服务器/客户端在超时后最多重发5次消息。</target>
        </trans-unit>
        <trans-unit id="0ef311c86e366780b4c01dfd6e2377efaa407576" translate="yes" xml:space="preserve">
          <source>Through CTHs the results of tests and configuration functions can be manipulated. The main purpose to do this with CTHs is to allow common patterns to be abstracted out from test suites and applied to multiple test suites without duplicating any code. All the callback functions for a CTH follow a common interface described hereafter.</source>
          <target state="translated">通过CTHs可以对测试和配置函数的结果进行操作。使用CTH的主要目的是允许从测试套件中抽象出共同的模式,并应用于多个测试套件,而无需重复任何代码。一个CTH的所有回调函数都遵循下面描述的通用接口。</target>
        </trans-unit>
        <trans-unit id="0aa7d917559b259354cb862e1c7d69350b345c76" translate="yes" xml:space="preserve">
          <source>Through a trigger function with a match specification created with &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过具有 &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt; 创建的匹配规范的触发函数。</target>
        </trans-unit>
        <trans-unit id="dee8ee6675b19f7cc839a400403e3a6bdfc64698" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;Mnesia&lt;/code&gt; (on one node) can hang if a double fault occurs, that is, when two nodes crash simultaneously and one attempts to start when the other refuses to start, for example, because of a hardware error.</source>
          <target state="translated">因此， &lt;code&gt;Mnesia&lt;/code&gt; （在一个节点上）如果发生双重故障（即，两个节点同时崩溃并且一个节点尝试启动而另一个节点由于硬件错误而拒绝启动）时尝试挂起，则可能会挂起。</target>
        </trans-unit>
        <trans-unit id="08620ab1394e488e40f6d760c0e43eb52ae9ae1e" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ch3&lt;/code&gt; must be loaded before &lt;code&gt;m1&lt;/code&gt;, in the upgrade case, and conversely in the downgrade case. &lt;code&gt;m1&lt;/code&gt; is said to be &lt;strong&gt;dependent on&lt;/strong&gt;&lt;code&gt;ch3&lt;/code&gt;. In a release handling instruction, this is expressed by the &lt;code&gt;DepMods&lt;/code&gt; element:</source>
          <target state="translated">因此，在升级情况下， &lt;code&gt;ch3&lt;/code&gt; 必须在 &lt;code&gt;m1&lt;/code&gt; 之前加载，而在降级情况下，则相反。据说 &lt;code&gt;m1&lt;/code&gt; &lt;strong&gt;取决于&lt;/strong&gt; &lt;code&gt;ch3&lt;/code&gt; 。在发布处理指令中，这由 &lt;code&gt;DepMods&lt;/code&gt; 元素表示：</target>
        </trans-unit>
        <trans-unit id="f4aac5229f9aff631f4112d990ef52e941da8602" translate="yes" xml:space="preserve">
          <source>Thus, Erlang pids contain information about where the process executes. So if you know the pid of a process, the &quot;!&quot; operator can be used to send it a message disregarding if the process is on the same node or on a different node.</source>
          <target state="translated">因此,Erlang的pid包含了进程在哪里执行的信息,所以如果你知道一个进程的pid,可以用&quot;!&quot;操作符向它发送消息,而不管这个进程是在同一个节点还是在不同的节点。因此,如果你知道一个进程的pid,就可以使用&quot;!&quot;操作符向它发送一条消息,而不管这个进程是在同一个节点上还是在不同的节点上。</target>
        </trans-unit>
        <trans-unit id="6cc9ac17e54e53ed54d89ecd362584a70502cce6" translate="yes" xml:space="preserve">
          <source>Thus, each table is made up of records, where the first element is a record name and the second element of the table is a key, which identifies the particular record in that table. The combination of the table name and a key is an arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; called the OID. For more information about the relationship beween the record name and the table name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">因此，每个表都由记录组成，其中第一个元素是记录名称，表的第二个元素是关键字，它标识该表中的特定记录。表名和键的组合是两个称为OID的两个元组 &lt;code&gt;{Tab, Key}&lt;/code&gt; 。有关记录名称和表名称之间的关系的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98419cf3e6cb70f3d1ec7c30e6c6cd8e96f4569b" translate="yes" xml:space="preserve">
          <source>Thus, groups of users with identical cookie files get Erlang nodes that can communicate freely and without interference from the magic cookie system. Users who want to run nodes on separate file systems must make certain that their cookie files are identical on the different file systems.</source>
          <target state="translated">这样,拥有相同cookie文件的用户群就得到了可以自由通信的Erlang节点,而不受魔法cookie系统的干扰。用户如果想在不同的文件系统上运行节点,必须保证他们在不同文件系统上的cookie文件是相同的。</target>
        </trans-unit>
        <trans-unit id="8100fa7ba98e8e96e75fe52a1370cae3f3496b11" translate="yes" xml:space="preserve">
          <source>Thus, in Erlang the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to encode a boolean value.</source>
          <target state="translated">因此，在Erlang中，原子 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 用于编码布尔值。</target>
        </trans-unit>
        <trans-unit id="6e7ecce73f034bf35ecbb506fb930930ac4b3eff" translate="yes" xml:space="preserve">
          <source>Thus, it can be assumed that if an application wants to use tables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, the application must perform some action similar to following before it can use the tables:</source>
          <target state="translated">因此，可以假定，如果应用程序要使用表 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，则该应用程序必须执行类似于以下的某些操作才能使用表：</target>
        </trans-unit>
        <trans-unit id="7e5bc2487ff82b85d2e3b10893d75ddc6f14f8fa" translate="yes" xml:space="preserve">
          <source>Thus, knowing the allowed structure it is easy to write a program that traverses the data structure and picks the information in the xmlElements records with name date.</source>
          <target state="translated">因此,知道了允许的结构,就很容易写出一个遍历数据结构的程序,并在xmlElements记录中选取名称为date的信息。</target>
        </trans-unit>
        <trans-unit id="b2e92eacbda98564b7e1dba01abee128e6082f80" translate="yes" xml:space="preserve">
          <source>Thus, the call &lt;code&gt;ch3:alloc()&lt;/code&gt; returns the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the &lt;code&gt;gen_server&lt;/code&gt; then waits for new requests, now with an updated list of available channels.</source>
          <target state="translated">因此，调用 &lt;code&gt;ch3:alloc()&lt;/code&gt; 返回分配的通道 &lt;code&gt;Ch&lt;/code&gt; ，然后 &lt;code&gt;gen_server&lt;/code&gt; 等待新请求，现在具有可用通道的更新列表。</target>
        </trans-unit>
        <trans-unit id="9ebad642bddf4ab3db22dd4beeeeb7f4311403f9" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-COMMUNITY-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-COMMUNITY-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="a7c61a5b14ab98813376fed50c0cd8d251b07679" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-FRAMEWORK-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-FRAMEWORK-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="612f9db5bba916759b754b605a4e539b1a5e5a7e" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-NOTIFICATION-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-NOTIFICATION-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="9d1588ecea3ad2284ae9aa05caccc396d78985d5" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-STANDARD-MIB和SNMPv2-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="43f6071a8cb0a08a947926938c79fe87f3b23556" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-TARGET-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,在调用该函数后,SNMP-TARGET-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="698103ec7a5a24bef7840c9a9eb88301e5ac5c6b" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,在调用该函数后,SNMP-USER-BASED-SM-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="b154aa3e0b0b0cb0972c7b7c21e5fa2a7b63dbbc" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-VIEW-BASED-ACM-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="ece286b7b7e10c58b8006a0db1d818bda1598793" translate="yes" xml:space="preserve">
          <source>Thus, the defined callbacks are as follows:</source>
          <target state="translated">因此,定义的回调如下。</target>
        </trans-unit>
        <trans-unit id="c7283b7df46e07452f871697fbbb43dfaeb34c85" translate="yes" xml:space="preserve">
          <source>Thus, the following pattern matches all possible clauses:</source>
          <target state="translated">因此,以下模式符合所有可能的分句。</target>
        </trans-unit>
        <trans-unit id="a6da41a12dddbe97c927f5b83e0ea21b128613a3" translate="yes" xml:space="preserve">
          <source>Thus, the main representation of test sets is &lt;strong&gt;deep lists&lt;/strong&gt;, and a simple test object can be viewed as a test set containing only a single test; there is no difference between &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">因此，测试集的主要表示形式是&lt;strong&gt;深层列表&lt;/strong&gt;，一个简单的测试对象可以视为仅包含一个测试的测试集。 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;[T]&lt;/code&gt; 之间没有区别。</target>
        </trans-unit>
        <trans-unit id="72fc65dc129a4472605c016017814aa86198846c" translate="yes" xml:space="preserve">
          <source>Thus, the module is called &lt;strong&gt;tut&lt;/strong&gt;. Notice the full stop &quot;.&quot; at the end of the line. The files which are used to store the module must have the same name as the module but with the extension &quot;.erl&quot;. In this case the file name is &lt;code&gt;tut.erl&lt;/code&gt;. When using a function in another module, the syntax &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; is used. So the following means call function &lt;code&gt;double&lt;/code&gt; in module &lt;code&gt;tut&lt;/code&gt; with argument &quot;10&quot;.</source>
          <target state="translated">因此，该模块称为&lt;strong&gt;tut&lt;/strong&gt;。注意句号&amp;ldquo;。&amp;rdquo;在该行的末尾。用于存储模块的文件必须与模块具有相同的名称，但扩展名为&amp;ldquo; .erl&amp;rdquo;。在这种情况下，文件名是 &lt;code&gt;tut.erl&lt;/code&gt; 。在另一个模块中使用函数时，将使用语法 &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; 。因此，以下方法意味着在模块 &lt;code&gt;tut&lt;/code&gt; 中使用参数&amp;ldquo; 10&amp;rdquo; 来调用 &lt;code&gt;double&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c34ce3a6ce18ac5cd93d950cae3e6a6b1eaefbd7" translate="yes" xml:space="preserve">
          <source>Thus, two instances of the application run simultaneously during the takeover, so that data can be transferred from the old to the new instance. If this is not an acceptable behavior, parts of the old instance can be shut down when the new instance is started. However, the application cannot be stopped entirely, at least the top supervisor must remain alive.</source>
          <target state="translated">因此,在接管过程中,应用程序的两个实例同时运行,因此数据可以从旧实例转移到新实例。如果这不是一种可接受的行为,可以在新实例启动时关闭旧实例的部分内容。但是,应用程序不能完全停止,至少顶层主管必须保持活着。</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="495255dc624907e5a1daae0dcc0d862cd07a65e4" translate="yes" xml:space="preserve">
          <source>Tidies Erlang source files in a directory and its subdirectories.</source>
          <target state="translated">整理一个目录及其子目录中的Erlang源文件。</target>
        </trans-unit>
        <trans-unit id="5ab18872f1a912f1810a74934cd2ae2c9eab483f" translate="yes" xml:space="preserve">
          <source>Tidies a syntax tree representation of a module definition. The given &lt;code&gt;Forms&lt;/code&gt; may be either a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. In either case, &lt;code&gt;Forms&lt;/code&gt; must represent a single complete module definition. The returned syntax tree has type &lt;code&gt;form_list&lt;/code&gt; and represents a tidied-up version of the same source code.</source>
          <target state="translated">整理模块定义的语法树表示形式。给定的 &lt;code&gt;Forms&lt;/code&gt; 可以是 &lt;code&gt;form_list&lt;/code&gt; 类型的单个语法树，也可以是表示&amp;ldquo;程序形式&amp;rdquo;的语法树列表。无论哪种情况， &lt;code&gt;Forms&lt;/code&gt; 必须代表一个完整的模块定义。返回的语法树的类型为 &lt;code&gt;form_list&lt;/code&gt; ,并表示同一源代码的整理版本。</target>
        </trans-unit>
        <trans-unit id="f1ca9281bec4536e142232511847b2d622b54efd" translate="yes" xml:space="preserve">
          <source>Tidies an Erlang source code file.</source>
          <target state="translated">整理一个Erlang源代码文件。</target>
        </trans-unit>
        <trans-unit id="82f374f21b06bcdcda1afc18f61cb6cebcc8d024" translate="yes" xml:space="preserve">
          <source>Tidies and pretty-prints Erlang source code, removing unused functions, updating obsolete constructs and function calls, etc.</source>
          <target state="translated">整理并漂亮地打印Erlang源代码,删除未使用的函数,更新过时的构造和函数调用等。</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="a82ad5fd600ff000d4dd1a4b75dec09bd53099b8" translate="yes" xml:space="preserve">
          <source>Time in milli-seconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="fb90c3d94bbbbb48a0690451d16d4a2746e6cf58" translate="yes" xml:space="preserve">
          <source>Time in milliseconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="52f73c9f88768be27ae1df301f0781defb2c8b55" translate="yes" xml:space="preserve">
          <source>Time interval (in seconds) between each update of the display.</source>
          <target state="translated">显示屏每次更新之间的时间间隔(秒)。</target>
        </trans-unit>
        <trans-unit id="aa2bb96c7dd2c54fd6b747929cbd2b7c505afa22" translate="yes" xml:space="preserve">
          <source>Time is in milliseconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="9335c98c7b128731a14ad90889a8a634ba7a0e3f" translate="yes" xml:space="preserve">
          <source>Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT).</source>
          <target state="translated">如果根据当前时区和夏令时调整时间,则为当地时间。如果时间反映的是零经度的时间,而不根据夏令时进行任何调整,则为世界时间。世界协调时间(UTC)也称为格林尼治标准时间(GMT)。</target>
        </trans-unit>
        <trans-unit id="778cab80afb8fbb53cb2e3770f0d9802c84b4243" translate="yes" xml:space="preserve">
          <source>Time is shown as percentage of total time and as absolute time.</source>
          <target state="translated">时间以总时间的百分比和绝对时间显示。</target>
        </trans-unit>
        <trans-unit id="bfab7fde2f2bd1c95dae042160e5b78de938455d" translate="yes" xml:space="preserve">
          <source>Time is vital to an Erlang program and, more importantly, &lt;strong&gt;correct&lt;/strong&gt; time is vital to an Erlang program. As Erlang is a language with soft real-time properties and we can express time in our programs, the Virtual Machine and the language must be careful about what is considered a correct time and in how time functions behave.</source>
          <target state="translated">时间对于Erlang程序至关重要，更重要的是，&lt;strong&gt;正确的&lt;/strong&gt;时间对于Erlang程序至关重要。由于Erlang是一种具有软实时属性的语言，并且我们可以在程序中表达时间，因此虚拟机和该语言必须谨慎选择正确的时间以及时间函数的行为。</target>
        </trans-unit>
        <trans-unit id="dfb8ee1d3368aa29179a6d65ecd926cdeee8b67e" translate="yes" xml:space="preserve">
          <source>Time of failure.</source>
          <target state="translated">失败的时间。</target>
        </trans-unit>
        <trans-unit id="e5b5ff320546cded57bcdfd8e9154e88bfce347b" translate="yes" xml:space="preserve">
          <source>Time since &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt;. Epoch is defined to be 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt;, 1970-01-01. &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; is defined to be exactly 86400 seconds long. Strangely enough, Epoch is defined to be a time in UTC, and UTC has another definition of how long a day is. Quoting the Open Group &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt;. The effect of this is that when an UTC leap second is inserted, POSIX time either stops for a second, or repeats the last second. If an UTC leap second would be deleted (which has not happened yet), POSIX time would make a one second leap forward.</source>
          <target state="translated">自 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt; 以来的时间。时代被定义为00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; ，1970-01-01。 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; 定义为正好是86400秒。奇怪的是，Epoch被定义为UTC时间，而UTC还定义了一天的时间。引用开放组 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt; 。这样的效果是，当插入UTC leap秒时，POSIX时间要么停止一秒，要么重复最后一秒。如果UTC leap秒将被删除（尚未发生），则POSIX时间将向前跳一秒。</target>
        </trans-unit>
        <trans-unit id="daff1c5051fc31c193cbc0ef30cf4e11a8fa0acc" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">花时间忙于等待。这也是调度器在使用 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 时不再报告其处于活动状态的状态。因此，如果您将除此状态和睡眠状态之外的所有其他状态相加，然后在线程中将其除以所有时间，则应该得到与 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 分数非常相似的信息。没有额外的状态，这一次是 &lt;code&gt;other&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="4b70b59840bac36480b4ca278b19551bc7ff7ba0" translate="yes" xml:space="preserve">
          <source>Time spent checking for new I/O events.</source>
          <target state="translated">检查新的I/O事件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="f8c4236fa95ff532dbcc0e2d31ef284b6605be9f" translate="yes" xml:space="preserve">
          <source>Time spent doing fullsweep garbage collection. Without extra states this time is part of the &lt;code&gt;gc&lt;/code&gt; state.</source>
          <target state="translated">花时间进行全清理垃圾收集。没有额外的状态，这一次是 &lt;code&gt;gc&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="804fe3e4c31d22ca440eb466bced64dac260645c" translate="yes" xml:space="preserve">
          <source>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</source>
          <target state="translated">做垃圾收集所花费的时间。当启用额外状态时,这是做非全扫垃圾收集所花费的时间。</target>
        </trans-unit>
        <trans-unit id="f0d5415566936904747ef14c0c4e3fb853196c06" translate="yes" xml:space="preserve">
          <source>Time spent doing unaccounted things.</source>
          <target state="translated">做不明事理的时间。</target>
        </trans-unit>
        <trans-unit id="4ba30f1fc2208657042880d6015e182708b6ae95" translate="yes" xml:space="preserve">
          <source>Time spent executing ETS BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">执行ETS BIF所花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="6f0aba2d54a382bffda8610e637bf0f9265a1fa2" translate="yes" xml:space="preserve">
          <source>Time spent executing Erlang processes.</source>
          <target state="translated">执行Erlang进程的时间。</target>
        </trans-unit>
        <trans-unit id="2140217ef427aad1b621513a3b193759d78a1510" translate="yes" xml:space="preserve">
          <source>Time spent executing ports.</source>
          <target state="translated">执行端口的时间。</target>
        </trans-unit>
        <trans-unit id="1d9aa0e3f8d5f8534bd40659e4d0e67ab0101833" translate="yes" xml:space="preserve">
          <source>Time spent handling auxiliary jobs.</source>
          <target state="translated">处理辅助工作的时间。</target>
        </trans-unit>
        <trans-unit id="18b77c82a332110e23d9be0001f08986fee15519" translate="yes" xml:space="preserve">
          <source>Time spent in BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">在BIF中花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="bcdc57b7f7275d059418c6711b15d167f486f63c" translate="yes" xml:space="preserve">
          <source>Time spent in NIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">NIF中花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="4050018617b293ffdfb42ee633136a70a84f563a" translate="yes" xml:space="preserve">
          <source>Time spent managing memory. Without extra states this time is spread out over all other states.</source>
          <target state="translated">管理内存的时间。如果没有额外的状态,这个时间就会被分散到其他所有状态中。</target>
        </trans-unit>
        <trans-unit id="9c01fc3b7f3c2c3c0d6942008a58943e7689d103" translate="yes" xml:space="preserve">
          <source>Time spent managing timers. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">花时间管理计时器。没有额外的状态，这一次是 &lt;code&gt;other&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="219f1ac61c024af183643b65bf00f27585517b49" translate="yes" xml:space="preserve">
          <source>Time spent sending messages (processes only). Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">发送消息所花费的时间（仅用于进程）。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="cbdb8b8de682894a050f647f9b6f67984322b3e7" translate="yes" xml:space="preserve">
          <source>Time spent sleeping.</source>
          <target state="translated">睡觉的时间。</target>
        </trans-unit>
        <trans-unit id="5e12873ae797e4ba07d58c20986f4c5eb0d01fbc" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages consist of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">概要文件消息中的时间戳由 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 和单调递增的整数组成。时间戳（Ts）与 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="0a74926d30453b95a42997402e366f9dbba46f4a" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages include a time stamp (Ts) that has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;. This is also the default if no time stamp flag is specified. If &lt;code&gt;cpu_timestamp&lt;/code&gt; has been enabled through &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, this also effects the time stamp produced in profiling messages when flag &lt;code&gt;timestamp&lt;/code&gt; is enabled.</source>
          <target state="translated">配置文件消息中的时间戳包括一个时间戳（Ts），该时间戳具有与 &lt;code&gt;erlang:now()&lt;/code&gt; 返回的形式相同的形式。如果未指定时间戳标志，则这也是默认设置。如果已通过 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 启用了 &lt;code&gt;cpu_timestamp&lt;/code&gt; ,则当启用了标记时间戳记时，这也会影响性能分析消息中产生的 &lt;code&gt;timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22076e8ed9090afa79ae14afc1154da3fcea7d53" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages use &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">配置文件消息中的时间戳使用 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 。时间戳（Ts）与 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="08ca334e927c4c6c13a180ed022f0e1809c6b0ea" translate="yes" xml:space="preserve">
          <source>Time unit expressed in parts per second. That is, the time unit equals &lt;code&gt;1/PartsPerSecond&lt;/code&gt; second.</source>
          <target state="translated">时间单位表示为每秒的零件数。即，时间单位等于 &lt;code&gt;1/PartsPerSecond&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="56955f846ca14fda201279a48f5480070c862756" translate="yes" xml:space="preserve">
          <source>Time unit of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 的时间单位。</target>
        </trans-unit>
        <trans-unit id="ddf7ef9b043acd2fefcc767917bfb64bbe68691e" translate="yes" xml:space="preserve">
          <source>Time unit of returned value.</source>
          <target state="translated">返回值的时间单位。</target>
        </trans-unit>
        <trans-unit id="c31fd1a438289cad94f807ff509ea2830cb0a280" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 来创建设置计时器的时间。计时器应该传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cba69c610e8e4d4cb1aafc070b3b00791654be26" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 来创建设置计时器的时间。计时器应该传递给 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ead486368f8803155ffc6453947e99e4019e5bc" translate="yes" xml:space="preserve">
          <source>Time warp safe code can handle a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">时间隧道安全的代码可以处理一个 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75c9ade9b7ea54157fc5ea15b058fcb35255e656" translate="yes" xml:space="preserve">
          <source>Time when the event record was created.</source>
          <target state="translated">事件记录的创建时间。</target>
        </trans-unit>
        <trans-unit id="1078e1766373df8f70c0326e90a0881d10d2001d" translate="yes" xml:space="preserve">
          <source>Time when the trace was generated. Same as event_ts if omitted in trace data.</source>
          <target state="translated">追踪数据产生的时间。如果在跟踪数据中省略,则与event_ts相同。</target>
        </trans-unit>
        <trans-unit id="7c54440dd4618f7bc17db7c59ce90a91687e0a3f" translate="yes" xml:space="preserve">
          <source>Time-constrained tracing</source>
          <target state="translated">时间限制跟踪</target>
        </trans-unit>
        <trans-unit id="dad879fd6c0ee22983f6de70e89c35317fb40e21" translate="yes" xml:space="preserve">
          <source>Time-out expired.</source>
          <target state="translated">超时已过。</target>
        </trans-unit>
        <trans-unit id="3e8c25c48b5132875c91d0c03a35c580928a7337" translate="yes" xml:space="preserve">
          <source>Time-out time for the request.</source>
          <target state="translated">请求的超时时间。</target>
        </trans-unit>
        <trans-unit id="dbff00965ebcca637b30964828cca5002698389b" translate="yes" xml:space="preserve">
          <source>Time-out timers &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events.</source>
          <target state="translated">处理超时计时器 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 。确保零时间的超时在任何外部尚未接收的事件发生之前传递到状态机，因此，如果请求了这样的超时，则将相应的零超时事件排队作为最新的接收事件；那是在已经排队的事件（例如插入和推迟的事件）之后。</target>
        </trans-unit>
        <trans-unit id="921bd14fe959f56d9bf6ef39fbc93c256e6bb1db" translate="yes" xml:space="preserve">
          <source>Time-out, in milliseconds, for establishing an association</source>
          <target state="translated">建立联系的超时时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="b9d894573097754c7b54a6191c10c2264d5de941" translate="yes" xml:space="preserve">
          <source>Timeout ::</source>
          <target state="translated">超时:。</target>
        </trans-unit>
        <trans-unit id="9ba0fea57692bed3e35ebe6f8f6d8f58f2ad3a37" translate="yes" xml:space="preserve">
          <source>Timeout :: timeout()) -&amp;gt;</source>
          <target state="translated">超时:: timeout（））-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fd55cd4f150e662912da414d712d8565cc5d6ef" translate="yes" xml:space="preserve">
          <source>Timeout = &lt;code&gt;non_neg_integer()&lt;/code&gt;</source>
          <target state="translated">超时= &lt;code&gt;non_neg_integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c83fda5023992a3a755c63b7feecf8cc4bb563b5" translate="yes" xml:space="preserve">
          <source>Timeout has expired.</source>
          <target state="translated">超时已过。</target>
        </trans-unit>
        <trans-unit id="4de3dd3689e574562fe201d283c89d77aad9ff30" translate="yes" xml:space="preserve">
          <source>Timeout set the maximum time in milliseconds that each server request may take.</source>
          <target state="translated">超时设置每个服务器请求可能需要的最大时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="0c72d1236b15e71c6081373a09d082eddd39e1e9" translate="yes" xml:space="preserve">
          <source>Timeout time for the call proxy.</source>
          <target state="translated">呼叫代理的超时时间。</target>
        </trans-unit>
        <trans-unit id="b5240d69e014aa8db2761b61b654dac666884a70" translate="yes" xml:space="preserve">
          <source>Timeout) -&amp;gt;</source>
          <target state="translated">超时）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cbe7ffd10c56674d0aeb143b8aef6a19536cbe9f" translate="yes" xml:space="preserve">
          <source>Timer functions.</source>
          <target state="translated">定时器功能。</target>
        </trans-unit>
        <trans-unit id="5775c0fa857a175458a6f31fe323d1c61544a03a" translate="yes" xml:space="preserve">
          <source>Timers and re-send of messages will be handled on locally on one node, that is node(1), in order to avoid unnecessary transfer of data between the Erlang nodes.</source>
          <target state="translated">定时器和重新发送消息将在本地的一个节点,即节点(1)上处理,以避免Erlang节点之间不必要的数据传输。</target>
        </trans-unit>
        <trans-unit id="345e4b38e568b767b30f56f4731767a882691f68" translate="yes" xml:space="preserve">
          <source>Timestamp = {MegaSecs, Secs, MicroSecs}</source>
          <target state="translated">时间戳={MegaSecs,Secs,MicroSecs}。</target>
        </trans-unit>
        <trans-unit id="15a044fe233b5f5d8f3f995d7e5a1a639fcad92c" translate="yes" xml:space="preserve">
          <source>Timestamps are formatted according to RFC3339, and the time designator is the character used as date and time separator.</source>
          <target state="translated">时间戳是根据RFC3339格式化的,时间代号是作为日期和时间分隔符的字符。</target>
        </trans-unit>
        <trans-unit id="ec489097f09779c8f0337c7ffff14c271f605260" translate="yes" xml:space="preserve">
          <source>Timetrap values can be extended with a multiplier value specified at startup with option &lt;code&gt;multiply_timetraps&lt;/code&gt;. It is also possible to let the test server decide to scale up timetrap time-out values automatically. That is, if tools such as &lt;code&gt;cover&lt;/code&gt; or &lt;code&gt;trace&lt;/code&gt; are running during the test. This feature is disabled by default and can be enabled with start option &lt;code&gt;scale_timetraps&lt;/code&gt;.</source>
          <target state="translated">Timetrap值可以用在启动时与选项指定的乘数值被扩展 &lt;code&gt;multiply_timetraps&lt;/code&gt; 。也可以让测试服务器决定自动扩展超时超时值。也就是说，如果工具，如 &lt;code&gt;cover&lt;/code&gt; 或 &lt;code&gt;trace&lt;/code&gt; 在测试过程中运行。此功能默认情况下处于禁用状态，可以通过启动选项 &lt;code&gt;scale_timetraps&lt;/code&gt; 启用。</target>
        </trans-unit>
        <trans-unit id="ce4a7717f17e9b8af076c5d38d2f59e28a523086" translate="yes" xml:space="preserve">
          <source>Tirhuta</source>
          <target state="translated">Tirhuta</target>
        </trans-unit>
        <trans-unit id="b51456deb293c14e281cc125141b1ca93bd63d71" translate="yes" xml:space="preserve">
          <source>Title case letter</source>
          <target state="translated">职称论文</target>
        </trans-unit>
        <trans-unit id="175f9c3cbfadc16808edf4696a9a651beef5a26c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - client side</source>
          <target state="translated">Tls/dtls选项说明-客户端。</target>
        </trans-unit>
        <trans-unit id="ebe960548ac60cdb2adcef7ca8456b9e2d23126c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - server side</source>
          <target state="translated">Tls/dtls选项说明-服务器端</target>
        </trans-unit>
        <trans-unit id="bf91222de5df25eb68a0c8123513399e374daae1" translate="yes" xml:space="preserve">
          <source>To &quot;teach&quot; the function how to extract, you can give a fun which replaces the default extraction function. The &lt;code&gt;fqdn_fun&lt;/code&gt; takes one argument and returns either a &lt;code&gt;string()&lt;/code&gt; to be matched to each CN-name or the atom &lt;code&gt;default&lt;/code&gt; which will invoke the default fqdn extraction function. The return value &lt;code&gt;undefined&lt;/code&gt; removes the current URI from the fqdn extraction.</source>
          <target state="translated">要&amp;ldquo;教&amp;rdquo;该函数如何提取，您可以尝试替换默认的提取函数。所述 &lt;code&gt;fqdn_fun&lt;/code&gt; 接收一个参数并返回任一 &lt;code&gt;string()&lt;/code&gt; 被匹配到每个CN-名称或原子 &lt;code&gt;default&lt;/code&gt; 这将调用默认FQDN提取功能。返回值 &lt;code&gt;undefined&lt;/code&gt; 从fqdn提取中删除当前URI。</target>
        </trans-unit>
        <trans-unit id="c6ddde9755b765c3b046311bcbccd6ae209f1079" translate="yes" xml:space="preserve">
          <source>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; instead of the simplified functions &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">要访问此类表，不能使用简化的访问功能（如前所述）。例如，将订户记录写入表需要功能 &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; 而不是简化的功能 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fff8dcb832da82946e10018f4faeadf19cfc862a" translate="yes" xml:space="preserve">
          <source>To acess the record in your callback-module use:</source>
          <target state="translated">要访问回调模块中的记录,请使用。</target>
        </trans-unit>
        <trans-unit id="2e9f9ccb32571596628f903ebec0197042453a6d" translate="yes" xml:space="preserve">
          <source>To achieve authentication and privacy, the client and server perform a TLS/DTLS handshake procedure before transmitting or receiving any data. During the handshake, they agree on a protocol version and cryptographic algorithms, generate shared secrets using public key cryptographies, and optionally authenticate each other with digital certificates.</source>
          <target state="translated">为了实现认证和隐私,客户端和服务器在传输或接收任何数据之前,都要执行TLS/DTLS握手程序。在握手过程中,双方就协议版本和加密算法达成一致,使用公钥加密技术生成共享秘密,并可选择使用数字证书对对方进行认证。</target>
        </trans-unit>
        <trans-unit id="0ec1db4ecbaf3ec0b305eae994234d479d4f46e8" translate="yes" xml:space="preserve">
          <source>To act as a timetrap. The time-out is triggered when the function returns.</source>
          <target state="translated">起到一个定时器的作用。函数返回时触发超时。</target>
        </trans-unit>
        <trans-unit id="589688126179f4b6262587b2faac1c9d33d97234" translate="yes" xml:space="preserve">
          <source>To activate the code coverage support, specify the name of the cover specification file as you start &lt;code&gt;Common Test&lt;/code&gt;. Do this by using flag &lt;code&gt;-cover&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">要激活代码覆盖支持，请在启动 &lt;code&gt;Common Test&lt;/code&gt; 时指定覆盖规格文件的名称。通过将标志 &lt;code&gt;-cover&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 一起使用来执行此操作，例如：</target>
        </trans-unit>
        <trans-unit id="9cae8d843ee99890bf287306d3e1fa2ea6334285" translate="yes" xml:space="preserve">
          <source>To actor, such as receiver of message.</source>
          <target state="translated">对行为人,如信息的接收者。</target>
        </trans-unit>
        <trans-unit id="b7c67d81ad5962900cef3025ec2c90eb9d886e13" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加disk_log处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="bc71d9dc8116b79c66537800da31d34775d71f00" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加标准处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="d25bba7220a4f7baf1911b739eb15c54b0c0b82c" translate="yes" xml:space="preserve">
          <source>To add hipe options, write like this from the Erlang shell:</source>
          <target state="translated">要添加hipe选项,可以在Erlang shell中这样写。</target>
        </trans-unit>
        <trans-unit id="3baa48763297e23c94a7b912bd0879afc5570f44" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">要一次将一个文件添加到打开的tar文件中，请使用函数 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 。添加完文件后，请使用函数 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 关闭tar文件。</target>
        </trans-unit>
        <trans-unit id="a84e38b55e72c3e97104e0980726fd48cb3019f6" translate="yes" xml:space="preserve">
          <source>To add or remove functions to the set of traced functions, use &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;.</source>
          <target state="translated">要将函数添加或删除到跟踪函数集中，请使用 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fda79af0ac4d5d28c0ded42a7d7b009f4b62fd23" translate="yes" xml:space="preserve">
          <source>To add or remove one or more processes to the set of traced processes, use &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将一个或多个进程添加或删除到一组跟踪的进程中，请使用 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd9ff12ed931dadbc8c2436f103539b09520bf39" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; to &lt;strong&gt;request unloading&lt;/strong&gt; to wait for &lt;strong&gt;actual unloading&lt;/strong&gt;, &lt;code&gt;monitor&lt;/code&gt; triggers can be specified in much the same way as when loading. However, as &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this function seldom are interested in more than decrementing the reference counts, monitoring is seldom needed.</source>
          <target state="translated">为了让 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 来&lt;strong&gt;请求卸载&lt;/strong&gt;等待&lt;strong&gt;实际的卸载&lt;/strong&gt;， &lt;code&gt;monitor&lt;/code&gt; 触发器可以在几乎相同的方式指定时加载。但是，由于此功能的 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 对减少参考计数的兴趣很少，因此很少需要监视。</target>
        </trans-unit>
        <trans-unit id="59bb251ccc89a2f6d964901c5abf9140c03fcff3" translate="yes" xml:space="preserve">
          <source>To avoid copying data when a large binary is sent or returned from the driver to an Erlang process, the driver must first allocate the binary and then send it to an Erlang process in some way.</source>
          <target state="translated">为了避免当一个大的二进制文件从驱动程序发送或返回到Erlang进程时复制数据,驱动程序必须首先分配二进制文件,然后以某种方式将其发送给Erlang进程。</target>
        </trans-unit>
        <trans-unit id="2865a7885b23338eb552d918abbacdfb214f7e88" translate="yes" xml:space="preserve">
          <source>To avoid copying the result in each iteration, build the list in reverse order and reverse the list when you are done:</source>
          <target state="translated">为了避免在每次迭代中复制结果,按相反的顺序建立列表,并在完成后将列表反过来。</target>
        </trans-unit>
        <trans-unit id="0e09f8fda1e6fc4cf2056ba424646d85461e4106" translate="yes" xml:space="preserve">
          <source>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify &lt;code&gt;UpFromVsn&lt;/code&gt; and &lt;code&gt;DownToVsn&lt;/code&gt;. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions &lt;code&gt;2.1.x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any number:</source>
          <target state="translated">为了避免重复执行升级指令，允许使用正则表达式指定 &lt;code&gt;UpFromVsn&lt;/code&gt; 和 &lt;code&gt;DownToVsn&lt;/code&gt; 。要被视为正则表达式，必须将版本标识符指定为二进制。例如，以下匹配所有版本 &lt;code&gt;2.1.x&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是任意数字：</target>
        </trans-unit>
        <trans-unit id="f3e4e6304ab6854db5a3171fca0bb16d781ed384" translate="yes" xml:space="preserve">
          <source>To avoid hanging on open ports, use function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">为避免挂在打开的端口上，请改用 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="31d3d102c2bccbc776e3cf95a6211839f76eac95" translate="yes" xml:space="preserve">
          <source>To avoid hard-coding data values related to the test and/or System Under Test (SUT) in the test suites, the data can instead be specified through configuration files or strings that &lt;code&gt;Common Test&lt;/code&gt; reads before the start of a test run. External configuration data makes it possible to change test properties without modifying the test suites using the data. Examples of configuration data follows:</source>
          <target state="translated">为避免硬编码与测试套件中的测试和/或被测系统（SUT）相关的数据值，可以通过在开始测试运行之前通过 &lt;code&gt;Common Test&lt;/code&gt; 读取的配置文件或字符串来指定数据。外部配置数据使更改测试属性成为可能，而无需使用该数据修改测试套件。配置数据示例如下：</target>
        </trans-unit>
        <trans-unit id="ff4064fdc26dd0f01d01190c1a8e9d791a3c3dfd" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">为避免这种情况，我们可以考虑为每个测试启动和停止服务器。因此，我们可以将start和stop操作实现为要从 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 调用的通用函数。（请记住分别测试启动和停止功能。）该配置还可以实现为通用功能，可以与启动功能分组。最后，连接和断开客户端的测试可以分为一个测试用例。结果套件如下所示：</target>
        </trans-unit>
        <trans-unit id="da22d86c6d5a5e12ab72051b2e07972d39e8f4d0" translate="yes" xml:space="preserve">
          <source>To avoid this, you can format the internal state that gets in the error log and gets returned from &lt;code&gt;sys:get_status/1,2&lt;/code&gt; by implementing function &lt;code&gt;Module:format_status/2&lt;/code&gt;, for example like this:</source>
          <target state="translated">为了避免这种情况，您可以通过实现功能 &lt;code&gt;Module:format_status/2&lt;/code&gt; 来格式化错误日志中的内部状态以及从 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回的内部状态，例如：</target>
        </trans-unit>
        <trans-unit id="5df12af7ca1de496492c0fd73285a97d145fbb83" translate="yes" xml:space="preserve">
          <source>To be able to access a record in a fragmented table, &lt;code&gt;Mnesia&lt;/code&gt; must determine to which fragment the actual record belongs. This is done by module &lt;code&gt;mnesia_frag&lt;/code&gt;, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; callback behavior. It is recommended to read the documentation about the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; to see how &lt;code&gt;mnesia_frag&lt;/code&gt; can be used as a &lt;code&gt;mnesia_access&lt;/code&gt; callback module.</source>
          <target state="translated">为了能够访问碎片表中的记录， &lt;code&gt;Mnesia&lt;/code&gt; 必须确定实际记录属于哪个碎片。这是由模块 &lt;code&gt;mnesia_frag&lt;/code&gt; 完成的，该模块实现了 &lt;code&gt;mnesia_access&lt;/code&gt; 回调行为。建议阅读有关函数 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; 的文档，以了解如何将 &lt;code&gt;mnesia_frag&lt;/code&gt; 用作 &lt;code&gt;mnesia_access&lt;/code&gt; 回调模块。</target>
        </trans-unit>
        <trans-unit id="23318e76150bd1f0abc3ba7a0d5c11d745ade1e5" translate="yes" xml:space="preserve">
          <source>To be able to access another source than &lt;code&gt;running&lt;/code&gt;, the server must advertise &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">为了能够访问 &lt;code&gt;running&lt;/code&gt; 以外的其他资源，服务器必须发布 &lt;code&gt;:candidate&lt;/code&gt; 和/或 &lt;code&gt;:startup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b51f87825f77244a25cc2b4cb931c55829d08561" translate="yes" xml:space="preserve">
          <source>To be able to build the 64bit VM, you will also need the 64bit MinGW compiler from:</source>
          <target state="translated">为了能够构建64位的虚拟机,你还需要64位的MinGW编译器,从。</target>
        </trans-unit>
        <trans-unit id="26291c0ee8be34dfdaf3cc8ddf503e49e01d4215" translate="yes" xml:space="preserve">
          <source>To be able to handle that the peer has done a shutdown on the write side, option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful.</source>
          <target state="translated">为了能够处理对等方已在写端执行关闭操作，选项 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="e5203ca51ac51dc3846f4da1bcecefb73078a29b" translate="yes" xml:space="preserve">
          <source>To be able to match on events, the event handler module must include the header file &lt;code&gt;ct_event.hrl&lt;/code&gt;. An event is a record with the following definition:</source>
          <target state="translated">为了能够匹配事件，事件处理程序模块必须包含头文件 &lt;code&gt;ct_event.hrl&lt;/code&gt; 。事件是具有以下定义的记录：</target>
        </trans-unit>
        <trans-unit id="e3749ffc8118407236ba6c1778f7ad9201b5e31f" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">为了能够对Erlang系统时间的变化做出反应，您必须能够检测到它发生了。当前时间偏移发生更改时，Erlang系统时间就会发生更改。因此，我们引入了使用 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 监视时间偏移的可能性。更改时间偏移后，将以以下格式向监视时间偏移的进程发送消息：</target>
        </trans-unit>
        <trans-unit id="4db2f48a1319253c8231fa7c3d7cafe6f17c3bfc" translate="yes" xml:space="preserve">
          <source>To be backward compatible, &lt;code&gt;erlang:now/0&lt;/code&gt; remains &quot;as is&quot;, but &lt;strong&gt;you are strongly discouraged from using it&lt;/strong&gt;. Many use cases of &lt;code&gt;erlang:now/0&lt;/code&gt; prevents you from using the new &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, which is an important part of this new time functionality improvement.</source>
          <target state="translated">为了向后兼容， &lt;code&gt;erlang:now/0&lt;/code&gt; 保持&amp;ldquo;原样&amp;rdquo;，但是&lt;strong&gt;强烈建议您不要使用它&lt;/strong&gt;。 &lt;code&gt;erlang:now/0&lt;/code&gt; 的许多使用情况使您无法使用新的 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; ，这是此新的时间功能改进的重要组成部分。</target>
        </trans-unit>
        <trans-unit id="329020006d74005fa227c858badad448a18d5417" translate="yes" xml:space="preserve">
          <source>To be explicit, this does not work:</source>
          <target state="translated">明确地说,这是不可行的。</target>
        </trans-unit>
        <trans-unit id="921be93011160f60c5394e46977ec4ffed9f386b" translate="yes" xml:space="preserve">
          <source>To be exploited by documentation tools, such as EDoc, for generating program documentation of various forms</source>
          <target state="translated">被EDoc等文档工具利用,生成各种形式的程序文档。</target>
        </trans-unit>
        <trans-unit id="f48ee1f9c7b05fd181e829e8e9aa1a1a445ae544" translate="yes" xml:space="preserve">
          <source>To be made the default version, the newly installed release must be made &lt;strong&gt;permanent&lt;/strong&gt;, which means the previous version becomes &lt;strong&gt;old&lt;/strong&gt;:</source>
          <target state="translated">要成为默认版本，必须使新安装的发行版成为&lt;strong&gt;永久&lt;/strong&gt;版本，这意味着以前的版本已&lt;strong&gt;旧&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="e74a300fec94193e2bb8d4e9a20ec23ef6d08170" translate="yes" xml:space="preserve">
          <source>To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">待写。</target>
        </trans-unit>
        <trans-unit id="478342ff97001f76e051ff05457f998d192f9c98" translate="yes" xml:space="preserve">
          <source>To bring up all functions of the module in the listbox, click the &lt;strong&gt;OK&lt;/strong&gt; button (or press the &lt;strong&gt;Return&lt;/strong&gt; or &lt;strong&gt;Tab&lt;/strong&gt; key) when a module name has been specified,.</source>
          <target state="translated">要在列表框中显示模块的所有功能，请在指定模块名称后单击&amp;ldquo; &lt;strong&gt;确定&amp;rdquo;&lt;/strong&gt;按钮（或按&lt;strong&gt;Return&lt;/strong&gt;键或&lt;strong&gt;Tab&lt;/strong&gt;键）。</target>
        </trans-unit>
        <trans-unit id="eef5c50b74cfb025ae830e60721c49d26fd50ea9" translate="yes" xml:space="preserve">
          <source>To browse the file hierarchy and interpret the appropriate modules, either select a module name and click &lt;strong&gt;Choose&lt;/strong&gt; (or press carriage return), or double-click the module name. Interpreted modules have the type &lt;code&gt;erl src&lt;/code&gt;.</source>
          <target state="translated">要浏览文件层次结构并解释适当的模块，请选择一个模块名称，然后单击&lt;strong&gt;&amp;ldquo;选择&amp;rdquo;&lt;/strong&gt;（或按回车键），或双击该模块名称。解释的模块的类型为 &lt;code&gt;erl src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28e906186648188c00413e57f57d46fc8b55c323" translate="yes" xml:space="preserve">
          <source>To build the map &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">要构建地图 &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt; ，可以进行以下调用。</target>
        </trans-unit>
        <trans-unit id="cf559a27d31b4ba64718074dda19ef0d468cf4ad" translate="yes" xml:space="preserve">
          <source>To build the tuple &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">要建立元组 &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt; ，可以进行以下调用。</target>
        </trans-unit>
        <trans-unit id="94328137f8adf38a2d5782ddb946585047133b14" translate="yes" xml:space="preserve">
          <source>To call an arbitrary function from the release handler, the following instruction is used:</source>
          <target state="translated">要从释放处理程序中调用一个任意函数,需要使用以下指令。</target>
        </trans-unit>
        <trans-unit id="648e7cf5c6adf0a3796e8cd7e102571a81de2b0f" translate="yes" xml:space="preserve">
          <source>To call the parser generator, use the following command:</source>
          <target state="translated">要调用解析器生成器,请使用以下命令。</target>
        </trans-unit>
        <trans-unit id="754fcce3ba1a05a254eee986bb434f3d90945ecd" translate="yes" xml:space="preserve">
          <source>To change from old code to current code, a process must make a fully qualified function call.</source>
          <target state="translated">要想从旧代码变为当前代码,一个进程必须进行完全限定的函数调用。</target>
        </trans-unit>
        <trans-unit id="d43cb0d79f1f2a05084529861044cff6d89a0ac1" translate="yes" xml:space="preserve">
          <source>To change that we would need to insert action &lt;code&gt;hibernate&lt;/code&gt; in more places. For example, the state-independent &lt;code&gt;set_lock_button&lt;/code&gt; operation would have to use &lt;code&gt;hibernate&lt;/code&gt; but only in the &lt;code&gt;{open,_}&lt;/code&gt; state, which would clutter the code.</source>
          <target state="translated">要进行更改，我们需要在更多地方插入 &lt;code&gt;hibernate&lt;/code&gt; 动作。例如，与状态无关的 &lt;code&gt;set_lock_button&lt;/code&gt; 操作必须使用 &lt;code&gt;hibernate&lt;/code&gt; 但只能在 &lt;code&gt;{open,_}&lt;/code&gt; 状态下使用，这会使代码混乱。</target>
        </trans-unit>
        <trans-unit id="6d2291b5accb98f7fdfc37910802e511d2e8b381" translate="yes" xml:space="preserve">
          <source>To change the above program to one that works out the minimum value of the element in a list, you only need to write &amp;lt; instead of &amp;gt;. (But it would be wise to change the name of the function to &lt;code&gt;list_min&lt;/code&gt;.)</source>
          <target state="translated">要将上述程序更改为可以计算列表中元素最小值的程序，只需编写&amp;lt;而不是&amp;gt;。（但是将函数名称更改为 &lt;code&gt;list_min&lt;/code&gt; 是明智的。）</target>
        </trans-unit>
        <trans-unit id="df565b9f1ce8851c5511996238157f3f30542cab" translate="yes" xml:space="preserve">
          <source>To change the algorithm list, there are two options which can be used in &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;. The options could of course be used in all other functions that initiates connections.</source>
          <target state="translated">要更改算法列表，可以在 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; 使用两个选项：connect / 2,3,4和 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 。这些选项当然可以用于启动连接的所有其他功能。</target>
        </trans-unit>
        <trans-unit id="645ec6265eaa80d65a779b7caa5860ddbfdebc42" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改处理程序的日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd786bf281877aa85271503f3c21215f44679fd5" translate="yes" xml:space="preserve">
          <source>To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this:</source>
          <target state="translated">为了改变模式,使其匹配所有的手写体字符串,而不仅仅是奇数字符的字符串,我们很想把模式改成这样。</target>
        </trans-unit>
        <trans-unit id="d9656eb62d534763e64141fc6d3d1d35b0b442bc" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改Logger的主日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="866ca5de7c21c0cf7da2438015592c26ee8d81d7" translate="yes" xml:space="preserve">
          <source>To change the rules that restrict the use of an asset, the user only needs write access to the directory where the asset is.</source>
          <target state="translated">要改变限制资产使用的规则,用户只需要对资产所在的目录进行写访问。</target>
        </trans-unit>
        <trans-unit id="f5621caa72f0f06f014de0ebbc8d407830e5d0da" translate="yes" xml:space="preserve">
          <source>To check if your code is executed within a transaction, use the function &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt;. It returns &lt;code&gt;true&lt;/code&gt; when called inside a transaction context, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">要检查代码是否在事务中执行，请使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt; 。在事务上下文中调用时返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b2516b6faafd214fb55f7400a6a5d85502f13d2" translate="yes" xml:space="preserve">
          <source>To check whether a term is a fun, use the test &lt;code&gt;is_function/1&lt;/code&gt; in a guard.</source>
          <target state="translated">要检查术语是否有趣，请在防护中使用测试 &lt;code&gt;is_function/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eaab6c693a13cade1df8955eec714a449d7d24" translate="yes" xml:space="preserve">
          <source>To choose the name for the generated module, for example, because you need to compile the same specs for different encoding rules.</source>
          <target state="translated">要为生成的模块选择名称,例如,因为你需要为不同的编码规则编译相同的规范。</target>
        </trans-unit>
        <trans-unit id="1427a1da5e3a256c344db44b11dc0bba14915bf8" translate="yes" xml:space="preserve">
          <source>To close the window, click &lt;strong&gt;Done&lt;/strong&gt;.</source>
          <target state="translated">要关闭窗口，请点击&lt;strong&gt;完成&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2b49e3e39a1c8fd0e9ebc5aae6e7cbc8ac29bcce" translate="yes" xml:space="preserve">
          <source>To communicate through Telnet to the host specified by &lt;code&gt;HostNameOrIpAddress&lt;/code&gt;, use the interface functions in &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;open(Name)&lt;/code&gt; and &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt;.</source>
          <target state="translated">要通过Telnet与 &lt;code&gt;HostNameOrIpAddress&lt;/code&gt; 指定的主机进行通信，请使用 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 中的接口函数，例如 &lt;code&gt;open(Name)&lt;/code&gt; 和 &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cc63914adafb29982dfe6a5968660a48f49ce2e" translate="yes" xml:space="preserve">
          <source>To compare styles, here follows the same example using &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt;, or rather the code to replace after function &lt;code&gt;init/1&lt;/code&gt; of the &lt;code&gt;pushbutton.erl&lt;/code&gt; example file above:</source>
          <target state="translated">为了比较样式，下面是使用 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 的相同示例，或者是上面的 &lt;code&gt;pushbutton.erl&lt;/code&gt; 示例文件的 &lt;code&gt;init/1&lt;/code&gt; 函数之后要替换的代码：</target>
        </trans-unit>
        <trans-unit id="f9bdaaae36af33eb796c91b4364a72c96ddef2b5" translate="yes" xml:space="preserve">
          <source>To compare the importance of the printout to a specific verbosity level.</source>
          <target state="translated">要将打印输出的重要性与特定的动词级别进行比较。</target>
        </trans-unit>
        <trans-unit id="54ed5bb067e17e1fa5d9fb9384ef7e59e200b2f4" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;erl_interface.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">要编译代码，请在命令行上指定适当的 &lt;code&gt;-I&lt;/code&gt; 参数，或者将其添加到 &lt;code&gt;Makefile&lt;/code&gt; 中的 &lt;code&gt;CFLAGS&lt;/code&gt; 定义中，以确保C编译器知道在哪里可以找到 &lt;code&gt;erl_interface.h&lt;/code&gt; 。此路径的正确值为 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="99dbaa9ef513face3ab175774b7916127ae86697" translate="yes" xml:space="preserve">
          <source>To complete the I/O server, we only need to read and write the table in an appropriate way:</source>
          <target state="translated">为了完成I/O服务器,我们只需要用适当的方式对表进行读写即可。</target>
        </trans-unit>
        <trans-unit id="ef56703b3c226b895e39bdf18576e702cab5ae0b" translate="yes" xml:space="preserve">
          <source>To configure the Logger backend, use &lt;code&gt;Kernel configuration parameters&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; in the Logger API.</source>
          <target state="translated">要配置Logger后端，请使用Logger API中的 &lt;code&gt;Kernel configuration parameters&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8abc4316358324e879aa4fb86c41abefacbe121" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt;, which stores information, such as the hostname, node name, and IP address for later use:</source>
          <target state="translated">要连接到分布式Erlang节点，必须首先使用 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt; 初始化连接例程，该例程存储诸如主机名，节点名和IP地址之类的信息，以供以后使用：</target>
        </trans-unit>
        <trans-unit id="da53f52f9b6e989d7d98084c289e93041ec03817" translate="yes" xml:space="preserve">
          <source>To constrain the match, it is needed to replace some of the &lt;code&gt;'_'&lt;/code&gt; elements. The code for matching out all female employees looks as follows:</source>
          <target state="translated">为了限制匹配，需要替换某些 &lt;code&gt;'_'&lt;/code&gt; 元素。匹配所有女性雇员的代码如下：</target>
        </trans-unit>
        <trans-unit id="db8fca00f1d4d2a5725d8baaafde57fb1f7e09a3" translate="yes" xml:space="preserve">
          <source>To convert an error term returned from one of the functions above to a readable message, use function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将以上函数之一返回的错误项转换为可读消息，请使用function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="746ad6da742f525d196ec4f846fc54c5b8d6665f" translate="yes" xml:space="preserve">
          <source>To copy text to the clipboard, use &lt;code&gt;Ctrl-C&lt;/code&gt;.</source>
          <target state="translated">要将文本复制到剪贴板，请使用 &lt;code&gt;Ctrl-C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f0c639143cf961891408084facf2efc28d6f4b6" translate="yes" xml:space="preserve">
          <source>To copy the selected text to the clipboard, either use &lt;code&gt;Ctrl-C&lt;/code&gt;, use the menu, or press the copy button in the toolbar.</source>
          <target state="translated">要将选定的文本复制到剪贴板，请使用 &lt;code&gt;Ctrl-C&lt;/code&gt; ，使用菜单或按工具栏中的复制按钮。</target>
        </trans-unit>
        <trans-unit id="b2f36469b72d764889b8bc2c05eb18e7c2e00c94" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">要从任意iolist创建二进制列表，请使用 &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b64ef8fa41b5eb9b9fbad8912a240355ac0b560d" translate="yes" xml:space="preserve">
          <source>To create a port:</source>
          <target state="translated">要创建一个端口。</target>
        </trans-unit>
        <trans-unit id="c1b10e93b99ca718329a25a25398d8dc9f5d3821" translate="yes" xml:space="preserve">
          <source>To create the Mnesia tables, we use two records defined in &lt;code&gt;mod_auth.hrl&lt;/code&gt;, so that file must be included. &lt;code&gt;first_start/0&lt;/code&gt; creates a schema that specifies on which nodes the database is to reside. Then it starts Mnesia and creates the tables. The first argument is the name of the tables, the second argument is a list of options of how to create the table, see &lt;code&gt;mnesia(3)&lt;/code&gt;, documentation for more information. As the implementation of the &lt;code&gt;mod_auth_mnesia&lt;/code&gt; saves one row for each user, the type must be &lt;code&gt;bag&lt;/code&gt;. When the schema and the tables are created, function &lt;code&gt;mnesia:start/0&lt;/code&gt; is used to start Mnesia and waits for the tables to be loaded. Mnesia uses the directory specified as &lt;code&gt;mnesia_dir&lt;/code&gt; at startup if specified, otherwise Mnesia uses the current directory. For security reasons, ensure that the Mnesia tables are stored outside the document tree of the HTTP server. If they are placed in the directory which it protects, clients can download the tables. Only the Dets and Mnesia storage methods allow writing of dynamic user data to disk. &lt;code&gt;plain&lt;/code&gt; is a read only method.</source>
          <target state="translated">要创建Mnesia表，我们使用 &lt;code&gt;mod_auth.hrl&lt;/code&gt; 中定义的两条记录，因此必须包括该文件。 &lt;code&gt;first_start/0&lt;/code&gt; 创建一个模式，该模式指定数据库要驻留在哪些节点上。然后，它启动Mnesia并创建表。第一个参数是表的名称，第二个参数是如何创建表的选项的列表，有关更多信息，请参见 &lt;code&gt;mnesia(3)&lt;/code&gt; 文档。由于 &lt;code&gt;mod_auth_mnesia&lt;/code&gt; 的实现为每个用户节省了一行，因此类型必须为 &lt;code&gt;bag&lt;/code&gt; 。创建模式和表后，函数 &lt;code&gt;mnesia:start/0&lt;/code&gt; 用于启动Mnesia并等待表被加载。 Mnesia使用指定为 &lt;code&gt;mnesia_dir&lt;/code&gt; 如果指定了启动时的mnesia_dir，否则Mnesia使用当前目录。出于安全原因，请确保Mnesia表存储在HTTP服务器的文档树之外。如果将它们放置在受保护的目录中，则客户端可以下载表。仅Dets和Mnesia存储方法允许将动态用户数据写入磁盘。 &lt;code&gt;plain&lt;/code&gt; 是只读方法。</target>
        </trans-unit>
        <trans-unit id="7026fff802f7dac35b82f566aac0d4c80c766528" translate="yes" xml:space="preserve">
          <source>To create zip archives, use function &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;create/2,3&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要创建zip档案，请使用功能 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;create/2,3&lt;/code&gt; 来使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="96ba6751b435aa130ce8000c31fb7a59eb14a8a4" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt;Module:init(Args)&lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; is called. This function behaves like an event handler function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">为了确定第一个状态，在调用任何 &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; 程序之前，先调用 &lt;code&gt;Module:init(Args)&lt;/code&gt; 回调函数。该函数的行为类似于事件处理程序函数，但是从 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;start/3,4&lt;/code&gt; 或 &lt;code&gt;start_link/3,4&lt;/code&gt; 函数获取唯一的参数 &lt;code&gt;Args&lt;/code&gt; ，并返回 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 或 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 。如果您使用此功能中的 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 动作，则该动作将被忽略，因为没有要推迟的事件。</target>
        </trans-unit>
        <trans-unit id="51c111740de9350080c7972bf37d34610910e708" translate="yes" xml:space="preserve">
          <source>To define a release, create a &lt;strong&gt;release resource file&lt;/strong&gt;, or in short a &lt;code&gt;.rel&lt;/code&gt; file. In the file, specify the name and version of the release, which ERTS version it is based on, and which applications it consists of:</source>
          <target state="translated">要定义发行版，请创建&lt;strong&gt;发行版资源文件&lt;/strong&gt;或简称为 &lt;code&gt;.rel&lt;/code&gt; 文件。在文件中，指定发行版的名称和版本，发行版所基于的ERTS版本以及组成的应用程序：</target>
        </trans-unit>
        <trans-unit id="7dcb9b11962f5e7cb3516154fef97049f24faad8" translate="yes" xml:space="preserve">
          <source>To define an application, an &lt;strong&gt;application specification&lt;/strong&gt; is created, which is put in an &lt;strong&gt;application resource file&lt;/strong&gt;, or in short an &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">要定义应用程序，将创建一个&lt;strong&gt;应用程序规范&lt;/strong&gt;，该&lt;strong&gt;规范&lt;/strong&gt;将放置在&lt;strong&gt;应用程序资源文件中&lt;/strong&gt;，或简称为 &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="54b3619697604e99e71233bb1079a1597fb1c5a2" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the current version and previous versions of an application, an &lt;strong&gt;application upgrade file&lt;/strong&gt;, or in short an &lt;code&gt;.appup&lt;/code&gt; file is created. The file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name:</source>
          <target state="translated">要定义如何在应用程序的当前版本和以前的版本之间升级/降级，将创建一个&lt;strong&gt;应用程序升级文件&lt;/strong&gt;，或简称为 &lt;code&gt;.appup&lt;/code&gt; 文件。该文件称为 &lt;code&gt;Application.appup&lt;/code&gt; ，其中 &lt;code&gt;Application&lt;/code&gt; 是应用程序名称：</target>
        </trans-unit>
        <trans-unit id="f1125003b8abae474fb015968f66692981cd19a0" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the new version and previous versions of a release, a &lt;strong&gt;release upgrade file&lt;/strong&gt;, or in short &lt;code&gt;relup&lt;/code&gt; file, is to be created.</source>
          <target state="translated">为了定义如何在发行版的新版本和先前版本之间升级/降级，将创建发行&lt;strong&gt;版升级文件&lt;/strong&gt;或简称 &lt;code&gt;relup&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1e010624d4e818c00508b53d915d93db2cfd9d3a" translate="yes" xml:space="preserve">
          <source>To detect that the server is not the intended one, the client must additionaly perform a</source>
          <target state="translated">为了检测到服务器不是预定的服务器,客户端必须额外执行一个</target>
        </trans-unit>
        <trans-unit id="29f1578f8a4341b69585b80b12a72f76a9569382" translate="yes" xml:space="preserve">
          <source>To dig deeper into the general results, or the result of a specific test case, the operator can do so by following the links in the HTML presentation and read the major or minor log files. The &quot;all_runs.html&quot; page is a good starting point. It is located in &lt;code&gt;logdir&lt;/code&gt; and contains a link to each test run, including a quick overview (with date and time, node name, number of tests, test names, and test result totals).</source>
          <target state="translated">为了更深入地了解常规结果或特定测试用例的结果，操作员可以按照HTML演示文稿中的链接进行操作，并读取主要或次要日志文件。&amp;ldquo; all_runs.html&amp;rdquo;页面是一个很好的起点。它位于 &lt;code&gt;logdir&lt;/code&gt; 中,并包含每个测试运行的链接，包括快速概述（日期和时间，节点名称，测试数量，测试名称和测试结果总计）。</target>
        </trans-unit>
        <trans-unit id="a47ea787070856206ef8e8c44cdc817088453a80" translate="yes" xml:space="preserve">
          <source>To disable all electric commands set the variable &lt;code&gt;erlang-electric-commands&lt;/code&gt; to the empty list. In short, place the following line in your &lt;code&gt;.emacs&lt;/code&gt;-file:</source>
          <target state="translated">要禁用所有电子命令，请将变量 &lt;code&gt;erlang-electric-commands&lt;/code&gt; 设置为空列表。简而言之，将以下行放在 &lt;code&gt;.emacs&lt;/code&gt; -file中：</target>
        </trans-unit>
        <trans-unit id="2719f4e1a729a417c71b36c21728b88e49361422" translate="yes" xml:space="preserve">
          <source>To disable certain modes, do the following:</source>
          <target state="translated">要禁用某些模式,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="7d843b983a258077823d6e0bf23f5a51462fef79" translate="yes" xml:space="preserve">
          <source>To disable the automatic compilation feature, use flag &lt;code&gt;-no_auto_compile&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, or option &lt;code&gt;{auto_compile,false}&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. With automatic compilation disabled, the user is responsible for compiling the test suite modules (and any help modules) before the test run. If the modules cannot be loaded from the local file system during startup of &lt;code&gt;Common Test&lt;/code&gt;, the user must preload the modules before starting the test. &lt;code&gt;Common Test&lt;/code&gt; only verifies that the specified test suites exist (that is, that they are, or can be, loaded). This is useful, for example, if the test suites are transferred and loaded as binaries through RPC from a remote node.</source>
          <target state="translated">要禁用自动编译功能， &lt;code&gt;-no_auto_compile&lt;/code&gt; 对 &lt;code&gt;ct_run&lt;/code&gt; 使用标志-no_auto_compile，对 &lt;code&gt;ct:run_test/1&lt;/code&gt; 使用选项 &lt;code&gt;{auto_compile,false}&lt;/code&gt; 。在禁用自动编译的情况下，用户负责在测试运行之前编译测试套件模块（以及所有帮助模块）。如果在 &lt;code&gt;Common Test&lt;/code&gt; 启动期间无法从本地文件系统加载模块，则用户必须在启动测试之前预加载模块。 &lt;code&gt;Common Test&lt;/code&gt; 仅验证指定的测试套件是否存在（即它们已经或可以被加载）。例如，如果测试套件是通过RPC从远程节点传输并作为二进制文件加载的，则这很有用。</target>
        </trans-unit>
        <trans-unit id="ceb4119cc35a0a33e9fed4f8110e9358a175961e" translate="yes" xml:space="preserve">
          <source>To disconnect from the shell without exiting the Erlang system, type &lt;code&gt;Ctrl-D&lt;/code&gt;.</source>
          <target state="translated">要在不退出Erlang系统的情况下与外壳断开连接，请输入 &lt;code&gt;Ctrl-D&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b548ad5d8837c627142ce75e81cde50b52ba7141" translate="yes" xml:space="preserve">
          <source>To distinguish trace logs produced with this tool from other logs, option &lt;code&gt;file&lt;/code&gt; is used in &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;. The logs are therefore fetched to a directory named &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt;</source>
          <target state="translated">为了区分使用此工具生成的跟踪日志和其他日志，在 &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 中使用了选项 &lt;code&gt;file&lt;/code&gt; 。因此，将日志提取到名为 &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt; 的目录中</target>
        </trans-unit>
        <trans-unit id="3e40468ed8befabe466118a08bf6fc28c0f6c6eb" translate="yes" xml:space="preserve">
          <source>To do this, create a &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; that defines which applications are included in the release.</source>
          <target state="translated">为此，请创建一个 &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; ，该文件定义发行中包括哪些应用程序。</target>
        </trans-unit>
        <trans-unit id="71c169e0b7cdb28847a1d261315129b8416e6027" translate="yes" xml:space="preserve">
          <source>To do this, create an &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt;, and describe how the application is to be started and stopped.</source>
          <target state="translated">为此，创建一个 &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt; ，并描述如何启动和停止该应用程序。</target>
        </trans-unit>
        <trans-unit id="24f741a20f0106dade011b163f1322e4510ccc13" translate="yes" xml:space="preserve">
          <source>To document function interfaces</source>
          <target state="translated">要记录功能接口</target>
        </trans-unit>
        <trans-unit id="4e2effe3d108d7692e70e0242432ef9323088c3f" translate="yes" xml:space="preserve">
          <source>To downgrade from &lt;code&gt;Vsn&lt;/code&gt; to &lt;code&gt;FromVsn&lt;/code&gt;, &lt;code&gt;install_release&lt;/code&gt; must be called again:</source>
          <target state="translated">要将 &lt;code&gt;Vsn&lt;/code&gt; 降级为 &lt;code&gt;FromVsn&lt;/code&gt; ，必须再次调用 &lt;code&gt;install_release&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c857b1910cd745feb809b3e36bb979959ad34032" translate="yes" xml:space="preserve">
          <source>To each module using records, a pseudo function is added during compilation to obtain information about records:</source>
          <target state="translated">对每一个使用记录的模块,在编译时都会添加一个伪函数来获取记录的信息。</target>
        </trans-unit>
        <trans-unit id="aa7093d0b40db64d8d5dbb29fff9e15755ac8d7c" translate="yes" xml:space="preserve">
          <source>To effectively perform a batch of similar queries, you can use parameterized queries. This means that you in your SQL query string will mark the places that usually would contain values with question marks and then provide lists of values for each parameter. For instance you can use this to insert multiple rows into the &lt;code&gt;EMPLOYEE&lt;/code&gt; table while executing only a single SQL statement, for example code see &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; section in the &quot;Getting Started&quot; chapter.</source>
          <target state="translated">为了有效地执行一批类似的查询，可以使用参数化查询。这意味着您在SQL查询字符串中将用问号标记通常包含值的位置，然后为每个参数提供值列表。例如，您可以使用它在仅执行一条SQL语句的同时向 &lt;code&gt;EMPLOYEE&lt;/code&gt; 表中插入多行，例如，代码请参见 &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; 入门&amp;rdquo;一章中的&amp;ldquo;使用Erlang API&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4b87466d719f55a7d0bc6167a3744c10376e2896" translate="yes" xml:space="preserve">
          <source>To enable inlining of list functions, use option &lt;code&gt;inline_list_funcs&lt;/code&gt;.</source>
          <target state="translated">要启用列表功能的内联，请使用选项 &lt;code&gt;inline_list_funcs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51f30cb208852b09d381f6f12d3f9662837e7b58" translate="yes" xml:space="preserve">
          <source>To enable inlining, either use the option &lt;code&gt;inline&lt;/code&gt; to let the compiler decide which functions to inline, or &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; to have the compiler inline all calls to the given functions. If the option is given inside a &lt;code&gt;compile&lt;/code&gt; directive in an Erlang module, &lt;code&gt;{Name,Arity}&lt;/code&gt; can be written as &lt;code&gt;Name/Arity&lt;/code&gt;.</source>
          <target state="translated">要启用内联，无论是使用选项 &lt;code&gt;inline&lt;/code&gt; ，让编译器决定哪些函数内联，或 &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; 可以让编译器内联给定函数的调用。如果在Erlang模块的 &lt;code&gt;compile&lt;/code&gt; 指令中提供了该选项，则 &lt;code&gt;{Name,Arity}&lt;/code&gt; 可以写为 &lt;code&gt;Name/Arity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85f19bd3dcfaf9ef3d9cd6caa0e986c9a4690183" translate="yes" xml:space="preserve">
          <source>To enable or disable &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt;. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">启用或禁用 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cdfffdcb7bb12d82a554ed4fb4604dfb3bff2f" translate="yes" xml:space="preserve">
          <source>To enable or disable time correction, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要启用或禁用时间校正，请将命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="708713ed825ecbbe1d0ddcd36ee2857e998c3c1b" translate="yes" xml:space="preserve">
          <source>To enable the full power of Merl, your module needs to include the Merl header file:</source>
          <target state="translated">为了充分发挥Merl的功能,您的模块需要包含Merl头文件。</target>
        </trans-unit>
        <trans-unit id="8d53019e25d31ae87446a8faff92ab534fbdf049" translate="yes" xml:space="preserve">
          <source>To encode a list, without knowing the arity in advance:</source>
          <target state="translated">要对一个列表进行编码,而事先不知道arity。</target>
        </trans-unit>
        <trans-unit id="6cd4ebf865b6fcb86e3b3c3d86118b3cbc2de974" translate="yes" xml:space="preserve">
          <source>To ensure that &lt;code&gt;Common Test&lt;/code&gt; does not start executing tests, or closes its log files and shuts down, before the external application is ready for it, &lt;code&gt;Common Test&lt;/code&gt; can be synchronized with the application. During startup and shutdown, &lt;code&gt;Common Test&lt;/code&gt; can be suspended, simply by having a CTH evaluate a &lt;code&gt;receive&lt;/code&gt; expression in the init- or terminate function. The macros &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (the process executing the hook init function) and &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (the process executing the hook terminate function) each specifies the name of the correct &lt;code&gt;Common Test&lt;/code&gt; process to send a message to. This is done to return from the &lt;code&gt;receive&lt;/code&gt;. These macros are defined in &lt;code&gt;ct.hrl&lt;/code&gt;.</source>
          <target state="translated">为确保 &lt;code&gt;Common Test&lt;/code&gt; 在外部应用程序准备就绪之前，它不会开始执行测试或关闭其日志文件并关闭，可以将 &lt;code&gt;Common Test&lt;/code&gt; 与该应用程序同步。在启动和关闭期间，只需通过让CTH评估init-或终止函数中的 &lt;code&gt;receive&lt;/code&gt; 表达式，即可挂起 &lt;code&gt;Common Test&lt;/code&gt; 。宏 &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; （执行挂接初始化函数的进程）和 &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; （执行挂接终止函数的进程）中的每一个都指定了向其发送消息的正确的 &lt;code&gt;Common Test&lt;/code&gt; 进程的名称。这样做是为了从 &lt;code&gt;receive&lt;/code&gt; 返回。这些宏在 &lt;code&gt;ct.hrl&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="d6a3ca4567317dc34953b8a7c1cc3b757bbc4816" translate="yes" xml:space="preserve">
          <source>To ensure that a driver instance always uses the same thread, the following call can be used:</source>
          <target state="translated">为了确保驱动实例始终使用同一个线程,可以使用以下调用。</target>
        </trans-unit>
        <trans-unit id="e8b277a4b4779423015664e7a3f401ea54aeecd5" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ct:pal,2,3&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">为了确保将输出到 &lt;code&gt;stdout&lt;/code&gt; 的打印输出（或用 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;ct:pal,2,3&lt;/code&gt; 进行的打印输出）写入测试用例日志文件，而不是写入 &lt;code&gt;Common Test&lt;/code&gt; framework日志，您可以与通过匹配evvents &lt;code&gt;tc_start&lt;/code&gt; 和 &lt;code&gt;tc_done&lt;/code&gt; 的 &lt;code&gt;Common Test&lt;/code&gt; 服务器。在这些事件之间的时间段内，所有I / O均定向到测试用例日志文件。同步发送这些事件以避免潜在的计时问题（例如，恰好在来自外部进程的I / O消息通过之前关闭测试用例日志文件）。知道这一点后，您需要注意 &lt;code&gt;handle_event/2&lt;/code&gt; 回调函数不会使测试执行停止，因此可能导致意外行为。</target>
        </trans-unit>
        <trans-unit id="a63e4ff906295f7807af4b654281729a99f4d599" translate="yes" xml:space="preserve">
          <source>To execute group &lt;code&gt;tests1&lt;/code&gt; twice with different properties for &lt;code&gt;tests2&lt;/code&gt; each time:</source>
          <target state="translated">执行组 &lt;code&gt;tests1&lt;/code&gt; 具有不同属性的两次 &lt;code&gt;tests2&lt;/code&gt; 每次：</target>
        </trans-unit>
        <trans-unit id="7239843e8d90d77d86be2ae7b38276b2e33faca1" translate="yes" xml:space="preserve">
          <source>To execute the test cases in the recent test suite, type the following on the UNIX/Linux command line (assuming that the suite module is in the current working directory):</source>
          <target state="translated">要执行最近测试套件中的测试用例,在 UNIX/Linux 命令行中键入以下内容(假设套件模块在当前工作目录中)。</target>
        </trans-unit>
        <trans-unit id="15b464ff8a64913edd497cc9c55da6f1268e3b00" translate="yes" xml:space="preserve">
          <source>To explain how it works, let us examine the following code line by line:</source>
          <target state="translated">为了解释它是如何工作的,让我们逐行检查下面的代码。</target>
        </trans-unit>
        <trans-unit id="6ace97c5b62d1ba123d6323684c350a22b583d3a" translate="yes" xml:space="preserve">
          <source>To extract all files from a tar file, use function &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt;. To extract only some files or to be able to specify some more options, use function &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要从tar文件中提取所有文件，请使用函数 &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt; 。要仅提取某些文件或能够指定更多选项，请使用函数 &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d79465290c25ae2d243af5890aece9f3a5c6794" translate="yes" xml:space="preserve">
          <source>To extract files from a zip archive, use function &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;extract/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要从zip存档中提取文件，请使用功能 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;extract/1,2&lt;/code&gt; 使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="49b523abf1ecfbea37ac71cc8ad901ada87596e3" translate="yes" xml:space="preserve">
          <source>To facilitate addition or removal of algorithms the option &lt;code&gt;modify_algorithms&lt;/code&gt; is available. See the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">为了便于添加或删除算法，可以使用选项 &lt;code&gt;modify_algorithms&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="318d261f2e9e44898ab106149f1818df3611a4d0" translate="yes" xml:space="preserve">
          <source>To facilitate for instance counting of failed tries, the &lt;code&gt;State&lt;/code&gt; variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the &lt;code&gt;State&lt;/code&gt; variable has the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">为了便于例如计数失败尝试，可以使用 &lt;code&gt;State&lt;/code&gt; 变量。此状态仅针对每个连接。第一次调用pwdfun进行连接时， &lt;code&gt;State&lt;/code&gt; 变量的值为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb30040c24cb4398d4f306c6f75be49b3309b50e" translate="yes" xml:space="preserve">
          <source>To facilitate incremental MIB implementation, the tool can generate a prototype implementation for a whole MIB, or parts thereof. This allows different MIBs and management applications to be developed at the same time.</source>
          <target state="translated">为了促进MIB的增量实施,该工具可以为整个MIB或其中的一部分生成一个原型实施。这样就可以同时开发不同的MIB和管理应用程序。</target>
        </trans-unit>
        <trans-unit id="c2bbbdeeda7bd5404449757f8d9770ca2ef7aaa9" translate="yes" xml:space="preserve">
          <source>To filter only by dates, specify the empty list as the &lt;code&gt;Filters&lt;/code&gt; parameter.</source>
          <target state="translated">要仅按日期进行过滤，请将空白列表指定为&amp;ldquo; &lt;code&gt;Filters&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="630e50a14a964d68d3d5576b2cd371a11e3b187e" translate="yes" xml:space="preserve">
          <source>To find &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; in all applications &lt;code&gt;src&lt;/code&gt; directories, use either of the following lines:</source>
          <target state="translated">要在所有应用程序的 &lt;code&gt;src&lt;/code&gt; 目录中找到 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; ，请使用以下任一行：</target>
        </trans-unit>
        <trans-unit id="a6396773c2bde8a4d52d39cd61a041b4f1f183b7" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.beam&lt;/code&gt; files in all applications, use the following line:</source>
          <target state="translated">要在所有应用程序中查找所有 &lt;code&gt;.beam&lt;/code&gt; 文件，请使用以下行：</target>
        </trans-unit>
        <trans-unit id="20cf9c172afcf3da74dfc71cb0f3fcae5974105f" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in any subdirectory:</source>
          <target state="translated">要在任何子目录中找到所有 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="7ed6cec65dd2913192c7cb022d1a0950d0fa1dc6" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">要在 &lt;code&gt;src&lt;/code&gt; 或 &lt;code&gt;include&lt;/code&gt; 目录中查找所有 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="fccdf7c91c9fff2872abc1dbafd75d06a060282b" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.hrl&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">要在 &lt;code&gt;src&lt;/code&gt; 中查找所有 &lt;code&gt;.hrl&lt;/code&gt; 文件或 &lt;code&gt;include&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="8e72309f663e0cdb8ebe00ece9160cd743a20ac1" translate="yes" xml:space="preserve">
          <source>To find out which data types will be returned for the columns in a table use the function &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">要查明将为表中的列返回哪些数据类型，请使用 &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="df081f6643e87b8a4d20937b6cf7036fe456bdf3" translate="yes" xml:space="preserve">
          <source>To find preceding keys in the table, use &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的先前键，请使用 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bab05c393dca1da866e4258e15bc30ee1a82d0d1" translate="yes" xml:space="preserve">
          <source>To find subsequent keys in the table, use &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在表中查找后续键，请使用 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5305b16b9a4a45c3c66348bdacc0a4e5b3a4971f" translate="yes" xml:space="preserve">
          <source>To find the first key in the table, use &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的第一个键，请使用 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f84576968a9f5a5747d5c908246715868508fa22" translate="yes" xml:space="preserve">
          <source>To find the last key in the table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的最后一个键，请使用 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b08cebc24b1775a65769e106895c5039d3db4448" translate="yes" xml:space="preserve">
          <source>To fold a function over all files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将功能折叠到zip存档中的所有文件上，请使用function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3107d752335f18f59b4878dac8c20e1cc44001a3" translate="yes" xml:space="preserve">
          <source>To force Unicode filename translation mode on systems where this is not the default was considered experimental in Erlang/OTP R14B01. This was because the initial implementation did not ignore wrongly encoded filenames, so that raw filenames could spread unexpectedly throughout the system. As from Erlang/OTP R16B, the wrongly encoded filenames are only retrieved by special functions (such as &lt;code&gt;file:list_dir_all/1&lt;/code&gt;). Since the impact on existing code is therefore much lower it is now supported. Unicode filename translation is expected to be default in future releases.</source>
          <target state="translated">在Erlang / OTP R14B01中，尝试在非默认文件系统上强制使用Unicode文件名转换模式是试验性的。这是因为最初的实现并未忽略编码错误的文件名，因此原始文件名可能会意外地散布到整个系统中。从Erlang / OTP R16B开始，错误编码的文件名只能通过特殊功能（例如 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; ）来检索。由于对现有代码的影响要小得多，因此现在可以支持。Unicode文件名转换在将来的版本中有望成为默认设置。</target>
        </trans-unit>
        <trans-unit id="286ba4fce2df7e992d24f0fa54be1d66081e5721" translate="yes" xml:space="preserve">
          <source>To format the printout according to a user-specific HTML Style Sheet (CSS).</source>
          <target state="translated">根据用户特定的HTML样式表(CSS)来格式化打印输出。</target>
        </trans-unit>
        <trans-unit id="d829ca082ad3db2ea55b112c3bcb9aa6980d21fb" translate="yes" xml:space="preserve">
          <source>To forsee the effect of an option there is an experimental function &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt;. It mangles the options &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt; in the same way as &lt;code&gt;ssh:dameon&lt;/code&gt;, &lt;code&gt;ssh:connect&lt;/code&gt; and their friends does.</source>
          <target state="translated">为了预见一个选项的效果，有一个实验函数 &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt; 。它以与 &lt;code&gt;ssh:dameon&lt;/code&gt; ， &lt;code&gt;ssh:connect&lt;/code&gt; 及其朋友相同的方式来处理选项 &lt;code&gt;preferred_algorithms&lt;/code&gt; 和 &lt;code&gt;modify_algorithms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dec9bf90ad555856d14e7f8a0bcc0b6c2749f95" translate="yes" xml:space="preserve">
          <source>To fully understand how to configure the algorithms, it is essential to have a basic understanding of the SSH protocol and how OTP SSH app handles the corresponding items</source>
          <target state="translated">要想充分了解如何配置算法,必须对SSH协议以及OTP SSH应用如何处理相应的项目有一个基本的了解。</target>
        </trans-unit>
        <trans-unit id="105f7930b5d0bd6dbe4b596f6e5e1aa3c7bab464" translate="yes" xml:space="preserve">
          <source>To gain performance by using the SMP emulator, your application &lt;strong&gt;must have more than one runnable Erlang process&lt;/strong&gt; most of the time. Otherwise, the Erlang emulator can still only run one Erlang process at the time, but you must still pay the overhead for locking. Although Erlang/OTP tries to reduce the locking overhead as much as possible, it will never become exactly zero.</source>
          <target state="translated">为了通过使用SMP仿真器获得性能，您的应用程序&lt;strong&gt;在&lt;/strong&gt;大多数情况下&lt;strong&gt;必须具有多个可运行的Erlang进程&lt;/strong&gt;。否则，Erlang仿真器当时仍只能运行一个Erlang进程，但是您仍然必须支付锁定的开销。尽管Erlang / OTP试图尽可能减少锁定开销，但它永远不会变成零。</target>
        </trans-unit>
        <trans-unit id="2cbd28c322c2b7823640cb5d04b4000794237448" translate="yes" xml:space="preserve">
          <source>To get an overview of the concepts and operation of &lt;code&gt;gen_statem&lt;/code&gt;, do read the &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; in &lt;code&gt;OTP Design Principles&lt;/code&gt; which frequently links back to this reference manual to avoid containing detailed facts that may rot by age.</source>
          <target state="translated">要 &lt;code&gt;gen_statem&lt;/code&gt; 的概念和操作，请阅读《 &lt;code&gt;OTP Design Principles&lt;/code&gt; 的 &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; ，该行为经常链接到本参考手册，以避免包含可能随年龄而变化的详细事实。</target>
        </trans-unit>
        <trans-unit id="01d79833ca3942345f121a64dcc3d55c1d0c6500" translate="yes" xml:space="preserve">
          <source>To get information about a PLT, use the following option:</source>
          <target state="translated">要获取PLT的信息,请使用以下选项。</target>
        </trans-unit>
        <trans-unit id="d1d5a6ae5a2a64c460f8242067e0ee912a4a4259" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统OS单调时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1abf6bacf41753f2d4e4f3e187da0b6ca761589" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统的OS系统时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b209da3c80686caad1fbe93f4b143a75dbb826a1" translate="yes" xml:space="preserve">
          <source>To get log events on the same format as produced by &lt;code&gt;error_logger_tty_h&lt;/code&gt; and &lt;code&gt;error_logger_file_h&lt;/code&gt;, use the default formatter, &lt;code&gt;logger_formatter&lt;/code&gt;, with configuration parameter &lt;code&gt;legacy_header&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. This is the default configuration of the &lt;code&gt;default&lt;/code&gt; handler started by Kernel.</source>
          <target state="translated">要获得与 &lt;code&gt;error_logger_tty_h&lt;/code&gt; 和 &lt;code&gt;error_logger_file_h&lt;/code&gt; 产生的格式相同的日志事件，请使用默认格式设置 &lt;code&gt;logger_formatter&lt;/code&gt; ，并将配置参数 &lt;code&gt;legacy_header&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。这是内核启动的 &lt;code&gt;default&lt;/code&gt; 处理程序的默认配置。</target>
        </trans-unit>
        <trans-unit id="51cf577b00fc8216155e456c21c9c0183f56b93f" translate="yes" xml:space="preserve">
          <source>To get started, the least you need to do is to start a tracer with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;, and set the required trace flags on the processes you want to trace with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首先，您最不需要做的就是使用 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 启动一个跟踪器，并在要使用 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 进行跟踪的进程上设置所需的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="fc4b00be659493772c3eb90fac788afdac82d1da" translate="yes" xml:space="preserve">
          <source>To get started, you should read about the &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; data type; the main constructor functions: &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt;; and the main layout function &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首先，您应该阅读一下 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 数据类型。主要的构造函数： &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; ；和主布局功能 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80a72b65fea86a98c851ba990e410aac5fd9f4fb" translate="yes" xml:space="preserve">
          <source>To get the consistent behavior of killing ports when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads, use driver option &lt;code&gt;kill_ports&lt;/code&gt; when loading the driver instead.</source>
          <target state="translated">要获得在最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 卸载时终止端口的一致行为， &lt;code&gt;kill_ports&lt;/code&gt; 在加载驱动程序时使用驱动程序选项kill_ports。</target>
        </trans-unit>
        <trans-unit id="97de7a8dc23625a08e5a773780e14b0a5c65aae2" translate="yes" xml:space="preserve">
          <source>To get the output printed to a file, use option &lt;code&gt;--output_file&lt;/code&gt;.</source>
          <target state="translated">要将输出打印到文件中，请使用选项 &lt;code&gt;--output_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f76cd184a6e7c8d866643b588a8bdefe5b9edef" translate="yes" xml:space="preserve">
          <source>To get trace messages containing return values from functions, use the &lt;code&gt;{return_trace}&lt;/code&gt; match specification action instead.</source>
          <target state="translated">要获取包含函数返回值的跟踪消息，请改用 &lt;code&gt;{return_trace}&lt;/code&gt; 匹配规范操作。</target>
        </trans-unit>
        <trans-unit id="1820d2a1d5bd22bcad0e15651513a749cd0ea7ac" translate="yes" xml:space="preserve">
          <source>To give an indication on the possible performance gain using the specialized decodes, some measures have been performed. The relative figures in the outcome between selective, exclusive, and complete decode (the normal case) depend on the structure of the type, the size of the message, and on what level the selective and exclusive decodes are specified.</source>
          <target state="translated">为了说明使用专门的解码器可能获得的性能增益,已经进行了一些测量。选择性、排他性和完全解码(正常情况)之间的相对数字取决于类型的结构、电文的大小,以及选择性和排他性解码的具体水平。</target>
        </trans-unit>
        <trans-unit id="a6bae83c7d1a2e1a895f2a1aac969ea5d6956ad8" translate="yes" xml:space="preserve">
          <source>To hack the erlang libraries, you simply do a &lt;code&gt;make opt&lt;/code&gt; in the specific &quot;applications&quot; directory, like:</source>
          <target state="translated">要破解erlang库，您只需在特定的&amp;ldquo;应用程序&amp;rdquo;目录中执行 &lt;code&gt;make opt&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="25afbf964210cbb860d968d22f8aec5dd76f1cff" translate="yes" xml:space="preserve">
          <source>To handle Unicode characters in Erlang, a common representation in both lists and binaries is needed. EEP (10) and the subsequent initial implementation in Erlang/OTP R13A settled a standard representation of Unicode characters in Erlang.</source>
          <target state="translated">为了在Erlang中处理Unicode字符,在列表和二进制文件中都需要一个通用的表示方法。EEP(10)和随后在Erlang/OTP R13A中的初步实现解决了Erlang中Unicode字符的标准表示方法。</target>
        </trans-unit>
        <trans-unit id="342c993bd4e7155816205341dd7a1c3953a4f6f8" translate="yes" xml:space="preserve">
          <source>To have &lt;code&gt;Common Test&lt;/code&gt; encrypt a specified file using function &lt;code&gt;DES3&lt;/code&gt; in application &lt;code&gt;Crypto&lt;/code&gt;, call &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; The encrypted file can then be used as a regular configuration file in combination with other encrypted files or normal text files. However, the key for decrypting the configuration file must be provided when running the test. This can be done with flag/option &lt;code&gt;decrypt_key&lt;/code&gt; or &lt;code&gt;decrypt_file&lt;/code&gt;, or a key file in a predefined location.</source>
          <target state="translated">要使 &lt;code&gt;Common Test&lt;/code&gt; 使用应用程序 &lt;code&gt;Crypto&lt;/code&gt; 中的函数 &lt;code&gt;DES3&lt;/code&gt; 加密指定的文件，请调用 &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; 。然后，可以将该加密文件与其他加密文件或普通文本文件结合用作常规配置文件。但是，运行测试时必须提供用于解密配置文件的密钥。这可以通过标志/选项 &lt;code&gt;decrypt_key&lt;/code&gt; 或 &lt;code&gt;decrypt_file&lt;/code&gt; 或预定义位置的密钥文件来完成。</target>
        </trans-unit>
        <trans-unit id="85cad9012ac3a0f7585ee9eb3d18653bcfe48b6e" translate="yes" xml:space="preserve">
          <source>To have an effect, a breakpoint must be set at an &lt;strong&gt;executable line&lt;/strong&gt;, which is a line of code containing an executable expression such as a matching or a function call. A blank line or a line containing a comment, function head, or pattern in a &lt;code&gt;case&lt;/code&gt; statement or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">为了产生效果，必须在&lt;strong&gt;可执行行&lt;/strong&gt;处设置断点，该行是包含可执行表达式（例如匹配或函数调用）的代码行。空行或 &lt;code&gt;case&lt;/code&gt; 语句或 &lt;code&gt;receive&lt;/code&gt; 语句中包含注释，函数头或模式的行不可执行。</target>
        </trans-unit>
        <trans-unit id="3526ad99fb939a42fd2ac8a732fa13795a7fc7c2" translate="yes" xml:space="preserve">
          <source>To have effect, this function is to be called from &lt;code&gt;init_per_suite/1&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;) before any tests are performed.</source>
          <target state="translated">为了生效，在执行任何测试之前，将从 &lt;code&gt;init_per_suite/1&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; ）中调用此函数。</target>
        </trans-unit>
        <trans-unit id="2708c75c960cc2ecf9c829562c09567eee5b452b" translate="yes" xml:space="preserve">
          <source>To help adapt configuration data to a test suite (or test case) and improve readability.</source>
          <target state="translated">帮助配置数据适应测试套件(或测试用例),提高可读性。</target>
        </trans-unit>
        <trans-unit id="030c50a15bdc06f6e3b51217f3e73b7d2d5a9ad8" translate="yes" xml:space="preserve">
          <source>To help setup the environment, there is a bat file, &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt;, that set's the appropriate environment for a Windows command prompt. This is not appropriate for bash, so you'll need to convert it to bash-style environments by editing your &lt;code&gt;.bash_profile&lt;/code&gt;. In my case, where the SDK is installed in the default directory and &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; is &lt;code&gt;C:\Program Files&lt;/code&gt;, the commands for setting up a 32bit build environment (on a 64bit or 32bit machine) look like this (in Cygwin):</source>
          <target state="translated">为了帮助设置环境，有一个bat文件 &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt; ，它为Windows命令提示符设置了合适的环境。这不适用于bash，因此您需要通过编辑 &lt;code&gt;.bash_profile&lt;/code&gt; 将其转换为bash风格的环境。在我的情况下，SDK安装在默认目录中， &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; 为 &lt;code&gt;C:\Program Files&lt;/code&gt; ，用于在32位或32位计算机上设置32位构建环境的命令如下所示（在Cygwin中）：</target>
        </trans-unit>
        <trans-unit id="8c68f332c622b4567e9853c18f5bd4711a371dc7" translate="yes" xml:space="preserve">
          <source>To help with debugging, EUnit defines several useful macros for printing messages directly to the console (rather than to the standard output). Furthermore, these macros all use the same basic format, which includes the file and line number where they occur, making it possible in some development environments (e.g., when running Erlang in an Emacs buffer) to simply click on the message and jump directly to the corresponding line in the code.</source>
          <target state="translated">为了帮助调试,EUnit定义了几个有用的宏,用于将消息直接打印到控制台(而不是标准输出)。此外,这些宏都使用相同的基本格式,其中包括文件和它们出现的行号,这使得在某些开发环境中(例如,当在Emacs缓冲区中运行Erlang时)可以简单地点击消息并直接跳转到代码中的相应行。</target>
        </trans-unit>
        <trans-unit id="f2bf4f85026136c5e9d89c67190507dcee8f99df" translate="yes" xml:space="preserve">
          <source>To identify connections (described later).</source>
          <target state="translated">要识别连接(后面会介绍)。</target>
        </trans-unit>
        <trans-unit id="a3a37007760548419af74fbda4faaad4a58f472b" translate="yes" xml:space="preserve">
          <source>To illustrate the interoperability principles, C programs running in a UNIX environment have been used. It is assumed that you have enough knowledge to apply these principles to the relevant programming languages and platforms.</source>
          <target state="translated">为了说明互操作性原则,我们使用了在UNIX环境下运行的C程序。假设你有足够的知识将这些原则应用于相关的编程语言和平台。</target>
        </trans-unit>
        <trans-unit id="e25970fd2bf365203fb3a3002e19cdcdbb27a907" translate="yes" xml:space="preserve">
          <source>To illustrate this we make up an example where the buttons instead generate down and up (press and release) events, and the lock responds to an up event only after the corresponding down event.</source>
          <target state="translated">为了说明这一点,我们做了一个例子,在这个例子中,按钮反而会产生向下和向上(按压和释放)事件,而锁只有在相应的向下事件之后才会响应向上事件。</target>
        </trans-unit>
        <trans-unit id="272786a4055a77679447504bd8a8b3f74b9c24f1" translate="yes" xml:space="preserve">
          <source>To illustrate this, do &lt;strong&gt;not&lt;/strong&gt; write as follows:</source>
          <target state="translated">为了说明这一点，就&lt;strong&gt;不会&lt;/strong&gt;写如下：</target>
        </trans-unit>
        <trans-unit id="968314d317898e187c56ec55b8af76cc4a65eba4" translate="yes" xml:space="preserve">
          <source>To illustrate this, suppose we extend our Mnesia &lt;code&gt;empTable&lt;/code&gt; with one internal column. We create it as before, but with an arity of 4, by adding another attribute.</source>
          <target state="translated">为了说明这一点，假设我们用一个内部列扩展Mnesia &lt;code&gt;empTable&lt;/code&gt; 。我们通过添加另一个属性，像以前一样创建它，但Arity为4。</target>
        </trans-unit>
        <trans-unit id="a162dc5a66ab8801f7f0ce0a26a9e8e3d6ef7a06" translate="yes" xml:space="preserve">
          <source>To illustrate this, the messenger example from the previous section is divided into the following five files:</source>
          <target state="translated">为了说明这一点,上一节中的messenger例子被分为以下五个文件。</target>
        </trans-unit>
        <trans-unit id="6bb28103d410bbb4345e8969c22657c7565cfc3a" translate="yes" xml:space="preserve">
          <source>To implement a new carrier for the Erlang distribution, the main steps are as follows.</source>
          <target state="translated">要实现一个新的Erlang发行版的载体,主要步骤如下。</target>
        </trans-unit>
        <trans-unit id="279afddbfce41bfb8c90b18f6a7106e81cad960d" translate="yes" xml:space="preserve">
          <source>To implement a user-defined behaviour, write code similar to code for a special process, but call functions in a callback module for handling specific tasks.</source>
          <target state="translated">要实现用户定义的行为,编写类似于特殊进程的代码,但要调用回调模块中的函数来处理特定任务。</target>
        </trans-unit>
        <trans-unit id="bbcff46d509465f1d50c1bdbf6bb8561780d4955" translate="yes" xml:space="preserve">
          <source>To implement an agent, the programmer writes instrumentation functions for the variables and the tables in the MIBs that the agent is going to support. A running prototype which handles &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;get-next&lt;/code&gt; can be created without any programming.</source>
          <target state="translated">为了实现代理，程序员为代理将支持的MIB中的变量和表编写了检测功能。无需任何编程即可创建处理 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;get-next&lt;/code&gt; 的运行原型。</target>
        </trans-unit>
        <trans-unit id="330de1ad3973af593bbd7d81e03664889a42ea4e" translate="yes" xml:space="preserve">
          <source>To implement your own service discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">要实现自己的服务发现模块，必须编写自己的EPMD模块。的 &lt;code&gt;EPMD module&lt;/code&gt; 负责提供另一节点的位置。分发模块（ &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; ）调用EPMD模块以获取另一个节点的IP地址和端口。作为Erlang / OTP一部分的EPMD模块将使用DNS解析主机名，并使用EPMD Unix进程获取另一个节点的端口。 EPMD UNIX进程通过连接到知名端口4369上的另一个节点来实现此目的。</target>
        </trans-unit>
        <trans-unit id="79134b2c4e38df5717fe5011c4463fea24abb3c3" translate="yes" xml:space="preserve">
          <source>To improve performance when analysing cover results it is possible to do multiple calls to &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; at once. You can also use the &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; convenience function.</source>
          <target state="translated">为了提高分析覆盖结果时的性能，可以一次执行多个调用来 &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 。您还可以使用 &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; 便捷功能。</target>
        </trans-unit>
        <trans-unit id="d70eada12ec2a8f92aa033daf56e896f20d26d8f" translate="yes" xml:space="preserve">
          <source>To include other nodes in the coverage analysis, use &lt;code&gt;start/1&lt;/code&gt;. All cover compiled modules will then be loaded on all nodes, and data from all nodes will be summed up when analysing. For simplicity this example only involves the current node.</source>
          <target state="translated">要在覆盖率分析中包括其他节点，请使用 &lt;code&gt;start/1&lt;/code&gt; 。然后将所有Cover编译的模块加载到所有节点上，并在分析时汇总来自所有节点的数据。为简单起见，此示例仅涉及当前节点。</target>
        </trans-unit>
        <trans-unit id="a5478a26ee1ac879ac54fc75bcb8b9a9f083c3ec" translate="yes" xml:space="preserve">
          <source>To include private shell commands, define them in a module &lt;code&gt;user_default&lt;/code&gt; and add the following argument as the first line in the &lt;code&gt;.erlang&lt;/code&gt; file:</source>
          <target state="translated">要包含私有shell命令，请在模块 &lt;code&gt;user_default&lt;/code&gt; 中定义它们，并在 &lt;code&gt;.erlang&lt;/code&gt; 文件的第一行中添加以下参数：</target>
        </trans-unit>
        <trans-unit id="203ccb7faa11c702e1202041c2be3ef44596552b" translate="yes" xml:space="preserve">
          <source>To initialize the database, execute the following code on one of the two nodes:</source>
          <target state="translated">要初始化数据库,请在两个节点中的一个节点上执行以下代码。</target>
        </trans-unit>
        <trans-unit id="026d2b6accddb0e61f3eda91aff0268e88788933" translate="yes" xml:space="preserve">
          <source>To insert an &amp;amp; or a \ in the result, precede it with a \. Notice that Erlang already gives a special meaning to \ in literal strings, so a single \ must be written as &lt;code&gt;&quot;\\&quot;&lt;/code&gt; and therefore a double \ as &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">要在结果中插入＆或\，请在其前面加上\。注意，Erlang已经在文字字符串中为\赋予了特殊的含义，因此单个\必须写为 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ，因此一个双\ 必须写为 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c018c38250aabfbb51e23ce90651060a950f1b96" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">要安装包括开始参数的 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44e25aea36620d24d591fc0a361139dfb3c4b11c" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">安装包括开始参数的 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c7864f1c5249a35705cc8dcabba48f995e8ae5" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">安装 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="025cdabf9ad94f75800cda5f1e9747d7ccc0323d" translate="yes" xml:space="preserve">
          <source>To install the CSS file (&lt;code&gt;Common Test&lt;/code&gt; inlines the definition in the HTML code), the file name can be provided when executing &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">要安装CSS文件（ &lt;code&gt;Common Test&lt;/code&gt; 内联HTML代码中的定义），可以在执行 &lt;code&gt;ct_run&lt;/code&gt; 时提供文件名。</target>
        </trans-unit>
        <trans-unit id="deb96dbc16afa611fcde38057919ecf9cc751bfa" translate="yes" xml:space="preserve">
          <source>To install the new version of the release in runtime, the &lt;strong&gt;release handler&lt;/strong&gt; is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the &lt;code&gt;release_handler&lt;/code&gt; module. For details, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">要在运行时中安装发行版的新版本，请使用&lt;strong&gt;发行处理程序&lt;/strong&gt;。这是属于SASL应用程序的过程，该过程负责处理发行包的解压缩，安装和删除。通过 &lt;code&gt;release_handler&lt;/code&gt; 模块进行通信。有关详细信息，请参见SASL中的 &lt;code&gt;release_handler(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="73c1bf364dc283d1176ab1d289c500fd685a5dab" translate="yes" xml:space="preserve">
          <source>To interpret all displayed modules in the chosen directory, click &lt;strong&gt;All&lt;/strong&gt;.</source>
          <target state="translated">要解释所选目录中所有显示的模块，请单击&lt;strong&gt;全部&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3292879da2b34dcadcc9f9ce0648b935ba4e7f92" translate="yes" xml:space="preserve">
          <source>To interrupt the runtime system or the shell process (depending on what has been specified with system flag &lt;code&gt;+B&lt;/code&gt;), use &lt;code&gt;Ctrl-Break&lt;/code&gt;.</source>
          <target state="translated">要中断运行时系统或shell进程（取决于使用系统标志 &lt;code&gt;+B&lt;/code&gt; 指定的内容），请使用 &lt;code&gt;Ctrl-Break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d9005b012d1045c52922820e7322a9dfa02e1f6" translate="yes" xml:space="preserve">
          <source>To investigate what Erlang thinks about the terminal, the call &lt;code&gt;io:getopts()&lt;/code&gt; can be used when the shell is started:</source>
          <target state="translated">要研究Erlang对终端的看法，可以在启动外壳程序时使用 &lt;code&gt;io:getopts()&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="11a6e867a167f9a4a740ad92d9902eefad28664c" translate="yes" xml:space="preserve">
          <source>To just run a shell on a remote machine, there are functions that bundles the needed three steps needed into one: &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt;. Similarily, to just open an sftp (file transfer) connection to a remote machine, the simplest way is to use &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要仅在远程计算机上运行Shell，有一些功能将所需的三个步骤捆绑为一个： &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt; 。同样，仅打开与远程计算机的sftp（文件传输）连接，最简单的方法是使用 &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f2634ff9e5775d30c933d162e116bcf2daeb2ae" translate="yes" xml:space="preserve">
          <source>To learn what sequential tracing is and how it can be used, see the Reference Manual for &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">要了解什么是顺序跟踪以及如何使用它，请参见 &lt;code&gt;seq_trace&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="ea8c91f9201e13f8a7af2544d0b6f79400981a45" translate="yes" xml:space="preserve">
          <source>To let the test suite continue on executing, return the configuration list that you want the test to use as the result.</source>
          <target state="translated">要让测试套件继续执行,请返回你希望测试使用的配置列表作为结果。</target>
        </trans-unit>
        <trans-unit id="d62397eee2357878fc975aeb84771b8bc2c06ea8" translate="yes" xml:space="preserve">
          <source>To limit the shutdown time, the time &lt;code&gt;init&lt;/code&gt; is allowed to spend taking down applications, command-line flag &lt;code&gt;-shutdown_time&lt;/code&gt; is to be used.</source>
          <target state="translated">为了限制关闭时间，允许使用时间 &lt;code&gt;init&lt;/code&gt; 来关闭应用程序，使用命令行标志 &lt;code&gt;-shutdown_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31df00fd05b2b4e7d3ede7fd0ed32c7595a82e9c" translate="yes" xml:space="preserve">
          <source>To list the contents of a configuration file, use &lt;code&gt;list_config/1&lt;/code&gt;.</source>
          <target state="translated">要列出配置文件的内容，请使用 &lt;code&gt;list_config/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5d893e9a4aaa1eb2af17414123d7e17dc6fd363" translate="yes" xml:space="preserve">
          <source>To listen on both SCTP and TCP, define one transport for each.</source>
          <target state="translated">要同时监听 SCTP 和 TCP,请为每个传输定义一个传输。</target>
        </trans-unit>
        <trans-unit id="07a54ad0b2a1bb175cf95b725d86a06fc8b48cbd" translate="yes" xml:space="preserve">
          <source>To look up one of the names:</source>
          <target state="translated">查询其中一个名字。</target>
        </trans-unit>
        <trans-unit id="8a56bbc15981f1188aa9ff7ef71388335fe7c6a6" translate="yes" xml:space="preserve">
          <source>To make a debug build of the emulator, you need to recompile both &lt;code&gt;beam.dll&lt;/code&gt; (the actual runtime system) and &lt;code&gt;erlexec.dll&lt;/code&gt;. Do like this</source>
          <target state="translated">要构建仿真器的调试版本，您需要重新编译 &lt;code&gt;beam.dll&lt;/code&gt; （实际的运行时系统）和 &lt;code&gt;erlexec.dll&lt;/code&gt; 。像这样</target>
        </trans-unit>
        <trans-unit id="038da331fd12e331816c4b78d58a10e2cc57ca86" translate="yes" xml:space="preserve">
          <source>To make it clearer exactly what code the warnings refer to, the warnings in the following examples are inserted as comments after the clause they refer to, for example:</source>
          <target state="translated">为了更清楚地说明警告所指的代码,在下面的例子中,警告被作为注释插入到它们所指的子句之后,例如。</target>
        </trans-unit>
        <trans-unit id="cd2982d9a90975bc47a9c7a7530d4f0cbaa3f7f2" translate="yes" xml:space="preserve">
          <source>To make it easier to understand this section, some terms are defined. This is a mix of our own terminology (Erlang/OS system time, Erlang/OS monotonic time, time warp) and globally accepted terminology.</source>
          <target state="translated">为了便于理解本节内容,我们定义了一些术语。这是我们自己的术语(Erlang/OS系统时间、Erlang/OS单调时间、时间扭曲)和全球公认的术语的混合。</target>
        </trans-unit>
        <trans-unit id="2921bab0b743bbb6198162ca9c596c8d4e059429" translate="yes" xml:space="preserve">
          <source>To make the descriptions simpler, we first list some definitions:</source>
          <target state="translated">为了使描述更简单,我们首先列出一些定义。</target>
        </trans-unit>
        <trans-unit id="9c4714caed05dab02e49dd183a4006e068e3199f" translate="yes" xml:space="preserve">
          <source>To make the example runnable, we start implementing the reading and writing of the data to/from the ETS table. First function &lt;code&gt;put_chars/3&lt;/code&gt;:</source>
          <target state="translated">为了使示例可运行，我们开始实现对ETS表的数据读写。第一个功能 &lt;code&gt;put_chars/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="632f6f737e1f0ad548a43d9ad64573eca55f152d" translate="yes" xml:space="preserve">
          <source>To make the process change code, send the message &lt;code&gt;code_switch&lt;/code&gt; to it. The process then makes a fully qualified call to &lt;code&gt;m:loop()&lt;/code&gt; and changes to current code. Notice that &lt;code&gt;m:loop/0&lt;/code&gt; must be exported.</source>
          <target state="translated">要更改流程代码，请向其发送消息 &lt;code&gt;code_switch&lt;/code&gt; 。然后，该过程对 &lt;code&gt;m:loop()&lt;/code&gt; 进行完全限定的调用，并更改为当前代码。请注意，必须导出 &lt;code&gt;m:loop/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e177c9389e3d182722e09e0544b0a24268ff84e3" translate="yes" xml:space="preserve">
          <source>To make the test fair, each new test run is to run in its own, newly created Erlang process. Otherwise, if all tests run in the same process, the later tests start out with larger heap sizes and therefore probably do fewer garbage collections. Also consider restarting the Erlang emulator between each test.</source>
          <target state="translated">为了使测试公平,每个新的测试运行都要在自己的、新创建的Erlang进程中运行。否则,如果所有的测试都在同一个进程中运行,那么后面的测试一开始就会有较大的堆大小,因此可能会做较少的垃圾回收。也可以考虑在每次测试之间重新启动Erlang模拟器。</target>
        </trans-unit>
        <trans-unit id="120ecf4e057892d6019b012a82abcf83ac9ffd85" translate="yes" xml:space="preserve">
          <source>To make this happen the megaco stack has to be configured:</source>
          <target state="translated">为了实现这一点,必须配置megaco栈。</target>
        </trans-unit>
        <trans-unit id="13169d7b871948e1e9a9c4457e119e83fe7939d4" translate="yes" xml:space="preserve">
          <source>To manipulate services, the logged on user is to have administrator privileges on the machine. The Erlang machine itself is (default) run as the local administrator. This can be changed with the Services applet in Windows.</source>
          <target state="translated">要操纵服务,登录的用户要有机器上的管理员权限。Erlang机器本身(默认)是以本地管理员的身份运行的。这可以通过Windows中的服务小程序来改变。</target>
        </trans-unit>
        <trans-unit id="330fd48fdffeb44ebc089750d09d688535c7db34" translate="yes" xml:space="preserve">
          <source>To manipulate the Erlang services easily, put the &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; directory in the path instead of &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt;. The &lt;code&gt;erlsrv&lt;/code&gt; program can be found from inside Erlang by using the &lt;code&gt;os:find_executable/1&lt;/code&gt; Erlang function.</source>
          <target state="translated">要轻松地操作Erlang服务，请将 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; 目录放在路径中，而不是 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt; 。该 &lt;code&gt;erlsrv&lt;/code&gt; 程序可以从内部二郎通过使用发现 &lt;code&gt;os:find_executable/1&lt;/code&gt; 二郎功能。</target>
        </trans-unit>
        <trans-unit id="7b0e537b9e6e88eafa3eeae7f7a02f18b4e1430f" translate="yes" xml:space="preserve">
          <source>To manipulate the table we implement the following utility functions:</source>
          <target state="translated">为了操作该表,我们实现了以下实用函数。</target>
        </trans-unit>
        <trans-unit id="af1c290996a023ca9ee9b2902b6c1dc2a988f5c7" translate="yes" xml:space="preserve">
          <source>To match out the rest of a binary, specify a binary field without size:</source>
          <target state="translated">要匹配出二进制的其余部分,请指定一个没有大小的二进制字段。</target>
        </trans-unit>
        <trans-unit id="50f6c59cd17dfe4a6719c66fb938f13bf13c9cd5" translate="yes" xml:space="preserve">
          <source>To match out the rest of a bitstring, specify a field without size:</source>
          <target state="translated">要匹配出一个位串的其余部分,请指定一个没有大小的字段。</target>
        </trans-unit>
        <trans-unit id="3c74e2148772d016b06b50e91a05f48c85c5db24" translate="yes" xml:space="preserve">
          <source>To merge all wrap logs from two nodes:</source>
          <target state="translated">合并两个节点的所有wrap日志。</target>
        </trans-unit>
        <trans-unit id="6ec3ba5252c54ac879e329c670bb92c1a4f26979" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="7cbe08d74968e08a72c3be83982bb750cd3d4357" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="5232b103674f04a52f0f595b415d6da9c86b5634" translate="yes" xml:space="preserve">
          <source>To not lose the data that the failing node stored up to the point of crash, the control node tries to fetch it before restarting trace. This must occur within the allowed time frame, otherwise it is aborted (default is 10 seconds, but it can be changed with &lt;code&gt;{resume, MSec}&lt;/code&gt;). The data fetched this way is then merged with all other traces.</source>
          <target state="translated">为了不丢失发生故障的节点存储到崩溃点之前的数据，控制节点将尝试在重新启动跟踪之前获取它。这必须在允许的时间范围内发生，否则将中止（默认值为10秒，但可以使用 &lt;code&gt;{resume, MSec}&lt;/code&gt; 进行更改）。然后将以此方式获取的数据与所有其他跟踪合并。</target>
        </trans-unit>
        <trans-unit id="eead728bbb8cc0046ae68985d45f67a85158d6b1" translate="yes" xml:space="preserve">
          <source>To not update a driver and only recompile, it probably works when building for a 32-bit machine creating a false sense of security. Hopefully that will generate many important warnings. But when recompiling the same driver later on for a 64-bit machine, there &lt;strong&gt;will&lt;/strong&gt; be warnings and almost certainly crashes. So it is a &lt;strong&gt;bad&lt;/strong&gt; idea to postpone updating the driver and not fixing the warnings.</source>
          <target state="translated">为了不更新驱动程序而只重新编译，它可能在为32位计算机构建时产生假的安全感时起作用。希望这会产生许多重要的警告。但是，稍后在为64位计算机重新编译同一驱动程序时，&lt;strong&gt;将&lt;/strong&gt;出现警告，并且几乎肯定会崩溃。因此，推迟更新驱动程序而不修复警告是一个&lt;strong&gt;坏&lt;/strong&gt;主意。</target>
        </trans-unit>
        <trans-unit id="25dd351d674ee351bc0d61f733e4bc4ab3924c98" translate="yes" xml:space="preserve">
          <source>To only collect data from remote nodes without stopping &lt;code&gt;cover&lt;/code&gt; on those nodes, use &lt;code&gt;cover:flush/1&lt;/code&gt;</source>
          <target state="translated">从远程节点不停止只收集数据 &lt;code&gt;cover&lt;/code&gt; 的那些节点，使用关于 &lt;code&gt;cover:flush/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228c30057d8d3d2590c6d0ceb056f1bc0cfdc8f" translate="yes" xml:space="preserve">
          <source>To only update an existing value, the following syntax is used:</source>
          <target state="translated">要只更新一个现有的值,需要使用以下语法。</target>
        </trans-unit>
        <trans-unit id="91ac146297375e57e22dd83d0532b37bf8d61261" translate="yes" xml:space="preserve">
          <source>To open a file for writing and place the BOM first is even simpler:</source>
          <target state="translated">要想打开文件写,先放BOM就更简单了。</target>
        </trans-unit>
        <trans-unit id="58c7c0dd2c707e847605f73d2bf4f644bea3024e" translate="yes" xml:space="preserve">
          <source>To open a popup menu from which the appropriate module can be selected, right-click the &lt;strong&gt;Module&lt;/strong&gt; entry.</source>
          <target state="translated">要打开一个弹出菜单，从中可以选择适当的模块，请右键单击&amp;ldquo; &lt;strong&gt;模块&amp;rdquo;&lt;/strong&gt;条目。</target>
        </trans-unit>
        <trans-unit id="14f5619a76f5c4433353480eb14374da920455d5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the module to which the fun belongs, right-click the row and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关该乐趣所属模块的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;mod&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="707dccebf0704f68a732417b3f2c2e2a669bd41f" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of a timer, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关计时器所有者进程的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="67b5909ded381e129ca3cf333f0952bd76fc77a6" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of an ETS table, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关ETS表所有者过程的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="310178f41809534c7c90fe35f112b61d4b6677f5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the scheduler, double-click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">要打开有关调度程序的详细信息页面，请双击或右键单击该行，然后&lt;strong&gt;为&amp;ldquo;标识符&amp;rdquo;&lt;/strong&gt;选择&amp;ldquo; &lt;strong&gt;属性&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="571318d856ef4524500a9b751e49f54bd8327c0e" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the table, double- click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">要打开有关表的详细信息页面，请双击或右键单击该行，然后&lt;strong&gt;为&amp;ldquo;标识符&amp;rdquo;&lt;/strong&gt;选择&amp;ldquo; &lt;strong&gt;属性&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0f882324ba7cf66c628fe99da4190c380235eb46" translate="yes" xml:space="preserve">
          <source>To output characters on an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">要在I / O设备上输出字符，存在以下 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4460b3a67f9f027204de0ad12d5d1dec14e5f20d" translate="yes" xml:space="preserve">
          <source>To overcome this situation, try to restart the ongoing transactions that are accessing tables on the failing node, and write a &lt;code&gt;mnesia_down&lt;/code&gt; entry to a log file.</source>
          <target state="translated">为了克服这种情况，请尝试重新启动正在访问故障节点上的表的正在进行的事务，并将 &lt;code&gt;mnesia_down&lt;/code&gt; 条目写入日志文件。</target>
        </trans-unit>
        <trans-unit id="7e7f8360d8ea17a73622310335fec57f5f594e5a" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use</source>
          <target state="translated">要覆盖现有配置而不进行任何合并,使用</target>
        </trans-unit>
        <trans-unit id="8eb9c41fc2b2f98f04f5d6d6242bc28f6713bd31" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db040bf59efb80826409bf9f754e7a7431f35000" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5df41f2e14a8f5ccfe8eb5134454968930bd33" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">要将数据从一个测试套件传递到另一个测试套件，将使用相同的机制。数据将由函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 保存，并由 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 的套件中的函数init_per_suite读取。在套件之间传递数据时， &lt;code&gt;Saver&lt;/code&gt; 带有测试套件的名称。</target>
        </trans-unit>
        <trans-unit id="de196dbd1fc4727b3381ea786892e523ea66df78" translate="yes" xml:space="preserve">
          <source>To pass start arguments to the event handler init function, use option &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; instead of &lt;code&gt;-event_handler&lt;/code&gt;.</source>
          <target state="translated">要将启动参数传递给事件处理程序init函数，请使用选项 &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; 代替 &lt;code&gt;-event_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05760d82d1ff0699d6462cb51afbab4089fd15b2" translate="yes" xml:space="preserve">
          <source>To paste text, use &lt;code&gt;Ctrl-V&lt;/code&gt;.</source>
          <target state="translated">要粘贴文本，请使用 &lt;code&gt;Ctrl-V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a0ab25b4dbcc22e8a0f55cfd17389d320947558" translate="yes" xml:space="preserve">
          <source>To perform a selective decode:</source>
          <target state="translated">要进行选择性解码。</target>
        </trans-unit>
        <trans-unit id="e34161a911d532a3fe5b96ed7a79392865f455a4" translate="yes" xml:space="preserve">
          <source>To perform an exclusive decode:</source>
          <target state="translated">要进行专属解码。</target>
        </trans-unit>
        <trans-unit id="3f8dad79e2d5118a556c41ca87119ccb799f35ee" translate="yes" xml:space="preserve">
          <source>To perform code coverage test (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">执行代码覆盖率测试（请参阅 &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a431fccb77738e590c035501f73871c8ebfc0dd5" translate="yes" xml:space="preserve">
          <source>To plug in a handler to the &lt;code&gt;Common Test&lt;/code&gt; Master event manager, specify &lt;code&gt;master&lt;/code&gt; as the node in &lt;code&gt;NodeRefs&lt;/code&gt;.</source>
          <target state="translated">要将处理程序插入 &lt;code&gt;Common Test&lt;/code&gt; Master事件管理器，请在 &lt;code&gt;NodeRefs&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 指定为节点。</target>
        </trans-unit>
        <trans-unit id="a9a49f1cec23382260ab3c7111ed66a3064f4b5e" translate="yes" xml:space="preserve">
          <source>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a &lt;strong&gt;maximum restart intensity&lt;/strong&gt; is defined using two integer values specified with keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the above map. Assuming the values &lt;code&gt;MaxR&lt;/code&gt; for &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;MaxT&lt;/code&gt; for &lt;code&gt;period&lt;/code&gt;, then, if more than &lt;code&gt;MaxR&lt;/code&gt; restarts occur within &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;. &lt;code&gt;intensity&lt;/code&gt; defaults to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">为了防止主管进入子进程终止和重新启动的无限循环，使用上面映射中的键 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 指定的两个整数值来定义&lt;strong&gt;最大重新启动强度&lt;/strong&gt;。假设值 &lt;code&gt;MaxR&lt;/code&gt; 为 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;MaxT&lt;/code&gt; 为 &lt;code&gt;period&lt;/code&gt; ，然后，如果超过 &lt;code&gt;MaxR&lt;/code&gt; 重新启动内发生 &lt;code&gt;MaxT&lt;/code&gt; 秒，监控终止所有的子进程，然后本身。在这种情况下，主管本身的终止原因将被 &lt;code&gt;shutdown&lt;/code&gt; 。 &lt;code&gt;intensity&lt;/code&gt; 默认为 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 默认为 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b6bd58de0f6a9d2c9e5412e4769e5fc57c89331" translate="yes" xml:space="preserve">
          <source>To prevent accidentally reloading of modules affecting the Erlang runtime system, directories &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;compiler&lt;/code&gt; are considered &lt;strong&gt;sticky&lt;/strong&gt;. This means that the system issues a warning and rejects the request if a user tries to reload a module residing in any of them. The feature can be disabled by using command-line flag &lt;code&gt;-nostick&lt;/code&gt;.</source>
          <target state="translated">为了防止意外重新加载影响Erlang运行时系统的模块，目录 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 和 &lt;code&gt;compiler&lt;/code&gt; 被认为是&lt;strong&gt;粘滞的&lt;/strong&gt;。这意味着如果用户尝试重新加载驻留在其中任何一个模块中的模块，系统将发出警告并拒绝该请求。可以使用命令行标志 &lt;code&gt;-nostick&lt;/code&gt; 禁用该功能。</target>
        </trans-unit>
        <trans-unit id="dec616600e41a5b6ef771d942e395567b990586c" translate="yes" xml:space="preserve">
          <source>To prevent late answers (after the time-out) from polluting the message queue of the caller, a middleman process is used to do the calls. Late answers are then discarded when they arrive to a terminated process.</source>
          <target state="translated">为了防止迟来的应答(超时后)污染呼叫者的消息队列,采用中间人进程进行呼叫。迟到的应答到达终止的进程后就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="3c59c8bcb62921917057af6666d0e9bc306363f2" translate="yes" xml:space="preserve">
          <source>To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将文件列表打印到Erlang Shell中，请使用功能 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e7f46b82ce549b77ba51c1629aef0ab23feab88" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment,Comment}&lt;/code&gt;.</source>
          <target state="translated">要在HTML结果页面上的字段 &lt;code&gt;Comment&lt;/code&gt; 中打印一些信息，请返回 &lt;code&gt;{comment,Comment}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cc0874eca15de116c6433f2f6c8188ae52c6b95" translate="yes" xml:space="preserve">
          <source>To produce sensible results, &lt;code&gt;fprof&lt;/code&gt; tries not to charge any function more than once for ACC time. The instance highest up (with longest duration) in the call stack is chosen.</source>
          <target state="translated">为了产生合理的结果， &lt;code&gt;fprof&lt;/code&gt; 尝试在ACC时间内不对任何功能进行多次充电。选择调用堆栈中最高级别（持续时间最长）的实例。</target>
        </trans-unit>
        <trans-unit id="fdb950e45ab67b6a47da12b4482a70174dcfdd0c" translate="yes" xml:space="preserve">
          <source>To provide customization and extensibility of the request handling of the HTTP servers, most of these steps are handled by one or more modules. These modules can be replaced or removed at runtime and new ones can be added. For each request, all modules are traversed in the order specified by the module directive in the server configuration file. Some parts, mainly the communication- related steps, are considered server core functionality and are not implemented using the Erlang web server API. A description of functionality implemented by the Erlang webserver API is described in &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为了提供HTTP服务器请求处理的自定义和可扩展性，这些步骤中的大多数由一个或多个模块处理。这些模块可以在运行时替换或删除，也可以添加新模块。对于每个请求，将按照服务器配置文件中的模块指令指定的顺序遍历所有模块。有些部分（主要是与通信相关的步骤）被视为服务器核心功能，并且未使用Erlang Web服务器API来实现。 &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt; 介绍了Erlang Web服务器API实现的功能。</target>
        </trans-unit>
        <trans-unit id="7caa6e3412703737187f18930265da85c613b9f8" translate="yes" xml:space="preserve">
          <source>To provide more information for bug detection tools, such as Dialyzer</source>
          <target state="translated">为Dialyzer等错误检测工具提供更多信息。</target>
        </trans-unit>
        <trans-unit id="5563a933e99748f8947b5b13de253c9bebd73132" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;erl_receive()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;erl_receive&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;ErlMessage&lt;/code&gt; structure.</source>
          <target state="translated">为了提供鲁棒性，分布式Erlang节点有时会轮询其所有连接的邻居，以尝试检测故障的节点或通信链路。预计收到此类消息的节点将立即以 &lt;code&gt;ERL_TICK&lt;/code&gt; 消息进行响应。这是由 &lt;code&gt;erl_receive()&lt;/code&gt; 自动完成的。然而，当这种情况发生， &lt;code&gt;erl_receive&lt;/code&gt; 返回 &lt;code&gt;ERL_TICK&lt;/code&gt; 给调用者，而不存储消息到 &lt;code&gt;ErlMessage&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="c22d22ca8626a0d9ad4822b6abdf3304ff0e2ed1" translate="yes" xml:space="preserve">
          <source>To quickly get started on tracing function calls you can use the following code in the Erlang shell:</source>
          <target state="translated">为了快速开始跟踪函数调用,你可以在Erlang shell中使用以下代码。</target>
        </trans-unit>
        <trans-unit id="4216c6c1555a4ffc81851d786b4c47388d4033ab" translate="yes" xml:space="preserve">
          <source>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</source>
          <target state="translated">将每个工资低于10的人的工资提高到10,并返回所有加薪的总和。</target>
        </trans-unit>
        <trans-unit id="487f9ae77ed1f6bfc72656beab390cd3da83a3a4" translate="yes" xml:space="preserve">
          <source>To read characters from an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">要从I / O设备读取字符，存在以下 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ebc4e78936132f1c46d3f47b17ef930ad86f68e" translate="yes" xml:space="preserve">
          <source>To read data saved by a previous test case, use macro &lt;code&gt;config&lt;/code&gt; with a &lt;code&gt;saved_config&lt;/code&gt; key as follows:</source>
          <target state="translated">要读取以前的测试用例保存的数据，请使用带有 &lt;code&gt;saved_config&lt;/code&gt; 键的宏 &lt;code&gt;config&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="0e65ac5f6db83037a2248f75d84c868aa8830d0a" translate="yes" xml:space="preserve">
          <source>To read test terms, use &lt;code&gt;Tag = tests&lt;/code&gt; (rather than &lt;code&gt;suites&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, or &lt;code&gt;cases&lt;/code&gt;). &lt;code&gt;Value&lt;/code&gt; is then the list of &lt;strong&gt;all&lt;/strong&gt; tests on the form &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt;, where &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt;.</source>
          <target state="translated">要读取测试条件，请使用 &lt;code&gt;Tag = tests&lt;/code&gt; （而不是 &lt;code&gt;suites&lt;/code&gt; ， &lt;code&gt;groups&lt;/code&gt; 或 &lt;code&gt;cases&lt;/code&gt; ）。然后， &lt;code&gt;Value&lt;/code&gt; 是 &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt; 形式的&lt;strong&gt;所有&lt;/strong&gt;测试的列表，其中 &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt; [案例]。</target>
        </trans-unit>
        <trans-unit id="5502e1d91075568dbfad6a71c308a3359400e11e" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要读取计数器值，请使用 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf5d7d89573645295c9ea3ad3f20e180a97f562f" translate="yes" xml:space="preserve">
          <source>To read the value of a configuration variable, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要读取配置变量的值，请使用函数 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85dbe7571965e09b1298a761ceeca08b4c2e5f97" translate="yes" xml:space="preserve">
          <source>To read the values from the table directly is not always possible. It can be needed to search one or more tables to get the wanted data, and this is done by writing database queries. Queries are always more expensive operations than direct lookups done with &lt;code&gt;mnesia:read&lt;/code&gt;. Therefore, avoid queries in performance-critical code.</source>
          <target state="translated">直接从表中读取值并不总是可能的。可能需要搜索一个或多个表以获取所需的数据，这可以通过编写数据库查询来完成。查询总是比使用 &lt;code&gt;mnesia:read&lt;/code&gt; 直接查找更昂贵的操作。因此，请避免在性能关键的代码中进行查询。</target>
        </trans-unit>
        <trans-unit id="9ca82b142769fd54c89e1f8c4e76ea91942c4a3b" translate="yes" xml:space="preserve">
          <source>To reboot on Windows, &lt;code&gt;HEART_COMMAND&lt;/code&gt; can be set to &lt;code&gt;heart -shutdown&lt;/code&gt; (included in the Erlang delivery) or to any other suitable program that can activate a reboot.</source>
          <target state="translated">要在Windows上重新启动，可以将 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 设置为 &lt;code&gt;heart -shutdown&lt;/code&gt; （包括在Erlang交付中）或任何其他可以重新启动的合适程序。</target>
        </trans-unit>
        <trans-unit id="7356ba3e6c5278038b64fa42047a269f1c25742e" translate="yes" xml:space="preserve">
          <source>To reload a driver, the process must have loaded the driver before, that is, there must be an active &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver in the process.</source>
          <target state="translated">要重新加载驱动程序，进程必须先加载驱动程序，也就是说，进程中必须有该驱动程序的活动 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3cdbff1f4721e1fea3341a44c74cdfddea8582" translate="yes" xml:space="preserve">
          <source>To remove the special meaning from a sequence of characters, put them between \Q and \E. This is different from Perl in that $ and @ are handled as literals in \Q...\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples:</source>
          <target state="translated">要从一个字符序列中删除特殊的含义,可以将它们放在 \Q 和 \E 之间。这与Perl的不同之处在于,在PCRE中,$和@是作为字元处理的,而在Perl中,$和@会导致变量插值。请注意下面的例子。</target>
        </trans-unit>
        <trans-unit id="18463ee935cca0988ac023c8a2bb9233c9fed26c" translate="yes" xml:space="preserve">
          <source>To resolve BIF clashes, use explicit module names or the &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; compiler directive.</source>
          <target state="translated">要解决BIF冲突，请使用显式模块名称或 &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; 编译器指令。</target>
        </trans-unit>
        <trans-unit id="b836fc9905c583f17eeb633ad4676ccd91021746" translate="yes" xml:space="preserve">
          <source>To restrict access further, firewall software must be used.</source>
          <target state="translated">要进一步限制访问,必须使用防火墙软件。</target>
        </trans-unit>
        <trans-unit id="d8f49586e1a231ba1f54695cd73e9669c2fc73d3" translate="yes" xml:space="preserve">
          <source>To retain backwards compatibility, this module can also be used to start a standalone &lt;code&gt;nteventlog&lt;/code&gt; process which is not part of the OS_Mon supervision tree. When starting such a process, the user has to supply an identifier as well as a callback function to handle the messages.</source>
          <target state="translated">为了保持向后兼容性，此模块还可以用于启动独立的 &lt;code&gt;nteventlog&lt;/code&gt; 进程，该进程不属于OS_Mon监视树。当开始这样的过程时，用户必须提供标识符以及回调函数来处理消息。</target>
        </trans-unit>
        <trans-unit id="df78eacbc0781784bde23219396762a59c5fc919" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">要检索有关哪些进程已修复了哪些表的 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; ，请使用info（Tab，safe_fixed_monotonic_time）。具有固定表的多个进程的系统可能需要一个监视器，该监视器在表修复时间过长时会发送警报。</target>
        </trans-unit>
        <trans-unit id="d6e2ab13997144de0b0946f9bce9ea8b713fdb68" translate="yes" xml:space="preserve">
          <source>To retrieve lock statistics information, use &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;. The collect operation will start a &lt;code&gt;lcnt&lt;/code&gt; server if it not already started. All collected data will be built into an Erlang term and uploaded to the server and a duration time will also be uploaded. This duration is the time between &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; and &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;.</source>
          <target state="translated">要检索锁统计信息，请使用 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 。收集操作将启动 &lt;code&gt;lcnt&lt;/code&gt; 服务器（如果尚未启动）。所有收集的数据都将内置到Erlang术语中并上传到服务器，并且持续时间也将上传。此持续时间是 &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; 和 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 之间的时间。</target>
        </trans-unit>
        <trans-unit id="ed81e642c8e411bd6b5d4f1ff2f2a981ab28269a" translate="yes" xml:space="preserve">
          <source>To retrieve options, the following request is used:</source>
          <target state="translated">要检索选项,请使用以下请求。</target>
        </trans-unit>
        <trans-unit id="c9ff785694d496350bf52e12cf31257901fe0f9a" translate="yes" xml:space="preserve">
          <source>To retrieve previous command lines, press the &lt;code&gt;Up arrow&lt;/code&gt; or use &lt;code&gt;Ctrl-P&lt;/code&gt;.</source>
          <target state="translated">要检索以前的命令行，请按 &lt;code&gt;Up arrow&lt;/code&gt; 或使用 &lt;code&gt;Ctrl-P&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559902e638ff39f33df6bbdca42175eae97e1371" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取当前时间偏移，请调用 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3766f9d946545324fc3caa134e7e2c3cc1ac0495" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">要检索脚本的路径名，请从脚本中调用 &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; （路径名通常，但并非总是绝对的）。</target>
        </trans-unit>
        <trans-unit id="2fa3ffd8aedc2e1d61b1e455bb122f9f20bde0a5" translate="yes" xml:space="preserve">
          <source>To retrieve the size of a tuple, either use function &lt;code&gt;erl_size&lt;/code&gt; (which checks the type of the checked term and works for a binary as well as for a tuple) or &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; returns the arity of a tuple. &lt;code&gt;erl_size()&lt;/code&gt; does the same thing, but it checks that the argument is a tuple. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; returns the element corresponding to a given position in the tuple.</source>
          <target state="translated">要检索元组的大小，请使用函数 &lt;code&gt;erl_size&lt;/code&gt; （检查被检查项的类型并针对二进制和元组工作）或 &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; 返回元组的奇偶性。 &lt;code&gt;erl_size()&lt;/code&gt; 做同样的事情，但是它检查参数是否为元组。 &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; 返回与元组中给定位置相对应的元素。</target>
        </trans-unit>
        <trans-unit id="e48e571028f75c8447b25387e9c4c4797341c527" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a tar file, use function &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;. To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要返回tar文件中的文件列表，请使用函数 &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 。要将文件列表打印到Erlang Shell中，请使用功能 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340c1d928e96b2c334351d4a254c0683a554ee08" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;table/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要返回zip存档中的文件列表，请使用函数 &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;table/1,2&lt;/code&gt; 使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="ede464349d4cd7d18cdfbdde4b663fdde07fb367" translate="yes" xml:space="preserve">
          <source>To return a timetrap time value (other than a function).</source>
          <target state="translated">返回一个定时器时间值(函数以外的)。</target>
        </trans-unit>
        <trans-unit id="8b77285912aad5ab1ca119d023b421a0ece59988" translate="yes" xml:space="preserve">
          <source>To return only a few answers, cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers:</source>
          <target state="translated">如果只返回几个答案,可以使用游标。下面的代码使用一个ETS表来存储唯一的答案,返回的答案不超过5个。</target>
        </trans-unit>
        <trans-unit id="9f1313328915fb09221beb5318c9e4409d5bb780" translate="yes" xml:space="preserve">
          <source>To return your own non-zero exit code, call &lt;code&gt;halt(ExitCode)&lt;/code&gt;, for example:</source>
          <target state="translated">要返回自己的非零退出代码，请调用 &lt;code&gt;halt(ExitCode)&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="1b79ecfdca80ef63664553eeb43bf5bf50699646" translate="yes" xml:space="preserve">
          <source>To revert to the old representation of the types, use option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">要恢复为旧的类型表示形式，请使用 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="91cba5ad0a4514ff3580b9b3644134649e4008a3" translate="yes" xml:space="preserve">
          <source>To run DTLS add the option {protocol, dtls} to third argument.</source>
          <target state="translated">要运行DTLS,请在第三个参数中添加{protocol,dtls}选项。</target>
        </trans-unit>
        <trans-unit id="6379d836d463079cbc440c281ea46705465f1d9e" translate="yes" xml:space="preserve">
          <source>To run it manually do the following:</source>
          <target state="translated">要手动运行它,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="adfad10f00ccaf0e104d2a8e3a7d4d9ca3d7a1f4" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data from a test case that is to be skipped, return tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt;.</source>
          <target state="translated">要保存要跳过的测试用例中的 &lt;code&gt;Config&lt;/code&gt; 数据，请返回元组 &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="519bc4bce2b33dabd607dc6ed921c16f90d09ddb" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data, return tuple &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; from &lt;code&gt;end_per_testcase&lt;/code&gt; or from the main test case function.</source>
          <target state="translated">要保存 &lt;code&gt;Config&lt;/code&gt; 数据，请从 &lt;code&gt;end_per_testcase&lt;/code&gt; 或主测试用例函数返回元组 &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c3f8d5138cdbd33fa95b3ba65e0753971bf624" translate="yes" xml:space="preserve">
          <source>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</source>
          <target state="translated">为了很好地扩展,最好确保记录均匀地分布在所有碎片上,包括新的碎片。</target>
        </trans-unit>
        <trans-unit id="4c8083213bdb28df6c894a96e97a47fb6b900182" translate="yes" xml:space="preserve">
          <source>To schedule a dirty NIF for execution, the application has two options:</source>
          <target state="translated">要安排脏NIF的执行,应用程序有两个选项。</target>
        </trans-unit>
        <trans-unit id="2dcc54bfbac822c2d50a90e01df3c8520791a56a" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">要查看所有受支持的密码套件，请致电 &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt; 。连接可用的密码套件取决于您的证书。还可以指定您希望连接使用的特定密码套件。默认是使用最强的可用。</target>
        </trans-unit>
        <trans-unit id="faa6a0098bcbb7837e8269c97adc5d1ee4575f3f" translate="yes" xml:space="preserve">
          <source>To see more detailed information about a node, double-click the row, or right-click the row and select &lt;strong&gt;Properties for node &amp;lt;node&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;, to open the detailed information window for the controlling port.</source>
          <target state="translated">要查看有关节点的更多详细信息，请双击该行，或右键单击该行，然后选择&lt;strong&gt;节点&amp;lt;node&amp;gt;的属性&lt;/strong&gt;。从右键单击菜单，您还可&lt;strong&gt;以为&amp;lt;port&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;，以打开控制端口的详细信息窗口。</target>
        </trans-unit>
        <trans-unit id="9b51fe379feee1d788abaddbf99683f3e6711cc7" translate="yes" xml:space="preserve">
          <source>To see relevant version information for ssl, call &lt;code&gt;ssl:versions/0&lt;/code&gt; .</source>
          <target state="translated">要查看ssl的相关版本信息，请调用 &lt;code&gt;ssl:versions/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f1a753c21aa1ee5d67b189d4fc20785c035d677" translate="yes" xml:space="preserve">
          <source>To see what names there are:</source>
          <target state="translated">要看看有哪些名字。</target>
        </trans-unit>
        <trans-unit id="1859a2e235479aee5e6ed677756b1cdde77dacdb" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">要查看系统中当前安装了哪些过滤器，请使用 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 。筛选器按应用顺序列出，也就是说，列表中的第一个筛选器将首先应用，依此类推。</target>
        </trans-unit>
        <trans-unit id="45a5562edb75b6f3eb1acaabf3b28d155bb31931" translate="yes" xml:space="preserve">
          <source>To select more text than fits in the window, start by selecting a small part in the beginning of the text you want, then use the scrollbar to view the end of the desired selection, point to it, and press the &lt;strong&gt;right&lt;/strong&gt; mouse button. The whole area between your first selection and the point where you right-clicked is included in the selection.</source>
          <target state="translated">要选择比窗口调整更多的文字，在你想要的文本的开始选择一小部分开始，然后使用滚动条来查看所需的选择结束后，指向它，并按下&lt;strong&gt;右&lt;/strong&gt;鼠标键。从第一个选择到您右键单击的点之间的整个区域都包括在选择中。</target>
        </trans-unit>
        <trans-unit id="33c0c20ef88e8a421c1e58b4d073cd8cec174df4" translate="yes" xml:space="preserve">
          <source>To select text in the &lt;code&gt;werl&lt;/code&gt; window, press and hold the left mouse button and drag the mouse over the text you want to select. If the selection crosses line boundaries, the selected text consists of complete lines where applicable (just like in a word processor).</source>
          <target state="translated">要在 &lt;code&gt;werl&lt;/code&gt; 窗口中选择文本，请按住鼠标左键，然后将鼠标拖到要选择的文本上。如果所选内容跨越行边界，则所选文本将在适用的情况下由完整的行组成（就像在文字处理器中一样）。</target>
        </trans-unit>
        <trans-unit id="baa709b93b3829a0df77188d6fd0ef0592956e57" translate="yes" xml:space="preserve">
          <source>To separate the first elements of the list from the rest of the list, &lt;code&gt;|&lt;/code&gt; is used. &lt;code&gt;First&lt;/code&gt; has got value 1 and &lt;code&gt;TheRest&lt;/code&gt; has got the value [2,3,4,5].</source>
          <target state="translated">要将列表的第一个元素与列表的其余部分分开， &lt;code&gt;|&lt;/code&gt; 。用来。 &lt;code&gt;First&lt;/code&gt; 的值为1， &lt;code&gt;TheRest&lt;/code&gt; 的值为[2,3,4,5]。</target>
        </trans-unit>
        <trans-unit id="c01449dac6b2c1e79ac6f7a80fed6fdc43f67423" translate="yes" xml:space="preserve">
          <source>To set the default handler, that starts initially with the Kernel application, to log to file instead of &lt;code&gt;standard_io&lt;/code&gt;, change the Kernel default logger configuration. Example:</source>
          <target state="translated">要设置最初从Kernel应用程序开始的默认处理程序，以记录到文件而不是 &lt;code&gt;standard_io&lt;/code&gt; ，请更改Kernel默认记录器配置。例：</target>
        </trans-unit>
        <trans-unit id="f3ccaabc6c6c384fa4607146b378de54d2e651c3" translate="yes" xml:space="preserve">
          <source>To set the time warp mode, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要设置时间扭曲模式，请将命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa0688ed50c18775a5b27e32c9d7ee33f891bdef" translate="yes" xml:space="preserve">
          <source>To set up Erlang distribution over TLS:</source>
          <target state="translated">要在TLS上设置Erlang分发。</target>
        </trans-unit>
        <trans-unit id="d2cce9d630a9f1b9f9af96de1b5c45472cb5cc3c" translate="yes" xml:space="preserve">
          <source>To set up client/server connections:</source>
          <target state="translated">要设置客户机/服务器连接。</target>
        </trans-unit>
        <trans-unit id="b43c85b2017cddcd0eeca4a7ee756681a2b5279f" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a UNIX systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt; in the your home directory.</source>
          <target state="translated">要在UNIX系统上设置Erlang Emacs模式，请在主目录中编辑/创建文件 &lt;code&gt;.emacs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17525f3111c9dc221811cc59d7953bea94c55a6a" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a Windows systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt;, the location of the file depends on the configuration of the system. If the &lt;strong&gt;HOME&lt;/strong&gt; environment variable is set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in the directory indicated by the &lt;strong&gt;HOME&lt;/strong&gt; variable. If &lt;strong&gt;HOME&lt;/strong&gt; is not set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in &lt;code&gt;C:\&lt;/code&gt;.</source>
          <target state="translated">要在Windows系统上设置Erlang Emacs模式，请编辑/创建文件 &lt;code&gt;.emacs&lt;/code&gt; ，文件的位置取决于系统的配置。如果设置了&lt;strong&gt;HOME&lt;/strong&gt;环境变量，则Emacs将在&lt;strong&gt;HOME&lt;/strong&gt;变量指示的目录中查找 &lt;code&gt;.emacs&lt;/code&gt; 文件。如果未设置&lt;strong&gt;HOME&lt;/strong&gt;，则Emacs将在 &lt;code&gt;C:\&lt;/code&gt; 中查找 &lt;code&gt;.emacs&lt;/code&gt; 文件。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b3c1a4e5864dbab572e9a5afb37792b236ea4a2" translate="yes" xml:space="preserve">
          <source>To simplify driver replacement, avoid designing your system so that more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has the driver loaded.</source>
          <target state="translated">为了简化驱动程序的替换，请避免设计系统，以便多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="6657bbbea9ee8b248ced80c3f983940e0a515151" translate="yes" xml:space="preserve">
          <source>To simulate a busy server, you can insert a delay between when &lt;code&gt;epmd&lt;/code&gt; gets notified that a new connection is requested and when the connection gets accepted.</source>
          <target state="translated">为了模拟繁忙的服务器，您可以在 &lt;code&gt;epmd&lt;/code&gt; 收到请求新连接的通知与连接被接受之间插入一个延迟。</target>
        </trans-unit>
        <trans-unit id="70ce8a79d8ffb4771e6a29808f1bcbc9c8b69320" translate="yes" xml:space="preserve">
          <source>To specify if the &lt;code&gt;cover&lt;/code&gt; tool is to be stopped after the test is completed (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定在测试完成后是否要停止 &lt;code&gt;cover&lt;/code&gt; 工具（请参见 &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f982d3b08151a090766a53c8ae58a0af1c7b2c36" translate="yes" xml:space="preserve">
          <source>To specify in which order groups are to be executed (also with respect to test cases that are not part of any group), add tuples on the form &lt;code&gt;{group,GroupName}&lt;/code&gt; to the &lt;code&gt;all/0&lt;/code&gt; list.</source>
          <target state="translated">要指定按什么顺序执行组（还针对不属于任何组的测试用例），请将格式为 &lt;code&gt;{group,GroupName}&lt;/code&gt; 的元组添加到 &lt;code&gt;all/0&lt;/code&gt; 列表中。</target>
        </trans-unit>
        <trans-unit id="1db9eb6998e57480fd022b5b675c80cbbd9dce31" translate="yes" xml:space="preserve">
          <source>To specify starting line for scanning in document which contains fragments of XML.</source>
          <target state="translated">指定包含 XML 片段的文档的扫描起始行。</target>
        </trans-unit>
        <trans-unit id="f61119c7e1b2cdde6ff6d2fa7c86881726228a8c" translate="yes" xml:space="preserve">
          <source>To specify the modules to be included in the code coverage test, provide a cover specification file. With this file you can point out specific modules or specify directories containing modules to be included in the analysis. You can also specify modules to be excluded from the analysis.</source>
          <target state="translated">要指定要包含在代码覆盖测试中的模块,请提供一个封面规范文件。通过这个文件,您可以指出特定的模块,或者指定包含模块的目录,以便包含在分析中。您也可以指定要从分析中排除的模块。</target>
        </trans-unit>
        <trans-unit id="a7e24433e118f3675a94b0839832059d75700c72" translate="yes" xml:space="preserve">
          <source>To specify which PLT, use option &lt;code&gt;--plt&lt;/code&gt;.</source>
          <target state="translated">要指定哪个PLT，请使用选项 &lt;code&gt;--plt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d24b6fe052b97ca4a3faae65960b6ff118b488" translate="yes" xml:space="preserve">
          <source>To speed up the execution of &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt;, first call &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt;, using option &lt;code&gt;purge&lt;/code&gt;. This does the same check for old code. Then purges all modules that can be soft-purged. The purged modules do then no longer have any old code, and &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; does not need to do the checks.</source>
          <target state="translated">为了加快 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 的执行速度，请先使用选项 &lt;code&gt;purge&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt; 。对旧代码执行相同的检查。然后清除所有可以软清除的模块。然后，清除的模块不再具有任何旧代码，并且 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 不需要进行检查。</target>
        </trans-unit>
        <trans-unit id="881ed36f05e94ae0a21c8004b304eb3bc37646d6" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first message in a sequence.</source>
          <target state="translated">要启动顺序跟踪,用户必须在将发送顺序中第一条消息的进程中明确设置跟踪令牌。</target>
        </trans-unit>
        <trans-unit id="76f1852c3add5606a83bf5fb3f21588a546c38d4" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在远程节点上启动类似的跟踪器，请使用 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af5676be701d6ebffdcd18fcceb076e666de274b" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在远程节点上启动类似的跟踪器，请使用 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="069df5419adf0afb2c7538e01048c5b636cbd10a" translate="yes" xml:space="preserve">
          <source>To start all applications specified in the original &lt;code&gt;mysystem.rel&lt;/code&gt; file, use flag &lt;code&gt;-boot&lt;/code&gt; as follows:</source>
          <target state="translated">要开始在原指定的所有应用程序 &lt;code&gt;mysystem.rel&lt;/code&gt; 文件，使用标志 &lt;code&gt;-boot&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="c6430f32849bacfbbbfdd73794b90f8a5cb5633c" translate="yes" xml:space="preserve">
          <source>To start an &lt;strong&gt;embedded target system&lt;/strong&gt;, the shell script &lt;code&gt;bin/start&lt;/code&gt; is used. The script calls &lt;code&gt;bin/run_erl&lt;/code&gt;, which in turn calls &lt;code&gt;bin/start_erl&lt;/code&gt; (roughly, &lt;code&gt;start_erl&lt;/code&gt; is an embedded variant of &lt;code&gt;erl&lt;/code&gt;).</source>
          <target state="translated">要启动&lt;strong&gt;嵌入式目标系统&lt;/strong&gt;，请使用shell脚本 &lt;code&gt;bin/start&lt;/code&gt; 。该脚本调用 &lt;code&gt;bin/run_erl&lt;/code&gt; ，而后者又调用 &lt;code&gt;bin/start_erl&lt;/code&gt; （大致上， &lt;code&gt;start_erl&lt;/code&gt; 是 &lt;code&gt;erl&lt;/code&gt; 的嵌入式变体）。</target>
        </trans-unit>
        <trans-unit id="9d22fc7b6b61af9ef2d6145dba2c1c36bbe3774d" translate="yes" xml:space="preserve">
          <source>To start an event manager for handling errors, as described in the previous example, call the following function:</source>
          <target state="translated">要启动一个用于处理错误的事件管理器,如前面的例子所述,调用以下函数。</target>
        </trans-unit>
        <trans-unit id="65443b4fc91dab6b76dab71d1d80de342db77ebd" translate="yes" xml:space="preserve">
          <source>To start the &lt;code&gt;Company&lt;/code&gt; database and get it running on the two specified nodes, enter the following commands:</source>
          <target state="translated">要启动 &lt;code&gt;Company&lt;/code&gt; 数据库并使它在两个指定的节点上运行，请输入以下命令：</target>
        </trans-unit>
        <trans-unit id="b812e0ece5117a4dc75569139c24b19927c8e4d0" translate="yes" xml:space="preserve">
          <source>To start the debug enabled runtime system execute:</source>
          <target state="translated">要启动启用调试的运行时系统执行。</target>
        </trans-unit>
        <trans-unit id="7fffc54b92267ef311f536c196ba13936bd59530" translate="yes" xml:space="preserve">
          <source>To start the interactive shell mode, start an Erlang shell manually and call &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; to install any configuration data you might need (use &lt;code&gt;[]&lt;/code&gt; as argument otherwise). Then call &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">要启动交互式shell模式，请手动启动Erlang shell并调用 &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; 来安装您可能需要的任何配置数据（否则使用 &lt;code&gt;[]&lt;/code&gt; 作为参数）。然后调用 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 启动 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2407e72a3ed0dce989e1ddb620f5b91d6fb2b5a8" translate="yes" xml:space="preserve">
          <source>To start, open a registry:</source>
          <target state="translated">首先,打开一个注册表。</target>
        </trans-unit>
        <trans-unit id="37329084650848867e8284198738d0867fe2834a" translate="yes" xml:space="preserve">
          <source>To stop Erlang Top, use function &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要停止Erlang Top，请使用功能 &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a960f069bc98edbba1ff0928e02093c32ffad4" translate="yes" xml:space="preserve">
          <source>To stop a distributed application, &lt;code&gt;stop/1&lt;/code&gt; must be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to &lt;code&gt;stop/1&lt;/code&gt; on the node where the application currently executes stops its execution. The application is not moved between nodes, as &lt;code&gt;stop/1&lt;/code&gt; is called on the node where the application currently executes before &lt;code&gt;stop/1&lt;/code&gt; is called on the other nodes.</source>
          <target state="translated">要停止分布式应用程序，必须在其可以执行的所有节点上（即，在已启动它的所有节点上）调用 &lt;code&gt;stop/1&lt;/code&gt; 。在应用程序当前执行的节点上对 &lt;code&gt;stop/1&lt;/code&gt; 的调用将停止其执行。本申请并不节点之间移动时，作为 &lt;code&gt;stop/1&lt;/code&gt; 被调用，其中该应用程序之前，执行当前的节点上 &lt;code&gt;stop/1&lt;/code&gt; 被调用的其他节点上。</target>
        </trans-unit>
        <trans-unit id="5b81bcf2bbed22c8b9d584525dc2bbe3c5752e21" translate="yes" xml:space="preserve">
          <source>To stop one or more tests, use function &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (to stop all) or &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要停止一个或多个测试，请使用函数 &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; （停止所有）或 &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b41c55a13290a9e7e9fdbffa7dec308f34e8baa6" translate="yes" xml:space="preserve">
          <source>To stop the Erlang emulator, close the &lt;code&gt;werl&lt;/code&gt; window.</source>
          <target state="translated">要停止Erlang仿真器，请关闭 &lt;code&gt;werl&lt;/code&gt; 窗口。</target>
        </trans-unit>
        <trans-unit id="805a085d9254eb5937e5f4dd565453dd8d6af7f9" translate="yes" xml:space="preserve">
          <source>To sum up this section: &lt;strong&gt;Do not use &lt;code&gt;erlang:now/0&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">总结本节：&lt;strong&gt;不要使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4c3f23c8b7d11fd791f43a0f06c76ab501c60d6" translate="yes" xml:space="preserve">
          <source>To summarize, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; only needs to create &lt;strong&gt;one&lt;/strong&gt; match context and no sub binaries.</source>
          <target state="translated">总而言之， &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 仅需要创建&lt;strong&gt;一个&lt;/strong&gt;匹配上下文，而无需子二进制文件。</target>
        </trans-unit>
        <trans-unit id="76f6d1c7fd98a557f9e7456fd478d01cb713b47b" translate="yes" xml:space="preserve">
          <source>To support Unicode in Erlang, problems in various areas have been addressed. This section describes each area briefly and more thoroughly later in this User's Guide.</source>
          <target state="translated">为了支持Erlang中的Unicode,已经解决了各个领域的问题。本节将在本用户指南中简要介绍每个领域,并在后面更详细地介绍。</target>
        </trans-unit>
        <trans-unit id="490eb8f14b00a3993b65db4b76111ea78b82422f" translate="yes" xml:space="preserve">
          <source>To support the debug facilites in &lt;code&gt;sys&lt;/code&gt;, a &lt;strong&gt;debug structure&lt;/strong&gt; is needed. The &lt;code&gt;Deb&lt;/code&gt; term is initialized using &lt;code&gt;sys:debug_options/1&lt;/code&gt;:</source>
          <target state="translated">为了支持 &lt;code&gt;sys&lt;/code&gt; 中的&lt;strong&gt;调试工具&lt;/strong&gt;，需要一个&lt;strong&gt;调试结构&lt;/strong&gt;。所述 &lt;code&gt;Deb&lt;/code&gt; 术语是使用初始化 &lt;code&gt;sys:debug_options/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="27cb03280676d8f91c2c5f4617f6dcad84db1918" translate="yes" xml:space="preserve">
          <source>To take Erlang down gracefully, see the &lt;code&gt;erl_call(1)&lt;/code&gt; manual page in &lt;code&gt;erl_interface&lt;/code&gt; for details on the use of &lt;code&gt;erl_call&lt;/code&gt;. However, that requires that Erlang runs as a distributed node, which is not always the case.</source>
          <target state="translated">要使Erlang正常运行，请参阅 &lt;code&gt;erl_interface&lt;/code&gt; 中的 &lt;code&gt;erl_call(1)&lt;/code&gt; 手册页，以获取有关 &lt;code&gt;erl_call&lt;/code&gt; 的使用的详细信息。但是，这要求Erlang作为分布式节点运行，但情况并非总是如此。</target>
        </trans-unit>
        <trans-unit id="794cd63b456b29e5f25c1b3a3a1a7cadacb90ffd" translate="yes" xml:space="preserve">
          <source>To test the distribution, the &lt;code&gt;net_kernel:start/1&lt;/code&gt; function can be used. It is useful, as it starts the distribution on a running system, where tracing/debugging can be performed. The &lt;code&gt;net_kernel:start/1&lt;/code&gt; routine takes a list as its single argument. The list first element in the list is to be the node name (without the &quot;@hostname&quot;) as an atom. The second (and last) element is to be one of the atoms &lt;code&gt;shortnames&lt;/code&gt; or &lt;code&gt;longnames&lt;/code&gt;. In the example case, &lt;code&gt;shortnames&lt;/code&gt; is preferred.</source>
          <target state="translated">要测试分发，可以使用 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 函数。这很有用，因为它可以在运行中的系统上开始分发，可以在其中执行跟踪/调试。该 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 例行取一个列表作为它的一个参数。列表中列表的第一个元素是作为原子的节点名称（不带&amp;ldquo; @hostname&amp;rdquo;）。第二个（也是最后一个）元素将成为原子 &lt;code&gt;shortnames&lt;/code&gt; 或 &lt;code&gt;longnames&lt;/code&gt; 之一。在示例情况下， &lt;code&gt;shortnames&lt;/code&gt; 是首选。</target>
        </trans-unit>
        <trans-unit id="1e25ada887f1b7f960ffeb09cb03b19c929e33ba" translate="yes" xml:space="preserve">
          <source>To the extent that it's practical, support SystemTap on Linux via DTrace provider compatibility.</source>
          <target state="translated">在切实可行的范围内,通过 DTrace 提供商的兼容性来支持 Linux 上的 SystemTap。</target>
        </trans-unit>
        <trans-unit id="fded3aabb510b1e1a75f760a53342f304a3c739e" translate="yes" xml:space="preserve">
          <source>To to start the application (agent and/or manager), the configuration files must be modified and there are two ways of doing this. Either edit the files manually, or run the configuration tool as follows.</source>
          <target state="translated">要启动应用程序(代理和/或管理器),必须修改配置文件,有两种方法。手动编辑文件,或者运行配置工具,如下所示。</target>
        </trans-unit>
        <trans-unit id="840859542432e2ae9a768d1a2567eb03227d2acc" translate="yes" xml:space="preserve">
          <source>To trace function calls, you also need to set up &lt;strong&gt;trace patterns&lt;/strong&gt;. Trace patterns select the function calls to be traced. The number of traced function calls can be further reduced with &lt;strong&gt;match specifications&lt;/strong&gt;. Match specifications can also be used to trigger more information in the trace messages.</source>
          <target state="translated">要跟踪函数调用，还需要设置&lt;strong&gt;跟踪模式&lt;/strong&gt;。跟踪模式选择要跟踪的函数调用。&lt;strong&gt;匹配规范&lt;/strong&gt;可以进一步减少跟踪的函数调用的数量。匹配规范还可用于触发跟踪消息中的更多信息。</target>
        </trans-unit>
        <trans-unit id="0c07cb7f2e8d2563df9d5fc9199e90556dc33e70" translate="yes" xml:space="preserve">
          <source>To trigger file compression, its extension must match with the &lt;code&gt;compress&lt;/code&gt; condition and must not match the &lt;code&gt;uncompress&lt;/code&gt; condition. For example, if &lt;code&gt;compress&lt;/code&gt; is set to &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; is set to &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt;, only files with extension &lt;code&gt;&quot;gif&quot;&lt;/code&gt; are compressed.</source>
          <target state="translated">要触发文件压缩，其扩展名必须与 &lt;code&gt;compress&lt;/code&gt; 条件匹配，并且必须与 &lt;code&gt;uncompress&lt;/code&gt; 条件不匹配。例如，如果 &lt;code&gt;compress&lt;/code&gt; 设置为 &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; ， &lt;code&gt;uncompress&lt;/code&gt; 设置为 &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt; ，则仅扩展名为 &lt;code&gt;&quot;gif&quot;&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="bdcf647abab37b8b3f8542efaeba10430ea6f745" translate="yes" xml:space="preserve">
          <source>To turn off the Debugger stack trace facility, select option &lt;strong&gt;Stack Off&lt;/strong&gt;.</source>
          <target state="translated">要关闭调试器堆栈跟踪工具，请选择选项&lt;strong&gt;Stack Off&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="25889e4ee1555771488e4d2de1a7bf2d51b5a3ab" translate="yes" xml:space="preserve">
          <source>To turn off warnings for improper lists, add the following line to the source file:</source>
          <target state="translated">要关闭不当列表的警告,请在源文件中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="8ed98f94cb168a3368774c5de90ad9aac72676b6" translate="yes" xml:space="preserve">
          <source>To understand the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup, it is essential to understand how &lt;code&gt;Mnesia&lt;/code&gt; reacts when it loses contact with &lt;code&gt;Mnesia&lt;/code&gt; on another node. At this stage, &lt;code&gt;Mnesia&lt;/code&gt; cannot distinguish between a communication failure and a &quot;normal&quot; node-down. When this occurs, &lt;code&gt;Mnesia&lt;/code&gt; assumes that the other node is no longer running, whereas, in reality, the communication between the nodes has failed.</source>
          <target state="translated">要了解 &lt;code&gt;Mnesia&lt;/code&gt; 在启动时的行为，必须了解 &lt;code&gt;Mnesia&lt;/code&gt; 在与另一个节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 失去联系时的反应。在此阶段， &lt;code&gt;Mnesia&lt;/code&gt; 无法区分通信失败和&amp;ldquo;正常&amp;rdquo;节点中断。发生这种情况时， &lt;code&gt;Mnesia&lt;/code&gt; 假定另一个节点不再运行，而实际上，这些节点之间的通信已失败。</target>
        </trans-unit>
        <trans-unit id="57ca1753f443dcffddf87cab0a01f1c5e59426d5" translate="yes" xml:space="preserve">
          <source>To understand this text, you also have to look at the &lt;code&gt;yacc&lt;/code&gt; documentation in the UNIX(TM) manual. This is most probably necessary in order to understand the idea of a parser generator, and the principle and problems of LALR parsing with finite look-ahead.</source>
          <target state="translated">要理解本文，您还必须查看UNIX&amp;trade;手册中的 &lt;code&gt;yacc&lt;/code&gt; 文档。为了理解解析器生成器的概念以及有限提前预知的LALR解析的原理和问题，这很有可能是必需的。</target>
        </trans-unit>
        <trans-unit id="257c2b917b12b68949e96a87bad80aa179cede62" translate="yes" xml:space="preserve">
          <source>To understand what is discussed and examplified here, we recommended you to first read section &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要了解此处讨论和例证的内容，我们建议您首先阅读&amp;ldquo; &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="a0d1537131067c43e7df0631cf8f01ef0dfa991f" translate="yes" xml:space="preserve">
          <source>To unregister a name:</source>
          <target state="translated">要取消注册一个名字:</target>
        </trans-unit>
        <trans-unit id="2d2a671d4b2f16d7f91c51ff47e2d4c92fb46607" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">要注销已发布的节点，应关闭 &lt;code&gt;ei_publish()&lt;/code&gt; 返回的描述符。</target>
        </trans-unit>
        <trans-unit id="f3c7fc1b435a8defaf215479b11edd52150783be" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should instead close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">要取消注册已发布的节点，您应该关闭 &lt;code&gt;ei_publish()&lt;/code&gt; 返回的描述符。</target>
        </trans-unit>
        <trans-unit id="2b518c28463d854508111ea65fca22a57c4c2cf2" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor.</source>
          <target state="translated">要取消在EPMD的注册,只需关闭返回的描述符即可。</target>
        </trans-unit>
        <trans-unit id="769d2fa177fb9e7db683f9606bab6d12279b1eda" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor. Do not use &lt;code&gt;ei_unpublish()&lt;/code&gt;, which is deprecated anyway.</source>
          <target state="translated">要注销EPMD，只需关闭返回的描述符。请勿使用 &lt;code&gt;ei_unpublish()&lt;/code&gt; ，无论如何都不要使用它。</target>
        </trans-unit>
        <trans-unit id="84b4679c04fbfbaa9588413bb040c5640c41eacc" translate="yes" xml:space="preserve">
          <source>To upgrade &lt;code&gt;ch_app&lt;/code&gt; from &lt;code&gt;&quot;1&quot;&lt;/code&gt; to &lt;code&gt;&quot;2&quot;&lt;/code&gt; (and to downgrade from &lt;code&gt;&quot;2&quot;&lt;/code&gt; to &lt;code&gt;&quot;1&quot;&lt;/code&gt;), you only need to load the new (old) version of the &lt;code&gt;ch3&lt;/code&gt; callback module. Create the application upgrade file &lt;code&gt;ch_app.appup&lt;/code&gt; in the &lt;code&gt;ebin&lt;/code&gt; directory:</source>
          <target state="translated">要将 &lt;code&gt;ch_app&lt;/code&gt; 从 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 升级到 &lt;code&gt;&quot;2&quot;&lt;/code&gt; （并从 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 降级到 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ），您只需要加载 &lt;code&gt;ch3&lt;/code&gt; 回调模块的新（旧）版本。在 &lt;code&gt;ebin&lt;/code&gt; 目录中创建应用程序升级文件 &lt;code&gt;ch_app.appup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f84bf7f2f7861b776ed5c35e1c7e32583ad5a627" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to an SSL connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">要将TCP/IP连接升级为SSL连接,客户端和服务器必须同意这样做。该协议可通过使用RFC 2817中指定的HTTP等协议来完成。</target>
        </trans-unit>
        <trans-unit id="3a48c54fe1c18b840875cc0d8882a5c73ce80e02" translate="yes" xml:space="preserve">
          <source>To upgrade to an SSL connection:</source>
          <target state="translated">要升级到SSL连接。</target>
        </trans-unit>
        <trans-unit id="ea7b425544bac4acf2d4b893b416d117aa7a59a1" translate="yes" xml:space="preserve">
          <source>To use Debugger, the basic steps are as follows:</source>
          <target state="translated">要使用Debugger,基本步骤如下。</target>
        </trans-unit>
        <trans-unit id="68fe3f1ab7b67db6b1b7b0c723fb8ab99d7ba09b" translate="yes" xml:space="preserve">
          <source>To use a literal &lt;code&gt;*&lt;/code&gt; character as &lt;code&gt;Pad&lt;/code&gt;, it must be passed as an argument:</source>
          <target state="translated">要将文字 &lt;code&gt;*&lt;/code&gt; 用作 &lt;code&gt;Pad&lt;/code&gt; ，必须将其作为参数传递：</target>
        </trans-unit>
        <trans-unit id="bfffbe9810584067e7d160ff8bce5770cf34f906" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following lines in your code:</source>
          <target state="translated">要使用任何 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数，请在代码中包含以下几行：</target>
        </trans-unit>
        <trans-unit id="e865188bf7a27ada82ac1699872c1f2decf0665c" translate="yes" xml:space="preserve">
          <source>To use encrypted debug information, a key must be provided to the compiler and &lt;code&gt;beam_lib&lt;/code&gt;. The key is specified as a string. It is recommended that the string contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used.</source>
          <target state="translated">要使用加密的调试信息，必须向编译器和 &lt;code&gt;beam_lib&lt;/code&gt; 提供密钥。键指定为字符串。建议该字符串至少包含32个字符，并且同时使用大写和小写字母以及数字和特殊字符。</target>
        </trans-unit>
        <trans-unit id="eb23e34638bd9093d10ee97bb3a0e372512e3fc8" translate="yes" xml:space="preserve">
          <source>To use event handlers written for &lt;code&gt;error_logger&lt;/code&gt;, just add your event handler with</source>
          <target state="translated">要使用为 &lt;code&gt;error_logger&lt;/code&gt; 编写的事件处理程序，只需添加带有</target>
        </trans-unit>
        <trans-unit id="0bdc7b110d3152a509f4766a597abefcfa1ed87d" translate="yes" xml:space="preserve">
          <source>To use the Erlang shell to run our test, you can evaluate the following call:</source>
          <target state="translated">要使用Erlang shell来运行我们的测试,你可以评估以下调用。</target>
        </trans-unit>
        <trans-unit id="0f4462aadd9025ab266be32a2032bf299d0b46f7" translate="yes" xml:space="preserve">
          <source>To use the disk_log handler instead of the default standard handler when starting an Erlang node, change the Kernel default logger to use &lt;code&gt;logger_disk_log_h&lt;/code&gt;. Example:</source>
          <target state="translated">要在启动Erlang节点时使用disk_log处理程序而不是默认的标准处理程序，请将内核默认记录程序更改为使用 &lt;code&gt;logger_disk_log_h&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="48d471ac0f461634b1a46f1744c359ab442ae3b1" translate="yes" xml:space="preserve">
          <source>To use the functions &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;release_shell&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">要使用功能 &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt; ，&lt;strong&gt;必须&lt;/strong&gt;将 &lt;code&gt;release_shell&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d698f2ffb5c429ffda0ac4557a52f1824b92cf1d" translate="yes" xml:space="preserve">
          <source>To use the pseudo functions triggering the translation, ensure to include the header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code. Failure to do so possibly results in runtime errors rather than compile time, as the expression can be valid as a plain Erlang program without translation.</source>
          <target state="translated">要使用触发转换的伪函数，请确保在源代码中包含头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 。未能执行此操作可能会导致运行时错误，而不是编译时，因为该表达式可以作为普通的Erlang程序有效而无需翻译。</target>
        </trans-unit>
        <trans-unit id="03f67b62fca597162026995f6815a18764fa1055" translate="yes" xml:space="preserve">
          <source>To use the real implementation, we must recompile the MIB and load it into the agent.</source>
          <target state="translated">为了使用真正的实现,我们必须重新编译MIB并将其加载到代理中。</target>
        </trans-unit>
        <trans-unit id="002952436d64ac58aa3de156b66387b85dc58e15" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">使用此功能添加驻留在动态加载的代码中的驱动程序很危险。如果添加的驱动程序的驱动程序代码与普通的动态加载的驱动程序（通过 &lt;code&gt;erl_ddll&lt;/code&gt; 接口加载）位于同一动态加载的模块（即 &lt;code&gt;.so&lt;/code&gt; 文件）中，则调用者将在添加驱动程序条目之前调用 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06c29935ed139b37075ecc2db062cd1dfb073f59" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute in both phases is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要使用此模式，请确保将在两个阶段中都执行的所有Erlang代码都是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af48a71f55d5ffa8ab787fda3994e5f52dec889c" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute on the runtime system is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要使用此模式，请确保将在运行时系统上执行的所有Erlang代码都是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="847b164165eea8a7ac372dcfbedc4f6fbc9d1539" translate="yes" xml:space="preserve">
          <source>To use this program, you need to:</source>
          <target state="translated">要使用这个程序,你需要:</target>
        </trans-unit>
        <trans-unit id="6a7e1aba43c701aa62b9243d847578c39295abed" translate="yes" xml:space="preserve">
          <source>To use this with threads and asynchronous routines, create a pipe on Unix and an &lt;code&gt;Event&lt;/code&gt; on Windows. When the routine completes, write to the pipe (use &lt;code&gt;SetEvent&lt;/code&gt; on Windows), this makes the emulator call &lt;code&gt;ready_input&lt;/code&gt; or &lt;code&gt;ready_output&lt;/code&gt;.</source>
          <target state="translated">要将其用于线程和异步例程，请在Unix上创建管道，在Windows 上创建 &lt;code&gt;Event&lt;/code&gt; 。例程完成后，写入管道（在Windows上使用 &lt;code&gt;SetEvent&lt;/code&gt; ），这将使模拟器调用 &lt;code&gt;ready_input&lt;/code&gt; 或 &lt;code&gt;ready_output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01b8773f5a669a11ac026442b354c5f873c02791" translate="yes" xml:space="preserve">
          <source>To validate the configuration strings, the callback module is to have function &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; exported.</source>
          <target state="translated">为了验证配置字符串，回调模块将导出函数 &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe32e508b386431ed270d6f4036397947cfdf797" translate="yes" xml:space="preserve">
          <source>To verify that everything is ok you should open &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; in your web browser and make sure that there are zero failed test cases.</source>
          <target state="translated">要验证一切正常，您应该在网络浏览器中打开 &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; 并确保失败的测试用例为零。</target>
        </trans-unit>
        <trans-unit id="816f7f291832fe5da7fded15c95dc5548b14b744" translate="yes" xml:space="preserve">
          <source>To verify that lock counting is enabled check that &lt;code&gt;[lock-counting]&lt;/code&gt; appears in the status text when the VM is started.</source>
          <target state="translated">要验证是否启用了锁定计数，请在启动VM时检查 &lt;code&gt;[lock-counting]&lt;/code&gt; 是否出现在状态文本中。</target>
        </trans-unit>
        <trans-unit id="d79825059ed41d40f1eb38140584c29e49d43c05" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific module, double- click the row, or right-click it and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要查看有关特定模块的详细信息，请双击该行，或右键单击该行，然后&lt;strong&gt;为&amp;lt;mod&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e3ee7cdc20eb34f07a508b3dffa9cad2da375fa2" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific process, double- click the row in the list, or right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要查看有关特定过程的详细信息，请双击列表中的行，或右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f9a2be366e30f8af91ea3157c65f941baf52859b" translate="yes" xml:space="preserve">
          <source>To view more details about a specific port, double-click the row or right-click it and select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;, where &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; is the process connected to the port.</source>
          <target state="translated">要查看有关特定端口的更多详细信息，请双击该行或右键单击该行，然后&lt;strong&gt;为&amp;lt;port&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。从右键单击菜单，您还可&lt;strong&gt;以为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;，其中 &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; 是连接到端口的进程。</target>
        </trans-unit>
        <trans-unit id="7c537dc716e918cf2d036be1a35d64af3e41081c" translate="yes" xml:space="preserve">
          <source>To view the result of a code coverage test, click the button labeled &quot;COVER LOG&quot; in the top-level index page for the test run.</source>
          <target state="translated">要查看代码覆盖率测试的结果,点击测试运行的顶层索引页中标有 &quot;COVER LOG &quot;的按钮。</target>
        </trans-unit>
        <trans-unit id="254465b8f25a6c97a3848f10e6162c3f124f7768" translate="yes" xml:space="preserve">
          <source>To view the result of macro expansion, a module can be compiled with the &lt;code&gt;'P'&lt;/code&gt; option. &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt;. This produces a listing of the parsed code after preprocessing and parse transforms, in the file &lt;code&gt;File.P&lt;/code&gt;.</source>
          <target state="translated">要查看宏扩展的结果，可以使用 &lt;code&gt;'P'&lt;/code&gt; 选项编译模块。 &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt; 。经过预处理和解析转换后，这将在文件 &lt;code&gt;File.P&lt;/code&gt; 中生成一份已解析代码的列表。</target>
        </trans-unit>
        <trans-unit id="2863e2789d755b777cac4c624de8395bb36a4b90" translate="yes" xml:space="preserve">
          <source>To visualize the structure of a syntax tree, you can use the function &lt;code&gt;merl:show(T)&lt;/code&gt;, which prints a summary. For example, entering</source>
          <target state="translated">要形象化语法树的结构，可以使用函数 &lt;code&gt;merl:show(T)&lt;/code&gt; ，该函数将打印摘要。例如，输入</target>
        </trans-unit>
        <trans-unit id="420f383fbb828ef9ba78290b1722db9b09af55f0" translate="yes" xml:space="preserve">
          <source>To work with binaries in ISO Latin-1 encoding, use the &lt;code&gt;file&lt;/code&gt; module instead.</source>
          <target state="translated">要使用ISO Latin-1编码的二进制文件，请改用 &lt;code&gt;file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="9368499385b79811c6e242f08579ba92f510e423" translate="yes" xml:space="preserve">
          <source>To write a function that inserts an employee record into the database, there must be an &lt;code&gt;at_dep&lt;/code&gt; record and a set of &lt;code&gt;in_proj&lt;/code&gt; records inserted. Examine the following code used to complete this action:</source>
          <target state="translated">要编写将员工记录插入数据库的函数，必须有一个 &lt;code&gt;at_dep&lt;/code&gt; 记录和一组 &lt;code&gt;in_proj&lt;/code&gt; 记录。检查以下用于完成此操作的代码：</target>
        </trans-unit>
        <trans-unit id="870bc92e8fb7bb157e38a72767baac7170c3e8c4" translate="yes" xml:space="preserve">
          <source>To write functions that manipulate this data, remember the following:</source>
          <target state="translated">要编写操作这些数据的函数,请记住以下几点。</target>
        </trans-unit>
        <trans-unit id="49f4806c44f9e994d710db8f38c6399e247bca8a" translate="yes" xml:space="preserve">
          <source>To write your own client channel handler, use the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt;. For server channel handlers use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; behaviour (replaces ssh_daemon_channel).</source>
          <target state="translated">要编写自己的客户端通道处理程序，请使用行为 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 。对于服务器通道处理程序，请使用 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 行为（代替ssh_daemon_channel）。</target>
        </trans-unit>
        <trans-unit id="f57b7cb4b41a526a6b5b1f9a162d27692ca9284c" translate="yes" xml:space="preserve">
          <source>Today there are no good ways of solving this problem and therefore the eval scheme can be removed in future release of &lt;code&gt;Inets&lt;/code&gt;.</source>
          <target state="translated">今天没有解决此问题的好方法，因此可以在将来的 &lt;code&gt;Inets&lt;/code&gt; 版本中删除评估方案。</target>
        </trans-unit>
        <trans-unit id="7edb68e9d3675d0ca9b5133bc31d9005c2bc6f47" translate="yes" xml:space="preserve">
          <source>Too long external command.</source>
          <target state="translated">外部命令太长。</target>
        </trans-unit>
        <trans-unit id="b53132babe55797aa27d88cc20db666d7ee40a5b" translate="yes" xml:space="preserve">
          <source>Tools that need to know about optional callback functions can call &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; to get a list of all optional callback functions.</source>
          <target state="translated">需要了解可选回调函数的工具可以调用 &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; 来获取所有可选回调函数的列表。</target>
        </trans-unit>
        <trans-unit id="dd3a74b17c3a112fdfc9b4f6b58e1ba85a6ec96d" translate="yes" xml:space="preserve">
          <source>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by &lt;code&gt;malloc&lt;/code&gt; when &lt;code&gt;sbrk&lt;/code&gt; is called to get more memory from the operating system. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">顶垫大小（以千字节为单位）。这是当调用 &lt;code&gt;sbrk&lt;/code&gt; 从操作系统获取更多内存时， &lt;code&gt;malloc&lt;/code&gt; 分配的额外内存量。默认为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8688b9f02fc264d86ffee1ffffdff34e5d5032b9" translate="yes" xml:space="preserve">
          <source>Total amount of data allocated by an Erlang node</source>
          <target state="translated">一个Erlang节点分配的数据总量。</target>
        </trans-unit>
        <trans-unit id="15b379311d06275e570d3c8276f0c74ac315b01b" translate="yes" xml:space="preserve">
          <source>Total and own</source>
          <target state="translated">合计和自己</target>
        </trans-unit>
        <trans-unit id="c2270f01832f95299124e422ec6e4ca5b86124d0" translate="yes" xml:space="preserve">
          <source>Total memory of all fragments</source>
          <target state="translated">所有碎片的总内存</target>
        </trans-unit>
        <trans-unit id="7e54e8f9975c397f222301a7b10e36746a3fb103" translate="yes" xml:space="preserve">
          <source>Total scheduler utilization will equal &lt;code&gt;1.0&lt;/code&gt; when all schedulers have been active all the time between the two measurements.</source>
          <target state="translated">当两次测量之间所有时间的所有调度程序都处于活动状态时，调度程序的总利用率将等于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f139724c9414120075277ba75a5a2d7bac69ee" translate="yes" xml:space="preserve">
          <source>Total size of all fragments</source>
          <target state="translated">所有碎片的总尺寸</target>
        </trans-unit>
        <trans-unit id="3d7796a77f0c2216ea352ac72490e4ec4449ab38" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers, weighted against maximum amount of available CPU time.</source>
          <target state="translated">所有正常和 dirty-cpu 调度器的总利用率,根据最大可用 CPU 时间加权。</target>
        </trans-unit>
        <trans-unit id="6da5bac4a207bc853f48fee09219f38e35859ae6" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers.</source>
          <target state="translated">所有正常和肮脏的CPU调度器的总利用率。</target>
        </trans-unit>
        <trans-unit id="9bff8a7fc7360671cf907e56ce21842e96c20fad" translate="yes" xml:space="preserve">
          <source>TotalRunQueueLengths</source>
          <target state="translated">TotalRunQueueLengths</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="80bb48f4677c815e975d8c45891c82e4681bcb89" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder</source>
          <target state="translated">跟踪工具生成器</target>
        </trans-unit>
        <trans-unit id="250a4f0c0db1541060f17b5d70ba72e38869d686" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder is a base for building trace tools for single node or distributed Erlang systems. It requires the Runtime_Tools application to be available on the traced node.</source>
          <target state="translated">跟踪工具生成器是为单节点或分布式Erlang系统构建跟踪工具的基础。它要求被跟踪的节点上有Runtime_Tools应用程序。</target>
        </trans-unit>
        <trans-unit id="d0e39bcc8d71bbaa0fa6b28e8699f8f1993f5c4d" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;arity&lt;/code&gt; can be used to change the contents of this message, so that &lt;code&gt;Arity&lt;/code&gt; is specified instead of &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">跟踪标志 &lt;code&gt;arity&lt;/code&gt; 可用于更改此消息的内容，以便指定 &lt;code&gt;Arity&lt;/code&gt; 而不是 &lt;code&gt;Args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2211485216352092a3c7b3ce77ba8fdb799ae23c" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;call&lt;/code&gt; is set on all processes. This means that any function activated with command &lt;code&gt;trc/1&lt;/code&gt; is traced on all existing and new processes.</source>
          <target state="translated">在所有进程上都设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; 。这意味着在所有现有和新进程上都将跟踪使用命令 &lt;code&gt;trc/1&lt;/code&gt; 激活的任何功能。</target>
        </trans-unit>
        <trans-unit id="0712efc6140a7fd34097a10dbcb83e8a2711b2c0" translate="yes" xml:space="preserve">
          <source>Trace garbage collection on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; that prints start, stop, and the time spent for each garbage collection.</source>
          <target state="translated">跟踪指定进程上的垃圾回收。所使用的格式处理程序是 &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; ，它显示开始，停止以及每个垃圾收集所花费的时间。</target>
        </trans-unit>
        <trans-unit id="8ad201247194a3bc5c13be5040f0d1b1e662cf18" translate="yes" xml:space="preserve">
          <source>Trace in-scheduling and out-scheduling on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; that prints each in-scheduling and out-scheduling with process, time-stamp, and current function. It also prints the total time each traced process was scheduled in.</source>
          <target state="translated">跟踪指定进程的计划内和计划外。所使用的格式处理程序是 &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; ，它使用进程，时间戳和当前函数打印每个按计划和按计划进行的计划和计划。它还会打印计划每个跟踪进程的总时间。</target>
        </trans-unit>
        <trans-unit id="ffc9984032978aa3b6449468569d3553d6cf5759" translate="yes" xml:space="preserve">
          <source>Trace messages:</source>
          <target state="translated">追踪信息。</target>
        </trans-unit>
        <trans-unit id="4d4722f0d0980b84f26e05618ea2d6105d2b13ac" translate="yes" xml:space="preserve">
          <source>Trace patterns can also be added for traced messages. Click button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt; and select &lt;strong&gt;Messages sent&lt;/strong&gt; or &lt;strong&gt;Messages received&lt;/strong&gt;, and a match specification.</source>
          <target state="translated">也可以为跟踪的邮件添加跟踪模式。单击按钮&lt;strong&gt;添加跟踪模式，&lt;/strong&gt;然后选择&lt;strong&gt;发送的&lt;/strong&gt;&lt;strong&gt;消息&lt;/strong&gt;或&lt;strong&gt;接收的消息&lt;/strong&gt;，以及匹配规范。</target>
        </trans-unit>
        <trans-unit id="0940d3dfe2f33f718de044f09bc83c6282e8f2ee" translate="yes" xml:space="preserve">
          <source>Trace patterns only apply to the traced processes and ports.</source>
          <target state="translated">跟踪模式只适用于被跟踪的进程和端口。</target>
        </trans-unit>
        <trans-unit id="2a9473289ba2f7fdb4aceac50e9847d3fb9343a9" translate="yes" xml:space="preserve">
          <source>Trace patterns specify how to trace a function or a message by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">跟踪模式指定如何通过使用匹配规范来跟踪功能或消息。比赛规格在《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="a02e22fba6caaac8c0531907ae75bbb4f037b1bf" translate="yes" xml:space="preserve">
          <source>Traces &lt;code&gt;Item&lt;/code&gt; in accordance to the value specified by &lt;code&gt;Flags&lt;/code&gt;. The variation of &lt;code&gt;Item&lt;/code&gt; is listed below:</source>
          <target state="translated">根据 &lt;code&gt;Flags&lt;/code&gt; 指定的值跟踪 &lt;code&gt;Item&lt;/code&gt; 。以下列出了 &lt;code&gt;Item&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="8d86b88eb80a4cb0c1e2e56d320a47a7c0a552ac" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">跟踪某些函数调用。通过调用 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 来指定要跟踪的函数。</target>
        </trans-unit>
        <trans-unit id="e6a38811b152556838705c34470f7050c3304700" translate="yes" xml:space="preserve">
          <source>Traces garbage collections of processes.</source>
          <target state="translated">追踪进程的垃圾收集。</target>
        </trans-unit>
        <trans-unit id="0bfeea5f77e5e80144fb5c69582ff8a4c4aa0a8c" translate="yes" xml:space="preserve">
          <source>Traces global function calls for the process according to the trace patterns set in the system (see tp/2).</source>
          <target state="translated">根据系统中设置的跟踪模式,跟踪进程的全局函数调用(见tp/2)。</target>
        </trans-unit>
        <trans-unit id="7b9365396596fa47926ca8347796645d68615fc5" translate="yes" xml:space="preserve">
          <source>Traces port related events to the port.</source>
          <target state="translated">追踪与端口相关的事件。</target>
        </trans-unit>
        <trans-unit id="9984d03ffd8c79d353ed1035134b4b78d308578d" translate="yes" xml:space="preserve">
          <source>Traces port-related events.</source>
          <target state="translated">追踪与端口相关的事件。</target>
        </trans-unit>
        <trans-unit id="53c6e4ac66fc9e05350a56f9ce0407168d386402" translate="yes" xml:space="preserve">
          <source>Traces process related events to the process.</source>
          <target state="translated">追踪与流程相关的事件。</target>
        </trans-unit>
        <trans-unit id="29908912e6fff8dc5249509363a4412791547f21" translate="yes" xml:space="preserve">
          <source>Traces process-related events.</source>
          <target state="translated">追踪与流程相关的事件。</target>
        </trans-unit>
        <trans-unit id="5fea32fcd1026ba95b7747cfa7687d7877ce29fa" translate="yes" xml:space="preserve">
          <source>Traces receiving of messages.</source>
          <target state="translated">追踪信息的接收情况。</target>
        </trans-unit>
        <trans-unit id="cc07cb20090b0accf4d5bc83ba241371cabc9b3a" translate="yes" xml:space="preserve">
          <source>Traces scheduling of exiting processes.</source>
          <target state="translated">对退出的进程进行跟踪调度。</target>
        </trans-unit>
        <trans-unit id="67d22b046457a4e977f4835a302c705d01e90b51" translate="yes" xml:space="preserve">
          <source>Traces scheduling of ports.</source>
          <target state="translated">追踪港口的调度情况。</target>
        </trans-unit>
        <trans-unit id="2f48a05431b99fc7b0ddcdfbdc7ffb069ba16117" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes just like &lt;code&gt;running&lt;/code&gt;. However, this option also includes schedule events when the process executes within the context of a port without being scheduled out itself.</source>
          <target state="translated">跟踪进程的调度，就像 &lt;code&gt;running&lt;/code&gt; 一样。但是，当进程在端口上下文中执行而自身未计划时，此选项还包括计划事件。</target>
        </trans-unit>
        <trans-unit id="7ce958853f2f4b0ef08e9d0a61efd87ba237714e" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes.</source>
          <target state="translated">追踪进程的调度。</target>
        </trans-unit>
        <trans-unit id="c4c7172939e3bf7fce3abeb0aee363e0caeecf04" translate="yes" xml:space="preserve">
          <source>Traces sending of messages.</source>
          <target state="translated">追踪信息的发送。</target>
        </trans-unit>
        <trans-unit id="47adf62bbb5b7db2ff2d321ec8c4e3902e48036a" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives and sends.</source>
          <target state="translated">追踪进程或端口接收和发送的消息。</target>
        </trans-unit>
        <trans-unit id="139350008a2a0843c976fc5033dee778dfce8767" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives.</source>
          <target state="translated">追踪进程或端口收到的消息。</target>
        </trans-unit>
        <trans-unit id="bd14c1efd1ddeca64fe6450f80e57e6c1564eaab" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port sends.</source>
          <target state="translated">追踪进程或端口发送的消息。</target>
        </trans-unit>
        <trans-unit id="c82c46612470fc95ddd9cc9407e733f834757c70" translate="yes" xml:space="preserve">
          <source>Tracing. Trace flags can still be set for the process, but no trace messages of any kind are generated. (If flag &lt;code&gt;sensitive&lt;/code&gt; is turned off, trace messages are again generated if any trace flags are set.)</source>
          <target state="translated">追踪。仍然可以为该进程设置跟踪标志，但是不会生成任何类型的跟踪消息。（如果关闭了标志 &lt;code&gt;sensitive&lt;/code&gt; 功能，那么如果设置了任何跟踪标志，则会再次生成跟踪消息。）</target>
        </trans-unit>
        <trans-unit id="47fc4ea1f09f1ee696b546f14553f696094e6dba" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph.</source>
          <target state="translated">追踪;归档,如上段所述。</target>
        </trans-unit>
        <trans-unit id="41e7b60cc9f2be5dd1ce4620f59c4b34f7bff5d2" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph. The trace contains entries for function calls, returns to function, process scheduling, other process related (spawn, etc) events, and garbage collection. All trace entries are timestamped.</source>
          <target state="translated">追踪;到文件,如前段所述。跟踪包含了函数调用、函数返回、进程调度、其他与进程相关的(产卵等)事件和垃圾收集的条目。所有跟踪条目都有时间戳。</target>
        </trans-unit>
        <trans-unit id="8fe0486a60ee6a3c01827363742db14787a69569" translate="yes" xml:space="preserve">
          <source>Traditionally the Presented IDs were found in the &lt;code&gt;Subject&lt;/code&gt; certificate field as &lt;code&gt;CN&lt;/code&gt; names. This is still quite common. When printing a certificate they show up as:</source>
          <target state="translated">传统上，在 &lt;code&gt;Subject&lt;/code&gt; 证书字段中以 &lt;code&gt;CN&lt;/code&gt; 名称找到Presented ID 。这仍然很普遍。打印证书时，它们显示为：</target>
        </trans-unit>
        <trans-unit id="cd6a9e832dedaac8dfc95165be3ac0b240579c52" translate="yes" xml:space="preserve">
          <source>Transaction properties, which include atomicity, consistency, isolation, and durability</source>
          <target state="translated">事务属性,包括原子性、一致性、隔离性和耐久性。</target>
        </trans-unit>
        <trans-unit id="0c055699e2752b762bcaa8253255fc14b9bef9a9" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; are both true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">事务发送者超时时间。有两个功能。首先，如果该值为0，则不会累积交易（例如，将不会启动交易发送方进程）。其次，如果该值大于0且 &lt;code&gt;auto_ack&lt;/code&gt; 和 &lt;code&gt;trans_ack&lt;/code&gt; 均为true或 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将启动事务发送方，并累积事务（取决于 &lt;code&gt;auto_ack&lt;/code&gt; ， &lt;code&gt;trans_ack&lt;/code&gt; 和 &lt;code&gt;trans_req&lt;/code&gt; 的值），供以后使用发送。</target>
        </trans-unit>
        <trans-unit id="269959a97a6fb575e49d0eca74353214adfc6c11" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; is true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">事务发送者超时时间。有两个功能。首先，如果该值为0，则不会累积交易（例如，将不会启动交易发送方进程）。其次，如果该值大于0且 &lt;code&gt;auto_ack&lt;/code&gt; 和 &lt;code&gt;trans_ack&lt;/code&gt; 为true或 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将启动事务发送方，并累积事务（取决于 &lt;code&gt;auto_ack&lt;/code&gt; ， &lt;code&gt;trans_ack&lt;/code&gt; 和 &lt;code&gt;trans_req&lt;/code&gt; 的值），以便以后发送。</target>
        </trans-unit>
        <trans-unit id="8663c67ab2c24806fdfac1e594f2b7c4880ae74b" translate="yes" xml:space="preserve">
          <source>Transaction-protected updates of counter records are not possible.</source>
          <target state="translated">柜台记录的交易保护更新是不可能的。</target>
        </trans-unit>
        <trans-unit id="92857e4acd00ac4a82a3a5846abb0210105c9b13" translate="yes" xml:space="preserve">
          <source>Transactions are important when designing fault-tolerant, distributed systems. A &lt;code&gt;Mnesia&lt;/code&gt; transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete &lt;code&gt;Mnesia&lt;/code&gt; records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</source>
          <target state="translated">在设计容错的分布式系统时，事务很重要。甲 &lt;code&gt;Mnesia&lt;/code&gt; 的事务是通过该一系列的数据库操作可以作为一个功能块执行的机制。作为事务运行的功能块称为功能对象（Fun），此代码可以读取，写入和删除 &lt;code&gt;Mnesia&lt;/code&gt; 记录。 Fun被评估为提交或终止的事务。如果事务成功执行Fun，它将在所有涉及的节点上复制操作，或者在发生错误时终止。</target>
        </trans-unit>
        <trans-unit id="4eb9104f2b09d1b5d4b87d82abb898d1890e970f" translate="yes" xml:space="preserve">
          <source>Transactions can be assigned the property of being executed on all nodes in the system, or on none. Transactions can also be bypassed in favor of running &quot;dirty operations&quot;, which reduce overheads and run fast.</source>
          <target state="translated">事务可以被指定为在系统中的所有节点上执行,或者在没有节点上执行的属性。事务也可以被绕过,转而运行 &quot;脏操作&quot;,这样可以减少开销并快速运行。</target>
        </trans-unit>
        <trans-unit id="a91a6387bdeb5a997e5106ce0eb7dbddb3fbc79e" translate="yes" xml:space="preserve">
          <source>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value &lt;code&gt;{aborted, Reason}&lt;/code&gt; and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</source>
          <target state="translated">事务可以以任意方式嵌套。子事务必须与其父事务在同一进程中运行。当子事务终止时，子事务的调用者将获得返回值 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 并且子事务执行的所有工作都将被擦除。如果提交了子事务，则将由子事务写入的记录传播到父事务。</target>
        </trans-unit>
        <trans-unit id="c7c5e2dea68a50fc96da311191d6565ac73e322c" translate="yes" xml:space="preserve">
          <source>Transactions that update the definition of a table requires that &lt;code&gt;Mnesia&lt;/code&gt; is started on all nodes where the storage type of the schema is &lt;code&gt;disc_copies&lt;/code&gt;. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</source>
          <target state="translated">更新表定义的事务要求在架构存储类型为 &lt;code&gt;disc_copies&lt;/code&gt; 的所有节点上启动 &lt;code&gt;Mnesia&lt;/code&gt; 。这些节点上表的所有副本也必须加载。这些可用性规则有一些例外：</target>
        </trans-unit>
        <trans-unit id="f8042cfa4648048958e1595a0cff5bd3d748ab7d" translate="yes" xml:space="preserve">
          <source>Transcodes an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;URIString&lt;/code&gt;, where &lt;code&gt;Options&lt;/code&gt; is a list of tagged tuples, specifying the inbound (&lt;code&gt;in_encoding&lt;/code&gt;) and outbound (&lt;code&gt;out_encoding&lt;/code&gt;) encodings. &lt;code&gt;in_encoding&lt;/code&gt; and &lt;code&gt;out_encoding&lt;/code&gt; specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned.</source>
          <target state="translated">对 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 兼容的 &lt;code&gt;URIString&lt;/code&gt; 进行代码转换，其中 &lt;code&gt;Options&lt;/code&gt; 是标记元组的列表，指定入站（ &lt;code&gt;in_encoding&lt;/code&gt; ）和出站（ &lt;code&gt;out_encoding&lt;/code&gt; ）编码。 &lt;code&gt;in_encoding&lt;/code&gt; 和 &lt;code&gt;out_encoding&lt;/code&gt; 同时为输入和输出数据指定二进制编码和百分比编码。不支持二进制编码与百分比编码不同的混合编码。如果参数无效，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="0276c8258f3ca2236ded67dcb45cec51cdd4d087" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; into the file &lt;code&gt;RemoteFile&lt;/code&gt; at the remote server.</source>
          <target state="translated">将二进制 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器上的文件 &lt;code&gt;RemoteFile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a31be82768a8a14fe4e45c8c31cc87a5a005d692" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; to the remote server and appends it to the file &lt;code&gt;RemoteFile&lt;/code&gt;. If the file does not exist, it is created.</source>
          <target state="translated">将二进制 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，并将其附加到文件 &lt;code&gt;RemoteFile&lt;/code&gt; 。如果该文件不存在，则会创建它。</target>
        </trans-unit>
        <trans-unit id="96ecc5026b0a2d6e144a5dcc9d3d15bc2637fba5" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which appends it to the file specified in the call to &lt;code&gt;append_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">将块 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，该服务器将其附加到对 &lt;code&gt;append_chunk_start/2&lt;/code&gt; 的调用中指定的文件中。</target>
        </trans-unit>
        <trans-unit id="6d777ccd8cf743ce8e8b1db94238262ce12eba79" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which writes it into the file specified in the call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">将块 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，该服务器将其写入到 &lt;code&gt;send_chunk_start/2&lt;/code&gt; 调用中指定的文件中。</target>
        </trans-unit>
        <trans-unit id="78ac497764b60c7c85e8349f223a68fe68089947" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;.</source>
          <target state="translated">将文件 &lt;code&gt;LocalFile&lt;/code&gt; 传输到远程服务器。如果指定了 &lt;code&gt;RemoteFile&lt;/code&gt; ，则将远程文件的名称设置为 &lt;code&gt;RemoteFile&lt;/code&gt; ，否则设置为 &lt;code&gt;LocalFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aec29636456fbdaa72ac911c194e9cb134c0de35" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file that the file is appended to is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;. If the file does not exists, it is created.</source>
          <target state="translated">将文件 &lt;code&gt;LocalFile&lt;/code&gt; 传输到远程服务器。如果指定了 &lt;code&gt;RemoteFile&lt;/code&gt; ，则将文件附加到的远程文件的名称设置为 &lt;code&gt;RemoteFile&lt;/code&gt; ，否则设置为 &lt;code&gt;LocalFile&lt;/code&gt; 。如果该文件不存在，则会创建它。</target>
        </trans-unit>
        <trans-unit id="90ba80cf80c63c0d2c8f02175aa1e10f13204467" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server and receives it as a binary.</source>
          <target state="translated">从远程服务器传输文件 &lt;code&gt;RemoteFile&lt;/code&gt; 并将其作为二进制文件接收。</target>
        </trans-unit>
        <trans-unit id="ef6a6bd4453d0b36a0f55436c56df830215430fd" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server to the file system of the local client. If &lt;code&gt;LocalFile&lt;/code&gt; is specified, the local file will be &lt;code&gt;LocalFile&lt;/code&gt;, otherwise &lt;code&gt;RemoteFile&lt;/code&gt;.</source>
          <target state="translated">将文件 &lt;code&gt;RemoteFile&lt;/code&gt; 从远程服务器传输到本地客户端的文件系统。如果指定了 &lt;code&gt;LocalFile&lt;/code&gt; ，则本地文件将为 &lt;code&gt;LocalFile&lt;/code&gt; ，否则为 &lt;code&gt;RemoteFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0ad6ecb9ddaf64bd66989047cba27a4d5603ff1" translate="yes" xml:space="preserve">
          <source>Transform a alias-name to its oid.</source>
          <target state="translated">将别名转换为其id。</target>
        </trans-unit>
        <trans-unit id="36c585abe302937d577b48572bd7c0e3655c0630" translate="yes" xml:space="preserve">
          <source>Transform a oid to its aliasname.</source>
          <target state="translated">将一个oid转换为它的别名。</target>
        </trans-unit>
        <trans-unit id="1d5829db0e03928c4e7cde6f753299a051ba3577" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, appending &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of the specified string.</source>
          <target state="translated">编译之前先对输入字典进行转换，并附加指定字符串的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b3111884f3054cc372ba38df92c0a135c770202" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, setting &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; to the specified string.</source>
          <target state="translated">编译之前先转换输入字典，将 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 设置为指定的字符串。</target>
        </trans-unit>
        <trans-unit id="c4f1d57f141d31ace69a30793395cb3994e3e4b6" translate="yes" xml:space="preserve">
          <source>Transforming URIs into a normalized form</source>
          <target state="translated">将URI转化为规范化的形式。</target>
        </trans-unit>
        <trans-unit id="52a09e92d39be036799f55f3466102e3964c9981" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (that is, it cannot be sent to a process on another node and still remain a valid compiled match specification, nor can it be stored on disk). To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 转换为内部表示，可在随后的 &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 调用中使用。内部表示形式是不透明的，不能转换为外部术语格式，然后再次返回而不会丢失其属性（即，不能将其发送到另一个节点上的进程，并且仍然保持有效的已编译匹配规范，也不能将其存储在磁盘）。要检查已编译的匹配规范的有效性，请使用 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29484fe337b3af71da5ca7a2dac4e696f5f79d47" translate="yes" xml:space="preserve">
          <source>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for &lt;code&gt;Node&lt;/code&gt;, as produced by the given &lt;code&gt;Printer&lt;/code&gt; function. Each line of the comment is prefixed by the string &lt;code&gt;Prefix&lt;/code&gt; (this does not include the initial &quot;&lt;code&gt;%&lt;/code&gt;&quot; character of the comment line).</source>
          <target state="translated">将语法树转换为抽象注释。注释行包含由给定 &lt;code&gt;Printer&lt;/code&gt; 函数产生的 &lt;code&gt;Node&lt;/code&gt; 文本。注释的每一行都以字符串 &lt;code&gt;Prefix&lt;/code&gt; （这不包括注释行的开头&amp;ldquo; &lt;code&gt;%&lt;/code&gt; &amp;rdquo;字符）。</target>
        </trans-unit>
        <trans-unit id="0cbb6e0e6a14a90b777a9f90d55d975cb9b29ca2" translate="yes" xml:space="preserve">
          <source>Transforms addresses from internal MIB format to one more useful to &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将地址从内部MIB格式转换为对 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt; 有用的另一种格式。</target>
        </trans-unit>
        <trans-unit id="dec43f85ac93650f89af6686bc1b1b60f6b9599f" translate="yes" xml:space="preserve">
          <source>Transforms an &lt;code&gt;URI&lt;/code&gt; into a normalized form using Syntax-Based Normalization as defined by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 定义的基于语法的规范化将 &lt;code&gt;URI&lt;/code&gt; 转换为规范化形式。</target>
        </trans-unit>
        <trans-unit id="d1d9a9fd8f3259ae9990008a8a6bec24b152a43a" translate="yes" xml:space="preserve">
          <source>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</source>
          <target state="translated">将一个SNMP索引转换为相应的Mnesia键。如果SNMP表有多个键,则键是键列的元组。</target>
        </trans-unit>
        <trans-unit id="187ea5deff287a5504fddf1b7e36cd0f09e23500" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;person&lt;/code&gt; table from a RAM table into a disc-based table at &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;person&lt;/code&gt; 表从RAM表转换为 &lt;code&gt;Node&lt;/code&gt; 处基于磁盘的表。</target>
        </trans-unit>
        <trans-unit id="e599fefddd1839d024d114d1fae1e8b80cf9332c" translate="yes" xml:space="preserve">
          <source>Transforms trace data and makes an event record out of it.</source>
          <target state="translated">转换跟踪数据,并对其进行事件记录。</target>
        </trans-unit>
        <trans-unit id="dae87e24dc1095e84bcbb6fcaaaa2c5136770260" translate="yes" xml:space="preserve">
          <source>Transient Failures</source>
          <target state="translated">瞬时故障</target>
        </trans-unit>
        <trans-unit id="340b8d86a3623f3b21be6c18b845921955f1271a" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the state transition. Here are the sequence of steps for a state transition:</source>
          <target state="translated">过渡选项可以通过 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 设置，并可以修改状态过渡。以下是状态转换的步骤顺序：</target>
        </trans-unit>
        <trans-unit id="6f68e1d1cfad7a14a47ac7096b71655133e8d261" translate="yes" xml:space="preserve">
          <source>Translates an SCTP error number from, for example, &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; or &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; into an explanatory string, or one of the atoms &lt;code&gt;ok&lt;/code&gt; for no error or &lt;code&gt;undefined&lt;/code&gt; for an unrecognized error.</source>
          <target state="translated">将SCTP错误编号从例如 &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; 或 &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; 转换为说明字符串，或将 &lt;code&gt;ok&lt;/code&gt; 原子表示为无错误，或者将原子之一 &lt;code&gt;undefined&lt;/code&gt; 为未识别的错误。</target>
        </trans-unit>
        <trans-unit id="6fca7eec0c5c2c402ec9feaf20fb1cf586209144" translate="yes" xml:space="preserve">
          <source>Translates signature algorithm OID to Erlang digest and signature types.</source>
          <target state="translated">将签名算法OID翻译成Erlang摘要和签名类型。</target>
        </trans-unit>
        <trans-unit id="2dd26e871e1b0c6741054f66f2c8c6fd1ff461e9" translate="yes" xml:space="preserve">
          <source>Translates the binary trace logs into something readable. By default, &lt;code&gt;ttb&lt;/code&gt; presents each trace message as a line of text, but you can also write your own handler to make more complex interpretations of the trace information. A trace log can also be presented graphically with application Event Tracer (ET).</source>
          <target state="translated">将二进制跟踪日志转换为可读的内容。默认情况下， &lt;code&gt;ttb&lt;/code&gt; 将每个跟踪消息显示为一行文本，但是您也可以编写自己的处理程序以对跟踪信息进行更复杂的解释。跟踪日志也可以通过应用程序事件跟踪器（ET）以图形方式显示。</target>
        </trans-unit>
        <trans-unit id="247b327869ef6106bf80329969b8c8bd5956cb2a" translate="yes" xml:space="preserve">
          <source>Translation Agents</source>
          <target state="translated">翻译公司</target>
        </trans-unit>
        <trans-unit id="c10d76c9a4b81c39c13a3bbf7cdb7a157dfb1551" translate="yes" xml:space="preserve">
          <source>Transport</source>
          <target state="translated">Transport</target>
        </trans-unit>
        <trans-unit id="b374a75b21ba249e1509b4f849a514f5f64e23f6" translate="yes" xml:space="preserve">
          <source>Transport Failure Algorithm</source>
          <target state="translated">传输失败算法</target>
        </trans-unit>
        <trans-unit id="67ca25bf09fe1a4bc0aa43dea06a3fcf06720b9d" translate="yes" xml:space="preserve">
          <source>Transport Failure Detection</source>
          <target state="translated">运输故障检测</target>
        </trans-unit>
        <trans-unit id="c24199b7fc627de79e3a1c89011039b836457577" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) and its predecessor, the Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. The protocols use X.509 certificates and hence public key (asymmetric) cryptography to authenticate the counterpart with whom they communicate, and to exchange a symmetric key for payload encryption. The protocol provides data/message confidentiality (encryption), integrity (through message authentication code checks) and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that is based on TLS but datagram oriented instead of stream oriented.</source>
          <target state="translated">传输层安全(TLS)及其前身安全套接字层(SSL)是旨在为计算机网络提供通信安全的加密协议。这些协议使用X.509证书,因此使用公共密钥(非对称)加密技术来验证与之通信的对应方,并为有效载荷加密交换对称密钥。该协议提供数据/消息的保密性(加密)、完整性(通过消息验证码检查)和主机验证(通过证书路径验证)。DTLS(数据报传输层安全),基于TLS,但面向数据报而不是面向流。</target>
        </trans-unit>
        <trans-unit id="784cd0f786d540e1df407cfe0bdede50bd4a091f" translate="yes" xml:space="preserve">
          <source>Transpose characters</source>
          <target state="translated">转换字符</target>
        </trans-unit>
        <trans-unit id="6e192302cce69f9e090d601f54b7e73e6fdccdad" translate="yes" xml:space="preserve">
          <source>Traverses &lt;code&gt;Dirs&lt;/code&gt; and adds each &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. This means that the order of &lt;code&gt;Dirs&lt;/code&gt; is reversed in the resulting code path. For example, if you add &lt;code&gt;[Dir1,Dir2]&lt;/code&gt;, the resulting path will be &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt;.</source>
          <target state="translated">遍历 &lt;code&gt;Dirs&lt;/code&gt; 并将每个 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径的开头。这意味着 &lt;code&gt;Dirs&lt;/code&gt; 的顺序在生成的代码路径中颠倒了。例如，如果添加 &lt;code&gt;[Dir1,Dir2]&lt;/code&gt; ，则结果路径将为 &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="137a357a519bf577c3a49eea20ac865057de4ba8" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise the function returns a key that can be used to read the actual record.</source>
          <target state="translated">遍历表并对表中的所有记录执行操作。当到达表的末尾时，将返回特殊键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。否则，该函数将返回可用于读取实际记录的键。</target>
        </trans-unit>
        <trans-unit id="d196f97744321413a11b3f30616c9f2f4eec01c6" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;.</source>
          <target state="translated">遍历表并对表中的所有记录执行操作。当到达表的末尾时，将返回特殊键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。否则，该函数将返回可用于读取实际记录的键。如果另一个Erlang进程在使用函数 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 遍历该表时对该表执行写操作，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="8dc9f15de712d9d574738e5b2e0901706f6adc90" translate="yes" xml:space="preserve">
          <source>Traverses a table in a manner similar to the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;. A table has a number of slots that range from 0 (zero) to an unknown upper bound. The function &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; returns the special atom &lt;code&gt;'$end_of_table'&lt;/code&gt; when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</source>
          <target state="translated">以类似于函数 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 的方式遍历表。一个表具有多个插槽，范围从0（零）到未知上限。当到达表的末尾时，函数 &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; 返回特殊原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。如果在遍历表时对表执行写操作，则此函数的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d5bce8436ec86270c2bccf19db4667aa0c4b7a23" translate="yes" xml:space="preserve">
          <source>Traversing the set of modules, it then recompiles every module for which at least one of the following conditions apply:</source>
          <target state="translated">遍历模块集,然后重新编译至少符合下列条件之一的每个模块:</target>
        </trans-unit>
        <trans-unit id="c0c84ee4b222403ef3c2a2f6e4a34ab18cd985d5" translate="yes" xml:space="preserve">
          <source>Tries to create directory &lt;code&gt;Dir&lt;/code&gt;. Missing parent directories are &lt;strong&gt;not&lt;/strong&gt; created. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">尝试创建目录 &lt;code&gt;Dir&lt;/code&gt; 。&lt;strong&gt;没有&lt;/strong&gt;创建丢失的父目录。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7539b9bc23bf1a63079b6009b66e55de1f511775" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the &lt;code&gt;NULL&lt;/code&gt;-terminated C-string &lt;code&gt;name&lt;/code&gt; with encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试从 &lt;code&gt;NULL&lt;/code&gt; 终止的C字符串 &lt;code&gt;name&lt;/code&gt; 使用encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 创建一个已经存在的原子的术语。</target>
        </trans-unit>
        <trans-unit id="d956aa4d45e626e33feccc52c2e668a01e46c2de" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the string &lt;code&gt;name&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; and encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; characters are treated as any other characters.</source>
          <target state="translated">尝试根据长度为 &lt;code&gt;len&lt;/code&gt; 的字符串 &lt;code&gt;name&lt;/code&gt; 创建一个已经存在的原子的术语，并使用encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;NULL&lt;/code&gt; 字符被视为其他任何字符。</target>
        </trans-unit>
        <trans-unit id="c7380de8914d3d9d8e70fd1f6c74d924099655d6" translate="yes" xml:space="preserve">
          <source>Tries to delete directory &lt;code&gt;Dir&lt;/code&gt;. The directory must be empty before it can be deleted. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">尝试删除目录 &lt;code&gt;Dir&lt;/code&gt; 。该目录必须为空，然后才能删除。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0694587d26aecfbb0a43b20ea81eab04225a2a67" translate="yes" xml:space="preserve">
          <source>Tries to delete file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">试图删除文件 &lt;code&gt;Filename&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="917cb6bdcab3e4dcc84eba06ed763b346415331e" translate="yes" xml:space="preserve">
          <source>Tries to find a &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">试图找到一个 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 从顶点 &lt;code&gt;V1&lt;/code&gt; 到顶点 &lt;code&gt;V2&lt;/code&gt; 有向图的 &lt;code&gt;G&lt;/code&gt; 。以顶点列表 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 的形式返回路径；如果不存在从 &lt;code&gt;V1&lt;/code&gt; 到 &lt;code&gt;V2&lt;/code&gt; 的长度为一个或多个的简单路径，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6d56eefae6afa713ee58d8d532711a39f9d00e8" translate="yes" xml:space="preserve">
          <source>Tries to find an application downgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a previous version &lt;code&gt;OldVsn&lt;/code&gt; located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">试图找到一个应用程序降级脚本 &lt;code&gt;App&lt;/code&gt; 从当前版本到以前的版本 &lt;code&gt;OldVsn&lt;/code&gt; 位于 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3cdb4b87509cbcdcf3943a3bdad2d3f9b6d987" translate="yes" xml:space="preserve">
          <source>Tries to find an application upgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">尝试查找 &lt;code&gt;App&lt;/code&gt; 的应用程序升级脚本，从当前版本升级到 &lt;code&gt;Dir&lt;/code&gt; 中的新版本。</target>
        </trans-unit>
        <trans-unit id="63810144427574ddc18730d454daf02c43dd8338" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; through vertex &lt;code&gt;V&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the cycle as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple cycle through &lt;code&gt;V&lt;/code&gt; exists. Notice that a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; is returned as list &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt;.</source>
          <target state="translated">试图通过图 &lt;code&gt;G&lt;/code&gt; 的顶点 &lt;code&gt;V&lt;/code&gt; 找到尽可能短的 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 。以顶点列表 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 的形式返回循环，如果不存在通过 &lt;code&gt;V&lt;/code&gt; 的简单循环，则返回 &lt;code&gt;false&lt;/code&gt; 。注意，通过 &lt;code&gt;V&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 作为列表 &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dd32105e9ea9dba4a3239b99d2841486b3f987d" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">试图找到一个尽可能短 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 从顶点 &lt;code&gt;V1&lt;/code&gt; 到顶点 &lt;code&gt;V2&lt;/code&gt; 有向图的 &lt;code&gt;G&lt;/code&gt; ^。以顶点列表 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 的形式返回路径；如果不存在从 &lt;code&gt;V1&lt;/code&gt; 到 &lt;code&gt;V2&lt;/code&gt; 的长度为一个或多个的简单路径，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f904e656f227e2a584648e9091f6b33093af20b3" translate="yes" xml:space="preserve">
          <source>Tries to load a module in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;, unless the module is already loaded. However, in embedded mode it does not load a module that is not already loaded, but returns &lt;code&gt;{error, embedded}&lt;/code&gt; instead. See &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; for a description of other possible error reasons.</source>
          <target state="translated">尝试以与 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 相同的方式加载模块，除非已加载模块。但是，在嵌入式模式下，它不会加载尚未加载的模块，而是返回 &lt;code&gt;{error, embedded}&lt;/code&gt; 。有关其他可能的错误原因的说明，请参见 &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; 的错误原因。</target>
        </trans-unit>
        <trans-unit id="ec25834fa1b726007249264a0c7c78aaaf71538e" translate="yes" xml:space="preserve">
          <source>Tries to load all of the modules in the list &lt;code&gt;Modules&lt;/code&gt; atomically. That means that either all modules are loaded at the same time, or none of the modules are loaded if there is a problem with any of the modules.</source>
          <target state="translated">尝试以原子方式加载&amp;ldquo;模块&amp;rdquo;列表中的所有 &lt;code&gt;Modules&lt;/code&gt; 。这意味着要么同时加载所有模块，要么如果任何模块有问题，则不加载任何模块。</target>
        </trans-unit>
        <trans-unit id="1aaf9b09924ea99accd919111039be58e3e4e9fc" translate="yes" xml:space="preserve">
          <source>Tries to load and restore Debugger settings from a file previously saved using &lt;strong&gt;Save Settings...&lt;/strong&gt; (see below). Any errors are silently ignored.</source>
          <target state="translated">尝试从以前使用&amp;ldquo; &lt;strong&gt;保存设置...&amp;rdquo;&lt;/strong&gt;保存的文件中加载和还原调试器设置（请参见下文）。任何错误都将被忽略。</target>
        </trans-unit>
        <trans-unit id="9bc1b21fc8af03b36192dd6ac14e4e4450744f7e" translate="yes" xml:space="preserve">
          <source>Tries to load any modules not already loaded in the list &lt;code&gt;Modules&lt;/code&gt; in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试以与 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 相同的方式加载列表 &lt;code&gt;Modules&lt;/code&gt; 中尚未加载的任何模块。</target>
        </trans-unit>
        <trans-unit id="b645a31575ab3155bc8f781878d4d3b627bae342" translate="yes" xml:space="preserve">
          <source>Tries to load code for all modules that have been previously prepared by &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt;. The loading occurs atomically, meaning that either all modules are loaded at the same time, or none of the modules are loaded.</source>
          <target state="translated">尝试为先前由 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 准备的所有模块加载代码。加载是原子发生的，这意味着要么同时加载所有模块，要么不加载任何模块。</target>
        </trans-unit>
        <trans-unit id="f4b988df2289cf719529adabbdd5889a80ea66c6" translate="yes" xml:space="preserve">
          <source>Tries to load the Erlang module &lt;code&gt;Module&lt;/code&gt;, using the code path. It looks for the object code file with an extension corresponding to the Erlang machine used, for example, &lt;code&gt;Module.beam&lt;/code&gt;. The loading fails if the module name found in the object code differs from the name &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; must be used to load object code with a module name that is different from the file name.</source>
          <target state="translated">尝试使用代码路径加载Erlang模块 &lt;code&gt;Module&lt;/code&gt; 。它查找目标代码文件，其扩展名对应于所使用的Erlang机器，例如 &lt;code&gt;Module.beam&lt;/code&gt; 。如果该模块的名称从名称的对象的不同代码中发现的加载失败 &lt;code&gt;Module&lt;/code&gt; 。必须使用 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 装载目标名称，该目标代码的模块名称与文件名不同。</target>
        </trans-unit>
        <trans-unit id="b49e8d37404b75156cbbeb1637eb4e0c68260be5" translate="yes" xml:space="preserve">
          <source>Tries to lock a mutex. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same mutex again.</source>
          <target state="translated">尝试锁定互斥锁。当前已锁定互斥锁的线程&lt;strong&gt;无法&lt;/strong&gt;尝试再次锁定同一互斥锁。</target>
        </trans-unit>
        <trans-unit id="369d095339d331183fd1de82b70ca1f958ce57f3" translate="yes" xml:space="preserve">
          <source>Tries to read &lt;code&gt;String&lt;/code&gt; in accordance with the control sequences in &lt;code&gt;Format&lt;/code&gt;. For a detailed description of the available formatting options, see &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt;. It is assumed that &lt;code&gt;String&lt;/code&gt; contains whole lines.</source>
          <target state="translated">尝试根据 &lt;code&gt;Format&lt;/code&gt; 中的控制序列读取 &lt;code&gt;String&lt;/code&gt; 。有关可用格式选项的详细说明，请参见 &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt; 。假定 &lt;code&gt;String&lt;/code&gt; 包含整行。</target>
        </trans-unit>
        <trans-unit id="b5361d5cdb192bb80b006486e2deeb6e3a86a448" translate="yes" xml:space="preserve">
          <source>Tries to read lock an rwlock.</source>
          <target state="translated">试图读取锁和Rwlock。</target>
        </trans-unit>
        <trans-unit id="078c41228c821f4992dac3d604b1f36b0a4cc3ba" translate="yes" xml:space="preserve">
          <source>Tries to read/write lock an rwlock. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same rwlock again.</source>
          <target state="translated">尝试读取/写入锁定rwlock。当前具有读或读/写锁定rwlock的线程&lt;strong&gt;无法&lt;/strong&gt;尝试再次锁定同一rwlock。</target>
        </trans-unit>
        <trans-unit id="542b3a8d434cdeb35d54c993e320baf91923b244" translate="yes" xml:space="preserve">
          <source>Tries to rename the file &lt;code&gt;Source&lt;/code&gt; to &lt;code&gt;Destination&lt;/code&gt;. It can be used to move files (and directories) between directories, but it is not sufficient to specify the destination only. The destination filename must also be specified. For example, if &lt;code&gt;bar&lt;/code&gt; is a normal file and &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are directories, &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; returns an error, but &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; succeeds. Returns &lt;code&gt;ok&lt;/code&gt; if it is successful.</source>
          <target state="translated">尝试将文件 &lt;code&gt;Source&lt;/code&gt; 重命名为 &lt;code&gt;Destination&lt;/code&gt; 。它可用于在目录之间移动文件（和目录），但是仅指定目的地是不够的。还必须指定目标文件名。例如，如果 &lt;code&gt;bar&lt;/code&gt; 是一个普通文件，而 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 是目录，则 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; 返回一个错误，但是 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; 成功。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69799527904c5b0f81a27b2394603c188136973" translate="yes" xml:space="preserve">
          <source>Tries to set the scheduler bind type. The same as flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; except how some errors are handled. For more information, see &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试设置调度程序绑定类型。除处理某些错误外，与标志 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 相同。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3739b1427af771c5c5c521a0baa015d6c8471836" translate="yes" xml:space="preserve">
          <source>Tries to suspend all processes using a module &lt;code&gt;Mod&lt;/code&gt;. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no &lt;code&gt;Timeout&lt;/code&gt; is specified or &lt;code&gt;default&lt;/code&gt; is specified, the default value for &lt;code&gt;sys:suspend&lt;/code&gt; is used.</source>
          <target state="translated">尝试使用模块 &lt;code&gt;Mod&lt;/code&gt; 挂起所有进程。如果某个进程没有响应，则将其忽略。这可能导致进程死机，要么是因为它自发地切换到新代码时崩溃了，要么是由于清除操作导致的。如果没有 &lt;code&gt;Timeout&lt;/code&gt; 指定或 &lt;code&gt;default&lt;/code&gt; 指定，默认值 &lt;code&gt;sys:suspend&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="f07a25fbd2993e4438fecb34b5a2a265898a4510" translate="yes" xml:space="preserve">
          <source>Trigger the user-probe &lt;code&gt;user_trace_i4s4&lt;/code&gt; in the NIF library &lt;code&gt;dyntrace.so&lt;/code&gt; by calling &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; 来触发NIF库 &lt;code&gt;dyntrace.so&lt;/code&gt; 中的用户探针 &lt;code&gt;user_trace_i4s4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b4e339fc739fe569582f228faed311550ce6f3" translate="yes" xml:space="preserve">
          <source>Triggers garbage collection of requested type. Default value is &lt;code&gt;'major'&lt;/code&gt;, which would trigger a fullsweep GC. The option &lt;code&gt;'minor'&lt;/code&gt; is considered a hint and may lead to either minor or major GC run.</source>
          <target state="translated">触发请求类型的垃圾回收。默认值为 &lt;code&gt;'major'&lt;/code&gt; ，它将触发全扫描GC。选项 &lt;code&gt;'minor'&lt;/code&gt; 被认为是提示，可能会导致次要或主要GC运行。</target>
        </trans-unit>
        <trans-unit id="bce7d4bc5bdcfee52b94b55561a6aeaf81f157f5" translate="yes" xml:space="preserve">
          <source>Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.</source>
          <target state="translated">触发下一个要流转的消息,也就是和套接字的主动行为一样。</target>
        </trans-unit>
        <trans-unit id="a0f37655e58e53f4d21a5d5b772a98970d6a45b9" translate="yes" xml:space="preserve">
          <source>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by &lt;code&gt;sbrk&lt;/code&gt;) that is kept by &lt;code&gt;malloc&lt;/code&gt; (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, &lt;code&gt;malloc&lt;/code&gt; releases it (by calling &lt;code&gt;sbrk&lt;/code&gt;). Trim threshold is specified in kilobytes. Defaults to &lt;code&gt;128&lt;/code&gt;.</source>
          <target state="translated">修剪阈值大小（以千字节为单位）。这是 &lt;code&gt;malloc&lt;/code&gt; （不释放给操作系统）保留的堆顶部（由 &lt;code&gt;sbrk&lt;/code&gt; 分配）顶部的最大可用内存量。当堆顶部的可用内存量超过修剪阈值时， &lt;code&gt;malloc&lt;/code&gt; 释放它（通过调用 &lt;code&gt;sbrk&lt;/code&gt; ）。修剪阈值以千字节为单位指定。默认为 &lt;code&gt;128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95ec715dc8ff6a5284221ec8f9868a8798be9478" translate="yes" xml:space="preserve">
          <source>Trivial FTP.</source>
          <target state="translated">琐碎的FTP。</target>
        </trans-unit>
        <trans-unit id="4ba00956ec7cf24ae072a34b8ff599479668e012" translate="yes" xml:space="preserve">
          <source>Trivial example (beep on anything except empty line, which is expanded to &lt;code&gt;&quot;quit&quot;&lt;/code&gt;):</source>
          <target state="translated">一个简单的示例（除了空行以外，其他任何地方都为哔哔声，它将扩展为 &lt;code&gt;&quot;quit&quot;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c64384e3540118ebd85f8e8adda7b3a0d9d9d577" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a binary.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是二进制，则为true 。</target>
        </trans-unit>
        <trans-unit id="2184451194ed3a9022be648eb665e2e8303c78bb" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a floating point number.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是浮点数，则为true 。</target>
        </trans-unit>
        <trans-unit id="739f16017ed1c1b0d52375a346e88d29489f5f4c" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with at least one element.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是包含至少一个元素的列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="4dc6a0f22eecbe39d3b7bafca6d0ecf3f15fab72" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with zero or more elements.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是具有零个或多个元素的列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="7e4dec6465a412dda92c461f8f7e72cba72e9ec3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a pid (process identifier).</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是pid（进程标识符），则为true 。</target>
        </trans-unit>
        <trans-unit id="ca9f92d44502347305071d3028c3415ccc6539b0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a port.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是端口，则为true 。</target>
        </trans-unit>
        <trans-unit id="63b81f24f20e74b9964fd68165f42bbd5f102696" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a reference.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是参考，则为true 。</target>
        </trans-unit>
        <trans-unit id="369ae59368966778ddc2fa05ef42ca484213f640" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a tuple.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是一个元组，则为true 。</target>
        </trans-unit>
        <trans-unit id="200e8169564499251662fa489120aa02ef56f5b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an atom.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是原子，则为真。</target>
        </trans-unit>
        <trans-unit id="d2096948a91663a352916722e0007725da8866ba" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an empty list.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 为空列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="7cf519e4319be41a9707146ad88931f2320203e5" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an integer.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 为整数，则为true 。</target>
        </trans-unit>
        <trans-unit id="58de67beda24834e524aecdc74c16cbb945cf7c3" translate="yes" xml:space="preserve">
          <source>Truncates the file referenced by &lt;code&gt;IoDevice&lt;/code&gt; at the current position. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">在当前位置截断 &lt;code&gt;IoDevice&lt;/code&gt; 引用的文件。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37023c65abd347268bb58c87d2fb0048749a483a" translate="yes" xml:space="preserve">
          <source>Try out the new function &lt;code&gt;mult&lt;/code&gt;:</source>
          <target state="translated">试用新功能 &lt;code&gt;mult&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ff47aa173fda0968a762374da8240dfe8b55c52" translate="yes" xml:space="preserve">
          <source>Trying to evaluate a &lt;code&gt;throw&lt;/code&gt;outside a &lt;code&gt;catch&lt;/code&gt;. &lt;code&gt;V&lt;/code&gt; is the thrown term.</source>
          <target state="translated">试图评估 &lt;code&gt;catch&lt;/code&gt; 外的 &lt;code&gt;throw&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 是抛出的术语。</target>
        </trans-unit>
        <trans-unit id="cae5dd25bf19639aecf488ad3d7ba57e76736991" translate="yes" xml:space="preserve">
          <source>Trying to link to a non-existing process.</source>
          <target state="translated">试图链接到一个不存在的进程。</target>
        </trans-unit>
        <trans-unit id="f4134e3f0fb2b5c47f2d5517769378391de080f4" translate="yes" xml:space="preserve">
          <source>Tunes the compression algorithm. Use the following values:</source>
          <target state="translated">调整压缩算法。使用以下数值:</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="83ed105f4df89ed36299f9fd59a044cb698807f7" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error, error_info()}&lt;/code&gt; and &lt;code&gt;{warning, error_info()}&lt;/code&gt;, denoting syntactically incorrect forms and warnings, and &lt;code&gt;{eof, line()}&lt;/code&gt;, denoting an end-of-stream encountered before a complete form had been parsed.</source>
          <target state="translated">元组 &lt;code&gt;{error, error_info()}&lt;/code&gt; 和 &lt;code&gt;{warning, error_info()}&lt;/code&gt; 表示语法上不正确的形式和警告，而 &lt;code&gt;{eof, line()}&lt;/code&gt; 表示在解析完整表格之前遇到的流结束。</target>
        </trans-unit>
        <trans-unit id="0ffa679969428a6c8a5fbef9da583b1339b8f137" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error,E}&lt;/code&gt; and &lt;code&gt;{warning,W}&lt;/code&gt;, denoting syntactically incorrect forms and warnings.</source>
          <target state="translated">元组 &lt;code&gt;{error,E}&lt;/code&gt; 和 &lt;code&gt;{warning,W}&lt;/code&gt; ，表示语法上不正确的形式和警告。</target>
        </trans-unit>
        <trans-unit id="f4a5e32a69d4a4da5b271ce1389ce7de27bf6be9" translate="yes" xml:space="preserve">
          <source>Tuples and string formats accepted by versions before ssl-8.2.4 will be converted for backwards compatibility</source>
          <target state="translated">ssl-8.2.4之前的版本所接受的Tuple和字符串格式将被转换为向后兼容。</target>
        </trans-unit>
        <trans-unit id="f1ed151ede62f70799b920d57a42f17bd5fb2581" translate="yes" xml:space="preserve">
          <source>Tuples can have more than two parts, in fact as many parts as you want, and contain any valid Erlang &lt;strong&gt;term&lt;/strong&gt;. For example, to represent the temperature of various cities of the world:</source>
          <target state="translated">元组可以包含两个以上的部分，实际上可以根据需要包含任意多个部分，并且可以包含任何有效的Erlang &lt;strong&gt;术语&lt;/strong&gt;。例如，代表世界上各个城市的温度：</target>
        </trans-unit>
        <trans-unit id="ef0f5b8ef4ff33f41dc26081793feb3c120d0be9" translate="yes" xml:space="preserve">
          <source>Tuples have a fixed number of items in them. Each item in a tuple is called an &lt;strong&gt;element&lt;/strong&gt;. In the tuple &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt;, element 1 is &lt;code&gt;moscow&lt;/code&gt; and element 2 is &lt;code&gt;{c,-10}&lt;/code&gt;. Here &lt;code&gt;c&lt;/code&gt; represents Celsius and &lt;code&gt;f&lt;/code&gt; Fahrenheit.</source>
          <target state="translated">元组中有固定数量的项目。元组中的每个项目都称为一个&lt;strong&gt;元素&lt;/strong&gt;。在元组 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 中，元素1是 &lt;code&gt;moscow&lt;/code&gt; ，元素2是 &lt;code&gt;{c,-10}&lt;/code&gt; 。这里 &lt;code&gt;c&lt;/code&gt; 代表摄氏温度， &lt;code&gt;f&lt;/code&gt; 代表华氏温度。</target>
        </trans-unit>
        <trans-unit id="6af244d55aef38e6c2274514e3d2ab60c94ed28b" translate="yes" xml:space="preserve">
          <source>Tuples in the template express if-exist tests for metadata keys. For example, the following tuple says that if &lt;code&gt;key1&lt;/code&gt; exists in the metadata map, print &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the value that &lt;code&gt;key1&lt;/code&gt; is associated with in the metadata map. If &lt;code&gt;key1&lt;/code&gt; does not exist, print nothing.</source>
          <target state="translated">模板中的元组表示是否存在元数据键的测试。例如，以下元组说，如果 &lt;code&gt;key1&lt;/code&gt; 存在于元数据映射中，则打印 &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt; ，其中 &lt;code&gt;Value&lt;/code&gt; 是与 &lt;code&gt;key1&lt;/code&gt; 在元数据映射中关联的值。如果 &lt;code&gt;key1&lt;/code&gt; 不存在，则不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="243da839e833dcd6a7348ba4d1efa268f8e8a3ec" translate="yes" xml:space="preserve">
          <source>Tuples, maps, and lists (except strings, see below) are built in reverse polish notation, so that to build a tuple, the elements are specified first, and then the tuple term, with a count. Likewise for lists and maps.</source>
          <target state="translated">图元组、地图和列表(字符串除外,见下文)都是用反向抛光符号建立的,所以要建立一个元组,首先要指定元素,然后再指定元组项,并有一个计数。同样,列表和地图也是如此。</target>
        </trans-unit>
        <trans-unit id="8d71459c65d809aa4497f4a28bfc896fb1085c9c" translate="yes" xml:space="preserve">
          <source>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt;. If the input is already a template, it is not modified further.</source>
          <target state="translated">将语法树或树列表转换为一个或多个模板。模板可以实例化或匹配，并使用 &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt; 还原回普通语法树。如果输入已经是模板，则不会进一步修改。</target>
        </trans-unit>
        <trans-unit id="d8971cba7199bca87b23c2ec538c7121c59edc40" translate="yes" xml:space="preserve">
          <source>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., &lt;code&gt;_@Foo&lt;/code&gt; in the template becomes the variable &lt;code&gt;Foo&lt;/code&gt; in the meta-template. Furthermore, variables ending with &lt;code&gt;@&lt;/code&gt; are automatically wrapped in a call to merl:term/1, so e.g. &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; in the meta-template.</source>
          <target state="translated">将模板变成代表该模板的语法树。如果模板中的元变量名称（在元变量前缀字符之后）以大写字母开头，则它们将转换为普通的Erlang变量。例如，模板中的 &lt;code&gt;_@Foo&lt;/code&gt; 成为元模板中的变量 &lt;code&gt;Foo&lt;/code&gt; 。此外，以 &lt;code&gt;@&lt;/code&gt; 结尾的变量会自动包装在对merl：term / 1的调用中，因此，例如 &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11fdfc294615cd6feba1dc471497bd296595a74" translate="yes" xml:space="preserve">
          <source>Turn an error reason returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; into a readable string.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 返回的错误原因转换为可读字符串。</target>
        </trans-unit>
        <trans-unit id="0a32475174f92b9fb2f8542dc37a90aaa235a8d8" translate="yes" xml:space="preserve">
          <source>Turn off monitoring of the SNMP manager.</source>
          <target state="translated">关闭对SNMP管理器的监控。</target>
        </trans-unit>
        <trans-unit id="1596e715102816d11edb68278af146f787525ee2" translate="yes" xml:space="preserve">
          <source>Turn on and pare down debugging</source>
          <target state="translated">开启并减少调试</target>
        </trans-unit>
        <trans-unit id="8d0273b96fc2970b3bd22f825df50106f57a4d5f" translate="yes" xml:space="preserve">
          <source>Turn on distribution tracing on the Erlang node.</source>
          <target state="translated">在Erlang节点上开启分布追踪。</target>
        </trans-unit>
        <trans-unit id="4b6673d76d88179b888141748a220ac4df22b7da" translate="yes" xml:space="preserve">
          <source>Turn on global tracing</source>
          <target state="translated">开启全局追踪</target>
        </trans-unit>
        <trans-unit id="b5fd46c0414339fbc6a9a1e9bcad5db789cc32cf" translate="yes" xml:space="preserve">
          <source>Turning the scrollable_cursors option off is noted to make old odbc-drivers able to connect that will otherwhise fail.</source>
          <target state="translated">关闭scrollable_cursors选项是为了使旧的odbc-drivers能够连接,否则会失败。</target>
        </trans-unit>
        <trans-unit id="b3754a20c309fb4bee5151fc9185df3eb19690cf" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;Expr&lt;/code&gt; into a &quot;test object&quot;, by wrapping it in a fun-expression and a source line number. Technically, this is the same as &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;Expr&lt;/code&gt; 封装在fun-expression和源行号中，将其变成&amp;ldquo;测试对象&amp;rdquo;。从技术上讲，这与 &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f90beb2441a8b6db181aba2d7f261f9f114ad008" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the net kernel was started using &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;{error, not_allowed}&lt;/code&gt; is returned. Returns &lt;code&gt;{error, not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">将分布式节点转变为非分布式节点。对于网络中的其他节点，这与发生故障的节点相同。仅当使用 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 启动网络内核时才可能，否则返回 &lt;code&gt;{error, not_allowed}&lt;/code&gt; 。如果本地节点未处于活动状态 &lt;code&gt;{error, not_found}&lt;/code&gt; 则返回{error，not_found}。</target>
        </trans-unit>
        <trans-unit id="d9857baf63bd4ff78f8a1416e9cce2328191833c" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node by starting &lt;code&gt;net_kernel&lt;/code&gt; and other necessary processes.</source>
          <target state="translated">通过启动 &lt;code&gt;net_kernel&lt;/code&gt; 和其他必要的过程，将非分布式节点转变为分布式节点。</target>
        </trans-unit>
        <trans-unit id="3f5c74d445a6ff38a1d1a5a031b9bc86b2fedd78" translate="yes" xml:space="preserve">
          <source>Turns a parsed dictionary, as returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt;, back into the dictionary format.</source>
          <target state="translated">将由 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 返回的已解析字典转回字典格式。</target>
        </trans-unit>
        <trans-unit id="e92b0eef302a90ddf93e3d3b8a0765906432d6ac" translate="yes" xml:space="preserve">
          <source>Turns an ordered list &lt;code&gt;List&lt;/code&gt; of key-value tuples into a tree. The list must not contain duplicate keys.</source>
          <target state="translated">将键值元组的有序列表 &lt;code&gt;List&lt;/code&gt; 变成树。该列表不得包含重复的键。</target>
        </trans-unit>
        <trans-unit id="8629e653fd2bdd0ad7cbe844c08311477772efcc" translate="yes" xml:space="preserve">
          <source>Turns an ordered-set list &lt;code&gt;List&lt;/code&gt; into a set. The list must not contain duplicates.</source>
          <target state="translated">将有序集合列表 &lt;code&gt;List&lt;/code&gt; 变成集合。该列表不得包含重复项。</target>
        </trans-unit>
        <trans-unit id="9373344ff9c8b8d02dd03592aeaf47c2fd0e64a6" translate="yes" xml:space="preserve">
          <source>Turns off all debugging for the process. This includes functions that are installed explicitly with function &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt;, for example, triggers.</source>
          <target state="translated">关闭该进程的所有调试。这包括与功能 &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt; 一起显式安装的功能，例如触发器。</target>
        </trans-unit>
        <trans-unit id="d36edf7582655f75400ba16943847aa4c6aa0271" translate="yes" xml:space="preserve">
          <source>Turns off warnings for &quot;fresh&quot; variables in functional objects or list comprehensions with the same name as some already defined variable. Default is to emit warnings for such variables.</source>
          <target state="translated">关闭对功能对象或列表理解中的 &quot;新鲜 &quot;变量的警告,这些变量的名称与某些已经定义的变量相同。默认情况下,对此类变量发出警告。</target>
        </trans-unit>
        <trans-unit id="c093c691688f1f921a86e4bb9a9da3d6975d7358" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions like &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; does, but only for the mentioned functions. &lt;code&gt;MFAs&lt;/code&gt; is a tuple &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">像 &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; 一样，关闭对已弃用函数的调用的警告，但仅针对所提及的函数。 &lt;code&gt;MFAs&lt;/code&gt; 是元组 &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; 或此类元组的列表。</target>
        </trans-unit>
        <trans-unit id="31c129b33c46ffb547299340b27a43f495c00d43" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions. Default is to emit warnings for every call to a function known by the compiler to be deprecated. Notice that the compiler does not know about attribute &lt;code&gt;-deprecated()&lt;/code&gt;, but uses an assembled list of deprecated functions in Erlang/OTP. To do a more general check, the Xref tool can be used. See also &lt;code&gt;xref(3)&lt;/code&gt; and the function &lt;code&gt;xref:m/1&lt;/code&gt;, also accessible through the function &lt;code&gt;c:xm/1&lt;/code&gt;.</source>
          <target state="translated">关闭针对不推荐使用的函数的警告。默认是对编译器已知要弃用的每个函数发出警告。请注意，编译器不知道属性 &lt;code&gt;-deprecated()&lt;/code&gt; ，但是使用Erlang / OTP中已汇编的不推荐使用的函数列表。要进行更常规的检查，可以使用外部参照工具。另请参见 &lt;code&gt;xref(3)&lt;/code&gt; 和函数 &lt;code&gt;xref:m/1&lt;/code&gt; ，也可以通过函数 &lt;code&gt;c:xm/1&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="d8643ee4d5408ecde9d2dfad0ec79316bb062403" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to old type testing BIFs, such as &lt;code&gt;pid/1&lt;/code&gt; and &lt;code&gt;list/1&lt;/code&gt;. See the &lt;code&gt;Erlang Reference Manual&lt;/code&gt; for a complete list of type testing BIFs and their old equivalents. Default is to emit warnings for calls to old type testing BIFs.</source>
          <target state="translated">关闭对老式测试BIF（例如 &lt;code&gt;pid/1&lt;/code&gt; 和 &lt;code&gt;list/1&lt;/code&gt; )的调用的警告。有关类型测试BIF及其旧等效项的完整列表，请参见《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 》。默认值为对旧类型测试BIF的调用发出警告。</target>
        </trans-unit>
        <trans-unit id="858be8f3bcf091fa061e46059bd3158726b548e6" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions like &lt;code&gt;nowarn_unused_function&lt;/code&gt; does, but only for the mentioned local functions. &lt;code&gt;FAs&lt;/code&gt; is a tuple &lt;code&gt;{Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">关闭未使用的本地函数（如 &lt;code&gt;nowarn_unused_function&lt;/code&gt; )的警告，但仅针对提到的本地函数。 &lt;code&gt;FAs&lt;/code&gt; 是元组 &lt;code&gt;{Name,Arity}&lt;/code&gt; 或此类元组的列表。</target>
        </trans-unit>
        <trans-unit id="c5e54f68af28f7baa91e0a423d6d647a5b8f257e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions. Default is to emit warnings for all local functions that are not called directly or indirectly by an exported function. The compiler does not include unused local functions in the generated beam file, but the warning is still useful to keep the source code cleaner.</source>
          <target state="translated">关闭未使用的本地函数的警告。默认情况下,对所有未被导出函数直接或间接调用的局部函数发出警告。编译器不会将未使用的局部函数包含在生成的梁文件中,但该警告对于保持源代码的清洁还是很有用的。</target>
        </trans-unit>
        <trans-unit id="8756279a371f2c74c71bfe9ea11d8fce882bd7ef" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused record types. Default is to emit warnings for unused locally defined record types.</source>
          <target state="translated">关闭对未使用的记录类型的警告。默认为对未使用的本地定义的记录类型发出警告。</target>
        </trans-unit>
        <trans-unit id="40e660b8f492c229e1e8f807933c1bba4d2abc6f" translate="yes" xml:space="preserve">
          <source>Turns off warnings for use of deprecated types. Default is to emit warnings for every use of a type known by the compiler to be deprecated.</source>
          <target state="translated">关闭对使用废弃类型的警告。缺省值是对每次使用编译器已知的废弃类型时发出警告。</target>
        </trans-unit>
        <trans-unit id="176262640a2c391f662fb5a4f78d832cbe27740e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for uses of the &lt;code&gt;export_all&lt;/code&gt; option. Default is to emit a warning if option &lt;code&gt;export_all&lt;/code&gt; is also given.</source>
          <target state="translated">关闭有关 &lt;code&gt;export_all&lt;/code&gt; 选项使用的警告。如果还给出了选项 &lt;code&gt;export_all&lt;/code&gt; ,则默认为发出警告。</target>
        </trans-unit>
        <trans-unit id="849c8f41403b31c687964c8f844bbdc3100c6d15" translate="yes" xml:space="preserve">
          <source>Turns on (if &lt;code&gt;How == true&lt;/code&gt;) or off (if &lt;code&gt;How == false&lt;/code&gt;) the trace flags in &lt;code&gt;FlagList&lt;/code&gt; for the process or processes represented by &lt;code&gt;PidPortSpec&lt;/code&gt;.</source>
          <target state="translated">在转弯时（如 &lt;code&gt;How == true&lt;/code&gt; ）或关闭（如果 &lt;code&gt;How == false&lt;/code&gt; ）跟踪的标志 &lt;code&gt;FlagList&lt;/code&gt; 由代表一个或多个进程 &lt;code&gt;PidPortSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90d4fea9a9eccae1bb6537b80425ce163c0e0e56" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for all types of function calls. Trace messages are sent whenever any of the specified functions are called, regardless of how they are called. If flag &lt;code&gt;return_to&lt;/code&gt; is set for the process, a &lt;code&gt;return_to&lt;/code&gt; message is also sent when this function returns to its caller.</source>
          <target state="translated">为所有类型的函数调用打开或关闭调用跟踪。无论何时调用任何指定函数，无论如何调用，都会发送跟踪消息。如果为进程设置了标志 &lt;code&gt;return_to&lt;/code&gt; ,则当此函数返回其调用方时，也会发送 &lt;code&gt;return_to&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="9cdc9034760c5ba6cf5f548250769a126c6a5dc8" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for global function calls (that is, calls specifying the module explicitly). Only exported functions match and only global calls generate trace messages. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">为全局函数调用（即，明确指定模块的调用）打开或关闭调用跟踪。只有导出的函数匹配，并且只有全局调用才能生成跟踪消息。&lt;strong&gt;这是默认值&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dbac06dc38fd14ffc69474d6cefe052fcc1e6496" translate="yes" xml:space="preserve">
          <source>Turns on or off meta-tracing for all types of function calls. Trace messages are sent to the tracer whenever any of the specified functions are called. If no tracer is specified, &lt;code&gt;self()&lt;/code&gt; is used as a default tracer process.</source>
          <target state="translated">为所有类型的函数调用打开或关闭元跟踪。每当调用任何指定功能时，跟踪消息就会发送到跟踪器。如果未指定跟踪器，则 &lt;code&gt;self()&lt;/code&gt; 用作默认跟踪器进程。</target>
        </trans-unit>
        <trans-unit id="a4a9e6071c635a8a8f47c7128d5e27fbe6794aa8" translate="yes" xml:space="preserve">
          <source>Turns on or off scheduler wall time measurements.</source>
          <target state="translated">开启或关闭调度器墙面时间测量。</target>
        </trans-unit>
        <trans-unit id="6491707b6fbdad098acea3fe30f8bc3c9caeff41" translate="yes" xml:space="preserve">
          <source>Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.</source>
          <target state="translated">开启/关闭微状态核算测量。当通过复位时,所有的计数器都被复位为0。</target>
        </trans-unit>
        <trans-unit id="49209b989e6c3ee063b36215b5a4316a9a7be144" translate="yes" xml:space="preserve">
          <source>Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is &lt;code&gt;AF_INET6&lt;/code&gt;).</source>
          <target state="translated">打开或关闭IPv4地址到IPv6地址的自动映射（如果套接字地址系列为 &lt;code&gt;AF_INET6&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f85ecd85cea1de6466fad134e2d2f8f716405e71" translate="yes" xml:space="preserve">
          <source>Turns on|off the Nagle algorithm for merging small packets into larger ones. This improves throughput at the expense of latency.</source>
          <target state="translated">打开|关闭Nagle算法,将小数据包合并成大数据包。这将以延迟为代价提高吞吐量。</target>
        </trans-unit>
        <trans-unit id="a1f9ac44326e752574b33a1f14907aa1c45d24f1" translate="yes" xml:space="preserve">
          <source>Turns the logging of system events on or off. If on, a maximum of &lt;code&gt;N&lt;/code&gt; events are kept in the debug structure (default is 10).</source>
          <target state="translated">打开或关闭系统事件的日志记录。如果启用，则调试结构中最多保留 &lt;code&gt;N&lt;/code&gt; 个事件（默认值为10）。</target>
        </trans-unit>
        <trans-unit id="23c458441c0867d8269280b70644bb94df142cbd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are supported:</source>
          <target state="translated">支持两种 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e3d52e5b54fd0236c6fd5f3a13294fee0ddff15" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;code&gt;match&lt;/code&gt; if they are of the same type and have the same value, so that &lt;code&gt;1&lt;/code&gt; matches &lt;code&gt;1&lt;/code&gt;, but not &lt;code&gt;1.0&lt;/code&gt; (as &lt;code&gt;1.0&lt;/code&gt; is a &lt;code&gt;float()&lt;/code&gt; and not an &lt;code&gt;integer()&lt;/code&gt;).</source>
          <target state="translated">如果两个Erlang项具有相同的类型并且具有相同的值，则它们 &lt;code&gt;match&lt;/code&gt; ，因此 &lt;code&gt;1&lt;/code&gt; 匹配 &lt;code&gt;1&lt;/code&gt; ，但不匹配 &lt;code&gt;1.0&lt;/code&gt; （因为 &lt;code&gt;1.0&lt;/code&gt; 是 &lt;code&gt;float()&lt;/code&gt; 而不是 &lt;code&gt;integer()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d09b25abb2a2cc4ca463f856d47434d8b27efd72" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;strong&gt;compare equal&lt;/strong&gt; if they either are of the same type and value, or if both are numeric types and extend to the same value, so that &lt;code&gt;1&lt;/code&gt; compares equal to both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">两方面的Erlang &lt;strong&gt;比较相等&lt;/strong&gt;，如果它们或者是相同的类型和值，或者如果两者都数字类型，并延伸到相同的值，从而使 &lt;code&gt;1&lt;/code&gt; 比较等于两个 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe9db2aa68d2fec9c04e8f17ebd9155b9b06ccb7" translate="yes" xml:space="preserve">
          <source>Two adjacent &lt;code&gt;*&lt;/code&gt; used as a single pattern match all files and zero or more directories and subdirectories.</source>
          <target state="translated">用作单个模式的两个相邻 &lt;code&gt;*&lt;/code&gt; 匹配所有文件以及零个或多个目录和子目录。</target>
        </trans-unit>
        <trans-unit id="b24fbae83d83ea5cfa4199071718c20f64dd2575" translate="yes" xml:space="preserve">
          <source>Two adjacent string literals are concatenated into one. This is done in the compilation, thus, does not incur any runtime overhead.</source>
          <target state="translated">两个相邻的字符串字元被连接成一个。这是在编译过程中完成的,因此,不会产生任何运行时的开销。</target>
        </trans-unit>
        <trans-unit id="1cec8b2ac60b473ad30ad5a9539e9b27a87fdf3d" translate="yes" xml:space="preserve">
          <source>Two are containers for binary data and are called:</source>
          <target state="translated">二是二进制数据的容器,称为。</target>
        </trans-unit>
        <trans-unit id="00afe0b16fc4b5dc8fb5d2b5e5c18c2ad4f6f71e" translate="yes" xml:space="preserve">
          <source>Two are merely references to a part of a binary and are called:</source>
          <target state="translated">二只是对二进制的一部分的引用,称为。</target>
        </trans-unit>
        <trans-unit id="98533a56936d4841968d6378e92444f0f102a983" translate="yes" xml:space="preserve">
          <source>Two cases can occur:</source>
          <target state="translated">会出现两种情况。</target>
        </trans-unit>
        <trans-unit id="f6f177120050db74caa4e744ec6cff39212557e9" translate="yes" xml:space="preserve">
          <source>Two different methods for opening a connection using the support functions in, for example, &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; follows:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 等支持功能打开连接的两种不同方法如下：</target>
        </trans-unit>
        <trans-unit id="d8398755c3e867c12fc5deb0d9e53ba2d8bf52d0" translate="yes" xml:space="preserve">
          <source>Two different names cannot define the same OBJECT IDENTIFIER.</source>
          <target state="translated">两个不同的名字不能定义同一个OBJECT IDENTIFIER。</target>
        </trans-unit>
        <trans-unit id="e330ec8353880267f056d94838df302f660f82d1" translate="yes" xml:space="preserve">
          <source>Two formats of the log files are supported:</source>
          <target state="translated">支持两种格式的日志文件。</target>
        </trans-unit>
        <trans-unit id="a4eef9b92d56df50918b227071f569535a9d01e3" translate="yes" xml:space="preserve">
          <source>Two forms have special meaning:</source>
          <target state="translated">两种形式具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="cfd82c68ad98788490ce7310efdb097df7571def" translate="yes" xml:space="preserve">
          <source>Two forms of &lt;code&gt;--inherits&lt;/code&gt; have special meaning:</source>
          <target state="translated">&lt;code&gt;--inherits&lt;/code&gt; 的两种形式具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="7200659e5edf764a36bafabfdd35b2bc1867bbcb" translate="yes" xml:space="preserve">
          <source>Two functions (modules, applications, releases) belong to the same strongly connected component if they call each other (in)directly. The interpretation of the &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; operator is the set of strongly connected components of a set of calls. The &lt;code&gt;condensation&lt;/code&gt; of a set of calls is a new set of calls between the strongly connected components such that there is an edge between two components if there is some constant of the first component that calls some constant of the second component.</source>
          <target state="translated">如果两个函数（模块，应用程序，发行版）彼此直接（间接）调用，则它们属于同一强连接的组件。 &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; 运算符的解释是一组调用中的一组强连接的组件。所述 &lt;code&gt;condensation&lt;/code&gt; 的一组呼叫的是一组新的强连接部件之间的呼叫，使得在这两个部件之间的边缘，如果有，调用第二组分的一些恒定的第一成分的一些常数。</target>
        </trans-unit>
        <trans-unit id="8330baa5a8c7712027a0d478bca1ae0572b758a5" translate="yes" xml:space="preserve">
          <source>Two guard BIFs handle maps:</source>
          <target state="translated">两个警卫BIF处理地图。</target>
        </trans-unit>
        <trans-unit id="0b0d7874fec4ed30ad6e8758caa4fe777cac7d9b" translate="yes" xml:space="preserve">
          <source>Two interoperability mechanisms are built into the Erlang runtime system, &lt;strong&gt;distributed Erlang&lt;/strong&gt; and &lt;strong&gt;ports&lt;/strong&gt;. A variation of ports is &lt;strong&gt;linked-in drivers&lt;/strong&gt;.</source>
          <target state="translated">Erlang运行时系统内置了两种互操作性机制，即&lt;strong&gt;分布式Erlang&lt;/strong&gt;和&lt;strong&gt;ports&lt;/strong&gt;。端口的变化是&lt;strong&gt;链接的驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5dedccf2b4c340ae3513b7f5da6ce218b6889bec" translate="yes" xml:space="preserve">
          <source>Two keys are considered equal if they match (&lt;code&gt;=:=&lt;/code&gt;). That is, numbers are compared literally rather than by value, so that, for example, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; are different keys.</source>
          <target state="translated">如果两个键匹配（ &lt;code&gt;=:=&lt;/code&gt; ），则认为它们相等。也就是说，数字是按字面意义而不是按值进行比较，因此，例如 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 是不同的键。</target>
        </trans-unit>
        <trans-unit id="211827ea828fd59c26ecf8cc7423a3ab35588d32" translate="yes" xml:space="preserve">
          <source>Two methods are available for writing database queries:</source>
          <target state="translated">编写数据库查询有两种方法。</target>
        </trans-unit>
        <trans-unit id="cad65263f8565f810c97115c267d8c4735088c82" translate="yes" xml:space="preserve">
          <source>Two more examples, both selecting Latin-1 as default encoding:</source>
          <target state="translated">还有两个例子,都选择Latin-1作为默认编码。</target>
        </trans-unit>
        <trans-unit id="310abdb2aa2e0aae49bd84e931c4347743cefcc7" translate="yes" xml:space="preserve">
          <source>Two old applications are of interest regarding interoperability. Both have been replaced by IC and are mentioned here for reference only:</source>
          <target state="translated">在互操作性方面,有两个旧的应用值得关注。这两个应用都已被IC所取代,在此仅作参考。</target>
        </trans-unit>
        <trans-unit id="b2ee15f30d25e865ebb91626574306b0a361ae12" translate="yes" xml:space="preserve">
          <source>Two processes can be &lt;strong&gt;linked&lt;/strong&gt; to each other. A link between two processes &lt;code&gt;Pid1&lt;/code&gt; and &lt;code&gt;Pid2&lt;/code&gt; is created by &lt;code&gt;Pid1&lt;/code&gt; calling the BIF &lt;code&gt;link(Pid2)&lt;/code&gt; (or conversely). There also exist a number of &lt;code&gt;spawn_link&lt;/code&gt; BIFs, which spawn and link to a process in one operation.</source>
          <target state="translated">两个过程可以相互&lt;strong&gt;链接&lt;/strong&gt;。两个进程 &lt;code&gt;Pid1&lt;/code&gt; 和 &lt;code&gt;Pid2&lt;/code&gt; 之间的链接是通过 &lt;code&gt;Pid1&lt;/code&gt; 调用BIF &lt;code&gt;link(Pid2)&lt;/code&gt; （或相反）来创建的。还存在许多 &lt;code&gt;spawn_link&lt;/code&gt; BIF，它们可以在一个操作中生成并链接到进程。</target>
        </trans-unit>
        <trans-unit id="5608c70162089e189da4df1a1b5bf134008a262e" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal iff they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果两个资源项传递给 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 时它们将产生相同的资源对象指针，则它们将比较相等。</target>
        </trans-unit>
        <trans-unit id="af30a2501d3290d8d47d226b3a9dd6e2917631b1" translate="yes" xml:space="preserve">
          <source>Two sets are &lt;strong id=&quot;disjoint&quot;&gt;disjoint&lt;/strong&gt; if their intersection is the empty set.</source>
          <target state="translated">如果两个集合的交集为空集合，则它们是&lt;strong id=&quot;disjoint&quot;&gt;不&lt;/strong&gt;相交的。</target>
        </trans-unit>
        <trans-unit id="e7ebc9faf237e0b7af0081118908fcbec68ae6ca" translate="yes" xml:space="preserve">
          <source>Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">有两组元字符:除方括号内的元字符外,图案中任何地方都能识别的元字符,以及方括号内的元字符。方括号外的元字符如下。</target>
        </trans-unit>
        <trans-unit id="ca80cfab8caa7daafc007467d281bddd65b58bec" translate="yes" xml:space="preserve">
          <source>Two simple implementation(s) is provided with the toolkit; the modules &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; which is the default and &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">工具包提供了两个简单的实现。默认模块 &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8aad91307995a202add0f48ff4e5e1745721276" translate="yes" xml:space="preserve">
          <source>Two subterms are supported, &lt;code&gt;node_start&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">支持两个子项， &lt;code&gt;node_start&lt;/code&gt; 和 &lt;code&gt;eval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a86bc9ecf16a74feace03ab8af025d243363cf6" translate="yes" xml:space="preserve">
          <source>Two terms &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; compare equal if &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. They match if &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ,则两个项 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 比较相等。如果 &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ,则它们匹配。</target>
        </trans-unit>
        <trans-unit id="319ab96ab6a94c595bf510dc2b6df202a2c7e4fb" translate="yes" xml:space="preserve">
          <source>Two time types are defined within ASN.1: Generalized Time and Universal Time Coordinated (UTC). Both are assigned a value as an ordinary string within double quotes, for example, &quot;19820102070533.8&quot;.</source>
          <target state="translated">ASN.1中定义了两种时间类型。通用时间和世界协调时间(UTC)。两者都以双引号内的普通字符串形式赋值,例如,&quot;19820102070533.8&quot;。</target>
        </trans-unit>
        <trans-unit id="5cbed6cd9f648062eb5c7c60f1a880bc94c83866" translate="yes" xml:space="preserve">
          <source>Two trace drivers are currently implemented, the &lt;code&gt;file&lt;/code&gt; and the &lt;code&gt;ip&lt;/code&gt; trace drivers. The file driver sends all trace messages into one or several binary files, from where they later can be fetched and processed with the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; function. The ip driver opens a TCP/IP port where it listens for connections. When a client (preferably started by calling &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; on another Erlang node) connects, all trace messages are sent over the IP network for further processing by the remote client.</source>
          <target state="translated">当前实现了两个跟踪驱动程序，即 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;ip&lt;/code&gt; 跟踪驱动程序。文件驱动程序将所有跟踪消息发送到一个或几个二进制文件中，以后可以使用 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 函数从中提取并处理它们。ip驱动程序打开一个TCP / IP端口，在其中侦听连接。当客户端（最好通过在另一个Erlang节点上调用 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 启动）连接时，所有跟踪消息都将通过IP网络发送，以供远程客户端进一步处理。</target>
        </trans-unit>
        <trans-unit id="c70732f422ad9f7dd9ec37500b2c8c51a72ca7dd" translate="yes" xml:space="preserve">
          <source>Two types of funs have slightly different semantics:</source>
          <target state="translated">两类趣味的语义略有不同。</target>
        </trans-unit>
        <trans-unit id="c611be8ba1da86ea53fc2e7c1dde0be77787929a" translate="yes" xml:space="preserve">
          <source>Two types of logs are supported:</source>
          <target state="translated">支持两种类型的日志。</target>
        </trans-unit>
        <trans-unit id="95838f01360f14fad0ac2ded66819bb7c9468ffa" translate="yes" xml:space="preserve">
          <source>Two upgrade instructions restart the emulator:</source>
          <target state="translated">两个升级指令重启模拟器。</target>
        </trans-unit>
        <trans-unit id="4806b67c077ea8929e31609963501c8a6fe89444" translate="yes" xml:space="preserve">
          <source>Two values are supported for &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; 支持两个值：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
