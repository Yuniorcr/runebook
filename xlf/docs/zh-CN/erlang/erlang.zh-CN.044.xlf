<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="400e9b2c243f2f7c7d92b4dcf08486534cb1952f" translate="yes" xml:space="preserve">
          <source>Time Precision</source>
          <target state="translated">时间精度</target>
        </trans-unit>
        <trans-unit id="cad164c081a78f266eeeb300b8131692f7bc1b2f" translate="yes" xml:space="preserve">
          <source>Time Resolution</source>
          <target state="translated">时间分辨率</target>
        </trans-unit>
        <trans-unit id="1b437206adf14eaf51046c0192d059cd605c7e97" translate="yes" xml:space="preserve">
          <source>Time Warp</source>
          <target state="translated">时空穿梭</target>
        </trans-unit>
        <trans-unit id="a82ad5fd600ff000d4dd1a4b75dec09bd53099b8" translate="yes" xml:space="preserve">
          <source>Time in milli-seconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="fb90c3d94bbbbb48a0690451d16d4a2746e6cf58" translate="yes" xml:space="preserve">
          <source>Time in milliseconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="52f73c9f88768be27ae1df301f0781defb2c8b55" translate="yes" xml:space="preserve">
          <source>Time interval (in seconds) between each update of the display.</source>
          <target state="translated">显示屏每次更新之间的时间间隔(秒)。</target>
        </trans-unit>
        <trans-unit id="aa2bb96c7dd2c54fd6b747929cbd2b7c505afa22" translate="yes" xml:space="preserve">
          <source>Time is in milliseconds.</source>
          <target state="translated">时间以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="9335c98c7b128731a14ad90889a8a634ba7a0e3f" translate="yes" xml:space="preserve">
          <source>Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT).</source>
          <target state="translated">如果根据当前时区和夏令时调整时间,则为当地时间。如果时间反映的是零经度的时间,而不根据夏令时进行任何调整,则为世界时间。世界协调时间(UTC)也称为格林尼治标准时间(GMT)。</target>
        </trans-unit>
        <trans-unit id="778cab80afb8fbb53cb2e3770f0d9802c84b4243" translate="yes" xml:space="preserve">
          <source>Time is shown as percentage of total time and as absolute time.</source>
          <target state="translated">时间以总时间的百分比和绝对时间显示。</target>
        </trans-unit>
        <trans-unit id="bfab7fde2f2bd1c95dae042160e5b78de938455d" translate="yes" xml:space="preserve">
          <source>Time is vital to an Erlang program and, more importantly, &lt;strong&gt;correct&lt;/strong&gt; time is vital to an Erlang program. As Erlang is a language with soft real-time properties and we can express time in our programs, the Virtual Machine and the language must be careful about what is considered a correct time and in how time functions behave.</source>
          <target state="translated">时间对于Erlang程序至关重要，更重要的是，&lt;strong&gt;正确的&lt;/strong&gt;时间对于Erlang程序至关重要。由于Erlang是一种具有软实时属性的语言，并且我们可以在程序中表达时间，因此虚拟机和该语言必须谨慎选择正确的时间以及时间函数的行为。</target>
        </trans-unit>
        <trans-unit id="dfb8ee1d3368aa29179a6d65ecd926cdeee8b67e" translate="yes" xml:space="preserve">
          <source>Time of failure.</source>
          <target state="translated">失败的时间。</target>
        </trans-unit>
        <trans-unit id="e5b5ff320546cded57bcdfd8e9154e88bfce347b" translate="yes" xml:space="preserve">
          <source>Time since &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt;. Epoch is defined to be 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt;, 1970-01-01. &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; is defined to be exactly 86400 seconds long. Strangely enough, Epoch is defined to be a time in UTC, and UTC has another definition of how long a day is. Quoting the Open Group &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt;. The effect of this is that when an UTC leap second is inserted, POSIX time either stops for a second, or repeats the last second. If an UTC leap second would be deleted (which has not happened yet), POSIX time would make a one second leap forward.</source>
          <target state="translated">自 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt; 以来的时间。时代被定义为00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; ，1970-01-01。 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; 定义为正好是86400秒。奇怪的是，Epoch被定义为UTC时间，而UTC还定义了一天的时间。引用开放组 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt; 。这样的效果是，当插入UTC leap秒时，POSIX时间要么停止一秒，要么重复最后一秒。如果UTC leap秒将被删除（尚未发生），则POSIX时间将向前跳一秒。</target>
        </trans-unit>
        <trans-unit id="c633e68c77dad8ff55d69828cca1fdead9120622" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt; statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">花时间忙于等待。这也是调度器在使用 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt; statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 时不再报告其处于活动状态的状态。因此，如果您将除此状态和睡眠状态之外的所有其他状态相加，然后在线程中将其除以所有时间，则应该得到与 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 分数非常相似的信息。没有额外的状态，这一次是 &lt;code&gt;other&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="daff1c5051fc31c193cbc0ef30cf4e11a8fa0acc" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">花时间忙于等待。这也是调度器在使用 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 时不再报告其处于活动状态的状态。因此，如果您将除此状态和睡眠状态之外的所有其他状态相加，然后在线程中将其除以所有时间，则应该得到与 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 分数非常相似的信息。没有额外的状态，这一次是 &lt;code&gt;other&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="4b70b59840bac36480b4ca278b19551bc7ff7ba0" translate="yes" xml:space="preserve">
          <source>Time spent checking for new I/O events.</source>
          <target state="translated">检查新的I/O事件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="f8c4236fa95ff532dbcc0e2d31ef284b6605be9f" translate="yes" xml:space="preserve">
          <source>Time spent doing fullsweep garbage collection. Without extra states this time is part of the &lt;code&gt;gc&lt;/code&gt; state.</source>
          <target state="translated">花时间进行全清理垃圾收集。没有额外的状态，这一次是 &lt;code&gt;gc&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="804fe3e4c31d22ca440eb466bced64dac260645c" translate="yes" xml:space="preserve">
          <source>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</source>
          <target state="translated">做垃圾收集所花费的时间。当启用额外状态时,这是做非全扫垃圾收集所花费的时间。</target>
        </trans-unit>
        <trans-unit id="f0d5415566936904747ef14c0c4e3fb853196c06" translate="yes" xml:space="preserve">
          <source>Time spent doing unaccounted things.</source>
          <target state="translated">做不明事理的时间。</target>
        </trans-unit>
        <trans-unit id="4ba30f1fc2208657042880d6015e182708b6ae95" translate="yes" xml:space="preserve">
          <source>Time spent executing ETS BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">执行ETS BIF所花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="6f0aba2d54a382bffda8610e637bf0f9265a1fa2" translate="yes" xml:space="preserve">
          <source>Time spent executing Erlang processes.</source>
          <target state="translated">执行Erlang进程的时间。</target>
        </trans-unit>
        <trans-unit id="2140217ef427aad1b621513a3b193759d78a1510" translate="yes" xml:space="preserve">
          <source>Time spent executing ports.</source>
          <target state="translated">执行端口的时间。</target>
        </trans-unit>
        <trans-unit id="1d9aa0e3f8d5f8534bd40659e4d0e67ab0101833" translate="yes" xml:space="preserve">
          <source>Time spent handling auxiliary jobs.</source>
          <target state="translated">处理辅助工作的时间。</target>
        </trans-unit>
        <trans-unit id="18b77c82a332110e23d9be0001f08986fee15519" translate="yes" xml:space="preserve">
          <source>Time spent in BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">在BIF中花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="bcdc57b7f7275d059418c6711b15d167f486f63c" translate="yes" xml:space="preserve">
          <source>Time spent in NIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">NIF中花费的时间。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="4050018617b293ffdfb42ee633136a70a84f563a" translate="yes" xml:space="preserve">
          <source>Time spent managing memory. Without extra states this time is spread out over all other states.</source>
          <target state="translated">管理内存的时间。如果没有额外的状态,这个时间就会被分散到其他所有状态中。</target>
        </trans-unit>
        <trans-unit id="9c01fc3b7f3c2c3c0d6942008a58943e7689d103" translate="yes" xml:space="preserve">
          <source>Time spent managing timers. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">花时间管理计时器。没有额外的状态，这一次是 &lt;code&gt;other&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="219f1ac61c024af183643b65bf00f27585517b49" translate="yes" xml:space="preserve">
          <source>Time spent sending messages (processes only). Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">发送消息所花费的时间（仅用于进程）。没有额外的状态，这一次是 &lt;code&gt;emulator&lt;/code&gt; 状态的一部分。</target>
        </trans-unit>
        <trans-unit id="cbdb8b8de682894a050f647f9b6f67984322b3e7" translate="yes" xml:space="preserve">
          <source>Time spent sleeping.</source>
          <target state="translated">睡觉的时间。</target>
        </trans-unit>
        <trans-unit id="5e12873ae797e4ba07d58c20986f4c5eb0d01fbc" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages consist of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">概要文件消息中的时间戳由 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 和单调递增的整数组成。时间戳（Ts）与 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="0a74926d30453b95a42997402e366f9dbba46f4a" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages include a time stamp (Ts) that has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;. This is also the default if no time stamp flag is specified. If &lt;code&gt;cpu_timestamp&lt;/code&gt; has been enabled through &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, this also effects the time stamp produced in profiling messages when flag &lt;code&gt;timestamp&lt;/code&gt; is enabled.</source>
          <target state="translated">配置文件消息中的时间戳包括一个时间戳（Ts），该时间戳具有与 &lt;code&gt;erlang:now()&lt;/code&gt; 返回的形式相同的形式。如果未指定时间戳标志，则这也是默认设置。如果已通过 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 启用了 &lt;code&gt;cpu_timestamp&lt;/code&gt; ,则当启用了标记时间戳记时，这也会影响性能分析消息中产生的 &lt;code&gt;timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22076e8ed9090afa79ae14afc1154da3fcea7d53" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages use &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">配置文件消息中的时间戳使用 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 。时间戳（Ts）与 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="08ca334e927c4c6c13a180ed022f0e1809c6b0ea" translate="yes" xml:space="preserve">
          <source>Time unit expressed in parts per second. That is, the time unit equals &lt;code&gt;1/PartsPerSecond&lt;/code&gt; second.</source>
          <target state="translated">时间单位表示为每秒的零件数。即，时间单位等于 &lt;code&gt;1/PartsPerSecond&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="56955f846ca14fda201279a48f5480070c862756" translate="yes" xml:space="preserve">
          <source>Time unit of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 的时间单位。</target>
        </trans-unit>
        <trans-unit id="ddf7ef9b043acd2fefcc767917bfb64bbe68691e" translate="yes" xml:space="preserve">
          <source>Time unit of returned value.</source>
          <target state="translated">返回值的时间单位。</target>
        </trans-unit>
        <trans-unit id="c31fd1a438289cad94f807ff509ea2830cb0a280" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 来创建设置计时器的时间。计时器应该传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cba69c610e8e4d4cb1aafc070b3b00791654be26" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 来创建设置计时器的时间。计时器应该传递给 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ead486368f8803155ffc6453947e99e4019e5bc" translate="yes" xml:space="preserve">
          <source>Time warp safe code can handle a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">时间隧道安全的代码可以处理一个 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75c9ade9b7ea54157fc5ea15b058fcb35255e656" translate="yes" xml:space="preserve">
          <source>Time when the event record was created.</source>
          <target state="translated">事件记录的创建时间。</target>
        </trans-unit>
        <trans-unit id="1078e1766373df8f70c0326e90a0881d10d2001d" translate="yes" xml:space="preserve">
          <source>Time when the trace was generated. Same as event_ts if omitted in trace data.</source>
          <target state="translated">追踪数据产生的时间。如果在跟踪数据中省略,则与event_ts相同。</target>
        </trans-unit>
        <trans-unit id="ea920146725e69689044ec910022adb3cb308cc6" translate="yes" xml:space="preserve">
          <source>Time-Constrained Tracing</source>
          <target state="translated">时间限制跟踪</target>
        </trans-unit>
        <trans-unit id="9b588b2f86ac72f24f2b525ef5518aac39862ff1" translate="yes" xml:space="preserve">
          <source>Time-Out Functions</source>
          <target state="translated">超时功能</target>
        </trans-unit>
        <trans-unit id="7c54440dd4618f7bc17db7c59ce90a91687e0a3f" translate="yes" xml:space="preserve">
          <source>Time-constrained tracing</source>
          <target state="translated">时间限制跟踪</target>
        </trans-unit>
        <trans-unit id="dad879fd6c0ee22983f6de70e89c35317fb40e21" translate="yes" xml:space="preserve">
          <source>Time-out expired.</source>
          <target state="translated">超时已过。</target>
        </trans-unit>
        <trans-unit id="3e8c25c48b5132875c91d0c03a35c580928a7337" translate="yes" xml:space="preserve">
          <source>Time-out time for the request.</source>
          <target state="translated">请求的超时时间。</target>
        </trans-unit>
        <trans-unit id="dbff00965ebcca637b30964828cca5002698389b" translate="yes" xml:space="preserve">
          <source>Time-out timers &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events.</source>
          <target state="translated">处理超时计时器 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 。确保零时间的超时在任何外部尚未接收的事件发生之前传递到状态机，因此，如果请求了这样的超时，则将相应的零超时事件排队作为最新的接收事件；那是在已经排队的事件（例如插入和推迟的事件）之后。</target>
        </trans-unit>
        <trans-unit id="921bd14fe959f56d9bf6ef39fbc93c256e6bb1db" translate="yes" xml:space="preserve">
          <source>Time-out, in milliseconds, for establishing an association</source>
          <target state="translated">建立联系的超时时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="321d15a7cc404b6bf384999b2f747b4923bb6c12" translate="yes" xml:space="preserve">
          <source>Time-outs in &lt;code&gt;gen_statem&lt;/code&gt; are started from a &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; during a state transition that is when exiting from the &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 中的超时是从 &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 期间从状态转换期间的 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 开始的。 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9d894573097754c7b54a6191c10c2264d5de941" translate="yes" xml:space="preserve">
          <source>Timeout ::</source>
          <target state="translated">超时:。</target>
        </trans-unit>
        <trans-unit id="9ba0fea57692bed3e35ebe6f8f6d8f58f2ad3a37" translate="yes" xml:space="preserve">
          <source>Timeout :: timeout()) -&amp;gt;</source>
          <target state="translated">超时:: timeout（））-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fd55cd4f150e662912da414d712d8565cc5d6ef" translate="yes" xml:space="preserve">
          <source>Timeout = &lt;code&gt;non_neg_integer()&lt;/code&gt;</source>
          <target state="translated">超时= &lt;code&gt;non_neg_integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c83fda5023992a3a755c63b7feecf8cc4bb563b5" translate="yes" xml:space="preserve">
          <source>Timeout has expired.</source>
          <target state="translated">超时已过。</target>
        </trans-unit>
        <trans-unit id="4de3dd3689e574562fe201d283c89d77aad9ff30" translate="yes" xml:space="preserve">
          <source>Timeout set the maximum time in milliseconds that each server request may take.</source>
          <target state="translated">超时设置每个服务器请求可能需要的最大时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="0c72d1236b15e71c6081373a09d082eddd39e1e9" translate="yes" xml:space="preserve">
          <source>Timeout time for the call proxy.</source>
          <target state="translated">呼叫代理的超时时间。</target>
        </trans-unit>
        <trans-unit id="b5240d69e014aa8db2761b61b654dac666884a70" translate="yes" xml:space="preserve">
          <source>Timeout) -&amp;gt;</source>
          <target state="translated">超时）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="cbe7ffd10c56674d0aeb143b8aef6a19536cbe9f" translate="yes" xml:space="preserve">
          <source>Timer functions.</source>
          <target state="translated">定时器功能。</target>
        </trans-unit>
        <trans-unit id="5775c0fa857a175458a6f31fe323d1c61544a03a" translate="yes" xml:space="preserve">
          <source>Timers and re-send of messages will be handled on locally on one node, that is node(1), in order to avoid unnecessary transfer of data between the Erlang nodes.</source>
          <target state="translated">定时器和重新发送消息将在本地的一个节点,即节点(1)上处理,以避免Erlang节点之间不必要的数据传输。</target>
        </trans-unit>
        <trans-unit id="345e4b38e568b767b30f56f4731767a882691f68" translate="yes" xml:space="preserve">
          <source>Timestamp = {MegaSecs, Secs, MicroSecs}</source>
          <target state="translated">时间戳={MegaSecs,Secs,MicroSecs}。</target>
        </trans-unit>
        <trans-unit id="15a044fe233b5f5d8f3f995d7e5a1a639fcad92c" translate="yes" xml:space="preserve">
          <source>Timestamps are formatted according to RFC3339, and the time designator is the character used as date and time separator.</source>
          <target state="translated">时间戳是根据RFC3339格式化的,时间代号是作为日期和时间分隔符的字符。</target>
        </trans-unit>
        <trans-unit id="ec489097f09779c8f0337c7ffff14c271f605260" translate="yes" xml:space="preserve">
          <source>Timetrap values can be extended with a multiplier value specified at startup with option &lt;code&gt;multiply_timetraps&lt;/code&gt;. It is also possible to let the test server decide to scale up timetrap time-out values automatically. That is, if tools such as &lt;code&gt;cover&lt;/code&gt; or &lt;code&gt;trace&lt;/code&gt; are running during the test. This feature is disabled by default and can be enabled with start option &lt;code&gt;scale_timetraps&lt;/code&gt;.</source>
          <target state="translated">Timetrap值可以用在启动时与选项指定的乘数值被扩展 &lt;code&gt;multiply_timetraps&lt;/code&gt; 。也可以让测试服务器决定自动扩展超时超时值。也就是说，如果工具，如 &lt;code&gt;cover&lt;/code&gt; 或 &lt;code&gt;trace&lt;/code&gt; 在测试过程中运行。此功能默认情况下处于禁用状态，可以通过启动选项 &lt;code&gt;scale_timetraps&lt;/code&gt; 启用。</target>
        </trans-unit>
        <trans-unit id="ce4a7717f17e9b8af076c5d38d2f59e28a523086" translate="yes" xml:space="preserve">
          <source>Tirhuta</source>
          <target state="translated">Tirhuta</target>
        </trans-unit>
        <trans-unit id="b51456deb293c14e281cc125141b1ca93bd63d71" translate="yes" xml:space="preserve">
          <source>Title case letter</source>
          <target state="translated">职称论文</target>
        </trans-unit>
        <trans-unit id="175f9c3cbfadc16808edf4696a9a651beef5a26c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - client side</source>
          <target state="translated">Tls/dtls选项说明-客户端。</target>
        </trans-unit>
        <trans-unit id="ebe960548ac60cdb2adcef7ca8456b9e2d23126c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - server side</source>
          <target state="translated">Tls/dtls选项说明-服务器端</target>
        </trans-unit>
        <trans-unit id="bf91222de5df25eb68a0c8123513399e374daae1" translate="yes" xml:space="preserve">
          <source>To &quot;teach&quot; the function how to extract, you can give a fun which replaces the default extraction function. The &lt;code&gt;fqdn_fun&lt;/code&gt; takes one argument and returns either a &lt;code&gt;string()&lt;/code&gt; to be matched to each CN-name or the atom &lt;code&gt;default&lt;/code&gt; which will invoke the default fqdn extraction function. The return value &lt;code&gt;undefined&lt;/code&gt; removes the current URI from the fqdn extraction.</source>
          <target state="translated">要&amp;ldquo;教&amp;rdquo;该函数如何提取，您可以尝试替换默认的提取函数。所述 &lt;code&gt;fqdn_fun&lt;/code&gt; 接收一个参数并返回任一 &lt;code&gt;string()&lt;/code&gt; 被匹配到每个CN-名称或原子 &lt;code&gt;default&lt;/code&gt; 这将调用默认FQDN提取功能。返回值 &lt;code&gt;undefined&lt;/code&gt; 从fqdn提取中删除当前URI。</target>
        </trans-unit>
        <trans-unit id="2c5be475329fded4946b65a55d659b706b6fb900" translate="yes" xml:space="preserve">
          <source>To :: &lt;code&gt;&lt;a href=&quot;#type-storage_type&quot;&gt;storage_type()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">到:: &lt;code&gt;&lt;a href=&quot;#type-storage_type&quot;&gt;storage_type()&lt;/a&gt;&lt;/code&gt; ）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6ddde9755b765c3b046311bcbccd6ae209f1079" translate="yes" xml:space="preserve">
          <source>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; instead of the simplified functions &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">要访问此类表，不能使用简化的访问功能（如前所述）。例如，将订户记录写入表需要功能 &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; 而不是简化的功能 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fff8dcb832da82946e10018f4faeadf19cfc862a" translate="yes" xml:space="preserve">
          <source>To acess the record in your callback-module use:</source>
          <target state="translated">要访问回调模块中的记录,请使用。</target>
        </trans-unit>
        <trans-unit id="2e9f9ccb32571596628f903ebec0197042453a6d" translate="yes" xml:space="preserve">
          <source>To achieve authentication and privacy, the client and server perform a TLS/DTLS handshake procedure before transmitting or receiving any data. During the handshake, they agree on a protocol version and cryptographic algorithms, generate shared secrets using public key cryptographies, and optionally authenticate each other with digital certificates.</source>
          <target state="translated">为了实现认证和隐私,客户端和服务器在传输或接收任何数据之前,都要执行TLS/DTLS握手程序。在握手过程中,双方就协议版本和加密算法达成一致,使用公钥加密技术生成共享秘密,并可选择使用数字证书对对方进行认证。</target>
        </trans-unit>
        <trans-unit id="0ec1db4ecbaf3ec0b305eae994234d479d4f46e8" translate="yes" xml:space="preserve">
          <source>To act as a timetrap. The time-out is triggered when the function returns.</source>
          <target state="translated">起到一个定时器的作用。函数返回时触发超时。</target>
        </trans-unit>
        <trans-unit id="589688126179f4b6262587b2faac1c9d33d97234" translate="yes" xml:space="preserve">
          <source>To activate the code coverage support, specify the name of the cover specification file as you start &lt;code&gt;Common Test&lt;/code&gt;. Do this by using flag &lt;code&gt;-cover&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">要激活代码覆盖支持，请在启动 &lt;code&gt;Common Test&lt;/code&gt; 时指定覆盖规格文件的名称。通过将标志 &lt;code&gt;-cover&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 一起使用来执行此操作，例如：</target>
        </trans-unit>
        <trans-unit id="9cae8d843ee99890bf287306d3e1fa2ea6334285" translate="yes" xml:space="preserve">
          <source>To actor, such as receiver of message.</source>
          <target state="translated">对行为人,如信息的接收者。</target>
        </trans-unit>
        <trans-unit id="c17cd393cb68cd745fb32bcdd513d6e91ea1d3f7" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加disk_log处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="b7c67d81ad5962900cef3025ec2c90eb9d886e13" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加disk_log处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="a62dcd7f8a5f7512f140f3f638e7ecdf1954fe0c" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加标准处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="bc71d9dc8116b79c66537800da31d34775d71f00" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">要添加标准处理程序的新实例，请使用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 。处理程序配置参数是一个映射，可以包含《 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 中所述的常规配置参数和特定于处理程序的参数。特定数据使用键 &lt;code&gt;config&lt;/code&gt; 存储在子映射中，并且可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="d25bba7220a4f7baf1911b739eb15c54b0c0b82c" translate="yes" xml:space="preserve">
          <source>To add hipe options, write like this from the Erlang shell:</source>
          <target state="translated">要添加hipe选项,可以在Erlang shell中这样写。</target>
        </trans-unit>
        <trans-unit id="fce45144e65c70b074644a796eba73061cd36112" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt; close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">要一次将一个文件添加到打开的tar文件中，请使用函数 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 。添加完文件后，使用函数 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt; close/1&lt;/a&gt;&lt;/code&gt; 关闭tar文件。</target>
        </trans-unit>
        <trans-unit id="3baa48763297e23c94a7b912bd0879afc5570f44" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">要一次将一个文件添加到打开的tar文件中，请使用函数 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 。添加完文件后，请使用函数 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 关闭tar文件。</target>
        </trans-unit>
        <trans-unit id="a84e38b55e72c3e97104e0980726fd48cb3019f6" translate="yes" xml:space="preserve">
          <source>To add or remove functions to the set of traced functions, use &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;.</source>
          <target state="translated">要将函数添加或删除到跟踪函数集中，请使用 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fda79af0ac4d5d28c0ded42a7d7b009f4b62fd23" translate="yes" xml:space="preserve">
          <source>To add or remove one or more processes to the set of traced processes, use &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将一个或多个进程添加或删除到一组跟踪的进程中，请使用 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97e9dc37875751d49fa3a200c5e6307140fdca4a" translate="yes" xml:space="preserve">
          <source>To allow Emacs to auto-indent the code, each file starts with the following line:</source>
          <target state="translated">为了让Emacs自动缩进代码,每个文件都以下面一行开始。</target>
        </trans-unit>
        <trans-unit id="dd9ff12ed931dadbc8c2436f103539b09520bf39" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; to &lt;strong&gt;request unloading&lt;/strong&gt; to wait for &lt;strong&gt;actual unloading&lt;/strong&gt;, &lt;code&gt;monitor&lt;/code&gt; triggers can be specified in much the same way as when loading. However, as &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this function seldom are interested in more than decrementing the reference counts, monitoring is seldom needed.</source>
          <target state="translated">为了让 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 来&lt;strong&gt;请求卸载&lt;/strong&gt;等待&lt;strong&gt;实际的卸载&lt;/strong&gt;， &lt;code&gt;monitor&lt;/code&gt; 触发器可以在几乎相同的方式指定时加载。但是，由于此功能的 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 对减少参考计数的兴趣很少，因此很少需要监视。</target>
        </trans-unit>
        <trans-unit id="59bb251ccc89a2f6d964901c5abf9140c03fcff3" translate="yes" xml:space="preserve">
          <source>To avoid copying data when a large binary is sent or returned from the driver to an Erlang process, the driver must first allocate the binary and then send it to an Erlang process in some way.</source>
          <target state="translated">为了避免当一个大的二进制文件从驱动程序发送或返回到Erlang进程时复制数据,驱动程序必须首先分配二进制文件,然后以某种方式将其发送给Erlang进程。</target>
        </trans-unit>
        <trans-unit id="2865a7885b23338eb552d918abbacdfb214f7e88" translate="yes" xml:space="preserve">
          <source>To avoid copying the result in each iteration, build the list in reverse order and reverse the list when you are done:</source>
          <target state="translated">为了避免在每次迭代中复制结果,按相反的顺序建立列表,并在完成后将列表反过来。</target>
        </trans-unit>
        <trans-unit id="0e09f8fda1e6fc4cf2056ba424646d85461e4106" translate="yes" xml:space="preserve">
          <source>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify &lt;code&gt;UpFromVsn&lt;/code&gt; and &lt;code&gt;DownToVsn&lt;/code&gt;. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions &lt;code&gt;2.1.x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any number:</source>
          <target state="translated">为了避免重复执行升级指令，允许使用正则表达式指定 &lt;code&gt;UpFromVsn&lt;/code&gt; 和 &lt;code&gt;DownToVsn&lt;/code&gt; 。要被视为正则表达式，必须将版本标识符指定为二进制。例如，以下匹配所有版本 &lt;code&gt;2.1.x&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是任意数字：</target>
        </trans-unit>
        <trans-unit id="f3e4e6304ab6854db5a3171fca0bb16d781ed384" translate="yes" xml:space="preserve">
          <source>To avoid hanging on open ports, use function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">为避免挂在打开的端口上，请改用 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="31d3d102c2bccbc776e3cf95a6211839f76eac95" translate="yes" xml:space="preserve">
          <source>To avoid hard-coding data values related to the test and/or System Under Test (SUT) in the test suites, the data can instead be specified through configuration files or strings that &lt;code&gt;Common Test&lt;/code&gt; reads before the start of a test run. External configuration data makes it possible to change test properties without modifying the test suites using the data. Examples of configuration data follows:</source>
          <target state="translated">为避免硬编码与测试套件中的测试和/或被测系统（SUT）相关的数据值，可以通过在开始测试运行之前通过 &lt;code&gt;Common Test&lt;/code&gt; 读取的配置文件或字符串来指定数据。外部配置数据使更改测试属性成为可能，而无需使用该数据修改测试套件。配置数据示例如下：</target>
        </trans-unit>
        <trans-unit id="dfbb5760a4f99858bb3dbeadd3c934b25eba7307" translate="yes" xml:space="preserve">
          <source>To avoid messing up the indentation, all comments are written as C++ style comments (&lt;code&gt;//&lt;/code&gt;) instead of &lt;code&gt;#&lt;/code&gt;. Note that a comment must start at the beginning of a line.</source>
          <target state="translated">为避免混淆缩进，所有注释均以C ++样式注释（ &lt;code&gt;//&lt;/code&gt; ）而不是 &lt;code&gt;#&lt;/code&gt; 编写。请注意，注释必须在行的开头。</target>
        </trans-unit>
        <trans-unit id="5a0e028a0de585306a96650beddc8214b6be458a" translate="yes" xml:space="preserve">
          <source>To avoid the three copies of the code, we could use only one specific instruction:</source>
          <target state="translated">为了避免三份代码,我们可以只使用一条特定的指令。</target>
        </trans-unit>
        <trans-unit id="ff4064fdc26dd0f01d01190c1a8e9d791a3c3dfd" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">为避免这种情况，我们可以考虑为每个测试启动和停止服务器。因此，我们可以将start和stop操作实现为要从 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 调用的通用函数。（请记住分别测试启动和停止功能。）该配置还可以实现为通用功能，可以与启动功能分组。最后，连接和断开客户端的测试可以分为一个测试用例。结果套件如下所示：</target>
        </trans-unit>
        <trans-unit id="b9201ec7b8336f2387fa27a7eefb8cd01282e065" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">为避免这种情况，我们可以考虑为每个测试启动和停止服务器。因此，我们可以将start和stop操作实现为要从 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 调用的通用函数。 （请记住分别测试启动和停止功能。）该配置还可以实现为通用功能，可能与启动功能分组在一起。最后，连接和断开客户端的测试可以分为一个测试用例。结果套件如下所示：</target>
        </trans-unit>
        <trans-unit id="da22d86c6d5a5e12ab72051b2e07972d39e8f4d0" translate="yes" xml:space="preserve">
          <source>To avoid this, you can format the internal state that gets in the error log and gets returned from &lt;code&gt;sys:get_status/1,2&lt;/code&gt; by implementing function &lt;code&gt;Module:format_status/2&lt;/code&gt;, for example like this:</source>
          <target state="translated">为了避免这种情况，您可以通过实现功能 &lt;code&gt;Module:format_status/2&lt;/code&gt; 来格式化错误日志中的内部状态以及从 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回的内部状态，例如：</target>
        </trans-unit>
        <trans-unit id="5df12af7ca1de496492c0fd73285a97d145fbb83" translate="yes" xml:space="preserve">
          <source>To be able to access a record in a fragmented table, &lt;code&gt;Mnesia&lt;/code&gt; must determine to which fragment the actual record belongs. This is done by module &lt;code&gt;mnesia_frag&lt;/code&gt;, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; callback behavior. It is recommended to read the documentation about the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; to see how &lt;code&gt;mnesia_frag&lt;/code&gt; can be used as a &lt;code&gt;mnesia_access&lt;/code&gt; callback module.</source>
          <target state="translated">为了能够访问碎片表中的记录， &lt;code&gt;Mnesia&lt;/code&gt; 必须确定实际记录属于哪个碎片。这是由模块 &lt;code&gt;mnesia_frag&lt;/code&gt; 完成的，该模块实现了 &lt;code&gt;mnesia_access&lt;/code&gt; 回调行为。建议阅读有关函数 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; 的文档，以了解如何将 &lt;code&gt;mnesia_frag&lt;/code&gt; 用作 &lt;code&gt;mnesia_access&lt;/code&gt; 回调模块。</target>
        </trans-unit>
        <trans-unit id="23318e76150bd1f0abc3ba7a0d5c11d745ade1e5" translate="yes" xml:space="preserve">
          <source>To be able to access another source than &lt;code&gt;running&lt;/code&gt;, the server must advertise &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">为了能够访问 &lt;code&gt;running&lt;/code&gt; 以外的其他资源，服务器必须发布 &lt;code&gt;:candidate&lt;/code&gt; 和/或 &lt;code&gt;:startup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b51f87825f77244a25cc2b4cb931c55829d08561" translate="yes" xml:space="preserve">
          <source>To be able to build the 64bit VM, you will also need the 64bit MinGW compiler from:</source>
          <target state="translated">为了能够构建64位的虚拟机,你还需要64位的MinGW编译器,从。</target>
        </trans-unit>
        <trans-unit id="26291c0ee8be34dfdaf3cc8ddf503e49e01d4215" translate="yes" xml:space="preserve">
          <source>To be able to handle that the peer has done a shutdown on the write side, option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful.</source>
          <target state="translated">为了能够处理对等方已在写端执行关闭操作，选项 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="e5203ca51ac51dc3846f4da1bcecefb73078a29b" translate="yes" xml:space="preserve">
          <source>To be able to match on events, the event handler module must include the header file &lt;code&gt;ct_event.hrl&lt;/code&gt;. An event is a record with the following definition:</source>
          <target state="translated">为了能够匹配事件，事件处理程序模块必须包含头文件 &lt;code&gt;ct_event.hrl&lt;/code&gt; 。事件是具有以下定义的记录：</target>
        </trans-unit>
        <trans-unit id="485420cfd5dcbb3ebc3984f14efff913d6cf6cf5" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt; erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">为了能够对Erlang系统时间的变化做出反应，您必须能够检测到它发生了。当更改当前时间偏移时，将发生Erlang系统时间的更改。因此，我们引入了使用 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt; erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 监视时间偏移的可能性。更改时间偏移量后，将以以下格式向监视时间偏移量的进程发送消息：</target>
        </trans-unit>
        <trans-unit id="e3749ffc8118407236ba6c1778f7ad9201b5e31f" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">为了能够对Erlang系统时间的变化做出反应，您必须能够检测到它发生了。当前时间偏移发生更改时，Erlang系统时间就会发生更改。因此，我们引入了使用 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 监视时间偏移的可能性。更改时间偏移后，将以以下格式向监视时间偏移的进程发送消息：</target>
        </trans-unit>
        <trans-unit id="247dec3e8d99aa407189a0694139d1d0d984205d" translate="yes" xml:space="preserve">
          <source>To be able to specify the different variants of version 3, the encoding config option &lt;code&gt;{version3, version3()}&lt;/code&gt;&lt;strong&gt;still&lt;/strong&gt; exists. This option, if present, has to be &lt;strong&gt;first&lt;/strong&gt; in the encoding config list. Version 1 and 2 codec's ignore this option, if found.</source>
          <target state="translated">为了能够指定版本3的不同变体，编码配置选项 &lt;code&gt;{version3, version3()}&lt;/code&gt; &lt;strong&gt;仍然&lt;/strong&gt;存在。如果存在此选项，则必须在编码配置列表中排在&lt;strong&gt;第一位&lt;/strong&gt;。如果找到版本1和2编解码器，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="4db2f48a1319253c8231fa7c3d7cafe6f17c3bfc" translate="yes" xml:space="preserve">
          <source>To be backward compatible, &lt;code&gt;erlang:now/0&lt;/code&gt; remains &quot;as is&quot;, but &lt;strong&gt;you are strongly discouraged from using it&lt;/strong&gt;. Many use cases of &lt;code&gt;erlang:now/0&lt;/code&gt; prevents you from using the new &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, which is an important part of this new time functionality improvement.</source>
          <target state="translated">为了向后兼容， &lt;code&gt;erlang:now/0&lt;/code&gt; 保持&amp;ldquo;原样&amp;rdquo;，但是&lt;strong&gt;强烈建议您不要使用它&lt;/strong&gt;。 &lt;code&gt;erlang:now/0&lt;/code&gt; 的许多使用情况使您无法使用新的 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; ，这是此新的时间功能改进的重要组成部分。</target>
        </trans-unit>
        <trans-unit id="329020006d74005fa227c858badad448a18d5417" translate="yes" xml:space="preserve">
          <source>To be explicit, this does not work:</source>
          <target state="translated">明确地说,这是不可行的。</target>
        </trans-unit>
        <trans-unit id="921be93011160f60c5394e46977ec4ffed9f386b" translate="yes" xml:space="preserve">
          <source>To be exploited by documentation tools, such as EDoc, for generating program documentation of various forms</source>
          <target state="translated">被EDoc等文档工具利用,生成各种形式的程序文档。</target>
        </trans-unit>
        <trans-unit id="f48ee1f9c7b05fd181e829e8e9aa1a1a445ae544" translate="yes" xml:space="preserve">
          <source>To be made the default version, the newly installed release must be made &lt;strong&gt;permanent&lt;/strong&gt;, which means the previous version becomes &lt;strong&gt;old&lt;/strong&gt;:</source>
          <target state="translated">要成为默认版本，必须使新安装的发行版成为&lt;strong&gt;永久&lt;/strong&gt;版本，这意味着以前的版本已&lt;strong&gt;旧&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="e74a300fec94193e2bb8d4e9a20ec23ef6d08170" translate="yes" xml:space="preserve">
          <source>To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f188872bc4af8764a7f9a37cf3e8af8d364819f6" translate="yes" xml:space="preserve">
          <source>To be used in &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;related functions&lt;/code&gt;.</source>
          <target state="translated">用于 &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; 及 &lt;code&gt;related functions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74a03c9a55622acfb1073ad485959792425762b4" translate="yes" xml:space="preserve">
          <source>To be used with:</source>
          <target state="translated">将与:</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">待写。</target>
        </trans-unit>
        <trans-unit id="478342ff97001f76e051ff05457f998d192f9c98" translate="yes" xml:space="preserve">
          <source>To bring up all functions of the module in the listbox, click the &lt;strong&gt;OK&lt;/strong&gt; button (or press the &lt;strong&gt;Return&lt;/strong&gt; or &lt;strong&gt;Tab&lt;/strong&gt; key) when a module name has been specified,.</source>
          <target state="translated">要在列表框中显示模块的所有功能，请在指定模块名称后单击&amp;ldquo; &lt;strong&gt;确定&amp;rdquo;&lt;/strong&gt;按钮（或按&lt;strong&gt;Return&lt;/strong&gt;键或&lt;strong&gt;Tab&lt;/strong&gt;键）。</target>
        </trans-unit>
        <trans-unit id="eef5c50b74cfb025ae830e60721c49d26fd50ea9" translate="yes" xml:space="preserve">
          <source>To browse the file hierarchy and interpret the appropriate modules, either select a module name and click &lt;strong&gt;Choose&lt;/strong&gt; (or press carriage return), or double-click the module name. Interpreted modules have the type &lt;code&gt;erl src&lt;/code&gt;.</source>
          <target state="translated">要浏览文件层次结构并解释适当的模块，请选择一个模块名称，然后单击&lt;strong&gt;&amp;ldquo;选择&amp;rdquo;&lt;/strong&gt;（或按回车键），或双击该模块名称。解释的模块的类型为 &lt;code&gt;erl src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28e906186648188c00413e57f57d46fc8b55c323" translate="yes" xml:space="preserve">
          <source>To build the map &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">要构建地图 &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt; ，可以进行以下调用。</target>
        </trans-unit>
        <trans-unit id="cf559a27d31b4ba64718074dda19ef0d468cf4ad" translate="yes" xml:space="preserve">
          <source>To build the tuple &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">要建立元组 &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt; ，可以进行以下调用。</target>
        </trans-unit>
        <trans-unit id="94328137f8adf38a2d5782ddb946585047133b14" translate="yes" xml:space="preserve">
          <source>To call an arbitrary function from the release handler, the following instruction is used:</source>
          <target state="translated">要从释放处理程序中调用一个任意函数,需要使用以下指令。</target>
        </trans-unit>
        <trans-unit id="648e7cf5c6adf0a3796e8cd7e102571a81de2b0f" translate="yes" xml:space="preserve">
          <source>To call the parser generator, use the following command:</source>
          <target state="translated">要调用解析器生成器,请使用以下命令。</target>
        </trans-unit>
        <trans-unit id="d0f9713393429e6796bf7c377bd68256251a30fd" translate="yes" xml:space="preserve">
          <source>To catch the exception, use for example:</source>
          <target state="translated">要捕获异常,请使用例如。</target>
        </trans-unit>
        <trans-unit id="754fcce3ba1a05a254eee986bb434f3d90945ecd" translate="yes" xml:space="preserve">
          <source>To change from old code to current code, a process must make a fully qualified function call.</source>
          <target state="translated">要想从旧代码变为当前代码,一个进程必须进行完全限定的函数调用。</target>
        </trans-unit>
        <trans-unit id="d43cb0d79f1f2a05084529861044cff6d89a0ac1" translate="yes" xml:space="preserve">
          <source>To change that we would need to insert action &lt;code&gt;hibernate&lt;/code&gt; in more places. For example, the state-independent &lt;code&gt;set_lock_button&lt;/code&gt; operation would have to use &lt;code&gt;hibernate&lt;/code&gt; but only in the &lt;code&gt;{open,_}&lt;/code&gt; state, which would clutter the code.</source>
          <target state="translated">要进行更改，我们需要在更多地方插入 &lt;code&gt;hibernate&lt;/code&gt; 动作。例如，与状态无关的 &lt;code&gt;set_lock_button&lt;/code&gt; 操作必须使用 &lt;code&gt;hibernate&lt;/code&gt; 但只能在 &lt;code&gt;{open,_}&lt;/code&gt; 状态下使用，这会使代码混乱。</target>
        </trans-unit>
        <trans-unit id="8177a3463ef365dc1edec90cb008147223f97121" translate="yes" xml:space="preserve">
          <source>To change the SYSDIR, see the &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">要更改SYSDIR，请参见 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="e21c4ee2840bdc59e21153e6a7bd3fa7292bfdf0" translate="yes" xml:space="preserve">
          <source>To change the USERDIR, see the &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; option</source>
          <target state="translated">要更改USERDIR，请参见 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="6d2291b5accb98f7fdfc37910802e511d2e8b381" translate="yes" xml:space="preserve">
          <source>To change the above program to one that works out the minimum value of the element in a list, you only need to write &amp;lt; instead of &amp;gt;. (But it would be wise to change the name of the function to &lt;code&gt;list_min&lt;/code&gt;.)</source>
          <target state="translated">要将上述程序更改为可以计算列表中元素最小值的程序，只需编写&amp;lt;而不是&amp;gt;。（但是将函数名称更改为 &lt;code&gt;list_min&lt;/code&gt; 是明智的。）</target>
        </trans-unit>
        <trans-unit id="df565b9f1ce8851c5511996238157f3f30542cab" translate="yes" xml:space="preserve">
          <source>To change the algorithm list, there are two options which can be used in &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;. The options could of course be used in all other functions that initiates connections.</source>
          <target state="translated">要更改算法列表，可以在 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; 使用两个选项：connect / 2,3,4和 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 。这些选项当然可以用于启动连接的所有其他功能。</target>
        </trans-unit>
        <trans-unit id="20b354ae68e6f4458aeb56c8ff9e5b341166ae57" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config(HandlerId, level, Level) &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改处理程序的日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config(HandlerId, level, Level) &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="645ec6265eaa80d65a779b7caa5860ddbfdebc42" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改处理程序的日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd786bf281877aa85271503f3c21215f44679fd5" translate="yes" xml:space="preserve">
          <source>To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this:</source>
          <target state="translated">为了改变模式,使其匹配所有的手写体字符串,而不仅仅是奇数字符的字符串,我们很想把模式改成这样。</target>
        </trans-unit>
        <trans-unit id="a6051fffc9d710c7ebcc3e122883720f210d4ada" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt; set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改Logger的主日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt; set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9656eb62d534763e64141fc6d3d1d35b0b442bc" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要更改Logger的主日志级别，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="866ca5de7c21c0cf7da2438015592c26ee8d81d7" translate="yes" xml:space="preserve">
          <source>To change the rules that restrict the use of an asset, the user only needs write access to the directory where the asset is.</source>
          <target state="translated">要改变限制资产使用的规则,用户只需要对资产所在的目录进行写访问。</target>
        </trans-unit>
        <trans-unit id="f5621caa72f0f06f014de0ebbc8d407830e5d0da" translate="yes" xml:space="preserve">
          <source>To check if your code is executed within a transaction, use the function &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt;. It returns &lt;code&gt;true&lt;/code&gt; when called inside a transaction context, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">要检查代码是否在事务中执行，请使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt; 。在事务上下文中调用时返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b2516b6faafd214fb55f7400a6a5d85502f13d2" translate="yes" xml:space="preserve">
          <source>To check whether a term is a fun, use the test &lt;code&gt;is_function/1&lt;/code&gt; in a guard.</source>
          <target state="translated">要检查术语是否有趣，请在防护中使用测试 &lt;code&gt;is_function/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eaab6c693a13cade1df8955eec714a449d7d24" translate="yes" xml:space="preserve">
          <source>To choose the name for the generated module, for example, because you need to compile the same specs for different encoding rules.</source>
          <target state="translated">要为生成的模块选择名称,例如,因为你需要为不同的编码规则编译相同的规范。</target>
        </trans-unit>
        <trans-unit id="77676158a92effec6457676e808555ae1fd71986" translate="yes" xml:space="preserve">
          <source>To close the connection, call the function &lt;code&gt;&lt;a href=&quot;ssh#close-1&quot;&gt;ssh:close(ConnectionRef)&lt;/a&gt;&lt;/code&gt;. As an alternative, set the option &lt;code&gt;&lt;a href=&quot;ssh#type-max_idle_time_common_option&quot;&gt;{idle_time, 1}&lt;/a&gt;&lt;/code&gt; when opening the connection. This will cause the connection to be closed automaticaly when there are no channels open for the specified time period, in this case 1 ms.</source>
          <target state="translated">要关闭连接，请调用函数 &lt;code&gt;&lt;a href=&quot;ssh#close-1&quot;&gt;ssh:close(ConnectionRef)&lt;/a&gt;&lt;/code&gt; 。或者，在打开连接时设置选项 &lt;code&gt;&lt;a href=&quot;ssh#type-max_idle_time_common_option&quot;&gt;{idle_time, 1}&lt;/a&gt;&lt;/code&gt; 。如果在指定的时间段内没有通道打开（在这种情况下为1 ms），这将导致连接自动关闭。</target>
        </trans-unit>
        <trans-unit id="1427a1da5e3a256c344db44b11dc0bba14915bf8" translate="yes" xml:space="preserve">
          <source>To close the window, click &lt;strong&gt;Done&lt;/strong&gt;.</source>
          <target state="translated">要关闭窗口，请点击&lt;strong&gt;完成&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8529722ba2eb984fe7acaf5239aaeee899afd795" translate="yes" xml:space="preserve">
          <source>To collect the channel messages in a program, use &lt;code&gt;receive...end&lt;/code&gt; instead of &lt;code&gt;flush/1&lt;/code&gt;:</source>
          <target state="translated">要在程序中收集频道消息，请使用 &lt;code&gt;receive...end&lt;/code&gt; 而不是 &lt;code&gt;flush/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b49e3e39a1c8fd0e9ebc5aae6e7cbc8ac29bcce" translate="yes" xml:space="preserve">
          <source>To communicate through Telnet to the host specified by &lt;code&gt;HostNameOrIpAddress&lt;/code&gt;, use the interface functions in &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;open(Name)&lt;/code&gt; and &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt;.</source>
          <target state="translated">要通过Telnet与 &lt;code&gt;HostNameOrIpAddress&lt;/code&gt; 指定的主机进行通信，请使用 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 中的接口函数，例如 &lt;code&gt;open(Name)&lt;/code&gt; 和 &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cc63914adafb29982dfe6a5968660a48f49ce2e" translate="yes" xml:space="preserve">
          <source>To compare styles, here follows the same example using &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt;, or rather the code to replace after function &lt;code&gt;init/1&lt;/code&gt; of the &lt;code&gt;pushbutton.erl&lt;/code&gt; example file above:</source>
          <target state="translated">为了比较样式，下面是使用 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 的相同示例，或者是上面的 &lt;code&gt;pushbutton.erl&lt;/code&gt; 示例文件的 &lt;code&gt;init/1&lt;/code&gt; 函数之后要替换的代码：</target>
        </trans-unit>
        <trans-unit id="f9bdaaae36af33eb796c91b4364a72c96ddef2b5" translate="yes" xml:space="preserve">
          <source>To compare the importance of the printout to a specific verbosity level.</source>
          <target state="translated">要将打印输出的重要性与特定的动词级别进行比较。</target>
        </trans-unit>
        <trans-unit id="ce902aa7e185b10f95db9c5e6db8ef30884a21be" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;ei.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">编译代码，请确保您的C编译器知道在哪里可以找到 &lt;code&gt;ei.h&lt;/code&gt; 通过指定适当的 &lt;code&gt;-I&lt;/code&gt; 命令行参数，或将其添加到 &lt;code&gt;CFLAGS&lt;/code&gt; 在你的定义 &lt;code&gt;Makefile&lt;/code&gt; 文件。此路径的正确值为 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="54ed5bb067e17e1fa5d9fb9384ef7e59e200b2f4" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;erl_interface.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">要编译代码，请在命令行上指定适当的 &lt;code&gt;-I&lt;/code&gt; 参数，或者将其添加到 &lt;code&gt;Makefile&lt;/code&gt; 中的 &lt;code&gt;CFLAGS&lt;/code&gt; 定义中，以确保C编译器知道在哪里可以找到 &lt;code&gt;erl_interface.h&lt;/code&gt; 。此路径的正确值为 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="99dbaa9ef513face3ab175774b7916127ae86697" translate="yes" xml:space="preserve">
          <source>To complete the I/O server, we only need to read and write the table in an appropriate way:</source>
          <target state="translated">为了完成I/O服务器,我们只需要用适当的方式对表进行读写即可。</target>
        </trans-unit>
        <trans-unit id="ef56703b3c226b895e39bdf18576e702cab5ae0b" translate="yes" xml:space="preserve">
          <source>To configure the Logger backend, use &lt;code&gt;Kernel configuration parameters&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; in the Logger API.</source>
          <target state="translated">要配置Logger后端，请使用Logger API中的 &lt;code&gt;Kernel configuration parameters&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8abc4316358324e879aa4fb86c41abefacbe121" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt;, which stores information, such as the hostname, node name, and IP address for later use:</source>
          <target state="translated">要连接到分布式Erlang节点，必须首先使用 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt; 初始化连接例程，该例程存储诸如主机名，节点名和IP地址之类的信息，以供以后使用：</target>
        </trans-unit>
        <trans-unit id="814ff103d76eb9252c18ebc95545cfae2963c042" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with one of the &lt;code&gt;&lt;a href=&quot;ei_connect#ei_connect_init&quot;&gt; ei_connect_init_*&lt;/a&gt;&lt;/code&gt; functions, which stores information, such as the hostname, and node name for later use:</source>
          <target state="translated">要连接到分布式Erlang节点，必须首先使用 &lt;code&gt;&lt;a href=&quot;ei_connect#ei_connect_init&quot;&gt; ei_connect_init_*&lt;/a&gt;&lt;/code&gt; 函数之一初始化连接例程，该函数存储诸如主机名和节点名之类的信息以供以后使用：</target>
        </trans-unit>
        <trans-unit id="da53f52f9b6e989d7d98084c289e93041ec03817" translate="yes" xml:space="preserve">
          <source>To constrain the match, it is needed to replace some of the &lt;code&gt;'_'&lt;/code&gt; elements. The code for matching out all female employees looks as follows:</source>
          <target state="translated">为了限制匹配，需要替换某些 &lt;code&gt;'_'&lt;/code&gt; 元素。匹配所有女性雇员的代码如下：</target>
        </trans-unit>
        <trans-unit id="db8fca00f1d4d2a5725d8baaafde57fb1f7e09a3" translate="yes" xml:space="preserve">
          <source>To convert an error term returned from one of the functions above to a readable message, use function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将以上函数之一返回的错误项转换为可读消息，请使用function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="746ad6da742f525d196ec4f846fc54c5b8d6665f" translate="yes" xml:space="preserve">
          <source>To copy text to the clipboard, use &lt;code&gt;Ctrl-C&lt;/code&gt;.</source>
          <target state="translated">要将文本复制到剪贴板，请使用 &lt;code&gt;Ctrl-C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f0c639143cf961891408084facf2efc28d6f4b6" translate="yes" xml:space="preserve">
          <source>To copy the selected text to the clipboard, either use &lt;code&gt;Ctrl-C&lt;/code&gt;, use the menu, or press the copy button in the toolbar.</source>
          <target state="translated">要将选定的文本复制到剪贴板，请使用 &lt;code&gt;Ctrl-C&lt;/code&gt; ，使用菜单或按工具栏中的复制按钮。</target>
        </trans-unit>
        <trans-unit id="d0e2976d5ba6748c5f943edab22facd4c396be64" translate="yes" xml:space="preserve">
          <source>To counter the &quot;bad cluster&quot; problem and also ease the contention, the search will now always start by first looking at the allocators &lt;strong&gt;own&lt;/strong&gt; carriers. That is, carriers that were initially created by the allocator itself and later had been abandoned to the pool. If none of our own abandoned carrier would do, then the search continues into the pool, as before, to look for carriers created by other allocators. However, if we have at least one abandoned carrier of our own that could not satisfy the request, we can use that as entry point into the pool.</source>
          <target state="translated">为了解决&amp;ldquo;坏簇&amp;rdquo;问题并缓解争用，现在总是首先查看分配者&lt;strong&gt;自己的&lt;/strong&gt;运营商来开始搜索。也就是说，最初由分配器本身创建并随后被丢弃到池中的载体。如果我们自己的废弃运营商都不愿意做，那么搜索将像以前一样继续进入池中，以查找由其他分配器创建的运营商。但是，如果我们自己有至少一个废弃的承运人无法满足请求，则可以将其用作池的入口点。</target>
        </trans-unit>
        <trans-unit id="b54150ad2122f90546c148d80de8d120283f00f8" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt; erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">要从任意iolist创建二进制列表，请使用 &lt;code&gt; erlang:iolist_to_iovec/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2f36469b72d764889b8bc2c05eb18e7c2e00c94" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">要从任意iolist创建二进制列表，请使用 &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b64ef8fa41b5eb9b9fbad8912a240355ac0b560d" translate="yes" xml:space="preserve">
          <source>To create a port:</source>
          <target state="translated">要创建一个端口。</target>
        </trans-unit>
        <trans-unit id="c1b10e93b99ca718329a25a25398d8dc9f5d3821" translate="yes" xml:space="preserve">
          <source>To create the Mnesia tables, we use two records defined in &lt;code&gt;mod_auth.hrl&lt;/code&gt;, so that file must be included. &lt;code&gt;first_start/0&lt;/code&gt; creates a schema that specifies on which nodes the database is to reside. Then it starts Mnesia and creates the tables. The first argument is the name of the tables, the second argument is a list of options of how to create the table, see &lt;code&gt;mnesia(3)&lt;/code&gt;, documentation for more information. As the implementation of the &lt;code&gt;mod_auth_mnesia&lt;/code&gt; saves one row for each user, the type must be &lt;code&gt;bag&lt;/code&gt;. When the schema and the tables are created, function &lt;code&gt;mnesia:start/0&lt;/code&gt; is used to start Mnesia and waits for the tables to be loaded. Mnesia uses the directory specified as &lt;code&gt;mnesia_dir&lt;/code&gt; at startup if specified, otherwise Mnesia uses the current directory. For security reasons, ensure that the Mnesia tables are stored outside the document tree of the HTTP server. If they are placed in the directory which it protects, clients can download the tables. Only the Dets and Mnesia storage methods allow writing of dynamic user data to disk. &lt;code&gt;plain&lt;/code&gt; is a read only method.</source>
          <target state="translated">要创建Mnesia表，我们使用 &lt;code&gt;mod_auth.hrl&lt;/code&gt; 中定义的两条记录，因此必须包括该文件。 &lt;code&gt;first_start/0&lt;/code&gt; 创建一个模式，该模式指定数据库要驻留在哪些节点上。然后，它启动Mnesia并创建表。第一个参数是表的名称，第二个参数是如何创建表的选项的列表，有关更多信息，请参见 &lt;code&gt;mnesia(3)&lt;/code&gt; 文档。由于 &lt;code&gt;mod_auth_mnesia&lt;/code&gt; 的实现为每个用户节省了一行，因此类型必须为 &lt;code&gt;bag&lt;/code&gt; 。创建模式和表后，函数 &lt;code&gt;mnesia:start/0&lt;/code&gt; 用于启动Mnesia并等待表被加载。 Mnesia使用指定为 &lt;code&gt;mnesia_dir&lt;/code&gt; 如果指定了启动时的mnesia_dir，否则Mnesia使用当前目录。出于安全原因，请确保Mnesia表存储在HTTP服务器的文档树之外。如果将它们放置在受保护的目录中，则客户端可以下载表。仅Dets和Mnesia存储方法允许将动态用户数据写入磁盘。 &lt;code&gt;plain&lt;/code&gt; 是只读方法。</target>
        </trans-unit>
        <trans-unit id="7026fff802f7dac35b82f566aac0d4c80c766528" translate="yes" xml:space="preserve">
          <source>To create zip archives, use function &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;create/2,3&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要创建zip档案，请使用功能 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;create/2,3&lt;/code&gt; 来使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="ebc5fc7bc8bd769bb1bb61a99c206e8739bf277b" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt; Module:init(Args) &lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is called. This function behaves like a &lt;strong&gt;state callback&lt;/strong&gt; function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt; start/3,4 &lt;/code&gt; or &lt;code&gt; start_link/3,4 &lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">为了确定第一个状态，在调用任何 &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 之前，先调用 &lt;code&gt; Module:init(Args) &lt;/code&gt; 回调函数。这个函数的行为就像一个&lt;strong&gt;状态回调&lt;/strong&gt;函数，但得到它的唯一参数 &lt;code&gt;Args&lt;/code&gt; 从 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt; start/3,4 &lt;/code&gt; 或 &lt;code&gt; start_link/3,4 &lt;/code&gt; 功能，并返回 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 或 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 。如果您使用此功能中的 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 动作，则该动作将被忽略，因为没有要推迟的事件。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96ba6751b435aa130ce8000c31fb7a59eb14a8a4" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt;Module:init(Args)&lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; is called. This function behaves like an event handler function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">为了确定第一个状态，在调用任何 &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; 程序之前，先调用 &lt;code&gt;Module:init(Args)&lt;/code&gt; 回调函数。该函数的行为类似于事件处理程序函数，但是从 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;start/3,4&lt;/code&gt; 或 &lt;code&gt;start_link/3,4&lt;/code&gt; 函数获取唯一的参数 &lt;code&gt;Args&lt;/code&gt; ，并返回 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 或 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 。如果您使用此功能中的 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 动作，则该动作将被忽略，因为没有要推迟的事件。</target>
        </trans-unit>
        <trans-unit id="51c111740de9350080c7972bf37d34610910e708" translate="yes" xml:space="preserve">
          <source>To define a release, create a &lt;strong&gt;release resource file&lt;/strong&gt;, or in short a &lt;code&gt;.rel&lt;/code&gt; file. In the file, specify the name and version of the release, which ERTS version it is based on, and which applications it consists of:</source>
          <target state="translated">要定义发行版，请创建&lt;strong&gt;发行版资源文件&lt;/strong&gt;或简称为 &lt;code&gt;.rel&lt;/code&gt; 文件。在文件中，指定发行版的名称和版本，发行版所基于的ERTS版本以及组成的应用程序：</target>
        </trans-unit>
        <trans-unit id="7dcb9b11962f5e7cb3516154fef97049f24faad8" translate="yes" xml:space="preserve">
          <source>To define an application, an &lt;strong&gt;application specification&lt;/strong&gt; is created, which is put in an &lt;strong&gt;application resource file&lt;/strong&gt;, or in short an &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">要定义应用程序，将创建一个&lt;strong&gt;应用程序规范&lt;/strong&gt;，该&lt;strong&gt;规范&lt;/strong&gt;将放置在&lt;strong&gt;应用程序资源文件中&lt;/strong&gt;，或简称为 &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="54b3619697604e99e71233bb1079a1597fb1c5a2" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the current version and previous versions of an application, an &lt;strong&gt;application upgrade file&lt;/strong&gt;, or in short an &lt;code&gt;.appup&lt;/code&gt; file is created. The file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name:</source>
          <target state="translated">要定义如何在应用程序的当前版本和以前的版本之间升级/降级，将创建一个&lt;strong&gt;应用程序升级文件&lt;/strong&gt;，或简称为 &lt;code&gt;.appup&lt;/code&gt; 文件。该文件称为 &lt;code&gt;Application.appup&lt;/code&gt; ，其中 &lt;code&gt;Application&lt;/code&gt; 是应用程序名称：</target>
        </trans-unit>
        <trans-unit id="f1125003b8abae474fb015968f66692981cd19a0" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the new version and previous versions of a release, a &lt;strong&gt;release upgrade file&lt;/strong&gt;, or in short &lt;code&gt;relup&lt;/code&gt; file, is to be created.</source>
          <target state="translated">为了定义如何在发行版的新版本和先前版本之间升级/降级，将创建发行&lt;strong&gt;版升级文件&lt;/strong&gt;或简称 &lt;code&gt;relup&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1e010624d4e818c00508b53d915d93db2cfd9d3a" translate="yes" xml:space="preserve">
          <source>To detect that the server is not the intended one, the client must additionaly perform a</source>
          <target state="translated">为了检测到服务器不是预定的服务器,客户端必须额外执行一个</target>
        </trans-unit>
        <trans-unit id="29f1578f8a4341b69585b80b12a72f76a9569382" translate="yes" xml:space="preserve">
          <source>To dig deeper into the general results, or the result of a specific test case, the operator can do so by following the links in the HTML presentation and read the major or minor log files. The &quot;all_runs.html&quot; page is a good starting point. It is located in &lt;code&gt;logdir&lt;/code&gt; and contains a link to each test run, including a quick overview (with date and time, node name, number of tests, test names, and test result totals).</source>
          <target state="translated">为了更深入地了解常规结果或特定测试用例的结果，操作员可以按照HTML演示文稿中的链接进行操作，并读取主要或次要日志文件。&amp;ldquo; all_runs.html&amp;rdquo;页面是一个很好的起点。它位于 &lt;code&gt;logdir&lt;/code&gt; 中,并包含每个测试运行的链接，包括快速概述（日期和时间，节点名称，测试数量，测试名称和测试结果总计）。</target>
        </trans-unit>
        <trans-unit id="a47ea787070856206ef8e8c44cdc817088453a80" translate="yes" xml:space="preserve">
          <source>To disable all electric commands set the variable &lt;code&gt;erlang-electric-commands&lt;/code&gt; to the empty list. In short, place the following line in your &lt;code&gt;.emacs&lt;/code&gt;-file:</source>
          <target state="translated">要禁用所有电子命令，请将变量 &lt;code&gt;erlang-electric-commands&lt;/code&gt; 设置为空列表。简而言之，将以下行放在 &lt;code&gt;.emacs&lt;/code&gt; -file中：</target>
        </trans-unit>
        <trans-unit id="2719f4e1a729a417c71b36c21728b88e49361422" translate="yes" xml:space="preserve">
          <source>To disable certain modes, do the following:</source>
          <target state="translated">要禁用某些模式,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="7d843b983a258077823d6e0bf23f5a51462fef79" translate="yes" xml:space="preserve">
          <source>To disable the automatic compilation feature, use flag &lt;code&gt;-no_auto_compile&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, or option &lt;code&gt;{auto_compile,false}&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. With automatic compilation disabled, the user is responsible for compiling the test suite modules (and any help modules) before the test run. If the modules cannot be loaded from the local file system during startup of &lt;code&gt;Common Test&lt;/code&gt;, the user must preload the modules before starting the test. &lt;code&gt;Common Test&lt;/code&gt; only verifies that the specified test suites exist (that is, that they are, or can be, loaded). This is useful, for example, if the test suites are transferred and loaded as binaries through RPC from a remote node.</source>
          <target state="translated">要禁用自动编译功能， &lt;code&gt;-no_auto_compile&lt;/code&gt; 对 &lt;code&gt;ct_run&lt;/code&gt; 使用标志-no_auto_compile，对 &lt;code&gt;ct:run_test/1&lt;/code&gt; 使用选项 &lt;code&gt;{auto_compile,false}&lt;/code&gt; 。在禁用自动编译的情况下，用户负责在测试运行之前编译测试套件模块（以及所有帮助模块）。如果在 &lt;code&gt;Common Test&lt;/code&gt; 启动期间无法从本地文件系统加载模块，则用户必须在启动测试之前预加载模块。 &lt;code&gt;Common Test&lt;/code&gt; 仅验证指定的测试套件是否存在（即它们已经或可以被加载）。例如，如果测试套件是通过RPC从远程节点传输并作为二进制文件加载的，则这很有用。</target>
        </trans-unit>
        <trans-unit id="ceb4119cc35a0a33e9fed4f8110e9358a175961e" translate="yes" xml:space="preserve">
          <source>To disconnect from the shell without exiting the Erlang system, type &lt;code&gt;Ctrl-D&lt;/code&gt;.</source>
          <target state="translated">要在不退出Erlang系统的情况下与外壳断开连接，请输入 &lt;code&gt;Ctrl-D&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b548ad5d8837c627142ce75e81cde50b52ba7141" translate="yes" xml:space="preserve">
          <source>To distinguish trace logs produced with this tool from other logs, option &lt;code&gt;file&lt;/code&gt; is used in &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;. The logs are therefore fetched to a directory named &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt;</source>
          <target state="translated">为了区分使用此工具生成的跟踪日志和其他日志，在 &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 中使用了选项 &lt;code&gt;file&lt;/code&gt; 。因此，将日志提取到名为 &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt; 的目录中</target>
        </trans-unit>
        <trans-unit id="896795105dbda22e2604c15284900f9f7aafa1c2" translate="yes" xml:space="preserve">
          <source>To do the first search among own carriers, every allocator instance has a &lt;code&gt;pooled_tree&lt;/code&gt; of carriers. This tree is only accessed by the allocator itself and can only contain its own carriers. When a carrier is abandoned and put in the pool, it is also inserted into &lt;code&gt;pooled_tree&lt;/code&gt;. This is either done direct, if the carrier was already employed by its owner, or by first passing it back to the owner via the delayed dealloc queue.</source>
          <target state="translated">为了在自己的载波之间进行第一次搜索，每个分配器实例都有一个 &lt;code&gt;pooled_tree&lt;/code&gt; 载波。该树只能由分配器本身访问，并且只能包含其自己的载体。当载体被抛弃并放入池中时，它也被插入 &lt;code&gt;pooled_tree&lt;/code&gt; 中。如果承运人已经被承运人雇用，则可以直接完成此操作，也可以先通过延迟的dealloc队列将其传回给承运人。</target>
        </trans-unit>
        <trans-unit id="3e40468ed8befabe466118a08bf6fc28c0f6c6eb" translate="yes" xml:space="preserve">
          <source>To do this, create a &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; that defines which applications are included in the release.</source>
          <target state="translated">为此，请创建一个 &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; ，该文件定义发行中包括哪些应用程序。</target>
        </trans-unit>
        <trans-unit id="71c169e0b7cdb28847a1d261315129b8416e6027" translate="yes" xml:space="preserve">
          <source>To do this, create an &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt;, and describe how the application is to be started and stopped.</source>
          <target state="translated">为此，创建一个 &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt; ，并描述如何启动和停止该应用程序。</target>
        </trans-unit>
        <trans-unit id="24f741a20f0106dade011b163f1322e4510ccc13" translate="yes" xml:space="preserve">
          <source>To document function interfaces</source>
          <target state="translated">要记录功能接口</target>
        </trans-unit>
        <trans-unit id="4e2effe3d108d7692e70e0242432ef9323088c3f" translate="yes" xml:space="preserve">
          <source>To downgrade from &lt;code&gt;Vsn&lt;/code&gt; to &lt;code&gt;FromVsn&lt;/code&gt;, &lt;code&gt;install_release&lt;/code&gt; must be called again:</source>
          <target state="translated">要将 &lt;code&gt;Vsn&lt;/code&gt; 降级为 &lt;code&gt;FromVsn&lt;/code&gt; ，必须再次调用 &lt;code&gt;install_release&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="66dd305cb60ccb1d581b1532183a42d9550cf7c0" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;cmac&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt;. Also check that the name in the</source>
          <target state="translated">要动态检查可用性，请检查 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 返回的列表中是否存在名称 &lt;code&gt;cmac&lt;/code&gt; 。还要检查名称是否在</target>
        </trans-unit>
        <trans-unit id="b6aee92d122edd91f99a63916628811ec1c754e0" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;hmac&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; and that the hash name is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(hashs)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要动态查询，检查该名称 &lt;code&gt;hmac&lt;/code&gt; 出现在返回的列表 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 和散列名字出现在返回的列表 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(hashs)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96b27582a0af681e39e67a0fb66383f1af501a73" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;poly1305&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要动态检查可用性，请检查 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 返回的列表中是否存在名称 &lt;code&gt;poly1305&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bca713a31b268396f2f08d09009aa103834e0eb" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name in the</source>
          <target state="translated">要动态检查可用性,请检查在</target>
        </trans-unit>
        <trans-unit id="8bd074941949eff62a2f10ace8d8745188c15d3a" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the wanted name in the</source>
          <target state="translated">要动态地检查可用性,检查在</target>
        </trans-unit>
        <trans-unit id="c857b1910cd745feb809b3e36bb979959ad34032" translate="yes" xml:space="preserve">
          <source>To each module using records, a pseudo function is added during compilation to obtain information about records:</source>
          <target state="translated">对每一个使用记录的模块,在编译时都会添加一个伪函数来获取记录的信息。</target>
        </trans-unit>
        <trans-unit id="aa7093d0b40db64d8d5dbb29fff9e15755ac8d7c" translate="yes" xml:space="preserve">
          <source>To effectively perform a batch of similar queries, you can use parameterized queries. This means that you in your SQL query string will mark the places that usually would contain values with question marks and then provide lists of values for each parameter. For instance you can use this to insert multiple rows into the &lt;code&gt;EMPLOYEE&lt;/code&gt; table while executing only a single SQL statement, for example code see &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; section in the &quot;Getting Started&quot; chapter.</source>
          <target state="translated">为了有效地执行一批类似的查询，可以使用参数化查询。这意味着您在SQL查询字符串中将用问号标记通常包含值的位置，然后为每个参数提供值列表。例如，您可以使用它在仅执行一条SQL语句的同时向 &lt;code&gt;EMPLOYEE&lt;/code&gt; 表中插入多行，例如，代码请参见 &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; 入门&amp;rdquo;一章中的&amp;ldquo;使用Erlang API&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4b87466d719f55a7d0bc6167a3744c10376e2896" translate="yes" xml:space="preserve">
          <source>To enable inlining of list functions, use option &lt;code&gt;inline_list_funcs&lt;/code&gt;.</source>
          <target state="translated">要启用列表功能的内联，请使用选项 &lt;code&gt;inline_list_funcs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51f30cb208852b09d381f6f12d3f9662837e7b58" translate="yes" xml:space="preserve">
          <source>To enable inlining, either use the option &lt;code&gt;inline&lt;/code&gt; to let the compiler decide which functions to inline, or &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; to have the compiler inline all calls to the given functions. If the option is given inside a &lt;code&gt;compile&lt;/code&gt; directive in an Erlang module, &lt;code&gt;{Name,Arity}&lt;/code&gt; can be written as &lt;code&gt;Name/Arity&lt;/code&gt;.</source>
          <target state="translated">要启用内联，无论是使用选项 &lt;code&gt;inline&lt;/code&gt; ，让编译器决定哪些函数内联，或 &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; 可以让编译器内联给定函数的调用。如果在Erlang模块的 &lt;code&gt;compile&lt;/code&gt; 指令中提供了该选项，则 &lt;code&gt;{Name,Arity}&lt;/code&gt; 可以写为 &lt;code&gt;Name/Arity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85f19bd3dcfaf9ef3d9cd6caa0e986c9a4690183" translate="yes" xml:space="preserve">
          <source>To enable or disable &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt;. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">启用或禁用 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cdfffdcb7bb12d82a554ed4fb4604dfb3bff2f" translate="yes" xml:space="preserve">
          <source>To enable or disable time correction, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要启用或禁用时间校正，请将命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="708713ed825ecbbe1d0ddcd36ee2857e998c3c1b" translate="yes" xml:space="preserve">
          <source>To enable the full power of Merl, your module needs to include the Merl header file:</source>
          <target state="translated">为了充分发挥Merl的功能,您的模块需要包含Merl头文件。</target>
        </trans-unit>
        <trans-unit id="8d53019e25d31ae87446a8faff92ab534fbdf049" translate="yes" xml:space="preserve">
          <source>To encode a list, without knowing the arity in advance:</source>
          <target state="translated">要对一个列表进行编码,而事先不知道arity。</target>
        </trans-unit>
        <trans-unit id="6cd4ebf865b6fcb86e3b3c3d86118b3cbc2de974" translate="yes" xml:space="preserve">
          <source>To ensure that &lt;code&gt;Common Test&lt;/code&gt; does not start executing tests, or closes its log files and shuts down, before the external application is ready for it, &lt;code&gt;Common Test&lt;/code&gt; can be synchronized with the application. During startup and shutdown, &lt;code&gt;Common Test&lt;/code&gt; can be suspended, simply by having a CTH evaluate a &lt;code&gt;receive&lt;/code&gt; expression in the init- or terminate function. The macros &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (the process executing the hook init function) and &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (the process executing the hook terminate function) each specifies the name of the correct &lt;code&gt;Common Test&lt;/code&gt; process to send a message to. This is done to return from the &lt;code&gt;receive&lt;/code&gt;. These macros are defined in &lt;code&gt;ct.hrl&lt;/code&gt;.</source>
          <target state="translated">为确保 &lt;code&gt;Common Test&lt;/code&gt; 在外部应用程序准备就绪之前，它不会开始执行测试或关闭其日志文件并关闭，可以将 &lt;code&gt;Common Test&lt;/code&gt; 与该应用程序同步。在启动和关闭期间，只需通过让CTH评估init-或终止函数中的 &lt;code&gt;receive&lt;/code&gt; 表达式，即可挂起 &lt;code&gt;Common Test&lt;/code&gt; 。宏 &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; （执行挂接初始化函数的进程）和 &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; （执行挂接终止函数的进程）中的每一个都指定了向其发送消息的正确的 &lt;code&gt;Common Test&lt;/code&gt; 进程的名称。这样做是为了从 &lt;code&gt;receive&lt;/code&gt; 返回。这些宏在 &lt;code&gt;ct.hrl&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="d6a3ca4567317dc34953b8a7c1cc3b757bbc4816" translate="yes" xml:space="preserve">
          <source>To ensure that a driver instance always uses the same thread, the following call can be used:</source>
          <target state="translated">为了确保驱动实例始终使用同一个线程,可以使用以下调用。</target>
        </trans-unit>
        <trans-unit id="a02dfbcc12d9a0c310d33ec7050492a8ba5fa268" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal,2,3&lt;/a&gt;&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">为确保将输出到 &lt;code&gt;stdout&lt;/code&gt; 的打印输出（或使用 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal,2,3&lt;/a&gt;&lt;/code&gt; 进行的打印输出）写入测试用例日志文件，而不写入 &lt;code&gt;Common Test&lt;/code&gt; Framework日志，可以与通过匹配evvents &lt;code&gt;tc_start&lt;/code&gt; 和 &lt;code&gt;tc_done&lt;/code&gt; 的 &lt;code&gt;Common Test&lt;/code&gt; 服务器。在这些事件之间的时间段内，所有I / O均定向到测试用例日志文件。同步发送这些事件以避免潜在的计时问题（例如，恰好在来自外部进程的I / O消息通过之前关闭测试用例日志文件）。知道这一点后，您需要注意 &lt;code&gt;handle_event/2&lt;/code&gt; 回调函数不会使测试执行停止，因此可能导致意外行为。</target>
        </trans-unit>
        <trans-unit id="e8b277a4b4779423015664e7a3f401ea54aeecd5" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ct:pal,2,3&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">为了确保将输出到 &lt;code&gt;stdout&lt;/code&gt; 的打印输出（或用 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;ct:pal,2,3&lt;/code&gt; 进行的打印输出）写入测试用例日志文件，而不是写入 &lt;code&gt;Common Test&lt;/code&gt; framework日志，您可以与通过匹配evvents &lt;code&gt;tc_start&lt;/code&gt; 和 &lt;code&gt;tc_done&lt;/code&gt; 的 &lt;code&gt;Common Test&lt;/code&gt; 服务器。在这些事件之间的时间段内，所有I / O均定向到测试用例日志文件。同步发送这些事件以避免潜在的计时问题（例如，恰好在来自外部进程的I / O消息通过之前关闭测试用例日志文件）。知道这一点后，您需要注意 &lt;code&gt;handle_event/2&lt;/code&gt; 回调函数不会使测试执行停止，因此可能导致意外行为。</target>
        </trans-unit>
        <trans-unit id="a63e4ff906295f7807af4b654281729a99f4d599" translate="yes" xml:space="preserve">
          <source>To execute group &lt;code&gt;tests1&lt;/code&gt; twice with different properties for &lt;code&gt;tests2&lt;/code&gt; each time:</source>
          <target state="translated">执行组 &lt;code&gt;tests1&lt;/code&gt; 具有不同属性的两次 &lt;code&gt;tests2&lt;/code&gt; 每次：</target>
        </trans-unit>
        <trans-unit id="7239843e8d90d77d86be2ae7b38276b2e33faca1" translate="yes" xml:space="preserve">
          <source>To execute the test cases in the recent test suite, type the following on the UNIX/Linux command line (assuming that the suite module is in the current working directory):</source>
          <target state="translated">要执行最近测试套件中的测试用例,在 UNIX/Linux 命令行中键入以下内容(假设套件模块在当前工作目录中)。</target>
        </trans-unit>
        <trans-unit id="15b464ff8a64913edd497cc9c55da6f1268e3b00" translate="yes" xml:space="preserve">
          <source>To explain how it works, let us examine the following code line by line:</source>
          <target state="translated">为了解释它是如何工作的,让我们逐行检查下面的代码。</target>
        </trans-unit>
        <trans-unit id="6ace97c5b62d1ba123d6323684c350a22b583d3a" translate="yes" xml:space="preserve">
          <source>To extract all files from a tar file, use function &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt;. To extract only some files or to be able to specify some more options, use function &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要从tar文件中提取所有文件，请使用函数 &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt; 。要仅提取某些文件或能够指定更多选项，请使用函数 &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d79465290c25ae2d243af5890aece9f3a5c6794" translate="yes" xml:space="preserve">
          <source>To extract files from a zip archive, use function &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;extract/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要从zip存档中提取文件，请使用功能 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;extract/1,2&lt;/code&gt; 使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="49b523abf1ecfbea37ac71cc8ad901ada87596e3" translate="yes" xml:space="preserve">
          <source>To facilitate addition or removal of algorithms the option &lt;code&gt;modify_algorithms&lt;/code&gt; is available. See the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">为了便于添加或删除算法，可以使用选项 &lt;code&gt;modify_algorithms&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="318d261f2e9e44898ab106149f1818df3611a4d0" translate="yes" xml:space="preserve">
          <source>To facilitate for instance counting of failed tries, the &lt;code&gt;State&lt;/code&gt; variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the &lt;code&gt;State&lt;/code&gt; variable has the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">为了便于例如计数失败尝试，可以使用 &lt;code&gt;State&lt;/code&gt; 变量。此状态仅针对每个连接。第一次调用pwdfun进行连接时， &lt;code&gt;State&lt;/code&gt; 变量的值为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb30040c24cb4398d4f306c6f75be49b3309b50e" translate="yes" xml:space="preserve">
          <source>To facilitate incremental MIB implementation, the tool can generate a prototype implementation for a whole MIB, or parts thereof. This allows different MIBs and management applications to be developed at the same time.</source>
          <target state="translated">为了促进MIB的增量实施,该工具可以为整个MIB或其中的一部分生成一个原型实施。这样就可以同时开发不同的MIB和管理应用程序。</target>
        </trans-unit>
        <trans-unit id="e3b821acb43789b1950f11a1cb4212f690e5c52d" translate="yes" xml:space="preserve">
          <source>To fetch the EEP-48 documentation for a module you can use &lt;code&gt;&lt;a href=&quot;code#get_doc-1&quot;&gt;code:get_doc/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取模块的EEP-48文档，可以使用 &lt;code&gt;&lt;a href=&quot;code#get_doc-1&quot;&gt;code:get_doc/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2bbbdeeda7bd5404449757f8d9770ca2ef7aaa9" translate="yes" xml:space="preserve">
          <source>To filter only by dates, specify the empty list as the &lt;code&gt;Filters&lt;/code&gt; parameter.</source>
          <target state="translated">要仅按日期进行过滤，请将空白列表指定为&amp;ldquo; &lt;code&gt;Filters&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="630e50a14a964d68d3d5576b2cd371a11e3b187e" translate="yes" xml:space="preserve">
          <source>To find &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; in all applications &lt;code&gt;src&lt;/code&gt; directories, use either of the following lines:</source>
          <target state="translated">要在所有应用程序的 &lt;code&gt;src&lt;/code&gt; 目录中找到 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; ，请使用以下任一行：</target>
        </trans-unit>
        <trans-unit id="a6396773c2bde8a4d52d39cd61a041b4f1f183b7" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.beam&lt;/code&gt; files in all applications, use the following line:</source>
          <target state="translated">要在所有应用程序中查找所有 &lt;code&gt;.beam&lt;/code&gt; 文件，请使用以下行：</target>
        </trans-unit>
        <trans-unit id="20cf9c172afcf3da74dfc71cb0f3fcae5974105f" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in any subdirectory:</source>
          <target state="translated">要在任何子目录中找到所有 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="7ed6cec65dd2913192c7cb022d1a0950d0fa1dc6" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">要在 &lt;code&gt;src&lt;/code&gt; 或 &lt;code&gt;include&lt;/code&gt; 目录中查找所有 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="fccdf7c91c9fff2872abc1dbafd75d06a060282b" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.hrl&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">要在 &lt;code&gt;src&lt;/code&gt; 中查找所有 &lt;code&gt;.hrl&lt;/code&gt; 文件或 &lt;code&gt;include&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="8e72309f663e0cdb8ebe00ece9160cd743a20ac1" translate="yes" xml:space="preserve">
          <source>To find out which data types will be returned for the columns in a table use the function &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">要查明将为表中的列返回哪些数据类型，请使用 &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="df081f6643e87b8a4d20937b6cf7036fe456bdf3" translate="yes" xml:space="preserve">
          <source>To find preceding keys in the table, use &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的先前键，请使用 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bab05c393dca1da866e4258e15bc30ee1a82d0d1" translate="yes" xml:space="preserve">
          <source>To find subsequent keys in the table, use &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在表中查找后续键，请使用 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5305b16b9a4a45c3c66348bdacc0a4e5b3a4971f" translate="yes" xml:space="preserve">
          <source>To find the first key in the table, use &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的第一个键，请使用 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42cc32e7cca81e536a322edfe74f1ef1ef453ef3" translate="yes" xml:space="preserve">
          <source>To find the last key in an &lt;code&gt;ordered_set&lt;/code&gt; table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在 &lt;code&gt;ordered_set&lt;/code&gt; 表中找到最后一个键，请使用 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f84576968a9f5a5747d5c908246715868508fa22" translate="yes" xml:space="preserve">
          <source>To find the last key in the table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要查找表中的最后一个键，请使用 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1a928f27f842a3eeb3e94898ada404294f44440" translate="yes" xml:space="preserve">
          <source>To find the smallest free segment that will satisfy a carrier allocation (best fit), the free segments are organized in a tree sorted by size (&lt;code&gt;stree&lt;/code&gt;). We search in this tree at allocation. If no free segment of sufficient size was found, the area (&lt;code&gt;sa&lt;/code&gt; or &lt;code&gt;sua&lt;/code&gt;) is instead expanded. If two or more free segments with equal size exist, the one at lowest address is chosen for &lt;code&gt;sa&lt;/code&gt; and highest address for &lt;code&gt;sua&lt;/code&gt;.</source>
          <target state="translated">为了找到满足载波分配（最适合）的最小空闲段，将空闲段组织在按大小排序的树中（ &lt;code&gt;stree&lt;/code&gt; ）。我们在分配时在这棵树中搜索。如果未找到足够大小的自由段，则将区域（ &lt;code&gt;sa&lt;/code&gt; 或 &lt;code&gt;sua&lt;/code&gt; ）扩大。如果存在两个或更多个大小相等的空闲段，则为 &lt;code&gt;sa&lt;/code&gt; 选择最低地址，为 &lt;code&gt;sua&lt;/code&gt; 选择最高地址。</target>
        </trans-unit>
        <trans-unit id="b08cebc24b1775a65769e106895c5039d3db4448" translate="yes" xml:space="preserve">
          <source>To fold a function over all files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将功能折叠到zip存档中的所有文件上，请使用function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3107d752335f18f59b4878dac8c20e1cc44001a3" translate="yes" xml:space="preserve">
          <source>To force Unicode filename translation mode on systems where this is not the default was considered experimental in Erlang/OTP R14B01. This was because the initial implementation did not ignore wrongly encoded filenames, so that raw filenames could spread unexpectedly throughout the system. As from Erlang/OTP R16B, the wrongly encoded filenames are only retrieved by special functions (such as &lt;code&gt;file:list_dir_all/1&lt;/code&gt;). Since the impact on existing code is therefore much lower it is now supported. Unicode filename translation is expected to be default in future releases.</source>
          <target state="translated">在Erlang / OTP R14B01中，尝试在非默认文件系统上强制使用Unicode文件名转换模式是试验性的。这是因为最初的实现并未忽略编码错误的文件名，因此原始文件名可能会意外地散布到整个系统中。从Erlang / OTP R16B开始，错误编码的文件名只能通过特殊功能（例如 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; ）来检索。由于对现有代码的影响要小得多，因此现在可以支持。Unicode文件名转换在将来的版本中有望成为默认设置。</target>
        </trans-unit>
        <trans-unit id="286ba4fce2df7e992d24f0fa54be1d66081e5721" translate="yes" xml:space="preserve">
          <source>To format the printout according to a user-specific HTML Style Sheet (CSS).</source>
          <target state="translated">根据用户特定的HTML样式表(CSS)来格式化打印输出。</target>
        </trans-unit>
        <trans-unit id="d829ca082ad3db2ea55b112c3bcb9aa6980d21fb" translate="yes" xml:space="preserve">
          <source>To forsee the effect of an option there is an experimental function &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt;. It mangles the options &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt; in the same way as &lt;code&gt;ssh:dameon&lt;/code&gt;, &lt;code&gt;ssh:connect&lt;/code&gt; and their friends does.</source>
          <target state="translated">为了预见一个选项的效果，有一个实验函数 &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt; 。它以与 &lt;code&gt;ssh:dameon&lt;/code&gt; ， &lt;code&gt;ssh:connect&lt;/code&gt; 及其朋友相同的方式来处理选项 &lt;code&gt;preferred_algorithms&lt;/code&gt; 和 &lt;code&gt;modify_algorithms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dec9bf90ad555856d14e7f8a0bcc0b6c2749f95" translate="yes" xml:space="preserve">
          <source>To fully understand how to configure the algorithms, it is essential to have a basic understanding of the SSH protocol and how OTP SSH app handles the corresponding items</source>
          <target state="translated">要想充分了解如何配置算法,必须对SSH协议以及OTP SSH应用如何处理相应的项目有一个基本的了解。</target>
        </trans-unit>
        <trans-unit id="105f7930b5d0bd6dbe4b596f6e5e1aa3c7bab464" translate="yes" xml:space="preserve">
          <source>To gain performance by using the SMP emulator, your application &lt;strong&gt;must have more than one runnable Erlang process&lt;/strong&gt; most of the time. Otherwise, the Erlang emulator can still only run one Erlang process at the time, but you must still pay the overhead for locking. Although Erlang/OTP tries to reduce the locking overhead as much as possible, it will never become exactly zero.</source>
          <target state="translated">为了通过使用SMP仿真器获得性能，您的应用程序&lt;strong&gt;在&lt;/strong&gt;大多数情况下&lt;strong&gt;必须具有多个可运行的Erlang进程&lt;/strong&gt;。否则，Erlang仿真器当时仍只能运行一个Erlang进程，但是您仍然必须支付锁定的开销。尽管Erlang / OTP试图尽可能减少锁定开销，但它永远不会变成零。</target>
        </trans-unit>
        <trans-unit id="a634d1c3b542e6ded32efa3015b3577d54cdb1be" translate="yes" xml:space="preserve">
          <source>To get a long period the Xoroshiro928 generator from the &lt;code&gt;rand&lt;/code&gt; module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values.</source>
          <target state="translated">为了获得较长的时间，必须将 &lt;code&gt;rand&lt;/code&gt; 模块中的Xoroshiro928生成器用作计数器（周期为2 ^ 928-1 ），并且通过AES对生成器的状态进行加扰以创建58位伪随机值。</target>
        </trans-unit>
        <trans-unit id="2cbd28c322c2b7823640cb5d04b4000794237448" translate="yes" xml:space="preserve">
          <source>To get an overview of the concepts and operation of &lt;code&gt;gen_statem&lt;/code&gt;, do read the &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; in &lt;code&gt;OTP Design Principles&lt;/code&gt; which frequently links back to this reference manual to avoid containing detailed facts that may rot by age.</source>
          <target state="translated">要 &lt;code&gt;gen_statem&lt;/code&gt; 的概念和操作，请阅读《 &lt;code&gt;OTP Design Principles&lt;/code&gt; 的 &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; ，该行为经常链接到本参考手册，以避免包含可能随年龄而变化的详细事实。</target>
        </trans-unit>
        <trans-unit id="01d79833ca3942345f121a64dcc3d55c1d0c6500" translate="yes" xml:space="preserve">
          <source>To get information about a PLT, use the following option:</source>
          <target state="translated">要获取PLT的信息,请使用以下选项。</target>
        </trans-unit>
        <trans-unit id="c0e64c3c0e0f616c357b7610945241b260af495d" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统的OS单调时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1d5a6ae5a2a64c460f8242067e0ee912a4a4259" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统OS单调时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d18259669e7618d7a319f9a564a8e6fb8e56985" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt; erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统的OS系统时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt; erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1abf6bacf41753f2d4e4f3e187da0b6ca761589" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取有关Erlang运行时系统的OS系统时间源的信息，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b209da3c80686caad1fbe93f4b143a75dbb826a1" translate="yes" xml:space="preserve">
          <source>To get log events on the same format as produced by &lt;code&gt;error_logger_tty_h&lt;/code&gt; and &lt;code&gt;error_logger_file_h&lt;/code&gt;, use the default formatter, &lt;code&gt;logger_formatter&lt;/code&gt;, with configuration parameter &lt;code&gt;legacy_header&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. This is the default configuration of the &lt;code&gt;default&lt;/code&gt; handler started by Kernel.</source>
          <target state="translated">要获得与 &lt;code&gt;error_logger_tty_h&lt;/code&gt; 和 &lt;code&gt;error_logger_file_h&lt;/code&gt; 产生的格式相同的日志事件，请使用默认格式设置 &lt;code&gt;logger_formatter&lt;/code&gt; ，并将配置参数 &lt;code&gt;legacy_header&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。这是内核启动的 &lt;code&gt;default&lt;/code&gt; 处理程序的默认配置。</target>
        </trans-unit>
        <trans-unit id="51cf577b00fc8216155e456c21c9c0183f56b93f" translate="yes" xml:space="preserve">
          <source>To get started, the least you need to do is to start a tracer with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;, and set the required trace flags on the processes you want to trace with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首先，您最不需要做的就是使用 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 启动一个跟踪器，并在要使用 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 进行跟踪的进程上设置所需的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="fc4b00be659493772c3eb90fac788afdac82d1da" translate="yes" xml:space="preserve">
          <source>To get started, you should read about the &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; data type; the main constructor functions: &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt;; and the main layout function &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首先，您应该阅读一下 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 数据类型。主要的构造函数： &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; ；和主布局功能 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80a72b65fea86a98c851ba990e410aac5fd9f4fb" translate="yes" xml:space="preserve">
          <source>To get the consistent behavior of killing ports when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads, use driver option &lt;code&gt;kill_ports&lt;/code&gt; when loading the driver instead.</source>
          <target state="translated">要获得在最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 卸载时终止端口的一致行为， &lt;code&gt;kill_ports&lt;/code&gt; 在加载驱动程序时使用驱动程序选项kill_ports。</target>
        </trans-unit>
        <trans-unit id="97de7a8dc23625a08e5a773780e14b0a5c65aae2" translate="yes" xml:space="preserve">
          <source>To get the output printed to a file, use option &lt;code&gt;--output_file&lt;/code&gt;.</source>
          <target state="translated">要将输出打印到文件中，请使用选项 &lt;code&gt;--output_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f76cd184a6e7c8d866643b588a8bdefe5b9edef" translate="yes" xml:space="preserve">
          <source>To get trace messages containing return values from functions, use the &lt;code&gt;{return_trace}&lt;/code&gt; match specification action instead.</source>
          <target state="translated">要获取包含函数返回值的跟踪消息，请改用 &lt;code&gt;{return_trace}&lt;/code&gt; 匹配规范操作。</target>
        </trans-unit>
        <trans-unit id="1820d2a1d5bd22bcad0e15651513a749cd0ea7ac" translate="yes" xml:space="preserve">
          <source>To give an indication on the possible performance gain using the specialized decodes, some measures have been performed. The relative figures in the outcome between selective, exclusive, and complete decode (the normal case) depend on the structure of the type, the size of the message, and on what level the selective and exclusive decodes are specified.</source>
          <target state="translated">为了说明使用专门的解码器可能获得的性能增益,已经进行了一些测量。选择性、排他性和完全解码(正常情况)之间的相对数字取决于类型的结构、电文的大小,以及选择性和排他性解码的具体水平。</target>
        </trans-unit>
        <trans-unit id="dcc0da7706c1bd437120fd6114754c61c3ba2f69" translate="yes" xml:space="preserve">
          <source>To give some background to the rest of this document, here follows a quick overview of how instructions are loaded.</source>
          <target state="translated">为了给本文档的其他部分提供一些背景资料,下面将简要介绍一下如何加载指令。</target>
        </trans-unit>
        <trans-unit id="a6bae83c7d1a2e1a895f2a1aac969ea5d6956ad8" translate="yes" xml:space="preserve">
          <source>To hack the erlang libraries, you simply do a &lt;code&gt;make opt&lt;/code&gt; in the specific &quot;applications&quot; directory, like:</source>
          <target state="translated">要破解erlang库，您只需在特定的&amp;ldquo;应用程序&amp;rdquo;目录中执行 &lt;code&gt;make opt&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="25afbf964210cbb860d968d22f8aec5dd76f1cff" translate="yes" xml:space="preserve">
          <source>To handle Unicode characters in Erlang, a common representation in both lists and binaries is needed. EEP (10) and the subsequent initial implementation in Erlang/OTP R13A settled a standard representation of Unicode characters in Erlang.</source>
          <target state="translated">为了在Erlang中处理Unicode字符,在列表和二进制文件中都需要一个通用的表示方法。EEP(10)和随后在Erlang/OTP R13A中的初步实现解决了Erlang中Unicode字符的标准表示方法。</target>
        </trans-unit>
        <trans-unit id="aff10dfbf070c41d255dec1932b739bd7e3bde90" translate="yes" xml:space="preserve">
          <source>To harbor real time characteristics, searching the pool is limited. We only inspect a limited number of carriers. If none of those carriers had a free block large enough to satisfy the allocation request, the search will fail. A carrier in the pool can also be BUSY if another thread is currently doing block deallocation work on the carrier. A BUSY carrier will also be skipped by the search as it cannot satisfy the request. The pool is lock-free and we do not want to block, waiting for the other thread to finish.</source>
          <target state="translated">为了包管实时特性,搜索池是有限的。我们只检查有限数量的载波。如果这些载体都没有足够大的空闲块来满足分配请求,搜索就会失败。如果当前有另一个线程正在对该载波进行块deallocation工作,那么池中的载波也可能是busy。BUSY的载体也会被搜索跳过,因为它不能满足请求。池子是无锁的,我们不想阻塞,等待其他线程完成。</target>
        </trans-unit>
        <trans-unit id="342c993bd4e7155816205341dd7a1c3953a4f6f8" translate="yes" xml:space="preserve">
          <source>To have &lt;code&gt;Common Test&lt;/code&gt; encrypt a specified file using function &lt;code&gt;DES3&lt;/code&gt; in application &lt;code&gt;Crypto&lt;/code&gt;, call &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; The encrypted file can then be used as a regular configuration file in combination with other encrypted files or normal text files. However, the key for decrypting the configuration file must be provided when running the test. This can be done with flag/option &lt;code&gt;decrypt_key&lt;/code&gt; or &lt;code&gt;decrypt_file&lt;/code&gt;, or a key file in a predefined location.</source>
          <target state="translated">要使 &lt;code&gt;Common Test&lt;/code&gt; 使用应用程序 &lt;code&gt;Crypto&lt;/code&gt; 中的函数 &lt;code&gt;DES3&lt;/code&gt; 加密指定的文件，请调用 &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; 。然后，可以将该加密文件与其他加密文件或普通文本文件结合用作常规配置文件。但是，运行测试时必须提供用于解密配置文件的密钥。这可以通过标志/选项 &lt;code&gt;decrypt_key&lt;/code&gt; 或 &lt;code&gt;decrypt_file&lt;/code&gt; 或预定义位置的密钥文件来完成。</target>
        </trans-unit>
        <trans-unit id="85cad9012ac3a0f7585ee9eb3d18653bcfe48b6e" translate="yes" xml:space="preserve">
          <source>To have an effect, a breakpoint must be set at an &lt;strong&gt;executable line&lt;/strong&gt;, which is a line of code containing an executable expression such as a matching or a function call. A blank line or a line containing a comment, function head, or pattern in a &lt;code&gt;case&lt;/code&gt; statement or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">为了产生效果，必须在&lt;strong&gt;可执行行&lt;/strong&gt;处设置断点，该行是包含可执行表达式（例如匹配或函数调用）的代码行。空行或 &lt;code&gt;case&lt;/code&gt; 语句或 &lt;code&gt;receive&lt;/code&gt; 语句中包含注释，函数头或模式的行不可执行。</target>
        </trans-unit>
        <trans-unit id="3526ad99fb939a42fd2ac8a732fa13795a7fc7c2" translate="yes" xml:space="preserve">
          <source>To have effect, this function is to be called from &lt;code&gt;init_per_suite/1&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;) before any tests are performed.</source>
          <target state="translated">为了生效，在执行任何测试之前，将从 &lt;code&gt;init_per_suite/1&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; ）中调用此函数。</target>
        </trans-unit>
        <trans-unit id="2708c75c960cc2ecf9c829562c09567eee5b452b" translate="yes" xml:space="preserve">
          <source>To help adapt configuration data to a test suite (or test case) and improve readability.</source>
          <target state="translated">帮助配置数据适应测试套件(或测试用例),提高可读性。</target>
        </trans-unit>
        <trans-unit id="030c50a15bdc06f6e3b51217f3e73b7d2d5a9ad8" translate="yes" xml:space="preserve">
          <source>To help setup the environment, there is a bat file, &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt;, that set's the appropriate environment for a Windows command prompt. This is not appropriate for bash, so you'll need to convert it to bash-style environments by editing your &lt;code&gt;.bash_profile&lt;/code&gt;. In my case, where the SDK is installed in the default directory and &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; is &lt;code&gt;C:\Program Files&lt;/code&gt;, the commands for setting up a 32bit build environment (on a 64bit or 32bit machine) look like this (in Cygwin):</source>
          <target state="translated">为了帮助设置环境，有一个bat文件 &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt; ，它为Windows命令提示符设置了合适的环境。这不适用于bash，因此您需要通过编辑 &lt;code&gt;.bash_profile&lt;/code&gt; 将其转换为bash风格的环境。在我的情况下，SDK安装在默认目录中， &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; 为 &lt;code&gt;C:\Program Files&lt;/code&gt; ，用于在32位或32位计算机上设置32位构建环境的命令如下所示（在Cygwin中）：</target>
        </trans-unit>
        <trans-unit id="8c68f332c622b4567e9853c18f5bd4711a371dc7" translate="yes" xml:space="preserve">
          <source>To help with debugging, EUnit defines several useful macros for printing messages directly to the console (rather than to the standard output). Furthermore, these macros all use the same basic format, which includes the file and line number where they occur, making it possible in some development environments (e.g., when running Erlang in an Emacs buffer) to simply click on the message and jump directly to the corresponding line in the code.</source>
          <target state="translated">为了帮助调试,EUnit定义了几个有用的宏,用于将消息直接打印到控制台(而不是标准输出)。此外,这些宏都使用相同的基本格式,其中包括文件和它们出现的行号,这使得在某些开发环境中(例如,当在Emacs缓冲区中运行Erlang时)可以简单地点击消息并直接跳转到代码中的相应行。</target>
        </trans-unit>
        <trans-unit id="f2bf4f85026136c5e9d89c67190507dcee8f99df" translate="yes" xml:space="preserve">
          <source>To identify connections (described later).</source>
          <target state="translated">要识别连接(后面会介绍)。</target>
        </trans-unit>
        <trans-unit id="a3a37007760548419af74fbda4faaad4a58f472b" translate="yes" xml:space="preserve">
          <source>To illustrate the interoperability principles, C programs running in a UNIX environment have been used. It is assumed that you have enough knowledge to apply these principles to the relevant programming languages and platforms.</source>
          <target state="translated">为了说明互操作性原则,我们使用了在UNIX环境下运行的C程序。假设你有足够的知识将这些原则应用于相关的编程语言和平台。</target>
        </trans-unit>
        <trans-unit id="e25970fd2bf365203fb3a3002e19cdcdbb27a907" translate="yes" xml:space="preserve">
          <source>To illustrate this we make up an example where the buttons instead generate down and up (press and release) events, and the lock responds to an up event only after the corresponding down event.</source>
          <target state="translated">为了说明这一点,我们做了一个例子,在这个例子中,按钮反而会产生向下和向上(按压和释放)事件,而锁只有在相应的向下事件之后才会响应向上事件。</target>
        </trans-unit>
        <trans-unit id="272786a4055a77679447504bd8a8b3f74b9c24f1" translate="yes" xml:space="preserve">
          <source>To illustrate this, do &lt;strong&gt;not&lt;/strong&gt; write as follows:</source>
          <target state="translated">为了说明这一点，就&lt;strong&gt;不会&lt;/strong&gt;写如下：</target>
        </trans-unit>
        <trans-unit id="968314d317898e187c56ec55b8af76cc4a65eba4" translate="yes" xml:space="preserve">
          <source>To illustrate this, suppose we extend our Mnesia &lt;code&gt;empTable&lt;/code&gt; with one internal column. We create it as before, but with an arity of 4, by adding another attribute.</source>
          <target state="translated">为了说明这一点，假设我们用一个内部列扩展Mnesia &lt;code&gt;empTable&lt;/code&gt; 。我们通过添加另一个属性，像以前一样创建它，但Arity为4。</target>
        </trans-unit>
        <trans-unit id="a162dc5a66ab8801f7f0ce0a26a9e8e3d6ef7a06" translate="yes" xml:space="preserve">
          <source>To illustrate this, the messenger example from the previous section is divided into the following five files:</source>
          <target state="translated">为了说明这一点,上一节中的messenger例子被分为以下五个文件。</target>
        </trans-unit>
        <trans-unit id="6bb28103d410bbb4345e8969c22657c7565cfc3a" translate="yes" xml:space="preserve">
          <source>To implement a new carrier for the Erlang distribution, the main steps are as follows.</source>
          <target state="translated">要实现一个新的Erlang发行版的载体,主要步骤如下。</target>
        </trans-unit>
        <trans-unit id="279afddbfce41bfb8c90b18f6a7106e81cad960d" translate="yes" xml:space="preserve">
          <source>To implement a user-defined behaviour, write code similar to code for a special process, but call functions in a callback module for handling specific tasks.</source>
          <target state="translated">要实现用户定义的行为,编写类似于特殊进程的代码,但要调用回调模块中的函数来处理特定任务。</target>
        </trans-unit>
        <trans-unit id="bbcff46d509465f1d50c1bdbf6bb8561780d4955" translate="yes" xml:space="preserve">
          <source>To implement an agent, the programmer writes instrumentation functions for the variables and the tables in the MIBs that the agent is going to support. A running prototype which handles &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;get-next&lt;/code&gt; can be created without any programming.</source>
          <target state="translated">为了实现代理，程序员为代理将支持的MIB中的变量和表编写了检测功能。无需任何编程即可创建处理 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;get-next&lt;/code&gt; 的运行原型。</target>
        </trans-unit>
        <trans-unit id="96a8f8e3de715f80a2e00a49b8a93d3352e72e52" translate="yes" xml:space="preserve">
          <source>To implement your own node discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">要实现自己的节点发现模块，您必须编写自己的EPMD模块。的 &lt;code&gt;EPMD module&lt;/code&gt; 负责提供另一节点的位置。分发模块（ &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; ）调用EPMD模块以获取另一个节点的IP地址和端口。作为Erlang / OTP一部分的EPMD模块将使用DNS解析主机名，并使用EPMD Unix进程获取另一个节点的端口。EPMD Unix进程通过连接到知名端口4369上的另一个节点来实现此目的。</target>
        </trans-unit>
        <trans-unit id="330de1ad3973af593bbd7d81e03664889a42ea4e" translate="yes" xml:space="preserve">
          <source>To implement your own service discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">要实现自己的服务发现模块，必须编写自己的EPMD模块。的 &lt;code&gt;EPMD module&lt;/code&gt; 负责提供另一节点的位置。分发模块（ &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; ）调用EPMD模块以获取另一个节点的IP地址和端口。作为Erlang / OTP一部分的EPMD模块将使用DNS解析主机名，并使用EPMD Unix进程获取另一个节点的端口。 EPMD UNIX进程通过连接到知名端口4369上的另一个节点来实现此目的。</target>
        </trans-unit>
        <trans-unit id="79134b2c4e38df5717fe5011c4463fea24abb3c3" translate="yes" xml:space="preserve">
          <source>To improve performance when analysing cover results it is possible to do multiple calls to &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; at once. You can also use the &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; convenience function.</source>
          <target state="translated">为了提高分析覆盖结果时的性能，可以一次执行多个调用来 &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 。您还可以使用 &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; 便捷功能。</target>
        </trans-unit>
        <trans-unit id="d70eada12ec2a8f92aa033daf56e896f20d26d8f" translate="yes" xml:space="preserve">
          <source>To include other nodes in the coverage analysis, use &lt;code&gt;start/1&lt;/code&gt;. All cover compiled modules will then be loaded on all nodes, and data from all nodes will be summed up when analysing. For simplicity this example only involves the current node.</source>
          <target state="translated">要在覆盖率分析中包括其他节点，请使用 &lt;code&gt;start/1&lt;/code&gt; 。然后将所有Cover编译的模块加载到所有节点上，并在分析时汇总来自所有节点的数据。为简单起见，此示例仅涉及当前节点。</target>
        </trans-unit>
        <trans-unit id="a5478a26ee1ac879ac54fc75bcb8b9a9f083c3ec" translate="yes" xml:space="preserve">
          <source>To include private shell commands, define them in a module &lt;code&gt;user_default&lt;/code&gt; and add the following argument as the first line in the &lt;code&gt;.erlang&lt;/code&gt; file:</source>
          <target state="translated">要包含私有shell命令，请在模块 &lt;code&gt;user_default&lt;/code&gt; 中定义它们，并在 &lt;code&gt;.erlang&lt;/code&gt; 文件的第一行中添加以下参数：</target>
        </trans-unit>
        <trans-unit id="203ccb7faa11c702e1202041c2be3ef44596552b" translate="yes" xml:space="preserve">
          <source>To initialize the database, execute the following code on one of the two nodes:</source>
          <target state="translated">要初始化数据库,请在两个节点中的一个节点上执行以下代码。</target>
        </trans-unit>
        <trans-unit id="026d2b6accddb0e61f3eda91aff0268e88788933" translate="yes" xml:space="preserve">
          <source>To insert an &amp;amp; or a \ in the result, precede it with a \. Notice that Erlang already gives a special meaning to \ in literal strings, so a single \ must be written as &lt;code&gt;&quot;\\&quot;&lt;/code&gt; and therefore a double \ as &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">要在结果中插入＆或\，请在其前面加上\。注意，Erlang已经在文字字符串中为\赋予了特殊的含义，因此单个\必须写为 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ，因此一个双\ 必须写为 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c018c38250aabfbb51e23ce90651060a950f1b96" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">要安装包括开始参数的 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44e25aea36620d24d591fc0a361139dfb3c4b11c" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">安装包括开始参数的 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c7864f1c5249a35705cc8dcabba48f995e8ae5" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">安装 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="025cdabf9ad94f75800cda5f1e9747d7ccc0323d" translate="yes" xml:space="preserve">
          <source>To install the CSS file (&lt;code&gt;Common Test&lt;/code&gt; inlines the definition in the HTML code), the file name can be provided when executing &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">要安装CSS文件（ &lt;code&gt;Common Test&lt;/code&gt; 内联HTML代码中的定义），可以在执行 &lt;code&gt;ct_run&lt;/code&gt; 时提供文件名。</target>
        </trans-unit>
        <trans-unit id="deb96dbc16afa611fcde38057919ecf9cc751bfa" translate="yes" xml:space="preserve">
          <source>To install the new version of the release in runtime, the &lt;strong&gt;release handler&lt;/strong&gt; is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the &lt;code&gt;release_handler&lt;/code&gt; module. For details, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">要在运行时中安装发行版的新版本，请使用&lt;strong&gt;发行处理程序&lt;/strong&gt;。这是属于SASL应用程序的过程，该过程负责处理发行包的解压缩，安装和删除。通过 &lt;code&gt;release_handler&lt;/code&gt; 模块进行通信。有关详细信息，请参见SASL中的 &lt;code&gt;release_handler(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="73c1bf364dc283d1176ab1d289c500fd685a5dab" translate="yes" xml:space="preserve">
          <source>To interpret all displayed modules in the chosen directory, click &lt;strong&gt;All&lt;/strong&gt;.</source>
          <target state="translated">要解释所选目录中所有显示的模块，请单击&lt;strong&gt;全部&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3292879da2b34dcadcc9f9ce0648b935ba4e7f92" translate="yes" xml:space="preserve">
          <source>To interrupt the runtime system or the shell process (depending on what has been specified with system flag &lt;code&gt;+B&lt;/code&gt;), use &lt;code&gt;Ctrl-Break&lt;/code&gt;.</source>
          <target state="translated">要中断运行时系统或shell进程（取决于使用系统标志 &lt;code&gt;+B&lt;/code&gt; 指定的内容），请使用 &lt;code&gt;Ctrl-Break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d9005b012d1045c52922820e7322a9dfa02e1f6" translate="yes" xml:space="preserve">
          <source>To investigate what Erlang thinks about the terminal, the call &lt;code&gt;io:getopts()&lt;/code&gt; can be used when the shell is started:</source>
          <target state="translated">要研究Erlang对终端的看法，可以在启动外壳程序时使用 &lt;code&gt;io:getopts()&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="11a6e867a167f9a4a740ad92d9902eefad28664c" translate="yes" xml:space="preserve">
          <source>To just run a shell on a remote machine, there are functions that bundles the needed three steps needed into one: &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt;. Similarily, to just open an sftp (file transfer) connection to a remote machine, the simplest way is to use &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要仅在远程计算机上运行Shell，有一些功能将所需的三个步骤捆绑为一个： &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt; 。同样，仅打开与远程计算机的sftp（文件传输）连接，最简单的方法是使用 &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f2634ff9e5775d30c933d162e116bcf2daeb2ae" translate="yes" xml:space="preserve">
          <source>To learn what sequential tracing is and how it can be used, see the Reference Manual for &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">要了解什么是顺序跟踪以及如何使用它，请参见 &lt;code&gt;seq_trace&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="ea8c91f9201e13f8a7af2544d0b6f79400981a45" translate="yes" xml:space="preserve">
          <source>To let the test suite continue on executing, return the configuration list that you want the test to use as the result.</source>
          <target state="translated">要让测试套件继续执行,请返回你希望测试使用的配置列表作为结果。</target>
        </trans-unit>
        <trans-unit id="d62397eee2357878fc975aeb84771b8bc2c06ea8" translate="yes" xml:space="preserve">
          <source>To limit the shutdown time, the time &lt;code&gt;init&lt;/code&gt; is allowed to spend taking down applications, command-line flag &lt;code&gt;-shutdown_time&lt;/code&gt; is to be used.</source>
          <target state="translated">为了限制关闭时间，允许使用时间 &lt;code&gt;init&lt;/code&gt; 来关闭应用程序，使用命令行标志 &lt;code&gt;-shutdown_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31df00fd05b2b4e7d3ede7fd0ed32c7595a82e9c" translate="yes" xml:space="preserve">
          <source>To list the contents of a configuration file, use &lt;code&gt;list_config/1&lt;/code&gt;.</source>
          <target state="translated">要列出配置文件的内容，请使用 &lt;code&gt;list_config/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5d893e9a4aaa1eb2af17414123d7e17dc6fd363" translate="yes" xml:space="preserve">
          <source>To listen on both SCTP and TCP, define one transport for each.</source>
          <target state="translated">要同时监听 SCTP 和 TCP,请为每个传输定义一个传输。</target>
        </trans-unit>
        <trans-unit id="11429257331a6c9848f977d465c2a19dfb56ed6e" translate="yes" xml:space="preserve">
          <source>To look for documentation for a module name example, a tool should:</source>
          <target state="translated">要查找模块名称范例的文档,工具应。</target>
        </trans-unit>
        <trans-unit id="07a54ad0b2a1bb175cf95b725d86a06fc8b48cbd" translate="yes" xml:space="preserve">
          <source>To look up one of the names:</source>
          <target state="translated">查询其中一个名字。</target>
        </trans-unit>
        <trans-unit id="8a56bbc15981f1188aa9ff7ef71388335fe7c6a6" translate="yes" xml:space="preserve">
          <source>To make a debug build of the emulator, you need to recompile both &lt;code&gt;beam.dll&lt;/code&gt; (the actual runtime system) and &lt;code&gt;erlexec.dll&lt;/code&gt;. Do like this</source>
          <target state="translated">要构建仿真器的调试版本，您需要重新编译 &lt;code&gt;beam.dll&lt;/code&gt; （实际的运行时系统）和 &lt;code&gt;erlexec.dll&lt;/code&gt; 。像这样</target>
        </trans-unit>
        <trans-unit id="038da331fd12e331816c4b78d58a10e2cc57ca86" translate="yes" xml:space="preserve">
          <source>To make it clearer exactly what code the warnings refer to, the warnings in the following examples are inserted as comments after the clause they refer to, for example:</source>
          <target state="translated">为了更清楚地说明警告所指的代码,在下面的例子中,警告被作为注释插入到它们所指的子句之后,例如。</target>
        </trans-unit>
        <trans-unit id="9a3d3828bd3e752b691c02502aca9ad44d8387dc" translate="yes" xml:space="preserve">
          <source>To make it easier to manage breakpoints without single threaded mode a redesign of the breakpoint mechanism has been made. The old &quot;breakpoint wheel&quot; data structure was a circular double-linked list of breakpoints for each instrumented function. It was invented before the SMP emulator. To support it in the SMP emulator, is was essentially expanded to one breakpoint wheel per scheduler. As more breakpoint types have been added, the implementation have become messy and hard to understand and maintain.</source>
          <target state="translated">为了在没有单线程模式的情况下更容易地管理断点,我们对断点机制进行了重新设计。旧的 &quot;断点轮 &quot;数据结构是一个循环的双链路列表,其中包含了每个被测函数的断点。它是在SMP仿真器之前发明的。为了在SMP仿真器中支持它,它基本上被扩展为每个调度器的一个断点轮。随着更多的断点类型被添加,实现变得混乱,难以理解和维护。</target>
        </trans-unit>
        <trans-unit id="cd2982d9a90975bc47a9c7a7530d4f0cbaa3f7f2" translate="yes" xml:space="preserve">
          <source>To make it easier to understand this section, some terms are defined. This is a mix of our own terminology (Erlang/OS system time, Erlang/OS monotonic time, time warp) and globally accepted terminology.</source>
          <target state="translated">为了便于理解本节内容,我们定义了一些术语。这是我们自己的术语(Erlang/OS系统时间、Erlang/OS单调时间、时间扭曲)和全球公认的术语的混合。</target>
        </trans-unit>
        <trans-unit id="2921bab0b743bbb6198162ca9c596c8d4e059429" translate="yes" xml:space="preserve">
          <source>To make the descriptions simpler, we first list some definitions:</source>
          <target state="translated">为了使描述更简单,我们首先列出一些定义。</target>
        </trans-unit>
        <trans-unit id="9c4714caed05dab02e49dd183a4006e068e3199f" translate="yes" xml:space="preserve">
          <source>To make the example runnable, we start implementing the reading and writing of the data to/from the ETS table. First function &lt;code&gt;put_chars/3&lt;/code&gt;:</source>
          <target state="translated">为了使示例可运行，我们开始实现对ETS表的数据读写。第一个功能 &lt;code&gt;put_chars/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="632f6f737e1f0ad548a43d9ad64573eca55f152d" translate="yes" xml:space="preserve">
          <source>To make the process change code, send the message &lt;code&gt;code_switch&lt;/code&gt; to it. The process then makes a fully qualified call to &lt;code&gt;m:loop()&lt;/code&gt; and changes to current code. Notice that &lt;code&gt;m:loop/0&lt;/code&gt; must be exported.</source>
          <target state="translated">要更改流程代码，请向其发送消息 &lt;code&gt;code_switch&lt;/code&gt; 。然后，该过程对 &lt;code&gt;m:loop()&lt;/code&gt; 进行完全限定的调用，并更改为当前代码。请注意，必须导出 &lt;code&gt;m:loop/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e177c9389e3d182722e09e0544b0a24268ff84e3" translate="yes" xml:space="preserve">
          <source>To make the test fair, each new test run is to run in its own, newly created Erlang process. Otherwise, if all tests run in the same process, the later tests start out with larger heap sizes and therefore probably do fewer garbage collections. Also consider restarting the Erlang emulator between each test.</source>
          <target state="translated">为了使测试公平,每个新的测试运行都要在自己的、新创建的Erlang进程中运行。否则,如果所有的测试都在同一个进程中运行,那么后面的测试一开始就会有较大的堆大小,因此可能会做较少的垃圾回收。也可以考虑在每次测试之间重新启动Erlang模拟器。</target>
        </trans-unit>
        <trans-unit id="120ecf4e057892d6019b012a82abcf83ac9ffd85" translate="yes" xml:space="preserve">
          <source>To make this happen the megaco stack has to be configured:</source>
          <target state="translated">为了实现这一点,必须配置megaco栈。</target>
        </trans-unit>
        <trans-unit id="13169d7b871948e1e9a9c4457e119e83fe7939d4" translate="yes" xml:space="preserve">
          <source>To manipulate services, the logged on user is to have administrator privileges on the machine. The Erlang machine itself is (default) run as the local administrator. This can be changed with the Services applet in Windows.</source>
          <target state="translated">要操纵服务,登录的用户要有机器上的管理员权限。Erlang机器本身(默认)是以本地管理员的身份运行的。这可以通过Windows中的服务小程序来改变。</target>
        </trans-unit>
        <trans-unit id="330fd48fdffeb44ebc089750d09d688535c7db34" translate="yes" xml:space="preserve">
          <source>To manipulate the Erlang services easily, put the &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; directory in the path instead of &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt;. The &lt;code&gt;erlsrv&lt;/code&gt; program can be found from inside Erlang by using the &lt;code&gt;os:find_executable/1&lt;/code&gt; Erlang function.</source>
          <target state="translated">要轻松地操作Erlang服务，请将 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; 目录放在路径中，而不是 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt; 。该 &lt;code&gt;erlsrv&lt;/code&gt; 程序可以从内部二郎通过使用发现 &lt;code&gt;os:find_executable/1&lt;/code&gt; 二郎功能。</target>
        </trans-unit>
        <trans-unit id="7b0e537b9e6e88eafa3eeae7f7a02f18b4e1430f" translate="yes" xml:space="preserve">
          <source>To manipulate the table we implement the following utility functions:</source>
          <target state="translated">为了操作该表,我们实现了以下实用函数。</target>
        </trans-unit>
        <trans-unit id="ffb58770364e94bc236d60f5ec83adb55db02d32" translate="yes" xml:space="preserve">
          <source>To match a variable number of arguments we need to use the special operand type &lt;code&gt;*&lt;/code&gt; like this:</source>
          <target state="translated">为了匹配可变数量的参数，我们需要使用特殊的操作数类型 &lt;code&gt;*&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="af1c290996a023ca9ee9b2902b6c1dc2a988f5c7" translate="yes" xml:space="preserve">
          <source>To match out the rest of a binary, specify a binary field without size:</source>
          <target state="translated">要匹配出二进制的其余部分,请指定一个没有大小的二进制字段。</target>
        </trans-unit>
        <trans-unit id="50f6c59cd17dfe4a6719c66fb938f13bf13c9cd5" translate="yes" xml:space="preserve">
          <source>To match out the rest of a bitstring, specify a field without size:</source>
          <target state="translated">要匹配出一个位串的其余部分,请指定一个没有大小的字段。</target>
        </trans-unit>
        <trans-unit id="3c74e2148772d016b06b50e91a05f48c85c5db24" translate="yes" xml:space="preserve">
          <source>To merge all wrap logs from two nodes:</source>
          <target state="translated">合并两个节点的所有wrap日志。</target>
        </trans-unit>
        <trans-unit id="9118cf58e561adea3d50918592e59eb25b8578d5" translate="yes" xml:space="preserve">
          <source>To modify the daemon start example above to reject one-time execution requests, we change &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; by adding the option &lt;code&gt;{exec, disabled}&lt;/code&gt; to:</source>
          <target state="translated">要修改上面的守护程序启动示例以拒绝一次执行请求，我们通过将选项 &lt;code&gt;{exec, disabled}&lt;/code&gt; 添加到以下 &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; 来更改步骤3：</target>
        </trans-unit>
        <trans-unit id="ca89d09befb2046f7583acd51b179a73eb3778d1" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt; update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt; update_handler_config/2&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1 &lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="6ec3ba5252c54ac879e329c670bb92c1a4f26979" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="d0497742c0aa1174886ab877594f8e6b707bfc8f" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt; update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt; update_primary_config/1&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0 &lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="7cbe08d74968e08a72c3be83982bb750cd3d4357" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="32727eea82b60880074a4863f6cda445f1b0e965" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_proxy_config-1&quot;&gt; update_proxy_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_proxy_config-0&quot;&gt;get_proxy_config/0 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">要修改现有配置，请使用 &lt;code&gt;&lt;a href=&quot;#update_proxy_config-1&quot;&gt; update_proxy_config/1&lt;/a&gt;&lt;/code&gt; ，或者，如果需要更复杂的合并，请使用 &lt;code&gt;&lt;a href=&quot;#get_proxy_config-0&quot;&gt;get_proxy_config/0 &lt;/a&gt;&lt;/code&gt; 读取当前配置，然后进行合并，然后再使用此功能将新配置写回。</target>
        </trans-unit>
        <trans-unit id="5232b103674f04a52f0f595b415d6da9c86b5634" translate="yes" xml:space="preserve">
          <source>To not lose the data that the failing node stored up to the point of crash, the control node tries to fetch it before restarting trace. This must occur within the allowed time frame, otherwise it is aborted (default is 10 seconds, but it can be changed with &lt;code&gt;{resume, MSec}&lt;/code&gt;). The data fetched this way is then merged with all other traces.</source>
          <target state="translated">为了不丢失发生故障的节点存储到崩溃点之前的数据，控制节点将尝试在重新启动跟踪之前获取它。这必须在允许的时间范围内发生，否则将中止（默认值为10秒，但可以使用 &lt;code&gt;{resume, MSec}&lt;/code&gt; 进行更改）。然后将以此方式获取的数据与所有其他跟踪合并。</target>
        </trans-unit>
        <trans-unit id="eead728bbb8cc0046ae68985d45f67a85158d6b1" translate="yes" xml:space="preserve">
          <source>To not update a driver and only recompile, it probably works when building for a 32-bit machine creating a false sense of security. Hopefully that will generate many important warnings. But when recompiling the same driver later on for a 64-bit machine, there &lt;strong&gt;will&lt;/strong&gt; be warnings and almost certainly crashes. So it is a &lt;strong&gt;bad&lt;/strong&gt; idea to postpone updating the driver and not fixing the warnings.</source>
          <target state="translated">为了不更新驱动程序而只重新编译，它可能在为32位计算机构建时产生假的安全感时起作用。希望这会产生许多重要的警告。但是，稍后在为64位计算机重新编译同一驱动程序时，&lt;strong&gt;将&lt;/strong&gt;出现警告，并且几乎肯定会崩溃。因此，推迟更新驱动程序而不修复警告是一个&lt;strong&gt;坏&lt;/strong&gt;主意。</target>
        </trans-unit>
        <trans-unit id="25dd351d674ee351bc0d61f733e4bc4ab3924c98" translate="yes" xml:space="preserve">
          <source>To only collect data from remote nodes without stopping &lt;code&gt;cover&lt;/code&gt; on those nodes, use &lt;code&gt;cover:flush/1&lt;/code&gt;</source>
          <target state="translated">从远程节点不停止只收集数据 &lt;code&gt;cover&lt;/code&gt; 的那些节点，使用关于 &lt;code&gt;cover:flush/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228c30057d8d3d2590c6d0ceb056f1bc0cfdc8f" translate="yes" xml:space="preserve">
          <source>To only update an existing value, the following syntax is used:</source>
          <target state="translated">要只更新一个现有的值,需要使用以下语法。</target>
        </trans-unit>
        <trans-unit id="91ac146297375e57e22dd83d0532b37bf8d61261" translate="yes" xml:space="preserve">
          <source>To open a file for writing and place the BOM first is even simpler:</source>
          <target state="translated">要想打开文件写,先放BOM就更简单了。</target>
        </trans-unit>
        <trans-unit id="58c7c0dd2c707e847605f73d2bf4f644bea3024e" translate="yes" xml:space="preserve">
          <source>To open a popup menu from which the appropriate module can be selected, right-click the &lt;strong&gt;Module&lt;/strong&gt; entry.</source>
          <target state="translated">要打开一个弹出菜单，从中可以选择适当的模块，请右键单击&amp;ldquo; &lt;strong&gt;模块&amp;rdquo;&lt;/strong&gt;条目。</target>
        </trans-unit>
        <trans-unit id="14f5619a76f5c4433353480eb14374da920455d5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the module to which the fun belongs, right-click the row and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关该乐趣所属模块的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;mod&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="707dccebf0704f68a732417b3f2c2e2a669bd41f" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of a timer, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关计时器所有者进程的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="67b5909ded381e129ca3cf333f0952bd76fc77a6" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of an ETS table, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要打开有关ETS表所有者过程的详细信息页面，请右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="310178f41809534c7c90fe35f112b61d4b6677f5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the scheduler, double-click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">要打开有关调度程序的详细信息页面，请双击或右键单击该行，然后&lt;strong&gt;为&amp;ldquo;标识符&amp;rdquo;&lt;/strong&gt;选择&amp;ldquo; &lt;strong&gt;属性&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="571318d856ef4524500a9b751e49f54bd8327c0e" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the table, double- click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">要打开有关表的详细信息页面，请双击或右键单击该行，然后&lt;strong&gt;为&amp;ldquo;标识符&amp;rdquo;&lt;/strong&gt;选择&amp;ldquo; &lt;strong&gt;属性&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9d9f96527be2bbc3f0e5c421b45a10f8abedace3" translate="yes" xml:space="preserve">
          <source>To optimize the copy operation in step 2, code access structures are reused. In current solution we have three sets of code access structures, identified by a code index of 0, 1 and 2. These indexes are used in a round robin fashion. Instead of having to initialize a completely new copy of all access structures for every load operation we just have to update with the changes that have happened since the last two code load operations. We could get by with only two code indexes (0 and 1), but that would require yet another round of waiting for thread progress before step 2 in the &lt;code&gt;finish_loading&lt;/code&gt; sequence. We cannot start reusing a code index as staging area until we know that no lingering scheduler thread is still using it as the active code index. With three generations of code indexes, the waiting for thread progress in step 4-6 will give this guarantee for us. Thread progress will wait for all running schedulers to reschedule at least one time. No ongoing execution reading code access structures reached from an old value of &lt;code&gt;the_active_code_index&lt;/code&gt; can exist after a second round of thread progress.</source>
          <target state="translated">为了在步骤2中优化复制操作，代码访问结构被重用。在当前解决方案中，我们具有三组代码访问结构，分别由代码索引0、1和2标识。这些索引以循环方式使用。不必为每个加载操作初始化所有访问结构的全新副本，我们只需更新自最后两个代码加载操作以来发生的更改即可。我们只能通过两个代码索引（0和1）来解决问题，但是这需要在 &lt;code&gt;finish_loading&lt;/code&gt; 的步骤2之前进行另一轮等待线程进度的操作顺序。在我们知道没有任何调度器线程仍在使用它作为活动代码索引之前，我们无法开始将代码索引重新用作登台区域。使用三代代码索引，步骤4-6中的等待线程进度将为我们提供这一保证。线程进度将等待所有正在运行的调度程序至少重新调度一次。在第二轮线程执行之后，不能存在从 &lt;code&gt;the_active_code_index&lt;/code&gt; 的旧值达到的正在进行的执行读取代码访问结构。</target>
        </trans-unit>
        <trans-unit id="0f882324ba7cf66c628fe99da4190c380235eb46" translate="yes" xml:space="preserve">
          <source>To output characters on an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">要在I / O设备上输出字符，存在以下 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4460b3a67f9f027204de0ad12d5d1dec14e5f20d" translate="yes" xml:space="preserve">
          <source>To overcome this situation, try to restart the ongoing transactions that are accessing tables on the failing node, and write a &lt;code&gt;mnesia_down&lt;/code&gt; entry to a log file.</source>
          <target state="translated">为了克服这种情况，请尝试重新启动正在访问故障节点上的表的正在进行的事务，并将 &lt;code&gt;mnesia_down&lt;/code&gt; 条目写入日志文件。</target>
        </trans-unit>
        <trans-unit id="7e7f8360d8ea17a73622310335fec57f5f594e5a" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use</source>
          <target state="translated">要覆盖现有配置而不进行任何合并,使用</target>
        </trans-unit>
        <trans-unit id="f7234cbfd68a0c262c592cc7d358092db950cccb" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2 &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eb9c41fc2b2f98f04f5d6d6242bc28f6713bd31" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c898f6aa3f00a6669d0ce126d552a738c9ef72d7" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1 &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db040bf59efb80826409bf9f754e7a7431f35000" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49fbf2912e0f2c254843c85e6a31555d4db4ff43" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_proxy_config-1&quot;&gt;set_proxy_config/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要覆盖现有配置而不进行任何合并，请使用 &lt;code&gt;&lt;a href=&quot;#set_proxy_config-1&quot;&gt;set_proxy_config/1 &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5df41f2e14a8f5ccfe8eb5134454968930bd33" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">要将数据从一个测试套件传递到另一个测试套件，将使用相同的机制。数据将由函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 保存，并由 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 的套件中的函数init_per_suite读取。在套件之间传递数据时， &lt;code&gt;Saver&lt;/code&gt; 带有测试套件的名称。</target>
        </trans-unit>
        <trans-unit id="7a2133d0447986ef047f45d46d57b0cba23ddd16" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">要将数据从一个测试套件传递到另一个测试套件，将使用相同的机制。数据将由end_per_suite函数保存，并由 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 的套件中的 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 函数读取。在套件之间传递数据时， &lt;code&gt;Saver&lt;/code&gt; 带有测试套件的名称。</target>
        </trans-unit>
        <trans-unit id="de196dbd1fc4727b3381ea786892e523ea66df78" translate="yes" xml:space="preserve">
          <source>To pass start arguments to the event handler init function, use option &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; instead of &lt;code&gt;-event_handler&lt;/code&gt;.</source>
          <target state="translated">要将启动参数传递给事件处理程序init函数，请使用选项 &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; 代替 &lt;code&gt;-event_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05760d82d1ff0699d6462cb51afbab4089fd15b2" translate="yes" xml:space="preserve">
          <source>To paste text, use &lt;code&gt;Ctrl-V&lt;/code&gt;.</source>
          <target state="translated">要粘贴文本，请使用 &lt;code&gt;Ctrl-V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a0ab25b4dbcc22e8a0f55cfd17389d320947558" translate="yes" xml:space="preserve">
          <source>To perform a selective decode:</source>
          <target state="translated">要进行选择性解码。</target>
        </trans-unit>
        <trans-unit id="e34161a911d532a3fe5b96ed7a79392865f455a4" translate="yes" xml:space="preserve">
          <source>To perform an exclusive decode:</source>
          <target state="translated">要进行专属解码。</target>
        </trans-unit>
        <trans-unit id="3f8dad79e2d5118a556c41ca87119ccb799f35ee" translate="yes" xml:space="preserve">
          <source>To perform code coverage test (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">执行代码覆盖率测试（请参阅 &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a431fccb77738e590c035501f73871c8ebfc0dd5" translate="yes" xml:space="preserve">
          <source>To plug in a handler to the &lt;code&gt;Common Test&lt;/code&gt; Master event manager, specify &lt;code&gt;master&lt;/code&gt; as the node in &lt;code&gt;NodeRefs&lt;/code&gt;.</source>
          <target state="translated">要将处理程序插入 &lt;code&gt;Common Test&lt;/code&gt; Master事件管理器，请在 &lt;code&gt;NodeRefs&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 指定为节点。</target>
        </trans-unit>
        <trans-unit id="a9a49f1cec23382260ab3c7111ed66a3064f4b5e" translate="yes" xml:space="preserve">
          <source>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a &lt;strong&gt;maximum restart intensity&lt;/strong&gt; is defined using two integer values specified with keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the above map. Assuming the values &lt;code&gt;MaxR&lt;/code&gt; for &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;MaxT&lt;/code&gt; for &lt;code&gt;period&lt;/code&gt;, then, if more than &lt;code&gt;MaxR&lt;/code&gt; restarts occur within &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;. &lt;code&gt;intensity&lt;/code&gt; defaults to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">为了防止主管进入子进程终止和重新启动的无限循环，使用上面映射中的键 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 指定的两个整数值来定义&lt;strong&gt;最大重新启动强度&lt;/strong&gt;。假设值 &lt;code&gt;MaxR&lt;/code&gt; 为 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;MaxT&lt;/code&gt; 为 &lt;code&gt;period&lt;/code&gt; ，然后，如果超过 &lt;code&gt;MaxR&lt;/code&gt; 重新启动内发生 &lt;code&gt;MaxT&lt;/code&gt; 秒，监控终止所有的子进程，然后本身。在这种情况下，主管本身的终止原因将被 &lt;code&gt;shutdown&lt;/code&gt; 。 &lt;code&gt;intensity&lt;/code&gt; 默认为 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 默认为 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b6bd58de0f6a9d2c9e5412e4769e5fc57c89331" translate="yes" xml:space="preserve">
          <source>To prevent accidentally reloading of modules affecting the Erlang runtime system, directories &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;compiler&lt;/code&gt; are considered &lt;strong&gt;sticky&lt;/strong&gt;. This means that the system issues a warning and rejects the request if a user tries to reload a module residing in any of them. The feature can be disabled by using command-line flag &lt;code&gt;-nostick&lt;/code&gt;.</source>
          <target state="translated">为了防止意外重新加载影响Erlang运行时系统的模块，目录 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 和 &lt;code&gt;compiler&lt;/code&gt; 被认为是&lt;strong&gt;粘滞的&lt;/strong&gt;。这意味着如果用户尝试重新加载驻留在其中任何一个模块中的模块，系统将发出警告并拒绝该请求。可以使用命令行标志 &lt;code&gt;-nostick&lt;/code&gt; 禁用该功能。</target>
        </trans-unit>
        <trans-unit id="dec616600e41a5b6ef771d942e395567b990586c" translate="yes" xml:space="preserve">
          <source>To prevent late answers (after the time-out) from polluting the message queue of the caller, a middleman process is used to do the calls. Late answers are then discarded when they arrive to a terminated process.</source>
          <target state="translated">为了防止迟来的应答(超时后)污染呼叫者的消息队列,采用中间人进程进行呼叫。迟到的应答到达终止的进程后就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="3c59c8bcb62921917057af6666d0e9bc306363f2" translate="yes" xml:space="preserve">
          <source>To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要将文件列表打印到Erlang Shell中，请使用功能 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c96078a18d7d337d7863d89fe19020a3f6b4c5e0" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment, Comment}&lt;/code&gt;.</source>
          <target state="translated">要在HTML结果页面上的字段 &lt;code&gt;Comment&lt;/code&gt; 中打印一些信息，请返回 &lt;code&gt;{comment, Comment}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e7f46b82ce549b77ba51c1629aef0ab23feab88" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment,Comment}&lt;/code&gt;.</source>
          <target state="translated">要在HTML结果页面上的字段 &lt;code&gt;Comment&lt;/code&gt; 中打印一些信息，请返回 &lt;code&gt;{comment,Comment}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cc0874eca15de116c6433f2f6c8188ae52c6b95" translate="yes" xml:space="preserve">
          <source>To produce sensible results, &lt;code&gt;fprof&lt;/code&gt; tries not to charge any function more than once for ACC time. The instance highest up (with longest duration) in the call stack is chosen.</source>
          <target state="translated">为了产生合理的结果， &lt;code&gt;fprof&lt;/code&gt; 尝试在ACC时间内不对任何功能进行多次充电。选择调用堆栈中最高级别（持续时间最长）的实例。</target>
        </trans-unit>
        <trans-unit id="fdb950e45ab67b6a47da12b4482a70174dcfdd0c" translate="yes" xml:space="preserve">
          <source>To provide customization and extensibility of the request handling of the HTTP servers, most of these steps are handled by one or more modules. These modules can be replaced or removed at runtime and new ones can be added. For each request, all modules are traversed in the order specified by the module directive in the server configuration file. Some parts, mainly the communication- related steps, are considered server core functionality and are not implemented using the Erlang web server API. A description of functionality implemented by the Erlang webserver API is described in &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为了提供HTTP服务器请求处理的自定义和可扩展性，这些步骤中的大多数由一个或多个模块处理。这些模块可以在运行时替换或删除，也可以添加新模块。对于每个请求，将按照服务器配置文件中的模块指令指定的顺序遍历所有模块。有些部分（主要是与通信相关的步骤）被视为服务器核心功能，并且未使用Erlang Web服务器API来实现。 &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt; 介绍了Erlang Web服务器API实现的功能。</target>
        </trans-unit>
        <trans-unit id="7caa6e3412703737187f18930265da85c613b9f8" translate="yes" xml:space="preserve">
          <source>To provide more information for bug detection tools, such as Dialyzer</source>
          <target state="translated">为Dialyzer等错误检测工具提供更多信息。</target>
        </trans-unit>
        <trans-unit id="70140cd0cd31cb537fdab4b337a2d1d9434b3002" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;ei_xreceive_msg()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;ei_xreceive_msg&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;erlang_msg&lt;/code&gt; structure.</source>
          <target state="translated">为了提供鲁棒性，分布式Erlang节点有时会轮询其所有连接的邻居，以尝试检测出现故障的节点或通信链路。预计收到此类消息的节点将立即使用 &lt;code&gt;ERL_TICK&lt;/code&gt; 消息进行响应。这是由 &lt;code&gt;ei_xreceive_msg()&lt;/code&gt; 自动完成的。然而，当这种情况发生， &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 返回 &lt;code&gt;ERL_TICK&lt;/code&gt; 给调用者，而不存储消息到 &lt;code&gt;erlang_msg&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="5563a933e99748f8947b5b13de253c9bebd73132" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;erl_receive()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;erl_receive&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;ErlMessage&lt;/code&gt; structure.</source>
          <target state="translated">为了提供鲁棒性，分布式Erlang节点有时会轮询其所有连接的邻居，以尝试检测故障的节点或通信链路。预计收到此类消息的节点将立即以 &lt;code&gt;ERL_TICK&lt;/code&gt; 消息进行响应。这是由 &lt;code&gt;erl_receive()&lt;/code&gt; 自动完成的。然而，当这种情况发生， &lt;code&gt;erl_receive&lt;/code&gt; 返回 &lt;code&gt;ERL_TICK&lt;/code&gt; 给调用者，而不存储消息到 &lt;code&gt;ErlMessage&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="c22d22ca8626a0d9ad4822b6abdf3304ff0e2ed1" translate="yes" xml:space="preserve">
          <source>To quickly get started on tracing function calls you can use the following code in the Erlang shell:</source>
          <target state="translated">为了快速开始跟踪函数调用,你可以在Erlang shell中使用以下代码。</target>
        </trans-unit>
        <trans-unit id="4216c6c1555a4ffc81851d786b4c47388d4033ab" translate="yes" xml:space="preserve">
          <source>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</source>
          <target state="translated">将每个工资低于10的人的工资提高到10,并返回所有加薪的总和。</target>
        </trans-unit>
        <trans-unit id="487f9ae77ed1f6bfc72656beab390cd3da83a3a4" translate="yes" xml:space="preserve">
          <source>To read characters from an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">要从I / O设备读取字符，存在以下 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ebc4e78936132f1c46d3f47b17ef930ad86f68e" translate="yes" xml:space="preserve">
          <source>To read data saved by a previous test case, use macro &lt;code&gt;config&lt;/code&gt; with a &lt;code&gt;saved_config&lt;/code&gt; key as follows:</source>
          <target state="translated">要读取以前的测试用例保存的数据，请使用带有 &lt;code&gt;saved_config&lt;/code&gt; 键的宏 &lt;code&gt;config&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="0e65ac5f6db83037a2248f75d84c868aa8830d0a" translate="yes" xml:space="preserve">
          <source>To read test terms, use &lt;code&gt;Tag = tests&lt;/code&gt; (rather than &lt;code&gt;suites&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, or &lt;code&gt;cases&lt;/code&gt;). &lt;code&gt;Value&lt;/code&gt; is then the list of &lt;strong&gt;all&lt;/strong&gt; tests on the form &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt;, where &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt;.</source>
          <target state="translated">要读取测试条件，请使用 &lt;code&gt;Tag = tests&lt;/code&gt; （而不是 &lt;code&gt;suites&lt;/code&gt; ， &lt;code&gt;groups&lt;/code&gt; 或 &lt;code&gt;cases&lt;/code&gt; ）。然后， &lt;code&gt;Value&lt;/code&gt; 是 &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt; 形式的&lt;strong&gt;所有&lt;/strong&gt;测试的列表，其中 &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt; [案例]。</target>
        </trans-unit>
        <trans-unit id="f7c528844ef8d79cae8d20604fa518c2950e82af" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt; erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要读取计数器值，请使用 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt; erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5502e1d91075568dbfad6a71c308a3359400e11e" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要读取计数器值，请使用 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf5d7d89573645295c9ea3ad3f20e180a97f562f" translate="yes" xml:space="preserve">
          <source>To read the value of a configuration variable, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要读取配置变量的值，请使用函数 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85dbe7571965e09b1298a761ceeca08b4c2e5f97" translate="yes" xml:space="preserve">
          <source>To read the values from the table directly is not always possible. It can be needed to search one or more tables to get the wanted data, and this is done by writing database queries. Queries are always more expensive operations than direct lookups done with &lt;code&gt;mnesia:read&lt;/code&gt;. Therefore, avoid queries in performance-critical code.</source>
          <target state="translated">直接从表中读取值并不总是可能的。可能需要搜索一个或多个表以获取所需的数据，这可以通过编写数据库查询来完成。查询总是比使用 &lt;code&gt;mnesia:read&lt;/code&gt; 直接查找更昂贵的操作。因此，请避免在性能关键的代码中进行查询。</target>
        </trans-unit>
        <trans-unit id="9ca82b142769fd54c89e1f8c4e76ea91942c4a3b" translate="yes" xml:space="preserve">
          <source>To reboot on Windows, &lt;code&gt;HEART_COMMAND&lt;/code&gt; can be set to &lt;code&gt;heart -shutdown&lt;/code&gt; (included in the Erlang delivery) or to any other suitable program that can activate a reboot.</source>
          <target state="translated">要在Windows上重新启动，可以将 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 设置为 &lt;code&gt;heart -shutdown&lt;/code&gt; （包括在Erlang交付中）或任何其他可以重新启动的合适程序。</target>
        </trans-unit>
        <trans-unit id="193023780b4eaa20d8ea195a384aafb6f435f70c" translate="yes" xml:space="preserve">
          <source>To reclaim data from the old heap, both young and old heaps are included during the collection and copied to a common &lt;strong&gt;to space&lt;/strong&gt;. Both the &lt;strong&gt;from space&lt;/strong&gt; of the young and old heap are then deallocated and the procedure will start over from the beginning. This type of garbage collection is called a full sweep and is triggered when the size of the area under the high-watermark is larger than the size of the free area of the old heap. It can also be triggered by doing a manual call to &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#garbage_collect-0&quot;&gt;erlang:garbage_collect()&lt;/a&gt;&lt;/code&gt;, or by running into the young garbage collection limit set by &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;spawn_opt(fun(),[{fullsweep_after, N}])&lt;/a&gt;&lt;/code&gt; where N is the number of young garbage collections to do before forcing a garbage collection of both young and old heap.</source>
          <target state="translated">为了从旧堆中回收数据，在收集期间会同时包含新堆和旧堆，并将它们复制&lt;strong&gt;到space&lt;/strong&gt;的公共&lt;strong&gt;空间&lt;/strong&gt;。然后重新分配年轻堆和旧堆的&lt;strong&gt;from空间&lt;/strong&gt;，并且过程将从头开始。这种类型的垃圾收集称为完全清除，当高水位标记下的区域大小大于旧堆的可用区域的大小时触发。也可以通过手动调用 &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#garbage_collect-0&quot;&gt;erlang:garbage_collect()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;spawn_opt(fun(),[{fullsweep_after, N}])&lt;/a&gt;&lt;/code&gt; 设置的年轻垃圾收集限制来触发，其中N是年轻垃圾的数量在强制对旧堆和旧堆进行垃圾回收之前要执行的回收。</target>
        </trans-unit>
        <trans-unit id="904a52a917c4933054a167b0ca9069fffee62faa" translate="yes" xml:space="preserve">
          <source>To reduce fragmentation within the super carrier, it is good to keep SBCs and MBCs apart. MBCs with their uniform alignment and sizes can be packed very efficiently together. SBCs without demand for aligment can also be allocated quite efficiently together. But mixing them can lead to a lot of memory wasted when we need to create large holes of padding to the next alignment limit.</source>
          <target state="translated">为了减少超级载体内的碎片,最好将SBC和MBC分开。具有统一排列和尺寸的MBC可以非常有效地装在一起。没有分片需求的SBC也可以很高效地分配在一起。但是当我们需要创建大孔的填充到下一个对齐极限时,混合它们会导致大量的内存浪费。</target>
        </trans-unit>
        <trans-unit id="7356ba3e6c5278038b64fa42047a269f1c25742e" translate="yes" xml:space="preserve">
          <source>To reload a driver, the process must have loaded the driver before, that is, there must be an active &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver in the process.</source>
          <target state="translated">要重新加载驱动程序，进程必须先加载驱动程序，也就是说，进程中必须有该驱动程序的活动 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5d80cf56917698c815ead9031a1b70952ad813b" translate="yes" xml:space="preserve">
          <source>To remove a breakpoint some more steps are needed. The idea is to first stage the breakpoint as disabled, do the switch, wait for thread progress and then remove the disabled breakpoint by restoring the original beam instruction.</source>
          <target state="translated">要删除一个断点,还需要一些步骤。其思路是先将断点阶段为禁用,进行切换,等待线程进度,然后通过恢复原束指令来删除禁用的断点。</target>
        </trans-unit>
        <trans-unit id="fa3cdbff1f4721e1fea3341a44c74cdfddea8582" translate="yes" xml:space="preserve">
          <source>To remove the special meaning from a sequence of characters, put them between \Q and \E. This is different from Perl in that $ and @ are handled as literals in \Q...\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples:</source>
          <target state="translated">要从一个字符序列中删除特殊的含义,可以将它们放在 \Q 和 \E 之间。这与Perl的不同之处在于,在PCRE中,$和@是作为字元处理的,而在Perl中,$和@会导致变量插值。请注意下面的例子。</target>
        </trans-unit>
        <trans-unit id="e4533b5e08e30a08269677e74e6167edc56c190c" translate="yes" xml:space="preserve">
          <source>To render the EEP-48 documentation for an Erlang module you can use &lt;code&gt;shell_docs:render/2&lt;/code&gt;.</source>
          <target state="translated">要呈现Erlang模块的EEP-48文档，可以使用 &lt;code&gt;shell_docs:render/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18463ee935cca0988ac023c8a2bb9233c9fed26c" translate="yes" xml:space="preserve">
          <source>To resolve BIF clashes, use explicit module names or the &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; compiler directive.</source>
          <target state="translated">要解决BIF冲突，请使用显式模块名称或 &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; 编译器指令。</target>
        </trans-unit>
        <trans-unit id="b836fc9905c583f17eeb633ad4676ccd91021746" translate="yes" xml:space="preserve">
          <source>To restrict access further, firewall software must be used.</source>
          <target state="translated">要进一步限制访问,必须使用防火墙软件。</target>
        </trans-unit>
        <trans-unit id="d8f49586e1a231ba1f54695cd73e9669c2fc73d3" translate="yes" xml:space="preserve">
          <source>To retain backwards compatibility, this module can also be used to start a standalone &lt;code&gt;nteventlog&lt;/code&gt; process which is not part of the OS_Mon supervision tree. When starting such a process, the user has to supply an identifier as well as a callback function to handle the messages.</source>
          <target state="translated">为了保持向后兼容性，此模块还可以用于启动独立的 &lt;code&gt;nteventlog&lt;/code&gt; 进程，该进程不属于OS_Mon监视树。当开始这样的过程时，用户必须提供标识符以及回调函数来处理消息。</target>
        </trans-unit>
        <trans-unit id="a959b682cb9f11efcb53765708cc1ed01908dbd3" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt; info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">要检索有关哪些进程已修复了哪些表的 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt; info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; ，请使用info（Tab，safe_fixed_monotonic_time）。具有固定表的多个进程的系统可能需要一个监视器，该监视器在表修复时间过长时会发送警报。</target>
        </trans-unit>
        <trans-unit id="df78eacbc0781784bde23219396762a59c5fc919" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">要检索有关哪些进程已修复了哪些表的 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; ，请使用info（Tab，safe_fixed_monotonic_time）。具有固定表的多个进程的系统可能需要一个监视器，该监视器在表修复时间过长时会发送警报。</target>
        </trans-unit>
        <trans-unit id="d6e2ab13997144de0b0946f9bce9ea8b713fdb68" translate="yes" xml:space="preserve">
          <source>To retrieve lock statistics information, use &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;. The collect operation will start a &lt;code&gt;lcnt&lt;/code&gt; server if it not already started. All collected data will be built into an Erlang term and uploaded to the server and a duration time will also be uploaded. This duration is the time between &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; and &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;.</source>
          <target state="translated">要检索锁统计信息，请使用 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 。收集操作将启动 &lt;code&gt;lcnt&lt;/code&gt; 服务器（如果尚未启动）。所有收集的数据都将内置到Erlang术语中并上传到服务器，并且持续时间也将上传。此持续时间是 &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; 和 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 之间的时间。</target>
        </trans-unit>
        <trans-unit id="ed81e642c8e411bd6b5d4f1ff2f2a981ab28269a" translate="yes" xml:space="preserve">
          <source>To retrieve options, the following request is used:</source>
          <target state="translated">要检索选项,请使用以下请求。</target>
        </trans-unit>
        <trans-unit id="c9ff785694d496350bf52e12cf31257901fe0f9a" translate="yes" xml:space="preserve">
          <source>To retrieve previous command lines, press the &lt;code&gt;Up arrow&lt;/code&gt; or use &lt;code&gt;Ctrl-P&lt;/code&gt;.</source>
          <target state="translated">要检索以前的命令行，请按 &lt;code&gt;Up arrow&lt;/code&gt; 或使用 &lt;code&gt;Ctrl-P&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa4079733e0da1dfbe5a6ebd7c48cf9cb0263ef" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取当前时间偏移，请调用 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559902e638ff39f33df6bbdca42175eae97e1371" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取当前时间偏移，请调用 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cbf41d37fbb9107d553f0edbf762bf1a41464d8" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name-0&quot;&gt; escript:script_name() &lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">要检索脚本的路径名，请从脚本中调用 &lt;code&gt;&lt;a href=&quot;#script_name-0&quot;&gt; escript:script_name() &lt;/a&gt;&lt;/code&gt; （路径名通常，但并非总是绝对的）。</target>
        </trans-unit>
        <trans-unit id="3766f9d946545324fc3caa134e7e2c3cc1ac0495" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">要检索脚本的路径名，请从脚本中调用 &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; （路径名通常，但并非总是绝对的）。</target>
        </trans-unit>
        <trans-unit id="2fa3ffd8aedc2e1d61b1e455bb122f9f20bde0a5" translate="yes" xml:space="preserve">
          <source>To retrieve the size of a tuple, either use function &lt;code&gt;erl_size&lt;/code&gt; (which checks the type of the checked term and works for a binary as well as for a tuple) or &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; returns the arity of a tuple. &lt;code&gt;erl_size()&lt;/code&gt; does the same thing, but it checks that the argument is a tuple. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; returns the element corresponding to a given position in the tuple.</source>
          <target state="translated">要检索元组的大小，请使用函数 &lt;code&gt;erl_size&lt;/code&gt; （检查被检查项的类型并针对二进制和元组工作）或 &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; 返回元组的奇偶性。 &lt;code&gt;erl_size()&lt;/code&gt; 做同样的事情，但是它检查参数是否为元组。 &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; 返回与元组中给定位置相对应的元素。</target>
        </trans-unit>
        <trans-unit id="e48e571028f75c8447b25387e9c4c4797341c527" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a tar file, use function &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;. To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要返回tar文件中的文件列表，请使用函数 &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 。要将文件列表打印到Erlang Shell中，请使用功能 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340c1d928e96b2c334351d4a254c0683a554ee08" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;table/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">要返回zip存档中的文件列表，请使用函数 &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt; 。它们也可以作为 &lt;code&gt;table/1,2&lt;/code&gt; 使用，类似于 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="ede464349d4cd7d18cdfbdde4b663fdde07fb367" translate="yes" xml:space="preserve">
          <source>To return a timetrap time value (other than a function).</source>
          <target state="translated">返回一个定时器时间值(函数以外的)。</target>
        </trans-unit>
        <trans-unit id="8b77285912aad5ab1ca119d023b421a0ece59988" translate="yes" xml:space="preserve">
          <source>To return only a few answers, cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers:</source>
          <target state="translated">如果只返回几个答案,可以使用游标。下面的代码使用一个ETS表来存储唯一的答案,返回的答案不超过5个。</target>
        </trans-unit>
        <trans-unit id="9f1313328915fb09221beb5318c9e4409d5bb780" translate="yes" xml:space="preserve">
          <source>To return your own non-zero exit code, call &lt;code&gt;halt(ExitCode)&lt;/code&gt;, for example:</source>
          <target state="translated">要返回自己的非零退出代码，请调用 &lt;code&gt;halt(ExitCode)&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="1b79ecfdca80ef63664553eeb43bf5bf50699646" translate="yes" xml:space="preserve">
          <source>To revert to the old representation of the types, use option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">要恢复为旧的类型表示形式，请使用 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="91cba5ad0a4514ff3580b9b3644134649e4008a3" translate="yes" xml:space="preserve">
          <source>To run DTLS add the option {protocol, dtls} to third argument.</source>
          <target state="translated">要运行DTLS,请在第三个参数中添加{protocol,dtls}选项。</target>
        </trans-unit>
        <trans-unit id="6379d836d463079cbc440c281ea46705465f1d9e" translate="yes" xml:space="preserve">
          <source>To run it manually do the following:</source>
          <target state="translated">要手动运行它,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="adfad10f00ccaf0e104d2a8e3a7d4d9ca3d7a1f4" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data from a test case that is to be skipped, return tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt;.</source>
          <target state="translated">要保存要跳过的测试用例中的 &lt;code&gt;Config&lt;/code&gt; 数据，请返回元组 &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="519bc4bce2b33dabd607dc6ed921c16f90d09ddb" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data, return tuple &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; from &lt;code&gt;end_per_testcase&lt;/code&gt; or from the main test case function.</source>
          <target state="translated">要保存 &lt;code&gt;Config&lt;/code&gt; 数据，请从 &lt;code&gt;end_per_testcase&lt;/code&gt; 或主测试用例函数返回元组 &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c3f8d5138cdbd33fa95b3ba65e0753971bf624" translate="yes" xml:space="preserve">
          <source>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</source>
          <target state="translated">为了很好地扩展,最好确保记录均匀地分布在所有碎片上,包括新的碎片。</target>
        </trans-unit>
        <trans-unit id="4c8083213bdb28df6c894a96e97a47fb6b900182" translate="yes" xml:space="preserve">
          <source>To schedule a dirty NIF for execution, the application has two options:</source>
          <target state="translated">要安排脏NIF的执行,应用程序有两个选项。</target>
        </trans-unit>
        <trans-unit id="f67e6c0f7313593a134591d24c1deff4f24d43c9" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all) &lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">要查看所有受支持的密码套件，请致电 &lt;code&gt;ssl:cipher_suites(all) &lt;/code&gt; 。连接可用的密码套件取决于您的证书。还可以指定您希望连接使用的特定密码套件。默认是使用最强的可用。</target>
        </trans-unit>
        <trans-unit id="2dcc54bfbac822c2d50a90e01df3c8520791a56a" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">要查看所有受支持的密码套件，请致电 &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt; 。连接可用的密码套件取决于您的证书。还可以指定您希望连接使用的特定密码套件。默认是使用最强的可用。</target>
        </trans-unit>
        <trans-unit id="faa6a0098bcbb7837e8269c97adc5d1ee4575f3f" translate="yes" xml:space="preserve">
          <source>To see more detailed information about a node, double-click the row, or right-click the row and select &lt;strong&gt;Properties for node &amp;lt;node&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;, to open the detailed information window for the controlling port.</source>
          <target state="translated">要查看有关节点的更多详细信息，请双击该行，或右键单击该行，然后选择&lt;strong&gt;节点&amp;lt;node&amp;gt;的属性&lt;/strong&gt;。从右键单击菜单，您还可&lt;strong&gt;以为&amp;lt;port&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;，以打开控制端口的详细信息窗口。</target>
        </trans-unit>
        <trans-unit id="9b51fe379feee1d788abaddbf99683f3e6711cc7" translate="yes" xml:space="preserve">
          <source>To see relevant version information for ssl, call &lt;code&gt;ssl:versions/0&lt;/code&gt; .</source>
          <target state="translated">要查看ssl的相关版本信息，请调用 &lt;code&gt;ssl:versions/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01a4feb6bffa4cdaf907be61314c3a9080a6778" translate="yes" xml:space="preserve">
          <source>To see what &lt;code&gt;-no_prefetch&lt;/code&gt; does, let's first look at the default code generation. Here is the code generated for &lt;code&gt;move_cx&lt;/code&gt;:</source>
          <target state="translated">要了解 &lt;code&gt;-no_prefetch&lt;/code&gt; 的功能，让我们首先看一下默认的代码生成。这是为 &lt;code&gt;move_cx&lt;/code&gt; 生成的代码：</target>
        </trans-unit>
        <trans-unit id="4f1a753c21aa1ee5d67b189d4fc20785c035d677" translate="yes" xml:space="preserve">
          <source>To see what names there are:</source>
          <target state="translated">要看看有哪些名字。</target>
        </trans-unit>
        <trans-unit id="fac884f3e42129e5cef89147e288ea2b8ca2327a" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt; logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">要查看系统中当前安装了哪些过滤器，请使用 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt; logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 。筛选器按应用顺序列出，也就是说，列表中的第一个筛选器将首先应用，依此类推。</target>
        </trans-unit>
        <trans-unit id="1859a2e235479aee5e6ed677756b1cdde77dacdb" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">要查看系统中当前安装了哪些过滤器，请使用 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 。筛选器按应用顺序列出，也就是说，列表中的第一个筛选器将首先应用，依此类推。</target>
        </trans-unit>
        <trans-unit id="45a5562edb75b6f3eb1acaabf3b28d155bb31931" translate="yes" xml:space="preserve">
          <source>To select more text than fits in the window, start by selecting a small part in the beginning of the text you want, then use the scrollbar to view the end of the desired selection, point to it, and press the &lt;strong&gt;right&lt;/strong&gt; mouse button. The whole area between your first selection and the point where you right-clicked is included in the selection.</source>
          <target state="translated">要选择比窗口调整更多的文字，在你想要的文本的开始选择一小部分开始，然后使用滚动条来查看所需的选择结束后，指向它，并按下&lt;strong&gt;右&lt;/strong&gt;鼠标键。从第一个选择到您右键单击的点之间的整个区域都包括在选择中。</target>
        </trans-unit>
        <trans-unit id="33c0c20ef88e8a421c1e58b4d073cd8cec174df4" translate="yes" xml:space="preserve">
          <source>To select text in the &lt;code&gt;werl&lt;/code&gt; window, press and hold the left mouse button and drag the mouse over the text you want to select. If the selection crosses line boundaries, the selected text consists of complete lines where applicable (just like in a word processor).</source>
          <target state="translated">要在 &lt;code&gt;werl&lt;/code&gt; 窗口中选择文本，请按住鼠标左键，然后将鼠标拖到要选择的文本上。如果所选内容跨越行边界，则所选文本将在适用的情况下由完整的行组成（就像在文字处理器中一样）。</target>
        </trans-unit>
        <trans-unit id="baa709b93b3829a0df77188d6fd0ef0592956e57" translate="yes" xml:space="preserve">
          <source>To separate the first elements of the list from the rest of the list, &lt;code&gt;|&lt;/code&gt; is used. &lt;code&gt;First&lt;/code&gt; has got value 1 and &lt;code&gt;TheRest&lt;/code&gt; has got the value [2,3,4,5].</source>
          <target state="translated">要将列表的第一个元素与列表的其余部分分开， &lt;code&gt;|&lt;/code&gt; 。用来。 &lt;code&gt;First&lt;/code&gt; 的值为1， &lt;code&gt;TheRest&lt;/code&gt; 的值为[2,3,4,5]。</target>
        </trans-unit>
        <trans-unit id="99399a80e908574c88a36cb976c633b07714e9f8" translate="yes" xml:space="preserve">
          <source>To set it, set the option &lt;code&gt;{key_cb, {ssh_file, [{optimize,TimeOrSpace}]}&lt;/code&gt; in the call of &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;&quot;ssh:connect/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2&lt;/a&gt;&lt;/code&gt; or similar function call that initiates an ssh connection.</source>
          <target state="translated">要进行设置，请在 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;&quot;ssh:connect/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2&lt;/a&gt;&lt;/code&gt; 或启动ssh连接的类似函数调用&amp;rdquo;的调用中设置选项 &lt;code&gt;{key_cb, {ssh_file, [{optimize,TimeOrSpace}]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c01449dac6b2c1e79ac6f7a80fed6fdc43f67423" translate="yes" xml:space="preserve">
          <source>To set the default handler, that starts initially with the Kernel application, to log to file instead of &lt;code&gt;standard_io&lt;/code&gt;, change the Kernel default logger configuration. Example:</source>
          <target state="translated">要设置最初从Kernel应用程序开始的默认处理程序，以记录到文件而不是 &lt;code&gt;standard_io&lt;/code&gt; ，请更改Kernel默认记录器配置。例：</target>
        </trans-unit>
        <trans-unit id="f3ccaabc6c6c384fa4607146b378de54d2e651c3" translate="yes" xml:space="preserve">
          <source>To set the time warp mode, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要设置时间扭曲模式，请将命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa0688ed50c18775a5b27e32c9d7ee33f891bdef" translate="yes" xml:space="preserve">
          <source>To set up Erlang distribution over TLS:</source>
          <target state="translated">要在TLS上设置Erlang分发。</target>
        </trans-unit>
        <trans-unit id="d2cce9d630a9f1b9f9af96de1b5c45472cb5cc3c" translate="yes" xml:space="preserve">
          <source>To set up client/server connections:</source>
          <target state="translated">要设置客户机/服务器连接。</target>
        </trans-unit>
        <trans-unit id="b43c85b2017cddcd0eeca4a7ee756681a2b5279f" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a UNIX systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt; in the your home directory.</source>
          <target state="translated">要在UNIX系统上设置Erlang Emacs模式，请在主目录中编辑/创建文件 &lt;code&gt;.emacs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17525f3111c9dc221811cc59d7953bea94c55a6a" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a Windows systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt;, the location of the file depends on the configuration of the system. If the &lt;strong&gt;HOME&lt;/strong&gt; environment variable is set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in the directory indicated by the &lt;strong&gt;HOME&lt;/strong&gt; variable. If &lt;strong&gt;HOME&lt;/strong&gt; is not set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in &lt;code&gt;C:\&lt;/code&gt;.</source>
          <target state="translated">要在Windows系统上设置Erlang Emacs模式，请编辑/创建文件 &lt;code&gt;.emacs&lt;/code&gt; ，文件的位置取决于系统的配置。如果设置了&lt;strong&gt;HOME&lt;/strong&gt;环境变量，则Emacs将在&lt;strong&gt;HOME&lt;/strong&gt;变量指示的目录中查找 &lt;code&gt;.emacs&lt;/code&gt; 文件。如果未设置&lt;strong&gt;HOME&lt;/strong&gt;，则Emacs将在 &lt;code&gt;C:\&lt;/code&gt; 中查找 &lt;code&gt;.emacs&lt;/code&gt; 文件。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b3c1a4e5864dbab572e9a5afb37792b236ea4a2" translate="yes" xml:space="preserve">
          <source>To simplify driver replacement, avoid designing your system so that more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has the driver loaded.</source>
          <target state="translated">为了简化驱动程序的替换，请避免设计系统，以便多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="6657bbbea9ee8b248ced80c3f983940e0a515151" translate="yes" xml:space="preserve">
          <source>To simulate a busy server, you can insert a delay between when &lt;code&gt;epmd&lt;/code&gt; gets notified that a new connection is requested and when the connection gets accepted.</source>
          <target state="translated">为了模拟繁忙的服务器，您可以在 &lt;code&gt;epmd&lt;/code&gt; 收到请求新连接的通知与连接被接受之间插入一个延迟。</target>
        </trans-unit>
        <trans-unit id="70ce8a79d8ffb4771e6a29808f1bcbc9c8b69320" translate="yes" xml:space="preserve">
          <source>To specify if the &lt;code&gt;cover&lt;/code&gt; tool is to be stopped after the test is completed (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指定在测试完成后是否要停止 &lt;code&gt;cover&lt;/code&gt; 工具（请参见 &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f982d3b08151a090766a53c8ae58a0af1c7b2c36" translate="yes" xml:space="preserve">
          <source>To specify in which order groups are to be executed (also with respect to test cases that are not part of any group), add tuples on the form &lt;code&gt;{group,GroupName}&lt;/code&gt; to the &lt;code&gt;all/0&lt;/code&gt; list.</source>
          <target state="translated">要指定按什么顺序执行组（还针对不属于任何组的测试用例），请将格式为 &lt;code&gt;{group,GroupName}&lt;/code&gt; 的元组添加到 &lt;code&gt;all/0&lt;/code&gt; 列表中。</target>
        </trans-unit>
        <trans-unit id="1db9eb6998e57480fd022b5b675c80cbbd9dce31" translate="yes" xml:space="preserve">
          <source>To specify starting line for scanning in document which contains fragments of XML.</source>
          <target state="translated">指定包含 XML 片段的文档的扫描起始行。</target>
        </trans-unit>
        <trans-unit id="f61119c7e1b2cdde6ff6d2fa7c86881726228a8c" translate="yes" xml:space="preserve">
          <source>To specify the modules to be included in the code coverage test, provide a cover specification file. With this file you can point out specific modules or specify directories containing modules to be included in the analysis. You can also specify modules to be excluded from the analysis.</source>
          <target state="translated">要指定要包含在代码覆盖测试中的模块,请提供一个封面规范文件。通过这个文件,您可以指出特定的模块,或者指定包含模块的目录,以便包含在分析中。您也可以指定要从分析中排除的模块。</target>
        </trans-unit>
        <trans-unit id="a7e24433e118f3675a94b0839832059d75700c72" translate="yes" xml:space="preserve">
          <source>To specify which PLT, use option &lt;code&gt;--plt&lt;/code&gt;.</source>
          <target state="translated">要指定哪个PLT，请使用选项 &lt;code&gt;--plt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d24b6fe052b97ca4a3faae65960b6ff118b488" translate="yes" xml:space="preserve">
          <source>To speed up the execution of &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt;, first call &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt;, using option &lt;code&gt;purge&lt;/code&gt;. This does the same check for old code. Then purges all modules that can be soft-purged. The purged modules do then no longer have any old code, and &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; does not need to do the checks.</source>
          <target state="translated">为了加快 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 的执行速度，请先使用选项 &lt;code&gt;purge&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt; 。对旧代码执行相同的检查。然后清除所有可以软清除的模块。然后，清除的模块不再具有任何旧代码，并且 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 不需要进行检查。</target>
        </trans-unit>
        <trans-unit id="bcb51d3d9e102b6569769ee6c7abeefeaf086476" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first information in a sequence.</source>
          <target state="translated">要启动顺序跟踪,用户必须在进程中明确设置跟踪令牌,该令牌将发送顺序中的第一个信息。</target>
        </trans-unit>
        <trans-unit id="881ed36f05e94ae0a21c8004b304eb3bc37646d6" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first message in a sequence.</source>
          <target state="translated">要启动顺序跟踪,用户必须在将发送顺序中第一条消息的进程中明确设置跟踪令牌。</target>
        </trans-unit>
        <trans-unit id="76f1852c3add5606a83bf5fb3f21588a546c38d4" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在远程节点上启动类似的跟踪器，请使用 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af5676be701d6ebffdcd18fcceb076e666de274b" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要在远程节点上启动类似的跟踪器，请使用 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="069df5419adf0afb2c7538e01048c5b636cbd10a" translate="yes" xml:space="preserve">
          <source>To start all applications specified in the original &lt;code&gt;mysystem.rel&lt;/code&gt; file, use flag &lt;code&gt;-boot&lt;/code&gt; as follows:</source>
          <target state="translated">要开始在原指定的所有应用程序 &lt;code&gt;mysystem.rel&lt;/code&gt; 文件，使用标志 &lt;code&gt;-boot&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="c6430f32849bacfbbbfdd73794b90f8a5cb5633c" translate="yes" xml:space="preserve">
          <source>To start an &lt;strong&gt;embedded target system&lt;/strong&gt;, the shell script &lt;code&gt;bin/start&lt;/code&gt; is used. The script calls &lt;code&gt;bin/run_erl&lt;/code&gt;, which in turn calls &lt;code&gt;bin/start_erl&lt;/code&gt; (roughly, &lt;code&gt;start_erl&lt;/code&gt; is an embedded variant of &lt;code&gt;erl&lt;/code&gt;).</source>
          <target state="translated">要启动&lt;strong&gt;嵌入式目标系统&lt;/strong&gt;，请使用shell脚本 &lt;code&gt;bin/start&lt;/code&gt; 。该脚本调用 &lt;code&gt;bin/run_erl&lt;/code&gt; ，而后者又调用 &lt;code&gt;bin/start_erl&lt;/code&gt; （大致上， &lt;code&gt;start_erl&lt;/code&gt; 是 &lt;code&gt;erl&lt;/code&gt; 的嵌入式变体）。</target>
        </trans-unit>
        <trans-unit id="9d22fc7b6b61af9ef2d6145dba2c1c36bbe3774d" translate="yes" xml:space="preserve">
          <source>To start an event manager for handling errors, as described in the previous example, call the following function:</source>
          <target state="translated">要启动一个用于处理错误的事件管理器,如前面的例子所述,调用以下函数。</target>
        </trans-unit>
        <trans-unit id="65443b4fc91dab6b76dab71d1d80de342db77ebd" translate="yes" xml:space="preserve">
          <source>To start the &lt;code&gt;Company&lt;/code&gt; database and get it running on the two specified nodes, enter the following commands:</source>
          <target state="translated">要启动 &lt;code&gt;Company&lt;/code&gt; 数据库并使它在两个指定的节点上运行，请输入以下命令：</target>
        </trans-unit>
        <trans-unit id="b812e0ece5117a4dc75569139c24b19927c8e4d0" translate="yes" xml:space="preserve">
          <source>To start the debug enabled runtime system execute:</source>
          <target state="translated">要启动启用调试的运行时系统执行。</target>
        </trans-unit>
        <trans-unit id="7fffc54b92267ef311f536c196ba13936bd59530" translate="yes" xml:space="preserve">
          <source>To start the interactive shell mode, start an Erlang shell manually and call &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; to install any configuration data you might need (use &lt;code&gt;[]&lt;/code&gt; as argument otherwise). Then call &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">要启动交互式shell模式，请手动启动Erlang shell并调用 &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; 来安装您可能需要的任何配置数据（否则使用 &lt;code&gt;[]&lt;/code&gt; 作为参数）。然后调用 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 启动 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2407e72a3ed0dce989e1ddb620f5b91d6fb2b5a8" translate="yes" xml:space="preserve">
          <source>To start, open a registry:</source>
          <target state="translated">首先,打开一个注册表。</target>
        </trans-unit>
        <trans-unit id="37329084650848867e8284198738d0867fe2834a" translate="yes" xml:space="preserve">
          <source>To stop Erlang Top, use function &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要停止Erlang Top，请使用功能 &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a960f069bc98edbba1ff0928e02093c32ffad4" translate="yes" xml:space="preserve">
          <source>To stop a distributed application, &lt;code&gt;stop/1&lt;/code&gt; must be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to &lt;code&gt;stop/1&lt;/code&gt; on the node where the application currently executes stops its execution. The application is not moved between nodes, as &lt;code&gt;stop/1&lt;/code&gt; is called on the node where the application currently executes before &lt;code&gt;stop/1&lt;/code&gt; is called on the other nodes.</source>
          <target state="translated">要停止分布式应用程序，必须在其可以执行的所有节点上（即，在已启动它的所有节点上）调用 &lt;code&gt;stop/1&lt;/code&gt; 。在应用程序当前执行的节点上对 &lt;code&gt;stop/1&lt;/code&gt; 的调用将停止其执行。本申请并不节点之间移动时，作为 &lt;code&gt;stop/1&lt;/code&gt; 被调用，其中该应用程序之前，执行当前的节点上 &lt;code&gt;stop/1&lt;/code&gt; 被调用的其他节点上。</target>
        </trans-unit>
        <trans-unit id="5b81bcf2bbed22c8b9d584525dc2bbe3c5752e21" translate="yes" xml:space="preserve">
          <source>To stop one or more tests, use function &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (to stop all) or &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要停止一个或多个测试，请使用函数 &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; （停止所有）或 &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b41c55a13290a9e7e9fdbffa7dec308f34e8baa6" translate="yes" xml:space="preserve">
          <source>To stop the Erlang emulator, close the &lt;code&gt;werl&lt;/code&gt; window.</source>
          <target state="translated">要停止Erlang仿真器，请关闭 &lt;code&gt;werl&lt;/code&gt; 窗口。</target>
        </trans-unit>
        <trans-unit id="805a085d9254eb5937e5f4dd565453dd8d6af7f9" translate="yes" xml:space="preserve">
          <source>To sum up this section: &lt;strong&gt;Do not use &lt;code&gt;erlang:now/0&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">总结本节：&lt;strong&gt;不要使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4c3f23c8b7d11fd791f43a0f06c76ab501c60d6" translate="yes" xml:space="preserve">
          <source>To summarize, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; only needs to create &lt;strong&gt;one&lt;/strong&gt; match context and no sub binaries.</source>
          <target state="translated">总而言之， &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 仅需要创建&lt;strong&gt;一个&lt;/strong&gt;匹配上下文，而无需子二进制文件。</target>
        </trans-unit>
        <trans-unit id="76f6d1c7fd98a557f9e7456fd478d01cb713b47b" translate="yes" xml:space="preserve">
          <source>To support Unicode in Erlang, problems in various areas have been addressed. This section describes each area briefly and more thoroughly later in this User's Guide.</source>
          <target state="translated">为了支持Erlang中的Unicode,已经解决了各个领域的问题。本节将在本用户指南中简要介绍每个领域,并在后面更详细地介绍。</target>
        </trans-unit>
        <trans-unit id="490eb8f14b00a3993b65db4b76111ea78b82422f" translate="yes" xml:space="preserve">
          <source>To support the debug facilites in &lt;code&gt;sys&lt;/code&gt;, a &lt;strong&gt;debug structure&lt;/strong&gt; is needed. The &lt;code&gt;Deb&lt;/code&gt; term is initialized using &lt;code&gt;sys:debug_options/1&lt;/code&gt;:</source>
          <target state="translated">为了支持 &lt;code&gt;sys&lt;/code&gt; 中的&lt;strong&gt;调试工具&lt;/strong&gt;，需要一个&lt;strong&gt;调试结构&lt;/strong&gt;。所述 &lt;code&gt;Deb&lt;/code&gt; 术语是使用初始化 &lt;code&gt;sys:debug_options/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="27cb03280676d8f91c2c5f4617f6dcad84db1918" translate="yes" xml:space="preserve">
          <source>To take Erlang down gracefully, see the &lt;code&gt;erl_call(1)&lt;/code&gt; manual page in &lt;code&gt;erl_interface&lt;/code&gt; for details on the use of &lt;code&gt;erl_call&lt;/code&gt;. However, that requires that Erlang runs as a distributed node, which is not always the case.</source>
          <target state="translated">要使Erlang正常运行，请参阅 &lt;code&gt;erl_interface&lt;/code&gt; 中的 &lt;code&gt;erl_call(1)&lt;/code&gt; 手册页，以获取有关 &lt;code&gt;erl_call&lt;/code&gt; 的使用的详细信息。但是，这要求Erlang作为分布式节点运行，但情况并非总是如此。</target>
        </trans-unit>
        <trans-unit id="794cd63b456b29e5f25c1b3a3a1a7cadacb90ffd" translate="yes" xml:space="preserve">
          <source>To test the distribution, the &lt;code&gt;net_kernel:start/1&lt;/code&gt; function can be used. It is useful, as it starts the distribution on a running system, where tracing/debugging can be performed. The &lt;code&gt;net_kernel:start/1&lt;/code&gt; routine takes a list as its single argument. The list first element in the list is to be the node name (without the &quot;@hostname&quot;) as an atom. The second (and last) element is to be one of the atoms &lt;code&gt;shortnames&lt;/code&gt; or &lt;code&gt;longnames&lt;/code&gt;. In the example case, &lt;code&gt;shortnames&lt;/code&gt; is preferred.</source>
          <target state="translated">要测试分发，可以使用 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 函数。这很有用，因为它可以在运行中的系统上开始分发，可以在其中执行跟踪/调试。该 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 例行取一个列表作为它的一个参数。列表中列表的第一个元素是作为原子的节点名称（不带&amp;ldquo; @hostname&amp;rdquo;）。第二个（也是最后一个）元素将成为原子 &lt;code&gt;shortnames&lt;/code&gt; 或 &lt;code&gt;longnames&lt;/code&gt; 之一。在示例情况下， &lt;code&gt;shortnames&lt;/code&gt; 是首选。</target>
        </trans-unit>
        <trans-unit id="1e25ada887f1b7f960ffeb09cb03b19c929e33ba" translate="yes" xml:space="preserve">
          <source>To the extent that it's practical, support SystemTap on Linux via DTrace provider compatibility.</source>
          <target state="translated">在切实可行的范围内,通过 DTrace 提供商的兼容性来支持 Linux 上的 SystemTap。</target>
        </trans-unit>
        <trans-unit id="250e07e289185ee8c7406f121d27b06d85769339" translate="yes" xml:space="preserve">
          <source>To the left of the &lt;code&gt;:=&lt;/code&gt; is the name of the specific instruction that should be implemented by the fragments, in this case &lt;code&gt;i_increment&lt;/code&gt;. To the right of &lt;code&gt;:=&lt;/code&gt; is the name of the group with the fragments, followed by a &lt;code&gt;.&lt;/code&gt;. Then the name of the fragments in the group are listed in the order they should be executed. Note that the &lt;code&gt;head&lt;/code&gt; fragment is not listed.</source>
          <target state="translated">&lt;code&gt;:=&lt;/code&gt; 左边是应该由片段实现的特定指令的名称，在这种情况下为 &lt;code&gt;i_increment&lt;/code&gt; 。 &lt;code&gt;:=&lt;/code&gt; 右边是带有片段的组的名称，后跟一个 &lt;code&gt;.&lt;/code&gt; 。然后，按照应执行的顺序列出组中片段的名称。请注意， &lt;code&gt;head&lt;/code&gt; 片段未列出。</target>
        </trans-unit>
        <trans-unit id="fded3aabb510b1e1a75f760a53342f304a3c739e" translate="yes" xml:space="preserve">
          <source>To to start the application (agent and/or manager), the configuration files must be modified and there are two ways of doing this. Either edit the files manually, or run the configuration tool as follows.</source>
          <target state="translated">要启动应用程序(代理和/或管理器),必须修改配置文件,有两种方法。手动编辑文件,或者运行配置工具,如下所示。</target>
        </trans-unit>
        <trans-unit id="840859542432e2ae9a768d1a2567eb03227d2acc" translate="yes" xml:space="preserve">
          <source>To trace function calls, you also need to set up &lt;strong&gt;trace patterns&lt;/strong&gt;. Trace patterns select the function calls to be traced. The number of traced function calls can be further reduced with &lt;strong&gt;match specifications&lt;/strong&gt;. Match specifications can also be used to trigger more information in the trace messages.</source>
          <target state="translated">要跟踪函数调用，还需要设置&lt;strong&gt;跟踪模式&lt;/strong&gt;。跟踪模式选择要跟踪的函数调用。&lt;strong&gt;匹配规范&lt;/strong&gt;可以进一步减少跟踪的函数调用的数量。匹配规范还可用于触发跟踪消息中的更多信息。</target>
        </trans-unit>
        <trans-unit id="0c07cb7f2e8d2563df9d5fc9199e90556dc33e70" translate="yes" xml:space="preserve">
          <source>To trigger file compression, its extension must match with the &lt;code&gt;compress&lt;/code&gt; condition and must not match the &lt;code&gt;uncompress&lt;/code&gt; condition. For example, if &lt;code&gt;compress&lt;/code&gt; is set to &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; is set to &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt;, only files with extension &lt;code&gt;&quot;gif&quot;&lt;/code&gt; are compressed.</source>
          <target state="translated">要触发文件压缩，其扩展名必须与 &lt;code&gt;compress&lt;/code&gt; 条件匹配，并且必须与 &lt;code&gt;uncompress&lt;/code&gt; 条件不匹配。例如，如果 &lt;code&gt;compress&lt;/code&gt; 设置为 &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; ， &lt;code&gt;uncompress&lt;/code&gt; 设置为 &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt; ，则仅扩展名为 &lt;code&gt;&quot;gif&quot;&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="bdcf647abab37b8b3f8542efaeba10430ea6f745" translate="yes" xml:space="preserve">
          <source>To turn off the Debugger stack trace facility, select option &lt;strong&gt;Stack Off&lt;/strong&gt;.</source>
          <target state="translated">要关闭调试器堆栈跟踪工具，请选择选项&lt;strong&gt;Stack Off&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="25889e4ee1555771488e4d2de1a7bf2d51b5a3ab" translate="yes" xml:space="preserve">
          <source>To turn off warnings for improper lists, add the following line to the source file:</source>
          <target state="translated">要关闭不当列表的警告,请在源文件中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="8ed98f94cb168a3368774c5de90ad9aac72676b6" translate="yes" xml:space="preserve">
          <source>To understand the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup, it is essential to understand how &lt;code&gt;Mnesia&lt;/code&gt; reacts when it loses contact with &lt;code&gt;Mnesia&lt;/code&gt; on another node. At this stage, &lt;code&gt;Mnesia&lt;/code&gt; cannot distinguish between a communication failure and a &quot;normal&quot; node-down. When this occurs, &lt;code&gt;Mnesia&lt;/code&gt; assumes that the other node is no longer running, whereas, in reality, the communication between the nodes has failed.</source>
          <target state="translated">要了解 &lt;code&gt;Mnesia&lt;/code&gt; 在启动时的行为，必须了解 &lt;code&gt;Mnesia&lt;/code&gt; 在与另一个节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 失去联系时的反应。在此阶段， &lt;code&gt;Mnesia&lt;/code&gt; 无法区分通信失败和&amp;ldquo;正常&amp;rdquo;节点中断。发生这种情况时， &lt;code&gt;Mnesia&lt;/code&gt; 假定另一个节点不再运行，而实际上，这些节点之间的通信已失败。</target>
        </trans-unit>
        <trans-unit id="57ca1753f443dcffddf87cab0a01f1c5e59426d5" translate="yes" xml:space="preserve">
          <source>To understand this text, you also have to look at the &lt;code&gt;yacc&lt;/code&gt; documentation in the UNIX(TM) manual. This is most probably necessary in order to understand the idea of a parser generator, and the principle and problems of LALR parsing with finite look-ahead.</source>
          <target state="translated">要理解本文，您还必须查看UNIX&amp;trade;手册中的 &lt;code&gt;yacc&lt;/code&gt; 文档。为了理解解析器生成器的概念以及有限提前预知的LALR解析的原理和问题，这很有可能是必需的。</target>
        </trans-unit>
        <trans-unit id="257c2b917b12b68949e96a87bad80aa179cede62" translate="yes" xml:space="preserve">
          <source>To understand what is discussed and examplified here, we recommended you to first read section &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要了解此处讨论和例证的内容，我们建议您首先阅读&amp;ldquo; &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="c214f91d106ddf617278abe4918056162b083c9a" translate="yes" xml:space="preserve">
          <source>To unload it use crypto:ensure_engine_unloaded/1 which removes the ID from the internal list before unloading the engine.</source>
          <target state="translated">要卸载它,使用crypto:sure_engine_unloaded/1,它在卸载引擎之前从内部列表中删除ID。</target>
        </trans-unit>
        <trans-unit id="a0d1537131067c43e7df0631cf8f01ef0dfa991f" translate="yes" xml:space="preserve">
          <source>To unregister a name:</source>
          <target state="translated">要取消注册一个名字:</target>
        </trans-unit>
        <trans-unit id="2d2a671d4b2f16d7f91c51ff47e2d4c92fb46607" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">要注销已发布的节点，应关闭 &lt;code&gt;ei_publish()&lt;/code&gt; 返回的描述符。</target>
        </trans-unit>
        <trans-unit id="f3c7fc1b435a8defaf215479b11edd52150783be" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should instead close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">要取消注册已发布的节点，您应该关闭 &lt;code&gt;ei_publish()&lt;/code&gt; 返回的描述符。</target>
        </trans-unit>
        <trans-unit id="2b518c28463d854508111ea65fca22a57c4c2cf2" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor.</source>
          <target state="translated">要取消在EPMD的注册,只需关闭返回的描述符即可。</target>
        </trans-unit>
        <trans-unit id="769d2fa177fb9e7db683f9606bab6d12279b1eda" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor. Do not use &lt;code&gt;ei_unpublish()&lt;/code&gt;, which is deprecated anyway.</source>
          <target state="translated">要注销EPMD，只需关闭返回的描述符。请勿使用 &lt;code&gt;ei_unpublish()&lt;/code&gt; ，无论如何都不要使用它。</target>
        </trans-unit>
        <trans-unit id="84b4679c04fbfbaa9588413bb040c5640c41eacc" translate="yes" xml:space="preserve">
          <source>To upgrade &lt;code&gt;ch_app&lt;/code&gt; from &lt;code&gt;&quot;1&quot;&lt;/code&gt; to &lt;code&gt;&quot;2&quot;&lt;/code&gt; (and to downgrade from &lt;code&gt;&quot;2&quot;&lt;/code&gt; to &lt;code&gt;&quot;1&quot;&lt;/code&gt;), you only need to load the new (old) version of the &lt;code&gt;ch3&lt;/code&gt; callback module. Create the application upgrade file &lt;code&gt;ch_app.appup&lt;/code&gt; in the &lt;code&gt;ebin&lt;/code&gt; directory:</source>
          <target state="translated">要将 &lt;code&gt;ch_app&lt;/code&gt; 从 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 升级到 &lt;code&gt;&quot;2&quot;&lt;/code&gt; （并从 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 降级到 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ），您只需要加载 &lt;code&gt;ch3&lt;/code&gt; 回调模块的新（旧）版本。在 &lt;code&gt;ebin&lt;/code&gt; 目录中创建应用程序升级文件 &lt;code&gt;ch_app.appup&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9c873673fdbf39b186e8a04df81cc090fc729ac9" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to a TLS connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">要将TCP/IP连接升级为TLS连接,客户端和服务器必须同意这样做。该协议可以通过使用RFC 2817中规定的HTTP等协议来完成。</target>
        </trans-unit>
        <trans-unit id="f84bf7f2f7861b776ed5c35e1c7e32583ad5a627" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to an SSL connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">要将TCP/IP连接升级为SSL连接,客户端和服务器必须同意这样做。该协议可通过使用RFC 2817中指定的HTTP等协议来完成。</target>
        </trans-unit>
        <trans-unit id="cd3aeb788d6c5ac30b033b2b969b7da351f17b7f" translate="yes" xml:space="preserve">
          <source>To upgrade to a TLS connection:</source>
          <target state="translated">要升级到TLS连接。</target>
        </trans-unit>
        <trans-unit id="3a48c54fe1c18b840875cc0d8882a5c73ce80e02" translate="yes" xml:space="preserve">
          <source>To upgrade to an SSL connection:</source>
          <target state="translated">要升级到SSL连接。</target>
        </trans-unit>
        <trans-unit id="ea7b425544bac4acf2d4b893b416d117aa7a59a1" translate="yes" xml:space="preserve">
          <source>To use Debugger, the basic steps are as follows:</source>
          <target state="translated">要使用Debugger,基本步骤如下。</target>
        </trans-unit>
        <trans-unit id="68fe3f1ab7b67db6b1b7b0c723fb8ab99d7ba09b" translate="yes" xml:space="preserve">
          <source>To use a literal &lt;code&gt;*&lt;/code&gt; character as &lt;code&gt;Pad&lt;/code&gt;, it must be passed as an argument:</source>
          <target state="translated">要将文字 &lt;code&gt;*&lt;/code&gt; 用作 &lt;code&gt;Pad&lt;/code&gt; ，必须将其作为参数传递：</target>
        </trans-unit>
        <trans-unit id="818b4f8cff2ed9c56e379af0203202630de033f4" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following line in your code:</source>
          <target state="translated">要使用任何 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数，请在代码中包含以下行：</target>
        </trans-unit>
        <trans-unit id="bfffbe9810584067e7d160ff8bce5770cf34f906" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following lines in your code:</source>
          <target state="translated">要使用任何 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数，请在代码中包含以下几行：</target>
        </trans-unit>
        <trans-unit id="e865188bf7a27ada82ac1699872c1f2decf0665c" translate="yes" xml:space="preserve">
          <source>To use encrypted debug information, a key must be provided to the compiler and &lt;code&gt;beam_lib&lt;/code&gt;. The key is specified as a string. It is recommended that the string contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used.</source>
          <target state="translated">要使用加密的调试信息，必须向编译器和 &lt;code&gt;beam_lib&lt;/code&gt; 提供密钥。键指定为字符串。建议该字符串至少包含32个字符，并且同时使用大写和小写字母以及数字和特殊字符。</target>
        </trans-unit>
        <trans-unit id="eb23e34638bd9093d10ee97bb3a0e372512e3fc8" translate="yes" xml:space="preserve">
          <source>To use event handlers written for &lt;code&gt;error_logger&lt;/code&gt;, just add your event handler with</source>
          <target state="translated">要使用为 &lt;code&gt;error_logger&lt;/code&gt; 编写的事件处理程序，只需添加带有</target>
        </trans-unit>
        <trans-unit id="0bdc7b110d3152a509f4766a597abefcfa1ed87d" translate="yes" xml:space="preserve">
          <source>To use the Erlang shell to run our test, you can evaluate the following call:</source>
          <target state="translated">要使用Erlang shell来运行我们的测试,你可以评估以下调用。</target>
        </trans-unit>
        <trans-unit id="0f4462aadd9025ab266be32a2032bf299d0b46f7" translate="yes" xml:space="preserve">
          <source>To use the disk_log handler instead of the default standard handler when starting an Erlang node, change the Kernel default logger to use &lt;code&gt;logger_disk_log_h&lt;/code&gt;. Example:</source>
          <target state="translated">要在启动Erlang节点时使用disk_log处理程序而不是默认的标准处理程序，请将内核默认记录程序更改为使用 &lt;code&gt;logger_disk_log_h&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="48d471ac0f461634b1a46f1744c359ab442ae3b1" translate="yes" xml:space="preserve">
          <source>To use the functions &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;release_shell&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">要使用功能 &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt; ，&lt;strong&gt;必须&lt;/strong&gt;将 &lt;code&gt;release_shell&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d698f2ffb5c429ffda0ac4557a52f1824b92cf1d" translate="yes" xml:space="preserve">
          <source>To use the pseudo functions triggering the translation, ensure to include the header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code. Failure to do so possibly results in runtime errors rather than compile time, as the expression can be valid as a plain Erlang program without translation.</source>
          <target state="translated">要使用触发转换的伪函数，请确保在源代码中包含头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 。未能执行此操作可能会导致运行时错误，而不是编译时，因为该表达式可以作为普通的Erlang程序有效而无需翻译。</target>
        </trans-unit>
        <trans-unit id="03f67b62fca597162026995f6815a18764fa1055" translate="yes" xml:space="preserve">
          <source>To use the real implementation, we must recompile the MIB and load it into the agent.</source>
          <target state="translated">为了使用真正的实现,我们必须重新编译MIB并将其加载到代理中。</target>
        </trans-unit>
        <trans-unit id="d6519596ccb4c5e8b4c324416978687438404d59" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt; driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">使用此功能添加驻留在动态加载的代码中的驱动程序很危险。如果添加的驱动程序的驱动程序代码与普通的动态加载的驱动程序（通过 &lt;code&gt;erl_ddll&lt;/code&gt; 接口加载）位于同一动态加载的模块（即 &lt;code&gt;.so&lt;/code&gt; 文件）中，则调用者将在添加驱动程序条目之前调用 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt; driver_lock_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="002952436d64ac58aa3de156b66387b85dc58e15" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">使用此功能添加驻留在动态加载的代码中的驱动程序很危险。如果添加的驱动程序的驱动程序代码与普通的动态加载的驱动程序（通过 &lt;code&gt;erl_ddll&lt;/code&gt; 接口加载）位于同一动态加载的模块（即 &lt;code&gt;.so&lt;/code&gt; 文件）中，则调用者将在添加驱动程序条目之前调用 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06c29935ed139b37075ecc2db062cd1dfb073f59" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute in both phases is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要使用此模式，请确保将在两个阶段中都执行的所有Erlang代码都是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af48a71f55d5ffa8ab787fda3994e5f52dec889c" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute on the runtime system is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要使用此模式，请确保将在运行时系统上执行的所有Erlang代码都是 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="847b164165eea8a7ac372dcfbedc4f6fbc9d1539" translate="yes" xml:space="preserve">
          <source>To use this program, you need to:</source>
          <target state="translated">要使用这个程序,你需要:</target>
        </trans-unit>
        <trans-unit id="6a7e1aba43c701aa62b9243d847578c39295abed" translate="yes" xml:space="preserve">
          <source>To use this with threads and asynchronous routines, create a pipe on Unix and an &lt;code&gt;Event&lt;/code&gt; on Windows. When the routine completes, write to the pipe (use &lt;code&gt;SetEvent&lt;/code&gt; on Windows), this makes the emulator call &lt;code&gt;ready_input&lt;/code&gt; or &lt;code&gt;ready_output&lt;/code&gt;.</source>
          <target state="translated">要将其用于线程和异步例程，请在Unix上创建管道，在Windows 上创建 &lt;code&gt;Event&lt;/code&gt; 。例程完成后，写入管道（在Windows上使用 &lt;code&gt;SetEvent&lt;/code&gt; ），这将使模拟器调用 &lt;code&gt;ready_input&lt;/code&gt; 或 &lt;code&gt;ready_output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01b8773f5a669a11ac026442b354c5f873c02791" translate="yes" xml:space="preserve">
          <source>To validate the configuration strings, the callback module is to have function &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; exported.</source>
          <target state="translated">为了验证配置字符串，回调模块将导出函数 &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe32e508b386431ed270d6f4036397947cfdf797" translate="yes" xml:space="preserve">
          <source>To verify that everything is ok you should open &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; in your web browser and make sure that there are zero failed test cases.</source>
          <target state="translated">要验证一切正常，您应该在网络浏览器中打开 &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; 并确保失败的测试用例为零。</target>
        </trans-unit>
        <trans-unit id="816f7f291832fe5da7fded15c95dc5548b14b744" translate="yes" xml:space="preserve">
          <source>To verify that lock counting is enabled check that &lt;code&gt;[lock-counting]&lt;/code&gt; appears in the status text when the VM is started.</source>
          <target state="translated">要验证是否启用了锁定计数，请在启动VM时检查 &lt;code&gt;[lock-counting]&lt;/code&gt; 是否出现在状态文本中。</target>
        </trans-unit>
        <trans-unit id="d79825059ed41d40f1eb38140584c29e49d43c05" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific module, double- click the row, or right-click it and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要查看有关特定模块的详细信息，请双击该行，或右键单击该行，然后&lt;strong&gt;为&amp;lt;mod&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e3ee7cdc20eb34f07a508b3dffa9cad2da375fa2" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific process, double- click the row in the list, or right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">要查看有关特定过程的详细信息，请双击列表中的行，或右键单击该行，然后&lt;strong&gt;为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f9a2be366e30f8af91ea3157c65f941baf52859b" translate="yes" xml:space="preserve">
          <source>To view more details about a specific port, double-click the row or right-click it and select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;, where &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; is the process connected to the port.</source>
          <target state="translated">要查看有关特定端口的更多详细信息，请双击该行或右键单击该行，然后&lt;strong&gt;为&amp;lt;port&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;。从右键单击菜单，您还可&lt;strong&gt;以为&amp;lt;pid&amp;gt;&lt;/strong&gt;选择&lt;strong&gt;Properties&lt;/strong&gt;，其中 &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; 是连接到端口的进程。</target>
        </trans-unit>
        <trans-unit id="7c537dc716e918cf2d036be1a35d64af3e41081c" translate="yes" xml:space="preserve">
          <source>To view the result of a code coverage test, click the button labeled &quot;COVER LOG&quot; in the top-level index page for the test run.</source>
          <target state="translated">要查看代码覆盖率测试的结果,点击测试运行的顶层索引页中标有 &quot;COVER LOG &quot;的按钮。</target>
        </trans-unit>
        <trans-unit id="254465b8f25a6c97a3848f10e6162c3f124f7768" translate="yes" xml:space="preserve">
          <source>To view the result of macro expansion, a module can be compiled with the &lt;code&gt;'P'&lt;/code&gt; option. &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt;. This produces a listing of the parsed code after preprocessing and parse transforms, in the file &lt;code&gt;File.P&lt;/code&gt;.</source>
          <target state="translated">要查看宏扩展的结果，可以使用 &lt;code&gt;'P'&lt;/code&gt; 选项编译模块。 &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt; 。经过预处理和解析转换后，这将在文件 &lt;code&gt;File.P&lt;/code&gt; 中生成一份已解析代码的列表。</target>
        </trans-unit>
        <trans-unit id="2863e2789d755b777cac4c624de8395bb36a4b90" translate="yes" xml:space="preserve">
          <source>To visualize the structure of a syntax tree, you can use the function &lt;code&gt;merl:show(T)&lt;/code&gt;, which prints a summary. For example, entering</source>
          <target state="translated">要形象化语法树的结构，可以使用函数 &lt;code&gt;merl:show(T)&lt;/code&gt; ，该函数将打印摘要。例如，输入</target>
        </trans-unit>
        <trans-unit id="420f383fbb828ef9ba78290b1722db9b09af55f0" translate="yes" xml:space="preserve">
          <source>To work with binaries in ISO Latin-1 encoding, use the &lt;code&gt;file&lt;/code&gt; module instead.</source>
          <target state="translated">要使用ISO Latin-1编码的二进制文件，请改用 &lt;code&gt;file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="9368499385b79811c6e242f08579ba92f510e423" translate="yes" xml:space="preserve">
          <source>To write a function that inserts an employee record into the database, there must be an &lt;code&gt;at_dep&lt;/code&gt; record and a set of &lt;code&gt;in_proj&lt;/code&gt; records inserted. Examine the following code used to complete this action:</source>
          <target state="translated">要编写将员工记录插入数据库的函数，必须有一个 &lt;code&gt;at_dep&lt;/code&gt; 记录和一组 &lt;code&gt;in_proj&lt;/code&gt; 记录。检查以下用于完成此操作的代码：</target>
        </trans-unit>
        <trans-unit id="870bc92e8fb7bb157e38a72767baac7170c3e8c4" translate="yes" xml:space="preserve">
          <source>To write functions that manipulate this data, remember the following:</source>
          <target state="translated">要编写操作这些数据的函数,请记住以下几点。</target>
        </trans-unit>
        <trans-unit id="49f4806c44f9e994d710db8f38c6399e247bca8a" translate="yes" xml:space="preserve">
          <source>To write your own client channel handler, use the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt;. For server channel handlers use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; behaviour (replaces ssh_daemon_channel).</source>
          <target state="translated">要编写自己的客户端通道处理程序，请使用行为 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 。对于服务器通道处理程序，请使用 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 行为（代替ssh_daemon_channel）。</target>
        </trans-unit>
        <trans-unit id="f57b7cb4b41a526a6b5b1f9a162d27692ca9284c" translate="yes" xml:space="preserve">
          <source>Today there are no good ways of solving this problem and therefore the eval scheme can be removed in future release of &lt;code&gt;Inets&lt;/code&gt;.</source>
          <target state="translated">今天没有解决此问题的好方法，因此可以在将来的 &lt;code&gt;Inets&lt;/code&gt; 版本中删除评估方案。</target>
        </trans-unit>
        <trans-unit id="7edb68e9d3675d0ca9b5133bc31d9005c2bc6f47" translate="yes" xml:space="preserve">
          <source>Too long external command.</source>
          <target state="translated">外部命令太长。</target>
        </trans-unit>
        <trans-unit id="306ef8d015fe20a0dcd8430c726d60b2b800ac4a" translate="yes" xml:space="preserve">
          <source>Tool Summary</source>
          <target state="translated">工具摘要</target>
        </trans-unit>
        <trans-unit id="b53132babe55797aa27d88cc20db666d7ee40a5b" translate="yes" xml:space="preserve">
          <source>Tools that need to know about optional callback functions can call &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; to get a list of all optional callback functions.</source>
          <target state="translated">需要了解可选回调函数的工具可以调用 &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; 来获取所有可选回调函数的列表。</target>
        </trans-unit>
        <trans-unit id="dd3a74b17c3a112fdfc9b4f6b58e1ba85a6ec96d" translate="yes" xml:space="preserve">
          <source>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by &lt;code&gt;malloc&lt;/code&gt; when &lt;code&gt;sbrk&lt;/code&gt; is called to get more memory from the operating system. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">顶垫大小（以千字节为单位）。这是当调用 &lt;code&gt;sbrk&lt;/code&gt; 从操作系统获取更多内存时， &lt;code&gt;malloc&lt;/code&gt; 分配的额外内存量。默认为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8688b9f02fc264d86ffee1ffffdff34e5d5032b9" translate="yes" xml:space="preserve">
          <source>Total amount of data allocated by an Erlang node</source>
          <target state="translated">一个Erlang节点分配的数据总量。</target>
        </trans-unit>
        <trans-unit id="15b379311d06275e570d3c8276f0c74ac315b01b" translate="yes" xml:space="preserve">
          <source>Total and own</source>
          <target state="translated">合计和自己</target>
        </trans-unit>
        <trans-unit id="c2270f01832f95299124e422ec6e4ca5b86124d0" translate="yes" xml:space="preserve">
          <source>Total memory of all fragments</source>
          <target state="translated">所有碎片的总内存</target>
        </trans-unit>
        <trans-unit id="7e54e8f9975c397f222301a7b10e36746a3fb103" translate="yes" xml:space="preserve">
          <source>Total scheduler utilization will equal &lt;code&gt;1.0&lt;/code&gt; when all schedulers have been active all the time between the two measurements.</source>
          <target state="translated">当两次测量之间所有时间的所有调度程序都处于活动状态时，调度程序的总利用率将等于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f139724c9414120075277ba75a5a2d7bac69ee" translate="yes" xml:space="preserve">
          <source>Total size of all fragments</source>
          <target state="translated">所有碎片的总尺寸</target>
        </trans-unit>
        <trans-unit id="3d7796a77f0c2216ea352ac72490e4ec4449ab38" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers, weighted against maximum amount of available CPU time.</source>
          <target state="translated">所有正常和 dirty-cpu 调度器的总利用率,根据最大可用 CPU 时间加权。</target>
        </trans-unit>
        <trans-unit id="6da5bac4a207bc853f48fee09219f38e35859ae6" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers.</source>
          <target state="translated">所有正常和肮脏的CPU调度器的总利用率。</target>
        </trans-unit>
        <trans-unit id="9bff8a7fc7360671cf907e56ce21842e96c20fad" translate="yes" xml:space="preserve">
          <source>TotalRunQueueLengths</source>
          <target state="translated">TotalRunQueueLengths</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="b977e923c4efbcbf64ad078300b599a2f20c534b" translate="yes" xml:space="preserve">
          <source>Trace Messages Sent to the System Tracer</source>
          <target state="translated">发送到系统跟踪器的跟踪信息</target>
        </trans-unit>
        <trans-unit id="0588c9e7ac9a2b21ded90cbcf26c439c837482b1" translate="yes" xml:space="preserve">
          <source>Trace Token</source>
          <target state="translated">追踪令牌</target>
        </trans-unit>
        <trans-unit id="80bb48f4677c815e975d8c45891c82e4681bcb89" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder</source>
          <target state="translated">跟踪工具生成器</target>
        </trans-unit>
        <trans-unit id="250a4f0c0db1541060f17b5d70ba72e38869d686" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder is a base for building trace tools for single node or distributed Erlang systems. It requires the Runtime_Tools application to be available on the traced node.</source>
          <target state="translated">跟踪工具生成器是为单节点或分布式Erlang系统构建跟踪工具的基础。它要求被跟踪的节点上有Runtime_Tools应用程序。</target>
        </trans-unit>
        <trans-unit id="d0e39bcc8d71bbaa0fa6b28e8699f8f1993f5c4d" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;arity&lt;/code&gt; can be used to change the contents of this message, so that &lt;code&gt;Arity&lt;/code&gt; is specified instead of &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">跟踪标志 &lt;code&gt;arity&lt;/code&gt; 可用于更改此消息的内容，以便指定 &lt;code&gt;Arity&lt;/code&gt; 而不是 &lt;code&gt;Args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2211485216352092a3c7b3ce77ba8fdb799ae23c" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;call&lt;/code&gt; is set on all processes. This means that any function activated with command &lt;code&gt;trc/1&lt;/code&gt; is traced on all existing and new processes.</source>
          <target state="translated">在所有进程上都设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; 。这意味着在所有现有和新进程上都将跟踪使用命令 &lt;code&gt;trc/1&lt;/code&gt; 激活的任何功能。</target>
        </trans-unit>
        <trans-unit id="0712efc6140a7fd34097a10dbcb83e8a2711b2c0" translate="yes" xml:space="preserve">
          <source>Trace garbage collection on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; that prints start, stop, and the time spent for each garbage collection.</source>
          <target state="translated">跟踪指定进程上的垃圾回收。所使用的格式处理程序是 &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; ，它显示开始，停止以及每个垃圾收集所花费的时间。</target>
        </trans-unit>
        <trans-unit id="8ad201247194a3bc5c13be5040f0d1b1e662cf18" translate="yes" xml:space="preserve">
          <source>Trace in-scheduling and out-scheduling on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; that prints each in-scheduling and out-scheduling with process, time-stamp, and current function. It also prints the total time each traced process was scheduled in.</source>
          <target state="translated">跟踪指定进程的计划内和计划外。所使用的格式处理程序是 &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; ，它使用进程，时间戳和当前函数打印每个按计划和按计划进行的计划和计划。它还会打印计划每个跟踪进程的总时间。</target>
        </trans-unit>
        <trans-unit id="ffc9984032978aa3b6449468569d3553d6cf5759" translate="yes" xml:space="preserve">
          <source>Trace messages:</source>
          <target state="translated">追踪信息。</target>
        </trans-unit>
        <trans-unit id="4d4722f0d0980b84f26e05618ea2d6105d2b13ac" translate="yes" xml:space="preserve">
          <source>Trace patterns can also be added for traced messages. Click button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt; and select &lt;strong&gt;Messages sent&lt;/strong&gt; or &lt;strong&gt;Messages received&lt;/strong&gt;, and a match specification.</source>
          <target state="translated">也可以为跟踪的邮件添加跟踪模式。单击按钮&lt;strong&gt;添加跟踪模式，&lt;/strong&gt;然后选择&lt;strong&gt;发送的&lt;/strong&gt;&lt;strong&gt;消息&lt;/strong&gt;或&lt;strong&gt;接收的消息&lt;/strong&gt;，以及匹配规范。</target>
        </trans-unit>
        <trans-unit id="0940d3dfe2f33f718de044f09bc83c6282e8f2ee" translate="yes" xml:space="preserve">
          <source>Trace patterns only apply to the traced processes and ports.</source>
          <target state="translated">跟踪模式只适用于被跟踪的进程和端口。</target>
        </trans-unit>
        <trans-unit id="2a9473289ba2f7fdb4aceac50e9847d3fb9343a9" translate="yes" xml:space="preserve">
          <source>Trace patterns specify how to trace a function or a message by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">跟踪模式指定如何通过使用匹配规范来跟踪功能或消息。比赛规格在《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="a02e22fba6caaac8c0531907ae75bbb4f037b1bf" translate="yes" xml:space="preserve">
          <source>Traces &lt;code&gt;Item&lt;/code&gt; in accordance to the value specified by &lt;code&gt;Flags&lt;/code&gt;. The variation of &lt;code&gt;Item&lt;/code&gt; is listed below:</source>
          <target state="translated">根据 &lt;code&gt;Flags&lt;/code&gt; 指定的值跟踪 &lt;code&gt;Item&lt;/code&gt; 。以下列出了 &lt;code&gt;Item&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="3d4251419a7232d0215690c25726bd1d8598264d" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">跟踪某些函数调用。通过调用 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 来指定要跟踪的函数。</target>
        </trans-unit>
        <trans-unit id="8d86b88eb80a4cb0c1e2e56d320a47a7c0a552ac" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">跟踪某些函数调用。通过调用 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 来指定要跟踪的函数。</target>
        </trans-unit>
        <trans-unit id="e6a38811b152556838705c34470f7050c3304700" translate="yes" xml:space="preserve">
          <source>Traces garbage collections of processes.</source>
          <target state="translated">追踪进程的垃圾收集。</target>
        </trans-unit>
        <trans-unit id="0bfeea5f77e5e80144fb5c69582ff8a4c4aa0a8c" translate="yes" xml:space="preserve">
          <source>Traces global function calls for the process according to the trace patterns set in the system (see tp/2).</source>
          <target state="translated">根据系统中设置的跟踪模式,跟踪进程的全局函数调用(见tp/2)。</target>
        </trans-unit>
        <trans-unit id="7b9365396596fa47926ca8347796645d68615fc5" translate="yes" xml:space="preserve">
          <source>Traces port related events to the port.</source>
          <target state="translated">追踪与端口相关的事件。</target>
        </trans-unit>
        <trans-unit id="9984d03ffd8c79d353ed1035134b4b78d308578d" translate="yes" xml:space="preserve">
          <source>Traces port-related events.</source>
          <target state="translated">追踪与端口相关的事件。</target>
        </trans-unit>
        <trans-unit id="53c6e4ac66fc9e05350a56f9ce0407168d386402" translate="yes" xml:space="preserve">
          <source>Traces process related events to the process.</source>
          <target state="translated">追踪与流程相关的事件。</target>
        </trans-unit>
        <trans-unit id="29908912e6fff8dc5249509363a4412791547f21" translate="yes" xml:space="preserve">
          <source>Traces process-related events.</source>
          <target state="translated">追踪与流程相关的事件。</target>
        </trans-unit>
        <trans-unit id="5fea32fcd1026ba95b7747cfa7687d7877ce29fa" translate="yes" xml:space="preserve">
          <source>Traces receiving of messages.</source>
          <target state="translated">追踪信息的接收情况。</target>
        </trans-unit>
        <trans-unit id="cc07cb20090b0accf4d5bc83ba241371cabc9b3a" translate="yes" xml:space="preserve">
          <source>Traces scheduling of exiting processes.</source>
          <target state="translated">对退出的进程进行跟踪调度。</target>
        </trans-unit>
        <trans-unit id="67d22b046457a4e977f4835a302c705d01e90b51" translate="yes" xml:space="preserve">
          <source>Traces scheduling of ports.</source>
          <target state="translated">追踪港口的调度情况。</target>
        </trans-unit>
        <trans-unit id="2f48a05431b99fc7b0ddcdfbdc7ffb069ba16117" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes just like &lt;code&gt;running&lt;/code&gt;. However, this option also includes schedule events when the process executes within the context of a port without being scheduled out itself.</source>
          <target state="translated">跟踪进程的调度，就像 &lt;code&gt;running&lt;/code&gt; 一样。但是，当进程在端口上下文中执行而自身未计划时，此选项还包括计划事件。</target>
        </trans-unit>
        <trans-unit id="7ce958853f2f4b0ef08e9d0a61efd87ba237714e" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes.</source>
          <target state="translated">追踪进程的调度。</target>
        </trans-unit>
        <trans-unit id="c4c7172939e3bf7fce3abeb0aee363e0caeecf04" translate="yes" xml:space="preserve">
          <source>Traces sending of messages.</source>
          <target state="translated">追踪信息的发送。</target>
        </trans-unit>
        <trans-unit id="47adf62bbb5b7db2ff2d321ec8c4e3902e48036a" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives and sends.</source>
          <target state="translated">追踪进程或端口接收和发送的消息。</target>
        </trans-unit>
        <trans-unit id="139350008a2a0843c976fc5033dee778dfce8767" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives.</source>
          <target state="translated">追踪进程或端口收到的消息。</target>
        </trans-unit>
        <trans-unit id="bd14c1efd1ddeca64fe6450f80e57e6c1564eaab" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port sends.</source>
          <target state="translated">追踪进程或端口发送的消息。</target>
        </trans-unit>
        <trans-unit id="1253e547a3faeb02225fd239c7816e109cca29cf" translate="yes" xml:space="preserve">
          <source>Tracing Local Node from Erlang Shell</source>
          <target state="translated">从Erlang Shell追踪本地节点</target>
        </trans-unit>
        <trans-unit id="c82c46612470fc95ddd9cc9407e733f834757c70" translate="yes" xml:space="preserve">
          <source>Tracing. Trace flags can still be set for the process, but no trace messages of any kind are generated. (If flag &lt;code&gt;sensitive&lt;/code&gt; is turned off, trace messages are again generated if any trace flags are set.)</source>
          <target state="translated">追踪。仍然可以为该进程设置跟踪标志，但是不会生成任何类型的跟踪消息。（如果关闭了标志 &lt;code&gt;sensitive&lt;/code&gt; 功能，那么如果设置了任何跟踪标志，则会再次生成跟踪消息。）</target>
        </trans-unit>
        <trans-unit id="47fc4ea1f09f1ee696b546f14553f696094e6dba" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph.</source>
          <target state="translated">追踪;归档,如上段所述。</target>
        </trans-unit>
        <trans-unit id="41e7b60cc9f2be5dd1ce4620f59c4b34f7bff5d2" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph. The trace contains entries for function calls, returns to function, process scheduling, other process related (spawn, etc) events, and garbage collection. All trace entries are timestamped.</source>
          <target state="translated">追踪;到文件,如前段所述。跟踪包含了函数调用、函数返回、进程调度、其他与进程相关的(产卵等)事件和垃圾收集的条目。所有跟踪条目都有时间戳。</target>
        </trans-unit>
        <trans-unit id="8fe0486a60ee6a3c01827363742db14787a69569" translate="yes" xml:space="preserve">
          <source>Traditionally the Presented IDs were found in the &lt;code&gt;Subject&lt;/code&gt; certificate field as &lt;code&gt;CN&lt;/code&gt; names. This is still quite common. When printing a certificate they show up as:</source>
          <target state="translated">传统上，在 &lt;code&gt;Subject&lt;/code&gt; 证书字段中以 &lt;code&gt;CN&lt;/code&gt; 名称找到Presented ID 。这仍然很普遍。打印证书时，它们显示为：</target>
        </trans-unit>
        <trans-unit id="cd6a9e832dedaac8dfc95165be3ac0b240579c52" translate="yes" xml:space="preserve">
          <source>Transaction properties, which include atomicity, consistency, isolation, and durability</source>
          <target state="translated">事务属性,包括原子性、一致性、隔离性和耐久性。</target>
        </trans-unit>
        <trans-unit id="0c055699e2752b762bcaa8253255fc14b9bef9a9" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; are both true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">事务发送者超时时间。有两个功能。首先，如果该值为0，则不会累积交易（例如，将不会启动交易发送方进程）。其次，如果该值大于0且 &lt;code&gt;auto_ack&lt;/code&gt; 和 &lt;code&gt;trans_ack&lt;/code&gt; 均为true或 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将启动事务发送方，并累积事务（取决于 &lt;code&gt;auto_ack&lt;/code&gt; ， &lt;code&gt;trans_ack&lt;/code&gt; 和 &lt;code&gt;trans_req&lt;/code&gt; 的值），供以后使用发送。</target>
        </trans-unit>
        <trans-unit id="269959a97a6fb575e49d0eca74353214adfc6c11" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; is true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">事务发送者超时时间。有两个功能。首先，如果该值为0，则不会累积交易（例如，将不会启动交易发送方进程）。其次，如果该值大于0且 &lt;code&gt;auto_ack&lt;/code&gt; 和 &lt;code&gt;trans_ack&lt;/code&gt; 为true或 &lt;code&gt;trans_req&lt;/code&gt; 为true，则将启动事务发送方，并累积事务（取决于 &lt;code&gt;auto_ack&lt;/code&gt; ， &lt;code&gt;trans_ack&lt;/code&gt; 和 &lt;code&gt;trans_req&lt;/code&gt; 的值），以便以后发送。</target>
        </trans-unit>
        <trans-unit id="8663c67ab2c24806fdfac1e594f2b7c4880ae74b" translate="yes" xml:space="preserve">
          <source>Transaction-protected updates of counter records are not possible.</source>
          <target state="translated">柜台记录的交易保护更新是不可能的。</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="92857e4acd00ac4a82a3a5846abb0210105c9b13" translate="yes" xml:space="preserve">
          <source>Transactions are important when designing fault-tolerant, distributed systems. A &lt;code&gt;Mnesia&lt;/code&gt; transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete &lt;code&gt;Mnesia&lt;/code&gt; records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</source>
          <target state="translated">在设计容错的分布式系统时，事务很重要。甲 &lt;code&gt;Mnesia&lt;/code&gt; 的事务是通过该一系列的数据库操作可以作为一个功能块执行的机制。作为事务运行的功能块称为功能对象（Fun），此代码可以读取，写入和删除 &lt;code&gt;Mnesia&lt;/code&gt; 记录。 Fun被评估为提交或终止的事务。如果事务成功执行Fun，它将在所有涉及的节点上复制操作，或者在发生错误时终止。</target>
        </trans-unit>
        <trans-unit id="4eb9104f2b09d1b5d4b87d82abb898d1890e970f" translate="yes" xml:space="preserve">
          <source>Transactions can be assigned the property of being executed on all nodes in the system, or on none. Transactions can also be bypassed in favor of running &quot;dirty operations&quot;, which reduce overheads and run fast.</source>
          <target state="translated">事务可以被指定为在系统中的所有节点上执行,或者在没有节点上执行的属性。事务也可以被绕过,转而运行 &quot;脏操作&quot;,这样可以减少开销并快速运行。</target>
        </trans-unit>
        <trans-unit id="a91a6387bdeb5a997e5106ce0eb7dbddb3fbc79e" translate="yes" xml:space="preserve">
          <source>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value &lt;code&gt;{aborted, Reason}&lt;/code&gt; and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</source>
          <target state="translated">事务可以以任意方式嵌套。子事务必须与其父事务在同一进程中运行。当子事务终止时，子事务的调用者将获得返回值 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 并且子事务执行的所有工作都将被擦除。如果提交了子事务，则将由子事务写入的记录传播到父事务。</target>
        </trans-unit>
        <trans-unit id="c7c5e2dea68a50fc96da311191d6565ac73e322c" translate="yes" xml:space="preserve">
          <source>Transactions that update the definition of a table requires that &lt;code&gt;Mnesia&lt;/code&gt; is started on all nodes where the storage type of the schema is &lt;code&gt;disc_copies&lt;/code&gt;. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</source>
          <target state="translated">更新表定义的事务要求在架构存储类型为 &lt;code&gt;disc_copies&lt;/code&gt; 的所有节点上启动 &lt;code&gt;Mnesia&lt;/code&gt; 。这些节点上表的所有副本也必须加载。这些可用性规则有一些例外：</target>
        </trans-unit>
        <trans-unit id="f8042cfa4648048958e1595a0cff5bd3d748ab7d" translate="yes" xml:space="preserve">
          <source>Transcodes an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;URIString&lt;/code&gt;, where &lt;code&gt;Options&lt;/code&gt; is a list of tagged tuples, specifying the inbound (&lt;code&gt;in_encoding&lt;/code&gt;) and outbound (&lt;code&gt;out_encoding&lt;/code&gt;) encodings. &lt;code&gt;in_encoding&lt;/code&gt; and &lt;code&gt;out_encoding&lt;/code&gt; specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned.</source>
          <target state="translated">对 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 兼容的 &lt;code&gt;URIString&lt;/code&gt; 进行代码转换，其中 &lt;code&gt;Options&lt;/code&gt; 是标记元组的列表，指定入站（ &lt;code&gt;in_encoding&lt;/code&gt; ）和出站（ &lt;code&gt;out_encoding&lt;/code&gt; ）编码。 &lt;code&gt;in_encoding&lt;/code&gt; 和 &lt;code&gt;out_encoding&lt;/code&gt; 同时为输入和输出数据指定二进制编码和百分比编码。不支持二进制编码与百分比编码不同的混合编码。如果参数无效，则返回错误元组。</target>
        </trans-unit>
        <trans-unit id="5bcd602254f322e5e2715324aa9c41970279ec4f" translate="yes" xml:space="preserve">
          <source>Transcript</source>
          <target state="translated">Transcript</target>
        </trans-unit>
        <trans-unit id="0276c8258f3ca2236ded67dcb45cec51cdd4d087" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; into the file &lt;code&gt;RemoteFile&lt;/code&gt; at the remote server.</source>
          <target state="translated">将二进制 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器上的文件 &lt;code&gt;RemoteFile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a31be82768a8a14fe4e45c8c31cc87a5a005d692" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; to the remote server and appends it to the file &lt;code&gt;RemoteFile&lt;/code&gt;. If the file does not exist, it is created.</source>
          <target state="translated">将二进制 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，并将其附加到文件 &lt;code&gt;RemoteFile&lt;/code&gt; 。如果该文件不存在，则会创建它。</target>
        </trans-unit>
        <trans-unit id="96ecc5026b0a2d6e144a5dcc9d3d15bc2637fba5" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which appends it to the file specified in the call to &lt;code&gt;append_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">将块 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，该服务器将其附加到对 &lt;code&gt;append_chunk_start/2&lt;/code&gt; 的调用中指定的文件中。</target>
        </trans-unit>
        <trans-unit id="6d777ccd8cf743ce8e8b1db94238262ce12eba79" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which writes it into the file specified in the call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">将块 &lt;code&gt;Bin&lt;/code&gt; 传输到远程服务器，该服务器将其写入到 &lt;code&gt;send_chunk_start/2&lt;/code&gt; 调用中指定的文件中。</target>
        </trans-unit>
        <trans-unit id="78ac497764b60c7c85e8349f223a68fe68089947" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;.</source>
          <target state="translated">将文件 &lt;code&gt;LocalFile&lt;/code&gt; 传输到远程服务器。如果指定了 &lt;code&gt;RemoteFile&lt;/code&gt; ，则将远程文件的名称设置为 &lt;code&gt;RemoteFile&lt;/code&gt; ，否则设置为 &lt;code&gt;LocalFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aec29636456fbdaa72ac911c194e9cb134c0de35" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file that the file is appended to is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;. If the file does not exists, it is created.</source>
          <target state="translated">将文件 &lt;code&gt;LocalFile&lt;/code&gt; 传输到远程服务器。如果指定了 &lt;code&gt;RemoteFile&lt;/code&gt; ，则将文件附加到的远程文件的名称设置为 &lt;code&gt;RemoteFile&lt;/code&gt; ，否则设置为 &lt;code&gt;LocalFile&lt;/code&gt; 。如果该文件不存在，则会创建它。</target>
        </trans-unit>
        <trans-unit id="90ba80cf80c63c0d2c8f02175aa1e10f13204467" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server and receives it as a binary.</source>
          <target state="translated">从远程服务器传输文件 &lt;code&gt;RemoteFile&lt;/code&gt; 并将其作为二进制文件接收。</target>
        </trans-unit>
        <trans-unit id="ef6a6bd4453d0b36a0f55436c56df830215430fd" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server to the file system of the local client. If &lt;code&gt;LocalFile&lt;/code&gt; is specified, the local file will be &lt;code&gt;LocalFile&lt;/code&gt;, otherwise &lt;code&gt;RemoteFile&lt;/code&gt;.</source>
          <target state="translated">将文件 &lt;code&gt;RemoteFile&lt;/code&gt; 从远程服务器传输到本地客户端的文件系统。如果指定了 &lt;code&gt;LocalFile&lt;/code&gt; ，则本地文件将为 &lt;code&gt;LocalFile&lt;/code&gt; ，否则为 &lt;code&gt;RemoteFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0ad6ecb9ddaf64bd66989047cba27a4d5603ff1" translate="yes" xml:space="preserve">
          <source>Transform a alias-name to its oid.</source>
          <target state="translated">将别名转换为其id。</target>
        </trans-unit>
        <trans-unit id="36c585abe302937d577b48572bd7c0e3655c0630" translate="yes" xml:space="preserve">
          <source>Transform a oid to its aliasname.</source>
          <target state="translated">将一个oid转换为它的别名。</target>
        </trans-unit>
        <trans-unit id="1d5829db0e03928c4e7cde6f753299a051ba3577" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, appending &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of the specified string.</source>
          <target state="translated">编译之前先对输入字典进行转换，并附加指定字符串的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b3111884f3054cc372ba38df92c0a135c770202" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, setting &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; to the specified string.</source>
          <target state="translated">编译之前先转换输入字典，将 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 设置为指定的字符串。</target>
        </trans-unit>
        <trans-unit id="c21ae8bb9de07f6c449c2bda96f788a3baf2c6fe" translate="yes" xml:space="preserve">
          <source>Transformation rules are used to rewrite generic instructions to other generic instructions. The transformations rules are applied repeatedly until no rule match. At that point, the first instruction in the resulting instruction sequence will be converted to a specific instruction and added to the code for the module being loaded. Then the transformation rules for the remaining instructions are run in the same way.</source>
          <target state="translated">转换规则用于将通用指令改写成其他通用指令。转换规则被反复应用,直到没有规则匹配。这时,结果指令序列中的第一条指令将被转换为特定指令,并添加到被加载模块的代码中。然后以同样的方式运行其余指令的转换规则。</target>
        </trans-unit>
        <trans-unit id="846b9581964cb477d07383c10e4204a0b7ad99e6" translate="yes" xml:space="preserve">
          <source>Transformations that are not possible to describe with the rule language as described here can be written as a C function in &lt;code&gt;beam_load.c&lt;/code&gt; and called from the right side of a transformation. The left side of the transformation will perform the match and bind operands to variables. The variables can then be passed to a generator function on the right side. For example:</source>
          <target state="translated">不能使用此处描述的规则语言描述的转换可以在 &lt;code&gt;beam_load.c&lt;/code&gt; 作为C函数编写，并可以从转换的右侧进行调用。转换的左侧将执行匹配并将操作数绑定到变量。然后可以将变量传递到右侧的生成器函数。例如：</target>
        </trans-unit>
        <trans-unit id="c4f1d57f141d31ace69a30793395cb3994e3e4b6" translate="yes" xml:space="preserve">
          <source>Transforming URIs into a normalized form</source>
          <target state="translated">将URI转化为规范化的形式。</target>
        </trans-unit>
        <trans-unit id="52a09e92d39be036799f55f3466102e3964c9981" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (that is, it cannot be sent to a process on another node and still remain a valid compiled match specification, nor can it be stored on disk). To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 转换为内部表示，可在随后的 &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 调用中使用。内部表示形式是不透明的，不能转换为外部术语格式，然后再次返回而不会丢失其属性（即，不能将其发送到另一个节点上的进程，并且仍然保持有效的已编译匹配规范，也不能将其存储在磁盘）。要检查已编译的匹配规范的有效性，请使用 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="127c97ad73e2098d2302e04d73b62ee91a692d00" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque. To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 转换为内部表示，可在随后对 &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 的调用中使用。内部表示是不透明的。要检查已编译的匹配规范的有效性，请使用 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29484fe337b3af71da5ca7a2dac4e696f5f79d47" translate="yes" xml:space="preserve">
          <source>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for &lt;code&gt;Node&lt;/code&gt;, as produced by the given &lt;code&gt;Printer&lt;/code&gt; function. Each line of the comment is prefixed by the string &lt;code&gt;Prefix&lt;/code&gt; (this does not include the initial &quot;&lt;code&gt;%&lt;/code&gt;&quot; character of the comment line).</source>
          <target state="translated">将语法树转换为抽象注释。注释行包含由给定 &lt;code&gt;Printer&lt;/code&gt; 函数产生的 &lt;code&gt;Node&lt;/code&gt; 文本。注释的每一行都以字符串 &lt;code&gt;Prefix&lt;/code&gt; （这不包括注释行的开头&amp;ldquo; &lt;code&gt;%&lt;/code&gt; &amp;rdquo;字符）。</target>
        </trans-unit>
        <trans-unit id="0cbb6e0e6a14a90b777a9f90d55d975cb9b29ca2" translate="yes" xml:space="preserve">
          <source>Transforms addresses from internal MIB format to one more useful to &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将地址从内部MIB格式转换为对 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt; 有用的另一种格式。</target>
        </trans-unit>
        <trans-unit id="dec43f85ac93650f89af6686bc1b1b60f6b9599f" translate="yes" xml:space="preserve">
          <source>Transforms an &lt;code&gt;URI&lt;/code&gt; into a normalized form using Syntax-Based Normalization as defined by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 定义的基于语法的规范化将 &lt;code&gt;URI&lt;/code&gt; 转换为规范化形式。</target>
        </trans-unit>
        <trans-unit id="d1d9a9fd8f3259ae9990008a8a6bec24b152a43a" translate="yes" xml:space="preserve">
          <source>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</source>
          <target state="translated">将一个SNMP索引转换为相应的Mnesia键。如果SNMP表有多个键,则键是键列的元组。</target>
        </trans-unit>
        <trans-unit id="187ea5deff287a5504fddf1b7e36cd0f09e23500" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;person&lt;/code&gt; table from a RAM table into a disc-based table at &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;person&lt;/code&gt; 表从RAM表转换为 &lt;code&gt;Node&lt;/code&gt; 处基于磁盘的表。</target>
        </trans-unit>
        <trans-unit id="e599fefddd1839d024d114d1fae1e8b80cf9332c" translate="yes" xml:space="preserve">
          <source>Transforms trace data and makes an event record out of it.</source>
          <target state="translated">转换跟踪数据,并对其进行事件记录。</target>
        </trans-unit>
        <trans-unit id="dae87e24dc1095e84bcbb6fcaaaa2c5136770260" translate="yes" xml:space="preserve">
          <source>Transient Failures</source>
          <target state="translated">瞬时故障</target>
        </trans-unit>
        <trans-unit id="635a90e0c9623c778cd92020a4761e58257d50d3" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the &lt;strong&gt;state transition&lt;/strong&gt;. The &lt;strong&gt;state transition&lt;/strong&gt; takes place when the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; has processed an event and returns. Here are the sequence of steps for a &lt;strong&gt;state transition&lt;/strong&gt;:</source>
          <target state="translated">可以通过 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 设置过渡选项，并修改&lt;strong&gt;状态过渡&lt;/strong&gt;。该&lt;strong&gt;状态转换&lt;/strong&gt;发生时，发生 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 已处理的事件，并返回。以下是&lt;strong&gt;状态转换&lt;/strong&gt;的步骤顺序：</target>
        </trans-unit>
        <trans-unit id="340b8d86a3623f3b21be6c18b845921955f1271a" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the state transition. Here are the sequence of steps for a state transition:</source>
          <target state="translated">过渡选项可以通过 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 设置，并可以修改状态过渡。以下是状态转换的步骤顺序：</target>
        </trans-unit>
        <trans-unit id="1c6cfa47dfcc18ddefe84ebeb0f5989ee0e3d8d7" translate="yes" xml:space="preserve">
          <source>Translates OID to Erlang digest type</source>
          <target state="translated">将OID翻译成Erlang摘要类型。</target>
        </trans-unit>
        <trans-unit id="6f68e1d1cfad7a14a47ac7096b71655133e8d261" translate="yes" xml:space="preserve">
          <source>Translates an SCTP error number from, for example, &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; or &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; into an explanatory string, or one of the atoms &lt;code&gt;ok&lt;/code&gt; for no error or &lt;code&gt;undefined&lt;/code&gt; for an unrecognized error.</source>
          <target state="translated">将SCTP错误编号从例如 &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; 或 &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; 转换为说明字符串，或将 &lt;code&gt;ok&lt;/code&gt; 原子表示为无错误，或者将原子之一 &lt;code&gt;undefined&lt;/code&gt; 为未识别的错误。</target>
        </trans-unit>
        <trans-unit id="80c4059735d8cda62f939032264b405f285841d8" translate="yes" xml:space="preserve">
          <source>Translates an abstract syntax tree to a corresponding explicit record representation. The records are defined in the file &quot;&lt;code&gt;cerl.hrl&lt;/code&gt;&quot;.</source>
          <target state="translated">将抽象语法树转换为相应的显式记录表示形式。记录在文件&amp;ldquo; &lt;code&gt;cerl.hrl&lt;/code&gt; &amp;rdquo;中定义。</target>
        </trans-unit>
        <trans-unit id="d19487fcfdbdd7c9b9b7de31aef67e2f1e3c0f27" translate="yes" xml:space="preserve">
          <source>Translates an explicit record representation to a corresponding abstract syntax tree. The records are defined in the file &quot;&lt;code&gt;core_parse.hrl&lt;/code&gt;&quot;.</source>
          <target state="translated">将显式记录表示形式转换为相应的抽象语法树。记录在文件&amp;ldquo; &lt;code&gt;core_parse.hrl&lt;/code&gt; &amp;rdquo;中定义。</target>
        </trans-unit>
        <trans-unit id="6fca7eec0c5c2c402ec9feaf20fb1cf586209144" translate="yes" xml:space="preserve">
          <source>Translates signature algorithm OID to Erlang digest and signature types.</source>
          <target state="translated">将签名算法OID翻译成Erlang摘要和签名类型。</target>
        </trans-unit>
        <trans-unit id="2dd26e871e1b0c6741054f66f2c8c6fd1ff461e9" translate="yes" xml:space="preserve">
          <source>Translates the binary trace logs into something readable. By default, &lt;code&gt;ttb&lt;/code&gt; presents each trace message as a line of text, but you can also write your own handler to make more complex interpretations of the trace information. A trace log can also be presented graphically with application Event Tracer (ET).</source>
          <target state="translated">将二进制跟踪日志转换为可读的内容。默认情况下， &lt;code&gt;ttb&lt;/code&gt; 将每个跟踪消息显示为一行文本，但是您也可以编写自己的处理程序以对跟踪信息进行更复杂的解释。跟踪日志也可以通过应用程序事件跟踪器（ET）以图形方式显示。</target>
        </trans-unit>
        <trans-unit id="247b327869ef6106bf80329969b8c8bd5956cb2a" translate="yes" xml:space="preserve">
          <source>Translation Agents</source>
          <target state="translated">翻译公司</target>
        </trans-unit>
        <trans-unit id="c10d76c9a4b81c39c13a3bbf7cdb7a157dfb1551" translate="yes" xml:space="preserve">
          <source>Transport</source>
          <target state="translated">Transport</target>
        </trans-unit>
        <trans-unit id="b374a75b21ba249e1509b4f849a514f5f64e23f6" translate="yes" xml:space="preserve">
          <source>Transport Failure Algorithm</source>
          <target state="translated">传输失败算法</target>
        </trans-unit>
        <trans-unit id="67ca25bf09fe1a4bc0aa43dea06a3fcf06720b9d" translate="yes" xml:space="preserve">
          <source>Transport Failure Detection</source>
          <target state="translated">运输故障检测</target>
        </trans-unit>
        <trans-unit id="c24199b7fc627de79e3a1c89011039b836457577" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) and its predecessor, the Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. The protocols use X.509 certificates and hence public key (asymmetric) cryptography to authenticate the counterpart with whom they communicate, and to exchange a symmetric key for payload encryption. The protocol provides data/message confidentiality (encryption), integrity (through message authentication code checks) and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that is based on TLS but datagram oriented instead of stream oriented.</source>
          <target state="translated">传输层安全(TLS)及其前身安全套接字层(SSL)是旨在为计算机网络提供通信安全的加密协议。这些协议使用X.509证书,因此使用公共密钥(非对称)加密技术来验证与之通信的对应方,并为有效载荷加密交换对称密钥。该协议提供数据/消息的保密性(加密)、完整性(通过消息验证码检查)和主机验证(通过证书路径验证)。DTLS(数据报传输层安全),基于TLS,但面向数据报而不是面向流。</target>
        </trans-unit>
        <trans-unit id="6d4ed04955b99e2e25f46f14a243ff2be9d1edb1" translate="yes" xml:space="preserve">
          <source>Transport Protocol</source>
          <target state="translated">传输协议</target>
        </trans-unit>
        <trans-unit id="784cd0f786d540e1df407cfe0bdede50bd4a091f" translate="yes" xml:space="preserve">
          <source>Transpose characters</source>
          <target state="translated">转换字符</target>
        </trans-unit>
        <trans-unit id="ad327557b2eecc894c5ce680d047ddb9ce864548" translate="yes" xml:space="preserve">
          <source>Trap Sending</source>
          <target state="translated">陷阱发送</target>
        </trans-unit>
        <trans-unit id="b87b3f0b12dc0cda40b5e7c065f4352f65c40f7f" translate="yes" xml:space="preserve">
          <source>Traversals using &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt; functions may not need to scan the entire table depending on how the key is specified. A match pattern with a &lt;strong&gt;fully bound key&lt;/strong&gt; (without any match variables) will optimize the operation to a single key lookup without any table traversal at all. For &lt;code&gt;ordered_set&lt;/code&gt; a &lt;strong&gt;partially bound key&lt;/strong&gt; will limit the traversal to only scan a subset of the table based on term order. A partially bound key is either a list or a tuple with a prefix that is fully bound. Example:</source>
          <target state="translated">使用 &lt;code&gt;match&lt;/code&gt; 和 &lt;code&gt;select&lt;/code&gt; 功能的遍历可能不需要扫描整个表，具体取决于指定键的方式。具有&lt;strong&gt;完全绑定键&lt;/strong&gt;（没有任何匹配变量）的匹配模式将优化对单个键查找的操作，而无需任何表遍历。对于 &lt;code&gt;ordered_set&lt;/code&gt; ，&lt;strong&gt;部分绑定的键&lt;/strong&gt;将限制遍历以仅基于术语顺序扫描表的子集。部分绑定的键是列表或具有完全绑定的前缀的元组。例子：</target>
        </trans-unit>
        <trans-unit id="6e192302cce69f9e090d601f54b7e73e6fdccdad" translate="yes" xml:space="preserve">
          <source>Traverses &lt;code&gt;Dirs&lt;/code&gt; and adds each &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. This means that the order of &lt;code&gt;Dirs&lt;/code&gt; is reversed in the resulting code path. For example, if you add &lt;code&gt;[Dir1,Dir2]&lt;/code&gt;, the resulting path will be &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt;.</source>
          <target state="translated">遍历 &lt;code&gt;Dirs&lt;/code&gt; 并将每个 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径的开头。这意味着 &lt;code&gt;Dirs&lt;/code&gt; 的顺序在生成的代码路径中颠倒了。例如，如果添加 &lt;code&gt;[Dir1,Dir2]&lt;/code&gt; ，则结果路径将为 &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="137a357a519bf577c3a49eea20ac865057de4ba8" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise the function returns a key that can be used to read the actual record.</source>
          <target state="translated">遍历表并对表中的所有记录执行操作。当到达表的末尾时，将返回特殊键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。否则，该函数将返回可用于读取实际记录的键。</target>
        </trans-unit>
        <trans-unit id="d196f97744321413a11b3f30616c9f2f4eec01c6" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;.</source>
          <target state="translated">遍历表并对表中的所有记录执行操作。当到达表的末尾时，将返回特殊键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。否则，该函数将返回可用于读取实际记录的键。如果另一个Erlang进程在使用函数 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 遍历该表时对该表执行写操作，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="8dc9f15de712d9d574738e5b2e0901706f6adc90" translate="yes" xml:space="preserve">
          <source>Traverses a table in a manner similar to the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;. A table has a number of slots that range from 0 (zero) to an unknown upper bound. The function &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; returns the special atom &lt;code&gt;'$end_of_table'&lt;/code&gt; when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</source>
          <target state="translated">以类似于函数 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 的方式遍历表。一个表具有多个插槽，范围从0（零）到未知上限。当到达表的末尾时，函数 &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; 返回特殊原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。如果在遍历表时对表执行写操作，则此函数的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d5bce8436ec86270c2bccf19db4667aa0c4b7a23" translate="yes" xml:space="preserve">
          <source>Traversing the set of modules, it then recompiles every module for which at least one of the following conditions apply:</source>
          <target state="translated">遍历模块集,然后重新编译至少符合下列条件之一的每个模块:</target>
        </trans-unit>
        <trans-unit id="7c6a05bfb91163574fcaf2b49273abce7fc5b093" translate="yes" xml:space="preserve">
          <source>Trees and iterators are built using opaque data structures that should not be pattern-matched from outside this module.</source>
          <target state="translated">树和迭代器是使用不透明的数据结构构建的,不应该从本模块外部进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="c0c84ee4b222403ef3c2a2f6e4a34ab18cd985d5" translate="yes" xml:space="preserve">
          <source>Tries to create directory &lt;code&gt;Dir&lt;/code&gt;. Missing parent directories are &lt;strong&gt;not&lt;/strong&gt; created. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">尝试创建目录 &lt;code&gt;Dir&lt;/code&gt; 。&lt;strong&gt;没有&lt;/strong&gt;创建丢失的父目录。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7539b9bc23bf1a63079b6009b66e55de1f511775" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the &lt;code&gt;NULL&lt;/code&gt;-terminated C-string &lt;code&gt;name&lt;/code&gt; with encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试从 &lt;code&gt;NULL&lt;/code&gt; 终止的C字符串 &lt;code&gt;name&lt;/code&gt; 使用encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 创建一个已经存在的原子的术语。</target>
        </trans-unit>
        <trans-unit id="d956aa4d45e626e33feccc52c2e668a01e46c2de" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the string &lt;code&gt;name&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; and encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; characters are treated as any other characters.</source>
          <target state="translated">尝试根据长度为 &lt;code&gt;len&lt;/code&gt; 的字符串 &lt;code&gt;name&lt;/code&gt; 创建一个已经存在的原子的术语，并使用encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;NULL&lt;/code&gt; 字符被视为其他任何字符。</target>
        </trans-unit>
        <trans-unit id="c7380de8914d3d9d8e70fd1f6c74d924099655d6" translate="yes" xml:space="preserve">
          <source>Tries to delete directory &lt;code&gt;Dir&lt;/code&gt;. The directory must be empty before it can be deleted. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">尝试删除目录 &lt;code&gt;Dir&lt;/code&gt; 。该目录必须为空，然后才能删除。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0694587d26aecfbb0a43b20ea81eab04225a2a67" translate="yes" xml:space="preserve">
          <source>Tries to delete file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">试图删除文件 &lt;code&gt;Filename&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="917cb6bdcab3e4dcc84eba06ed763b346415331e" translate="yes" xml:space="preserve">
          <source>Tries to find a &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">试图找到一个 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 从顶点 &lt;code&gt;V1&lt;/code&gt; 到顶点 &lt;code&gt;V2&lt;/code&gt; 有向图的 &lt;code&gt;G&lt;/code&gt; 。以顶点列表 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 的形式返回路径；如果不存在从 &lt;code&gt;V1&lt;/code&gt; 到 &lt;code&gt;V2&lt;/code&gt; 的长度为一个或多个的简单路径，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6d56eefae6afa713ee58d8d532711a39f9d00e8" translate="yes" xml:space="preserve">
          <source>Tries to find an application downgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a previous version &lt;code&gt;OldVsn&lt;/code&gt; located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">试图找到一个应用程序降级脚本 &lt;code&gt;App&lt;/code&gt; 从当前版本到以前的版本 &lt;code&gt;OldVsn&lt;/code&gt; 位于 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3cdb4b87509cbcdcf3943a3bdad2d3f9b6d987" translate="yes" xml:space="preserve">
          <source>Tries to find an application upgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">尝试查找 &lt;code&gt;App&lt;/code&gt; 的应用程序升级脚本，从当前版本升级到 &lt;code&gt;Dir&lt;/code&gt; 中的新版本。</target>
        </trans-unit>
        <trans-unit id="63810144427574ddc18730d454daf02c43dd8338" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; through vertex &lt;code&gt;V&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the cycle as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple cycle through &lt;code&gt;V&lt;/code&gt; exists. Notice that a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; is returned as list &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt;.</source>
          <target state="translated">试图通过图 &lt;code&gt;G&lt;/code&gt; 的顶点 &lt;code&gt;V&lt;/code&gt; 找到尽可能短的 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 。以顶点列表 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 的形式返回循环，如果不存在通过 &lt;code&gt;V&lt;/code&gt; 的简单循环，则返回 &lt;code&gt;false&lt;/code&gt; 。注意，通过 &lt;code&gt;V&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 作为列表 &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dd32105e9ea9dba4a3239b99d2841486b3f987d" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">试图找到一个尽可能短 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 从顶点 &lt;code&gt;V1&lt;/code&gt; 到顶点 &lt;code&gt;V2&lt;/code&gt; 有向图的 &lt;code&gt;G&lt;/code&gt; ^。以顶点列表 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 的形式返回路径；如果不存在从 &lt;code&gt;V1&lt;/code&gt; 到 &lt;code&gt;V2&lt;/code&gt; 的长度为一个或多个的简单路径，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f904e656f227e2a584648e9091f6b33093af20b3" translate="yes" xml:space="preserve">
          <source>Tries to load a module in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;, unless the module is already loaded. However, in embedded mode it does not load a module that is not already loaded, but returns &lt;code&gt;{error, embedded}&lt;/code&gt; instead. See &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; for a description of other possible error reasons.</source>
          <target state="translated">尝试以与 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 相同的方式加载模块，除非已加载模块。但是，在嵌入式模式下，它不会加载尚未加载的模块，而是返回 &lt;code&gt;{error, embedded}&lt;/code&gt; 。有关其他可能的错误原因的说明，请参见 &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; 的错误原因。</target>
        </trans-unit>
        <trans-unit id="ec25834fa1b726007249264a0c7c78aaaf71538e" translate="yes" xml:space="preserve">
          <source>Tries to load all of the modules in the list &lt;code&gt;Modules&lt;/code&gt; atomically. That means that either all modules are loaded at the same time, or none of the modules are loaded if there is a problem with any of the modules.</source>
          <target state="translated">尝试以原子方式加载&amp;ldquo;模块&amp;rdquo;列表中的所有 &lt;code&gt;Modules&lt;/code&gt; 。这意味着要么同时加载所有模块，要么如果任何模块有问题，则不加载任何模块。</target>
        </trans-unit>
        <trans-unit id="1aaf9b09924ea99accd919111039be58e3e4e9fc" translate="yes" xml:space="preserve">
          <source>Tries to load and restore Debugger settings from a file previously saved using &lt;strong&gt;Save Settings...&lt;/strong&gt; (see below). Any errors are silently ignored.</source>
          <target state="translated">尝试从以前使用&amp;ldquo; &lt;strong&gt;保存设置...&amp;rdquo;&lt;/strong&gt;保存的文件中加载和还原调试器设置（请参见下文）。任何错误都将被忽略。</target>
        </trans-unit>
        <trans-unit id="9bc1b21fc8af03b36192dd6ac14e4e4450744f7e" translate="yes" xml:space="preserve">
          <source>Tries to load any modules not already loaded in the list &lt;code&gt;Modules&lt;/code&gt; in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试以与 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 相同的方式加载列表 &lt;code&gt;Modules&lt;/code&gt; 中尚未加载的任何模块。</target>
        </trans-unit>
        <trans-unit id="b645a31575ab3155bc8f781878d4d3b627bae342" translate="yes" xml:space="preserve">
          <source>Tries to load code for all modules that have been previously prepared by &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt;. The loading occurs atomically, meaning that either all modules are loaded at the same time, or none of the modules are loaded.</source>
          <target state="translated">尝试为先前由 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 准备的所有模块加载代码。加载是原子发生的，这意味着要么同时加载所有模块，要么不加载任何模块。</target>
        </trans-unit>
        <trans-unit id="f4b988df2289cf719529adabbdd5889a80ea66c6" translate="yes" xml:space="preserve">
          <source>Tries to load the Erlang module &lt;code&gt;Module&lt;/code&gt;, using the code path. It looks for the object code file with an extension corresponding to the Erlang machine used, for example, &lt;code&gt;Module.beam&lt;/code&gt;. The loading fails if the module name found in the object code differs from the name &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; must be used to load object code with a module name that is different from the file name.</source>
          <target state="translated">尝试使用代码路径加载Erlang模块 &lt;code&gt;Module&lt;/code&gt; 。它查找目标代码文件，其扩展名对应于所使用的Erlang机器，例如 &lt;code&gt;Module.beam&lt;/code&gt; 。如果该模块的名称从名称的对象的不同代码中发现的加载失败 &lt;code&gt;Module&lt;/code&gt; 。必须使用 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 装载目标名称，该目标代码的模块名称与文件名不同。</target>
        </trans-unit>
        <trans-unit id="b49e8d37404b75156cbbeb1637eb4e0c68260be5" translate="yes" xml:space="preserve">
          <source>Tries to lock a mutex. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same mutex again.</source>
          <target state="translated">尝试锁定互斥锁。当前已锁定互斥锁的线程&lt;strong&gt;无法&lt;/strong&gt;尝试再次锁定同一互斥锁。</target>
        </trans-unit>
        <trans-unit id="369d095339d331183fd1de82b70ca1f958ce57f3" translate="yes" xml:space="preserve">
          <source>Tries to read &lt;code&gt;String&lt;/code&gt; in accordance with the control sequences in &lt;code&gt;Format&lt;/code&gt;. For a detailed description of the available formatting options, see &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt;. It is assumed that &lt;code&gt;String&lt;/code&gt; contains whole lines.</source>
          <target state="translated">尝试根据 &lt;code&gt;Format&lt;/code&gt; 中的控制序列读取 &lt;code&gt;String&lt;/code&gt; 。有关可用格式选项的详细说明，请参见 &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt; 。假定 &lt;code&gt;String&lt;/code&gt; 包含整行。</target>
        </trans-unit>
        <trans-unit id="b5361d5cdb192bb80b006486e2deeb6e3a86a448" translate="yes" xml:space="preserve">
          <source>Tries to read lock an rwlock.</source>
          <target state="translated">试图读取锁和Rwlock。</target>
        </trans-unit>
        <trans-unit id="078c41228c821f4992dac3d604b1f36b0a4cc3ba" translate="yes" xml:space="preserve">
          <source>Tries to read/write lock an rwlock. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same rwlock again.</source>
          <target state="translated">尝试读取/写入锁定rwlock。当前具有读或读/写锁定rwlock的线程&lt;strong&gt;无法&lt;/strong&gt;尝试再次锁定同一rwlock。</target>
        </trans-unit>
        <trans-unit id="dc8fa12e3d041770e3cb72f5520664da24c9462a" translate="yes" xml:space="preserve">
          <source>Tries to reduce a guard expression to a single constant value, if possible. The returned value is &lt;code&gt;{value, Term}&lt;/code&gt; if the guard expression &lt;code&gt;Expr&lt;/code&gt; always yields the constant value &lt;code&gt;Term&lt;/code&gt;, and is otherwise &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">尝试将保护表达式减小为单个常量值（如果可能）。如果保护表达式 &lt;code&gt;Expr&lt;/code&gt; 始终产生常数值 &lt;code&gt;Term&lt;/code&gt; ，则返回的值为 &lt;code&gt;{value, Term}&lt;/code&gt; ，否则为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542b3a8d434cdeb35d54c993e320baf91923b244" translate="yes" xml:space="preserve">
          <source>Tries to rename the file &lt;code&gt;Source&lt;/code&gt; to &lt;code&gt;Destination&lt;/code&gt;. It can be used to move files (and directories) between directories, but it is not sufficient to specify the destination only. The destination filename must also be specified. For example, if &lt;code&gt;bar&lt;/code&gt; is a normal file and &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are directories, &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; returns an error, but &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; succeeds. Returns &lt;code&gt;ok&lt;/code&gt; if it is successful.</source>
          <target state="translated">尝试将文件 &lt;code&gt;Source&lt;/code&gt; 重命名为 &lt;code&gt;Destination&lt;/code&gt; 。它可用于在目录之间移动文件（和目录），但是仅指定目的地是不够的。还必须指定目标文件名。例如，如果 &lt;code&gt;bar&lt;/code&gt; 是一个普通文件，而 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 是目录，则 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; 返回一个错误，但是 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; 成功。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69799527904c5b0f81a27b2394603c188136973" translate="yes" xml:space="preserve">
          <source>Tries to set the scheduler bind type. The same as flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; except how some errors are handled. For more information, see &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试设置调度程序绑定类型。除处理某些错误外，与标志 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 相同。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3739b1427af771c5c5c521a0baa015d6c8471836" translate="yes" xml:space="preserve">
          <source>Tries to suspend all processes using a module &lt;code&gt;Mod&lt;/code&gt;. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no &lt;code&gt;Timeout&lt;/code&gt; is specified or &lt;code&gt;default&lt;/code&gt; is specified, the default value for &lt;code&gt;sys:suspend&lt;/code&gt; is used.</source>
          <target state="translated">尝试使用模块 &lt;code&gt;Mod&lt;/code&gt; 挂起所有进程。如果某个进程没有响应，则将其忽略。这可能导致进程死机，要么是因为它自发地切换到新代码时崩溃了，要么是由于清除操作导致的。如果没有 &lt;code&gt;Timeout&lt;/code&gt; 指定或 &lt;code&gt;default&lt;/code&gt; 指定，默认值 &lt;code&gt;sys:suspend&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="f07a25fbd2993e4438fecb34b5a2a265898a4510" translate="yes" xml:space="preserve">
          <source>Trigger the user-probe &lt;code&gt;user_trace_i4s4&lt;/code&gt; in the NIF library &lt;code&gt;dyntrace.so&lt;/code&gt; by calling &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; 来触发NIF库 &lt;code&gt;dyntrace.so&lt;/code&gt; 中的用户探针 &lt;code&gt;user_trace_i4s4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b4e339fc739fe569582f228faed311550ce6f3" translate="yes" xml:space="preserve">
          <source>Triggers garbage collection of requested type. Default value is &lt;code&gt;'major'&lt;/code&gt;, which would trigger a fullsweep GC. The option &lt;code&gt;'minor'&lt;/code&gt; is considered a hint and may lead to either minor or major GC run.</source>
          <target state="translated">触发请求类型的垃圾回收。默认值为 &lt;code&gt;'major'&lt;/code&gt; ，它将触发全扫描GC。选项 &lt;code&gt;'minor'&lt;/code&gt; 被认为是提示，可能会导致次要或主要GC运行。</target>
        </trans-unit>
        <trans-unit id="bce7d4bc5bdcfee52b94b55561a6aeaf81f157f5" translate="yes" xml:space="preserve">
          <source>Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.</source>
          <target state="translated">触发下一个要流转的消息,也就是和套接字的主动行为一样。</target>
        </trans-unit>
        <trans-unit id="a0f37655e58e53f4d21a5d5b772a98970d6a45b9" translate="yes" xml:space="preserve">
          <source>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by &lt;code&gt;sbrk&lt;/code&gt;) that is kept by &lt;code&gt;malloc&lt;/code&gt; (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, &lt;code&gt;malloc&lt;/code&gt; releases it (by calling &lt;code&gt;sbrk&lt;/code&gt;). Trim threshold is specified in kilobytes. Defaults to &lt;code&gt;128&lt;/code&gt;.</source>
          <target state="translated">修剪阈值大小（以千字节为单位）。这是 &lt;code&gt;malloc&lt;/code&gt; （不释放给操作系统）保留的堆顶部（由 &lt;code&gt;sbrk&lt;/code&gt; 分配）顶部的最大可用内存量。当堆顶部的可用内存量超过修剪阈值时， &lt;code&gt;malloc&lt;/code&gt; 释放它（通过调用 &lt;code&gt;sbrk&lt;/code&gt; ）。修剪阈值以千字节为单位指定。默认为 &lt;code&gt;128&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95ec715dc8ff6a5284221ec8f9868a8798be9478" translate="yes" xml:space="preserve">
          <source>Trivial FTP.</source>
          <target state="translated">琐碎的FTP。</target>
        </trans-unit>
        <trans-unit id="4ba00956ec7cf24ae072a34b8ff599479668e012" translate="yes" xml:space="preserve">
          <source>Trivial example (beep on anything except empty line, which is expanded to &lt;code&gt;&quot;quit&quot;&lt;/code&gt;):</source>
          <target state="translated">一个简单的示例（除了空行以外，其他任何地方都为哔哔声，它将扩展为 &lt;code&gt;&quot;quit&quot;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c64384e3540118ebd85f8e8adda7b3a0d9d9d577" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a binary.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是二进制，则为true 。</target>
        </trans-unit>
        <trans-unit id="2184451194ed3a9022be648eb665e2e8303c78bb" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a floating point number.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是浮点数，则为true 。</target>
        </trans-unit>
        <trans-unit id="739f16017ed1c1b0d52375a346e88d29489f5f4c" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with at least one element.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是包含至少一个元素的列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="4dc6a0f22eecbe39d3b7bafca6d0ecf3f15fab72" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with zero or more elements.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是具有零个或多个元素的列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="7e4dec6465a412dda92c461f8f7e72cba72e9ec3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a pid (process identifier).</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是pid（进程标识符），则为true 。</target>
        </trans-unit>
        <trans-unit id="ca9f92d44502347305071d3028c3415ccc6539b0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a port.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是端口，则为true 。</target>
        </trans-unit>
        <trans-unit id="63b81f24f20e74b9964fd68165f42bbd5f102696" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a reference.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是参考，则为true 。</target>
        </trans-unit>
        <trans-unit id="369ae59368966778ddc2fa05ef42ca484213f640" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a tuple.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是一个元组，则为true 。</target>
        </trans-unit>
        <trans-unit id="200e8169564499251662fa489120aa02ef56f5b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an atom.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 是原子，则为真。</target>
        </trans-unit>
        <trans-unit id="d2096948a91663a352916722e0007725da8866ba" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an empty list.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 为空列表，则为true 。</target>
        </trans-unit>
        <trans-unit id="7cf519e4319be41a9707146ad88931f2320203e5" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an integer.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 为整数，则为true 。</target>
        </trans-unit>
        <trans-unit id="58de67beda24834e524aecdc74c16cbb945cf7c3" translate="yes" xml:space="preserve">
          <source>Truncates the file referenced by &lt;code&gt;IoDevice&lt;/code&gt; at the current position. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">在当前位置截断 &lt;code&gt;IoDevice&lt;/code&gt; 引用的文件。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37023c65abd347268bb58c87d2fb0048749a483a" translate="yes" xml:space="preserve">
          <source>Try out the new function &lt;code&gt;mult&lt;/code&gt;:</source>
          <target state="translated">试用新功能 &lt;code&gt;mult&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ff47aa173fda0968a762374da8240dfe8b55c52" translate="yes" xml:space="preserve">
          <source>Trying to evaluate a &lt;code&gt;throw&lt;/code&gt;outside a &lt;code&gt;catch&lt;/code&gt;. &lt;code&gt;V&lt;/code&gt; is the thrown term.</source>
          <target state="translated">试图评估 &lt;code&gt;catch&lt;/code&gt; 外的 &lt;code&gt;throw&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 是抛出的术语。</target>
        </trans-unit>
        <trans-unit id="07a738ec4060694f8cccf2229438cc8e4149b664" translate="yes" xml:space="preserve">
          <source>Trying to link or monitor to a non-existing process or port.</source>
          <target state="translated">试图连接或监控一个不存在的进程或端口。</target>
        </trans-unit>
        <trans-unit id="cae5dd25bf19639aecf488ad3d7ba57e76736991" translate="yes" xml:space="preserve">
          <source>Trying to link to a non-existing process.</source>
          <target state="translated">试图链接到一个不存在的进程。</target>
        </trans-unit>
        <trans-unit id="f4134e3f0fb2b5c47f2d5517769378391de080f4" translate="yes" xml:space="preserve">
          <source>Tunes the compression algorithm. Use the following values:</source>
          <target state="translated">调整压缩算法。使用以下数值:</target>
        </trans-unit>
        <trans-unit id="f3e0a317e78b26f5945cf71664d252d582664be5" translate="yes" xml:space="preserve">
          <source>Tuning the intensity and period</source>
          <target state="translated">调整强度和周期</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="83ed105f4df89ed36299f9fd59a044cb698807f7" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error, error_info()}&lt;/code&gt; and &lt;code&gt;{warning, error_info()}&lt;/code&gt;, denoting syntactically incorrect forms and warnings, and &lt;code&gt;{eof, line()}&lt;/code&gt;, denoting an end-of-stream encountered before a complete form had been parsed.</source>
          <target state="translated">元组 &lt;code&gt;{error, error_info()}&lt;/code&gt; 和 &lt;code&gt;{warning, error_info()}&lt;/code&gt; 表示语法上不正确的形式和警告，而 &lt;code&gt;{eof, line()}&lt;/code&gt; 表示在解析完整表格之前遇到的流结束。</target>
        </trans-unit>
        <trans-unit id="0ffa679969428a6c8a5fbef9da583b1339b8f137" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error,E}&lt;/code&gt; and &lt;code&gt;{warning,W}&lt;/code&gt;, denoting syntactically incorrect forms and warnings.</source>
          <target state="translated">元组 &lt;code&gt;{error,E}&lt;/code&gt; 和 &lt;code&gt;{warning,W}&lt;/code&gt; ，表示语法上不正确的形式和警告。</target>
        </trans-unit>
        <trans-unit id="f4a5e32a69d4a4da5b271ce1389ce7de27bf6be9" translate="yes" xml:space="preserve">
          <source>Tuples and string formats accepted by versions before ssl-8.2.4 will be converted for backwards compatibility</source>
          <target state="translated">ssl-8.2.4之前的版本所接受的Tuple和字符串格式将被转换为向后兼容。</target>
        </trans-unit>
        <trans-unit id="f1ed151ede62f70799b920d57a42f17bd5fb2581" translate="yes" xml:space="preserve">
          <source>Tuples can have more than two parts, in fact as many parts as you want, and contain any valid Erlang &lt;strong&gt;term&lt;/strong&gt;. For example, to represent the temperature of various cities of the world:</source>
          <target state="translated">元组可以包含两个以上的部分，实际上可以根据需要包含任意多个部分，并且可以包含任何有效的Erlang &lt;strong&gt;术语&lt;/strong&gt;。例如，代表世界上各个城市的温度：</target>
        </trans-unit>
        <trans-unit id="ef0f5b8ef4ff33f41dc26081793feb3c120d0be9" translate="yes" xml:space="preserve">
          <source>Tuples have a fixed number of items in them. Each item in a tuple is called an &lt;strong&gt;element&lt;/strong&gt;. In the tuple &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt;, element 1 is &lt;code&gt;moscow&lt;/code&gt; and element 2 is &lt;code&gt;{c,-10}&lt;/code&gt;. Here &lt;code&gt;c&lt;/code&gt; represents Celsius and &lt;code&gt;f&lt;/code&gt; Fahrenheit.</source>
          <target state="translated">元组中有固定数量的项目。元组中的每个项目都称为一个&lt;strong&gt;元素&lt;/strong&gt;。在元组 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 中，元素1是 &lt;code&gt;moscow&lt;/code&gt; ，元素2是 &lt;code&gt;{c,-10}&lt;/code&gt; 。这里 &lt;code&gt;c&lt;/code&gt; 代表摄氏温度， &lt;code&gt;f&lt;/code&gt; 代表华氏温度。</target>
        </trans-unit>
        <trans-unit id="6af244d55aef38e6c2274514e3d2ab60c94ed28b" translate="yes" xml:space="preserve">
          <source>Tuples in the template express if-exist tests for metadata keys. For example, the following tuple says that if &lt;code&gt;key1&lt;/code&gt; exists in the metadata map, print &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the value that &lt;code&gt;key1&lt;/code&gt; is associated with in the metadata map. If &lt;code&gt;key1&lt;/code&gt; does not exist, print nothing.</source>
          <target state="translated">模板中的元组表示是否存在元数据键的测试。例如，以下元组说，如果 &lt;code&gt;key1&lt;/code&gt; 存在于元数据映射中，则打印 &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt; ，其中 &lt;code&gt;Value&lt;/code&gt; 是与 &lt;code&gt;key1&lt;/code&gt; 在元数据映射中关联的值。如果 &lt;code&gt;key1&lt;/code&gt; 不存在，则不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="243da839e833dcd6a7348ba4d1efa268f8e8a3ec" translate="yes" xml:space="preserve">
          <source>Tuples, maps, and lists (except strings, see below) are built in reverse polish notation, so that to build a tuple, the elements are specified first, and then the tuple term, with a count. Likewise for lists and maps.</source>
          <target state="translated">图元组、地图和列表(字符串除外,见下文)都是用反向抛光符号建立的,所以要建立一个元组,首先要指定元素,然后再指定元组项,并有一个计数。同样,列表和地图也是如此。</target>
        </trans-unit>
        <trans-unit id="8d71459c65d809aa4497f4a28bfc896fb1085c9c" translate="yes" xml:space="preserve">
          <source>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt;. If the input is already a template, it is not modified further.</source>
          <target state="translated">将语法树或树列表转换为一个或多个模板。模板可以实例化或匹配，并使用 &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt; 还原回普通语法树。如果输入已经是模板，则不会进一步修改。</target>
        </trans-unit>
        <trans-unit id="d8971cba7199bca87b23c2ec538c7121c59edc40" translate="yes" xml:space="preserve">
          <source>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., &lt;code&gt;_@Foo&lt;/code&gt; in the template becomes the variable &lt;code&gt;Foo&lt;/code&gt; in the meta-template. Furthermore, variables ending with &lt;code&gt;@&lt;/code&gt; are automatically wrapped in a call to merl:term/1, so e.g. &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; in the meta-template.</source>
          <target state="translated">将模板变成代表该模板的语法树。如果模板中的元变量名称（在元变量前缀字符之后）以大写字母开头，则它们将转换为普通的Erlang变量。例如，模板中的 &lt;code&gt;_@Foo&lt;/code&gt; 成为元模板中的变量 &lt;code&gt;Foo&lt;/code&gt; 。此外，以 &lt;code&gt;@&lt;/code&gt; 结尾的变量会自动包装在对merl：term / 1的调用中，因此，例如 &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11fdfc294615cd6feba1dc471497bd296595a74" translate="yes" xml:space="preserve">
          <source>Turn an error reason returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; into a readable string.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 返回的错误原因转换为可读字符串。</target>
        </trans-unit>
        <trans-unit id="0a32475174f92b9fb2f8542dc37a90aaa235a8d8" translate="yes" xml:space="preserve">
          <source>Turn off monitoring of the SNMP manager.</source>
          <target state="translated">关闭对SNMP管理器的监控。</target>
        </trans-unit>
        <trans-unit id="1596e715102816d11edb68278af146f787525ee2" translate="yes" xml:space="preserve">
          <source>Turn on and pare down debugging</source>
          <target state="translated">开启并减少调试</target>
        </trans-unit>
        <trans-unit id="8d0273b96fc2970b3bd22f825df50106f57a4d5f" translate="yes" xml:space="preserve">
          <source>Turn on distribution tracing on the Erlang node.</source>
          <target state="translated">在Erlang节点上开启分布追踪。</target>
        </trans-unit>
        <trans-unit id="4b6673d76d88179b888141748a220ac4df22b7da" translate="yes" xml:space="preserve">
          <source>Turn on global tracing</source>
          <target state="translated">开启全局追踪</target>
        </trans-unit>
        <trans-unit id="b5fd46c0414339fbc6a9a1e9bcad5db789cc32cf" translate="yes" xml:space="preserve">
          <source>Turning the scrollable_cursors option off is noted to make old odbc-drivers able to connect that will otherwhise fail.</source>
          <target state="translated">关闭scrollable_cursors选项是为了使旧的odbc-drivers能够连接,否则会失败。</target>
        </trans-unit>
        <trans-unit id="b3754a20c309fb4bee5151fc9185df3eb19690cf" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;Expr&lt;/code&gt; into a &quot;test object&quot;, by wrapping it in a fun-expression and a source line number. Technically, this is the same as &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;Expr&lt;/code&gt; 封装在fun-expression和源行号中，将其变成&amp;ldquo;测试对象&amp;rdquo;。从技术上讲，这与 &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f90beb2441a8b6db181aba2d7f261f9f114ad008" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the net kernel was started using &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;{error, not_allowed}&lt;/code&gt; is returned. Returns &lt;code&gt;{error, not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">将分布式节点转变为非分布式节点。对于网络中的其他节点，这与发生故障的节点相同。仅当使用 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 启动网络内核时才可能，否则返回 &lt;code&gt;{error, not_allowed}&lt;/code&gt; 。如果本地节点未处于活动状态 &lt;code&gt;{error, not_found}&lt;/code&gt; 则返回{error，not_found}。</target>
        </trans-unit>
        <trans-unit id="d9857baf63bd4ff78f8a1416e9cce2328191833c" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node by starting &lt;code&gt;net_kernel&lt;/code&gt; and other necessary processes.</source>
          <target state="translated">通过启动 &lt;code&gt;net_kernel&lt;/code&gt; 和其他必要的过程，将非分布式节点转变为分布式节点。</target>
        </trans-unit>
        <trans-unit id="3f5c74d445a6ff38a1d1a5a031b9bc86b2fedd78" translate="yes" xml:space="preserve">
          <source>Turns a parsed dictionary, as returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt;, back into the dictionary format.</source>
          <target state="translated">将由 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 返回的已解析字典转回字典格式。</target>
        </trans-unit>
        <trans-unit id="e92b0eef302a90ddf93e3d3b8a0765906432d6ac" translate="yes" xml:space="preserve">
          <source>Turns an ordered list &lt;code&gt;List&lt;/code&gt; of key-value tuples into a tree. The list must not contain duplicate keys.</source>
          <target state="translated">将键值元组的有序列表 &lt;code&gt;List&lt;/code&gt; 变成树。该列表不得包含重复的键。</target>
        </trans-unit>
        <trans-unit id="8629e653fd2bdd0ad7cbe844c08311477772efcc" translate="yes" xml:space="preserve">
          <source>Turns an ordered-set list &lt;code&gt;List&lt;/code&gt; into a set. The list must not contain duplicates.</source>
          <target state="translated">将有序集合列表 &lt;code&gt;List&lt;/code&gt; 变成集合。该列表不得包含重复项。</target>
        </trans-unit>
        <trans-unit id="9373344ff9c8b8d02dd03592aeaf47c2fd0e64a6" translate="yes" xml:space="preserve">
          <source>Turns off all debugging for the process. This includes functions that are installed explicitly with function &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt;, for example, triggers.</source>
          <target state="translated">关闭该进程的所有调试。这包括与功能 &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt; 一起显式安装的功能，例如触发器。</target>
        </trans-unit>
        <trans-unit id="d36edf7582655f75400ba16943847aa4c6aa0271" translate="yes" xml:space="preserve">
          <source>Turns off warnings for &quot;fresh&quot; variables in functional objects or list comprehensions with the same name as some already defined variable. Default is to emit warnings for such variables.</source>
          <target state="translated">关闭对功能对象或列表理解中的 &quot;新鲜 &quot;变量的警告,这些变量的名称与某些已经定义的变量相同。默认情况下,对此类变量发出警告。</target>
        </trans-unit>
        <trans-unit id="c093c691688f1f921a86e4bb9a9da3d6975d7358" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions like &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; does, but only for the mentioned functions. &lt;code&gt;MFAs&lt;/code&gt; is a tuple &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">像 &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; 一样，关闭对已弃用函数的调用的警告，但仅针对所提及的函数。 &lt;code&gt;MFAs&lt;/code&gt; 是元组 &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; 或此类元组的列表。</target>
        </trans-unit>
        <trans-unit id="31c129b33c46ffb547299340b27a43f495c00d43" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions. Default is to emit warnings for every call to a function known by the compiler to be deprecated. Notice that the compiler does not know about attribute &lt;code&gt;-deprecated()&lt;/code&gt;, but uses an assembled list of deprecated functions in Erlang/OTP. To do a more general check, the Xref tool can be used. See also &lt;code&gt;xref(3)&lt;/code&gt; and the function &lt;code&gt;xref:m/1&lt;/code&gt;, also accessible through the function &lt;code&gt;c:xm/1&lt;/code&gt;.</source>
          <target state="translated">关闭针对不推荐使用的函数的警告。默认是对编译器已知要弃用的每个函数发出警告。请注意，编译器不知道属性 &lt;code&gt;-deprecated()&lt;/code&gt; ，但是使用Erlang / OTP中已汇编的不推荐使用的函数列表。要进行更常规的检查，可以使用外部参照工具。另请参见 &lt;code&gt;xref(3)&lt;/code&gt; 和函数 &lt;code&gt;xref:m/1&lt;/code&gt; ，也可以通过函数 &lt;code&gt;c:xm/1&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="aee881859be77fa1680f379d9cb9a8b67406b5bf" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP.</source>
          <target state="translated">关闭对已经被删除的函数的调用的警告。默认情况下,当编译器知道某个函数最近被从 Erlang/OTP 中删除时,会发出警告。</target>
        </trans-unit>
        <trans-unit id="f5a9e8c56d11bc3f831ac60e969adff2295cdb81" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to modules or functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP.</source>
          <target state="translated">关闭对已被删除的模块或函数的调用的警告。默认情况下,当编译器知道某个函数最近被从 Erlang/OTP 中删除时,会发出警告。</target>
        </trans-unit>
        <trans-unit id="d8643ee4d5408ecde9d2dfad0ec79316bb062403" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to old type testing BIFs, such as &lt;code&gt;pid/1&lt;/code&gt; and &lt;code&gt;list/1&lt;/code&gt;. See the &lt;code&gt;Erlang Reference Manual&lt;/code&gt; for a complete list of type testing BIFs and their old equivalents. Default is to emit warnings for calls to old type testing BIFs.</source>
          <target state="translated">关闭对老式测试BIF（例如 &lt;code&gt;pid/1&lt;/code&gt; 和 &lt;code&gt;list/1&lt;/code&gt; )的调用的警告。有关类型测试BIF及其旧等效项的完整列表，请参见《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 》。默认值为对旧类型测试BIF的调用发出警告。</target>
        </trans-unit>
        <trans-unit id="858be8f3bcf091fa061e46059bd3158726b548e6" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions like &lt;code&gt;nowarn_unused_function&lt;/code&gt; does, but only for the mentioned local functions. &lt;code&gt;FAs&lt;/code&gt; is a tuple &lt;code&gt;{Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">关闭未使用的本地函数（如 &lt;code&gt;nowarn_unused_function&lt;/code&gt; )的警告，但仅针对提到的本地函数。 &lt;code&gt;FAs&lt;/code&gt; 是元组 &lt;code&gt;{Name,Arity}&lt;/code&gt; 或此类元组的列表。</target>
        </trans-unit>
        <trans-unit id="c5e54f68af28f7baa91e0a423d6d647a5b8f257e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions. Default is to emit warnings for all local functions that are not called directly or indirectly by an exported function. The compiler does not include unused local functions in the generated beam file, but the warning is still useful to keep the source code cleaner.</source>
          <target state="translated">关闭未使用的本地函数的警告。默认情况下,对所有未被导出函数直接或间接调用的局部函数发出警告。编译器不会将未使用的局部函数包含在生成的梁文件中,但该警告对于保持源代码的清洁还是很有用的。</target>
        </trans-unit>
        <trans-unit id="8756279a371f2c74c71bfe9ea11d8fce882bd7ef" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused record types. Default is to emit warnings for unused locally defined record types.</source>
          <target state="translated">关闭对未使用的记录类型的警告。默认为对未使用的本地定义的记录类型发出警告。</target>
        </trans-unit>
        <trans-unit id="40e660b8f492c229e1e8f807933c1bba4d2abc6f" translate="yes" xml:space="preserve">
          <source>Turns off warnings for use of deprecated types. Default is to emit warnings for every use of a type known by the compiler to be deprecated.</source>
          <target state="translated">关闭对使用废弃类型的警告。缺省值是对每次使用编译器已知的废弃类型时发出警告。</target>
        </trans-unit>
        <trans-unit id="176262640a2c391f662fb5a4f78d832cbe27740e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for uses of the &lt;code&gt;export_all&lt;/code&gt; option. Default is to emit a warning if option &lt;code&gt;export_all&lt;/code&gt; is also given.</source>
          <target state="translated">关闭有关 &lt;code&gt;export_all&lt;/code&gt; 选项使用的警告。如果还给出了选项 &lt;code&gt;export_all&lt;/code&gt; ,则默认为发出警告。</target>
        </trans-unit>
        <trans-unit id="849c8f41403b31c687964c8f844bbdc3100c6d15" translate="yes" xml:space="preserve">
          <source>Turns on (if &lt;code&gt;How == true&lt;/code&gt;) or off (if &lt;code&gt;How == false&lt;/code&gt;) the trace flags in &lt;code&gt;FlagList&lt;/code&gt; for the process or processes represented by &lt;code&gt;PidPortSpec&lt;/code&gt;.</source>
          <target state="translated">在转弯时（如 &lt;code&gt;How == true&lt;/code&gt; ）或关闭（如果 &lt;code&gt;How == false&lt;/code&gt; ）跟踪的标志 &lt;code&gt;FlagList&lt;/code&gt; 由代表一个或多个进程 &lt;code&gt;PidPortSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90d4fea9a9eccae1bb6537b80425ce163c0e0e56" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for all types of function calls. Trace messages are sent whenever any of the specified functions are called, regardless of how they are called. If flag &lt;code&gt;return_to&lt;/code&gt; is set for the process, a &lt;code&gt;return_to&lt;/code&gt; message is also sent when this function returns to its caller.</source>
          <target state="translated">为所有类型的函数调用打开或关闭调用跟踪。无论何时调用任何指定函数，无论如何调用，都会发送跟踪消息。如果为进程设置了标志 &lt;code&gt;return_to&lt;/code&gt; ,则当此函数返回其调用方时，也会发送 &lt;code&gt;return_to&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="9cdc9034760c5ba6cf5f548250769a126c6a5dc8" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for global function calls (that is, calls specifying the module explicitly). Only exported functions match and only global calls generate trace messages. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">为全局函数调用（即，明确指定模块的调用）打开或关闭调用跟踪。只有导出的函数匹配，并且只有全局调用才能生成跟踪消息。&lt;strong&gt;这是默认值&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="dbac06dc38fd14ffc69474d6cefe052fcc1e6496" translate="yes" xml:space="preserve">
          <source>Turns on or off meta-tracing for all types of function calls. Trace messages are sent to the tracer whenever any of the specified functions are called. If no tracer is specified, &lt;code&gt;self()&lt;/code&gt; is used as a default tracer process.</source>
          <target state="translated">为所有类型的函数调用打开或关闭元跟踪。每当调用任何指定功能时，跟踪消息就会发送到跟踪器。如果未指定跟踪器，则 &lt;code&gt;self()&lt;/code&gt; 用作默认跟踪器进程。</target>
        </trans-unit>
        <trans-unit id="a4a9e6071c635a8a8f47c7128d5e27fbe6794aa8" translate="yes" xml:space="preserve">
          <source>Turns on or off scheduler wall time measurements.</source>
          <target state="translated">开启或关闭调度器墙面时间测量。</target>
        </trans-unit>
        <trans-unit id="6491707b6fbdad098acea3fe30f8bc3c9caeff41" translate="yes" xml:space="preserve">
          <source>Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.</source>
          <target state="translated">开启/关闭微状态核算测量。当通过复位时,所有的计数器都被复位为0。</target>
        </trans-unit>
        <trans-unit id="49209b989e6c3ee063b36215b5a4316a9a7be144" translate="yes" xml:space="preserve">
          <source>Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is &lt;code&gt;AF_INET6&lt;/code&gt;).</source>
          <target state="translated">打开或关闭IPv4地址到IPv6地址的自动映射（如果套接字地址系列为 &lt;code&gt;AF_INET6&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f85ecd85cea1de6466fad134e2d2f8f716405e71" translate="yes" xml:space="preserve">
          <source>Turns on|off the Nagle algorithm for merging small packets into larger ones. This improves throughput at the expense of latency.</source>
          <target state="translated">打开|关闭Nagle算法,将小数据包合并成大数据包。这将以延迟为代价提高吞吐量。</target>
        </trans-unit>
        <trans-unit id="a1f9ac44326e752574b33a1f14907aa1c45d24f1" translate="yes" xml:space="preserve">
          <source>Turns the logging of system events on or off. If on, a maximum of &lt;code&gt;N&lt;/code&gt; events are kept in the debug structure (default is 10).</source>
          <target state="translated">打开或关闭系统事件的日志记录。如果启用，则调试结构中最多保留 &lt;code&gt;N&lt;/code&gt; 个事件（默认值为10）。</target>
        </trans-unit>
        <trans-unit id="23c458441c0867d8269280b70644bb94df142cbd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are supported:</source>
          <target state="translated">支持两种 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e3d52e5b54fd0236c6fd5f3a13294fee0ddff15" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;code&gt;match&lt;/code&gt; if they are of the same type and have the same value, so that &lt;code&gt;1&lt;/code&gt; matches &lt;code&gt;1&lt;/code&gt;, but not &lt;code&gt;1.0&lt;/code&gt; (as &lt;code&gt;1.0&lt;/code&gt; is a &lt;code&gt;float()&lt;/code&gt; and not an &lt;code&gt;integer()&lt;/code&gt;).</source>
          <target state="translated">如果两个Erlang项具有相同的类型并且具有相同的值，则它们 &lt;code&gt;match&lt;/code&gt; ，因此 &lt;code&gt;1&lt;/code&gt; 匹配 &lt;code&gt;1&lt;/code&gt; ，但不匹配 &lt;code&gt;1.0&lt;/code&gt; （因为 &lt;code&gt;1.0&lt;/code&gt; 是 &lt;code&gt;float()&lt;/code&gt; 而不是 &lt;code&gt;integer()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d09b25abb2a2cc4ca463f856d47434d8b27efd72" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;strong&gt;compare equal&lt;/strong&gt; if they either are of the same type and value, or if both are numeric types and extend to the same value, so that &lt;code&gt;1&lt;/code&gt; compares equal to both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">两方面的Erlang &lt;strong&gt;比较相等&lt;/strong&gt;，如果它们或者是相同的类型和值，或者如果两者都数字类型，并延伸到相同的值，从而使 &lt;code&gt;1&lt;/code&gt; 比较等于两个 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe9db2aa68d2fec9c04e8f17ebd9155b9b06ccb7" translate="yes" xml:space="preserve">
          <source>Two adjacent &lt;code&gt;*&lt;/code&gt; used as a single pattern match all files and zero or more directories and subdirectories.</source>
          <target state="translated">用作单个模式的两个相邻 &lt;code&gt;*&lt;/code&gt; 匹配所有文件以及零个或多个目录和子目录。</target>
        </trans-unit>
        <trans-unit id="b24fbae83d83ea5cfa4199071718c20f64dd2575" translate="yes" xml:space="preserve">
          <source>Two adjacent string literals are concatenated into one. This is done in the compilation, thus, does not incur any runtime overhead.</source>
          <target state="translated">两个相邻的字符串字元被连接成一个。这是在编译过程中完成的,因此,不会产生任何运行时的开销。</target>
        </trans-unit>
        <trans-unit id="1cec8b2ac60b473ad30ad5a9539e9b27a87fdf3d" translate="yes" xml:space="preserve">
          <source>Two are containers for binary data and are called:</source>
          <target state="translated">二是二进制数据的容器,称为。</target>
        </trans-unit>
        <trans-unit id="00afe0b16fc4b5dc8fb5d2b5e5c18c2ad4f6f71e" translate="yes" xml:space="preserve">
          <source>Two are merely references to a part of a binary and are called:</source>
          <target state="translated">二只是对二进制的一部分的引用,称为。</target>
        </trans-unit>
        <trans-unit id="98533a56936d4841968d6378e92444f0f102a983" translate="yes" xml:space="preserve">
          <source>Two cases can occur:</source>
          <target state="translated">会出现两种情况。</target>
        </trans-unit>
        <trans-unit id="f6f177120050db74caa4e744ec6cff39212557e9" translate="yes" xml:space="preserve">
          <source>Two different methods for opening a connection using the support functions in, for example, &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; follows:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 等支持功能打开连接的两种不同方法如下：</target>
        </trans-unit>
        <trans-unit id="d8398755c3e867c12fc5deb0d9e53ba2d8bf52d0" translate="yes" xml:space="preserve">
          <source>Two different names cannot define the same OBJECT IDENTIFIER.</source>
          <target state="translated">两个不同的名字不能定义同一个OBJECT IDENTIFIER。</target>
        </trans-unit>
        <trans-unit id="e330ec8353880267f056d94838df302f660f82d1" translate="yes" xml:space="preserve">
          <source>Two formats of the log files are supported:</source>
          <target state="translated">支持两种格式的日志文件。</target>
        </trans-unit>
        <trans-unit id="a4eef9b92d56df50918b227071f569535a9d01e3" translate="yes" xml:space="preserve">
          <source>Two forms have special meaning:</source>
          <target state="translated">两种形式具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="cfd82c68ad98788490ce7310efdb097df7571def" translate="yes" xml:space="preserve">
          <source>Two forms of &lt;code&gt;--inherits&lt;/code&gt; have special meaning:</source>
          <target state="translated">&lt;code&gt;--inherits&lt;/code&gt; 的两种形式具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="7200659e5edf764a36bafabfdd35b2bc1867bbcb" translate="yes" xml:space="preserve">
          <source>Two functions (modules, applications, releases) belong to the same strongly connected component if they call each other (in)directly. The interpretation of the &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; operator is the set of strongly connected components of a set of calls. The &lt;code&gt;condensation&lt;/code&gt; of a set of calls is a new set of calls between the strongly connected components such that there is an edge between two components if there is some constant of the first component that calls some constant of the second component.</source>
          <target state="translated">如果两个函数（模块，应用程序，发行版）彼此直接（间接）调用，则它们属于同一强连接的组件。 &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; 运算符的解释是一组调用中的一组强连接的组件。所述 &lt;code&gt;condensation&lt;/code&gt; 的一组呼叫的是一组新的强连接部件之间的呼叫，使得在这两个部件之间的边缘，如果有，调用第二组分的一些恒定的第一成分的一些常数。</target>
        </trans-unit>
        <trans-unit id="8330baa5a8c7712027a0d478bca1ae0572b758a5" translate="yes" xml:space="preserve">
          <source>Two guard BIFs handle maps:</source>
          <target state="translated">两个警卫BIF处理地图。</target>
        </trans-unit>
        <trans-unit id="0b0d7874fec4ed30ad6e8758caa4fe777cac7d9b" translate="yes" xml:space="preserve">
          <source>Two interoperability mechanisms are built into the Erlang runtime system, &lt;strong&gt;distributed Erlang&lt;/strong&gt; and &lt;strong&gt;ports&lt;/strong&gt;. A variation of ports is &lt;strong&gt;linked-in drivers&lt;/strong&gt;.</source>
          <target state="translated">Erlang运行时系统内置了两种互操作性机制，即&lt;strong&gt;分布式Erlang&lt;/strong&gt;和&lt;strong&gt;ports&lt;/strong&gt;。端口的变化是&lt;strong&gt;链接的驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5dedccf2b4c340ae3513b7f5da6ce218b6889bec" translate="yes" xml:space="preserve">
          <source>Two keys are considered equal if they match (&lt;code&gt;=:=&lt;/code&gt;). That is, numbers are compared literally rather than by value, so that, for example, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; are different keys.</source>
          <target state="translated">如果两个键匹配（ &lt;code&gt;=:=&lt;/code&gt; ），则认为它们相等。也就是说，数字是按字面意义而不是按值进行比较，因此，例如 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 是不同的键。</target>
        </trans-unit>
        <trans-unit id="211827ea828fd59c26ecf8cc7423a3ab35588d32" translate="yes" xml:space="preserve">
          <source>Two methods are available for writing database queries:</source>
          <target state="translated">编写数据库查询有两种方法。</target>
        </trans-unit>
        <trans-unit id="cad65263f8565f810c97115c267d8c4735088c82" translate="yes" xml:space="preserve">
          <source>Two more examples, both selecting Latin-1 as default encoding:</source>
          <target state="translated">还有两个例子,都选择Latin-1作为默认编码。</target>
        </trans-unit>
        <trans-unit id="310abdb2aa2e0aae49bd84e931c4347743cefcc7" translate="yes" xml:space="preserve">
          <source>Two old applications are of interest regarding interoperability. Both have been replaced by IC and are mentioned here for reference only:</source>
          <target state="translated">在互操作性方面,有两个旧的应用值得关注。这两个应用都已被IC所取代,在此仅作参考。</target>
        </trans-unit>
        <trans-unit id="b2ee15f30d25e865ebb91626574306b0a361ae12" translate="yes" xml:space="preserve">
          <source>Two processes can be &lt;strong&gt;linked&lt;/strong&gt; to each other. A link between two processes &lt;code&gt;Pid1&lt;/code&gt; and &lt;code&gt;Pid2&lt;/code&gt; is created by &lt;code&gt;Pid1&lt;/code&gt; calling the BIF &lt;code&gt;link(Pid2)&lt;/code&gt; (or conversely). There also exist a number of &lt;code&gt;spawn_link&lt;/code&gt; BIFs, which spawn and link to a process in one operation.</source>
          <target state="translated">两个过程可以相互&lt;strong&gt;链接&lt;/strong&gt;。两个进程 &lt;code&gt;Pid1&lt;/code&gt; 和 &lt;code&gt;Pid2&lt;/code&gt; 之间的链接是通过 &lt;code&gt;Pid1&lt;/code&gt; 调用BIF &lt;code&gt;link(Pid2)&lt;/code&gt; （或相反）来创建的。还存在许多 &lt;code&gt;spawn_link&lt;/code&gt; BIF，它们可以在一个操作中生成并链接到进程。</target>
        </trans-unit>
        <trans-unit id="66233b52f4a68d187c85f03b1740a9c4ed076273" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal if and only if they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当且仅当两个资源项在传递给 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 时会产生相同的资源对象指针时，它们才会比较相等。</target>
        </trans-unit>
        <trans-unit id="5608c70162089e189da4df1a1b5bf134008a262e" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal iff they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果两个资源项传递给 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 时它们将产生相同的资源对象指针，则它们将比较相等。</target>
        </trans-unit>
        <trans-unit id="af30a2501d3290d8d47d226b3a9dd6e2917631b1" translate="yes" xml:space="preserve">
          <source>Two sets are &lt;strong id=&quot;disjoint&quot;&gt;disjoint&lt;/strong&gt; if their intersection is the empty set.</source>
          <target state="translated">如果两个集合的交集为空集合，则它们是&lt;strong id=&quot;disjoint&quot;&gt;不&lt;/strong&gt;相交的。</target>
        </trans-unit>
        <trans-unit id="e7ebc9faf237e0b7af0081118908fcbec68ae6ca" translate="yes" xml:space="preserve">
          <source>Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">有两组元字符:除方括号内的元字符外,图案中任何地方都能识别的元字符,以及方括号内的元字符。方括号外的元字符如下。</target>
        </trans-unit>
        <trans-unit id="ca80cfab8caa7daafc007467d281bddd65b58bec" translate="yes" xml:space="preserve">
          <source>Two simple implementation(s) is provided with the toolkit; the modules &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; which is the default and &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">工具包提供了两个简单的实现。默认模块 &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8aad91307995a202add0f48ff4e5e1745721276" translate="yes" xml:space="preserve">
          <source>Two subterms are supported, &lt;code&gt;node_start&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">支持两个子项， &lt;code&gt;node_start&lt;/code&gt; 和 &lt;code&gt;eval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a86bc9ecf16a74feace03ab8af025d243363cf6" translate="yes" xml:space="preserve">
          <source>Two terms &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; compare equal if &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. They match if &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ,则两个项 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 比较相等。如果 &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ,则它们匹配。</target>
        </trans-unit>
        <trans-unit id="319ab96ab6a94c595bf510dc2b6df202a2c7e4fb" translate="yes" xml:space="preserve">
          <source>Two time types are defined within ASN.1: Generalized Time and Universal Time Coordinated (UTC). Both are assigned a value as an ordinary string within double quotes, for example, &quot;19820102070533.8&quot;.</source>
          <target state="translated">ASN.1中定义了两种时间类型。通用时间和世界协调时间(UTC)。两者都以双引号内的普通字符串形式赋值,例如,&quot;19820102070533.8&quot;。</target>
        </trans-unit>
        <trans-unit id="5cbed6cd9f648062eb5c7c60f1a880bc94c83866" translate="yes" xml:space="preserve">
          <source>Two trace drivers are currently implemented, the &lt;code&gt;file&lt;/code&gt; and the &lt;code&gt;ip&lt;/code&gt; trace drivers. The file driver sends all trace messages into one or several binary files, from where they later can be fetched and processed with the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; function. The ip driver opens a TCP/IP port where it listens for connections. When a client (preferably started by calling &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; on another Erlang node) connects, all trace messages are sent over the IP network for further processing by the remote client.</source>
          <target state="translated">当前实现了两个跟踪驱动程序，即 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;ip&lt;/code&gt; 跟踪驱动程序。文件驱动程序将所有跟踪消息发送到一个或几个二进制文件中，以后可以使用 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 函数从中提取并处理它们。ip驱动程序打开一个TCP / IP端口，在其中侦听连接。当客户端（最好通过在另一个Erlang节点上调用 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 启动）连接时，所有跟踪消息都将通过IP网络发送，以供远程客户端进一步处理。</target>
        </trans-unit>
        <trans-unit id="e5e6393335f1e611665a4a7a24f8bce5b9e0c892" translate="yes" xml:space="preserve">
          <source>Two types of counter arrays can be created with options &lt;code&gt;atomics&lt;/code&gt; or &lt;code&gt;write_concurrency&lt;/code&gt;. The &lt;code&gt;atomics&lt;/code&gt; counters have good allround performance with nice consistent semantics while &lt;code&gt;write_concurrency&lt;/code&gt; counters offers even better concurrent write performance at the expense of some potential read inconsistencies. See &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;atomics&lt;/code&gt; 或 &lt;code&gt;write_concurrency&lt;/code&gt; 选项创建两种类型的计数器数组。在 &lt;code&gt;atomics&lt;/code&gt; 柜台有很好的一致的语义良好的综合性能，同时 &lt;code&gt;write_concurrency&lt;/code&gt; 柜台报价甚至在一些潜在的代价更好的并发写入性能读不一致。参见 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c70732f422ad9f7dd9ec37500b2c8c51a72ca7dd" translate="yes" xml:space="preserve">
          <source>Two types of funs have slightly different semantics:</source>
          <target state="translated">两类趣味的语义略有不同。</target>
        </trans-unit>
        <trans-unit id="c611be8ba1da86ea53fc2e7c1dde0be77787929a" translate="yes" xml:space="preserve">
          <source>Two types of logs are supported:</source>
          <target state="translated">支持两种类型的日志。</target>
        </trans-unit>
        <trans-unit id="95838f01360f14fad0ac2ded66819bb7c9468ffa" translate="yes" xml:space="preserve">
          <source>Two upgrade instructions restart the emulator:</source>
          <target state="translated">两个升级指令重启模拟器。</target>
        </trans-unit>
        <trans-unit id="4806b67c077ea8929e31609963501c8a6fe89444" translate="yes" xml:space="preserve">
          <source>Two values are supported for &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; 支持两个值：</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="d651b987b0a7139ea05af6dee8d526234f2fc5bb" translate="yes" xml:space="preserve">
          <source>Type &quot;2 + 5.&quot; in the shell and then press Enter (carriage return). Notice that you tell the shell you are done entering code by finishing with a full stop &quot;.&quot; and a carriage return.</source>
          <target state="translated">在shell中输入 &quot;2+5.&quot;,然后按回车键(回车)。请注意,你用句号&quot;.&quot;和回车来告诉shell你已经完成了代码输入。</target>
        </trans-unit>
        <trans-unit id="58364f896fc728f993e560667ecfb60de4f30fa0" translate="yes" xml:space="preserve">
          <source>Type &quot;a&quot; to leave the Erlang system.</source>
          <target state="translated">输入 &quot;a &quot;离开Erlang系统。</target>
        </trans-unit>
        <trans-unit id="bb5acf833432a1b10201899b4168eeb24706098c" translate="yes" xml:space="preserve">
          <source>Type ::= &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</source>
          <target state="translated">输入:: = &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca7274bab6669941602b10cce52d6006cb9d4c5" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt;, that is, the HTTP method.</source>
          <target state="translated">输入 &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt; ，即HTTP方法。</target>
        </trans-unit>
        <trans-unit id="7b17bb0639b15e0f667e2fd419629250d1fac8bc" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt;. &lt;code&gt;parsed_header&lt;/code&gt; contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; for a listing of all header fields. For example, the date field is stored as &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt;. RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. &lt;code&gt;httpd&lt;/code&gt; ensures that all header field names are in lower case.</source>
          <target state="translated">键入 &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt; 。 &lt;code&gt;parsed_header&lt;/code&gt; 包含来自HTTP请求的所有HTTP标头字段，这些字段作为键值元组存储在列表中。有关所有标头字段的列表，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 。例如，日期字段存储为 &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt; 。RFC 2616定义HTTP为不区分大小写的协议，并且标头字段可以为小写或大写。 &lt;code&gt;httpd&lt;/code&gt; 确保所有标头字段名称都小写。</target>
        </trans-unit>
        <trans-unit id="88ea934d5b010cb0dc7ac9b9cf16bdd13e544370" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; is used to propagate data between modules. Depicted &lt;code&gt;interaction_data()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">类型 &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; 用于在模块之间传播数据。函数类型声明中描述的 &lt;code&gt;interaction_data()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6c98d13e8efa980132b032f5c0f337a67821802" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;which makensis.exe&lt;/code&gt; in the bash prompt and you should get the path to the program.</source>
          <target state="translated">在bash提示符下键入 &lt;code&gt;which makensis.exe&lt;/code&gt; ，您应该获得程序的路径。</target>
        </trans-unit>
        <trans-unit id="1a1f7e9e5b0f8e672e72370d1ca9a97b0c0c8e01" translate="yes" xml:space="preserve">
          <source>Type UTF8String is represented as a UTF-8 encoded binary in Erlang. Such binaries can be created directly using the binary syntax or by converting from a list of Unicode code points using function &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">UTF8String类型在Erlang中表示为UTF-8编码的二进制。可以使用二进制语法直接创建此类二进制文件，也可以使用 &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt; 函数从Unicode代码点列表进行转换来创建此类二进制文件。</target>
        </trans-unit>
        <trans-unit id="8e178121a16f6b2c746af40f7c8a4a42ab3a0ec2" translate="yes" xml:space="preserve">
          <source>Type constraints allowed in patterns</source>
          <target state="translated">模式中允许的类型限制</target>
        </trans-unit>
        <trans-unit id="0b347ce4e1bb3f750a45e84a0eec8e47bcbc5d1c" translate="yes" xml:space="preserve">
          <source>Type declarations can also be parameterized by including type variables between the parentheses. The syntax of type variables is the same as Erlang variables, that is, starts with an upper-case letter. Naturally, these variables can - and is to - appear on the RHS of the definition. A concrete example follows:</source>
          <target state="translated">类型声明也可以通过在括号之间加入类型变量来进行参数化。类型变量的语法与Erlang变量相同,即以大写字母开头。当然,这些变量可以--也是要--出现在定义的RHS上。下面是一个具体的例子。</target>
        </trans-unit>
        <trans-unit id="6300b103de258ff822aa6629b9e4238dd2a5ce7d" translate="yes" xml:space="preserve">
          <source>Type definitions related to HTTP:</source>
          <target state="translated">与HTTP相关的类型定义。</target>
        </trans-unit>
        <trans-unit id="833b41c81d15ae09af14347e83ccba5147adbd10" translate="yes" xml:space="preserve">
          <source>Type definitions that are related to URI:</source>
          <target state="translated">与URI相关的类型定义。</target>
        </trans-unit>
        <trans-unit id="b644ccc50476a72e86f7c39296fad76704713706" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</source>
          <target state="translated">在本模块中不止一次使用的类型定义,或表示数据类型预期用途的抽象,或两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="d2cf34335496de985396b3065117c3a7c2a8fa2b" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module:</source>
          <target state="translated">在本模块中不止一次使用的类型定义。</target>
        </trans-unit>
        <trans-unit id="589fe68e6ecbba2c443f7f0f1e09900382145a63" translate="yes" xml:space="preserve">
          <source>Type descriptors can be compared for equality or order (in the Erlang term order), but remember that floating-point values should in general never be tested for equality.</source>
          <target state="translated">类型描述符可以进行平等或顺序的比较(在Erlang术语中是顺序),但请记住,浮点值一般不应进行平等测试。</target>
        </trans-unit>
        <trans-unit id="dfb0b5d119973a2ca756d65efb3094aa7a2749aa" translate="yes" xml:space="preserve">
          <source>Type information can be used for the following:</source>
          <target state="translated">类型信息可用于以下方面:</target>
        </trans-unit>
        <trans-unit id="455328c30f9e89d8dd33028cd24752b9087d170d" translate="yes" xml:space="preserve">
          <source>Type letters on the right side</source>
          <target state="translated">在右边输入字母</target>
        </trans-unit>
        <trans-unit id="3ebeb58712dc090b9f1c0c555b88300efc0c9f1b" translate="yes" xml:space="preserve">
          <source>Type makensis at the bash prompt and you should get a list of options if everything is OK.</source>
          <target state="translated">在bash提示下输入makensis,如果一切正常,你应该会得到一个选项列表。</target>
        </trans-unit>
        <trans-unit id="e5d444f8eae5fc410e04ffff9e480446db812725" translate="yes" xml:space="preserve">
          <source>Type of lock: &lt;code&gt;rw_mutex&lt;/code&gt;, &lt;code&gt;mutex&lt;/code&gt;, &lt;code&gt;spinlock&lt;/code&gt;, &lt;code&gt;rw_spinlock&lt;/code&gt; or &lt;code&gt;proclock&lt;/code&gt;.</source>
          <target state="translated">锁的类型： &lt;code&gt;rw_mutex&lt;/code&gt; ， &lt;code&gt;mutex&lt;/code&gt; ， &lt;code&gt;spinlock&lt;/code&gt; ， &lt;code&gt;rw_spinlock&lt;/code&gt; 或 &lt;code&gt;proclock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab1c2b1113b129c21326cea282b309a413da68f9" translate="yes" xml:space="preserve">
          <source>Type tests: &lt;code&gt;is_atom&lt;/code&gt;, &lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_integer&lt;/code&gt;, &lt;code&gt;is_list&lt;/code&gt;, &lt;code&gt;is_number&lt;/code&gt;, &lt;code&gt;is_pid&lt;/code&gt;, &lt;code&gt;is_port&lt;/code&gt;, &lt;code&gt;is_reference&lt;/code&gt;, &lt;code&gt;is_tuple&lt;/code&gt;, &lt;code&gt;is_binary&lt;/code&gt;, &lt;code&gt;is_function&lt;/code&gt;, &lt;code&gt;is_record&lt;/code&gt;</source>
          <target state="translated">类型测试： &lt;code&gt;is_atom&lt;/code&gt; ， &lt;code&gt;is_float&lt;/code&gt; ， &lt;code&gt;is_integer&lt;/code&gt; ， &lt;code&gt;is_list&lt;/code&gt; ， &lt;code&gt;is_number&lt;/code&gt; ， &lt;code&gt;is_pid&lt;/code&gt; ， &lt;code&gt;is_port&lt;/code&gt; ， &lt;code&gt;is_reference&lt;/code&gt; ， &lt;code&gt;is_tuple&lt;/code&gt; ， &lt;code&gt;is_binary&lt;/code&gt; ， &lt;code&gt;is_function&lt;/code&gt; ， &lt;code&gt;is_record&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca8a72020b7154672a01a7e0906d7d4fb8f5305d" translate="yes" xml:space="preserve">
          <source>Type variables can be used in specifications to specify relations for the input and output arguments of a function. For example, the following specification defines the type of a polymorphic identity function:</source>
          <target state="translated">在规范中可以使用类型变量来指定函数的输入和输出参数的关系。例如,下面的规范定义了一个多态身份函数的类型。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="844d69ffa5852c018b86872fd3385643da1684b4" translate="yes" xml:space="preserve">
          <source>Types and function specifications</source>
          <target state="translated">类型和功能规格</target>
        </trans-unit>
        <trans-unit id="d9cf88052e09b9cf4919f33ab2053b176aa31518" translate="yes" xml:space="preserve">
          <source>Types corresponding to RFC 6733 AVP Data Formats. Defined in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对应于RFC 6733 AVP数据格式的类型。定义在 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="19b63cf79ea9c163682784b133c791343ee64d2c" translate="yes" xml:space="preserve">
          <source>Types declared as &lt;code&gt;opaque&lt;/code&gt; represent sets of terms whose structure is not supposed to be visible from outside of their defining module. That is, only the module defining them is allowed to depend on their term structure. Consequently, such types do not make much sense as module local - module local types are not accessible by other modules anyway - and is always to be exported.</source>
          <target state="translated">声明为 &lt;code&gt;opaque&lt;/code&gt; 类型表示术语集，这些术语的结构不应从其定义模块的外部看到。也就是说，只允许定义它们的模块取决于它们的术语结构。因此，此类类型的意义不大，因为模块本地-模块本地类型无论如何也不能被其他模块访问-始终要导出。</target>
        </trans-unit>
        <trans-unit id="535782a993effddbcbcaf96e815b800bf2866b08" translate="yes" xml:space="preserve">
          <source>Types describe sets of Erlang terms. Types consist of, and are built from, a set of predefined types, for example, &lt;code&gt;integer()&lt;/code&gt;, &lt;code&gt;atom()&lt;/code&gt;, and &lt;code&gt;pid()&lt;/code&gt;. Predefined types represent a typically infinite set of Erlang terms that belong to this type. For example, the type &lt;code&gt;atom()&lt;/code&gt; denotes the set of all Erlang atoms.</source>
          <target state="translated">类型描述Erlang术语集。类型由一组预定义类型组成，并从中构建，例如， &lt;code&gt;integer()&lt;/code&gt; ， &lt;code&gt;atom()&lt;/code&gt; 和 &lt;code&gt;pid()&lt;/code&gt; 。预定义类型表示属于该类型的典型的Erlang术语的无限集合。例如，类型 &lt;code&gt;atom()&lt;/code&gt; 表示所有Erlang原子的集合。</target>
        </trans-unit>
        <trans-unit id="16b7d8aee0365ea3f9bf161364bd57ac3691c6da" translate="yes" xml:space="preserve">
          <source>Types for Engines</source>
          <target state="translated">发动机的类型</target>
        </trans-unit>
        <trans-unit id="4826f9f1cd21548c629153b4f8bdd98bd55b49d6" translate="yes" xml:space="preserve">
          <source>Types that refer to themselves are called recursive types. Example:</source>
          <target state="translated">引用自身的类型被称为递归类型。例如:</target>
        </trans-unit>
        <trans-unit id="024abbee89dd93c227a8c61717c55412558d1806" translate="yes" xml:space="preserve">
          <source>Types used in TLS/DTLS</source>
          <target state="translated">TLS/DTLS中使用的类型</target>
        </trans-unit>
        <trans-unit id="1c02047b4473ab1d57fc7225f4164216e6bcfaf2" translate="yes" xml:space="preserve">
          <source>Types:</source>
          <target state="translated">Types:</target>
        </trans-unit>
        <trans-unit id="2f711f90b7022e079d8d5f49cef08ad4c28d080c" translate="yes" xml:space="preserve">
          <source>Typical &lt;code&gt;Reasons&lt;/code&gt;s:</source>
          <target state="translated">典型 &lt;code&gt;Reasons&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="129bb568100797e751f2b2f98cd51094a6287657" translate="yes" xml:space="preserve">
          <source>Typical Error Reasons</source>
          <target state="translated">典型的错误原因</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">典型的错误原因有:</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">典型的错误原因。</target>
        </trans-unit>
        <trans-unit id="a875996fe6fd67197a25c652eb601e185ed5cc23" translate="yes" xml:space="preserve">
          <source>Typical error reasons: as for &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; if a file had to be opened, and as for &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">典型的错误原因：对于 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 是否必须打开文件，以及对于 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc74151b7056fe15fd99a84d554133408c7c5852" translate="yes" xml:space="preserve">
          <source>Typical usage when writing to a file descriptor looks like this:</source>
          <target state="translated">写入文件描述符时的典型用法是这样的。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="987aa67db85afce4340f54b81c2c1c09452ae62a" translate="yes" xml:space="preserve">
          <source>Typical users of the dirty CPU schedulers are large garbage collections, json protocol encode/decoders written as nifs and matrix manipulation libraries.</source>
          <target state="translated">dirty CPU调度器的典型用户是大型垃圾收集、写成nifs的json协议编码/解码器和矩阵操作库。</target>
        </trans-unit>
        <trans-unit id="866cbe1e9d381ba3cdbeb39e4730521fbfcc8133" translate="yes" xml:space="preserve">
          <source>Typical users of the dirty IO schedulers are reading and writing to files.</source>
          <target state="translated">脏IO调度器的典型用户是对文件的读写。</target>
        </trans-unit>
        <trans-unit id="fa0583dc7b5aaef5f34ea3fa51cd6e026a525fd0" translate="yes" xml:space="preserve">
          <source>Typically high &lt;code&gt;time&lt;/code&gt; values are bad and this is often the thing to look for. However, one should also look for high lock acquisition frequencies (#tries) since locks generate overhead and because high frequency could become problematic if they begin to have conflicts even if it is not shown in a particular test.</source>
          <target state="translated">通常，高 &lt;code&gt;time&lt;/code&gt; 值是不好的，这通常是要寻找的东西。但是，由于锁会产生开销，并且即使在特定的测试中未显示冲突，如果高频开始产生冲突，因为高频可能会成为问题，因此也应该寻找较高的锁定获取频率（#tries）。</target>
        </trans-unit>
        <trans-unit id="2c47ac130c9d90117072288c85fcf5d65c5fe895" translate="yes" xml:space="preserve">
          <source>Typically the operator, possibly running hundreds or thousands of test cases, does not want to fill the console with details about, or printouts from, specific test cases. By default, the operator only sees the following:</source>
          <target state="translated">通常情况下,操作者可能会运行几百个或几千个测试用例,他们不希望在控制台中填满关于特定测试用例的细节或打印输出。默认情况下,操作员只看到以下内容。</target>
        </trans-unit>
        <trans-unit id="97e9960729125226aaee305f3d87924465b5abf5" translate="yes" xml:space="preserve">
          <source>Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists.</source>
          <target state="translated">通常情况下,您希望先替换否定词,然后是别名,然后执行一个或多个扩展(有时您希望在进行主扩展之前对特定条目进行预扩展)。你可能想反复替换否定词和/或别名,以便在别名和扩展列表的右侧允许这种形式。</target>
        </trans-unit>
        <trans-unit id="4535970fd788996603de7fcae8b5b1132c50cf1f" translate="yes" xml:space="preserve">
          <source>Typically, OpenSSL engines provide a hardware implementation of specific cryptographic operations. The hardware implementation usually offers improved performance over its software-based counterpart, which is known as cryptographic acceleration.</source>
          <target state="translated">通常,OpenSSL引擎提供了特定加密操作的硬件实现。硬件实现通常比基于软件的对应系统提供更好的性能,这就是所谓的加密加速。</target>
        </trans-unit>
        <trans-unit id="c81772f74c1a9d8da4ff099d810781ce160aacf0" translate="yes" xml:space="preserve">
          <source>Typographic conventions:</source>
          <target state="translated">排版惯例:</target>
        </trans-unit>
        <trans-unit id="0d3d0996d3543e832deef4b0344dd80b1d22ba4d" translate="yes" xml:space="preserve">
          <source>UDP packets from the network</source>
          <target state="translated">来自网络的UDP数据包</target>
        </trans-unit>
        <trans-unit id="50aa3ec0f92e35711e8ffb982901d2c7f9850924" translate="yes" xml:space="preserve">
          <source>UDP queries are used unless resolver option &lt;code&gt;usevc&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which forces TCP queries. If the query is too large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.</source>
          <target state="translated">除非解析器选项 &lt;code&gt;usevc&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，否则将使用UDP查询，这将强制执行TCP查询。如果查询对于UDP太大，则使用TCP。对于常规DNS查询，大小限制为512字节。</target>
        </trans-unit>
        <trans-unit id="486c66a0286294375958525f91cdfdb3f82c9cb3" translate="yes" xml:space="preserve">
          <source>URI processing functions.</source>
          <target state="translated">URI处理功能。</target>
        </trans-unit>
        <trans-unit id="1d057bddb70164b040386e82de4c64661e29e8f2" translate="yes" xml:space="preserve">
          <source>URI to filename translation.</source>
          <target state="translated">URI到文件名的翻译。</target>
        </trans-unit>
        <trans-unit id="52c3521da24366089045fe93222bbbea327aa8ee" translate="yes" xml:space="preserve">
          <source>URI utility module</source>
          <target state="translated">URI实用模块</target>
        </trans-unit>
        <trans-unit id="2497da8c1e8f3017cb461e9ead3580ed94a9004a" translate="yes" xml:space="preserve">
          <source>URL Aliasing</source>
          <target state="translated">URL 别名</target>
        </trans-unit>
        <trans-unit id="f09d741a3ad78a10aeac235b7eda60b472c1c7ea" translate="yes" xml:space="preserve">
          <source>URL aliasing.</source>
          <target state="translated">URL别名。</target>
        </trans-unit>
        <trans-unit id="284501aa026d810fca5e30ec3e6fbb8b907a7d92" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt; ：//java.sun.com</target>
        </trans-unit>
        <trans-unit id="2390079739ca194b6adba26faaa714759aa93368" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt; ：//nsis.sourceforge.net/download</target>
        </trans-unit>
        <trans-unit id="d52349cc271c6019348a86ea4c491c0478f8cdd3" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt; ：//openssl.org/community/binaries.html</target>
        </trans-unit>
        <trans-unit id="b0133be96d80a337735afdf94d4b6d5617e90e15" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt; : //sourceforge.net/projects/mingw-w64/files/latest/download?source=files</target>
        </trans-unit>
        <trans-unit id="71a52ac449904e56f2f8f4257d980b456503a1c2" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt; ：//sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/</target>
        </trans-unit>
        <trans-unit id="b683663e96daabab32de2bda24157392f5a1dc1c" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt; ：//www.cygwin.com</target>
        </trans-unit>
        <trans-unit id="46c81ae6362771f7cb6b8c4396678a5639bfb460" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.oracle.com/java/technologies/javase-downloads.html&quot;&gt;http://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;http://www.oracle.com/java/technologies/javase-downloads.html&quot;&gt;http://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/code&gt; ：//www.oracle.com/java/technologies/javase-downloads.html</target>
        </trans-unit>
        <trans-unit id="276871ba1190025d3a896ad5f2648a68709c0037" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt; ：//msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx</target>
        </trans-unit>
        <trans-unit id="53f076fb21dd236ea02ee81db09d3c6d1a9c2d70" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">网址： &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt; ：//msys2.github.io/</target>
        </trans-unit>
        <trans-unit id="c130e8186817488b08e47f250bc88b4918c57145" translate="yes" xml:space="preserve">
          <source>URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba178104dbef5fc6beaedd696ad3c447ee9da6ac" translate="yes" xml:space="preserve">
          <source>UT1</source>
          <target state="translated">UT1</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="8c0cd56da21e982f4424f294a92af6cffab886e5" translate="yes" xml:space="preserve">
          <source>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can usually use heuristics to determine if a file is in UTF-8 or if it is encoded in ISO Latin-1 (one byte per character). The &lt;code&gt;unicode&lt;/code&gt; module can be used to determine if data can be interpreted as UTF-8:</source>
          <target state="translated">UTF-8的设计使得将数字超出7位ASCII范围的ISO Latin-1字符在解码为UTF-8时很少被视为有效。因此，通常可以使用试探法来确定文件是使用UTF-8格式还是使用ISO Latin-1编码（每个字符一个字节）。所述 &lt;code&gt;unicode&lt;/code&gt; 模块可用于确定数据是否可被解释为UTF-8：</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="7a2f970d37032e17cb13a44bc956fa4e60bba4ed" translate="yes" xml:space="preserve">
          <source>Unary +</source>
          <target state="translated">单音+</target>
        </trans-unit>
        <trans-unit id="898ecd6a265af9abef6adb306b4c0c9c0e00c767" translate="yes" xml:space="preserve">
          <source>Unary + - bnot not</source>
          <target state="translated">Unary+-bnot not</target>
        </trans-unit>
        <trans-unit id="684c6ddd5eb8c278f83bc5399212042f5f7e16e9" translate="yes" xml:space="preserve">
          <source>Unary -</source>
          <target state="translated">Unary -</target>
        </trans-unit>
        <trans-unit id="637d4f607a8fd2105b314306ae4c76ef4925ad36" translate="yes" xml:space="preserve">
          <source>Unary bitwise NOT</source>
          <target state="translated">单一位数 NOT</target>
        </trans-unit>
        <trans-unit id="c9d35054fa41b42db47e25b9d91e662cc93e9f89" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;FormatFun&lt;/code&gt; is used by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; for displaying the call that created the query handle of the table. Defaults to &lt;code&gt;undefined&lt;/code&gt;, which means that &lt;code&gt;info/1,2&lt;/code&gt; displays a call to &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt;. It is up to &lt;code&gt;FormatFun&lt;/code&gt; to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by &lt;code&gt;info/1,2&lt;/code&gt; though).</source>
          <target state="translated">一元回调函数 &lt;code&gt;FormatFun&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 使用，以显示创建表查询句柄的调用。默认为 &lt;code&gt;undefined&lt;/code&gt; ，这意味着 &lt;code&gt;info/1,2&lt;/code&gt; 显示对 &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt; 的调用。由 &lt;code&gt;FormatFun&lt;/code&gt; 决定是否以适当的方式显示表的选定对象。但是，如果选择一个字符列表进行显示，则它必须是一个可以被扫描和解析的Erlang表达式（尽管 &lt;code&gt;info/1,2&lt;/code&gt; 添加了一个尾点）。</target>
        </trans-unit>
        <trans-unit id="8a8cf6ea70815c5c8dc6febb5bc34ace0255c96a" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;InfoFun&lt;/code&gt; is to return information about the table. &lt;code&gt;undefined&lt;/code&gt; is to be returned if the value of some tag is unknown:</source>
          <target state="translated">一元回调函数 &lt;code&gt;InfoFun&lt;/code&gt; 将返回有关表的信息。如果某些标签的值未知，则返回 &lt;code&gt;undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1442c4ded70572e00f428d9108e7ae55df7a65b5" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;PreFun&lt;/code&gt; is called once before the table is read for the first time. If the call fails, the query evaluation fails.</source>
          <target state="translated">一元回调函数 &lt;code&gt;PreFun&lt;/code&gt; 在第一次读取表之前被调用一次。如果调用失败，则查询评估失败。</target>
        </trans-unit>
        <trans-unit id="5a92175579f60db68a9c361cc251147f8debf6b0" translate="yes" xml:space="preserve">
          <source>Unary logical NOT</source>
          <target state="translated">单元逻辑NOT</target>
        </trans-unit>
        <trans-unit id="27bb4c7fe8d37999952aa5b0af1c3595bd259bdb" translate="yes" xml:space="preserve">
          <source>UnaryGraphOp ::= &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</source>
          <target state="translated">UnaryGraphOp :: = &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01c0a17c153449bd9a04099f8971f3292a601fb" translate="yes" xml:space="preserve">
          <source>UnarySetOp ::= &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">UnarySetOp :: = &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="8707e2ffeef5fa8b41de5e679969a877cb9db6f0" translate="yes" xml:space="preserve">
          <source>Unblocks a log. A log can only be unblocked by the blocking process.</source>
          <target state="translated">解除对日志的封锁。日志只能通过封堵过程来解除封堵。</target>
        </trans-unit>
        <trans-unit id="fe39591d424d43f7cc9d6d4ca1303c1c24c48eab" translate="yes" xml:space="preserve">
          <source>Unbound and unsafe variables</source>
          <target state="translated">非约束和不安全变量</target>
        </trans-unit>
        <trans-unit id="b13fe86cfdf1fdbc7031b4349a4b6f2fc354ab38" translate="yes" xml:space="preserve">
          <source>Uncompressed Size</source>
          <target state="translated">未压缩尺寸</target>
        </trans-unit>
        <trans-unit id="0a4c7b6c3e87ff86f41e836e792f67b6c2bdf902" translate="yes" xml:space="preserve">
          <source>Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded:</source>
          <target state="translated">未压缩的大小(无符号的32位整数,以大字节顺序排列)是数据被压缩前的大小。压缩后的数据在被扩展后具有以下格式。</target>
        </trans-unit>
        <trans-unit id="848b92d8de0252bd79df355552090abc0668ced9" translate="yes" xml:space="preserve">
          <source>Uncompresses data with gz headers and checksum.</source>
          <target state="translated">用gz头和校验和解压数据。</target>
        </trans-unit>
        <trans-unit id="79897564d08477a4d49effa829f40061f9569280" translate="yes" xml:space="preserve">
          <source>Uncompresses data with zlib headers and checksum.</source>
          <target state="translated">用zlib头和校验和解压数据。</target>
        </trans-unit>
        <trans-unit id="6ad0694c3152ef1643cde8ba2d996a0323a6b4d2" translate="yes" xml:space="preserve">
          <source>Uncompresses data without zlib headers and checksum.</source>
          <target state="translated">解压没有zlib头和校验的数据。</target>
        </trans-unit>
        <trans-unit id="a1c0570481ff7f3e6ed039d51cc86442ea076a33" translate="yes" xml:space="preserve">
          <source>Undefined thread that is not a scheduler thread.</source>
          <target state="translated">未定义不是调度线程的线程。</target>
        </trans-unit>
        <trans-unit id="f7aa71224a65884ef564916a9d0da2f89835d7d4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;$ROOT/releases&lt;/code&gt;, a new directory &lt;code&gt;B&lt;/code&gt; is created, containing &lt;code&gt;ch_rel-2.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;$ROOT/releases&lt;/code&gt; ，创建一个新目录 &lt;code&gt;B&lt;/code&gt; ，其中包含 &lt;code&gt;ch_rel-2.rel&lt;/code&gt; ， &lt;code&gt;start.boot&lt;/code&gt; ， &lt;code&gt;sys.config&lt;/code&gt; 和 &lt;code&gt;relup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9db2e4f4f838b5c44fe9cf387c90abe7108283e8" translate="yes" xml:space="preserve">
          <source>Under Windows, batch file &lt;code&gt;etop.bat&lt;/code&gt; can be used.</source>
          <target state="translated">在Windows下，可以使用批处理文件 &lt;code&gt;etop.bat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3264cd9d9eb75df44ac7458f032202c1c187eb3e" translate="yes" xml:space="preserve">
          <source>Under Windows, the batch file &lt;code&gt;cdv.bat&lt;/code&gt; can be used.</source>
          <target state="translated">在Windows下，可以使用批处理文件 &lt;code&gt;cdv.bat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c9e5a121880663dee4769e1af65faa7b494736" translate="yes" xml:space="preserve">
          <source>Under a key, any number of named values can be stored. They have names, types, and data.</source>
          <target state="translated">在一个键下,可以存储任意数量的命名值。它们有名称、类型和数据。</target>
        </trans-unit>
        <trans-unit id="dd8f3b0e81b0f054de52ff314e53658c55941c1a" translate="yes" xml:space="preserve">
          <source>Under certain circumstances incompatible changes might be introduced even in parts of the system that should be compatible between releases. Things that might trigger incompatible changes like this are:</source>
          <target state="translated">在某些情况下,即使是系统中应该在不同版本之间兼容的部分,也可能会引入不兼容的变化。可能引发这种不兼容变化的情况有:</target>
        </trans-unit>
        <trans-unit id="572aa08aba747d5d8b7a4a50d789147e2afaec76" translate="yes" xml:space="preserve">
          <source>Under the &lt;strong&gt;Warnings&lt;/strong&gt; pull-down menu, there are buttons that control which discrepancies are reported to the user in the &lt;strong&gt;Warnings&lt;/strong&gt; window. By clicking these buttons, you can enable/disable a whole class of warnings. Information about the classes of warnings is found on the &quot;Warnings&quot; item under the &lt;strong&gt;Help&lt;/strong&gt; menu (in the rightmost top corner).</source>
          <target state="translated">在&amp;ldquo; &lt;strong&gt;警告&amp;rdquo;&lt;/strong&gt;下拉菜单下，有一些按钮可控制在&amp;ldquo; &lt;strong&gt;警告&amp;rdquo;&lt;/strong&gt;窗口中向用户报告哪些差异。通过单击这些按钮，可以启用/禁用整个警告类别。有关警告类别的信息，可在&amp;ldquo; &lt;strong&gt;帮助&amp;rdquo;&lt;/strong&gt;菜单（位于最右上角）下的&amp;ldquo;警告&amp;rdquo;项中找到。</target>
        </trans-unit>
        <trans-unit id="f9f2c37bc89cf9d5792256518a7724565bd0f1e9" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt; erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">标签&lt;strong&gt;= allocated_areas&lt;/strong&gt;下显示的信息类似于可以通过 &lt;code&gt; erlang:system_info(allocated_areas)&lt;/code&gt; 在活动节点上获得的信息。</target>
        </trans-unit>
        <trans-unit id="ae6ad23ca12e3d31111c9342b18cb40e19aa690d" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">标签&lt;strong&gt;= allocated_areas&lt;/strong&gt;下显示的信息类似于可以通过 &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt; 在活动节点上获得的信息。</target>
        </trans-unit>
        <trans-unit id="b011cdf662fa95678104f28ffe7a2bd2b09e3ee6" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt; erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在标记&lt;strong&gt;= allocator：&amp;lt;A&amp;gt;&lt;/strong&gt;下显示了有关分配器&amp;lt;A&amp;gt;的各种信息。该信息类似于可以通过 &lt;code&gt; erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; 在活动节点上获得的信息。有关更多信息，另请参见 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4c5641fd04e324ff84f71ed58f45687d78170d8" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在标记&lt;strong&gt;= allocator：&amp;lt;A&amp;gt;&lt;/strong&gt;下显示了有关分配器&amp;lt;A&amp;gt;的各种信息。该信息类似于可以通过 &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; 在活动节点上获得的信息。有关更多信息，另请参见 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d79bffcbce82c370cc6389413481bbd120a99622" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt; erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">标签&lt;strong&gt;= memory&lt;/strong&gt;下显示的信息类似于可以通过 &lt;code&gt; erlang:memory()&lt;/code&gt; 在活动节点上获得的信息。</target>
        </trans-unit>
        <trans-unit id="0d37cd225e87fcc610bec30b5a05911619436d89" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtainted on a living node with &lt;code&gt;erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">在标记&lt;strong&gt;= memory&lt;/strong&gt;下显示的信息类似于可以通过 &lt;code&gt;erlang:memory()&lt;/code&gt; 在活动节点上获得的信息。</target>
        </trans-unit>
        <trans-unit id="63ce4685b2bc584945411c035f09d36043b054a2" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=scheduler&lt;/strong&gt; is shown information about the current state and statistics of the schedulers in the runtime system. On operating systems that allow suspension of other threads, the data within this section reflects what the runtime system looks like when a crash occurs.</source>
          <target state="translated">在标记&lt;strong&gt;= scheduler&lt;/strong&gt;下显示了有关运行系统中调度程序的当前状态和统计信息。在允许暂停其他线程的操作系统上，此部分中的数据反映了发生崩溃时运行时系统的外观。</target>
        </trans-unit>
        <trans-unit id="c4dc6bd20baf250db6e40693e866b1962ff4e8bc" translate="yes" xml:space="preserve">
          <source>Under the tags &lt;strong&gt;=hash_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; and &lt;strong&gt;=index_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; is shown internal tables. These are mostly of interest for runtime system developers.</source>
          <target state="translated">内部表在标签&lt;strong&gt;= hash_table：&amp;lt;table_name&amp;gt;&lt;/strong&gt;和&lt;strong&gt;= index_table：&amp;lt;table_name&amp;gt;下&lt;/strong&gt;。这些是运行时系统开发人员最感兴趣的。</target>
        </trans-unit>
        <trans-unit id="bd488528eeec3369801c6ace7a039c15038c870d" translate="yes" xml:space="preserve">
          <source>Undo Operation</source>
          <target state="translated">撤销操作</target>
        </trans-unit>
        <trans-unit id="2cc501eac2fcb3163225e3af20fdf997e537c7a6" translate="yes" xml:space="preserve">
          <source>Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before.</source>
          <target state="translated">未记录的(旧)算法已被废弃,但仍在实施,因此依赖它们的旧代码将产生与之前相同的伪随机序列。</target>
        </trans-unit>
        <trans-unit id="87e34279dd28e6f111c12cefa204d1bbe4761338" translate="yes" xml:space="preserve">
          <source>Undocumented functions in this module are not to be used.</source>
          <target state="translated">本模块中未记录的功能不得使用。</target>
        </trans-unit>
        <trans-unit id="196d8f0f66ad490a457b6fb5d6806ec3993a5c10" translate="yes" xml:space="preserve">
          <source>Unfolds all occurrences of atoms in &lt;code&gt;ListIn&lt;/code&gt; to tuples &lt;code&gt;{Atom, true}&lt;/code&gt;.</source>
          <target state="translated">将ListIn中所有出现的原子 &lt;code&gt;ListIn&lt;/code&gt; 为元组 &lt;code&gt;{Atom, true}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d44efc32ffe75b3dcb95ec9933fa94f5e6f5bc0b" translate="yes" xml:space="preserve">
          <source>Unfortunately not only threads managed by the thread progress functionality may insert memory blocks. Other threads also needs to be taken care of. Other threads will not be as frequent users of this functionality as managed threads, so using a less efficient scheme for them is not that big of a problem. In order to handle unmanaged threads we use two reference counters. When an unmanaged thread enters this implementation it increments the reference counter currently used, and when it leaves this implementation it decrements the same reference counter. When the consumer thread calls &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; in order to determine when it is safe to move &lt;code&gt;head.unref_end&lt;/code&gt;, it also swaps reference counters for unmanaged threads. The previous current represents outstanding references from the time up to this point. The new current represents future reference following this point. When the consumer thread detects that we have both reached the desired thread progress and when the previous current reference counter reach zero it is safe to move the &lt;code&gt;head.unref_end&lt;/code&gt;.</source>
          <target state="translated">不幸的是，不仅由线程进度功能管理的线程可能会插入内存块。其他线程也需要照顾。其他线程将不像托管线程那样频繁地使用此功能，因此对它们使用效率较低的方案并不是什么大问题。为了处理非托管线程，我们使用两个引用计数器。当非托管线程进入此实现时，它将递增当前使用的引用计数器，而当离开此实现时，它将递减相同的引用计数器。当使用者线程调用 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 以确定何时安全移动 &lt;code&gt;head.unref_end&lt;/code&gt; ，它还会将引用计数器交换为非托管线程。以前的电流代表从那时起至今的杰出参考。在此之后，新的电流代表将来的参考。当使用者线程检测到我们都达到了所需的线程进度时，并且当先前的当前参考计数器达到零时，可以安全地移动 &lt;code&gt;head.unref_end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="3ab34ddc2bf3b987c39e2558abfd1de510704f88" translate="yes" xml:space="preserve">
          <source>Unicode binary encoded as UTF16 little endian.</source>
          <target state="translated">Unicode二进制编码为UTF16小恩迪。</target>
        </trans-unit>
        <trans-unit id="9476616408be8ddee79977abc7989cebfe910910" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows and MacOS X, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">Unicode文件名转换通过 &lt;code&gt;+fnu&lt;/code&gt; 开关打开。在Linux上，未显式说明文件名转换模式而启动的VM默认为 &lt;code&gt;latin1&lt;/code&gt; 作为本机文件名编码。在Windows和MacOS X上，默认行为是Unicode文件名转换。因此，默认情况下， &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 在这些系统上返回 &lt;code&gt;utf8&lt;/code&gt; （Windows在文件系统级别上未使用UTF-8，但是Erlang程序员可以放心地忽略它）。默认行为，如前所述，使用，变更选项 &lt;code&gt;+fnu&lt;/code&gt; 或 &lt;code&gt;+fnl&lt;/code&gt; 的VM，看到 &lt;code&gt;erl&lt;/code&gt; 程序。如果VM以Unicode文件名转换模式启动， &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回原子 &lt;code&gt;utf8&lt;/code&gt; 。开关 &lt;code&gt;+fnu&lt;/code&gt; 后面可以跟 &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; 或 &lt;code&gt;e&lt;/code&gt; ,以控制如何报告错误编码的文件名。</target>
        </trans-unit>
        <trans-unit id="0ae13754db32b01d8c677dc9a973140e8500d0a8" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows, MacOS X and Android, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">Unicode文件名转换通过 &lt;code&gt;+fnu&lt;/code&gt; 开关打开。在Linux上，未显式说明文件名转换模式而启动的VM默认为 &lt;code&gt;latin1&lt;/code&gt; 作为本机文件名编码。在Windows，MacOS X和Android上，默认行为是Unicode文件名转换。因此，默认情况下， &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 在这些系统上返回 &lt;code&gt;utf8&lt;/code&gt; （Windows在文件系统级别上未使用UTF-8，但是Erlang程序员可以放心地忽略它）。默认行为，如前所述，使用，变更选项 &lt;code&gt;+fnu&lt;/code&gt; 或 &lt;code&gt;+fnl&lt;/code&gt; 的VM，看到 &lt;code&gt;erl&lt;/code&gt; 程序。如果VM以Unicode文件名转换模式启动， &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 返回原子 &lt;code&gt;utf8&lt;/code&gt; 。开关 &lt;code&gt;+fnu&lt;/code&gt; 后面可以跟 &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; 或 &lt;code&gt;e&lt;/code&gt; ,以控制如何报告错误编码的文件名。</target>
        </trans-unit>
        <trans-unit id="988784de449d7b8cbc0704eff09bcd0c69371d5a" translate="yes" xml:space="preserve">
          <source>Unicode is a standard defining code points (numbers) for all known, living or dead, scripts. In principle, every symbol used in any language has a Unicode code point. Unicode code points are defined and published by the Unicode Consortium, which is a non-profit organization.</source>
          <target state="translated">Unicode是一个标准,它为所有已知的、活的或死的文字定义了码点(数字)。原则上,任何语言中使用的每个符号都有一个Unicode码点。Unicode码点由非营利组织Unicode Consortium定义和公布。</target>
        </trans-unit>
        <trans-unit id="753a9fc18dc38abc9e40310e1511762a587d6d68" translate="yes" xml:space="preserve">
          <source>Unicode metadata stored in PAX headers is preserved</source>
          <target state="translated">存储在PAX头中的Unicode元数据将被保留</target>
        </trans-unit>
        <trans-unit id="717d423333854e072ef433389e96fff5bd03e76d" translate="yes" xml:space="preserve">
          <source>Unicode support is basically UTF-8 based. To use Unicode characters, you either call &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; with option &lt;code&gt;unicode&lt;/code&gt;, or the pattern must start with one of these special sequences:</source>
          <target state="translated">Unicode支持基本上基于UTF-8。要使用Unicode字符，请使用 &lt;code&gt;unicode&lt;/code&gt; 选项调用 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; ，或者该模式必须以以下特殊序列之一开头：</target>
        </trans-unit>
        <trans-unit id="9619f5cd0ede72c7dc62df2d3b5ff34d2c75b610" translate="yes" xml:space="preserve">
          <source>Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced.</source>
          <target state="translated">Uniform floats具有非均匀的密度,因此小的值,即小于0.5的值在生成值接近0.0的时候会有较小的间隔,尽管在足够大的子范围内仍然是均匀分布的。新算法产生的均匀分布的浮点数为N*2.0^(-53),因此间距相等。</target>
        </trans-unit>
        <trans-unit id="4488ef1f56a2d01fb6e741f79e8378c71279a1d3" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high.</source>
          <target state="translated">统一整数范围的概率分布有一个偏斜,对于小范围的概率分布不明显,但对于小于生成器精度的大范围,产生低数的概率可能是高数概率的两倍。</target>
        </trans-unit>
        <trans-unit id="adabbdf2f0cec9c6d0d246d5a204f96b7e74b355" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce.</source>
          <target state="translated">大于或等于生成器精度的统一整数范围使用了浮点回落,只用52位计算,而52位比要求的范围小,因此并不是要求范围内的所有数都能生成。</target>
        </trans-unit>
        <trans-unit id="36e839dc7592fa37041cd55253f794215f4f6c06" translate="yes" xml:space="preserve">
          <source>Union of &lt;code&gt;rsa_digest_type()&lt;/code&gt;, &lt;code&gt;dss_digest_type()&lt;/code&gt;, and &lt;code&gt;ecdsa_digest_type()&lt;/code&gt;.</source>
          <target state="translated">联盟 &lt;code&gt;rsa_digest_type()&lt;/code&gt; ， &lt;code&gt;dss_digest_type()&lt;/code&gt; ，和 &lt;code&gt;ecdsa_digest_type()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a878275b775589505d998070ad22ad6d0081609" translate="yes" xml:space="preserve">
          <source>Unique Integers on a Runtime System Instance</source>
          <target state="translated">运行时系统实例上的唯一整数</target>
        </trans-unit>
        <trans-unit id="a2cc5144e25dba2fec68e539fbd788a730b7301a" translate="yes" xml:space="preserve">
          <source>Unique References on a Runtime System Instance</source>
          <target state="translated">在运行时系统实例上的唯一引用。</target>
        </trans-unit>
        <trans-unit id="1d658374db6cb2482782dbc55d76ade6be07a287" translate="yes" xml:space="preserve">
          <source>Unique Values</source>
          <target state="translated">独特的价值</target>
        </trans-unit>
        <trans-unit id="a306f316fd3f985303c362b8053185a26f2e0d45" translate="yes" xml:space="preserve">
          <source>Unique identifier for the application in the scope of the service. Defaults to the value of the &lt;code&gt;dictionary&lt;/code&gt; option.</source>
          <target state="translated">服务范围内应用程序的唯一标识符。默认为 &lt;code&gt;dictionary&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="5724b00a081ae3e8a4cc6f50314a3e776bc6f0d2" translate="yes" xml:space="preserve">
          <source>Unit Testing is testing of individual program &quot;units&quot; in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</source>
          <target state="translated">单元测试是对单个程序 &quot;单元 &quot;进行相对独立的测试。没有特定的大小要求:一个单元可以是一个函数、一个模块、一个进程,甚至是整个应用程序,但最典型的测试单元是单个函数或模块。为了测试一个单元,你需要指定一组单独的测试,设置最小的必要环境来运行这些测试(通常情况下,你根本不需要做任何设置),你需要运行测试并收集结果,最后你需要做任何必要的清理工作,以便以后可以再次运行测试。单元测试框架试图在这个过程的每一个阶段帮助你,这样就可以很容易地编写测试,很容易地运行它们,很容易地看到哪些测试失败了(这样你就可以修复错误)。</target>
        </trans-unit>
        <trans-unit id="9caddb3cd5b7265345df4fab350e48f214540b46" translate="yes" xml:space="preserve">
          <source>Universal Time. UT1 is based on the rotation of the earth and conceptually means solar time at 0&amp;deg; longitude.</source>
          <target state="translated">世界时间。UT1基于地球的自转，从概念上讲是指经度为0&amp;deg;的太阳时间。</target>
        </trans-unit>
        <trans-unit id="67fdab77a1c02655cb90e9076adda573749aee76" translate="yes" xml:space="preserve">
          <source>Universaltime</source>
          <target state="translated">Universaltime</target>
        </trans-unit>
        <trans-unit id="f0fd69818de3f9565ba68951c5c09c08312d1123" translate="yes" xml:space="preserve">
          <source>Unix 'tar' utility for reading and writing tar archives.</source>
          <target state="translated">Unix 'tar' 工具,用于读取和写入 tar 档案。</target>
        </trans-unit>
        <trans-unit id="c497be34c3d12775e6c6e249a2bb96e5096e4688" translate="yes" xml:space="preserve">
          <source>Unix example: &lt;code&gt;/usr/local/bin&lt;/code&gt;</source>
          <target state="translated">Unix示例： &lt;code&gt;/usr/local/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52db1f36f26e76a3a2c634008d80678e33f56bbd" translate="yes" xml:space="preserve">
          <source>Unknown Functions.</source>
          <target state="translated">未知功能。</target>
        </trans-unit>
        <trans-unit id="b20270332ab7fc1d7887105b864abda119f91200" translate="yes" xml:space="preserve">
          <source>Unknown Modules.</source>
          <target state="translated">不明模块。</target>
        </trans-unit>
        <trans-unit id="c3ac576a2d7732a8c0c77a12f249926d64da2561" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is fixated using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a call to &lt;code&gt;next/2&lt;/code&gt; will fail if &lt;code&gt;Key1&lt;/code&gt; no longer exists in the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function always returns the next key after &lt;code&gt;Key1&lt;/code&gt; in term order, regardless whether &lt;code&gt;Key1&lt;/code&gt; ever existed in the table.</source>
          <target state="translated">除非类型的表 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ，或 &lt;code&gt;duplicate_bag&lt;/code&gt; 使用迷恋 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; ，一个以呼叫 &lt;code&gt;next/2&lt;/code&gt; ，如果将失败 &lt;code&gt;Key1&lt;/code&gt; 不再在表中存在。对于表类型 &lt;code&gt;ordered_set&lt;/code&gt; ，该函数始终按术语顺序返回 &lt;code&gt;Key1&lt;/code&gt; 之后的下一个键，而不管表中是否存在 &lt;code&gt;Key1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c65364e9fb4489250a3ae7948a13788521c35e" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns a list containing object &lt;code&gt;I&lt;/code&gt; in Erlang term order.</source>
          <target state="translated">除非类型的表 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ，或 &lt;code&gt;duplicate_bag&lt;/code&gt; 正在使用保护 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; ，如果并发更新是对表进行遍历可能失败。对于表类型 &lt;code&gt;ordered_set&lt;/code&gt; ，该函数以Erlang术语顺序返回包含对象 &lt;code&gt;I&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="efdfb6336f1dc28fe44fc86849dcd9997db099f2" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the next key in order, even if the object does no longer exist.</source>
          <target state="translated">除非类型的表 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; ，或 &lt;code&gt;duplicate_bag&lt;/code&gt; 正在使用保护 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; ，如果并发更新是对表进行遍历可能失败。对于表类型 &lt;code&gt;ordered_set&lt;/code&gt; ，即使该对象不再存在，该函数也会按顺序返回下一个键。</target>
        </trans-unit>
        <trans-unit id="743984ff40a29e25f3a91777282531a480bea68e" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified by the options, all modules are assumed to be at least &quot;static&quot;, and all except the target module are assumed to be &quot;safe&quot;. See the &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; options for details.</source>
          <target state="translated">除非选项另有说明，否则所有模块均假定为至少&amp;ldquo;静态&amp;rdquo;，而目标模块以外的所有模块均假定为&amp;ldquo;安全&amp;rdquo;。有关详细信息，请参见 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;safe&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6fd12a82bf92d67e237725f9648f0226fb3bb44f" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output.</source>
          <target state="translated">除非另有规定,否则返回值类型和编码与输入类型和编码相同。也就是说,二进制输入返回二进制输出,列表输入返回列表输出,但混合输入返回列表输出。</target>
        </trans-unit>
        <trans-unit id="2452df07cb8ca79cfe0600811352c2e7e3686be8" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output.</source>
          <target state="translated">除非另有规定,否则返回值类型与输入类型相同。也就是说,二进制输入返回二进制输出,列表输入返回列表输出,混合输入可以返回混合输出。</target>
        </trans-unit>
        <trans-unit id="f3df395f5cdf2fa36eee4743206fa60a6a1a66c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.</source>
          <target state="translated">除非另有规定,否则所有控制序列的前导空格将被忽略。一个输入字段的宽度不能超过一行。</target>
        </trans-unit>
        <trans-unit id="4a1cc2b0ee63b4df93cb4cef8c16bee9110c56a5" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, the order of the registered filters will be the order in which they are registered.</source>
          <target state="translated">除非另有规定,否则已注册的过滤器的顺序将是它们注册的顺序。</target>
        </trans-unit>
        <trans-unit id="336e16f5b15c1bb3924a2d4ee1f281da2f5d2f39" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</source>
          <target state="translated">除非另有说明,否则所有函数都假定位置编号从1开始,也就是说,列表的第一个元素在位置1。</target>
        </trans-unit>
        <trans-unit id="a5744f08804fbcbd546e4dfc2b0e6fcafee559f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_server&lt;/code&gt; process does not exist or if bad arguments are specified.</source>
          <target state="translated">除非另有说明，否则如果指定的 &lt;code&gt;gen_server&lt;/code&gt; 进程不存在或指定了错误的参数，则此模块中的所有功能都会失败。</target>
        </trans-unit>
        <trans-unit id="33f0b9bf676eb2bfd97e1ca14eb9192d3876198f" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_statem&lt;/code&gt; does not exist or if bad arguments are specified.</source>
          <target state="translated">除非另有说明，否则如果指定的 &lt;code&gt;gen_statem&lt;/code&gt; 不存在或指定了错误的参数，则此模块中的所有功能都会失败。</target>
        </trans-unit>
        <trans-unit id="2130ed65fd03b5efa6f9266bb204f3dc0f269a98" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</source>
          <target state="translated">除非另有说明,如果指定的事件管理器不存在或者指定了坏的参数,本模块的所有函数都会失败。</target>
        </trans-unit>
        <trans-unit id="94ecf2431ac506145df210d3f762df7ef9ac568e" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified.</source>
          <target state="translated">除非另有说明,如果指定的主管网桥不存在或者指定了坏的参数,本模块的所有函数都会失败。</target>
        </trans-unit>
        <trans-unit id="ce6e960d5712a50515c10d0e5588263e19e9ce6b" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</source>
          <target state="translated">除非另有说明,如果指定的上级不存在或者指定了坏的参数,本模块中的所有函数都会失败。</target>
        </trans-unit>
        <trans-unit id="5c7ee08644b98d18eca27766dd86d186eaca4f73" translate="yes" xml:space="preserve">
          <source>Unless specified by the user when the array is created, the default value is the atom &lt;code&gt;undefined&lt;/code&gt;. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt;). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries.</source>
          <target state="translated">除非用户在创建数组时指定，否则默认值为原子 &lt;code&gt;undefined&lt;/code&gt; 。未设置的条目和已显式设置为与默认值相同的值（比较 &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt; ）之间没有区别。如果需要区分未设置条目和设置条目，请确保默认值不能与设置条目的值混淆。</target>
        </trans-unit>
        <trans-unit id="dd13caf6027b189cef2a36a20e0fd13e56485aad" translate="yes" xml:space="preserve">
          <source>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (&lt;code&gt;code:get_path()&lt;/code&gt;). This means that the names of typical &quot;app&quot; files can be used directly, without a path, e.g., &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt;.</source>
          <target state="translated">除非文件名是绝对的，否则首先将相对于当前目录搜索文件，然后使用常规搜索路径（ &lt;code&gt;code:get_path()&lt;/code&gt; ）。这意味着可以直接使用典型的&amp;ldquo; app&amp;rdquo;文件的名称，而无需使用路径，例如 &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07a837b10265d2be2c9f800bf253594222b1cdf6" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, calls to &lt;code&gt;bchunk/2&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">除非使用 &lt;code&gt;safe_fixtable/2&lt;/code&gt; 保护表，否则如果对表进行并发更新，则对 &lt;code&gt;bchunk/2&lt;/code&gt; 的调用可能无法按预期方式工作。</target>
        </trans-unit>
        <trans-unit id="ec243991d25d3f676894294544e13f5bc4cfeae2" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, subsequent calls to &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">除非使用 &lt;code&gt;safe_fixtable/2&lt;/code&gt; 保护表，否则如果对表进行并发更新，则对 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 的后续调用可能无法按预期方式工作。</target>
        </trans-unit>
        <trans-unit id="f2c55317241e5b2c59b25e3b0df5f88453b5f333" translate="yes" xml:space="preserve">
          <source>Unless the value is &lt;code&gt;none&lt;/code&gt;, the given function is called for each node whose list of annotations is not empty; see below for details. The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">除非值是 &lt;code&gt;none&lt;/code&gt; ，否则为注释列表不为空的每个节点调用给定函数；否则，将为每个节点调用给定函数。有关详情，请参见下文。默认值为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdff867eb339963be03bd21021856778c904302c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt;, Ifname is encoded a binary. In the unlikely case that a system is using non-7-bit-ASCII characters in network device names, special care has to be taken when encoding this argument.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; 不同，Ifname编码为二进制。如果系统在网络设备名称中使用非7位ASCII字符（这种情况不太可能发生），则在对该参数进行编码时必须格外小心。</target>
        </trans-unit>
        <trans-unit id="ae5c0bd0a60e997d1705e91f30f45cde14782afc" translate="yes" xml:space="preserve">
          <source>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</source>
          <target state="translated">与数据表不同,模式表中的信息只能通过使用本节中描述的模式相关函数进行访问和修改。</target>
        </trans-unit>
        <trans-unit id="315fbdc2014934db1db457f44c68e1cf848dbeb6" translate="yes" xml:space="preserve">
          <source>Unlike in &quot;plain Erlang&quot;, &lt;code&gt;proc_lib&lt;/code&gt; processes will not generate &lt;strong&gt;error reports&lt;/strong&gt;, which are written to the terminal by the emulator. All exceptions are converted to &lt;strong&gt;exits&lt;/strong&gt; which are ignored by the default &lt;code&gt;logger&lt;/code&gt; handler.</source>
          <target state="translated">与&amp;ldquo;普通Erlang&amp;rdquo;不同， &lt;code&gt;proc_lib&lt;/code&gt; 进程不会生成&lt;strong&gt;错误报告&lt;/strong&gt;，该&lt;strong&gt;错误报告&lt;/strong&gt;由仿真器写入终端。所有异常都将转换为默认 &lt;code&gt;logger&lt;/code&gt; 程序处理程序将忽略的&lt;strong&gt;出口&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8e53ff65d2dc51b350969a552119bea613d0b243" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send&lt;/a&gt;&lt;/code&gt; function, this one sends &lt;strong&gt;one message&lt;/strong&gt;. This means that if, for whatever reason, its not possible to send the message in one go, the function will instead return with the &lt;strong&gt;remaining&lt;/strong&gt; data (&lt;code&gt;{ok, Remaining}&lt;/code&gt;). Thereby leaving it up to the caller to decide what to do (retry with the remaining data of give up).</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 功能不同，此功能发送&lt;strong&gt;一条消息&lt;/strong&gt;。这意味着，如果由于某种原因无法一次发送消息，则该函数将返回&lt;strong&gt;剩余的&lt;/strong&gt;数据（ &lt;code&gt;{ok, Remaining}&lt;/code&gt; ）。从而将其留给调用方来决定要做什么（重试放弃的剩余数据）。</target>
        </trans-unit>
        <trans-unit id="4f0b46a073145149fc17e2f042255d68220cd4a4" translate="yes" xml:space="preserve">
          <source>Unload &lt;code&gt;Mibs&lt;/code&gt; from an agent. If it cannot unload all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where unloading was aborted.</source>
          <target state="translated">从代理卸载 &lt;code&gt;Mibs&lt;/code&gt; 。如果无法卸载所有MIB（ &lt;code&gt;Force&lt;/code&gt; 参数的默认值为 &lt;code&gt;false&lt;/code&gt; ），它将指示卸载在何处中止。</target>
        </trans-unit>
        <trans-unit id="01b2dca21a4f55d7d0fa16561ba72c0a5a938d9c" translate="yes" xml:space="preserve">
          <source>Unload a &lt;code&gt;Mib&lt;/code&gt; from the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">从管理器中卸载 &lt;code&gt;Mib&lt;/code&gt; 。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如，</target>
        </trans-unit>
        <trans-unit id="318d9f4d5f03a67d10200c73fcad432663d2f29b" translate="yes" xml:space="preserve">
          <source>Unload a single &lt;code&gt;Mib&lt;/code&gt; from an agent.</source>
          <target state="translated">从代理卸载单个 &lt;code&gt;Mib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769b903ce1d90a72efda3ccafb33dcd1f3d777a4" translate="yes" xml:space="preserve">
          <source>Unload the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument from the mib-server.</source>
          <target state="translated">从mib服务器卸载 &lt;code&gt;Filename&lt;/code&gt; 参数指定的mib。</target>
        </trans-unit>
        <trans-unit id="ddd4c00f912e6ef2189a832da23d9650d2872c8c" translate="yes" xml:space="preserve">
          <source>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (that is, this &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;) no longer needs the driver. That can, if there are no other users, trigger unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed.</source>
          <target state="translated">卸载可以描述为告诉仿真器该特定过程中该代码的特定部分（即该 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ）不再需要驱动程序的过程。如果没有其他用户，则可以触发驱动程序的卸载，在这种情况下，驱动程序名称将从系统中消失，并且（如果可能）回收驱动程序可执行代码占用的内存。</target>
        </trans-unit>
        <trans-unit id="f01cfbd5c8a37883cb11fbfce549beccf62c0bdc" translate="yes" xml:space="preserve">
          <source>Unloads an engine loaded with the &lt;code&gt;ensure_engine_loaded&lt;/code&gt; function. It both removes the label from the OpenSSL internal engine list and unloads the engine. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">卸载通过 &lt;code&gt;ensure_engine_loaded&lt;/code&gt; 函数加载的引擎。它既从OpenSSL内部引擎列表中删除标签，又卸载引擎。如果无法卸载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="39ecc66fc726ebe5dc1f5680017eb9863277fd3d" translate="yes" xml:space="preserve">
          <source>Unloads an engine loaded with the &lt;code&gt;ensure_engine_loaded&lt;/code&gt; function. It both removes the label from the OpenSSL internal engine list and unloads the engine. This function is the same as calling &lt;code&gt;ensure_engine_unloaded/2&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">卸载通过 &lt;code&gt;ensure_engine_loaded&lt;/code&gt; 函数加载的引擎。它既从OpenSSL内部引擎列表中删除标签，又卸载引擎。此功能与调用 &lt;code&gt;ensure_engine_unloaded/2&lt;/code&gt; 与 &lt;code&gt;EngineMethods&lt;/code&gt; 设置为所有可能的方法的列表。如果无法卸载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="7779518675ffce53110af3008d7744e065e1a5f3" translate="yes" xml:space="preserve">
          <source>Unloads the MIBs from agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">从代理 &lt;code&gt;snmp_master_agent&lt;/code&gt; 卸载MIB 。</target>
        </trans-unit>
        <trans-unit id="f4a3d6a062d2d5ee9eda88a5ecd1085fce084994" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-MIB.</source>
          <target state="translated">卸载OTP-MIB。</target>
        </trans-unit>
        <trans-unit id="c48f8e606621c6fa11b525d4c336815899ff648e" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-OS-MON-MIB.</source>
          <target state="translated">卸载OTP-OS-MON-MIB。</target>
        </trans-unit>
        <trans-unit id="66f8e5114123bed6be608b90ce2bc660face1031" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;Engine&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">卸载 &lt;code&gt;Engine&lt;/code&gt; 提供的OpenSSL引擎。如果无法卸载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="38ed8242b3b1b71902fb9d376310f5c95786abfe" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">卸载 &lt;code&gt;EngineId&lt;/code&gt; 给定的OpenSSL引擎。如果无法卸载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="5cff9e0ced01393a829b38eaa7e0451df21ea9d5" translate="yes" xml:space="preserve">
          <source>Unloads the application specification for &lt;code&gt;Application&lt;/code&gt; from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</source>
          <target state="translated">卸载的应用程序规范 &lt;code&gt;Application&lt;/code&gt; 从应用控制器。它还会卸载所有包含的应用程序的应用程序规范。请注意，该函数不会清除Erlang目标代码。</target>
        </trans-unit>
        <trans-unit id="351a6f889a5ded537e77bca6799737838e6f4f76" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, all remaining open ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; and the driver eventually gets unloaded.</source>
          <target state="translated">卸载或至少取消引用名为 &lt;code&gt;Name&lt;/code&gt; 的驱动程序。如果调用方是驱动程序的最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，则使用 &lt;code&gt;driver_unloaded&lt;/code&gt; 原因杀死使用该驱动程序的所有剩余打开端口，并最终卸载该驱动程序。</target>
        </trans-unit>
        <trans-unit id="2061febf2aa265ba0d12f05d42293814e13d57b8" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and no more open ports use the driver, the driver gets unloaded. Otherwise, unloading is delayed until all ports are closed and no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; remain.</source>
          <target state="translated">卸载或至少取消引用名为 &lt;code&gt;Name&lt;/code&gt; 的驱动程序。如果调用方是驱动程序的最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，并且不再有打开的端口使用该驱动程序，则该驱动程序将被卸载。否则，卸载将被延迟，直到所有端口都关闭并且没有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 可用为止。</target>
        </trans-unit>
        <trans-unit id="38ad66e7caef87bb85f8df32ab5caabf7bf35995" translate="yes" xml:space="preserve">
          <source>Unlocks a mutex. The mutex currently must be locked by the calling thread.</source>
          <target state="translated">解锁一个mutex。当前mutex必须由调用线程锁定。</target>
        </trans-unit>
        <trans-unit id="3b9b1fba9416c1278f7484dce6e469b9ce20199f" translate="yes" xml:space="preserve">
          <source>Unlocks the configuration target.</source>
          <target state="translated">解锁配置目标。</target>
        </trans-unit>
        <trans-unit id="19786a83cc46632e0d13d564e393de3e1de085fe" translate="yes" xml:space="preserve">
          <source>Unlocks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">解锁作为参数（ &lt;code&gt;pdl&lt;/code&gt; ）传递的端口数据锁。</target>
        </trans-unit>
        <trans-unit id="c1621249e0ef6ecc8c1156b8b07b094cf1d8ea3a" translate="yes" xml:space="preserve">
          <source>Unmanaged threads can delay thread progress being made:</source>
          <target state="translated">无人管理的线程会延迟线程的进展。</target>
        </trans-unit>
        <trans-unit id="9e529736ebba8b22ec528fcbede64fa669b39cc8" translate="yes" xml:space="preserve">
          <source>Unordered sending is configurable in &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt;. There is no special handling of DPR/DPA: since a user that cares about pending answers should wait for them before initiating DPR.</source>
          <target state="translated">无序发送是可以在 &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt; 中配置的。DPR / DPA没有特殊处理：因为关心未决答案的用户应在启动DPR之前等待它们。</target>
        </trans-unit>
        <trans-unit id="cdfeac47c5892b6d5954da0f63cd683192cebcee" translate="yes" xml:space="preserve">
          <source>Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</source>
          <target state="translated">无序集和有序集是正交的,同样在这个模块中,没有无序集等于任何有序集。</target>
        </trans-unit>
        <trans-unit id="0315bcb1361b2c68fa29fded47a0e3b15d0b5028" translate="yes" xml:space="preserve">
          <source>Unpacking and Installation of Release Packages</source>
          <target state="translated">解压和安装发行包</target>
        </trans-unit>
        <trans-unit id="3b45b03b4626e1a53bac859dec0524861ec0a57e" translate="yes" xml:space="preserve">
          <source>Unpacks a release package &lt;code&gt;Name.tar.gz&lt;/code&gt; located in the &lt;code&gt;releases&lt;/code&gt; directory.</source>
          <target state="translated">对位于 &lt;code&gt;releases&lt;/code&gt; 目录中的发行包 &lt;code&gt;Name.tar.gz&lt;/code&gt; 进行解压缩。</target>
        </trans-unit>
        <trans-unit id="1a99a056cf6ecaf575d784978bf9746e5f0db64d" translate="yes" xml:space="preserve">
          <source>Unrecognized options are ignored.</source>
          <target state="translated">未识别的选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="c3e8f759a055d6a9097dc478f2320ca3772d6837" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored but are returned unmodified by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; and can be referred to in predicate functions passed to &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无法识别的选项将被静默忽略，但不会被 &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; 修改而返回，并且可以在传递给 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 的谓词函数中进行引用。</target>
        </trans-unit>
        <trans-unit id="fcf136da00ab173645906b6446844bfeeb401e42" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored.</source>
          <target state="translated">未识别的选项被默默忽略。</target>
        </trans-unit>
        <trans-unit id="54d58ee32687d0ed22df44187d707090c9f1ee63" translate="yes" xml:space="preserve">
          <source>Unregister a Node from EPMD</source>
          <target state="translated">从EPMD解除注册节点</target>
        </trans-unit>
        <trans-unit id="db0b20da3e0471bc484aaa9c62ebfd991d58e416" translate="yes" xml:space="preserve">
          <source>Unregister a notification filter.</source>
          <target state="translated">取消注册一个通知过滤器。</target>
        </trans-unit>
        <trans-unit id="4e280e10a8485894674391e4d6645db6545aff52" translate="yes" xml:space="preserve">
          <source>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in &lt;code&gt;Agent&lt;/code&gt;.</source>
          <target state="translated">取消注册子代理。如果第二个参数是pid，则该子代理将从 &lt;code&gt;Agent&lt;/code&gt; 中的所有树中注销。</target>
        </trans-unit>
        <trans-unit id="f03ca80c8e4fbe50cea94aadfa5356b1cefa6ea2" translate="yes" xml:space="preserve">
          <source>Unregister the agent.</source>
          <target state="translated">取消代理注册。</target>
        </trans-unit>
        <trans-unit id="b5f3dba02392fc14b01a49c5237fb9ba133abd12" translate="yes" xml:space="preserve">
          <source>Unregister the subagent, handling part of the mib-tree, as specified by the &lt;code&gt;oid()&lt;/code&gt; or &lt;code&gt;pid()&lt;/code&gt; (&lt;code&gt;PidOrOid&lt;/code&gt;).</source>
          <target state="translated">根据 &lt;code&gt;oid()&lt;/code&gt; 或 &lt;code&gt;pid()&lt;/code&gt; （ &lt;code&gt;PidOrOid&lt;/code&gt; ）的指定，注销子代理，处理mib树的一部分。</target>
        </trans-unit>
        <trans-unit id="6f8277a7a1c1b3585ee2c7d6442d480190db4efc" translate="yes" xml:space="preserve">
          <source>Unregister the user.</source>
          <target state="translated">取消用户注册。</target>
        </trans-unit>
        <trans-unit id="a8a27c51fcd7b00626a6adb2154cd8c213ef4ec1" translate="yes" xml:space="preserve">
          <source>Unregister this USM user.</source>
          <target state="translated">取消注册该USM用户。</target>
        </trans-unit>
        <trans-unit id="e8d7b4bee0a41ee99a7b5f42eb631d46c2797262" translate="yes" xml:space="preserve">
          <source>Unregisters a name from &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;global&lt;/code&gt; 中注销一个名称。</target>
        </trans-unit>
        <trans-unit id="778ebac023e85b1f0510378d21c9e5c1fcf345ea" translate="yes" xml:space="preserve">
          <source>Unregisters all USM users.</source>
          <target state="translated">取消注册所有USM用户。</target>
        </trans-unit>
        <trans-unit id="3c58e843a4c38141952ae3478058bdba2218974e" translate="yes" xml:space="preserve">
          <source>Unregisters all managed agents.</source>
          <target state="translated">解除对所有管理的代理商的注册。</target>
        </trans-unit>
        <trans-unit id="246367dd21663f20ce31444da8332f55bea35d97" translate="yes" xml:space="preserve">
          <source>Unregisters all users.</source>
          <target state="translated">解除所有用户的注册。</target>
        </trans-unit>
        <trans-unit id="32c40ce96fa1e83b3bd9616363397a86b832aa70" translate="yes" xml:space="preserve">
          <source>Unregisters the crypto key fun and terminates the process holding it, started by &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注销由 &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 开始的加密密钥fun，并终止持有它的进程。</target>
        </trans-unit>
        <trans-unit id="7c5ba8d70542c76fd25b8d56f14442cbc2255390" translate="yes" xml:space="preserve">
          <source>Unregisters the specified USM users.</source>
          <target state="translated">取消注册指定的USM用户。</target>
        </trans-unit>
        <trans-unit id="01d1e628f578a9203fd5dd6ce46d237fc06cee37" translate="yes" xml:space="preserve">
          <source>Unregisters the specified managed agents.</source>
          <target state="translated">解除注册指定的管理代理。</target>
        </trans-unit>
        <trans-unit id="b35f5d367e4318dedf6e9eecba89fb487eb5ab44" translate="yes" xml:space="preserve">
          <source>Unregisters the specified users.</source>
          <target state="translated">解除对指定用户的注册。</target>
        </trans-unit>
        <trans-unit id="39827e01c383c5bfbd3766c32b34efde1bf35451" translate="yes" xml:space="preserve">
          <source>Unresolved Calls. Empty in &lt;code&gt;modules&lt;/code&gt; mode.</source>
          <target state="translated">未解决的呼叫。在 &lt;code&gt;modules&lt;/code&gt; 模式下为空。</target>
        </trans-unit>
        <trans-unit id="19f30d44760477c48d3263ea185339929d64ed8c" translate="yes" xml:space="preserve">
          <source>Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.</source>
          <target state="translated">未解决的调用使模块数据不完整,这意味着分析结果可能无效。</target>
        </trans-unit>
        <trans-unit id="fb40d6160cba8c7f57aa914e409db0d952645ffe" translate="yes" xml:space="preserve">
          <source>Unset the log level for all the modules of the specified application.</source>
          <target state="translated">解除指定应用程序的所有模块的日志级别。</target>
        </trans-unit>
        <trans-unit id="6d813c57ac643b33b15704ddfaac2f69f436d7ab" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer.</source>
          <target state="translated">无符号8位整数。</target>
        </trans-unit>
        <trans-unit id="c196c4cb59b173e8333c1a8a5df703d2addbca5b" translate="yes" xml:space="preserve">
          <source>Unspecified connection shutdown.</source>
          <target state="translated">未指定的连接关闭。</target>
        </trans-unit>
        <trans-unit id="23ba21b928bd868bd499fdc4e16f1fbae6b293bf" translate="yes" xml:space="preserve">
          <source>Unsticks a directory that is marked as sticky.</source>
          <target state="translated">解除标记为粘性的目录。</target>
        </trans-unit>
        <trans-unit id="2277446510c2f9009fdeac95bbe80a1168ba956b" translate="yes" xml:space="preserve">
          <source>Unsubscribe to event messages from a service.</source>
          <target state="translated">退订服务的事件消息。</target>
        </trans-unit>
        <trans-unit id="bcf5dcc3da0cf64b87e972ea01a22a51c15d8495" translate="yes" xml:space="preserve">
          <source>Unused Functions (*). All local and exported functions of analyzed modules that have not been used.</source>
          <target state="translated">未使用的函数(*)。分析模块的所有未使用的本地和导出函数。</target>
        </trans-unit>
        <trans-unit id="ef54ae19c4ebc6695e02cbec5080af83b195b393" translate="yes" xml:space="preserve">
          <source>Unused Variables</source>
          <target state="translated">未使用的变量</target>
        </trans-unit>
        <trans-unit id="48532263f2300b60babe28fff5fbbc91ed7d708c" translate="yes" xml:space="preserve">
          <source>Unused functions and imports</source>
          <target state="translated">未使用的功能和进口</target>
        </trans-unit>
        <trans-unit id="e9b3d935e2fe5c05c6efefdff41786dcbb306041" translate="yes" xml:space="preserve">
          <source>Unused variables</source>
          <target state="translated">未使用的变量</target>
        </trans-unit>
        <trans-unit id="b7745c954ca016fa895b408f407a03e565617f6b" translate="yes" xml:space="preserve">
          <source>Up to five log files at maximum 100 KB each with the content of the standard streams from and to the command. (Both the number of logs and sizes can be changed by environment variables, see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; below.)</source>
          <target state="translated">最多五个日志文件，每个文件最大100 KB，带有往返于命令的标准流的内容。（日志的数量和大小都可以通过环境变量来更改，请参阅下面的 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。）</target>
        </trans-unit>
        <trans-unit id="9dd274c7d6098a1a4d8932d92e9e158a8e9dd4b8" translate="yes" xml:space="preserve">
          <source>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the &lt;strong&gt;simplest&lt;/strong&gt;&lt;code&gt;Mnesia&lt;/code&gt; functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing &lt;code&gt;Mnesia&lt;/code&gt; activity) exists, they all fail.</source>
          <target state="translated">到目前为止，已经显示了可以在事务内部使用的许多功能的示例。以下列表显示了与事务配合使用的&lt;strong&gt;最简单的&lt;/strong&gt; &lt;code&gt;Mnesia&lt;/code&gt; 函数。请注意，这些功能必须嵌入事务中。如果不存在任何封闭的事务（或其他封闭的 &lt;code&gt;Mnesia&lt;/code&gt; 活动），则它们都将失败。</target>
        </trans-unit>
        <trans-unit id="01b4c751d26980e5035738b359c986debcfcf4b4" translate="yes" xml:space="preserve">
          <source>Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (&lt;code&gt;fun&lt;/code&gt;s in process context), and references to literals in the code.</source>
          <target state="translated">直到ERTS版本8. *，检查过程代码操作都会检查对旧代码的所有引用类型。也就是说，直接引用（例如，过程堆栈上的返回地址），间接引用（过程上下文中的 &lt;code&gt;fun&lt;/code&gt; ）以及对代码中文字的引用。</target>
        </trans-unit>
        <trans-unit id="8debd6fa2cf5bff1fb2fae483fef9fdfafa670e1" translate="yes" xml:space="preserve">
          <source>Up until OTP 17 there used to exist an experimental &lt;code&gt;pg&lt;/code&gt; module in &lt;code&gt;stdlib&lt;/code&gt;. This &lt;code&gt;pg&lt;/code&gt; module is not the same module as that experimental &lt;code&gt;pg&lt;/code&gt; module, and only share the same module name.</source>
          <target state="translated">直到OTP 17为止，在 &lt;code&gt;stdlib&lt;/code&gt; 中一直存在一个实验性 &lt;code&gt;pg&lt;/code&gt; 模块。该 &lt;code&gt;pg&lt;/code&gt; 模块与实验 &lt;code&gt;pg&lt;/code&gt; 模块不同，仅共享相同的模块名称。</target>
        </trans-unit>
        <trans-unit id="4c2624bab6b3cfd68919c56a6d5e5cfd349d334b" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. An exception &lt;code&gt;{badkey,Key}&lt;/code&gt; is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the map.</source>
          <target state="translated">通过对旧值调用 &lt;code&gt;Fun&lt;/code&gt; 以获得新值，来更新与 &lt;code&gt;Key&lt;/code&gt; 关联的 &lt;code&gt;Map1&lt;/code&gt; 中的值。如果映射中不存在 &lt;code&gt;Key&lt;/code&gt; &lt;code&gt;{badkey,Key}&lt;/code&gt; 则会生成异常{badkey，Key}。</target>
        </trans-unit>
        <trans-unit id="1c9b1268f0c338627a3b15658c74da637dde057f" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in &lt;code&gt;Map1&lt;/code&gt; then &lt;code&gt;Init&lt;/code&gt; will be associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">通过对旧值调用 &lt;code&gt;Fun&lt;/code&gt; 以获得新值，来更新与 &lt;code&gt;Key&lt;/code&gt; 关联的 &lt;code&gt;Map1&lt;/code&gt; 中的值。如果 &lt;code&gt;Map1&lt;/code&gt; 中不存在 &lt;code&gt;Key&lt;/code&gt; ，则 &lt;code&gt;Init&lt;/code&gt; 将与 &lt;code&gt;Key&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="5e2fca097e563aa25bfd5fb033663686a751ded2" translate="yes" xml:space="preserve">
          <source>Update agent config. The function &lt;code&gt;update_agent_info/3&lt;/code&gt; should be used when several values needs to be updated atomically.</source>
          <target state="translated">更新代理配置。当需要自动更新多个值时，应使用功能 &lt;code&gt;update_agent_info/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7afc903ad53b7f5b82a666a44760f2b71394b08f" translate="yes" xml:space="preserve">
          <source>Update all access structures in the staging area to include the newly prepared module.</source>
          <target state="translated">更新中转区的所有通道结构,纳入新编制的模块。</target>
        </trans-unit>
        <trans-unit id="e65320d77653af5410845622a9ee939279e72f69" translate="yes" xml:space="preserve">
          <source>Update an MD5 &lt;code&gt;Context&lt;/code&gt; with &lt;code&gt;Data&lt;/code&gt; and returns a &lt;code&gt;NewContext&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Data&lt;/code&gt; 更新MD5 &lt;code&gt;Context&lt;/code&gt; 并返回 &lt;code&gt;NewContext&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d392faf5b221ec067551948fb64c66dc210a1b9" translate="yes" xml:space="preserve">
          <source>Update configuration data for the Logger proxy. This function behaves as if it was implemented as follows:</source>
          <target state="translated">更新记录仪代理的配置数据。该函数的行为就像它的实现一样,如下所示。</target>
        </trans-unit>
        <trans-unit id="15c23ed960405748d119e2cf48c12e3dfbd628b3" translate="yes" xml:space="preserve">
          <source>Update configuration data for the specified handler. This function behaves as if it was implemented as follows:</source>
          <target state="translated">更新指定处理程序的配置数据。该函数的运行方式如下。</target>
        </trans-unit>
        <trans-unit id="fe58a4200c84c77e18dad55e69d7d322faa4c745" translate="yes" xml:space="preserve">
          <source>Update information about a user</source>
          <target state="translated">更新用户信息</target>
        </trans-unit>
        <trans-unit id="312c6091d8eac0e5b07d6cd16487ac2bd404f20a" translate="yes" xml:space="preserve">
          <source>Update information about an active connection</source>
          <target state="translated">更新活动连接的信息</target>
        </trans-unit>
        <trans-unit id="1fe0611d972ddd201356bf6556896ed52b2f48ec" translate="yes" xml:space="preserve">
          <source>Update primary configuration data for Logger. This function behaves as if it was implemented as follows:</source>
          <target state="translated">更新记录仪的主要配置数据。该函数的行为就像它的实现一样,如下所示。</target>
        </trans-unit>
        <trans-unit id="764a554dd6a058f4ee8b2a49aff080d148edb108" translate="yes" xml:space="preserve">
          <source>Update the application version number in the &lt;code&gt;.app&lt;/code&gt; file and write an &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">更新 &lt;code&gt;.app&lt;/code&gt; 文件中的应用程序版本号并编写一个 &lt;code&gt;.appup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="df2e0eab67dde01477b9adecadae6f860b5f68c2" translate="yes" xml:space="preserve">
          <source>Update the connection info protocol_version.</source>
          <target state="translated">更新连接信息协议_版本。</target>
        </trans-unit>
        <trans-unit id="1ae0552d56ac843dfab3a0e0e90394739c437be4" translate="yes" xml:space="preserve">
          <source>Update the formatter configuration for the specified handler.</source>
          <target state="translated">更新指定处理程序的格式化配置。</target>
        </trans-unit>
        <trans-unit id="e12a74739554e4908ca08a51e98ff68b92ec211d" translate="yes" xml:space="preserve">
          <source>Update the receive handle of the control process (e.g. after having changed protocol version).</source>
          <target state="translated">更新控制进程的接收句柄(例如,在更改协议版本后)。</target>
        </trans-unit>
        <trans-unit id="4ff8cf55883e7040256c251d18a9776b47973fa6" translate="yes" xml:space="preserve">
          <source>Update the receive handle with the encoding-config (the &lt;code&gt;encoding_config&lt;/code&gt; field).</source>
          <target state="translated">使用encoding-config（ &lt;code&gt;encoding_config&lt;/code&gt; 字段）更新接收句柄。</target>
        </trans-unit>
        <trans-unit id="3fc874196868b2850c4d27972aa555825f4c8abc" translate="yes" xml:space="preserve">
          <source>Update the staging part of all affected breakpoints. Disable breakpoints that are to be removed.</source>
          <target state="translated">更新所有受影响断点的暂存部分。禁用要删除的断点。</target>
        </trans-unit>
        <trans-unit id="b4e75d0ad461333a3e5a1fa13055100c26a0e7bc" translate="yes" xml:space="preserve">
          <source>Update usm user config.</source>
          <target state="translated">更新usm用户配置。</target>
        </trans-unit>
        <trans-unit id="5ff39bab1bf1708cca0909e3396800e9779cd838" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree.</source>
          <target state="translated">更新 &lt;code&gt;Key&lt;/code&gt; 价值 &lt;code&gt;Value&lt;/code&gt; 在 &lt;code&gt;Tree1&lt;/code&gt; 并返回新树。假定该键存在于树中。</target>
        </trans-unit>
        <trans-unit id="ce52fdc3093dff8fef11813ce4ce3d448b0c6f2e" translate="yes" xml:space="preserve">
          <source>Updates a running Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</source>
          <target state="translated">更新 &lt;code&gt;Data&lt;/code&gt; 的正在运行的Adler-32校验和。如果 &lt;code&gt;Data&lt;/code&gt; 是空的二进制文件或空的iolist，则此函数返回校验和所需的初始值。</target>
        </trans-unit>
        <trans-unit id="39a616ffbea893cd0d7caf81f5c475e558b40da3" translate="yes" xml:space="preserve">
          <source>Updates a running CRC checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</source>
          <target state="translated">更新 &lt;code&gt;Data&lt;/code&gt; 的运行CRC校验和。如果 &lt;code&gt;Data&lt;/code&gt; 是空二进制或空iolist，则此函数返回CRC所需的初始值。</target>
        </trans-unit>
        <trans-unit id="78c9911ea54430b2ec4c2464fea0fba3c01b13cb" translate="yes" xml:space="preserve">
          <source>Updates a time-out with a new &lt;code&gt;EventContent&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; for how to start a time-out.</source>
          <target state="translated">使用新的 &lt;code&gt;EventContent&lt;/code&gt; 更新超时。有关如何启动超时，请参见 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8d39f7d480179f5db485862d26b6c6e7aed7b81" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. An exception is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary.</source>
          <target state="translated">通过调用值上的 &lt;code&gt;Fun&lt;/code&gt; 以获取新值来更新字典中的值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ,则会生成一个异常。</target>
        </trans-unit>
        <trans-unit id="ab59d74f46080461c39369f0019171f2f23af955" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as follows:</source>
          <target state="translated">通过调用值上的 &lt;code&gt;Fun&lt;/code&gt; 以获取新值来更新字典中的值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则将 &lt;code&gt;Initial&lt;/code&gt; 作为第一个值存储。例如， &lt;code&gt;append/3&lt;/code&gt; 可以定义如下：</target>
        </trans-unit>
        <trans-unit id="9f6a761f1dc7fcd9496ff0fc00ba409b036ce20c" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as:</source>
          <target state="translated">通过调用值上的 &lt;code&gt;Fun&lt;/code&gt; 以获取新值来更新字典中的值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则将 &lt;code&gt;Initial&lt;/code&gt; 作为第一个值存储。例如， &lt;code&gt;append/3&lt;/code&gt; 可以定义为：</target>
        </trans-unit>
        <trans-unit id="37c90a4670b3f9486158db598e8de0114e5577be" translate="yes" xml:space="preserve">
          <source>Updates an accumulator by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt;. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The final value of the accumulator is returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">更新应用累加器 &lt;code&gt;Fun&lt;/code&gt; 上的注释的每个集合 &lt;code&gt;erl_parse&lt;/code&gt; 树 &lt;code&gt;Abstr&lt;/code&gt; 。第一个通话 &lt;code&gt;Fun&lt;/code&gt; 有 &lt;code&gt;AccIn&lt;/code&gt; 作为参数，蓄能器返回的 &lt;code&gt;AccOut&lt;/code&gt; 被传递到下一个电话，等等。返回累加器的最终值。该 &lt;code&gt;erl_parse&lt;/code&gt; 树的深度优先，左到右的方式运行。</target>
        </trans-unit>
        <trans-unit id="e6ebcf826afc7224f3463dd215eb5352561a6434" translate="yes" xml:space="preserve">
          <source>Updates information about debugged processes. Information about all terminated processes are removed from the window. All Attach Process windows for terminated processes are closed.</source>
          <target state="translated">更新已调试进程的信息。从窗口中删除所有终止进程的信息。关闭所有终止进程的附加进程窗口。</target>
        </trans-unit>
        <trans-unit id="a4db32f627e995a84c52631b1bbbde821d611764" translate="yes" xml:space="preserve">
          <source>Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using an HMAC init function (such as &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt; or to one of the functions &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">使用给定的 &lt;code&gt;Data&lt;/code&gt; 更新由 &lt;code&gt;Context&lt;/code&gt; 表示的HMAC 。必须使用HMAC初始化函数（例如 &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt; ）生成 &lt;code&gt;Context&lt;/code&gt; 。 &lt;code&gt;Data&lt;/code&gt; 可以是任何长度。必须将 &lt;code&gt;NewContext&lt;/code&gt; 传递给下一次对 &lt;code&gt;hmac_update&lt;/code&gt; 或函数 &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt; 的调用</target>
        </trans-unit>
        <trans-unit id="1728dfd48279b9b9b36c71be367adee8270c7c05" translate="yes" xml:space="preserve">
          <source>Updates the MAC represented by &lt;code&gt;State0&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt; which could be of any length.</source>
          <target state="translated">使用可以为任意长度的给定 &lt;code&gt;Data&lt;/code&gt; 更新 &lt;code&gt;State0&lt;/code&gt; 表示的MAC 。</target>
        </trans-unit>
        <trans-unit id="0cc7f14f3a3fed19f2f8c9a020605209d8a12c68" translate="yes" xml:space="preserve">
          <source>Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;Data&lt;/code&gt; 更新由 &lt;code&gt;Context&lt;/code&gt; 表示的摘要。必须使用 &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; 或对该函数的先前调用来生成 &lt;code&gt;Context&lt;/code&gt; 。 &lt;code&gt;Data&lt;/code&gt; 可以是任何长度。必须将 &lt;code&gt;NewContext&lt;/code&gt; 传递到对 &lt;code&gt;hash_update&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt; 的下一个调用中。</target>
        </trans-unit>
        <trans-unit id="0a37f581698786fafdf7275742d9f7c793868104" translate="yes" xml:space="preserve">
          <source>Updates the hook function field of the prettyprinter context.</source>
          <target state="translated">更新prettyprinter上下文的钩子函数字段。</target>
        </trans-unit>
        <trans-unit id="c2e71d06680882c2ec32b2dc6bea400636a79824" translate="yes" xml:space="preserve">
          <source>Updates the line widh field of the prettyprinter context.</source>
          <target state="translated">更新prettyprinter上下文的行宽字段。</target>
        </trans-unit>
        <trans-unit id="06a0436ed02af4ad242287fe8c27e31aafc0067b" translate="yes" xml:space="preserve">
          <source>Updates the object with key &lt;code&gt;Key&lt;/code&gt; stored in table &lt;code&gt;Name&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at the &lt;code&gt;Pos&lt;/code&gt;:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</source>
          <target state="translated">更新用键的对象 &lt;code&gt;Key&lt;/code&gt; 存储在表 &lt;code&gt;Name&lt;/code&gt; 类型的 &lt;code&gt;set&lt;/code&gt; 加入 &lt;code&gt;Incr&lt;/code&gt; 于在所述元件 &lt;code&gt;Pos&lt;/code&gt; ：个位置。返回新的计数器值。如果未指定位置，则更新键之后的元素。</target>
        </trans-unit>
        <trans-unit id="74b81e579810979a583fac3a15071ea6d7e0648e" translate="yes" xml:space="preserve">
          <source>Updates the operator precedence field of the prettyprinter context. See the &lt;code&gt;erl_parse(3)&lt;/code&gt; module for operator precedences.</source>
          <target state="translated">更新prettyprinter上下文的运算符优先级字段。有关操作符优先级，请参见 &lt;code&gt;erl_parse(3)&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="63d2d102522483d5460d1744c9d5282ecfc3df2b" translate="yes" xml:space="preserve">
          <source>Updates the paper widh field of the prettyprinter context.</source>
          <target state="translated">更新prettyprinter上下文的纸张宽度字段。</target>
        </trans-unit>
        <trans-unit id="1f9326e8e858c536ca9e794bc54c6e439dd4f44b" translate="yes" xml:space="preserve">
          <source>Updates the user data field of the prettyprinter context.</source>
          <target state="translated">更新prettyprinter上下文的用户数据字段。</target>
        </trans-unit>
        <trans-unit id="d4648225b60a7bf7a7074d97ae9b8282d0ba6646" translate="yes" xml:space="preserve">
          <source>Updating Maps</source>
          <target state="translated">更新地图</target>
        </trans-unit>
        <trans-unit id="eb57e471df554364292c825fe5e79967d1cd792b" translate="yes" xml:space="preserve">
          <source>Updating a map has a similar syntax as constructing it.</source>
          <target state="translated">更新地图的语法与构建地图的语法相似。</target>
        </trans-unit>
        <trans-unit id="20eed44fc68b8b204aedfb0f91c533a64f205785" translate="yes" xml:space="preserve">
          <source>Updating a persistent term with the same value as it already has is specially optimized to do nothing quickly; thus, there is no need compare the old and new values and avoid calling &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt; if the values are equal.</source>
          <target state="translated">更新具有与现有值相同的值的永久性术语经过专门优化，使其无法快速执行任何操作；因此，不需要比较旧值和新值，并且如果值相等，则避免调用 &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d141042860aca10991eb65163181406dcf7137" translate="yes" xml:space="preserve">
          <source>Updating or deleting a persistent term will trigger a global GC if the term does not fit in one machine word. Processes will be scheduled as usual, but all processes will be made runnable at once, which will make the system less responsive until all process have run and scanned their heaps for the deleted terms. One way to minimize the effects on responsiveness could be to minimize the number of processes on the node before updating or deleting a persistent term. It would also be wise to avoid updating terms when the system is at peak load.</source>
          <target state="translated">更新或删除一个持久性术语,如果该术语不适合放在一个机器字中,将触发全局GC。进程将像往常一样被调度,但所有进程都会被一次变成可运行的,这将使系统的响应性降低,直到所有进程都运行并扫描其堆中的被删除的术语。将对响应性的影响降到最低的一种方法是,在更新或删除一个持久性术语之前,尽量减少节点上的进程数量。避免在系统处于负载高峰时更新术语也是明智之举。</target>
        </trans-unit>
        <trans-unit id="52b5471f4080ddbb8029246652a7263fae21041d" translate="yes" xml:space="preserve">
          <source>Upgrade Example - TLS only</source>
          <target state="translated">升级示例-仅限TLS</target>
        </trans-unit>
        <trans-unit id="a4ccacf954181a7d1504665a82641050052eb900" translate="yes" xml:space="preserve">
          <source>Upgrade the connection associated with &lt;code&gt;Handle&lt;/code&gt; to a tls connection if possible.</source>
          <target state="translated">如果可能，将与 &lt;code&gt;Handle&lt;/code&gt; 关联的连接升级为tls连接。</target>
        </trans-unit>
        <trans-unit id="db0184af500cc1d274a7e5600d1d6a2de2501102" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to a TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">将 &lt;code&gt;gen_tcp&lt;/code&gt; 或等效的连接套接字升级到TLS套接字，即执行客户端TLS握手。</target>
        </trans-unit>
        <trans-unit id="ca4651bcfd7cc66e9b643622e9b6fa5cf9be97fb" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">将 &lt;code&gt;gen_tcp&lt;/code&gt; 或等效的连接套接字升级到TLS套接字，即执行客户端TLS握手。</target>
        </trans-unit>
        <trans-unit id="0885a1400bd730b033aa9a97c94e31cdcc2976c9" translate="yes" xml:space="preserve">
          <source>Upgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">根据 &lt;code&gt;.appup&lt;/code&gt; 文件，将应用程序 &lt;code&gt;App&lt;/code&gt; 从当前版本升级到 &lt;code&gt;Dir&lt;/code&gt; 中的新版本。</target>
        </trans-unit>
        <trans-unit id="fe465284017475712d39dd7e9e97f804a2375abf" translate="yes" xml:space="preserve">
          <source>Upon failure to reopen the log, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">重新打开日志失败时，磁盘日志进程将以EXIT消息 &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt; 终止。 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 请求排队的其他进程收到消息{disk_log，Node，{error，disk_log_stopped}}。</target>
        </trans-unit>
        <trans-unit id="313cdf1a747cf13f7fb3ba0b75e218a96c2914cd" translate="yes" xml:space="preserve">
          <source>Uppercase letter</source>
          <target state="translated">大写字母</target>
        </trans-unit>
        <trans-unit id="655dc371ef84593d2a9260f8648168e35e59595a" translate="yes" xml:space="preserve">
          <source>Uppercase letters</source>
          <target state="translated">大写字母</target>
        </trans-unit>
        <trans-unit id="42df97f2f6a736b6736486799c452f7ab2ae5c74" translate="yes" xml:space="preserve">
          <source>Uppercase letters signify real identifiers and lowercase letters signify fake identifiers only used for description of the topology. Identifiers passed as real identifiers can be used by the runtime system when trying to access specific hardware; if they are incorrect the behavior is undefined. Faked logical CPU identifiers are not accepted, as there is no point in defining the CPU topology without real logical CPU identifiers. Thread, core, processor, and node identifiers can be omitted. If omitted, the thread ID defaults to &lt;code&gt;t0&lt;/code&gt;, the core ID defaults to &lt;code&gt;c0&lt;/code&gt;, the processor ID defaults to &lt;code&gt;p0&lt;/code&gt;, and the node ID is left undefined. Either each logical processor must belong to only one NUMA node, or no logical processors must belong to any NUMA nodes.</source>
          <target state="translated">大写字母表示真实标识符，小写字母表示仅用于描述拓扑的伪造标识符。尝试访问特定硬件时，运行时系统可以使用作为真实标识符传递的标识符。如果它们不正确，则行为是不确定的。不接受伪造的逻辑CPU标识符，因为没有实际逻辑CPU标识符就没有必要定义CPU拓扑。线程，核心，处理器和节点标识符可以省略。如果省略，则线程ID默认为 &lt;code&gt;t0&lt;/code&gt; ，内核ID默认为 &lt;code&gt;c0&lt;/code&gt; ，处理器ID默认为 &lt;code&gt;p0&lt;/code&gt; ，并且节点ID未定义。每个逻辑处理器必须仅属于一个NUMA节点，或者没有逻辑处理器必须属于任何NUMA节点。</target>
        </trans-unit>
        <trans-unit id="19370c86dcca239b2f891f36eb2a0c4f475f930f" translate="yes" xml:space="preserve">
          <source>Uri data types</source>
          <target state="translated">Uri数据类型</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">用例。</target>
        </trans-unit>
        <trans-unit id="2c9af3bf645c9bf6cb6b56eedb88807aad3f66ae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; with an absolute path after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; 与后绝对路径 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c47962432a46afd10354bf7faf78b77ebd176482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; together with &lt;code&gt;enif_select&lt;/code&gt; to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 连同 &lt;code&gt;enif_select&lt;/code&gt; 检测失败的Erlang进程，并阻止它们引起的资源和它们所包含OS事件对象的持续泄漏。</target>
        </trans-unit>
        <trans-unit id="44e7e015a8657a665a01a0520fdb99490efbc8b2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 来保证以后对 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 的调用的 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7da24533e796ccef89e6be1ffa753ac897a16df3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 来保证对 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; 的后续调用的 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc01bc65b8bccb967f709eb00a1f11cb2c754fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 可以确保后续 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 的调用的安全遍历。</target>
        </trans-unit>
        <trans-unit id="ac19f9c55f3cb262bc1bcb3f39438151f391e8ca" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt; gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt; gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; 发出信号，表明不再发送任何数据，并等待套接字的读取端关闭。</target>
        </trans-unit>
        <trans-unit id="f81221a29d13782207a78cbfa816c0cbf3c464d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; 发出信号，表示不再发送任何数据，并等待套接字的读取端关闭。</target>
        </trans-unit>
        <trans-unit id="7ead82a2bde7adf5d2bb9488a1ed038033681dd8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erl_ext_dist#fragments&quot;&gt;fragmented&lt;/a&gt;&lt;/code&gt; distribution messages to send large messages.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#fragments&quot;&gt;fragmented&lt;/a&gt;&lt;/code&gt; 分发消息来发送大型消息。</target>
        </trans-unit>
        <trans-unit id="88a6e8689fc8004e74f39f7b9aff0d955c4830e5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt; erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt; erlang:system_time/1&lt;/a&gt;&lt;/code&gt; 以您选择的 &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 检索当前的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="71bd29e8e106825432b11d0f4aa2b931f6f8bf79" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; 以您选择的 &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 检索当前的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="0c6d38128136d372de87b2cca11fa0fc14d3b6dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="611de99bd7fd476bf937c72c0e0fd5671d5f5338" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; to see the content of the history buffer and &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; to re-execute one of the entries.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; 查看历史记录缓冲区的内容，并使用 &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; 重新执行其中一项。</target>
        </trans-unit>
        <trans-unit id="a08416b12ce433a16c45d0b1b7b6dcc6f100d529" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received (or cancelled) and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made. &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; will first cancel any selected events before it calls or schedules the &lt;code&gt;stop&lt;/code&gt; callback. Arguments &lt;code&gt;pid&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; are ignored when &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; is specified.</source>
          <target state="translated">使用 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 作为 &lt;code&gt;mode&lt;/code&gt; ，以安全地关闭已传递给 &lt;code&gt;enif_select&lt;/code&gt; 的事件对象。当可以安全关闭事件对象时，将调用资源 &lt;code&gt;obj&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 回调。即使已收到（或取消了）所有通知并且没有对 &lt;code&gt;enif_select&lt;/code&gt; 进行进一步调用，也必须使用这种安全的关闭事件对象的方法。 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 将在调用或计划 &lt;code&gt;stop&lt;/code&gt; 回调之前首先取消所有选定的事件。指定 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 时，将忽略参数 &lt;code&gt;pid&lt;/code&gt; 和 &lt;code&gt;ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03a0a6dcdb4bb774d1d742179139e2e450523f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made.</source>
          <target state="translated">使用 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 作为 &lt;code&gt;mode&lt;/code&gt; ，以安全地关闭已传递给 &lt;code&gt;enif_select&lt;/code&gt; 的事件对象。当可以安全关闭事件对象时，将调用资源 &lt;code&gt;obj&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 回调。即使已收到所有通知并且没有对 &lt;code&gt;enif_select&lt;/code&gt; 进行进一步调用，也必须使用这种安全的关闭事件对象的方法。</target>
        </trans-unit>
        <trans-unit id="4dbf19e8e181869d7824e230cc259b4296e049dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;M-x compile&lt;/code&gt; to compile an MIB from inside Emacs, and enter:</source>
          <target state="translated">使用 &lt;code&gt;M-x compile&lt;/code&gt; 从Emacs内部编译MIB，然后输入：</target>
        </trans-unit>
        <trans-unit id="43487582b9c31bb61fd048104c15adf5df0fcbcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:is_compiled/1&lt;/code&gt; or &lt;code&gt;code:which/1&lt;/code&gt; to see if a module is Cover compiled (and still loaded) or not.</source>
          <target state="translated">使用 &lt;code&gt;cover:is_compiled/1&lt;/code&gt; 或 &lt;code&gt;code:which/1&lt;/code&gt; 来查看模块是否经过Cover编译（并仍然加载）。</target>
        </trans-unit>
        <trans-unit id="7f85d8a08505e2b0a869a54c5dd45740db5b3406" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:start/1&lt;/code&gt; and &lt;code&gt;cover:stop/1&lt;/code&gt; to add or remove nodes. The same Cover compiled code will be loaded on each node, and analysis will collect and sum up coverage data results from all nodes.</source>
          <target state="translated">使用 &lt;code&gt;cover:start/1&lt;/code&gt; 和 &lt;code&gt;cover:stop/1&lt;/code&gt; 可以添加或删除节点。相同的Cover编译代码将加载到每个节点上，分析将收集并汇总所有节点的coverage数据结果。</target>
        </trans-unit>
        <trans-unit id="5b51e4203eb742f5eb4fc26e38e7eb765f543077" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;driver_alloc_binary()&lt;/code&gt; to allocate a binary.</source>
          <target state="translated">使用 &lt;code&gt;driver_alloc_binary()&lt;/code&gt; 分配二进制文件。</target>
        </trans-unit>
        <trans-unit id="c95131c00c47173f141a21936f6eef73f82cca9f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:get_cookie()&lt;/code&gt; in ERTS instead.</source>
          <target state="translated">在ERTS中使用 &lt;code&gt;erlang:get_cookie()&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="7c041275bff1db161bb6bcf06b8c664a175f0746" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:now/0&lt;/code&gt; to retrieve the current Erlang system time.</source>
          <target state="translated">使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 检索当前的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="70734f79b3e2d0baca01b45e43fb19b230f1b8af" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(), Cookie) in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;erlang:set_cookie(node(), Cookie) in ERTS&lt;/code&gt; 使用erlang：set_cookie（node（），Cookie）。</target>
        </trans-unit>
        <trans-unit id="de069253a09bf6a9eebbd010c198840f5e87a703" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; 使用erlang：set_cookie（node（），Cookie）。</target>
        </trans-unit>
        <trans-unit id="4290f2a7a214d1f9ba5e3a266d300f53024ef971" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;hipe:help_options/0&lt;/code&gt; to print out the available options.</source>
          <target state="translated">使用 &lt;code&gt;hipe:help_options/0&lt;/code&gt; 打印出可用选项。</target>
        </trans-unit>
        <trans-unit id="ae0a3e8fb6ea6a46c1431393956ad0cdb131d016" translate="yes" xml:space="preserve">
          <source>Use Compiler option &lt;code&gt;{debug_info_key,Key}&lt;/code&gt;, see &lt;code&gt;compile(3)&lt;/code&gt; and function &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; to register a fun that returns the key whenever &lt;code&gt;beam_lib&lt;/code&gt; must decrypt the debug information.</source>
          <target state="translated">使用编译器选项 &lt;code&gt;{debug_info_key,Key}&lt;/code&gt; ，请参见 &lt;code&gt;compile(3)&lt;/code&gt; 和函数 &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 来注册一个有趣的函数，该函数可以在 &lt;code&gt;beam_lib&lt;/code&gt; 必须解密调试信息时返回密钥。</target>
        </trans-unit>
        <trans-unit id="cf76996b770b568aba2d669a4a4c375802561542" translate="yes" xml:space="preserve">
          <source>Use Dialyzer from the command line to detect defects in the specified files or directories containing &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.beam&lt;/code&gt; files, depending on the type of the analysis.</source>
          <target state="translated">从命令行使用Dialyzer来检测指定文件或包含 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.beam&lt;/code&gt; 文件的目录中的缺陷，具体取决于分析的类型。</target>
        </trans-unit>
        <trans-unit id="52ecd59359aa11823ae3489c4b92ca323d2f8686" translate="yes" xml:space="preserve">
          <source>Use Mnesia with the following types of applications:</source>
          <target state="translated">将Mnesia用于以下类型的应用:</target>
        </trans-unit>
        <trans-unit id="cd0851048c67fb91d296c17c79d984235168aa8a" translate="yes" xml:space="preserve">
          <source>Use STDLIB application variable &lt;code&gt;restricted_shell&lt;/code&gt; and specify, as its value, the name of the callback module. Example (with callback functions implemented in &lt;code&gt;callback_mod.erl&lt;/code&gt;): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt;.</source>
          <target state="translated">使用STDLIB应用程序变量 &lt;code&gt;restricted_shell&lt;/code&gt; 并指定，作为其值，则回调模块的名称。例如（在实现的回调函数 &lt;code&gt;callback_mod.erl&lt;/code&gt; ）： &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9de9466c5fd84c1497ee031330a8bf3182295b3" translate="yes" xml:space="preserve">
          <source>Use a parameterized query to insert many rows in one go.</source>
          <target state="translated">使用参数化查询,一次性插入多条记录。</target>
        </trans-unit>
        <trans-unit id="4246bdbd0514a46c24c66d6a824bf38823f49b83" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm with a constant seed:</source>
          <target state="translated">使用指定的算法与恒定的种子。</target>
        </trans-unit>
        <trans-unit id="98d7bed7136a80ee2a1f391e37af7b4e25791949" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm:</source>
          <target state="translated">使用指定的算法。</target>
        </trans-unit>
        <trans-unit id="0ef43eef2287dfb39d5045b73777b94383dd1809" translate="yes" xml:space="preserve">
          <source>Use active mode only if your high-level protocol provides its own flow control (for example, acknowledging received messages) or the amount of data exchanged is small. &lt;code&gt;{active, false}&lt;/code&gt; mode, use of the &lt;code&gt;{active, once}&lt;/code&gt; mode, or &lt;code&gt;{active, N}&lt;/code&gt; mode with values of &lt;code&gt;N&lt;/code&gt; appropriate for the application provides flow control. The other side cannot send faster than the receiver can read.</source>
          <target state="translated">仅当高级协议提供自己的流控制（例如，确认收到的消息）或交换的数据量很少时，才使用活动模式。 &lt;code&gt;{active, false}&lt;/code&gt; 模式，使用 &lt;code&gt;{active, once}&lt;/code&gt; 模式或 &lt;code&gt;{active, N}&lt;/code&gt; 模式（具有适用于应用程序的 &lt;code&gt;N&lt;/code&gt; 值）提供流量控制。另一端的发送速度不能超过接收器的读取速度。</target>
        </trans-unit>
        <trans-unit id="0cb9f5afdf0431967f44f8bc5907c7bc9106a55e" translate="yes" xml:space="preserve">
          <source>Use batch file &lt;code&gt;etop.bat&lt;/code&gt;, for example, &lt;code&gt;etop -node tiger@durin&lt;/code&gt;.</source>
          <target state="translated">使用批处理文件 &lt;code&gt;etop.bat&lt;/code&gt; ，例如 &lt;code&gt;etop -node tiger@durin&lt;/code&gt; node tiger @ durin。</target>
        </trans-unit>
        <trans-unit id="804cbb37615425c1f58bef26b23df4ccbb998e2d" translate="yes" xml:space="preserve">
          <source>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like &lt;code&gt;==&lt;/code&gt;, as that may cause your application to stop working.</source>
          <target state="translated">使用按位与测试返回值中的特定位。将来的发行版中可能会添加新的有效位，以提供有关失败和成功调用的更多详细信息。不要使用 &lt;code&gt;==&lt;/code&gt; 之类的相等测试，因为这可能会导致您的应用程序停止运行。</target>
        </trans-unit>
        <trans-unit id="28d05d6e3c0c6496475b27e170aa3c9890b934a6" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</source>
          <target state="translated">使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; 获得一个基本模式，该模式与表中的所有记录匹配，或者在记录创建中使用默认值。不要对模式进行硬编码，因为这会使代码更容易受到记录定义的将来更改的影响。</target>
        </trans-unit>
        <trans-unit id="36fef5f536ab55188b5441adeba6150367c3ff02" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; to list all loaded reports:</source>
          <target state="translated">使用函数 &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; 列出所有已加载的报告：</target>
        </trans-unit>
        <trans-unit id="b28b25ff39058f6138bbe1ff3ebce8f3b6ccb94a" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; to show details of a specific report:</source>
          <target state="translated">使用功能 &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; 显示特定报告的详细信息：</target>
        </trans-unit>
        <trans-unit id="a0eac0e99e0695efffadbf6a76c731707faeeeea" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; to stop the &lt;code&gt;rb_server&lt;/code&gt;:</source>
          <target state="translated">使用函数 &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; 停止 &lt;code&gt;rb_server&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="012887c588a915c59771e087bcd639512c6a8489" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; to get all flags for features that require strict order delivery.</source>
          <target state="translated">使用函数 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 可以获取需要严格下单的功能的所有标志。</target>
        </trans-unit>
        <trans-unit id="7f83ae95c5e5857514f24ca4885f3294c1f168dd" translate="yes" xml:space="preserve">
          <source>Use its graphical interface to investigate the state of the current test case.</source>
          <target state="translated">使用其图形界面来调查当前测试用例的状态。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
