<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f975f613537adf39477a68ad11e1dc4894dd6870" translate="yes" xml:space="preserve">
          <source>Action Mappings</source>
          <target state="translated">动作映射</target>
        </trans-unit>
        <trans-unit id="2440fec108b517d1d709ba90c75d4f7a63c7e81f" translate="yes" xml:space="preserve">
          <source>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...}</source>
          <target state="translated">ActionCall ::={ActionFunction}。| {ActionFunction,ActionTerm,...}。</target>
        </trans-unit>
        <trans-unit id="5590c86022b5bc14c1ea74cf910bca92aa274578" translate="yes" xml:space="preserve">
          <source>ActionFunction ::= &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</source>
          <target state="translated">ActionFunction :: = &lt;code&gt;set_seq_token&lt;/code&gt; | &lt;code&gt;get_seq_token&lt;/code&gt; | &lt;code&gt;message&lt;/code&gt; | &lt;code&gt;return_trace&lt;/code&gt; | &lt;code&gt;exception_trace&lt;/code&gt; | &lt;code&gt;process_dump&lt;/code&gt; | &lt;code&gt;enable_trace&lt;/code&gt; | &lt;code&gt;disable_trace&lt;/code&gt; | &lt;code&gt;trace&lt;/code&gt; | &lt;code&gt;display&lt;/code&gt; | &lt;code&gt;caller&lt;/code&gt; | &lt;code&gt;set_tcw&lt;/code&gt; | &lt;code&gt;silent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51c493fd8bfe5291ac344e060529e5b42558f385" translate="yes" xml:space="preserve">
          <source>ActionTerm ::= ConditionExpression | ActionCall</source>
          <target state="translated">ActionTerm ::=ConditionExpression | ActionCall</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="89ff6dbfdb936ca69e6587ae4d22e9a120904bf2" translate="yes" xml:space="preserve">
          <source>Actions :: [&lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">动作:: [ &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ] | &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; ）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="61334da16104ac9d91a8736e913a8cbee03e40e6" translate="yes" xml:space="preserve">
          <source>Actions are executed in the containing list order.</source>
          <target state="translated">行动按包含的列表顺序执行。</target>
        </trans-unit>
        <trans-unit id="6ef0f3b4c93f31bddb43b327dd452b51df2f0936" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;event_timeout()&lt;/code&gt; in the list.</source>
          <target state="translated">设置 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 动作将覆盖相同类型的所有先前选项，因此包含列表中的最后一个将获胜。例如，最后一个 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; 会覆盖列表中以前的所有 &lt;code&gt;event_timeout()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1964869d062538b54d1a15f6f4171d706fef3d8" translate="yes" xml:space="preserve">
          <source>Actions that set &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; override any previous of the same type, so the last in the containing list wins. For example, the last &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; overrides any previous &lt;code&gt;postpone()&lt;/code&gt; in the list.</source>
          <target state="translated">设置 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 动作将覆盖相同类型的所有先前选项，因此包含列表中的最后一个将获胜。例如，最后一个 &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 会覆盖列表中的所有先前的 &lt;code&gt;postpone()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13b1df2d40bde8a02c4921e1004b0065de68e10c" translate="yes" xml:space="preserve">
          <source>Activates a connection to a remote user. When this is done the connection can be used to send messages (with SendMod:send_message/2). The ControlPid is the identifier of a process that controls the connection. That process will be supervised and if it dies, this will be detected and the UserMod:handle_disconnect/2 callback function will be invoked. See the megaco_user module for more info about the callback arguments. The connection may also explicitly be deactivated by invoking megaco:disconnect/2.</source>
          <target state="translated">激活与远程用户的连接。当此操作完成后,该连接可以用来发送消息(使用SendMod:send_message/2)。ControlPid是控制连接的进程的标识符。这个进程将被监督,如果它死了,将被检测到并调用 UserMod:handle_disconnect/2 回调函数。关于回调参数的更多信息,请参见 megaco_user 模块。连接也可以通过调用megaco:disconnect/2显式地被停用。</target>
        </trans-unit>
        <trans-unit id="f69ba29b1f84217c9d2ca2dc152317da71e06308" translate="yes" xml:space="preserve">
          <source>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy, and performs a backup using &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt;. The default value of the backup callback module &lt;code&gt;BackupMod&lt;/code&gt; is obtained by &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt;.</source>
          <target state="translated">以最大程度的冗余度激活一个覆盖所有Mnesia表（包括架构）的新检查点，并使用 &lt;code&gt;backup_checkpoint/2/3&lt;/code&gt; 执行备份。备份回调模块 &lt;code&gt;BackupMod&lt;/code&gt; 的默认值由 &lt;code&gt;mnesia:system_info(backup_module)&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="0574212bd6baf73e32ac9c415b72677146bade9b" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates on all &lt;code&gt;Mnesia&lt;/code&gt; tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">在调试级别激活所有事件。在此级别上， &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序开始订阅所有 &lt;code&gt;Mnesia&lt;/code&gt; 表上的更新。该级别仅用于调试小型玩具系统，因为会生成许多大型事件。</target>
        </trans-unit>
        <trans-unit id="1473502b15ef43d2fc312f7968ec2627f8afe701" translate="yes" xml:space="preserve">
          <source>Activates all events at the debug level. On this level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is intended only for debugging small toy systems, as many large events can be generated.</source>
          <target state="translated">激活调试层的所有事件,在这个层面,Mnesia事件处理程序开始订阅所有Mnesia表的更新。在这个级别,Mnesia事件处理程序开始订阅所有Mnesia表的更新。这个级别只用于调试小型玩具系统,因为会产生许多大型事件。</target>
        </trans-unit>
        <trans-unit id="a11fef95fdd152ac782e603cddf000bf9537358d" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus full trace of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">在详细级别激活所有事件以及所有调试事件的完整跟踪。这些调试事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到Mnesia事件处理程序。在此调试级别，Mnesia事件处理程序开始订阅模式表中的更新。</target>
        </trans-unit>
        <trans-unit id="d10f11346b4f9c94838ab97da164ecb5b326c009" translate="yes" xml:space="preserve">
          <source>Activates all events at the verbose level plus traces of all debug events. These debug events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler. On this debug level, the &lt;code&gt;Mnesia&lt;/code&gt; event handler starts subscribing to updates in the schema table.</source>
          <target state="translated">在详细级别激活所有事件以及所有调试事件的跟踪。这些调试事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序。在此调试级别， &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序开始订阅模式表中的更新。</target>
        </trans-unit>
        <trans-unit id="6ded0de3f180c32378392899db72b086ca5f1741" translate="yes" xml:space="preserve">
          <source>Activates read data buffering. If &lt;code&gt;read/2&lt;/code&gt; calls are for significantly less than &lt;code&gt;Size&lt;/code&gt; bytes, read operations to the operating system are still performed for blocks of &lt;code&gt;Size&lt;/code&gt; bytes. The extra data is buffered and returned in subsequent &lt;code&gt;read/2&lt;/code&gt; calls, giving a performance gain as the number of operating system calls is reduced.</source>
          <target state="translated">激活读取数据缓冲。如果 &lt;code&gt;read/2&lt;/code&gt; 调用的字节数明显少于 &lt;code&gt;Size&lt;/code&gt; 字节，则仍对 &lt;code&gt;Size&lt;/code&gt; 字节块执行对操作系统的读取操作。多余的数据被缓冲并在随后的 &lt;code&gt;read/2&lt;/code&gt; 调用中返回，随着操作系统调用数量的减少，性能得到提高。</target>
        </trans-unit>
        <trans-unit id="eb6a9b28d658257a2883ec371985ebb9360570ed" translate="yes" xml:space="preserve">
          <source>Activates the fragmentation properties of an existing table. &lt;code&gt;FragProps&lt;/code&gt; is either to contain &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; or be empty.</source>
          <target state="translated">激活现有表的碎片属性。 &lt;code&gt;FragProps&lt;/code&gt; 要么包含 &lt;code&gt;{node_pool, Nodes}&lt;/code&gt; 要么为空。</target>
        </trans-unit>
        <trans-unit id="532f0aa046ec26e3e6682e682916731e989482e8" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with &lt;code&gt;mnesia:subscribe/1&lt;/code&gt;. The events are always sent to the Mnesia event handler.</source>
          <target state="translated">激活重要调试事件的跟踪。这些事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用 &lt;code&gt;mnesia:subscribe/1&lt;/code&gt; 订阅这些事件。事件总是发送到Mnesia事件处理程序。</target>
        </trans-unit>
        <trans-unit id="e0f95d91404d34111854383ce61fa17d9871d976" translate="yes" xml:space="preserve">
          <source>Activates tracing of important debug events. These events generate &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; system events. Processes can subscribe to these events with the function &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt;. The events are always sent to the &lt;code&gt;Mnesia&lt;/code&gt; event handler.</source>
          <target state="translated">激活重要调试事件的跟踪。这些事件生成 &lt;code&gt;{mnesia_info, Format, Args}&lt;/code&gt; 系统事件。进程可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#subscribe-1&quot;&gt;mnesia:subscribe/1&lt;/a&gt;&lt;/code&gt; 订阅这些事件。事件总是发送到 &lt;code&gt;Mnesia&lt;/code&gt; 事件处理程序。</target>
        </trans-unit>
        <trans-unit id="7f2c331b898e66e4e4d774932df99c6432852c98" translate="yes" xml:space="preserve">
          <source>Activates/deactivates tracing by changing the current trace pattern.</source>
          <target state="translated">通过改变当前的跟踪模式来激活/停用跟踪。</target>
        </trans-unit>
        <trans-unit id="29f45195e4be19fb8b96702dcdd15944ea37fdad" translate="yes" xml:space="preserve">
          <source>Active breakpoints are displayed in red and inactive breakpoints in blue.</source>
          <target state="translated">活动的断点显示为红色,不活动的断点显示为蓝色。</target>
        </trans-unit>
        <trans-unit id="a903c4b66a2fb224f4d96a51df759ac9a67bfc6d" translate="yes" xml:space="preserve">
          <source>Activity concept and various access contexts</source>
          <target state="translated">活动概念和各种访问环境</target>
        </trans-unit>
        <trans-unit id="713a8072ef62aa0b1fde6095af47e4a910316756" translate="yes" xml:space="preserve">
          <source>Actual protocol version.</source>
          <target state="translated">当前的协议版本。</target>
        </trans-unit>
        <trans-unit id="134344cda8fb9734c656b66e40554d208ac6e58b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;-ct_hooks&lt;/code&gt; as an argument to &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;. To add multiple CTHs using this method, append them to each other using the keyword &lt;code&gt;and&lt;/code&gt;, that is, &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;-ct_hooks&lt;/code&gt; 作为参数 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 。要添加使用该方法的多个CTHS，它们附加到彼此使用关键字 &lt;code&gt;and&lt;/code&gt; ，即， &lt;code&gt;ct_run -ct_hooks cth1 [{debug,true}] and cth2 ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8718d4f36d948a3675c6bdc12db7b8c27966873" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;return_trace&lt;/code&gt; message if the function is of arity 3:</source>
          <target state="translated">如果该函数属于同类3，请添加 &lt;code&gt;return_trace&lt;/code&gt; 消息：</target>
        </trans-unit>
        <trans-unit id="dcfe51c34611d10c0d112932679c857d2a6476fa" translate="yes" xml:space="preserve">
          <source>Add a filter to the specified handler.</source>
          <target state="translated">为指定的处理程序添加一个过滤器。</target>
        </trans-unit>
        <trans-unit id="988a7e297bf981c7e71c06b09b7717bd00d611be" translate="yes" xml:space="preserve">
          <source>Add a handler with the given configuration.</source>
          <target state="translated">添加一个给定配置的处理程序。</target>
        </trans-unit>
        <trans-unit id="07e4c199b9f19567f7bbd64299d17b2cc8c094ac" translate="yes" xml:space="preserve">
          <source>Add a primary filter to Logger.</source>
          <target state="translated">为记录仪添加一个主过滤器。</target>
        </trans-unit>
        <trans-unit id="1970f7a8e650aa5473c699a8c07cc9a162ef1004" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the primary nameserver to use for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">添加要用于 &lt;code&gt;inet_res(3)&lt;/code&gt; 的主名称服务器的地址（如果不是默认端口，则为端口）。</target>
        </trans-unit>
        <trans-unit id="1cfc1bd9fd579f7622617b9af78a944445ba8847" translate="yes" xml:space="preserve">
          <source>Add address (and port, if other than default) of the secondary nameserver for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;inet_res(3)&lt;/code&gt; 添加辅助名称服务器的地址（如果不是默认端口，则为端口）。</target>
        </trans-unit>
        <trans-unit id="d8a12963c05fa3aec6cf7012ff1f7fc0a2d99e08" translate="yes" xml:space="preserve">
          <source>Add an entry. The entry must not exist.</source>
          <target state="translated">增加一个条目。该条目必须不存在。</target>
        </trans-unit>
        <trans-unit id="1e310729251dbd2e2aab36a457e446b150b20e5e" translate="yes" xml:space="preserve">
          <source>Add host entry to the hosts table.</source>
          <target state="translated">在主机表中添加主机条目。</target>
        </trans-unit>
        <trans-unit id="064eb4472489455e1a24510aa444bd6d5e585d65" translate="yes" xml:space="preserve">
          <source>Add javac &lt;strong&gt;LAST&lt;/strong&gt; to your path environment in bash, in my case this means:</source>
          <target state="translated">在bash中将javac &lt;strong&gt;LAST&lt;/strong&gt;添加到您的路径环境中，在我的情况下，这意味着：</target>
        </trans-unit>
        <trans-unit id="3c0bb0d661a36f1c95bc663da03400bb07c43351" translate="yes" xml:space="preserve">
          <source>Add or update configuration data for the specified handler. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">添加或更新指定处理程序的配置数据。如果给定的 &lt;code&gt;Key&lt;/code&gt; 已经存在，则其关联的值将更改为 &lt;code&gt;Value&lt;/code&gt; 。如果不存在，它将被添加。</target>
        </trans-unit>
        <trans-unit id="2e23ac8cf9bd396ad94605da91fe04cfdf9b6acd" translate="yes" xml:space="preserve">
          <source>Add or update primary configuration data for Logger. If the given &lt;code&gt;Key&lt;/code&gt; already exists, its associated value will be changed to &lt;code&gt;Value&lt;/code&gt;. If it does not exist, it will be added.</source>
          <target state="translated">添加或更新Logger的主要配置数据。如果给定的 &lt;code&gt;Key&lt;/code&gt; 已经存在，则其关联的值将更改为 &lt;code&gt;Value&lt;/code&gt; 。如果不存在，它将被添加。</target>
        </trans-unit>
        <trans-unit id="fa1f218791abec296d536eef9aee8fee9c4907e8" translate="yes" xml:space="preserve">
          <source>Add search domains for &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;inet_res(3)&lt;/code&gt; 添加搜索域。</target>
        </trans-unit>
        <trans-unit id="fd1016b584a0c08284e356371e0b67d2c6544a4a" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将标签 &lt;code&gt;ct_hooks&lt;/code&gt; 添加到您的 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specification&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62bfcf8bed94dcc27f1ebd702bd7df63f5908679" translate="yes" xml:space="preserve">
          <source>Add tag &lt;code&gt;ct_hooks&lt;/code&gt; to your call to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将标签 &lt;code&gt;ct_hooks&lt;/code&gt; 添加到对 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 的调用中。</target>
        </trans-unit>
        <trans-unit id="bb8bd196c7c5b5791600663f12d69529068e2cf5" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;{scanner, flex}&lt;/code&gt; (or similar) directive to an Erlang system config file for the megaco app (see &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; chapter for details).</source>
          <target state="translated">将 &lt;code&gt;{scanner, flex}&lt;/code&gt; （或类似）指令添加到megaco应用程序的Erlang系统配置文件中（有关详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;megaco_run#initial_config&quot;&gt;initial configuration&lt;/a&gt;&lt;/code&gt; 章节）。</target>
        </trans-unit>
        <trans-unit id="a2012ba10173073b8d6e03fc90ee362531d7db30" translate="yes" xml:space="preserve">
          <source>Add the applications Crypto, Public Key, and SSL with their current version numbers after the STDLIB application.</source>
          <target state="translated">在STDLIB应用程序后添加应用程序Crypto、Public Key和SSL及其当前版本号。</target>
        </trans-unit>
        <trans-unit id="cf34fb9a5fda73afda9f1d571b702839ff2f58b3" translate="yes" xml:space="preserve">
          <source>Add the following directive to the module:</source>
          <target state="translated">在模块中添加以下指令:</target>
        </trans-unit>
        <trans-unit id="497564ebabd956c895ba8a4ea1a4bb25e8ed7093" translate="yes" xml:space="preserve">
          <source>Add transport capability to a service.</source>
          <target state="translated">为服务增加运输能力。</target>
        </trans-unit>
        <trans-unit id="22ba7777616ece673914dfbc3af9096a68b87e29" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using &lt;code&gt;add_module&lt;/code&gt;.</source>
          <target state="translated">添加应用程序意味着使用 &lt;code&gt;add_module&lt;/code&gt; 加载 &lt;code&gt;.app&lt;/code&gt; 文件中由 &lt;code&gt;modules&lt;/code&gt; 键定义的模块。</target>
        </trans-unit>
        <trans-unit id="19baa62e86ec3c161512eb728cf268b6e381fb8a" translate="yes" xml:space="preserve">
          <source>Adding an application means that the modules defined by the &lt;code&gt;modules&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file are loaded using a number of &lt;code&gt;add_module&lt;/code&gt; instructions, and then the application is started.</source>
          <target state="translated">添加应用程序意味着使用许多 &lt;code&gt;add_module&lt;/code&gt; 指令加载由 &lt;code&gt;.app&lt;/code&gt; 文件中的 &lt;code&gt;modules&lt;/code&gt; 键定义的模块，然后启动该应用程序。</target>
        </trans-unit>
        <trans-unit id="4a2fed64edcf79517387cddb884610573fd90ba1" translate="yes" xml:space="preserve">
          <source>Adding patches</source>
          <target state="translated">添加补丁</target>
        </trans-unit>
        <trans-unit id="9aa3df6db85161c52e69b8f34d6e3268949dc0a1" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;fop&lt;/code&gt; script (in &lt;code&gt;$FOP_HOME&lt;/code&gt;) to your &lt;code&gt;$PATH&lt;/code&gt;, either by adding &lt;code&gt;$FOP_HOME&lt;/code&gt; to &lt;code&gt;$PATH&lt;/code&gt;, or by copying the &lt;code&gt;fop&lt;/code&gt; script to a directory already in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;fop&lt;/code&gt; 脚本（在 &lt;code&gt;$FOP_HOME&lt;/code&gt; ）到您的 &lt;code&gt;$PATH&lt;/code&gt; ，通过添加 &lt;code&gt;$FOP_HOME&lt;/code&gt; 至 &lt;code&gt;$PATH&lt;/code&gt; ，或者通过复制 &lt;code&gt;fop&lt;/code&gt; 你已经脚本目录 &lt;code&gt;$PATH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38751bf8e4b616e26910db8b22c357a8c20a53f2" translate="yes" xml:space="preserve">
          <source>Adding the location of your installation of &lt;code&gt;fop&lt;/code&gt; in &lt;code&gt;$FOP_HOME&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;$FOP_HOME&lt;/code&gt; 添加安装 &lt;code&gt;fop&lt;/code&gt; 的位置。</target>
        </trans-unit>
        <trans-unit id="ab0b27d891b1318285ee4899ad6b140de6e4ed3b" translate="yes" xml:space="preserve">
          <source>Additional information and links of interest for Erlang programmers can be found on the Erlang Open Source site &lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org&lt;/a&gt;.</source>
          <target state="translated">Erlang程序员感兴趣的其他信息和链接可以在Erlang开源站点&lt;a href=&quot;http://www.erlang.org/&quot;&gt;http://www.erlang.org上找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afdeb8447e9059c599becedc9101b844f957850" translate="yes" xml:space="preserve">
          <source>Additionally, values that can be encoded are limited by way of their encoding as four octets as required by RFC 6733 with the required extension from RFC 2030. In particular, only values between &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; and &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; (both inclusive) can be encoded.</source>
          <target state="translated">此外，可编码的值通过RFC 6733要求的四个八位字节进行编码，并具有RFC 2030要求的扩展名。特别是，只有 &lt;code&gt;{{1968,1,20},{3,14,8}}&lt;/code&gt; 和 &lt;code&gt;{{2104,2,26},{9,42,23}}&lt;/code&gt; （包括两者）可以进行编码。</target>
        </trans-unit>
        <trans-unit id="74fda4b3ec4ffdc7738f6833bc3191a5b59bbcea" translate="yes" xml:space="preserve">
          <source>Addresses as inputs to functions can be either a string or a tuple. For example, the IP address 150.236.20.73 can be passed to &lt;code&gt;gethostbyaddr/1&lt;/code&gt;, either as string &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; or as tuple &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt;.</source>
          <target state="translated">作为函数输入的地址可以是字符串或元组。例如，可以将IP地址150.236.20.73 作为字符串 &lt;code&gt;&quot;150.236.20.73&quot;&lt;/code&gt; 或作为元组 &lt;code&gt;{150, 236, 20, 73}&lt;/code&gt; 150，236，20，73 }传递给 &lt;code&gt;gethostbyaddr/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="919ffc168cee16019d09aa5279148893d8d24a34" translate="yes" xml:space="preserve">
          <source>Addresses besides &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; ones that are returned from socket API functions. See in particular &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; The &lt;code&gt;unspec&lt;/code&gt; family corresponds to AF_UNSPEC and can occur if the other side has no socket address. The &lt;code&gt;undefined&lt;/code&gt; family can only occur in the unlikely event of an address family that the VM does not recognize.</source>
          <target state="translated">从套接字API函数返回的除 &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 之外的地址。特别参见 &lt;code&gt;&lt;a href=&quot;#type-local_address&quot;&gt;local_address().&lt;/a&gt;&lt;/code&gt; 该 &lt;code&gt;unspec&lt;/code&gt; 家庭对应AF_UNSPEC，如果对方没有套接字地址可能发生。在 &lt;code&gt;undefined&lt;/code&gt; 家庭只能发生在一个地址族的VM不承认万一。</target>
        </trans-unit>
        <trans-unit id="e5d78a2b44c9f8c46bb6a05a403783dea60e8b77" translate="yes" xml:space="preserve">
          <source>Addresses to the test plant or other instruments</source>
          <target state="translated">试验厂或其他仪器的地址</target>
        </trans-unit>
        <trans-unit id="e2dc16d39802f8e13757680f2285e270d512d4d0" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. If &lt;code&gt;Dir&lt;/code&gt; exists, it is removed from the old position in the code path.</source>
          <target state="translated">将 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径的开头。如果 &lt;code&gt;Dir&lt;/code&gt; 存在，则将其从代码路径中的旧位置删除。</target>
        </trans-unit>
        <trans-unit id="926f262a813d5bf3968371cfef08e827663b2a16" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the code path. The directory is added as the last directory in the new path. If &lt;code&gt;Dir&lt;/code&gt; already exists in the path, it is not added.</source>
          <target state="translated">将 &lt;code&gt;Dir&lt;/code&gt; 添加到代码路径。该目录被添加为新路径中的最后一个目录。如果路径中已经存在 &lt;code&gt;Dir&lt;/code&gt; ，则不会添加。</target>
        </trans-unit>
        <trans-unit id="ca41b9b5a14be7cc19bac8bafe3b381efcc40caa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Dir&lt;/code&gt; to the list of directories to be searched when including a file. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">包含文件时，将 &lt;code&gt;Dir&lt;/code&gt; 添加到要搜索的目录列表中。当遇到 &lt;code&gt;-include&lt;/code&gt; 或 &lt;code&gt;-include_lib&lt;/code&gt; 指令时，编译器会在以下目录中搜索头文件：</target>
        </trans-unit>
        <trans-unit id="5307e57c8c5d61db386c45a450b3023f9b59e82e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;IncludeDir&lt;/code&gt; to the search-path for &lt;code&gt;.asn1db&lt;/code&gt; and &lt;code&gt;ASN.1&lt;/code&gt; source files. The compiler tries to open an &lt;code&gt;.asn1db&lt;/code&gt; file when a module imports definitions from another &lt;code&gt;ASN.1&lt;/code&gt; module. If no &lt;code&gt;.asn1db&lt;/code&gt; file is found, the &lt;code&gt;ASN.1&lt;/code&gt; source file is parsed. Several &lt;code&gt;{i, IncludeDir}&lt;/code&gt; can be given.</source>
          <target state="translated">将 &lt;code&gt;IncludeDir&lt;/code&gt; 添加到 &lt;code&gt;.asn1db&lt;/code&gt; 和 &lt;code&gt;ASN.1&lt;/code&gt; 源文件的搜索路径。当模块从另一个 &lt;code&gt;ASN.1&lt;/code&gt; 模块导入定义时，编译器将尝试打开 &lt;code&gt;.asn1db&lt;/code&gt; 文件。如果未找到 &lt;code&gt;.asn1db&lt;/code&gt; 文件，则将分析 &lt;code&gt;ASN.1&lt;/code&gt; 源文件。可以给出几个 &lt;code&gt;{i, IncludeDir}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="595c4b05c70f5ee3afd4c0ee71bd2a9507a8d8e9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and store this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">将&amp;ldquo; &lt;code&gt;Increment&lt;/code&gt; 添加到与&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 关联的值并存储该值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则 &lt;code&gt;Increment&lt;/code&gt; 存储为第一个值。</target>
        </trans-unit>
        <trans-unit id="9cf5a5933a7780d09616786318d8b162063b8502" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;Increment&lt;/code&gt; to the value associated with &lt;code&gt;Key&lt;/code&gt; and stores this value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Increment&lt;/code&gt; is stored as the first value.</source>
          <target state="translated">将&amp;ldquo; &lt;code&gt;Increment&lt;/code&gt; 添加到与&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 关联的值并存储该值。如果字典中不存在 &lt;code&gt;Key&lt;/code&gt; ，则 &lt;code&gt;Increment&lt;/code&gt; 存储为第一个值。</target>
        </trans-unit>
        <trans-unit id="608d4ac3b1f40dea43a70f3ee04cd69ef181057c" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;Slave&lt;/code&gt; node to the list of allowed slave hosts.</source>
          <target state="translated">将一个 &lt;code&gt;Slave&lt;/code&gt; 节点添加到允许的从主机列表中。</target>
        </trans-unit>
        <trans-unit id="c8419b1c93b9fd6c91cbede4425bbc8634cca3f1" translate="yes" xml:space="preserve">
          <source>Adds a USM security data (user) to the agent config. Equivalent to one line in the &lt;code&gt;usm.conf&lt;/code&gt; file.</source>
          <target state="translated">将USM安全数据（用户）添加到代理配置。相当于 &lt;code&gt;usm.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="608718b6fe3ec7101404f6c3f283054c442dd2b4" translate="yes" xml:space="preserve">
          <source>Adds a access definition to the agent config. Equivalent to one vacmAccess-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将访问定义添加到代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmAccess行。</target>
        </trans-unit>
        <trans-unit id="56be82c63eeffefdb9fecc96c8582dde485169c1" translate="yes" xml:space="preserve">
          <source>Adds a comment to the zip archive.</source>
          <target state="translated">在压缩包中添加注释。</target>
        </trans-unit>
        <trans-unit id="43e098c039b116cd95896a1756a343c44df7c071" translate="yes" xml:space="preserve">
          <source>Adds a community to the agent config. Equivalent to one line in the &lt;code&gt;community.conf&lt;/code&gt; file.</source>
          <target state="translated">将社区添加到代理配置。等效于 &lt;code&gt;community.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="45955c71ab38b246ddf99aa7e08be1cf306c82b3" translate="yes" xml:space="preserve">
          <source>Adds a context to the agent config. Equivalent to one line in the &lt;code&gt;context.conf&lt;/code&gt; file.</source>
          <target state="translated">将上下文添加到代理配置。等效于 &lt;code&gt;context.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="6c32cf7ccbd49be4e1811292b2c307f4eba42f61" translate="yes" xml:space="preserve">
          <source>Adds a driver entry to the list of drivers known by Erlang. The &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; function of parameter &lt;code&gt;de&lt;/code&gt; is called.</source>
          <target state="translated">将驱动程序条目添加到Erlang已知的驱动程序列表中。调用参数 &lt;code&gt;de&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;driver_entry#init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="d07970fe182b9d81897e40e78d3b14e7a4e7a0d7" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将文件添加到已由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 打开以进行写入的tar文件中。</target>
        </trans-unit>
        <trans-unit id="b2fca474d01b00ce9ba861cfe769df64577ac35b" translate="yes" xml:space="preserve">
          <source>Adds a file to a tar file that has been opened for writing by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;. This function accepts the same options as &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将文件添加到已由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 打开以进行写入的tar文件中。此函数接受与 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3&lt;/a&gt;&lt;/code&gt; 相同的选项。</target>
        </trans-unit>
        <trans-unit id="5eccbecba42ae4288806c579ad8b8fbf3b51a728" translate="yes" xml:space="preserve">
          <source>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</source>
          <target state="translated">将一个片段添加到一个片段表中。其中一个旧片段中的所有记录都被重述,其中约一半记录被移到新的(最后)片段中。所有在外键中引用这个表的其他碎片表,都会自动得到一个新的碎片。此外,它们的记录也会以与主表相同的方式进行动态重洗。</target>
        </trans-unit>
        <trans-unit id="d84d2fb93ae834309e6167a0b3e43d9fab2545e1" translate="yes" xml:space="preserve">
          <source>Adds a host key to the set of trusted host keys.</source>
          <target state="translated">将一个主机密钥添加到受信任的主机密钥集合中。</target>
        </trans-unit>
        <trans-unit id="2d77c18b4124fe87017036ce4362ca94cf644272" translate="yes" xml:space="preserve">
          <source>Adds a module and its &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The module will not be member of any application. Returns the name of the module.</source>
          <target state="translated">将模块及其 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 添加到外部 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。该模块将不是任何应用程序的成员。返回模块的名称。</target>
        </trans-unit>
        <trans-unit id="32c8a7869e19433d754f5fcd1913f72de6ee2803" translate="yes" xml:space="preserve">
          <source>Adds a new &lt;code&gt;Key&lt;/code&gt; to the process dictionary, associated with the value &lt;code&gt;Val&lt;/code&gt;, and returns &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;Key&lt;/code&gt; exists, the old value is deleted and replaced by &lt;code&gt;Val&lt;/code&gt;, and the function returns the old value. Example:</source>
          <target state="translated">向流程字典添加一个与值 &lt;code&gt;Val&lt;/code&gt; 关联的新 &lt;code&gt;Key&lt;/code&gt; ，并返回 &lt;code&gt;undefined&lt;/code&gt; 。如果 &lt;code&gt;Key&lt;/code&gt; 存在，则将旧值删除并替换为 &lt;code&gt;Val&lt;/code&gt; ，并且该函数将返回旧值。例：</target>
        </trans-unit>
        <trans-unit id="72a77907fe15211efb4ac1705211f4a6082a3750" translate="yes" xml:space="preserve">
          <source>Adds a new event handler in the same way as &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;, but also supervises the connection between the event handler and the calling process.</source>
          <target state="translated">以与 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 相同的方式添加新的事件处理程序，但还监督事件处理程序和调用进程之间的连接。</target>
        </trans-unit>
        <trans-unit id="e9446fd51850eeb6666eac3dc67fdb3d82b72082" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to event manager &lt;code&gt;EventMgrRef&lt;/code&gt;. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initiate the event handler and its internal state.</source>
          <target state="translated">向事件管理器 &lt;code&gt;EventMgrRef&lt;/code&gt; 添加新的事件处理程序。事件管理器调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 来初始化事件处理程序及其内部状态。</target>
        </trans-unit>
        <trans-unit id="be923232cecb872d45d1007a0378c8bbbe25c6cc" translate="yes" xml:space="preserve">
          <source>Adds a new event handler to the error logger. The event handler must be implemented as a &lt;code&gt;gen_event&lt;/code&gt; callback module, see &lt;code&gt;gen_event(3)&lt;/code&gt;.</source>
          <target state="translated">将新的事件处理程序添加到错误记录器。事件处理程序必须实现为 &lt;code&gt;gen_event&lt;/code&gt; 回调模块，请参见 &lt;code&gt;gen_event(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346f98f933f954790f0ea34b8324039679ac74dd" translate="yes" xml:space="preserve">
          <source>Adds a node to &lt;code&gt;node_pool&lt;/code&gt;. The new node pool affects the list returned from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将一个节点添加到 &lt;code&gt;node_pool&lt;/code&gt; 。新的节点池会影响从函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 返回的列表。</target>
        </trans-unit>
        <trans-unit id="35b3eb9263608d380a272fe1f7c6c1eafd65bf84" translate="yes" xml:space="preserve">
          <source>Adds a notify definition to the agent config. Equivalent to one line in the &lt;code&gt;notify.conf&lt;/code&gt; file.</source>
          <target state="translated">将通知定义添加到代理配置。相当于 &lt;code&gt;notify.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="13890bf5b34b3baf9845e8775db87c295022c6ec" translate="yes" xml:space="preserve">
          <source>Adds a phony target for each dependency.</source>
          <target state="translated">为每个依赖关系添加一个假造的目标。</target>
        </trans-unit>
        <trans-unit id="29b1ac0ca171003684f30d397e314620318042ec" translate="yes" xml:space="preserve">
          <source>Adds a reference to resource object &lt;code&gt;obj&lt;/code&gt; obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. Each call to &lt;code&gt;enif_keep_resource&lt;/code&gt; for an object must be balanced by a call to &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; before the object is destructed.</source>
          <target state="translated">添加对从 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 获得的资源对象 &lt;code&gt;obj&lt;/code&gt; 的引用。在 &lt;code&gt;enif_keep_resource&lt;/code&gt; 对象之前，必须先通过调用 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 来平衡对对象的每次enif_keep_resource调用。</target>
        </trans-unit>
        <trans-unit id="ac2aa5a6a26bf2accad0209a44849095d34310fd" translate="yes" xml:space="preserve">
          <source>Adds a release, the applications of the release, the modules of the applications, and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The applications will be members of the release, and the modules will be members of the applications. The default is to use the base name of the directory as release name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the release.</source>
          <target state="translated">将版本，版本的应用程序，应用程序的模块以及 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。这些应用程序将是发行版的成员，而模块将成为应用程序的成员。缺省值是使用目录的基本名称作为发行版名称，但是可以用 &lt;code&gt;name&lt;/code&gt; 选项覆盖。返回发布的名称。</target>
        </trans-unit>
        <trans-unit id="5963e0eadddadc6570ac86b11276f6f4e83b3156" translate="yes" xml:space="preserve">
          <source>Adds a security to group definition to the agent config. Equivalent to one vacmSecurityToGroup-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将安全性添加到组定义中的代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmSecurityToGroup-line 。</target>
        </trans-unit>
        <trans-unit id="d4f785833568b0e86ada1e532e1405f500e20a42" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; for a more complete description.</source>
          <target state="translated">在每个分配的块中添加一个小标签，其中包含有关其内容和分配人的基本信息。请参阅 &lt;code&gt;&lt;a href=&quot;#M_atags&quot;&gt;+M&amp;lt;S&amp;gt;atags&lt;/a&gt;&lt;/code&gt; 以获取更完整的描述。</target>
        </trans-unit>
        <trans-unit id="0dfd9dbecdeed6491e670fb60727a24505e80431" translate="yes" xml:space="preserve">
          <source>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the &lt;code&gt;instrument&lt;/code&gt; module to inspect this information.</source>
          <target state="translated">在每个分配的块中添加一个小标签，其中包含有关其内容和分配人的基本信息。使用 &lt;code&gt;instrument&lt;/code&gt; 模块检查此信息。</target>
        </trans-unit>
        <trans-unit id="e4864b206394f8b2d7b76e4230a5c12a58cc9d0e" translate="yes" xml:space="preserve">
          <source>Adds a target address definition to the agent config. Equivalent to one line in the &lt;code&gt;target_addr.conf&lt;/code&gt; file.</source>
          <target state="translated">将目标地址定义添加到代理配置。等效于 &lt;code&gt;target_addr.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="82b2d6b8384860d53fc589e045f4515d51086799" translate="yes" xml:space="preserve">
          <source>Adds a target parameter definition to the agent config. Equivalent to one line in the &lt;code&gt;target_params.conf&lt;/code&gt; file.</source>
          <target state="translated">将目标参数定义添加到代理配置。等效于 &lt;code&gt;target_params.conf&lt;/code&gt; 文件中的一行。</target>
        </trans-unit>
        <trans-unit id="5794b16429f3c188c00edeb3043c4596518ea624" translate="yes" xml:space="preserve">
          <source>Adds a view tree family definition to the agent config. Equivalent to one vacmViewTreeFamily-line in the &lt;code&gt;vacm.conf&lt;/code&gt; file.</source>
          <target state="translated">将视图树系列定义添加到代理配置。相当于 &lt;code&gt;vacm.conf&lt;/code&gt; 文件中的一个vacmViewTreeFamily行。</target>
        </trans-unit>
        <trans-unit id="10d0b1e780ad0788836f31276e65ce6efb15e764" translate="yes" xml:space="preserve">
          <source>Adds an application, the modules of the application and &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of the modules to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The modules will be members of the application. The default is to use the base name of the directory with the version removed as application name, but this can be overridden by the &lt;code&gt;name&lt;/code&gt; option. Returns the name of the application.</source>
          <target state="translated">将应用程序，应用程序的模块和 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。这些模块将成为该应用程序的成员。缺省设置是使用目录的基本名称，而将版本删除为应用程序名称，但是 &lt;code&gt;name&lt;/code&gt; 选项可以覆盖该名称。返回应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="110ffd01521ffa85d725f633c684562720f4ba39" translate="yes" xml:space="preserve">
          <source>Adds binding &lt;code&gt;Name=Value&lt;/code&gt; to &lt;code&gt;BindingStruct&lt;/code&gt;. Returns an updated binding structure.</source>
          <target state="translated">将Binding &lt;code&gt;Name=Value&lt;/code&gt; 添加到 &lt;code&gt;BindingStruct&lt;/code&gt; 。返回更新的绑定结构。</target>
        </trans-unit>
        <trans-unit id="166b6b5a44b378b7ef528300e6dd1ab66edcbe83" translate="yes" xml:space="preserve">
          <source>Adds nodes to current cover test. Notice that this only works if cover support is active.</source>
          <target state="translated">将节点添加到当前的覆盖测试中。请注意,只有在盖板支持激活的情况下,此功能才会生效。</target>
        </trans-unit>
        <trans-unit id="ebbd57f6aab385f9f5cefe84013bbde0f94bd2a8" translate="yes" xml:space="preserve">
          <source>Adds optional capabilities and sends a &lt;code&gt;hello&lt;/code&gt; message to the server and waits for the return.</source>
          <target state="translated">添加可选功能，并向服务器发送 &lt;code&gt;hello&lt;/code&gt; 消息，并等待返回。</target>
        </trans-unit>
        <trans-unit id="f4e867c0e696fbab1087c9d79da2f2d90aa8bb6f" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. &lt;code&gt;Bindings&lt;/code&gt; specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</source>
          <target state="translated">在语法树中的节点上添加或更新注释。 &lt;code&gt;Bindings&lt;/code&gt; 指定顶级节点环境中的一组绑定变量。以下注释会受到影响：</target>
        </trans-unit>
        <trans-unit id="b3ac712b8a650dd6e42451afed1ca538238431c7" translate="yes" xml:space="preserve">
          <source>Adds or updates annotations on nodes in a syntax tree. Equivalent to &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; where the top-level environment &lt;code&gt;Bindings&lt;/code&gt; is taken from the annotation &lt;code&gt;{env, Bindings}&lt;/code&gt; on the root node of &lt;code&gt;Tree&lt;/code&gt;. An exception is thrown if no such annotation should exist.</source>
          <target state="translated">在语法树中的节点上添加或更新注释。等效于 &lt;code&gt;annotate_bindings(Tree, Bindings)&lt;/code&gt; ，其中顶级环境 &lt;code&gt;Bindings&lt;/code&gt; 来自 &lt;code&gt;Tree&lt;/code&gt; 根节点上的注释 &lt;code&gt;{env, Bindings}&lt;/code&gt; 。如果不存在这样的注释，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="7bbf9ca1c736db15763a8239f95f4d5c1b66558d" translate="yes" xml:space="preserve">
          <source>Adds the directories in &lt;code&gt;Dirs&lt;/code&gt; to the end of the code path. If a &lt;code&gt;Dir&lt;/code&gt; exists, it is not added.</source>
          <target state="translated">将 &lt;code&gt;Dirs&lt;/code&gt; 中的目录添加到代码路径的末尾。如果 &lt;code&gt;Dir&lt;/code&gt; 存在，则不添加。</target>
        </trans-unit>
        <trans-unit id="c8d419cc2314f6341b04eb8bad24bf2f277d7f87" translate="yes" xml:space="preserve">
          <source>Adds the modules found in the given directory and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;. The default is not to examine subdirectories, but if the option &lt;code&gt;recurse&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, modules are searched for in subdirectories on all levels as well as in the given directory. Returns a sorted list of the names of the added modules.</source>
          <target state="translated">将在给定目录中找到的模块和 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;modules' data&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。缺省情况是不检查子目录，但是如果 &lt;code&gt;recurse&lt;/code&gt; 选项的值为 &lt;code&gt;true&lt;/code&gt; ，则在所有级别以及给定目录的子目录中搜索模块。返回添加模块名称的排序列表。</target>
        </trans-unit>
        <trans-unit id="34d712dcc34471fdb6acaa22554dc0975d1f5dc6" translate="yes" xml:space="preserve">
          <source>Adds the registered name of the process. This can be useful when tracing on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">添加进程的注册名称。当在许多节点上进行跟踪时,这很有用,因为使用该名称的进程将在所有被跟踪的节点上进行跟踪。</target>
        </trans-unit>
        <trans-unit id="6bbf14dbe70908fe6ce0549e066a68aa359629b3" translate="yes" xml:space="preserve">
          <source>Adds the selected process and all processes below, right of it, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">将选定的进程及其下面的所有进程添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡中。</target>
        </trans-unit>
        <trans-unit id="3fcbc67018c8db0d7d54f40db7c26439211fb94f" translate="yes" xml:space="preserve">
          <source>Adds the selected process identifier to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the process resides on.</source>
          <target state="translated">将选定的进程标识符添加到&amp;ldquo; &lt;strong&gt;跟踪概述&amp;rdquo;&lt;/strong&gt;选项卡以及该进程所在的节点。</target>
        </trans-unit>
        <trans-unit id="3aebb82fdca9aa95c0538fef0af13a3b616d5fe2" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the beginning of the code path, similar to &lt;code&gt;code:add_pathsa/1&lt;/code&gt;. Note that the order of the given directories will be reversed in the resulting path.</source>
          <target state="translated">将指定目录添加到代码路径的开头，类似于 &lt;code&gt;code:add_pathsa/1&lt;/code&gt; 。请注意，给定目录的顺序将在结果路径中颠倒。</target>
        </trans-unit>
        <trans-unit id="0a1c883186e0d00a77adaf41f013ddc82c811398" translate="yes" xml:space="preserve">
          <source>Adds the specified directories to the end of the code path, similar to &lt;code&gt;code:add_pathsz/1&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">将指定的目录添加到代码路径的末尾，类似于 &lt;code&gt;code:add_pathsz/1&lt;/code&gt; ; 参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d2e0e96fcba01247b2f834ed2a0365db181f6d4" translate="yes" xml:space="preserve">
          <source>Adds the specified primary filters.</source>
          <target state="translated">添加指定的主过滤器。</target>
        </trans-unit>
        <trans-unit id="d613e82163d56d8326249e8169f52e84f75a04cb" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of compress extensions.</source>
          <target state="translated">将这些扩展添加到压缩扩展列表中。</target>
        </trans-unit>
        <trans-unit id="25822e567273ecdc04d1dd713da5a9ee0671d675" translate="yes" xml:space="preserve">
          <source>Adds these extensions to the list of uncompress extensions.</source>
          <target state="translated">将这些扩展添加到解压扩展列表中。</target>
        </trans-unit>
        <trans-unit id="2f502d97e1ab810c3754afd45a8594c92efa30f8" translate="yes" xml:space="preserve">
          <source>Adds to &lt;code&gt;Forms&lt;/code&gt; the code for the standard pre-defined functions (such as &lt;code&gt;module_info/0&lt;/code&gt;) that are to be included in every module.</source>
          <target state="translated">将要包含在每个模块中的标准预定义功能（例如 &lt;code&gt;module_info/0&lt;/code&gt; ）的代码添加到 &lt;code&gt;Forms&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="bb8f1512f2d702beeef48e8c7223a0b1dde1e4a0" translate="yes" xml:space="preserve">
          <source>Adjust the process(&quot;beam&quot;) reference to your beam version and attach the script to a running &quot;beam&quot; instance:</source>
          <target state="translated">调整process(&quot;beam&quot;)对你的beam版本的引用,并将脚本附加到一个正在运行的 &quot;beam &quot;实例上。</target>
        </trans-unit>
        <trans-unit id="c57f256463601b2a2c62f254f5126bfecb16a4d2" translate="yes" xml:space="preserve">
          <source>Adjusts the SSH flow control window. This is to be done by both the client- and server-side channel processes.</source>
          <target state="translated">调整SSH流控窗口。这要由客户端和服务器端的通道进程来完成。</target>
        </trans-unit>
        <trans-unit id="980e8823b26ab3a416e4eec330a78a5f567d8a4d" translate="yes" xml:space="preserve">
          <source>Affects SSL-3.0 and TLS-1.0 connections only. Used to change the BEAST mitigation strategy to interoperate with legacy software. Defaults to &lt;code&gt;one_n_minus_one&lt;/code&gt;.</source>
          <target state="translated">仅影响SSL-3.0和TLS-1.0连接。用于更改BEAST缓解策略以与旧版软件互操作。默认为 &lt;code&gt;one_n_minus_one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6004ea02cc23d09682422b618c26d349782aa93" translate="yes" xml:space="preserve">
          <source>Affects TLS-1.0 connections only. If set to &lt;code&gt;false&lt;/code&gt;, it disables the block cipher padding check to be able to interoperate with legacy software.</source>
          <target state="translated">仅影响TLS-1.0连接。如果设置为 &lt;code&gt;false&lt;/code&gt; ，它将禁用块密码填充检查，以便能够与旧版软件互操作。</target>
        </trans-unit>
        <trans-unit id="4b6ffc59171bd18b8e61a3e781dab573deabf10a" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs on Windows only. The standard input and standard output handles of the port program are, if this option is supplied, opened with flag &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt;, so that the port program can (and must) do overlapped I/O on its standard handles. This is not normally the case for simple port programs, but an option of value for the experienced Windows programmer. &lt;strong&gt;On all other platforms, this option is silently discarded.&lt;/strong&gt;</source>
          <target state="translated">仅影响Windows上的外部程序的端口。如果提供了此选项，则使用标志 &lt;code&gt;FILE_FLAG_OVERLAPPED&lt;/code&gt; 打开端口程序的标准输入和标准输出句柄，以便端口程序可以（并且必须）在其标准句柄上执行重叠的I / O。对于简单的端口程序，通常不是这种情况，但是对于经验丰富的Windows程序员来说，这是一种有价值的选择。&lt;strong&gt;在所有其他平台上，此选项将被静默丢弃。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf4fb0d4263b60ac21dc80f51c2dec3dcfb5747e" translate="yes" xml:space="preserve">
          <source>Affects ports to external programs. The executed program gets its standard error file redirected to its standard output file. &lt;code&gt;stderr_to_stdout&lt;/code&gt; and &lt;code&gt;nouse_stdio&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">影响到外部程序的端口。执行的程序将其标准错误文件重定向到其标准输出文件。 &lt;code&gt;stderr_to_stdout&lt;/code&gt; 和 &lt;code&gt;nouse_stdio&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="76c066b0f9a1e6496e99cead0881b8f872728f45" translate="yes" xml:space="preserve">
          <source>After LTTng is properly installed on the system Erlang/OTP can be built with LTTng support.</source>
          <target state="translated">在系统上正确安装LTTng后,就可以用LTTng支持构建Erlang/OTP。</target>
        </trans-unit>
        <trans-unit id="1facbcf11ae5793aa1bc80ef16d286aebd0fc34d" translate="yes" xml:space="preserve">
          <source>After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">在0之后,最多读取两个八位数。如果少于两个数字,则只使用现有的数字。因此,序列 \0\x\015指定了两个二进制零,后面是一个CR字符(代码值13)。如果后面的模式字符本身是一个八进制数字,请确保在初始零之后提供两个数字。</target>
        </trans-unit>
        <trans-unit id="d732389ea2448ab3a2fa3d0a36ca3e321f1eb8c8" translate="yes" xml:space="preserve">
          <source>After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:</source>
          <target state="translated">在部分匹配或匹配失败后,会返回整个匹配过程中最后遇到的名字,例如。</target>
        </trans-unit>
        <trans-unit id="18ee0e3703c2647b03b1406f234f9cc3d123429d" translate="yes" xml:space="preserve">
          <source>After adding more records to the &lt;code&gt;Company&lt;/code&gt; database, the result can be the following records:</source>
          <target state="translated">在将更多记录添加到 &lt;code&gt;Company&lt;/code&gt; 数据库后，结果可能是以下记录：</target>
        </trans-unit>
        <trans-unit id="22669be288b8402f937e20a5b4c0d8be02ada8ae" translate="yes" xml:space="preserve">
          <source>After an analysis, you can inspect this information. In the &lt;strong&gt;PLT&lt;/strong&gt; menu you can choose to either search the PLT or inspect the contents of the whole PLT. The information is presented in &lt;code&gt;EDoc&lt;/code&gt; format.</source>
          <target state="translated">经过分析，您可以检查此信息。在&lt;strong&gt;PLT&lt;/strong&gt;菜单中，您可以选择搜索PLT或检查整个PLT的内容。该信息以 &lt;code&gt;EDoc&lt;/code&gt; 格式显示。</target>
        </trans-unit>
        <trans-unit id="6ef9c0c6bbe4e27c696f859b427107c4e849d03c" translate="yes" xml:space="preserve">
          <source>After any post hook has been executed for all installed CTHs, &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; is called if the testcase failed or was skipped, respectively. You cannot affect the outcome of the tests any further at this point.</source>
          <target state="translated">在对所有已安装的CTH执行任何发布挂钩之后，如果测试用例失败或被跳过，则分别调用 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_fail-4&quot;&gt;on_tc_fail&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:on_tc_skip-4&quot;&gt;on_tc_skip&lt;/a&gt;&lt;/code&gt; 。您现在不能再影响测试结果了。</target>
        </trans-unit>
        <trans-unit id="f056750b4e33f30fb9d5942f6265a2d4f346b9dc" translate="yes" xml:space="preserve">
          <source>After at least one tab-character, the line added is to contain the full name of the named pipe where &lt;code&gt;syslogd&lt;/code&gt; writes its information. The path must be the same as for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The filename must be &lt;code&gt;syslog.otp&lt;/code&gt;.</source>
          <target state="translated">在至少一个制表符之后，添加的行将包含 &lt;code&gt;syslogd&lt;/code&gt; 写入其信息的命名管道的全名。该路径必须与 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 文件的路径相同。文件名必须是 &lt;code&gt;syslog.otp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ce4ab81087082fd95156bdaf8c2e0786410e8e3" translate="yes" xml:space="preserve">
          <source>After completing all the normal building steps described above a debug enabled runtime system can be built. To do this you have to change directory to &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and execute:</source>
          <target state="translated">完成上述所有正常构建步骤后，即可构建启用调试的运行时系统。为此，您必须将目录更改为 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 并执行：</target>
        </trans-unit>
        <trans-unit id="9cd742cd300933dfb65e0a535f4d15de36d37f01" translate="yes" xml:space="preserve">
          <source>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">在解码一个消息后,为了让用户能够正确的操作,各种用户回调函数被调用。关于回调参数的更多信息,请参见megaco_user模块。</target>
        </trans-unit>
        <trans-unit id="dc240b1130d5df1612bf5772e5400cd74e1cad80" translate="yes" xml:space="preserve">
          <source>After flag fields for atom cache references, another half byte flag field is located with the following format:</source>
          <target state="translated">在原子缓存引用的标志字段之后,还有一个半字节的标志字段,其格式如下。</target>
        </trans-unit>
        <trans-unit id="8aca18c81b4ecc6e98bd69677c9d22a41d1f8407" translate="yes" xml:space="preserve">
          <source>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use &lt;code&gt;erl_connect()&lt;/code&gt;. The following example sets up the connection and is to result in a valid socket file descriptor:</source>
          <target state="translated">初始化后，建立与Erlang节点的连接。要指定要连接的Erlang节点，请使用 &lt;code&gt;erl_connect()&lt;/code&gt; 。下面的示例设置连接并生成有效的套接字文件描述符：</target>
        </trans-unit>
        <trans-unit id="71297d463c83eda2a6c9154b983ee09e837036ff" translate="yes" xml:space="preserve">
          <source>After installation you can access the documentation by</source>
          <target state="translated">安装后,您可以通过以下方式访问文档</target>
        </trans-unit>
        <trans-unit id="6b0c5270a184c48e498da3c725b4712069c50f99" translate="yes" xml:space="preserve">
          <source>After matching all six digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.</source>
          <target state="translated">在匹配了所有六位数字后,又未能匹配到 &quot;foo&quot;,匹配器的正常操作是只用五位数字再试一次匹配项 \d+,然后用四位,以此类推,最终失败。&quot;原子分组&quot;(这个术语取自Jeffrey Friedl的书)提供了指定子模式一旦匹配后,就不能再这样重新评估的方法。</target>
        </trans-unit>
        <trans-unit id="ae043d6d909deeb13bd861dc2fdf16fc111c0f4f" translate="yes" xml:space="preserve">
          <source>After reading the &lt;code&gt;erts_alloc(3)&lt;/code&gt; documentation, the returned information more or less speaks for itself, but it can be worth explaining some things. Call counts are presented by two values, the first value is giga calls, and the second value is calls. &lt;code&gt;mbcs&lt;/code&gt; and &lt;code&gt;sbcs&lt;/code&gt; denote multi-block carriers, and single-block carriers, respectively. Sizes are presented in bytes. When a size is not presented, it is the amount of something. Sizes and amounts are often presented by three values:</source>
          <target state="translated">阅读了 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 文档后，返回的信息或多或少地说明了问题，但是有些事情值得解释。呼叫计数由两个值表示，第一个值是千兆呼叫，第二个值是呼叫。 &lt;code&gt;mbcs&lt;/code&gt; 和 &lt;code&gt;sbcs&lt;/code&gt; 分别表示多块载波和单块载波。大小以字节为单位。如果未显示尺寸，则为一定数量。大小和数量通常由三个值表示：</target>
        </trans-unit>
        <trans-unit id="e9095c6393c06f16504fcb2b9e560f38a38a063b" translate="yes" xml:space="preserve">
          <source>After registering the name, use &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; to wait for incoming connections.</source>
          <target state="translated">注册名称后，使用 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_accept&quot;&gt;erl_connect:erl_accept&lt;/a&gt;&lt;/code&gt; 等待传入连接。</target>
        </trans-unit>
        <trans-unit id="d3c38468398c9f7ba65583a0574f32622bbcf3f0" translate="yes" xml:space="preserve">
          <source>After sending the message &lt;code&gt;pong&lt;/code&gt; to the process &quot;ping&quot;, &quot;pong&quot; calls the &lt;code&gt;pong&lt;/code&gt; function again, which causes it to get back to the &lt;code&gt;receive&lt;/code&gt; again and wait for another message.</source>
          <target state="translated">在将消息 &lt;code&gt;pong&lt;/code&gt; 发送到进程&amp;ldquo; ping&amp;rdquo;之后，&amp;ldquo; pong&amp;rdquo; 再次调用 &lt;code&gt;pong&lt;/code&gt; 函数，这使它再次返回到 &lt;code&gt;receive&lt;/code&gt; 并等待另一条消息。</target>
        </trans-unit>
        <trans-unit id="e36306045d856ed44b3178bdde7ee2e0ace1e9c1" translate="yes" xml:space="preserve">
          <source>After setting the dictionary the inflate operation should be retried without new input.</source>
          <target state="translated">在设置字典后,膨胀操作应该在没有新输入的情况下重新尝试。</target>
        </trans-unit>
        <trans-unit id="46b2484894cf1b418bcc258ea3f4b87e3bcd685f" translate="yes" xml:space="preserve">
          <source>After testing that the client process exists:</source>
          <target state="translated">在测试客户进程存在后。</target>
        </trans-unit>
        <trans-unit id="22756028dc88f951673801206c8f0149ec02c1b4" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;Flags&lt;/code&gt; field follow the &lt;code&gt;AtomCacheRefs&lt;/code&gt;. The first &lt;code&gt;AtomCacheRef&lt;/code&gt; is the one corresponding to &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0. Higher indices follow in sequence up to index &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Flags&lt;/code&gt; 字段之后，跟随 &lt;code&gt;AtomCacheRefs&lt;/code&gt; 。第一个 &lt;code&gt;AtomCacheRef&lt;/code&gt; 是与 &lt;code&gt;AtomCacheReferenceIndex&lt;/code&gt; 0 对应的一个。更高的索引依次到索引 &lt;code&gt;NumberOfAtomCacheRefs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca4e4c96c0a14c7be226e5bd7489709c72d0c43" translate="yes" xml:space="preserve">
          <source>After the application specifications have been updated, the instructions in the script are evaluated and the function returns &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; if successful. &lt;code&gt;OtherVsn&lt;/code&gt; and &lt;code&gt;Descr&lt;/code&gt; are the version (&lt;code&gt;UpFromVsn&lt;/code&gt; or &lt;code&gt;Vsn&lt;/code&gt;) and description (&lt;code&gt;Descr1&lt;/code&gt; or &lt;code&gt;Descr2&lt;/code&gt;) as specified in the script.</source>
          <target state="translated">更新应用程序规范后，将评估脚本中的指令，如果成功 &lt;code&gt;{ok,OtherVsn,Descr}&lt;/code&gt; 函数将返回{ok，OtherVsn，Descr}。 &lt;code&gt;OtherVsn&lt;/code&gt; 和 &lt;code&gt;Descr&lt;/code&gt; 是版本（ &lt;code&gt;UpFromVsn&lt;/code&gt; 或 &lt;code&gt;Vsn&lt;/code&gt; ）和说明（ &lt;code&gt;Descr1&lt;/code&gt; 或 &lt;code&gt;Descr2&lt;/code&gt; 如在脚本中指定）。</target>
        </trans-unit>
        <trans-unit id="0d4f7a31773a30c9ab44ee914a380f7ad8d9358d" translate="yes" xml:space="preserve">
          <source>After the change, 5 lines are presented as follows:</source>
          <target state="translated">改造后,5条线呈现如下。</target>
        </trans-unit>
        <trans-unit id="2c691aee72f4af2559c4df9a131c0a55a89cadf0" translate="yes" xml:space="preserve">
          <source>After the database is deleted, it can still be possible to start Mnesia as a disc-less node. This depends on how configuration parameter &lt;code&gt;schema_location&lt;/code&gt; is set.</source>
          <target state="translated">删除数据库后，仍然可以将Mnesia作为无盘节点启动。这取决于如何设置配置参数 &lt;code&gt;schema_location&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4e458fe2735510f2a3f94986ee2e1c2798b1558" translate="yes" xml:space="preserve">
          <source>After the insertion of the employee named &lt;code&gt;klacke&lt;/code&gt;, the database has the following records:</source>
          <target state="translated">插入名为 &lt;code&gt;klacke&lt;/code&gt; 的员工后，数据库具有以下记录：</target>
        </trans-unit>
        <trans-unit id="014d2e6e6b7efad4c0429a37b959bc880d48f38c" translate="yes" xml:space="preserve">
          <source>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</source>
          <target state="translated">安装完成后,应用控制器对所有正在运行的应用进行新旧配置参数的比较,并调用回调函数。</target>
        </trans-unit>
        <trans-unit id="8b5bb17b2c511826d46800999f421579e3ca514c" translate="yes" xml:space="preserve">
          <source>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</source>
          <target state="translated">还原操作后,注册表的全部内容被标记为未修改。请注意,这包括任何在还原前被修改且未被还原覆盖的对象。</target>
        </trans-unit>
        <trans-unit id="c4f3acb2fc60165a466769fee1869d300231ddf6" translate="yes" xml:space="preserve">
          <source>After the rootsymbol declaration comes an optional declaration of the &lt;code&gt;end_of_input&lt;/code&gt; symbol that your scanner is expected to use. For example:</source>
          <target state="translated">在rootsymbol声明后的是一个可选的声明 &lt;code&gt;end_of_input&lt;/code&gt; 符号您的扫描仪，预计使用。例如：</target>
        </trans-unit>
        <trans-unit id="2770f0bd427f63fd51d60a2a398782f6d81807ca" translate="yes" xml:space="preserve">
          <source>After the successful build it's time to patch. The source tree directory, the directory of the installation and the applications to patch are given as arguments to &lt;code&gt;otp_patch_apply&lt;/code&gt;. The dependencies of each application are validated against the applications in the installation and the other applications given as arguments. If a dependency error is detected, the script will be aborted.</source>
          <target state="translated">成功构建之后，就该进行修补了。源树目录，安装目录和要修补的应用程序作为 &lt;code&gt;otp_patch_apply&lt;/code&gt; 的参数给出。对照安装中的应用程序和作为参数给出的其他应用程序验证每个应用程序的依赖性。如果检测到依赖性错误，则脚本将被中止。</target>
        </trans-unit>
        <trans-unit id="59c978cfe3812d62d5db4509ebca4d4c5513e4b6" translate="yes" xml:space="preserve">
          <source>After the system has been cross built you can build and install the documentation the same way as after a native build of the system. See the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; section in the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document for information on how to build the documentation.</source>
          <target state="translated">跨系统构建之后，您可以按照本机构建后的相同方式构建和安装文档。请参阅 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 文档中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP_How-to-Build-the-Documentation&quot;&gt;How to Build the Documentation&lt;/a&gt;&lt;/code&gt; 部分，以获取有关如何构建文档的信息。</target>
        </trans-unit>
        <trans-unit id="9b3f9b5771b4280d0c55a70767959a27ea46eb52" translate="yes" xml:space="preserve">
          <source>After this is compiled and the file &lt;code&gt;tut19.beam&lt;/code&gt; is copied to the necessary directories, the following is seen on (pong@kosken):</source>
          <target state="translated">编译完成并将文件 &lt;code&gt;tut19.beam&lt;/code&gt; 复制到必要的目录后，在（pong @ kosken）上可以看到以下内容：</target>
        </trans-unit>
        <trans-unit id="e0717a39ec07e9aad70e9e475eae5bb9f752c8e1" translate="yes" xml:space="preserve">
          <source>Again, the &lt;code&gt;relup&lt;/code&gt; file is created manually. Either from scratch or by editing a generated version. Load all code for &lt;code&gt;ch_app&lt;/code&gt; first, and also load the application specification, before &lt;code&gt;prim_sup&lt;/code&gt; is updated. When downgrading, &lt;code&gt;prim_sup&lt;/code&gt; is to updated first, before the code for &lt;code&gt;ch_app&lt;/code&gt; and its application specification are unloaded.</source>
          <target state="translated">同样， &lt;code&gt;relup&lt;/code&gt; 文件是手动创建的。从头开始或通过编辑生成的版本。在更新 &lt;code&gt;prim_sup&lt;/code&gt; 之前，首先加载 &lt;code&gt;ch_app&lt;/code&gt; 的所有代码，并加载应用程序规范。降级的情况下， &lt;code&gt;prim_sup&lt;/code&gt; 是首先更新，代码之前 &lt;code&gt;ch_app&lt;/code&gt; 及其应用规范被卸载。</target>
        </trans-unit>
        <trans-unit id="1b5e61e0895721c0ebf450f07d288833226aa589" translate="yes" xml:space="preserve">
          <source>Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:</source>
          <target state="translated">同样,这在Perl中也能用,但在PCRE中就不行了,原因也一样。当深层递归匹配过一个字符后,就不能再输入匹配一个空字符串。解决的办法是将两种情况分开,将奇数和偶数的情况作为上层的备选方案写出来。</target>
        </trans-unit>
        <trans-unit id="3b2767e308e62a98e4db59a3a9f824fa516512cb" translate="yes" xml:space="preserve">
          <source>Agent configuration:</source>
          <target state="translated">代理配置。</target>
        </trans-unit>
        <trans-unit id="3ec3b79e0abd28ca38f812dac049f7131b92ea23" translate="yes" xml:space="preserve">
          <source>Agent semantics</source>
          <target state="translated">代理人语义</target>
        </trans-unit>
        <trans-unit id="292ef3c4e0286769b6dbb07a9c3a55d1d989a61e" translate="yes" xml:space="preserve">
          <source>Agent specific config options and types:</source>
          <target state="translated">代理商特定的配置选项和类型。</target>
        </trans-unit>
        <trans-unit id="9183ce25ce4e057cce5e3b5d3d28a86f4aa93b15" translate="yes" xml:space="preserve">
          <source>Agents to be accessed by the manager needs to be registered by a user. Once registered, they can be accessed by all registered users.</source>
          <target state="translated">经理要访问的代理需要用户注册。一旦注册,所有注册用户都可以访问它们。</target>
        </trans-unit>
        <trans-unit id="b321e7cb00697b98b1069def622912b90e34756e" translate="yes" xml:space="preserve">
          <source>Aho &amp;amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</source>
          <target state="translated">Aho＆Johnson：&amp;ldquo; LR解析&amp;rdquo;，ACM计算调查，第1卷。1974年6：2。</target>
        </trans-unit>
        <trans-unit id="8314c1bccd7fbe31d59f08ffd330d112f0923137" translate="yes" xml:space="preserve">
          <source>Aim for finding bugs. Write whatever test that has the highest probability of finding a bug, now or in the future. Concentrate more on the critical parts. Bugs in critical subsystems are much more expensive than others.</source>
          <target state="translated">以找到bug为目标。不管是现在还是将来,只要是发现bug的概率最高的测试都要写。更多地集中在关键部分。关键子系统的bug比其他子系统的bug要贵得多。</target>
        </trans-unit>
        <trans-unit id="2e73e04c930e7b3b6a12e1613006c2d06e333b4f" translate="yes" xml:space="preserve">
          <source>Aim for functionality testing rather than implementation details. Implementation details change quite often, and the test suites are to be long lived. Implementation details often differ on different platforms and versions. If implementation details must be tested, try to factor them out into separate test cases. These test cases can later be rewritten or skipped.</source>
          <target state="translated">瞄准功能测试而不是实现细节。实现细节经常变化,测试套件要长期存在。在不同的平台和版本上,实现细节往往不同。如果必须对实现细节进行测试,尽量将其分解成单独的测试用例。这些测试用例以后可以重写或跳过。</target>
        </trans-unit>
        <trans-unit id="5204c24c2356e334c01209b09953d29e8b1c732c" translate="yes" xml:space="preserve">
          <source>Alarm handling</source>
          <target state="translated">报警处理</target>
        </trans-unit>
        <trans-unit id="07994d0d2fea2b8ccddc2fe4a57609e0e8cf0605" translate="yes" xml:space="preserve">
          <source>Alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">报警,即BEL字符(十六进制07)</target>
        </trans-unit>
        <trans-unit id="44b68bd3aa7ebc745c49072e3fc9224605032491" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is either of the alarms specified above.</source>
          <target state="translated">警报将报告给SASL警报处理程序，请参阅 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 。要设置警报，将 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; ，其中&amp;ldquo; &lt;code&gt;Alarm&lt;/code&gt; 是上面指定的警报之一。</target>
        </trans-unit>
        <trans-unit id="0f8dd2eebf6d2846565db4f8d38173a2b29d2814" translate="yes" xml:space="preserve">
          <source>Alarms are reported to the SASL alarm handler, see &lt;code&gt;alarm_handler(3)&lt;/code&gt;. To set an alarm, &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; is called where &lt;code&gt;Alarm&lt;/code&gt; is the alarm specified above.</source>
          <target state="translated">警报将报告给SASL警报处理程序，请参阅 &lt;code&gt;alarm_handler(3)&lt;/code&gt; 。要设置警报，将 &lt;code&gt;alarm_handler:set_alarm(Alarm)&lt;/code&gt; ，其中&amp;ldquo; &lt;code&gt;Alarm&lt;/code&gt; &amp;rdquo;是上面指定的警报。</target>
        </trans-unit>
        <trans-unit id="84ce7c0201c306089cc2d312b83151f452054aab" translate="yes" xml:space="preserve">
          <source>Alas some drivers only support sequential traversal of the result set, e.i. they do not support what in the ODBC world is known as scrollable cursors. This will have the effect that functions such as &lt;code&gt;first/[1,2]&lt;/code&gt;, &lt;code&gt;last/[1,2]&lt;/code&gt;, &lt;code&gt;prev[1,2]&lt;/code&gt;, etc will return &lt;code&gt;{error, driver_does_not_support_function}&lt;/code&gt;</source>
          <target state="translated">遗憾的是，某些驱动程序仅支持结果集的顺序遍历，即它们不支持ODBC世界中称为滚动游标的内容。这样的结果是，诸如 &lt;code&gt;first/[1,2]&lt;/code&gt; ， &lt;code&gt;last/[1,2]&lt;/code&gt; ， &lt;code&gt;prev[1,2]&lt;/code&gt; 等 &lt;code&gt;{error, driver_does_not_support_function}&lt;/code&gt; 将返回{error，driver_does_not_support_function}</target>
        </trans-unit>
        <trans-unit id="f3544e748508a0bbd0fc5c633ca3118ece8b0800" translate="yes" xml:space="preserve">
          <source>Algorithm &lt;code&gt;dss&lt;/code&gt; can only be used together with digest type &lt;code&gt;sha&lt;/code&gt;.</source>
          <target state="translated">算法 &lt;code&gt;dss&lt;/code&gt; 只能与摘要类型 &lt;code&gt;sha&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="37c4127ccfb7b20befe4cb97e24121c28c2f7f1f" translate="yes" xml:space="preserve">
          <source>Algorithm specific internal state</source>
          <target state="translated">算法特定的内部状态</target>
        </trans-unit>
        <trans-unit id="f502ff90b179f9e55f8a7ae7ffe6d44ac52ffa57" translate="yes" xml:space="preserve">
          <source>Algorithm-dependent state that can be printed or saved to file.</source>
          <target state="translated">与算法有关的状态,可以打印或保存到文件中。</target>
        </trans-unit>
        <trans-unit id="75ed735ab6b662cd2ed59461e6465ca8ad02da5f" translate="yes" xml:space="preserve">
          <source>Algorithm-dependent state.</source>
          <target state="translated">算法依赖的状态。</target>
        </trans-unit>
        <trans-unit id="d44cc1b551df7badcd7a33c05306605d60158636" translate="yes" xml:space="preserve">
          <source>Algorithms for directed graphs.</source>
          <target state="translated">有向图的算法。</target>
        </trans-unit>
        <trans-unit id="479976d6e7303ea1ee63388a8b2e770b0c6d7167" translate="yes" xml:space="preserve">
          <source>Alivename, &lt;code&gt;alive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alive&lt;/code&gt; 名字</target>
        </trans-unit>
        <trans-unit id="113679e7d7df16876eb31c71a0f678be963054d7" translate="yes" xml:space="preserve">
          <source>All &quot;function calls&quot; must be tuples, even if they take no arguments. The value of &lt;code&gt;self&lt;/code&gt; is the atom() &lt;code&gt;self&lt;/code&gt;, but the value of &lt;code&gt;{self}&lt;/code&gt; is the pid() of the current process.</source>
          <target state="translated">所有&amp;ldquo;函数调用&amp;rdquo;都必须是元组，即使它们不带任何参数也是如此。 &lt;code&gt;self&lt;/code&gt; 的值是atom（） &lt;code&gt;self&lt;/code&gt; ，而 &lt;code&gt;{self}&lt;/code&gt; 的值是当前进程的pid（）。</target>
        </trans-unit>
        <trans-unit id="c96f50147ab1ef9d7a93bb31a493f340cbc1ac77" translate="yes" xml:space="preserve">
          <source>All (in)direct calls from functions in &lt;code&gt;toolbar&lt;/code&gt; to functions in &lt;code&gt;debugger&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;toolbar&lt;/code&gt; 函数到 &lt;code&gt;debugger&lt;/code&gt; 函数的所有（间接）调用。</target>
        </trans-unit>
        <trans-unit id="089083e2c94f89536494899703365f0e8ddff6fd" translate="yes" xml:space="preserve">
          <source>All (locally) mounted disks are checked, including the swap disk if it is present.</source>
          <target state="translated">所有(本地)安装的磁盘都会被检查,包括交换磁盘(如果存在)。</target>
        </trans-unit>
        <trans-unit id="f677675819b8b0d1f1b80ed411e21b154b117015" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; are processed in order of appearance.</source>
          <target state="translated">所有 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 均按出现顺序进行处理。</target>
        </trans-unit>
        <trans-unit id="05aeddfde77656e8d62c4f7d53fc3c8c4d3ed5c3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;LevelEntry&lt;/code&gt;s of a list must contain the same &lt;code&gt;LevelTag&lt;/code&gt;, except on the top level where both &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;processor&lt;/code&gt;&lt;code&gt;LevelTag&lt;/code&gt;s can coexist.    &lt;code&gt;{LevelTag, SubLevel} == {LevelTag, [], SubLevel}&lt;/code&gt;    More &lt;code&gt;LevelTag&lt;/code&gt;s can be introduced in a future release.     The &lt;code&gt;info_list()&lt;/code&gt; can be extended in a future release.</source>
          <target state="translated">列表中的所有 &lt;code&gt;LevelEntry&lt;/code&gt; 都必须包含相同的 &lt;code&gt;LevelTag&lt;/code&gt; ，除了在顶层， &lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;processor&lt;/code&gt; &lt;code&gt;LevelTag&lt;/code&gt; 可以共存。 &lt;code&gt;{LevelTag, SubLevel} == {LevelTag, [], SubLevel}&lt;/code&gt; 在以后的版本 &lt;code&gt;LevelTag&lt;/code&gt; 引入 更多LevelTag。该 &lt;code&gt;info_list()&lt;/code&gt; 可以在将来的版本进行扩展。</target>
        </trans-unit>
        <trans-unit id="6724788c6ade526686ec55a7af8484e09d219146" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;cth_conn_log&lt;/code&gt; hook options described can also be specified in a configuration file with configuration variable &lt;code&gt;ct_conn_log&lt;/code&gt;.</source>
          <target state="translated">还可以在配置文件中使用配置变量 &lt;code&gt;ct_conn_log&lt;/code&gt; 指定所有描述的 &lt;code&gt;cth_conn_log&lt;/code&gt; 挂钩选项。</target>
        </trans-unit>
        <trans-unit id="8a4b3de223153d6148caabecc5ca1ade2664a14a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;snmp&lt;/code&gt; counters are set to zero.</source>
          <target state="translated">所有 &lt;code&gt;snmp&lt;/code&gt; 计数器都设置为零。</target>
        </trans-unit>
        <trans-unit id="1518061c2a50f94ff59e63daeae206bdc35745d1" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;named&lt;/strong&gt; subpatterns in the regular expression, as if a &lt;code&gt;list()&lt;/code&gt; of all the names &lt;strong&gt;in alphabetical order&lt;/strong&gt; was specified. The list of all names can also be retrieved with &lt;code&gt;&lt;a href=&quot;#inspect-2&quot;&gt;inspect/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">正则表达式中的所有&lt;strong&gt;命名&lt;/strong&gt;子模式，就好像指定&lt;strong&gt;了按字母顺序排列&lt;/strong&gt;的所有名称的 &lt;code&gt;list()&lt;/code&gt; 一样。还可以使用 &lt;code&gt;&lt;a href=&quot;#inspect-2&quot;&gt;inspect/2&lt;/a&gt;&lt;/code&gt; 检索所有名称的列表。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4916d63a32f5bd45e8c8ebc0b371a252007867f" translate="yes" xml:space="preserve">
          <source>All API functions that update the index return a &lt;code&gt;NewIndex&lt;/code&gt; term. This is for backward compatibility with a previous implementation that used a B+ tree written purely in Erlang for the index. The &lt;code&gt;NewIndex&lt;/code&gt; return value can now be ignored. The return value is now the unchanged table identifier for the ets table.</source>
          <target state="translated">所有更新索引的API函数均返回 &lt;code&gt;NewIndex&lt;/code&gt; 术语。这是为了与以前的实现向后兼容，该实现使用了纯粹用Erlang编写的B +树作为索引。该 &lt;code&gt;NewIndex&lt;/code&gt; 返回值现在可以忽略不计。现在，返回值是ets表的未更改表标识符。</target>
        </trans-unit>
        <trans-unit id="508db9dc0ec99907c00ed0f8830bf421e130f560" translate="yes" xml:space="preserve">
          <source>All API-functions are guarded and if you pass an argument of the wrong type a runtime error will occur. All input parameters to internal functions are trusted to be correct. It is a good programming practise to only distrust input from truly external sources. You are not supposed to catch these errors, it will only make the code very messy and much more complex, which introduces more bugs and in the worst case also covers up the actual faults. Put your effort on testing instead, you should trust your own input.</source>
          <target state="translated">所有的API函数都是有保护的,如果你传递一个错误类型的参数,就会发生运行时错误。所有内部函数的输入参数都被信任为正确的。只有不信任来自真正外部的输入才是一个好的编程实践。你不应该去捕捉这些错误,这只会让代码变得非常混乱和复杂得多,从而引入更多的错误,在最坏的情况下还会掩盖实际的故障。把精力放在测试上吧,你应该相信自己的输入。</target>
        </trans-unit>
        <trans-unit id="00ff4622a14c4c7f7fbaab2bf437fe6ca8d16292" translate="yes" xml:space="preserve">
          <source>All DTLS versions supported by the SSL application. DTLS 1.2 requires sufficient support from the Crypto application.</source>
          <target state="translated">SSL应用程序支持的所有DTLS版本。DTLS 1.2 需要 Crypto 应用程序的充分支持。</target>
        </trans-unit>
        <trans-unit id="59b704215a27754dabda2c983777a71cd473ecc4" translate="yes" xml:space="preserve">
          <source>All Dets functions return &lt;code&gt;{error, Reason}&lt;/code&gt; if an error occurs (&lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; are exceptions, they exit the process with the error tuple). If badly formed arguments are specified, all functions exit the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">所有dets的函数返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 如果发生错误，（ &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 是例外，它们离开用误差元组中的处理）。如果指定了 &lt;code&gt;badarg&lt;/code&gt; 错误的参数，则所有函数都将通过badarg消息退出该过程。</target>
        </trans-unit>
        <trans-unit id="6860af1b417f061473f28a251963ae51220b55b4" translate="yes" xml:space="preserve">
          <source>All Erlang processes have a default standard I/O device. This device is used when no &lt;code&gt;IoDevice&lt;/code&gt; argument is specified in the function calls in this module. However, it is sometimes desirable to use an explicit &lt;code&gt;IoDevice&lt;/code&gt; argument that refers to the default I/O device. This is the case with functions that can access either a file or the default I/O device. The atom &lt;code&gt;standard_io&lt;/code&gt; has this special meaning. The following example illustrates this:</source>
          <target state="translated">所有的Erlang进程都有一个默认的标准I / O设备。在此模块的函数调用中未指定 &lt;code&gt;IoDevice&lt;/code&gt; 参数时，将使用此设备。但是，有时需要使用一个引用默认I / O设备的显式 &lt;code&gt;IoDevice&lt;/code&gt; 参数。可以访问文件或默认I / O设备的功能就是这种情况。原子 &lt;code&gt;standard_io&lt;/code&gt; 具有此特殊含义。以下示例说明了这一点：</target>
        </trans-unit>
        <trans-unit id="97b951c1c805c5f05124e900fd4fa56864d49618" translate="yes" xml:space="preserve">
          <source>All Erlang types are the string equivalent in LTTng.</source>
          <target state="translated">所有的Erlang类型都是Lttng中的字符串等价物。</target>
        </trans-unit>
        <trans-unit id="d9f521ade6fc1dd9350ccff9c5983982a41844ce" translate="yes" xml:space="preserve">
          <source>All Erlang/OTP applications except the &lt;code&gt;wx&lt;/code&gt; application can be cross compiled. The build of the &lt;code&gt;wx&lt;/code&gt; driver will currently be automatically disabled when cross compiling.</source>
          <target state="translated">除 &lt;code&gt;wx&lt;/code&gt; 应用程序外，所有Erlang / OTP应用程序都可以交叉编译。当前，交叉编译时将自动禁用 &lt;code&gt;wx&lt;/code&gt; 驱动程序的构建。</target>
        </trans-unit>
        <trans-unit id="5ad88821804527519cf8d8d810f3204aedf5bf2e" translate="yes" xml:space="preserve">
          <source>All I/O from the port is binary data objects as opposed to lists of bytes.</source>
          <target state="translated">所有来自端口的I/O都是二进制数据对象,而不是字节列表。</target>
        </trans-unit>
        <trans-unit id="2dd52ee361652541899aa325d9fd9f53e18c02c1" translate="yes" xml:space="preserve">
          <source>All Mnesia transactions, including all the schema update functions, either return value &lt;code&gt;{atomic, Val}&lt;/code&gt; or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; can be either of the atoms in the following list. The function &lt;code&gt;error_description/1&lt;/code&gt; returns a descriptive string that describes the error.</source>
          <target state="translated">所有Mnesia事务，包括所有模式更新功能，返回值 &lt;code&gt;{atomic, Val}&lt;/code&gt; 或元组 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 。 &lt;code&gt;Reason&lt;/code&gt; 可以是以下列表中的任何一个原子。函数 &lt;code&gt;error_description/1&lt;/code&gt; 返回描述错误的描述性字符串。</target>
        </trans-unit>
        <trans-unit id="4d3c60202c3777ca90cba552fcd0b5e85782d21a" translate="yes" xml:space="preserve">
          <source>All NIFs of a module must have an Erlang implementation as well.</source>
          <target state="translated">一个模块的所有NIF也必须有一个Erlang的实现。</target>
        </trans-unit>
        <trans-unit id="a725195324a4bf0385d8cc76f623d576b9073dd8" translate="yes" xml:space="preserve">
          <source>All ProcBin objects in a process are part of a linked list, so that the garbage collector can keep track of them and decrement the reference counters in the binary when a ProcBin disappears.</source>
          <target state="translated">进程中的所有ProcBin对象都是链接列表的一部分,这样垃圾收集器就可以跟踪它们,并在ProcBin消失时减少二进制中的引用计数器。</target>
        </trans-unit>
        <trans-unit id="ea090b0550d7e3c8580dc19d0e4eca0afcac1702" translate="yes" xml:space="preserve">
          <source>All SASL reports have a metadata field &lt;code&gt;domain&lt;/code&gt; which is set to &lt;code&gt;[otp,sasl]&lt;/code&gt;. This field can be used by filters to stop or allow the log events.</source>
          <target state="translated">所有SASL报告均具有设置为 &lt;code&gt;[otp,sasl]&lt;/code&gt; 的元数据字段 &lt;code&gt;domain&lt;/code&gt; 。过滤器可以使用此字段来停止或允许日志事件。</target>
        </trans-unit>
        <trans-unit id="4f15754d3db80f2fdc54c4817ccee09d053bbbf8" translate="yes" xml:space="preserve">
          <source>All SSL and TLS versions prior to TLS 1.2 use a combination of md5 and sha1 hashes in the handshake for various purposes:</source>
          <target state="translated">TLS 1.2之前的所有SSL和TLS版本都在握手中使用了md5和sha1哈希的组合,以达到各种目的。</target>
        </trans-unit>
        <trans-unit id="4d20ed1ea888788dca7c3c5db66c577a283406e7" translate="yes" xml:space="preserve">
          <source>All SSL/TLS versions supported by the SSL application. TLS 1.2 requires sufficient support from the Crypto application.</source>
          <target state="translated">SSL应用程序支持的所有SSL/TLS版本。TLS 1.2需要Crypto应用程序的充分支持。</target>
        </trans-unit>
        <trans-unit id="68fce467cd9e8e0d201b3f589073cfe5fb95d32d" translate="yes" xml:space="preserve">
          <source>All TCP socket options are accepted except &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;deliver&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;packet&lt;/code&gt;</source>
          <target state="translated">接受所有TCP套接字选项，但 &lt;code&gt;active&lt;/code&gt; ， &lt;code&gt;binary&lt;/code&gt; ， &lt;code&gt;deliver&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;mode&lt;/code&gt; 和 &lt;code&gt;packet&lt;/code&gt; 除外</target>
        </trans-unit>
        <trans-unit id="a5b34ac6bc99e27ebc78ae9ef663f69f3aa7a65b" translate="yes" xml:space="preserve">
          <source>All Unicode newline sequences</source>
          <target state="translated">所有Unicode换行序列</target>
        </trans-unit>
        <trans-unit id="2dbd3097b8923c397d9061270fd4c85d43474de4" translate="yes" xml:space="preserve">
          <source>All access files in the path to a requested asset are read once per request. This means that the load on the server increases when &lt;code&gt;htaccess&lt;/code&gt; is used.</source>
          <target state="translated">每个请求读取一次请求资产路径中的所有访问文件。这意味着使用 &lt;code&gt;htaccess&lt;/code&gt; 时服务器上的负载会增加。</target>
        </trans-unit>
        <trans-unit id="b65f417a9d96a9f2d2511f358eeb52c2d5221959" translate="yes" xml:space="preserve">
          <source>All allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected.</source>
          <target state="translated">所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 的分配器都会生效。</target>
        </trans-unit>
        <trans-unit id="487ed78b0938a6d1f8103db69e76299ed79ed19c" translate="yes" xml:space="preserve">
          <source>All application directories found in the additional directories appears before the standard OTP applications, except for the Kernel and STDLIB applications, which are placed before any additional applications. In other words, modules found in any of the additional library directories override modules with the same name in OTP, except for modules in Kernel and STDLIB.</source>
          <target state="translated">除了Kernel和STDLIB应用外,所有在附加目录中发现的应用目录都会出现在标准OTP应用之前。换句话说,除了Kernel和STDLIB中的模块外,任何附加库目录中的模块都会覆盖OTP中的同名模块。</target>
        </trans-unit>
        <trans-unit id="aed81dd75a1fe5a5f216237b2556bd6822c73c1d" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;code&gt;halt(Status)&lt;/code&gt;. If command-line flag &lt;code&gt;-heart&lt;/code&gt; was specified, the &lt;code&gt;heart&lt;/code&gt; program is terminated before the Erlang node terminates. For more information, see &lt;code&gt;heart(3)&lt;/code&gt;.</source>
          <target state="translated">在系统终止之前，通过调用 &lt;code&gt;halt(Status)&lt;/code&gt; 可以平稳地关闭所有应用程序，卸载所有代码，并关闭所有端口。如果指定了命令行标志 &lt;code&gt;-heart&lt;/code&gt; ，则在Erlang节点终止之前， &lt;code&gt;heart&lt;/code&gt; 程序将终止。有关更多信息，请参见 &lt;code&gt;heart(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d181c1e78cebe0843b022cbfb70d621d01c1feeb" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates. If command-line flag &lt;code&gt;-heart&lt;/code&gt; was specified, the &lt;code&gt;heart&lt;/code&gt; program tries to reboot the system. For more information, see &lt;code&gt;heart(3)&lt;/code&gt;.</source>
          <target state="translated">在系统终止之前，所有应用程序均顺利关闭，所有代码均已卸载，并且所有端口均已关闭。如果指定了命令行标志 &lt;code&gt;-heart&lt;/code&gt; ，则 &lt;code&gt;heart&lt;/code&gt; 程序将尝试重新引导系统。有关更多信息，请参见 &lt;code&gt;heart(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31bd3e3bf18b14bb65fb12d63888c9cd0d2fd4b0" translate="yes" xml:space="preserve">
          <source>All applications included by this application. When this application is started, all included applications are loaded automatically, but not started, by the application controller. It is assumed that the top-most supervisor of the included application is started by a supervisor of this application.</source>
          <target state="translated">该应用程序所包含的所有应用程序。当这个应用程序被启动时,所有包含的应用程序都会被应用程序控制器自动加载,但不会被启动。假设被包含的应用程序的最上级主管是由本应用程序的主管启动的。</target>
        </trans-unit>
        <trans-unit id="240f8d13b43d7ee3cac18e5842f7f15a95cd9de5" translate="yes" xml:space="preserve">
          <source>All applications that must be started before this application is allowed to be started. &lt;code&gt;systools&lt;/code&gt; uses this list to generate correct start scripts. Defaults to the empty list, but notice that all applications have dependencies to (at least) Kernel and STDLIB.</source>
          <target state="translated">允许启动此应用程序之前必须启动的所有应用程序。 &lt;code&gt;systools&lt;/code&gt; 使用此列表来生成正确的启动脚本。默认为空列表，但是请注意，所有应用程序都（至少）具有对内核和STDLIB的依赖关系。</target>
        </trans-unit>
        <trans-unit id="8d2add5c786e4437232e07f68f555e8cec5d10a4" translate="yes" xml:space="preserve">
          <source>All available ports in the Erlang emulator are in use.</source>
          <target state="translated">Erlang模拟器中所有可用的端口都在使用中。</target>
        </trans-unit>
        <trans-unit id="f84b54afc405de6cbd2ad11831864c463f1ea3fa" translate="yes" xml:space="preserve">
          <source>All available probes can be listed like this:</source>
          <target state="translated">所有可用的探头都可以这样列出。</target>
        </trans-unit>
        <trans-unit id="99d3b3bbd1737cb224eb46fd66ec80e666cf1f66" translate="yes" xml:space="preserve">
          <source>All binary operators are left associative; for instance, &lt;code&gt;A&amp;nbsp;|&amp;nbsp;B &amp;nbsp;||&amp;nbsp;C&lt;/code&gt; is equivalent to &lt;code&gt;(A&amp;nbsp;|&amp;nbsp;B)&amp;nbsp;||&amp;nbsp;C&lt;/code&gt;. The following is a list of all operators, in increasing order of  &lt;strong id=&quot;precedence&quot;&gt;precedence&lt;/strong&gt;:</source>
          <target state="translated">所有二进制运算符都保留关联；例如， &lt;code&gt;A&amp;nbsp;|&amp;nbsp;B &amp;nbsp;||&amp;nbsp;C&lt;/code&gt; 等于 &lt;code&gt;(A&amp;nbsp;|&amp;nbsp;B)&amp;nbsp;||&amp;nbsp;C&lt;/code&gt; 。以下是所有运算符的列表，按 &lt;strong id=&quot;precedence&quot;&gt;优先级升序排列&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="4eba54c164609c10e1724efde1b5a4f8594b594d" translate="yes" xml:space="preserve">
          <source>All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;binary&lt;/code&gt;, not returning subpatterns you are not interested in is a good way to optimize.</source>
          <target state="translated">除了第一个匹配子模式之外的所有子模式，即所有明确捕获的子模式，但不是主题字符串的完整匹配部分。如果正则表达式整体上与主题的大部分匹配，但是您感兴趣的部分位于显式捕获的子模式中，则这很有用。如果返回类型为 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;binary&lt;/code&gt; ，则不返回您不感兴趣的子模式是一种优化的好方法。</target>
        </trans-unit>
        <trans-unit id="b4ba388e0b6829ee7e6b0f29a6f89a7986b6d983" translate="yes" xml:space="preserve">
          <source>All calls are stored in the history buffer and can be recalled and stored in a configuration file. This makes it easy to set up the same trace environment, for example, if you want to compare two test runs. It also reduces the amount of typing when using &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell.</source>
          <target state="translated">所有调用都存储在历史记录缓冲区中，可以重新调用并存储在配置文件中。例如，如果您要比较两个测试运行，这使设置相同的跟踪环境变得容易。当从Erlang shell中使用 &lt;code&gt;ttb&lt;/code&gt; 时，它还减少了键入量。</target>
        </trans-unit>
        <trans-unit id="b75423c77806558051eb62cb5b02445cef05ff93" translate="yes" xml:space="preserve">
          <source>All calls that have both an external and a local version.</source>
          <target state="translated">所有同时拥有外部和本地版本的调用。</target>
        </trans-unit>
        <trans-unit id="d0fd374788e00e86bd43e2341f520f508c4c7e7e" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;ttb&lt;/code&gt; is stored in the history. This function returns the current content of the history. Any entry can be reexecuted with &lt;code&gt;run_history/1&lt;/code&gt; or stored in a configuration file with &lt;code&gt;write_config/2,3&lt;/code&gt;.</source>
          <target state="translated">所有对 &lt;code&gt;ttb&lt;/code&gt; 的调用都存储在历史记录中。此函数返回历史记录的当前内容。任何条目都可以使用 &lt;code&gt;run_history/1&lt;/code&gt; 重新执行，或使用 &lt;code&gt;write_config/2,3&lt;/code&gt; 存储在配置文件中。</target>
        </trans-unit>
        <trans-unit id="5bbe19e21b0c2eee883cf8913cd7724d259725e7" translate="yes" xml:space="preserve">
          <source>All calls within the Kernel application.</source>
          <target state="translated">内核应用中的所有调用。</target>
        </trans-unit>
        <trans-unit id="d69e89620f8a9f9e87b4eee0b38ab9d9d4411b86" translate="yes" xml:space="preserve">
          <source>All captured subpatterns including the complete matching string. This is the default.</source>
          <target state="translated">所有捕获的子模式,包括完整的匹配字符串。这是默认值。</target>
        </trans-unit>
        <trans-unit id="34abf6827e137ec9ba4d30877ba27c48b7d401ae" translate="yes" xml:space="preserve">
          <source>All characters needs to be valid characters on the specific OS using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters not necessarily will cause &lt;code&gt;&lt;a href=&quot;#cmd-1&quot;&gt;os:cmd/1&lt;/a&gt;&lt;/code&gt; to fail, but may instead produce invalid results.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码，所有字符都必须是特定操作系统上的有效字符。请注意，明确不允许使用空字符（整数值零）。但是，请注意，并非所有无效字符都不一定会导致 &lt;code&gt;&lt;a href=&quot;#cmd-1&quot;&gt;os:cmd/1&lt;/a&gt;&lt;/code&gt; 失败，而是可能产生无效结果。</target>
        </trans-unit>
        <trans-unit id="9ccc47d84718cbe0754906ab548e6f0d0c99ed92" translate="yes" xml:space="preserve">
          <source>All checks with function &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; are performed before the release package is created. Options &lt;code&gt;src_tests&lt;/code&gt; and &lt;code&gt;exref&lt;/code&gt; are also valid here.</source>
          <target state="translated">在创建发行包之前，将执行所有使用 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 函数进行的检查。选项 &lt;code&gt;src_tests&lt;/code&gt; 和 &lt;code&gt;exref&lt;/code&gt; 在这里也有效。</target>
        </trans-unit>
        <trans-unit id="2a363a443c582c3241bf4c750bee059e7cc5f662" translate="yes" xml:space="preserve">
          <source>All communication between Erlang and C must be established by creating the port. The Erlang process that creates a port is said to be &lt;strong&gt;the connected process&lt;/strong&gt; of the port. All communication to and from the port must go through the connected process. If the connected process terminates, the port also terminates (and the external program, if it is written properly).</source>
          <target state="translated">必须通过创建端口来建立Erlang和C之间的所有通信。创建端口的Erlang进程被称为端口&lt;strong&gt;的连接进程&lt;/strong&gt;。与端口之间的所有通信都必须经过连接的过程。如果连接的进程终止，则端口也终止（如果正确编写，则终止外部程序）。</target>
        </trans-unit>
        <trans-unit id="eb709283e324b3781c25b7de16d1f666dbdb72e8" translate="yes" xml:space="preserve">
          <source>All configuration data must be included in configuration files that are located in the configuration directory. The name of this directory is given in the &lt;code&gt;config_dir&lt;/code&gt; configuration parameter. These files are read at start-up, and are used to initialize the SNMPv2-MIB or STANDARD-MIB, SNMP-FRAMEWORK-MIB, SNMP-MPD-MIB, SNMP-VIEW-BASED-ACM-MIB, SNMP-COMMUNITY-MIB, SNMP-USER-BASED-SM-MIB, SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB (refer to the &lt;code&gt;&lt;a href=&quot;snmp_agent_funct_descr#management&quot;&gt;Management of the Agent&lt;/a&gt;&lt;/code&gt; for a description of the MIBs).</source>
          <target state="translated">所有配置数据都必须包含在配置目录中的配置文件中。该目录的名称在 &lt;code&gt;config_dir&lt;/code&gt; 配置参数中给出。这些文件在启动时会读取，并用于初始化SNMPv2-MIB或STANDARD-MIB，SNMP-FRAMEWORK-MIB，SNMP-MPD-MIB，SNMP-VIEW-BASED-ACM-MIB，SNMP-COMMUNITY-MIB ，SNMP-USER-BASED-SM-MIB，SNMP-TARGET-MIB和SNMP-NOTIFICATION-MIB（有关MIB 的说明，请参阅 &lt;code&gt;&lt;a href=&quot;snmp_agent_funct_descr#management&quot;&gt;Management of the Agent&lt;/a&gt;&lt;/code&gt; 的管理）。</target>
        </trans-unit>
        <trans-unit id="8fb98e168e1cdf700c77f9c617ec623e357237e5" translate="yes" xml:space="preserve">
          <source>All configuration parameters can be set at start by adding &lt;code&gt;-OptName Value&lt;/code&gt; to the command line, for example:</source>
          <target state="translated">可以在开始时通过将 &lt;code&gt;-OptName Value&lt;/code&gt; 添加到命令行来设置所有配置参数，例如：</target>
        </trans-unit>
        <trans-unit id="e34d05132c3363672c983606c16c8b3f4cd48ded" translate="yes" xml:space="preserve">
          <source>All contained terms of a list/tuple/map must belong to the same environment as the list/tuple/map itself. Terms can be copied between environments with &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列表/元组/映射的所有包含术语必须与列表/元组/映射本身属于同一环境。可以使用 &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; 在环境之间复制条款。</target>
        </trans-unit>
        <trans-unit id="17c9652ae90aa032b597d6483480d6b35f039ee7" translate="yes" xml:space="preserve">
          <source>All created threads must be joined by the driver before it is unloaded. If the driver fails to join all threads created before it is unloaded, the runtime system most likely crashes when the driver code is unloaded.</source>
          <target state="translated">所有创建的线程必须在卸载前被驱动程序加入。如果驱动程序未能在卸载前加入所有创建的线程,那么当驱动程序代码被卸载时,运行时系统很可能会崩溃。</target>
        </trans-unit>
        <trans-unit id="b1b81e568bd7b5d5fd8f96a201883e60680fff00" translate="yes" xml:space="preserve">
          <source>All currently existing ports and all that will be created in the future.</source>
          <target state="translated">所有现有的端口和所有未来将创建的端口。</target>
        </trans-unit>
        <trans-unit id="bc6ddc7f5e7f3a0bc6a355b03f78b8fb8d4e520a" translate="yes" xml:space="preserve">
          <source>All currently existing ports.</source>
          <target state="translated">现有的所有港口。</target>
        </trans-unit>
        <trans-unit id="f5bd9e7d7b44e072c90e6f8dda758c22961a860e" translate="yes" xml:space="preserve">
          <source>All currently existing processes and all that will be created in the future.</source>
          <target state="translated">所有现有的流程和未来将创建的所有流程;</target>
        </trans-unit>
        <trans-unit id="2f2c9f694f2fd17dd3c35e9d0f951e41f0de39c2" translate="yes" xml:space="preserve">
          <source>All currently existing processes and ports and all that will be created in the future.</source>
          <target state="translated">所有现有的进程和端口以及未来将创建的所有进程和端口。</target>
        </trans-unit>
        <trans-unit id="a4a1660f0cdb5d321af926f22eca810cb75c7869" translate="yes" xml:space="preserve">
          <source>All currently existing processes and ports.</source>
          <target state="translated">所有现有的进程和端口。</target>
        </trans-unit>
        <trans-unit id="f2774916f15014b59bbde049da46ed37bb38a8f7" translate="yes" xml:space="preserve">
          <source>All currently existing processes.</source>
          <target state="translated">所有现有的进程。</target>
        </trans-unit>
        <trans-unit id="ff87064c3c8ceacf6dda1a78dcbdf032fd899aad" translate="yes" xml:space="preserve">
          <source>All data in messages between Erlang processes is copied, except for &lt;code&gt;&lt;a href=&quot;binaryhandling#refc_binary&quot;&gt;refc binaries&lt;/a&gt;&lt;/code&gt; on the same Erlang node.</source>
          <target state="translated">除了在同一Erlang节点上的 &lt;code&gt;&lt;a href=&quot;binaryhandling#refc_binary&quot;&gt;refc binaries&lt;/a&gt;&lt;/code&gt; 外，还将复制Erlang进程之间消息中的所有数据。</target>
        </trans-unit>
        <trans-unit id="aa1a7180beea8d2918397b581bb39b7c3d97266f" translate="yes" xml:space="preserve">
          <source>All dates conform to the Gregorian calendar. This calendar was introduced by Pope Gregory XIII in 1582 and was used in all Catholic countries from this year. Protestant parts of Germany and the Netherlands adopted it in 1698, England followed in 1752, and Russia in 1918 (the October revolution of 1917 took place in November according to the Gregorian calendar).</source>
          <target state="translated">所有日期都符合格里高利历。该历法由教皇格雷戈里十三世于1582年推出,并从这一年开始在所有天主教国家使用。1698年德国和荷兰的新教地区采用了这一历法,1752年英国也采用了这一历法,1918年俄罗斯采用了这一历法(1917年的十月革命按照格里高利历在11月进行)。</target>
        </trans-unit>
        <trans-unit id="5a9db788cb6f00701b230b3a0369568000727f48" translate="yes" xml:space="preserve">
          <source>All dictionaries should typically inherit RFC 6733 AVPs from &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt;.</source>
          <target state="translated">所有字典通常都应从 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; _gen_base_rfc6733继承RFC 6733 AVP 。</target>
        </trans-unit>
        <trans-unit id="4c2f43f5ea4d88b08d32795c7efcb41af6ca7e5e" translate="yes" xml:space="preserve">
          <source>All direct and indirect calls within the Kernel application. Both the calling and the used functions of indirect calls are defined in modules of the kernel application, but it is possible that some functions outside the kernel application are used by indirect calls.</source>
          <target state="translated">内核程序内的所有直接和间接调用。间接调用的调用和使用的函数都是在内核程序的模块中定义的,但内核程序之外的一些函数也有可能被间接调用使用。</target>
        </trans-unit>
        <trans-unit id="d1f33a648178dc389edc92503195d2baefeb6e84" translate="yes" xml:space="preserve">
          <source>All dirty functions execute a call to &lt;code&gt;exit({aborted, Reason})&lt;/code&gt; on failure. Even if the following functions are executed inside a transaction no locks are acquired. The following functions are available:</source>
          <target state="translated">所有 &lt;code&gt;exit({aborted, Reason})&lt;/code&gt; 函数都会在失败时执行对exit（{aborted，Reason}）的调用。即使在事务内执行以下功能，也不会获取任何锁。提供以下功能：</target>
        </trans-unit>
        <trans-unit id="f81b19ae425dcfaf7c61e80cc7669618b08d52e7" translate="yes" xml:space="preserve">
          <source>All elements must be bound. Or match a binary:</source>
          <target state="translated">所有元素都必须绑定。或者匹配一个二进制。</target>
        </trans-unit>
        <trans-unit id="e35304a8cee7dd66deca414eafb00819e73f44e7" translate="yes" xml:space="preserve">
          <source>All encode functions assume that the &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; parameters point to a buffer large enough for the data. To get the size of an encoded term, without encoding it, pass &lt;code&gt;NULL&lt;/code&gt; instead of a buffer pointer. Parameter &lt;code&gt;index&lt;/code&gt; is incremented, but nothing will be encoded. This is the way in &lt;code&gt;ei&lt;/code&gt; to &quot;preflight&quot; term encoding.</source>
          <target state="translated">所有编码函数均假定 &lt;code&gt;buf&lt;/code&gt; 和 &lt;code&gt;index&lt;/code&gt; 参数指向一个足以容纳数据的缓冲区。要获取编码项的大小而不进行编码，请传递 &lt;code&gt;NULL&lt;/code&gt; 而不是缓冲区指针。参数 &lt;code&gt;index&lt;/code&gt; 增加，但是不会被编码。这是 &lt;code&gt;ei&lt;/code&gt; 中&amp;ldquo;预检&amp;rdquo;术语编码的方式。</target>
        </trans-unit>
        <trans-unit id="151ad8ec849846d67f11a6c9c136c41384a8ac5e" translate="yes" xml:space="preserve">
          <source>All event handler modules must have &lt;code&gt;gen_event&lt;/code&gt; behavior. These modules must be precompiled and their locations must be added explicitly to the Erlang code server search path (as in the previous example).</source>
          <target state="translated">所有事件处理程序模块必须具有 &lt;code&gt;gen_event&lt;/code&gt; 行为。这些模块必须预先编译，并且必须将其位置显式添加到Erlang代码服务器搜索路径中（如上例所示）。</target>
        </trans-unit>
        <trans-unit id="9edf833c0b78d11f089bdd4ddb61ffd9bb5f9435" translate="yes" xml:space="preserve">
          <source>All event handlers added to the error logger must handle the following events. &lt;code&gt;Gleader&lt;/code&gt; is the group leader pid of the process that sent the event, and &lt;code&gt;Pid&lt;/code&gt; is the process that sent the event.</source>
          <target state="translated">添加到错误记录器的所有事件处理程序都必须处理以下事件。 &lt;code&gt;Gleader&lt;/code&gt; 是发送事件的进程的组长pid，而 &lt;code&gt;Pid&lt;/code&gt; 是发送事件的进程。</target>
        </trans-unit>
        <trans-unit id="97354d25fc5709fda87feb85d1e3e6ab6be22375" translate="yes" xml:space="preserve">
          <source>All events are filtered thru the collector filter, which optionally may transform or discard the event. The first call should use the pid of the collector process as report handle, while subsequent calls should use the table handle.</source>
          <target state="translated">所有事件都会通过收集器过滤器进行过滤,过滤器可以选择转换或丢弃事件。第一次调用应使用收集器进程的pid作为报告句柄,而后续调用应使用表句柄。</target>
        </trans-unit>
        <trans-unit id="edda3d39980ef94b93836b935091c5b117c59583" translate="yes" xml:space="preserve">
          <source>All events stored with &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; are inserted to be processed before previously queued events.</source>
          <target state="translated">插入所有使用 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 存储的事件，以便在先前排队的事件之前对其进行处理。</target>
        </trans-unit>
        <trans-unit id="3491bb0a7d4060188eb065fbc6bc2594ddbd17ff" translate="yes" xml:space="preserve">
          <source>All existing ports are traced.</source>
          <target state="translated">所有现有的端口都会被追踪。</target>
        </trans-unit>
        <trans-unit id="2c72dcc5bba29ea41d56cc0f3108b0b76f9c39f4" translate="yes" xml:space="preserve">
          <source>All existing processes and ports are traced.</source>
          <target state="translated">追踪所有现有的进程和端口。</target>
        </trans-unit>
        <trans-unit id="5a4d069c79f3590b37639cb25e98cd7c35810632" translate="yes" xml:space="preserve">
          <source>All existing processes are traced.</source>
          <target state="translated">所有现有的流程都会被追踪。</target>
        </trans-unit>
        <trans-unit id="5747d94a7ab87afa870a4b1a23637cb5fdeb263d" translate="yes" xml:space="preserve">
          <source>All exported functions &lt;code&gt;f/0&lt;/code&gt;, &lt;code&gt;f/1&lt;/code&gt; and so on are deprecated.</source>
          <target state="translated">不推荐使用所有导出的函数 &lt;code&gt;f/0&lt;/code&gt; ， &lt;code&gt;f/1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="ebe25266a3aaabe1092ea2284360d4d7880f5b5d" translate="yes" xml:space="preserve">
          <source>All exported functions in the module are deprecated and will eventually be removed.</source>
          <target state="translated">该模块中的所有导出函数都已废弃,并最终将被删除。</target>
        </trans-unit>
        <trans-unit id="7d0101bf6297ebfbf7dbf99d16c4071d8e1de6f5" translate="yes" xml:space="preserve">
          <source>All exported functions in the module are deprecated. Equivalent to &lt;code&gt;-deprecated({'_','_'}).&lt;/code&gt;.</source>
          <target state="translated">该模块中所有导出的功能均已弃用。等效于 &lt;code&gt;-deprecated({'_','_'}).&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a830cb4b996f3591a6f1ba33560d9c6eba657de5" translate="yes" xml:space="preserve">
          <source>All exported functions of the &lt;code&gt;digraph&lt;/code&gt; module used (in)directly by some function in &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;digraph&lt;/code&gt; 模块的所有导出函数都由有 &lt;code&gt;digraph&lt;/code&gt; 的某些函数直接使用。</target>
        </trans-unit>
        <trans-unit id="a0ffdac5fcbe59b543d6b023f7bcb7ab4d567156" translate="yes" xml:space="preserve">
          <source>All exported functions of the &lt;code&gt;xref&lt;/code&gt; module. The first operand of the intersection operator &lt;code&gt;*&lt;/code&gt; is implicitly converted to the more special type of the second operand.</source>
          <target state="translated">&lt;code&gt;xref&lt;/code&gt; 模块的所有导出功能。相交运算符 &lt;code&gt;*&lt;/code&gt; 的第一个操作数被隐式转换为第二个操作数的更特殊类型。</target>
        </trans-unit>
        <trans-unit id="942827b9949c1750c953f7ebc266219ebc7cdd42" translate="yes" xml:space="preserve">
          <source>All external calls to local functions.</source>
          <target state="translated">所有对本地函数的外部调用。</target>
        </trans-unit>
        <trans-unit id="ce56e411c31ac7116e9fd3632deb508253a985ba" translate="yes" xml:space="preserve">
          <source>All files are compressed (as long as they pass the &lt;code&gt;uncompress&lt;/code&gt; condition).</source>
          <target state="translated">所有文件都被压缩（只要它们通过 &lt;code&gt;uncompress&lt;/code&gt; 条件即可）。</target>
        </trans-unit>
        <trans-unit id="0489e9084611f97b451f50f894c7a01abd2cecc5" translate="yes" xml:space="preserve">
          <source>All files are searched for in the current path. It is assumed that the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.beam&lt;/code&gt; files for an application are located in the same directory. The &lt;code&gt;.erl&lt;/code&gt; files are also assumed to be located in this directory, unless it is an &lt;code&gt;ebin&lt;/code&gt; directory in which case they can be located in the corresponding &lt;code&gt;src&lt;/code&gt; directory.</source>
          <target state="translated">在当前路径中搜索所有文件。假定 &lt;code&gt;.app&lt;/code&gt; 和 &lt;code&gt;.beam&lt;/code&gt; 文件位于同一目录中。该 &lt;code&gt;.erl&lt;/code&gt; 也假定文件位于此目录中，除非它是一个 &lt;code&gt;ebin&lt;/code&gt; 目录在这种情况下，他们可以位于相应 &lt;code&gt;src&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="8252fbc317a2198d72c5445b998e2855db44bf75" translate="yes" xml:space="preserve">
          <source>All filters (registered in a &lt;code&gt;Collector&lt;/code&gt; or in a &lt;code&gt;Viewer&lt;/code&gt;) must be able to handle an &lt;code&gt;Event record&lt;/code&gt; as input. The &lt;code&gt;Collector Filter&lt;/code&gt; (that is the filter named &lt;code&gt;all&lt;/code&gt;) is a little bit special, as its input also may be raw &lt;code&gt;Erlang Trace Data&lt;/code&gt;</source>
          <target state="translated">所有过滤器（在 &lt;code&gt;Collector&lt;/code&gt; 或 &lt;code&gt;Viewer&lt;/code&gt; ）都必须能够处理 &lt;code&gt;Event record&lt;/code&gt; 作为输入。在 &lt;code&gt;Collector Filter&lt;/code&gt; （即指定的过滤器 &lt;code&gt;all&lt;/code&gt; ）是一个有点特殊，因为它的输入也可能是原 &lt;code&gt;Erlang Trace Data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="422be21988c49192a9f5f28262b52e1e51a8fd90" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; and &lt;code&gt;xref_base&lt;/code&gt; to &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;xref&lt;/code&gt; 和 &lt;code&gt;xref_base&lt;/code&gt; 到 &lt;code&gt;lists&lt;/code&gt; 和 &lt;code&gt;digraph&lt;/code&gt; 的所有函数调用。</target>
        </trans-unit>
        <trans-unit id="9db576c6625a484a5d2e923a006859fafb0310a1" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; to &lt;code&gt;lists&lt;/code&gt;, and all function calls from &lt;code&gt;xref_base&lt;/code&gt; to &lt;code&gt;digraph&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;xref&lt;/code&gt; 到 &lt;code&gt;lists&lt;/code&gt; 所有函数调用，从 &lt;code&gt;xref_base&lt;/code&gt; 到 &lt;code&gt;digraph&lt;/code&gt; 的所有函数调用。</target>
        </trans-unit>
        <trans-unit id="d129df75799c1b4bd0113f7d6ec3fb57b5027d20" translate="yes" xml:space="preserve">
          <source>All function calls from &lt;code&gt;xref&lt;/code&gt; to &lt;code&gt;xref_base&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;xref&lt;/code&gt; 到 &lt;code&gt;xref_base&lt;/code&gt; 的所有函数调用。</target>
        </trans-unit>
        <trans-unit id="7ca2ffb4856752604dde896ca6470b50c7619bd8" translate="yes" xml:space="preserve">
          <source>All functions can have an optional argument, which specifies a hook that is called if an attempt is made to print an unknown form.</source>
          <target state="translated">所有函数都可以有一个可选参数,它指定了一个钩子,当有人试图打印未知表格时,该钩子会被调用。</target>
        </trans-unit>
        <trans-unit id="823a79f73d165ac889d6bd172b59abd37f41a632" translate="yes" xml:space="preserve">
          <source>All functions exported from this module can be used as primary or handler filters. See &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; for more information about how filters are added.</source>
          <target state="translated">从该模块导出的所有功能都可以用作主过滤器或处理程序过滤器。有关如何添加过滤器的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec741d9917990170ff113c4353ac60a9452852b7" translate="yes" xml:space="preserve">
          <source>All functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if arguments are of wrong type, for example, queue arguments are not queues, indexes are not integers, and list arguments are not lists. Improper lists cause internal crashes. An index out of range for a queue also causes a failure with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果参数的类型错误，则所有函数都会失败，原因为 &lt;code&gt;badarg&lt;/code&gt; ，例如，队列参数不是队列，索引不是整数，列表参数不是列表。列表不正确会导致内部崩溃。队列的索引超出范围也会导致失败，原因是 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e43fac8a393e657d49457e2719a0083470b80dc0" translate="yes" xml:space="preserve">
          <source>All functions in all loaded modules.</source>
          <target state="translated">所有加载模块中的所有功能。</target>
        </trans-unit>
        <trans-unit id="ef103221583f1169bd63b6128675c2644466fb99" translate="yes" xml:space="preserve">
          <source>All functions in module &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">模块 &lt;code&gt;Module&lt;/code&gt; 中的所有功能。</target>
        </trans-unit>
        <trans-unit id="2466011b635e6de04d4ec84d7f837c33d888a271" translate="yes" xml:space="preserve">
          <source>All functions in module &lt;code&gt;seq_trace&lt;/code&gt;, except &lt;code&gt;set_system_tracer/1&lt;/code&gt;, can be used after the trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">在模块的所有功能。 &lt;code&gt;seq_trace&lt;/code&gt; ，除了 &lt;code&gt;set_system_tracer/1&lt;/code&gt; 时，跟踪端口开始使用后可用于 &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43c6b1b0a958a8deaa986884119e0ee53ee936a8" translate="yes" xml:space="preserve">
          <source>All functions in the driver takes a handle (returned from &lt;code&gt;start&lt;/code&gt;) that is just passed along by the Erlang process. This must in some way refer to the port driver instance.</source>
          <target state="translated">驱动程序中的所有函数都带有一个由Erlang进程传递的句柄（从 &lt;code&gt;start&lt;/code&gt; 返回）。这必须以某种方式引用端口驱动程序实例。</target>
        </trans-unit>
        <trans-unit id="f6a9297c81dbe83f85ddbef20dc3f747dd1bff17" translate="yes" xml:space="preserve">
          <source>All functions in this Reference Manual can be used in any combination with queries using the list comprehension notation. For information about the query notation, see the &lt;code&gt;qlc&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">可以将本参考手册中的所有功能与使用列表理解符号的查询结合使用。有关查询表示法的信息，请参见STDLIB中的 &lt;code&gt;qlc&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="83563c273b58224103fb5b60259d697709cba0bd" translate="yes" xml:space="preserve">
          <source>All functions in this behavior must be implemented as NIFs. This limitation can be removed in a future releases. An &lt;code&gt;&lt;a href=&quot;#example&quot;&gt;example tracer module NIF&lt;/a&gt;&lt;/code&gt; implementation is provided at the end of this page.</source>
          <target state="translated">此行为中的所有功能都必须实现为NIF。此限制可以在将来的版本中删除。一个 &lt;code&gt;&lt;a href=&quot;#example&quot;&gt;example tracer module NIF&lt;/a&gt;&lt;/code&gt; 实现在该页面的末尾提供。</target>
        </trans-unit>
        <trans-unit id="5ba27ab55837d04a290469850ad1f69dc5566c5f" translate="yes" xml:space="preserve">
          <source>All functions in this module have an optional parameter &lt;code&gt;IoDevice&lt;/code&gt;. If included, it must be the pid of a process that handles the I/O protocols. Normally, it is the &lt;code&gt;IoDevice&lt;/code&gt; returned by &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">该模块中的所有功能都有一个可选参数 &lt;code&gt;IoDevice&lt;/code&gt; 。如果包含的话，它必须是处理I / O协议的进程的pid。通常，它是 &lt;code&gt;file:open/2&lt;/code&gt; 返回的 &lt;code&gt;IoDevice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="726200fe284b64e025780d2f8b454ec9973f6634" translate="yes" xml:space="preserve">
          <source>All functions of any arity named &lt;code&gt;Function&lt;/code&gt; in module &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">任何在模块 &lt;code&gt;Module&lt;/code&gt; 中名为 &lt;code&gt;Function&lt;/code&gt; 的函数的所有函数。</target>
        </trans-unit>
        <trans-unit id="f45f048113d0373b3ce22b0d7dd55cfb45f73d15" translate="yes" xml:space="preserve">
          <source>All functions of the &lt;code&gt;xref&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;xref&lt;/code&gt; 模块的所有功能。</target>
        </trans-unit>
        <trans-unit id="eba6863daa045e951bded6ccc11181d5402b27a1" translate="yes" xml:space="preserve">
          <source>All functions return &lt;code&gt;0&lt;/code&gt; if successful, otherwise &lt;code&gt;-1&lt;/code&gt; (for example, if a term is not of the expected type, or the data to decode is an invalid Erlang term).</source>
          <target state="translated">如果成功，所有函数将返回 &lt;code&gt;0&lt;/code&gt; ，否则返回 &lt;code&gt;-1&lt;/code&gt; （例如，如果术语不是预期的类型，或者要解码的数据是无效的Erlang术语）。</target>
        </trans-unit>
        <trans-unit id="f5bc6aaf22245be7eb164a817018deef6e568078" translate="yes" xml:space="preserve">
          <source>All functions take two parameters:</source>
          <target state="translated">所有函数都需要两个参数。</target>
        </trans-unit>
        <trans-unit id="956ed5e678dd45f2252e7ddbe4d7c18199877e4b" translate="yes" xml:space="preserve">
          <source>All functions that a driver needs to do with Erlang are performed through driver API functions. Functions exist for the following functionality:</source>
          <target state="translated">驱动程序在使用Erlang时需要做的所有功能都是通过驱动程序API函数来实现的。这些函数存在于以下功能中。</target>
        </trans-unit>
        <trans-unit id="060ec634508a875eb366a978194bdb8554c750a9" translate="yes" xml:space="preserve">
          <source>All functions with a &lt;code&gt;FuncCallCount&lt;/code&gt; lower than &lt;code&gt;Limit&lt;/code&gt; are excluded from &lt;code&gt;FuncAnalysisList&lt;/code&gt;. They are still included in &lt;code&gt;ModCallCount&lt;/code&gt;, though. The default value for &lt;code&gt;Limit&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FuncCallCount&lt;/code&gt; 小于 &lt;code&gt;Limit&lt;/code&gt; 的所有函数都将从 &lt;code&gt;FuncAnalysisList&lt;/code&gt; 中排除。不过，它们仍包含在 &lt;code&gt;ModCallCount&lt;/code&gt; 中。为默认值 &lt;code&gt;Limit&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="046534351d00f7cf7cc373a50278b04994192a3a" translate="yes" xml:space="preserve">
          <source>All initialization, including name registration, is done in &lt;code&gt;init&lt;/code&gt;. The new process must also acknowledge that it has been started to the parent:</source>
          <target state="translated">所有初始化（包括名称注册）均在 &lt;code&gt;init&lt;/code&gt; 中完成。新进程还必须向父进程确认已启动：</target>
        </trans-unit>
        <trans-unit id="46cda0f29f9968b1b8eac1178e9399bb98ac0756" translate="yes" xml:space="preserve">
          <source>All interaction between NIF code and the Erlang runtime system is performed by calling NIF API functions. Functions exist for the following functionality:</source>
          <target state="translated">NIF代码和Erlang运行时系统之间的所有交互都是通过调用NIF API函数来实现的。有以下功能的函数。</target>
        </trans-unit>
        <trans-unit id="b8bf9347aac7d69c1a7c4192dd20e3c477cd2eef" translate="yes" xml:space="preserve">
          <source>All involved nodes must agree on the global group definition, otherwise the behavior of the system is undefined.</source>
          <target state="translated">所有参与的节点必须在全局组定义上达成一致,否则系统的行为将无法定义。</target>
        </trans-unit>
        <trans-unit id="2ddeb2fa9e303d6ec0189514f0afae8c313983ca" translate="yes" xml:space="preserve">
          <source>All involved nodes must have the same value for &lt;code&gt;distributed&lt;/code&gt; and &lt;code&gt;sync_nodes_timeout&lt;/code&gt;. Otherwise the system behaviour is undefined.</source>
          <target state="translated">所有涉及的节点必须对 &lt;code&gt;distributed&lt;/code&gt; 和 &lt;code&gt;sync_nodes_timeout&lt;/code&gt; 具有相同的值。否则，系统行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="cc6547cbb70d26e829dedc7fc557e10f893223e6" translate="yes" xml:space="preserve">
          <source>All items in &lt;code&gt;Options&lt;/code&gt; that are not make options are assumed to be compiler options and are passed as-is to &lt;code&gt;compile:file/2&lt;/code&gt;. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; 中不是make选项的所有项均假定为编译器选项，并按原样传递给 &lt;code&gt;compile:file/2&lt;/code&gt; 。 &lt;code&gt;Options&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a74854341f74c068c82ad0a8f0663aa4e14988f" translate="yes" xml:space="preserve">
          <source>All jobs that do not use standard I/O run in the normal way.</source>
          <target state="translated">所有不使用标准I/O的作业都以正常方式运行。</target>
        </trans-unit>
        <trans-unit id="1865391b0c3e8e089483ce4975e720c45e5a9c41" translate="yes" xml:space="preserve">
          <source>All keys and values in the map are terms. Any expression is first evaluated and then the resulting terms are used as &lt;strong&gt;key&lt;/strong&gt; and &lt;strong&gt;value&lt;/strong&gt; respectively.</source>
          <target state="translated">地图中的所有键和值都是术语。首先对任何表达式求值，然后将所得的项分别用作&lt;strong&gt;键&lt;/strong&gt;和&lt;strong&gt;值&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b9288c9e5c221796e80a2e7498e046ec5f58a8b5" translate="yes" xml:space="preserve">
          <source>All keys and values must belong to &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">所有键和值都必须属于 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aae0ef6a36eb4138caa9b3ee5995eea319883b4" translate="yes" xml:space="preserve">
          <source>All list expressions are evaluated. If a cursor has been created, evaluation takes place in the cursor process. For list expressions that are QLCs, the list expressions of the generators of the QLCs are evaluated as well. Be careful if list expressions have side effects, as list expressions are evaluated in unspecified order.</source>
          <target state="translated">所有的列表表达式都会被评估。如果已经创建了游标,那么评估将在游标过程中进行。对于作为QLC的列表表达式,QLC生成器的列表表达式也会被评估。如果列表表达式有副作用,请注意,因为列表表达式的评价顺序没有规定。</target>
        </trans-unit>
        <trans-unit id="ea62e05bff6ced6fe4f7db7a70fe5d182215dc60" translate="yes" xml:space="preserve">
          <source>All lists of identifiers must produce the same number of identifiers.</source>
          <target state="translated">所有的识别器列表必须产生相同数量的识别器。</target>
        </trans-unit>
        <trans-unit id="831a903ff3acb3a95d91bc2244d77f78dbc1b105" translate="yes" xml:space="preserve">
          <source>All locks are continuously monitored and its statistics updated. Use &lt;code&gt;lcnt:clear/0&lt;/code&gt; to initially clear all counters before running any specific tests. This command will also reset the duration timer internally.</source>
          <target state="translated">持续监视所有锁并更新其统计信息。在运行任何特定测试之前，请使用 &lt;code&gt;lcnt:clear/0&lt;/code&gt; 初始清除所有计数器。此命令还将在内部重置持续时间计时器。</target>
        </trans-unit>
        <trans-unit id="9cd647737f1c87ee7c161c5ee26fe910048843cf" translate="yes" xml:space="preserve">
          <source>All logical drives of type &quot;FIXED_DISK&quot; are checked.</source>
          <target state="translated">检查所有类型为 &quot;FIXED_DISK &quot;的逻辑驱动器。</target>
        </trans-unit>
        <trans-unit id="d4db0be4b4b4c802ce985caea6e5dff7b25d978f" translate="yes" xml:space="preserve">
          <source>All macro names generated by the compiler are prefixed with &lt;code&gt;Prefix&lt;/code&gt;. This is useful when multiple protocols that contain macros with identical names are included in a single module.</source>
          <target state="translated">编译器生成的所有宏名称都以 &lt;code&gt;Prefix&lt;/code&gt; 为前缀。当单个模块中包含多个包含具有相同名称的宏的协议时，这很有用。</target>
        </trans-unit>
        <trans-unit id="494705700ec0edc0b3e9bd3d1008f1481b1665ee" translate="yes" xml:space="preserve">
          <source>All macros expand to a call to Logger, where &lt;code&gt;Level&lt;/code&gt; is taken from the macro name, and location data is added to the metadata. See the description of the &lt;code&gt;&lt;a href=&quot;#type-metadata&quot;&gt;metadata()&lt;/a&gt;&lt;/code&gt; type for more information about the location data.</source>
          <target state="translated">所有宏都扩展为对Logger的调用，其中从宏名称获取 &lt;code&gt;Level&lt;/code&gt; ，并将位置数据添加到元数据。有关位置数据的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-metadata&quot;&gt;metadata()&lt;/a&gt;&lt;/code&gt; 类型的描述。</target>
        </trans-unit>
        <trans-unit id="d0c8d5eebae1c81c9d4cc44fa89d86c186216006" translate="yes" xml:space="preserve">
          <source>All memory sizes are presented as number of &lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">所有内存大小均以&lt;strong&gt;字节&lt;/strong&gt;数&lt;strong&gt;表示&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c95b69f492d38b3c97ab065a21ebadda9800ddeb" translate="yes" xml:space="preserve">
          <source>All messages in the message queue will eventually be placed on heap. They can however temporarily be stored off heap. This is how messages always have been stored up until ERTS 8.0.</source>
          <target state="translated">消息队列中的所有消息最终都会被放在堆上。然而,它们可以暂时不在堆上存储,这是在 ERTS 8.0 之前,消息队列中所有消息的存储方式。这也是ERTS 8.0之前消息的存储方式。</target>
        </trans-unit>
        <trans-unit id="f77aafd15225e94bc1f5d8df9caf3f4c48675dfa" translate="yes" xml:space="preserve">
          <source>All messages sent over the transport interface are of the form &lt;code&gt;{diameter, term()}&lt;/code&gt;.</source>
          <target state="translated">通过传输接口发送的所有消息的格式为 &lt;code&gt;{diameter, term()}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9fadb6f85546bb42570866cced284af7083a859" translate="yes" xml:space="preserve">
          <source>All modules introduced by this application. &lt;code&gt;systools&lt;/code&gt; uses this list when generating start scripts and tar files. A module can only be defined in one application.</source>
          <target state="translated">此应用程序介绍的所有模块。生成启动脚本和tar文件时， &lt;code&gt;systools&lt;/code&gt; 使用此列表。一个模块只能在一个应用程序中定义。</target>
        </trans-unit>
        <trans-unit id="b81023ab4e25ef6717f23395a1aedb12fb5ddbc7" translate="yes" xml:space="preserve">
          <source>All modules of the Tools application.</source>
          <target state="translated">工具应用程序的所有模块。</target>
        </trans-unit>
        <trans-unit id="429cfbd4010cf55e09670589087f82f8687b863b" translate="yes" xml:space="preserve">
          <source>All modules with a name beginning with &lt;code&gt;xref_&lt;/code&gt;.</source>
          <target state="translated">名称以 &lt;code&gt;xref_&lt;/code&gt; 开头的所有模块。</target>
        </trans-unit>
        <trans-unit id="d8fe3d0304a41f7579b1ba411ab3df7b0920caa7" translate="yes" xml:space="preserve">
          <source>All names of registered processes started in this application. &lt;code&gt;systools&lt;/code&gt; uses this list to detect name clashes between different applications.</source>
          <target state="translated">已注册进程的所有名称均在此应用程序中启动。 &lt;code&gt;systools&lt;/code&gt; 使用此列表来检测不同应用程序之间的名称冲突。</target>
        </trans-unit>
        <trans-unit id="63603405883458e08fdb5a997ded4a3cb73fef22" translate="yes" xml:space="preserve">
          <source>All nitty gritty details of the event.</source>
          <target state="translated">活动的所有琐碎细节。</target>
        </trans-unit>
        <trans-unit id="8955d624f919ff35c5d686d0dd52b90c5392d816" translate="yes" xml:space="preserve">
          <source>All nodes added with &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; will be affected by this call, and if Module is not &lt;code&gt;'_'&lt;/code&gt; the module will be loaded on all nodes.</source>
          <target state="translated">所有添加了 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 的节点都将受到此调用的影响，如果Module不是 &lt;code&gt;'_'&lt;/code&gt; ,则该模块将被加载到所有节点上。</target>
        </trans-unit>
        <trans-unit id="c596dc51ad6ac7a667444d4ab6da510586b442cc" translate="yes" xml:space="preserve">
          <source>All nodes added with &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; will be affected by this call.</source>
          <target state="translated">此调用将影响添加了 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 的所有节点。</target>
        </trans-unit>
        <trans-unit id="d9448e54ad1639a4fc81a3d2181edf3fa2a36dab" translate="yes" xml:space="preserve">
          <source>All nodes connected to this node.</source>
          <target state="translated">与此节点相连的所有节点。</target>
        </trans-unit>
        <trans-unit id="c16d866482510d3df4a4d9c10e80cfd8693ce976" translate="yes" xml:space="preserve">
          <source>All of these MIBs should be loaded into the Master Agent. Once loaded, these MIBs are always available in all contexts.</source>
          <target state="translated">所有这些MIB都应该被加载到主代理中。一旦加载,这些MIBs在所有的上下文中都是可用的。</target>
        </trans-unit>
        <trans-unit id="5404924b8d62bd94a8e2b48b441dd9ef3bb2c473" translate="yes" xml:space="preserve">
          <source>All of these can be used in guards. Now for some BIFs that cannot be used in guards:</source>
          <target state="translated">这些都可以用在防护罩上。现在说说一些不能用于守卫的BIF。</target>
        </trans-unit>
        <trans-unit id="50f0e79a9827c7185eb8a799e8536a39c5dbce1a" translate="yes" xml:space="preserve">
          <source>All open tables must be closed before the system is stopped. If an attempt is made to open a table that is not properly closed, Dets automatically tries to repair it.</source>
          <target state="translated">在系统停止之前,必须关闭所有打开的表格。如果试图打开一个没有正确关闭的表,Dets会自动尝试修复它。</target>
        </trans-unit>
        <trans-unit id="9366c0e819489e6627469b740a2d8b3479faca40" translate="yes" xml:space="preserve">
          <source>All operations has an amortized O(1) running time, except &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;filter/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#len-1&quot;&gt;len/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#member-2&quot;&gt;member/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-2&quot;&gt;split/2&lt;/a&gt;&lt;/code&gt; that have O(n). To minimize the size of a queue minimizing the amount of garbage built by queue operations, the queues do not contain explicit length information, and that is why &lt;code&gt;len/1&lt;/code&gt; is O(n). If better performance for this particular operation is essential, it is easy for the caller to keep track of the length.</source>
          <target state="translated">除具有O（n）的 &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;filter/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#len-1&quot;&gt;len/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#member-2&quot;&gt;member/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#split-2&quot;&gt;split/2&lt;/a&gt;&lt;/code&gt; 之外，所有操作的摊销O（1）运行时间。为了最小化队列的大小，最大程度地减少由队列操作建立的垃圾数量，队列不包含显式的长度信息，这就是 &lt;code&gt;len/1&lt;/code&gt; 为O（n）的原因。如果此特定操作的更好性能是必不可少的，则呼叫者很容易跟踪长度。</target>
        </trans-unit>
        <trans-unit id="4bb3faf2c2244b5d385e1264229f20eef126b3f8" translate="yes" xml:space="preserve">
          <source>All operations on applications are coordinated by the application controller. It is interacted through the functions in the module &lt;code&gt;application&lt;/code&gt;, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel. In particular, applications can be loaded, unloaded, started, and stopped.</source>
          <target state="translated">应用程序上的所有操作均由应用程序控制器协调。它通过模块 &lt;code&gt;application&lt;/code&gt; 的功能进行交互，请参见内核中的 &lt;code&gt;application(3)&lt;/code&gt; 手册页。特别是，可以加载，卸载，启动和停止应用程序。</target>
        </trans-unit>
        <trans-unit id="9a155092927253ab8adb73277ff15a9389de0ffb" translate="yes" xml:space="preserve">
          <source>All operations that can be performed on &lt;code&gt;dets&lt;/code&gt; files can also be performed on the &lt;code&gt;Mnesia&lt;/code&gt; data files. For example, &lt;code&gt;dets&lt;/code&gt; contains the function &lt;code&gt;dets:traverse/2&lt;/code&gt;, which can be used to view the contents of a &lt;code&gt;Mnesia&lt;/code&gt;&lt;code&gt;DAT&lt;/code&gt; file. However, this can only be done when &lt;code&gt;Mnesia&lt;/code&gt; is not running. So, to view the schema file, do as follows;</source>
          <target state="translated">可以对 &lt;code&gt;dets&lt;/code&gt; 文件执行的所有操作也可以在 &lt;code&gt;Mnesia&lt;/code&gt; 数据文件上执行。例如， &lt;code&gt;dets&lt;/code&gt; 包含函数 &lt;code&gt;dets:traverse/2&lt;/code&gt; ，该函数可用于查看 &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;DAT&lt;/code&gt; 文件的内容。但是，只有在 &lt;code&gt;Mnesia&lt;/code&gt; 未运行时才能执行此操作。因此，要查看模式文件，请执行以下操作；</target>
        </trans-unit>
        <trans-unit id="7944ca23e769d63791bf6d56110b8504cc650e69" translate="yes" xml:space="preserve">
          <source>All options &lt;code&gt;Opt&lt;/code&gt; are set on the socket before the association is attempted. If an option record has undefined field values, the options record is first read from the socket for those values. In effect, &lt;code&gt;Opt&lt;/code&gt; option records only define field values to change before connecting.</source>
          <target state="translated">尝试关联之前，所有选项 &lt;code&gt;Opt&lt;/code&gt; 都已在套接字上设置。如果选项记录具有未定义的字段值，则首先从套接字读取这些值的选项记录。实际上，&amp;ldquo; &lt;code&gt;Opt&lt;/code&gt; 选项记录仅定义要在连接之前更改的字段值。</target>
        </trans-unit>
        <trans-unit id="717f82077e05a6bd5c4e1f6ec9f053ccca43eecd" translate="yes" xml:space="preserve">
          <source>All options has default values.</source>
          <target state="translated">所有选项都有默认值。</target>
        </trans-unit>
        <trans-unit id="df6d621c39e158f12320b634e0dfbb13f7f0a03f" translate="yes" xml:space="preserve">
          <source>All options, except the include path (&lt;code&gt;{i,Dir}&lt;/code&gt;), can also be given in the file with attribute &lt;code&gt;-compile([Option,...])&lt;/code&gt;. Attribute &lt;code&gt;-compile()&lt;/code&gt; is allowed after the function definitions.</source>
          <target state="translated">除包含路径（ &lt;code&gt;{i,Dir}&lt;/code&gt; ）外的所有选项，也都可以在文件中使用 &lt;code&gt;-compile([Option,...])&lt;/code&gt; 属性给出。函数定义之后允许使用 &lt;code&gt;-compile()&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="3262efdb0e0795ddd30e0491c99cd9db2b1217ce" translate="yes" xml:space="preserve">
          <source>All other error codes are to be translated by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. Notice that calls to &lt;code&gt;format_error&lt;/code&gt; are to be performed from the same running instance of the Erlang virtual machine as the error is detected in, because of system-dependent behavior concerning error values.</source>
          <target state="translated">所有其他错误代码都将通过 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 函数进行转换。请注意，由于与系统有关的错误值相关行为，因此将在检测到错误的Erlang虚拟机的同一运行实例中对 &lt;code&gt;format_error&lt;/code&gt; 进行调用。</target>
        </trans-unit>
        <trans-unit id="5f6a14eeedaaeb7e6254232d3638d6dc2f6e8555" translate="yes" xml:space="preserve">
          <source>All other funs are called &lt;strong&gt;local&lt;/strong&gt;. When a local fun is called, the same version of the code that created the fun is called (even if a newer version of the module has been loaded).</source>
          <target state="translated">所有其他乐趣称为&lt;strong&gt;本地&lt;/strong&gt;乐趣。调用本地功能时，将调用创建该功能的相同版本的代码（即使已加载了较新版本的模块）。</target>
        </trans-unit>
        <trans-unit id="8838f7dce02b840a82ef3664122b2c9a0564b86c" translate="yes" xml:space="preserve">
          <source>All other options are directly passed to &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; or ignored if a connection is already provided.</source>
          <target state="translated">所有其他选项都直接传递到 &lt;code&gt;&lt;a href=&quot;ssh&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; ，如果已经提供了连接，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="0fdd5012a3999f248928e35df9097ed59369e26c" translate="yes" xml:space="preserve">
          <source>All other tables that refer to this table in their foreign key</source>
          <target state="translated">所有在外键中引用本表的其他表格。</target>
        </trans-unit>
        <trans-unit id="7bef1fa75d2399a77a342855446a7b8e1b60ed9b" translate="yes" xml:space="preserve">
          <source>All paragraphs up to the next process header only concerns function calls within this process.</source>
          <target state="translated">到下一个过程标题的所有段落只涉及该过程中的函数调用。</target>
        </trans-unit>
        <trans-unit id="a921a840e963ba360d450906acb47195c661a0fd" translate="yes" xml:space="preserve">
          <source>All parts returned as binaries.</source>
          <target state="translated">所有部件均以二进制形式返回。</target>
        </trans-unit>
        <trans-unit id="21e943024f0cf28dbeb8a994a76fa77df65f90d8" translate="yes" xml:space="preserve">
          <source>All parts returned as lists of characters (&quot;strings&quot;).</source>
          <target state="translated">所有部件均以字符列表(&quot;字符串&quot;)的形式返回。</target>
        </trans-unit>
        <trans-unit id="eacdc8b4f05f878b8de176b164d8e1333a39ed8a" translate="yes" xml:space="preserve">
          <source>All patterns must be matched in a sequence. A match is not concluded until all patterns are matched. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="translated">所有模式必须按顺序匹配。在所有模式都匹配之前，不会结束匹配。一个或多个 &lt;code&gt;HaltPatterns&lt;/code&gt; 可以中断此选项。总是返回 &lt;code&gt;MatchList&lt;/code&gt; ，即 &lt;code&gt;Match&lt;/code&gt; 的列表，而不是一个 &lt;code&gt;Match&lt;/code&gt; 。还返回 &lt;code&gt;HaltReason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe1686901bbde4606445ec2f94e1d9d4f885ae9d" translate="yes" xml:space="preserve">
          <source>All ports created after the call is are to be traced.</source>
          <target state="translated">呼叫后创建的所有端口都要被追踪。</target>
        </trans-unit>
        <trans-unit id="f925b88f64b63747ed903430e90112298afb46f9" translate="yes" xml:space="preserve">
          <source>All ports in the system as well as all ports created hereafter are to be traced.</source>
          <target state="translated">系统中的所有端口以及以后创建的所有端口都要进行追踪。</target>
        </trans-unit>
        <trans-unit id="17489271f7d94016b64b27eb715c1631842f0ea9" translate="yes" xml:space="preserve">
          <source>All ports that will be created in the future.</source>
          <target state="translated">未来将建立的所有端口。</target>
        </trans-unit>
        <trans-unit id="76ff66e92ea2da8c3fa29ddd1a6eef5dcf62d533" translate="yes" xml:space="preserve">
          <source>All pre hooks, except &lt;code&gt;pre_end_per_testcase/4&lt;/code&gt;, can skip or fail the test by returning a tuple with &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;fail&lt;/code&gt;, and a reason as the result.</source>
          <target state="translated">除了 &lt;code&gt;pre_end_per_testcase/4&lt;/code&gt; 以外，所有其他预钩子都可以通过返回带有 &lt;code&gt;skip&lt;/code&gt; 或 &lt;code&gt;fail&lt;/code&gt; 以及结果的原因的元组来跳过或失败测试。</target>
        </trans-unit>
        <trans-unit id="c675952980c889f0d89ff8e73fd8703b823a9ed6" translate="yes" xml:space="preserve">
          <source>All printable Unicode characters are considered when determining if a list of integers is to be displayed in string syntax. This can give unexpected results if, for example, your font does not cover all Unicode characters.</source>
          <target state="translated">在决定是否以字符串语法显示整数列表时,会考虑所有可打印的Unicode字符。例如,如果您的字体没有涵盖所有Unicode字符,这可能会产生意想不到的结果。</target>
        </trans-unit>
        <trans-unit id="3b7ed40b3a03fdb7bdd0b017e905acbe12c81905" translate="yes" xml:space="preserve">
          <source>All processes and ports created after the call is are to be traced.</source>
          <target state="translated">呼叫后创建的所有进程和端口都要被追踪。</target>
        </trans-unit>
        <trans-unit id="ec9536dced588a5adfc7f095f97a48ee12e811ce" translate="yes" xml:space="preserve">
          <source>All processes and ports in the system as well as all processes and ports created hereafter are to be traced.</source>
          <target state="translated">系统中的所有进程和端口以及此后创建的所有进程和端口都要进行跟踪。</target>
        </trans-unit>
        <trans-unit id="02ef48a5ab6a5d0ee8466733327d3e4350edfd7d" translate="yes" xml:space="preserve">
          <source>All processes and ports that will be created in the future.</source>
          <target state="translated">未来将创建的所有进程和端口。</target>
        </trans-unit>
        <trans-unit id="d9be8009e2c7f6a938c6f743db853b2dfb9ccf36" translate="yes" xml:space="preserve">
          <source>All processes created after the call is are to be traced.</source>
          <target state="translated">调用后创建的所有进程都要被跟踪。</target>
        </trans-unit>
        <trans-unit id="058932c80ec58afa4c752d8e488f1fd07db947f7" translate="yes" xml:space="preserve">
          <source>All processes executing code in interpreted modules are displayed in the Monitor window.</source>
          <target state="translated">所有在解释模块中执行代码的进程都会显示在监控窗口中。</target>
        </trans-unit>
        <trans-unit id="974deb8f031d33a6740c7ebe7532a4266b1e29c9" translate="yes" xml:space="preserve">
          <source>All processes in the system as well as all processes created hereafter are to be traced.</source>
          <target state="translated">系统中的所有流程以及此后创建的所有流程都要进行追踪。</target>
        </trans-unit>
        <trans-unit id="263aac7a2b0fbff02edd125aaea0db769c21d0fa" translate="yes" xml:space="preserve">
          <source>All processes that will be created in the future.</source>
          <target state="translated">未来将建立的所有进程。</target>
        </trans-unit>
        <trans-unit id="b62c900a4023fa86a2240db1615b7f1efe40eb78" translate="yes" xml:space="preserve">
          <source>All programs accessing the database through the transaction system can be written as if they had sole access to the data. This is a desirable property, as all synchronization is taken care of by the transaction handler. If a program reads or writes data, the system ensures that no other program tries to manipulate the same data at the same time.</source>
          <target state="translated">所有通过事务处理系统访问数据库的程序都可以被写成好像它们拥有对数据的唯一访问权一样。这是一个理想的属性,因为所有的同步都由事务处理程序负责。如果一个程序读取或写入数据,系统会确保没有其他程序试图同时操作相同的数据。</target>
        </trans-unit>
        <trans-unit id="17a5433d9d8b1ba8d9bee65a3013cbeaf6dd7b31" translate="yes" xml:space="preserve">
          <source>All record names generated by the compiler are prefixed with &lt;code&gt;Prefix&lt;/code&gt;. This is useful when multiple protocols that contain records with identical names are included in a single module.</source>
          <target state="translated">编译器生成的所有记录名称均以 &lt;code&gt;Prefix&lt;/code&gt; 为前缀。当单个模块中包含多个包含具有相同名称的记录的协议时，这很有用。</target>
        </trans-unit>
        <trans-unit id="979b4a0590268416125e90127fc8bfa28240add9" translate="yes" xml:space="preserve">
          <source>All records used in this Reference Manual are generated from ASN.1 specifications and are documented in the User's Guide. See &lt;code&gt;&lt;a href=&quot;public_key_records&quot;&gt;Public-key Records&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本参考手册中使用的所有记录均根据ASN.1规范生成，并记录在《用户指南》中。请参阅 &lt;code&gt;&lt;a href=&quot;public_key_records&quot;&gt;Public-key Records&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ac9354c0bfca95837d962e8ba1466208a9c37ae" translate="yes" xml:space="preserve">
          <source>All references to this node can then use the node name. For example, a file over FTP is fetched like follows:</source>
          <target state="translated">所有对这个节点的引用就可以使用这个节点名。例如,通过FTP获取一个文件的方法如下。</target>
        </trans-unit>
        <trans-unit id="9078a5064d8a2d7b1b465df78627e79bf9b494a4" translate="yes" xml:space="preserve">
          <source>All replicas are &lt;code&gt;ram_copies&lt;/code&gt;.</source>
          <target state="translated">所有副本都是 &lt;code&gt;ram_copies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02e9fe7f27cf72b855151f6db9301e6668c3912f" translate="yes" xml:space="preserve">
          <source>All reports containing a common pattern can be shown. Suppose a process crashes because it tries to call a non-existing function &lt;code&gt;release_handler:mbj_func/1&lt;/code&gt;. The reports can then be shown as follows:</source>
          <target state="translated">可以显示所有包含通用模式的报告。假设一个进程崩溃是因为它试图调用一个不存在的函数 &lt;code&gt;release_handler:mbj_func/1&lt;/code&gt; 。然后可以如下显示报告：</target>
        </trans-unit>
        <trans-unit id="d223dc7b2bab3d6a8406ce4cb25c92a16820e095" translate="yes" xml:space="preserve">
          <source>All reports matching the regular expression &lt;code&gt;RegExp&lt;/code&gt; are displayed. &lt;code&gt;RegExp&lt;/code&gt; can be any of the following:</source>
          <target state="translated">显示与正则表达式 &lt;code&gt;RegExp&lt;/code&gt; 匹配的所有报告。 &lt;code&gt;RegExp&lt;/code&gt; 可以是以下任意一项：</target>
        </trans-unit>
        <trans-unit id="feccd905133ca27d919366e9013d126e914e1433" translate="yes" xml:space="preserve">
          <source>All request made by the client to the connection are synchronous. If the timeout is used and expires the client process will exit with reason timeout. Proably the right thing to do is let the client die and perhaps be restarted by its supervisor. But if the client chooses to catch this timeout, it is a good idea to wait a little while before trying again. If there are too many consecutive timeouts that are caught the connection process will conclude that there is something radically wrong and terminate the connection.</source>
          <target state="translated">客户端对连接的所有请求都是同步的。如果使用了超时,并且过期了,客户端进程将以理由超时退出。原本正确的做法是让客户端死掉,或许会被其上级重新启动。但如果客户端选择赶上这个超时,最好等一会儿再尝试。如果连续抓到的超时次数过多,连接进程就会断定有根本性的问题,并终止连接。</target>
        </trans-unit>
        <trans-unit id="032cbcc0d828f70779b0c0ed0bc3facdb5203770" translate="yes" xml:space="preserve">
          <source>All resource objects are created as instances of some &lt;strong&gt;resource type&lt;/strong&gt;. This makes resources from different modules to be distinguishable. A resource type is created by calling &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type&quot;&gt;enif_open_resource_type&lt;/a&gt;&lt;/code&gt; when a library is loaded. Objects of that resource type can then later be allocated and &lt;code&gt;enif_get_resource&lt;/code&gt; verifies that the resource is of the expected type. A resource type can have a user-supplied destructor function, which is automatically called when resources of that type are released (by either the garbage collector or &lt;code&gt;enif_release_resource&lt;/code&gt;). Resource types are uniquely identified by a supplied name string and the name of the implementing module.</source>
          <target state="translated">所有资源对象都是作为某种&lt;strong&gt;资源类型的&lt;/strong&gt;实例创建的。这样可以区分来自不同模块的资源。加载库时，通过调用 &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type&quot;&gt;enif_open_resource_type&lt;/a&gt;&lt;/code&gt; 创建资源类型。然后可以稍后分配该资源类型的对象，并且 &lt;code&gt;enif_get_resource&lt;/code&gt; 验证该资源是否属于预期类型。资源类型可以具有用户提供的析构函数，该函数在释放该类型的资源时（通过垃圾回收器或 &lt;code&gt;enif_release_resource&lt;/code&gt; ）会自动调用。资源类型由提供的名称字符串和实现模块的名称唯一标识。</target>
        </trans-unit>
        <trans-unit id="8b7a4f2a8dc320cacf959f8d17456e7115df6332" translate="yes" xml:space="preserve">
          <source>All runtime dependencies specified in OTP applications during the OTP 17 release may not be completely correct. This is actively being worked on. Declared runtime dependencies in OTP applications are expected to be correct in OTP 18.</source>
          <target state="translated">在OTP 17版本中,OTP应用程序中指定的所有运行时依赖关系可能并不完全正确。目前正在积极解决这个问题。OTP应用程序中宣布的运行时依赖性预计在OTP 18中是正确的。</target>
        </trans-unit>
        <trans-unit id="8d4e91d8f62a7df11a977cb27005070535f221fd" translate="yes" xml:space="preserve">
          <source>All sections are returned even if they do not exist in the escript. If a particular section happens to have the same value as the default value, the extracted value is set to the atom &lt;code&gt;default&lt;/code&gt;. If a section is missing, the extracted value is set to the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">即使escript中不存在，也将返回所有节。如果特定部分的值恰好与默认值相同，则提取的值将设置为atom &lt;code&gt;default&lt;/code&gt; 。如果缺少部分，则将提取的值设置为原子 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93c2177455dcce657afa2684588a0241cb58b085" translate="yes" xml:space="preserve">
          <source>All sizes are in words.</source>
          <target state="translated">所有尺寸都是以字为单位。</target>
        </trans-unit>
        <trans-unit id="816578661858d321b1e0e5d92462cad1bde0c144" translate="yes" xml:space="preserve">
          <source>All source directories identified by &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; should contain build results of OTP applications.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 标识的所有源目录应包含OTP应用程序的构建结果。</target>
        </trans-unit>
        <trans-unit id="279a723e274bbdf44bf4e5f4cdb64a6e1d7b0708" translate="yes" xml:space="preserve">
          <source>All strongly connected components of the Inter Call Graph. Each component is a set of exported or unused local functions that call each other (in)directly.</source>
          <target state="translated">Inter Call Graph的所有强连接组件。每个组件都是一组导出的或未使用的本地函数,它们互相(在)直接调用。</target>
        </trans-unit>
        <trans-unit id="ce9911ac68b49180cc63944c113ff7ba4d2e2e06" translate="yes" xml:space="preserve">
          <source>All subexpressions are evaluated before an expression itself is evaluated, unless explicitly stated otherwise. For example, consider the expression:</source>
          <target state="translated">除非另有明确说明,否则所有的子表达式都会在表达式本身被评估之前被评估。例如,考虑以下表达式</target>
        </trans-unit>
        <trans-unit id="bc8cf988787046c6e827bee8905f94b4d9c3ab4c" translate="yes" xml:space="preserve">
          <source>All subroutine calls, recursive or not, are always treated as atomic groups. That is, once a subroutine has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. Any capturing parentheses that are set during the subroutine call revert to their previous values afterwards.</source>
          <target state="translated">所有的子程序调用,无论是否递归,总是被视为原子组。也就是说,一旦一个子程序匹配了主题字符串中的某些内容,即使其中包含了未经尝试的备选方案,并且随后出现了匹配失败的情况,也绝不会重新进入。在子程序调用过程中设置的任何捕获括号在之后都会恢复到之前的值。</target>
        </trans-unit>
        <trans-unit id="1d5c8272d5e19cda4e470b25066c4bee5acf4aba" translate="yes" xml:space="preserve">
          <source>All supported applications are sent in CEA. The user can reject an incoming CER or CEA in a configured callback.</source>
          <target state="translated">所有支持的应用都以CEA方式发送。用户可以在配置的回调中拒绝接收CER或CEA。</target>
        </trans-unit>
        <trans-unit id="275f9905a31aea84897da6140c192789acae8be1" translate="yes" xml:space="preserve">
          <source>All system events are subscribed by the &lt;code&gt;Mnesia&lt;/code&gt;&lt;code&gt;gen_event&lt;/code&gt; handler. The default &lt;code&gt;gen_event&lt;/code&gt; handler is &lt;code&gt;mnesia_event&lt;/code&gt;, but it can be changed by using application parameter &lt;code&gt;event_module&lt;/code&gt;. The value of this parameter must be the name of a module implementing a complete handler, as specified by the &lt;code&gt;gen_event&lt;/code&gt; module in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;gen_event&lt;/code&gt; 处理程序订阅了所有系统事件。默认的 &lt;code&gt;gen_event&lt;/code&gt; 处理程序是 &lt;code&gt;mnesia_event&lt;/code&gt; ，但是可以使用应用程序参数 &lt;code&gt;event_module&lt;/code&gt; 进行更改。该参数的值必须是实现完整处理程序的模块的名称，这由 &lt;code&gt;STDLIB&lt;/code&gt; 中的 &lt;code&gt;gen_event&lt;/code&gt; 模块指定。</target>
        </trans-unit>
        <trans-unit id="4d08314aed5dcca44e10e6d9a69ebf73a80227eb" translate="yes" xml:space="preserve">
          <source>All tables in these MIBs have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">这些MIB中的所有表都有一个类型为 &lt;code&gt;StorageType&lt;/code&gt; 的列。此列的值指定每行的存储方式，以及在代理重新启动的情况下发生的情况。该实现支持值 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;nonVolatile&lt;/code&gt; 。最初用配置文件中的数据填充表时，这些行将自动具有存储类型 &lt;code&gt;nonVolatile&lt;/code&gt; 。代理重新启动后，所有 &lt;code&gt;volatile&lt;/code&gt; 行将在重新启动后继续存在， &lt;code&gt;nonVolatile&lt;/code&gt; 失性行将丢失。默认情况下，重新启动时不会读取配置文件。</target>
        </trans-unit>
        <trans-unit id="2be215003503f0345c1ed6d0ccc3e065ee26074f" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of the column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">此MIB中的所有表都有一个类型为 &lt;code&gt;StorageType&lt;/code&gt; 的列。列的值指定如何存储每一行​​，以及在代理重新启动的情况下会发生什么。该实现支持值 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;nonVolatile&lt;/code&gt; 。最初用配置文件中的数据填充表时，这些行将自动具有存储类型 &lt;code&gt;nonVolatile&lt;/code&gt; 。代理重新启动后，所有 &lt;code&gt;volatile&lt;/code&gt; 行将在重新启动后继续存在， &lt;code&gt;nonVolatile&lt;/code&gt; 失性行将丢失。默认情况下，重新启动时不会读取配置文件。</target>
        </trans-unit>
        <trans-unit id="b6acc62d86c3d4707c0eac98a8d2e6fe30ade03d" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart by default.</source>
          <target state="translated">此MIB中的所有表都有一个类型为 &lt;code&gt;StorageType&lt;/code&gt; 的列。此列的值指定每行的存储方式，以及在代理重新启动的情况下发生的情况。该实现支持值 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;nonVolatile&lt;/code&gt; 。最初用配置文件中的数据填充表时，这些行将自动具有存储类型 &lt;code&gt;nonVolatile&lt;/code&gt; 。代理重新启动后，所有 &lt;code&gt;volatile&lt;/code&gt; 行将在重新启动后继续存在， &lt;code&gt;nonVolatile&lt;/code&gt; 失性行将丢失。默认情况下，重新启动时不会读取配置文件。</target>
        </trans-unit>
        <trans-unit id="00646ed20fc05656dbed000a1f7dd63af6936be5" translate="yes" xml:space="preserve">
          <source>All tables in this MIB have a column of type &lt;code&gt;StorageType&lt;/code&gt;. The value of this column specifies how each row is stored, and what happens in case of a restart of the agent. The implementation supports the values &lt;code&gt;volatile&lt;/code&gt; and &lt;code&gt;nonVolatile&lt;/code&gt;. When the tables are initially filled with data from the configuration files, these rows will automatically have storage type &lt;code&gt;nonVolatile&lt;/code&gt;. Should the agent restart, all &lt;code&gt;nonVolatile&lt;/code&gt; rows survive the restart, while the &lt;code&gt;volatile&lt;/code&gt; rows are lost. The configuration files are not read at restart, by default.</source>
          <target state="translated">此MIB中的所有表都有一个类型为 &lt;code&gt;StorageType&lt;/code&gt; 的列。此列的值指定每行的存储方式，以及在代理重新启动的情况下发生的情况。该实现支持值 &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;nonVolatile&lt;/code&gt; 。最初用配置文件中的数据填充表时，这些行将自动具有存储类型 &lt;code&gt;nonVolatile&lt;/code&gt; 。代理重新启动后，所有 &lt;code&gt;volatile&lt;/code&gt; 行将在重新启动后继续存在， &lt;code&gt;nonVolatile&lt;/code&gt; 失性行将丢失。默认情况下，重新启动时不会读取配置文件。</target>
        </trans-unit>
        <trans-unit id="1d08c6b8f5332d226fb098f25e3d0026f24d96b0" translate="yes" xml:space="preserve">
          <source>All terminal sessions, forwarded connections, and so on, are channels. Multiple channels are multiplexed into a single connection. All channels are flow-controlled. This means that no data is sent to a channel peer until a message is received to indicate that window space is available. The &lt;strong&gt;initial window size&lt;/strong&gt; specifies how many bytes of channel data that can be sent to the channel peer without adjusting the window. Typically, an SSH client opens a channel, sends data (commands), receives data (control information), and then closes the channel. The &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behaviour handles generic parts of SSH channel management. This makes it easy to write your own SSH client/server processes that use flow-control and thus opens for more focus on the application logic.</source>
          <target state="translated">所有终端会话，转发的连接等等都是通道。多个通道被多路复用为单个连接。所有通道都是流量控制的。这意味着，直到接收到指示窗口空间可用的消息，才将数据发送到通道对等方。的&lt;strong&gt;初始窗口大小&lt;/strong&gt;指定多少，可以被发送到对等信道，而无需调整窗口信道的数据的字节。通常，SSH客户端打开一个通道，发送数据（命令），接收数据（控制信息），然后关闭该通道。该 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为处理SSH渠道管理的通用器件。这使得编写自己的使用流控制的SSH客户端/服务器进程变得容易，因此可以更加关注应用程序逻辑。</target>
        </trans-unit>
        <trans-unit id="bbaac04b0726304e8bc0e8488270b15fbabc7eec" translate="yes" xml:space="preserve">
          <source>All terms of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; belong to an environment of type &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;. The lifetime of a term is controlled by the lifetime of its environment object. All API functions that read or write terms has the environment that the term belongs to as the first function argument.</source>
          <target state="translated">类型的所有方面 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 属于类型的环境 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; 。术语的生存期由其环境对象的生存期控制。读取或写入术语的所有API函数均具有该术语所属的环境作为第一个函数参数。</target>
        </trans-unit>
        <trans-unit id="a9bcc2ff9eb94545ba2264a6548aeeb2cfbc7213" translate="yes" xml:space="preserve">
          <source>All test specification terms can have a &lt;code&gt;NodeRefs&lt;/code&gt; element. This element specifies which node or nodes a configuration operation or a test is to be executed on. &lt;code&gt;NodeRefs&lt;/code&gt; is defined as follows:</source>
          <target state="translated">所有测试规范术语都可以具有 &lt;code&gt;NodeRefs&lt;/code&gt; 元素。该元素指定要在哪个或哪些节点上执行配置操作或测试。 &lt;code&gt;NodeRefs&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="48735adbc1ab5a93b4785b0a0f4fffaf6f1c2e20" translate="yes" xml:space="preserve">
          <source>All the Latin-1 printable characters can be used and are shown without the escape backslash convention.</source>
          <target state="translated">所有的Latin-1可打印字符都可以使用,并且在显示时不使用转义反斜线约定。</target>
        </trans-unit>
        <trans-unit id="c7d4b662d48820ea13cd394713d1d0d65d538449" translate="yes" xml:space="preserve">
          <source>All the files are searched for in the code path. It is assumed that the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.appup&lt;/code&gt; files for an application are located in the same directory.</source>
          <target state="translated">在代码路径中搜索所有文件。假定 &lt;code&gt;.app&lt;/code&gt; 和 &lt;code&gt;.appup&lt;/code&gt; 文件位于同一目录中。</target>
        </trans-unit>
        <trans-unit id="0444fd0cb5c7b225515f5d7a7b6af2522512c8ad" translate="yes" xml:space="preserve">
          <source>All the makefiles in the entire directory tree use the environment variable &lt;code&gt;ERL_TOP&lt;/code&gt; to find the absolute path of the installation. The &lt;code&gt;configure&lt;/code&gt; script will figure this out and set it in the top level Makefile (which, when building, it will pass on). However, when developing it is sometimes convenient to be able to run make in a subdirectory. To do this you must set the &lt;code&gt;ERL_TOP&lt;/code&gt; variable before you run make.</source>
          <target state="translated">整个目录树中的所有makefile都使用环境变量 &lt;code&gt;ERL_TOP&lt;/code&gt; 查找安装的绝对路径。该 &lt;code&gt;configure&lt;/code&gt; 脚本会想出解决办法，并在顶层Makefile文件设置（其中，建筑时，它会通过上）。但是，在开发时，有时可以在子目录中运行make会很方便。为此，必须在运行make之前设置 &lt;code&gt;ERL_TOP&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="4e454e4a6b739313895f7f1cd6dd60a39deee0fd" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single character value can be used both inside and outside character classes. Also, inside a character class, \b is interpreted as the backspace character (hex 08).</source>
          <target state="translated">所有定义单个字符值的序列都可以在字符类内部和外部使用。另外,在字符类内部,/b被解释为退格字符(十六进制08)。</target>
        </trans-unit>
        <trans-unit id="4ee45dea67a291aecd38cc8ca1fc6c4d76ed45cd" translate="yes" xml:space="preserve">
          <source>All the standard &lt;code&gt;erlc&lt;/code&gt; flags are supported, e.g.</source>
          <target state="translated">支持所有标准 &lt;code&gt;erlc&lt;/code&gt; 标志，例如</target>
        </trans-unit>
        <trans-unit id="7f1c4eba20235be2abd7c818764fb7f15db8c9f6" translate="yes" xml:space="preserve">
          <source>All these approaches have different advantages and disadvantages. Mnesia applications can easily be opened to the SNMP protocol. A direct 1-to-1 mapping can be established between Mnesia tables and SNMP tables. This means that a Mnesia table can be configured to be &lt;strong&gt;both&lt;/strong&gt; a Mnesia table and an SNMP table. A number of functions to control this behavior are described in the Reference Manual.</source>
          <target state="translated">所有这些方法都有不同的优点和缺点。Mnesia应用程序可以轻松地打开SNMP协议。可以在Mnesia表和SNMP表之间建立直接的一对一映射。这意味着一个Mnesia表可以被配置为&lt;strong&gt;既&lt;/strong&gt;一个Mnesia表和SNMP表。《参考手册》中描述了许多控制此行为的功能。</target>
        </trans-unit>
        <trans-unit id="1fac601052f4adfe0b1a57d2c3f3d2911074176e" translate="yes" xml:space="preserve">
          <source>All these files are searched for in the current path. If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">在当前路径中搜索所有这些文件。如果指定了选项 &lt;code&gt;{path,[Dir]}&lt;/code&gt; ，则此路径将附加到当前路径。通配符 &lt;code&gt;*&lt;/code&gt; 扩展到所有匹配的目录。示例： &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7e2356ccbec315a42104120c05856a52f734c98" translate="yes" xml:space="preserve">
          <source>All these specifications are commonly referred to as &quot;SNMPv3&quot;, but it is actually only the Message module, which defines a new message format, and Security module, which takes care of encryption and authentication, that cannot be used with SNMPv1 or SNMPv2c. In this version of the agent toolkit, all the standard MIBs for agent configuration are used. This includes MIBs for definition of management targets for notifications. These MIBs are used regardless of which SNMP version the agent is configured to use.</source>
          <target state="translated">所有这些规范通常被称为 &quot;SNMPv3&quot;,但实际上只有定义了新的消息格式的Message模块和负责加密和认证的Security模块不能与SNMPv1或SNMPv2c一起使用。在这个版本的代理工具包中,使用了所有用于代理配置的标准MIB。这包括用于定义通知的管理目标的MIB。无论代理配置使用哪个SNMP版本,都会使用这些MIB。</target>
        </trans-unit>
        <trans-unit id="3cac96e5ed27b35536f52f9e48ab7dabf6e3dcbc" translate="yes" xml:space="preserve">
          <source>All these terms are tuples or atoms and this property will hold in any future version of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">所有这些术语都是元组或原子，并且此属性将在 &lt;code&gt;gen_statem&lt;/code&gt; 的任何将来版本中保留。</target>
        </trans-unit>
        <trans-unit id="890112740b2f13fe0da0f81f57e7bfd71e15b913" translate="yes" xml:space="preserve">
          <source>All those processes are suspended using &lt;code&gt;sys:suspend&lt;/code&gt;, the new module version is loaded, and then the processes are resumed using &lt;code&gt;sys:resume&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;sys:suspend&lt;/code&gt; 暂停所有这些进程，加载新的模块版本，然后使用 &lt;code&gt;sys:resume&lt;/code&gt; 恢复这些进程。</target>
        </trans-unit>
        <trans-unit id="cdb00a5ac19881ad68109f99749ac6602091708a" translate="yes" xml:space="preserve">
          <source>All time values in the printout are in milliseconds.</source>
          <target state="translated">打印输出中的所有时间值都以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="3664934232b9c1e3d5ba66ce6f23f716a86fdf6f" translate="yes" xml:space="preserve">
          <source>All time-out parameters in &lt;code&gt;ct_ssh&lt;/code&gt; functions are values in milliseconds.</source>
          <target state="translated">&lt;code&gt;ct_ssh&lt;/code&gt; 函数中的所有超时参数都是以毫秒为单位的值。</target>
        </trans-unit>
        <trans-unit id="73ac2e4652c66f37048e2ce303fb4b7c12c7f46b" translate="yes" xml:space="preserve">
          <source>All trace messages are now sent to the trace port driver, which in turn listens for connections on the TCP/IP port 4711. If we want to see the messages on another node, preferably on another host, we do like this:</source>
          <target state="translated">现在,所有的跟踪消息都会被发送到跟踪端口驱动程序,而该端口驱动程序则会监听TCP/IP端口4711上的连接。如果我们想在另一个节点上看到消息,最好是在另一个主机上,我们这样做。</target>
        </trans-unit>
        <trans-unit id="8f71e5171eeb0a212a223f31caa94583b81ed2fb" translate="yes" xml:space="preserve">
          <source>All trace messages described in &lt;code&gt;erlang:trace/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; 中描述的所有跟踪消息</target>
        </trans-unit>
        <trans-unit id="d3efff8fa8f318980d38111160f5b67cc47267dc" translate="yes" xml:space="preserve">
          <source>All tracepoints are in the domain of &lt;code&gt;org_erlang_dyntrace&lt;/code&gt;</source>
          <target state="translated">所有跟踪点都在 &lt;code&gt;org_erlang_dyntrace&lt;/code&gt; 的域中</target>
        </trans-unit>
        <trans-unit id="44cb4a9b19b2ae441f7387b7938876140dd1d39f" translate="yes" xml:space="preserve">
          <source>All tracepoints are in the domain of &lt;code&gt;org_erlang_otp&lt;/code&gt;</source>
          <target state="translated">所有跟踪点都在 &lt;code&gt;org_erlang_otp&lt;/code&gt; 的域中</target>
        </trans-unit>
        <trans-unit id="fe016daf62582765dc4aa1a03f24a6e0af233e2a" translate="yes" xml:space="preserve">
          <source>All tracepoints via dyntrace are now visibile and can be listed through &lt;code&gt;lttng list -u&lt;/code&gt;.</source>
          <target state="translated">通过dyntrace的所有跟踪点现在都可见，并且可以通过 &lt;code&gt;lttng list -u&lt;/code&gt; 列出。</target>
        </trans-unit>
        <trans-unit id="499f82751e8891c03eee132bbb924f122760fc91" translate="yes" xml:space="preserve">
          <source>All uses of &lt;code&gt;erlang:now/0&lt;/code&gt; are not necessarily time warp unsafe. If you do not use it to get time, it is time warp safe. However, &lt;strong&gt;all uses of &lt;code&gt;erlang:now/0&lt;/code&gt; are suboptimal&lt;/strong&gt; from a performance and scalability perspective. So you really want to replace the use of it with other functionality. For examples of how to replace the use of &lt;code&gt;erlang:now/0&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#Dos_and_Donts&quot;&gt;How to Work with the New API&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 的所有用法不一定都是时间扭曲不安全的。如果您不使用它来获取时间，那么时间扭曲是安全的。但是，从性能和可伸缩性的角度来看，&lt;strong&gt;对 &lt;code&gt;erlang:now/0&lt;/code&gt; 的所有使用都不理想&lt;/strong&gt;。因此，您真的想用其他功能代替它的使用。有关如何替换 &lt;code&gt;erlang:now/0&lt;/code&gt; 的用法的示例，请参见 &lt;code&gt;&lt;a href=&quot;#Dos_and_Donts&quot;&gt;How to Work with the New API&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211631ba4463502ebe4c8f751cdd7698a665a9d5" translate="yes" xml:space="preserve">
          <source>All valid &lt;code&gt;Modifier&lt;/code&gt;s can be combined. Repeated (valid) &lt;code&gt;Modifier&lt;/code&gt;s in the &lt;code&gt;ModifierList&lt;/code&gt; are ignored.</source>
          <target state="translated">可以组合所有有效的 &lt;code&gt;Modifier&lt;/code&gt; 。重复（有效） &lt;code&gt;Modifier&lt;/code&gt; ■在 &lt;code&gt;ModifierList&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="b7b522b5a14ce33ffd78ac8c417a27a7fc89b353" translate="yes" xml:space="preserve">
          <source>All value tuples returned, except user terms, have the node name as first element.</source>
          <target state="translated">除了用户术语外,所有返回的值元组都以节点名作为第一个元素。</target>
        </trans-unit>
        <trans-unit id="21e9bece8ea26173685ff9911582acaf9d4050b7" translate="yes" xml:space="preserve">
          <source>All variables are bound in the head of a match specification, so the translator cannot allow multiple bindings. The special case when matching is done on the top-level makes the variable bind to &lt;code&gt;'$_'&lt;/code&gt; in the resulting match specification. It is to allow a more natural access to the whole matched object. Pseudo function &lt;code&gt;object()&lt;/code&gt; can be used instead, see below.</source>
          <target state="translated">所有变量都绑定在匹配说明的开头，因此翻译器不允许多个绑定。在顶层进行匹配时的特殊情况使变量在结果匹配说明中绑定到 &lt;code&gt;'$_'&lt;/code&gt; 。这是为了更自然地访问整个匹配的对象。可以使用伪函数 &lt;code&gt;object()&lt;/code&gt; 代替，请参见下文。</target>
        </trans-unit>
        <trans-unit id="3239372c6832b6066bf1341e4487441749e323f8" translate="yes" xml:space="preserve">
          <source>All variables in this section can also be used when native compiling.</source>
          <target state="translated">本节中的所有变量也可以在本地编译时使用。</target>
        </trans-unit>
        <trans-unit id="e461c8c7353cd1b34f013d7ed1f82ff4c3ffca7d" translate="yes" xml:space="preserve">
          <source>All variables that occur in a generator pattern are assumed to be &quot;fresh&quot; variables.</source>
          <target state="translated">所有在生成器模式中出现的变量都被假定为 &quot;新鲜 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="df218dfee4c4921dcfbc282d5dc989b168d2e1f4" translate="yes" xml:space="preserve">
          <source>All variables that occur in the head of a fun are assumed to be &quot;fresh&quot; variables.</source>
          <target state="translated">所有出现在fun头的变量都被假定为 &quot;新鲜 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="9dca8a39352aeb9ee959a27cda59139e72297719" translate="yes" xml:space="preserve">
          <source>All versions of a release, except the first one, must contain a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">除第一个版本外，所有版本的版本都必须包含一个 &lt;code&gt;relup&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1e91b63c830fdded4d39a3a4df9692ba7ad1288f" translate="yes" xml:space="preserve">
          <source>All write operations must be written to persistent storage.</source>
          <target state="translated">所有的写操作都必须写入持久性存储。</target>
        </trans-unit>
        <trans-unit id="156cc2a3256755987835162d54df2b3bc251cdec" translate="yes" xml:space="preserve">
          <source>Allocates a binary of size &lt;code&gt;size&lt;/code&gt; bytes and creates an owning term. The binary data is mutable until the calling NIF returns. This is a quick way to create a new binary without having to use &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt;. The drawbacks are that the binary cannot be kept between NIF calls and it cannot be reallocated.</source>
          <target state="translated">分配 &lt;code&gt;size&lt;/code&gt; 字节大小的二进制文件并创建一个拥有项。二进制数据是可变的，直到调用NIF返回为止。这是无需使用 &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt; 即可创建新二进制文件的快速方法。缺点是二进制文件不能在NIF调用之间保留，也不能重新分配。</target>
        </trans-unit>
        <trans-unit id="fb968cb7c5633735b69c8c6ae48cba56207bf43d" translate="yes" xml:space="preserve">
          <source>Allocates a driver binary with a memory block of at least &lt;code&gt;size&lt;/code&gt; bytes, and returns a pointer to it, or &lt;code&gt;NULL&lt;/code&gt; on failure (out of memory). When a driver binary has been sent to the emulator, it must not be changed. Every allocated binary is to be freed by a corresponding call to &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; (unless otherwise stated).</source>
          <target state="translated">为驱动程序二进制文件分配至少一个 &lt;code&gt;size&lt;/code&gt; 字节的内存块，并返回指向它的指针，如果失败（内存不足），则返回 &lt;code&gt;NULL&lt;/code&gt; 。将驱动程序二进制文件发送到仿真器后，不得更改它。每个分配的二进制文件都应通过对 &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; 的相应调用来释放（除非另有说明）。</target>
        </trans-unit>
        <trans-unit id="833eb9c3ea4fa101cb31390f1caf6a0a0d2db0c7" translate="yes" xml:space="preserve">
          <source>Allocates a memory block of the size specified in &lt;code&gt;size&lt;/code&gt;, and returns it. This fails only on out of memory, in which case &lt;code&gt;NULL&lt;/code&gt; is returned. (This is most often a wrapper for &lt;code&gt;malloc&lt;/code&gt;).</source>
          <target state="translated">分配大小在 &lt;code&gt;size&lt;/code&gt; 中指定的内存块，并返回它。这仅在内存不足时失败，在这种情况下将返回 &lt;code&gt;NULL&lt;/code&gt; 。（这通常是 &lt;code&gt;malloc&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="7113d00f84f8c1774bce3cf42e016073857670b7" translate="yes" xml:space="preserve">
          <source>Allocates a memory-managed resource object of type &lt;code&gt;type&lt;/code&gt; and size &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">分配 &lt;code&gt;type&lt;/code&gt; 和大小 &lt;code&gt;size&lt;/code&gt; 字节类型的内存管理资源对象。</target>
        </trans-unit>
        <trans-unit id="40cbb022971bb0ea9616862fa9f96313f80c2ace" translate="yes" xml:space="preserve">
          <source>Allocates a new &lt;code&gt;ei_x_buff&lt;/code&gt; buffer. The fields of the structure pointed to by parameter &lt;code&gt;x&lt;/code&gt; is filled in, and a default buffer is allocated. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; also puts an initial version byte, which is used in the binary format (so that &lt;code&gt;ei_x_encode_version()&lt;/code&gt; will not be needed.)</source>
          <target state="translated">分配新的 &lt;code&gt;ei_x_buff&lt;/code&gt; 缓冲区。填充由参数 &lt;code&gt;x&lt;/code&gt; 指向的结构的字段，并分配默认缓冲区。 &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; 还会放入一个初始版本字节，该字节以二进制格式使用（因此将 &lt;code&gt;ei_x_encode_version()&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="aba86698e833f8743e3f8398d4c7b3c5cba11222" translate="yes" xml:space="preserve">
          <source>Allocates a new binary of size &lt;code&gt;size&lt;/code&gt; bytes. Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; to refer to the allocated binary. The binary must either be released by &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; or ownership transferred to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. An allocated (and owned) &lt;code&gt;ErlNifBinary&lt;/code&gt; can be kept between NIF calls.</source>
          <target state="translated">分配一个新的大小 &lt;code&gt;size&lt;/code&gt; 字节大小的二进制文件。初始化 &lt;code&gt;bin&lt;/code&gt; 指向的结构以引用分配的二进制文件。二进制必须通过释放 &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; 或所有权转移至Erlang项与 &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt; 。可以在NIF调用之间保留已分配（并拥有）的 &lt;code&gt;ErlNifBinary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7773bdff2c5401e19b3fa0521031da780795237d" translate="yes" xml:space="preserve">
          <source>Allocates a new binary with &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; and stores the result of encoding &lt;code&gt;term&lt;/code&gt; according to the Erlang external term format.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 分配一个新的二进制文件，并根据Erlang外部术语格式存储编码 &lt;code&gt;term&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="7d5526a3227cb0d073e447c7c317d1cd47b6a7bb" translate="yes" xml:space="preserve">
          <source>Allocates a new process-independent environment. The environment can be used to hold terms that are not bound to any process. Such terms can later be copied to a process environment with &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; or be sent to a process as a message with &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">分配新的与流程无关的环境。该环境可用于保存不受任何过程约束的术语。这样的术语可在以后被复制到一个处理环境与 &lt;code&gt;&lt;a href=&quot;#enif_make_copy&quot;&gt;enif_make_copy&lt;/a&gt;&lt;/code&gt; 或被发送到一个进程作为与消息 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef1154674774259204ce883b3c8820bd4b8d7df0" translate="yes" xml:space="preserve">
          <source>Allocates an &lt;code&gt;(ETERM)&lt;/code&gt; structure.</source>
          <target state="translated">分配 &lt;code&gt;(ETERM)&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="24619459ec0a72f9cf9f4e797e9676fdd79c448d" translate="yes" xml:space="preserve">
          <source>Allocates and initializes a thread option structure.</source>
          <target state="translated">分配并初始化一个线程选项结构。</target>
        </trans-unit>
        <trans-unit id="a18ef353480e9b28111af2f5cb94cf322d5db150" translate="yes" xml:space="preserve">
          <source>Allocates memory of &lt;code&gt;size&lt;/code&gt; bytes.</source>
          <target state="translated">分配 &lt;code&gt;size&lt;/code&gt; 字节的内存。</target>
        </trans-unit>
        <trans-unit id="6d3c5411f35ce9d979ab943b82f49536b0b3d755" translate="yes" xml:space="preserve">
          <source>Allocation strategy. The following strategies are valid:</source>
          <target state="translated">分配战略。下列战略有效:</target>
        </trans-unit>
        <trans-unit id="90fca3fd6d65264d4e4e5dc53f3e23f12741c724" translate="yes" xml:space="preserve">
          <source>Allocator used by the &lt;code&gt;HiPE&lt;/code&gt; application for native executable code.</source>
          <target state="translated">&lt;code&gt;HiPE&lt;/code&gt; 应用程序用于本机可执行代码的分配器。</target>
        </trans-unit>
        <trans-unit id="e5156ecc9d7848780f93b6f5ebc71cee114aba96" translate="yes" xml:space="preserve">
          <source>Allocator used for &lt;code&gt;ets&lt;/code&gt; data.</source>
          <target state="translated">用于 &lt;code&gt;ets&lt;/code&gt; 数据的分配器。</target>
        </trans-unit>
        <trans-unit id="efc1c3dea60e348865091b6b8e2060dd569f66c2" translate="yes" xml:space="preserve">
          <source>Allocator used for Erlang binary data.</source>
          <target state="translated">用于Erlang二进制数据的分配器。</target>
        </trans-unit>
        <trans-unit id="7a3adf2a9bd06e8c3a3e083ec99105ea6ffe70ec" translate="yes" xml:space="preserve">
          <source>Allocator used for Erlang heap data, such as Erlang process heaps.</source>
          <target state="translated">用于Erlang堆数据的分配器,如Erlang进程堆。</target>
        </trans-unit>
        <trans-unit id="8e85fcae342a51464bc8fd23b308ac874d7d0a04" translate="yes" xml:space="preserve">
          <source>Allocator used for constant terms in Erlang code.</source>
          <target state="translated">用于Erlang代码中常数项的分配器。</target>
        </trans-unit>
        <trans-unit id="e1d6940ddd5a1c15fef14e15f5f4c63526b4e648" translate="yes" xml:space="preserve">
          <source>Allocator used for driver data.</source>
          <target state="translated">用于驱动数据的分配器。</target>
        </trans-unit>
        <trans-unit id="3ea76fff61ed65e7a4390d7beabc10d7b1f5293b" translate="yes" xml:space="preserve">
          <source>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</source>
          <target state="translated">用于预期长寿命的内存块的分配器,例如,Erlang代码。</target>
        </trans-unit>
        <trans-unit id="a3b32174d0cb257a1aff46d5fa0ab778500a96d6" translate="yes" xml:space="preserve">
          <source>Allocator used for memory blocks that are expected to be short-lived.</source>
          <target state="translated">分配器用于预期是短期的内存块。</target>
        </trans-unit>
        <trans-unit id="d37461cad7f410e82c9bcd356e966dab124d9b70" translate="yes" xml:space="preserve">
          <source>Allocator used for most memory blocks not allocated through any of the other allocators described above.</source>
          <target state="translated">分配器用于大多数未通过上述任何其他分配器分配的内存块。</target>
        </trans-unit>
        <trans-unit id="e693dfe3e7d7c8a81002580ac04e0ce504a69571" translate="yes" xml:space="preserve">
          <source>Allocator used for temporary allocations.</source>
          <target state="translated">用于临时分配的分配器。</target>
        </trans-unit>
        <trans-unit id="10f9e4423c6925e89dc2106becb3f6ab79d98e45" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;sys_alloc&lt;/code&gt; carriers. Defaults to &lt;code&gt;true&lt;/code&gt;. If set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;sys_alloc&lt;/code&gt; carriers are never created by allocators using the &lt;code&gt;alloc_util&lt;/code&gt; framework.</source>
          <target state="translated">允许 &lt;code&gt;sys_alloc&lt;/code&gt; 载体。默认为 &lt;code&gt;true&lt;/code&gt; 。如果设置为 &lt;code&gt;false&lt;/code&gt; ，则分配器决不会使用 &lt;code&gt;alloc_util&lt;/code&gt; 框架创建 &lt;code&gt;sys_alloc&lt;/code&gt; 载体。</target>
        </trans-unit>
        <trans-unit id="eff7134dcdaeb2b5c83d79ef04547c8d9cc7e16d" translate="yes" xml:space="preserve">
          <source>Allow Erlang code to supply annotations.</source>
          <target state="translated">允许Erlang代码提供注释。</target>
        </trans-unit>
        <trans-unit id="2367e7a84c9f7bf24def174981a401bf837d2c24" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests if &lt;code&gt;RecordTag&lt;/code&gt; is a literal atom and &lt;code&gt;Size&lt;/code&gt; is a literal integer.</source>
          <target state="translated">如果 &lt;code&gt;RecordTag&lt;/code&gt; 是文字原子且 &lt;code&gt;Size&lt;/code&gt; 是文字整数，则在防护测试中允许。</target>
        </trans-unit>
        <trans-unit id="501b2ae74253f22d1b49c8d28118aa90b6840545" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests, if &lt;code&gt;RecordTag&lt;/code&gt; is a literal atom.</source>
          <target state="translated">如果 &lt;code&gt;RecordTag&lt;/code&gt; 是文字原子，则在保护测试中允许。</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="translated">允许在防护试验中。</target>
        </trans-unit>
        <trans-unit id="36ba60d3da32240e2b1d7c2743d638c321c3a258" translate="yes" xml:space="preserve">
          <source>Allowed values for &lt;code&gt;Encoding&lt;/code&gt;:</source>
          <target state="translated">允许的 &lt;code&gt;Encoding&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="99a20c43f2025ca6e009397d28af92a72d22a63a" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycles&lt;/a&gt;&lt;/code&gt; in the digraph (default).</source>
          <target state="translated">允许在有向图中 &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycles&lt;/a&gt;&lt;/code&gt; （默认）。</target>
        </trans-unit>
        <trans-unit id="9f8f1bb0255618251aa9f45e2eb49f1f0585198d" translate="yes" xml:space="preserve">
          <source>Allows Igor to work as a component of the Erlang compiler. Including the term &lt;code&gt;{parse_transform, igor}&lt;/code&gt; in the compile options when compiling an Erlang module (cf. &lt;code&gt;compile:file/2&lt;/code&gt;), will call upon Igor to process the source code, allowing automatic inclusion of other source files. No files are created or overwritten when this function is used.</source>
          <target state="translated">允许Igor充当Erlang编译器的组件。编译Erlang模块时，在编译选项中包含术语 &lt;code&gt;{parse_transform, igor}&lt;/code&gt; （参见 &lt;code&gt;compile:file/2&lt;/code&gt; ），将调用Igor处理源代码，从而自动包含其他源文件。使用此功能时，不会创建或覆盖文件。</target>
        </trans-unit>
        <trans-unit id="d62f1a06265052c97727445916da061a31b46c03" translate="yes" xml:space="preserve">
          <source>Allows an Erlang process to access any currently opened file descriptors used by Erlang. The file descriptor &lt;code&gt;In&lt;/code&gt; can be used for standard input, and the file descriptor &lt;code&gt;Out&lt;/code&gt; for standard output. It is only used for various servers in the Erlang OS (&lt;code&gt;shell&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt;). Hence, its use is limited.</source>
          <target state="translated">允许Erlang进程访问Erlang使用的任何当前打开的文件描述符。文件描述符 &lt;code&gt;In&lt;/code&gt; 可以用于标准输入，文件描述符 &lt;code&gt;Out&lt;/code&gt; 可以用于标准输出。它仅用于Erlang OS中的各种服务器（ &lt;code&gt;shell&lt;/code&gt; 和 &lt;code&gt;user&lt;/code&gt; ）。因此，其使用受到限制。</target>
        </trans-unit>
        <trans-unit id="720d85d8bcd2b0982465cd89217c4403945af062" translate="yes" xml:space="preserve">
          <source>Allows an existing file-descriptor to be used (passed on to the transport protocol).</source>
          <target state="translated">允许使用现有的文件描述符(传递给传输协议)。</target>
        </trans-unit>
        <trans-unit id="5a7d300ab2bf430dd90e7faf7d031bdea72764be" translate="yes" xml:space="preserve">
          <source>Allows compilers built on top of &lt;code&gt;compile&lt;/code&gt; to attach extra compilation metadata to the &lt;code&gt;compile_info&lt;/code&gt; chunk in the generated beam file.</source>
          <target state="translated">允许在编译基础上构建的 &lt;code&gt;compile&lt;/code&gt; 器将额外的编译元数据附加到生成的Beam文件中的 &lt;code&gt;compile_info&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="e2d9ebd39621d33904a794e05cf3bb97eb76cd7e" translate="yes" xml:space="preserve">
          <source>Allows faster access to a file, as no Erlang process is needed to handle the file. However, a file opened in this way has the following limitations:</source>
          <target state="translated">允许更快地访问文件,因为不需要Erlang进程来处理文件。但是,以这种方式打开的文件有以下限制。</target>
        </trans-unit>
        <trans-unit id="11d38a6520a61a4489f42b5d87122e227d5717f7" translate="yes" xml:space="preserve">
          <source>Allows or disallows local reuse of port numbers. By default, reuse is disallowed.</source>
          <target state="translated">允许或不允许本地重用端口号。默认情况下,不允许重用。</target>
        </trans-unit>
        <trans-unit id="ffa1d032886c439e4bec827547cfb0410648a8e3" translate="yes" xml:space="preserve">
          <source>Allows specification of the directory to fetch the data to. If the directory already exists, an error is thrown.</source>
          <target state="translated">允许指定要获取数据的目录。如果该目录已经存在,则抛出错误。</target>
        </trans-unit>
        <trans-unit id="cb4fe77b0bd1f96cbd1b0f77fd621a2567c4e7b4" translate="yes" xml:space="preserve">
          <source>Allows to enable overload checking on the nodes under trace. &lt;code&gt;Module:Function(check)&lt;/code&gt; is performed each &lt;code&gt;MSec&lt;/code&gt; millisecond. If the check returns &lt;code&gt;true&lt;/code&gt;, the tracing is disabled on a specified node.</source>
          <target state="translated">允许在跟踪下的节点上启用过载检查。 &lt;code&gt;Module:Function(check)&lt;/code&gt; 进行各 &lt;code&gt;MSec&lt;/code&gt; 毫秒。如果检查返回 &lt;code&gt;true&lt;/code&gt; ，那么将在指定节点上禁用跟踪。</target>
        </trans-unit>
        <trans-unit id="4d34cd5d35400761bb61a8de2c3b8cac8b75f88f" translate="yes" xml:space="preserve">
          <source>Allows to specify DTD name when it isn't available in the XML document. This option has effect only together with &lt;code&gt;{validation,'dtd'&lt;/code&gt; option.</source>
          <target state="translated">当XML文档中没有DTD名称时，允许指定该名称。此选项仅与 &lt;code&gt;{validation,'dtd'&lt;/code&gt; 选项一起起作用。</target>
        </trans-unit>
        <trans-unit id="47912c360e75c64559b07b272500ccc88ac1869a" translate="yes" xml:space="preserve">
          <source>Allows to specify the order of preference for named curves and to restrict their usage when using a cipher suite supporting them.</source>
          <target state="translated">允许指定命名曲线的优先顺序,并在使用支持命名曲线的密码套件时限制其使用。</target>
        </trans-unit>
        <trans-unit id="f489a56c04187aff8cb1e8fd899369509580cc57" translate="yes" xml:space="preserve">
          <source>Allows user-specific terms in a test specification (described later).</source>
          <target state="translated">允许用户在测试规范中使用特定的术语(后面会介绍)。</target>
        </trans-unit>
        <trans-unit id="a041c6fe34c8772f10490994f72eedc84ac17b8e" translate="yes" xml:space="preserve">
          <source>Allows you to disable chunked transfer-encoding when sending a response to an HTTP/1.1 client. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在向HTTP / 1.1客户端发送响应时，允许您禁用分块传输编码。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7dfd6f2f9e5a386b1eb293fb8cbfe622a3386d" translate="yes" xml:space="preserve">
          <source>Almost all functionality available in the &lt;code&gt;et_viewer&lt;/code&gt; is also available via shortcuts. Which key that has the same effect as selecting a menu entry is shown enclosed in parentheses. For example pressing the key &lt;code&gt;r&lt;/code&gt; is equivalent to selecting the menu entry &lt;code&gt;Viewer-&amp;gt;Refresh&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;et_viewer&lt;/code&gt; 中几乎所有可用的功能也都可以通过快捷方式使用。括号中显示与选择菜单项具有相同作用的键。例如，按 &lt;code&gt;r&lt;/code&gt; 键等效于选择菜单项 &lt;code&gt;Viewer-&amp;gt;Refresh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5ddea236d72017f9bb6251d4cd4ca6ee8c89d93" translate="yes" xml:space="preserve">
          <source>Almost all server functionality has been implemented using an especially crafted server API, which is described in the Erlang Web Server API. This API can be used to enhance the core server functionality, for example with custom logging and authentication.</source>
          <target state="translated">几乎所有的服务器功能都是通过一个特别制作的服务器API来实现的,这在Erlang Web服务器API中有描述。这个API可以用来增强服务器的核心功能,例如自定义日志和认证。</target>
        </trans-unit>
        <trans-unit id="e164535afa87d85e1d8e4d869a83d45ecdea2bd2" translate="yes" xml:space="preserve">
          <source>Alpha converts a pattern (renames variables). Similar to tsubst/1, but only renames variables (including globs).</source>
          <target state="translated">Alpha 转换一个模式(重命名变量)。类似于 tsubst/1,但只重命名变量(包括 globs)。</target>
        </trans-unit>
        <trans-unit id="94e6d313a320186aef8a05e769cde9d6aee31ec8" translate="yes" xml:space="preserve">
          <source>Also a simulation of a busy server. Inserts a delay before a reply is sent.</source>
          <target state="translated">也是对繁忙服务器的模拟。在发送回复之前插入一个延迟。</target>
        </trans-unit>
        <trans-unit id="c107930bfba767a92d8fada4aaa539db162143a4" translate="yes" xml:space="preserve">
          <source>Also environment variable operations used to accept names and values of environment variables containing null characters (integer value zero). This caused operations to silently produce erroneous results. Environment variable names and values containing null characters inside the name or value are now &lt;strong&gt;rejected&lt;/strong&gt; and will cause environment variable operations to fail.</source>
          <target state="translated">同样，环境变量操作用于接受包含空字符（整数值为零）的环境变量的名称和值。这导致操作无提示地产生错误结果。现在&lt;strong&gt;拒绝&lt;/strong&gt;环境变量名称和名称或值中包含空字符的值，这将导致环境变量操作失败。</target>
        </trans-unit>
        <trans-unit id="d9b60222b2c75f1c86ff987c34e09f8cde41625a" translate="yes" xml:space="preserve">
          <source>Also for convenience, record notation is allowed to be used. Records are shorthands for the corresponding tuples:</source>
          <target state="translated">另外,为了方便起见,允许使用记录符号。记录是相应元组的简写。</target>
        </trans-unit>
        <trans-unit id="a3a4b07a56cad329b79384243949038cbc1372cd" translate="yes" xml:space="preserve">
          <source>Also note that Erlang records will be renamed as necessary to avoid non-equivalent definitions using the same record name. This does not work if the source code accesses the name field of such record tuples by &lt;code&gt;element/2&lt;/code&gt; or similar methods. Always use the record syntax to handle record tuples, if possible.</source>
          <target state="translated">还要注意，Erlang记录将根据需要重命名，以避免使用相同记录名的非等效定义。如果源代码通过 &lt;code&gt;element/2&lt;/code&gt; 或类似方法访问此类记录元组的名称字段，则此方法不起作用。如果可能，请始终使用记录语法来处理记录元组。</target>
        </trans-unit>
        <trans-unit id="7ac5f975913185a02359637f04ddfbdfbcd994b3" translate="yes" xml:space="preserve">
          <source>Also note that there are some shell features like history list (control-p and control-n), in line editing (Emacs key bindings) and module and function name completion (tab) if the module is loaded.</source>
          <target state="translated">另外要注意的是,还有一些shell功能,比如历史列表(control-p和control-n)、行内编辑(Emacs键绑定)以及模块和函数名完成(tab),如果模块被加载的话。</target>
        </trans-unit>
        <trans-unit id="8a063b92ca8f32cb5670e7484a2f6224c06de2e7" translate="yes" xml:space="preserve">
          <source>Also note when upgrading a &lt;code&gt;gen_statem&lt;/code&gt;, this function and hence the &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; parameter in the &lt;code&gt;appup&lt;/code&gt; file is not only needed to update the internal state or to act on the &lt;code&gt;Extra&lt;/code&gt; argument. It is also needed if an upgrade or downgrade should change &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, or else the callback mode after the code change will not be honoured, most probably causing a server crash.</source>
          <target state="translated">还要注意，在升级 &lt;code&gt;gen_statem&lt;/code&gt; 时，不仅需要此函数，而且还需要 &lt;code&gt;appup&lt;/code&gt; 文件中的 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 参数来更新内部状态或作用于 &lt;code&gt;Extra&lt;/code&gt; 参数。如果升级或降级应该更改 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，或者代码更改后的回调模式将不被执行，很可能导致服务器崩溃，也需要这样做。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b03a08b970bd32744c558ee650c59b74bf3ec43b" translate="yes" xml:space="preserve">
          <source>Also try the &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;erl_tidy&lt;/a&gt;&lt;/code&gt; module, as follows:</source>
          <target state="translated">还可以尝试 &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;erl_tidy&lt;/a&gt;&lt;/code&gt; 模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="c49a065dda16af9230d583d9a156ea20f71a1f7b" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;errno&lt;/code&gt; values from &lt;code&gt;socket&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; and &lt;code&gt;connect&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; system calls can be propagated into &lt;code&gt;erl_errno&lt;/code&gt;.</source>
          <target state="translated">同样，来自 &lt;code&gt;socket&lt;/code&gt; &lt;strong&gt;（2）&lt;/strong&gt;和 &lt;code&gt;connect&lt;/code&gt; &lt;strong&gt;（2）&lt;/strong&gt;系统调用的 &lt;code&gt;errno&lt;/code&gt; 值可以传播到 &lt;code&gt;erl_errno&lt;/code&gt; 中。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0950deda4048dd3e61bbd230b1ca6f75c0083a70" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;errno&lt;/code&gt; values from &lt;code&gt;socket&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; and &lt;code&gt;connect&lt;/code&gt;&lt;strong&gt;(2)&lt;/strong&gt; system calls may be propagated into &lt;code&gt;erl_errno&lt;/code&gt;.</source>
          <target state="translated">同样，来自 &lt;code&gt;socket&lt;/code&gt; &lt;strong&gt;（2）&lt;/strong&gt;和 &lt;code&gt;connect&lt;/code&gt; &lt;strong&gt;（2）&lt;/strong&gt;系统调用的 &lt;code&gt;errno&lt;/code&gt; 值可以传播到 &lt;code&gt;erl_errno&lt;/code&gt; 中。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89386e204a09fa8d2107f970fae5575cde96ce99" translate="yes" xml:space="preserve">
          <source>Also, a read-only traversal of the source backup can be performed without updating a target backup. If &lt;code&gt;TargetMod==read_only&lt;/code&gt;, no target backup is accessed.</source>
          <target state="translated">此外，可以在不更新目标备份的情况下执行源备份的只读遍历。如果 &lt;code&gt;TargetMod==read_only&lt;/code&gt; ，则不会访问任何目标备份。</target>
        </trans-unit>
        <trans-unit id="35a2ab2594479e34bf702bdcbfc2a6ff056e0ee5" translate="yes" xml:space="preserve">
          <source>Also, a time-out of five seconds has been introduced in the &lt;code&gt;await_result&lt;/code&gt; function. That is, if the server does not reply within five seconds (5000 ms), the client terminates. This is only needed in the logon sequence before the client and the server are linked.</source>
          <target state="translated">同样，在 &lt;code&gt;await_result&lt;/code&gt; 函数中引入了五秒钟的超时。即，如果服务器在五秒钟（5000毫秒）内未回复，则客户端终止。仅在客户端和服务器链接之前，登录顺序中才需要这样做。</target>
        </trans-unit>
        <trans-unit id="fbe49c130871a8ea81b48a336d4846f52b1db188" translate="yes" xml:space="preserve">
          <source>Also, aim for testing everything once, no less, no more. It is not effective having every test case fail only because one function in the interface changed.</source>
          <target state="translated">另外,争取所有东西都测试一次,不能少,不能多。仅仅因为接口中的一个功能发生了变化,就让每个测试用例都失败,是没有效果的。</target>
        </trans-unit>
        <trans-unit id="38092a15de7c4da112bf97ddb70a794cc7c246e0" translate="yes" xml:space="preserve">
          <source>Also, because of fragmentation and prereservation of memory areas, the size of the memory segments containing the dynamically allocated memory blocks can be much larger than the total size of the dynamically allocated memory blocks.</source>
          <target state="translated">另外,由于内存区域的碎片化和预保存,包含动态分配的内存块的内存段的大小可能远远大于动态分配的内存块的总大小。</target>
        </trans-unit>
        <trans-unit id="d5b32fcc26a6a8b9a2395401bc02ead29333f9bb" translate="yes" xml:space="preserve">
          <source>Also, different activity access contexts can be mixed while nesting. However, the dirty ones (&lt;code&gt;async_dirty&lt;/code&gt;, &lt;code&gt;sync_dirty&lt;/code&gt;, and &lt;code&gt;ets&lt;/code&gt;) inherit the transaction semantics if they are called inside a transaction and thus grab locks and use two or three phase commit.</source>
          <target state="translated">同样，嵌套时可以混合使用不同的活动访问上下文。但是，如果脏对象（ &lt;code&gt;async_dirty&lt;/code&gt; ， &lt;code&gt;sync_dirty&lt;/code&gt; 和 &lt;code&gt;ets&lt;/code&gt; ）在事务内部被调用，它们将继承事务语义，从而获取锁并使用两阶段或三阶段提交。</target>
        </trans-unit>
        <trans-unit id="823028d8a3ebcfad8bc2f54c9ca2e8fbebc07b0d" translate="yes" xml:space="preserve">
          <source>Also, for documentation purposes, argument names can be given:</source>
          <target state="translated">另外,为了便于记录,还可以给出参数名称。</target>
        </trans-unit>
        <trans-unit id="d5a32ab36ee173194b5ab198d8e878626de325e7" translate="yes" xml:space="preserve">
          <source>Also, if &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read/3&lt;/code&gt; call fails if the data contains characters larger than 255, which is why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">同样，如果将 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 之外的其他值，则如果数据包含的字符大于255 ，则 &lt;code&gt;read/3&lt;/code&gt; 调用将失败，这就是为什么在读取此类文件时首选模块 &lt;code&gt;io(3)&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="425722573d70397b1c7d94c9000e50ce9ddd142d" translate="yes" xml:space="preserve">
          <source>Also, the API driver functions &lt;code&gt;driver_output*&lt;/code&gt; and &lt;code&gt;driver_vec_to_buf&lt;/code&gt;, &lt;code&gt;driver_alloc/realloc*&lt;/code&gt;, and the &lt;code&gt;driver_*&lt;/code&gt; queue functions were changed to have larger length arguments and return values. This is a lesser problem, as code that passes smaller types gets them auto-converted in the calls, and as long as the driver does not handle sizes that overflow an &lt;code&gt;int&lt;/code&gt;, all will work as before.</source>
          <target state="translated">此外，API驱动函数 &lt;code&gt;driver_output*&lt;/code&gt; 和 &lt;code&gt;driver_vec_to_buf&lt;/code&gt; ， &lt;code&gt;driver_alloc/realloc*&lt;/code&gt; 和 &lt;code&gt;driver_*&lt;/code&gt; 队列功能改变为具有更大的长度参数和返回值。这是一个较小的问题，因为传递较小类型的代码会在调用中将它们自动转换，并且只要驱动程序不处理溢出 &lt;code&gt;int&lt;/code&gt; 的大小，所有内容都将像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="5bf6719ad80d4978b49cbb0963084e0b9ffea279" translate="yes" xml:space="preserve">
          <source>Also, the Erlang implementation requires understanding of concepts that were never an issue for many (Erlang) programmers. To understand and use Unicode characters requires that you study the subject thoroughly, even if you are an experienced programmer.</source>
          <target state="translated">另外,Erlang的实现需要理解一些概念,而这些概念对于很多(Erlang)程序员来说从来都不是问题。要理解和使用Unicode字符,需要你深入研究这个问题,即使你是一个经验丰富的程序员。</target>
        </trans-unit>
        <trans-unit id="97ffcd43fe119d65b1c38d259f0ad035db9d9f66" translate="yes" xml:space="preserve">
          <source>Also, the toolkit does not support dependencies between sub-agents. A sub-agent should by definition be stand alone and it is therefore not good design to create dependencies between them.</source>
          <target state="translated">此外,该工具包不支持子代理之间的依赖关系。根据定义,子代理应该是独立的,因此在它们之间建立依赖关系不是好的设计。</target>
        </trans-unit>
        <trans-unit id="36abf7ef6c434f71bc62120ad73dd9f305fae2ba" translate="yes" xml:space="preserve">
          <source>Also, this code compares lists elements using the &quot;&lt;code&gt;==&lt;/code&gt;&quot; operator, while &quot;&lt;code&gt;--&lt;/code&gt;&quot; uses the &quot;&lt;code&gt;=:=&lt;/code&gt;&quot; operator. If that difference is important, &lt;code&gt;sets&lt;/code&gt; can be used instead of &lt;code&gt;gb_sets&lt;/code&gt;, but &lt;code&gt;sets:from_list/1&lt;/code&gt; is much slower than &lt;code&gt;gb_sets:from_list/1&lt;/code&gt; for long lists.</source>
          <target state="translated">另外，此代码使用&amp;ldquo; &lt;code&gt;==&lt;/code&gt; &amp;rdquo;运算符比较列表元素，而&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;使用&amp;ldquo; &lt;code&gt;=:=&lt;/code&gt; &amp;rdquo;运算符。如果这种差异是很重要的， &lt;code&gt;sets&lt;/code&gt; 可以用来代替 &lt;code&gt;gb_sets&lt;/code&gt; ，但 &lt;code&gt;sets:from_list/1&lt;/code&gt; 比慢得多 &lt;code&gt;gb_sets:from_list/1&lt;/code&gt; 的长列表。</target>
        </trans-unit>
        <trans-unit id="6b487a502989be65a999a414931c10e73d9e958d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;OptionList == []&lt;/code&gt;, only visible nodes, that is, nodes that appear in the result of &lt;code&gt;erlang:nodes/0&lt;/code&gt;, are monitored.</source>
          <target state="translated">另外，当 &lt;code&gt;OptionList == []&lt;/code&gt; ，仅监视可见节点，即出现在 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 结果中的节点。</target>
        </trans-unit>
        <trans-unit id="7c7e2f70e0a7fca68066437851c1d0da8c3f758e" translate="yes" xml:space="preserve">
          <source>Also, when a table is opened this file is read, if it exists.</source>
          <target state="translated">另外,当一个表被打开时,如果存在的话,这个文件也会被读取。</target>
        </trans-unit>
        <trans-unit id="bf226a59dfe6aed5d51c1238c21cc12d02623322" translate="yes" xml:space="preserve">
          <source>Alternation. It matches either &lt;code&gt;r1&lt;/code&gt; or &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">交替。它匹配 &lt;code&gt;r1&lt;/code&gt; 或 &lt;code&gt;r2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d3884e669febf89019a2dd3d1f7118c5ae8dd7e" translate="yes" xml:space="preserve">
          <source>Alternation. Matches one of the alternatives.</source>
          <target state="translated">替代品。匹配其中一个备选方案。</target>
        </trans-unit>
        <trans-unit id="b0e0df8a7d7ac3abd4437e1480f042a0637f8891" translate="yes" xml:space="preserve">
          <source>Alternative &lt;code&gt;ab&lt;/code&gt; is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps.</source>
          <target state="translated">找到替代 &lt;code&gt;ab&lt;/code&gt; ，结果为[{1,2}，{1,2}]。结果被添加到结果列表中，并且搜索字符串中的位置前进了两个步骤。</target>
        </trans-unit>
        <trans-unit id="388bde91034a0c2bd5c6b83f406e6d950cb39478" translate="yes" xml:space="preserve">
          <source>Alternative syntax for acquisition of table locks is as follows:</source>
          <target state="translated">获取表锁的替代语法如下。</target>
        </trans-unit>
        <trans-unit id="de359fc26767f6609fd33d4bab9ab9ec84302a3a" translate="yes" xml:space="preserve">
          <source>Alternative way to stop the HTTP client profile:</source>
          <target state="translated">停止HTTP客户端配置文件的替代方式。</target>
        </trans-unit>
        <trans-unit id="3b8239e68048624328c3887db9856779071451e0" translate="yes" xml:space="preserve">
          <source>Alternative:</source>
          <target state="translated">Alternative:</target>
        </trans-unit>
        <trans-unit id="84eb863ce8c5fe0eaf266247b00e7b639109efa7" translate="yes" xml:space="preserve">
          <source>Alternatively you download MinGW and MSYS. You'll find the latest installer at:</source>
          <target state="translated">或者下载MinGW和MSYS。你可以在以下网站找到最新的安装程序。</target>
        </trans-unit>
        <trans-unit id="2a9a5b357a1ebe1596911f8227c3f50733821b16" translate="yes" xml:space="preserve">
          <source>Alternatively, application configuration parameters can be added or updated in &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">或者，可以在 &lt;code&gt;sys.config&lt;/code&gt; 中添加或更新应用程序配置参数。</target>
        </trans-unit>
        <trans-unit id="1d257655b31583a29c42cb081673cc370da4eb39" translate="yes" xml:space="preserve">
          <source>Alternatively, for more control, use functions &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另外，要获得更多控制，请使用功能 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d20174a3ef0c0e03812655f5a1538626e3ef7e1" translate="yes" xml:space="preserve">
          <source>Alternatively, setting flags to &lt;code&gt;EI_FORCE&lt;/code&gt; causes a full backup to be done, and &lt;code&gt;EI_NOPURGE&lt;/code&gt; causes the deleted objects to be left in the registry afterwards. These can be bitwise OR'ed together if both behaviors are desired. If &lt;code&gt;EI_NOPURGE&lt;/code&gt; was specified, &lt;code&gt;ei_reg_purge()&lt;/code&gt; can be used to explicitly remove the deleted items from the registry later.</source>
          <target state="translated">或者，将标志设置为 &lt;code&gt;EI_FORCE&lt;/code&gt; 会导致进行完整备份，而 &lt;code&gt;EI_NOPURGE&lt;/code&gt; 会导致删除的对象随后留在注册表中。如果需要两种行为，可以将这些按位或在一起。如果 &lt;code&gt;EI_NOPURGE&lt;/code&gt; 指定， &lt;code&gt;ei_reg_purge()&lt;/code&gt; 可以用来明确地从注册表中删除后删除的项目。</target>
        </trans-unit>
        <trans-unit id="eda106df891b543c9d37c11d60d93578eda797a2" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;erl_send()&lt;/code&gt; and &lt;code&gt;erl_receive_msg&lt;/code&gt;, which handle the encoding and decoding of messages transparently.</source>
          <target state="translated">另外，您可以使用 &lt;code&gt;erl_send()&lt;/code&gt; 和 &lt;code&gt;erl_receive_msg&lt;/code&gt; ，它们透明地处理消息的编码和解码。</target>
        </trans-unit>
        <trans-unit id="8a36a8fbf04bc6a8060ec964f113d3388e9e6727" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Common Test&lt;/code&gt; was created primarily for black-box testing, nothing prevents it from working perfectly as a white-box testing tool as well. This is especially true when the application to test is written in Erlang. Then the test ports are easily realized with Erlang function calls.</source>
          <target state="translated">尽管 &lt;code&gt;Common Test&lt;/code&gt; 主要是为黑盒测试创建的，但没有什么可以阻止它完美地用作白盒测试工具。当使用Erlang编写要测试的应用程序时，尤其如此。然后，通过Erlang函数调用可以轻松实现测试端口。</target>
        </trans-unit>
        <trans-unit id="4b19755925d10feb1c1eeb84ec413b87f2a2d0e8" translate="yes" xml:space="preserve">
          <source>Although EUnit uses many preprocessor macros, they have been designed to be as nonintrusive as possible, and should not cause conflicts with existing code. Adding EUnit tests to a module should thus not normally require changing existing code. Furthermore, tests that only exercise the exported functions of a module can always be placed in a completely separate module, avoiding any conflicts entirely.</source>
          <target state="translated">尽管EUnit使用了许多预处理程序宏,但它们被设计成尽可能的非侵入性,并且不会与现有的代码产生冲突。因此,在一个模块中添加EUnit测试通常不需要改变现有的代码。此外,只行使模块的导出函数的测试总是可以放在一个完全独立的模块中,完全避免了任何冲突。</target>
        </trans-unit>
        <trans-unit id="16e985c50acb7aa3cc2e37887e81edfb84b36580" translate="yes" xml:space="preserve">
          <source>Although Erlang can handle Unicode data in many forms does not automatically mean that the content of any file can be Unicode text. The external entities, such as ports and I/O servers, are not generally Unicode capable.</source>
          <target state="translated">虽然Erlang可以处理多种形式的Unicode数据,但并不意味着任何文件的内容都能自动成为Unicode文本。外部实体,如端口和I/O服务器,一般不具备Unicode功能。</target>
        </trans-unit>
        <trans-unit id="02df0b028081655673738d27b03c581fc80907e4" translate="yes" xml:space="preserve">
          <source>Although Erlang drivers in general can be beyond the scope of this section, a brief introduction seems to be in place.</source>
          <target state="translated">虽然一般的Erlang驱动可能超出了本节的范围,但似乎已经有了一个简单的介绍。</target>
        </trans-unit>
        <trans-unit id="145c19dfbd3603b0f1f5d0df7751ed8d04c50799" translate="yes" xml:space="preserve">
          <source>Although all the functionality of EUnit is available even without the use of preprocessor macros, the EUnit header file defines a number of such macros in order to make it as easy as possible to write unit tests as compactly as possible and without getting too many details in the way.</source>
          <target state="translated">虽然EUnit的所有功能在不使用预处理器宏的情况下也可以使用,但EUnit头文件定义了一些这样的宏,以使其尽可能紧凑地编写单元测试,而不至于有太多的细节阻碍。</target>
        </trans-unit>
        <trans-unit id="288b1873eb386778abf8c7efb5abf1c61cbff2fe" translate="yes" xml:space="preserve">
          <source>Although it would be both pointless and counterproductive to use segmentation on a transport that already does this (e.g. TCP), the megaco application does not check this. Instead, it is up to the user to configure this properly.</source>
          <target state="translated">虽然在已经做了分段的传输上使用分段是没有意义的,也是适得其反的,但是megaco应用程序并不检查这个。相反,这要由用户来正确配置。</target>
        </trans-unit>
        <trans-unit id="beb0a28a74c40d09218865dad1a734397c647414" translate="yes" xml:space="preserve">
          <source>Although public key algorithms are supported in FIPS mode they can only be used with secure key sizes. The Security Policy requires the following minimum values:</source>
          <target state="translated">虽然FIPS模式下支持公钥算法,但它们只能用于安全密钥大小。安全策略要求以下最小值。</target>
        </trans-unit>
        <trans-unit id="bc4daacf4342e7c4815a182117afe540cdf564a1" translate="yes" xml:space="preserve">
          <source>Although the garbage collector grows the heap, it grows it step-by-step, which is more costly than directly establishing a larger heap when the process is spawned.</source>
          <target state="translated">虽然垃圾收集器会增长堆,但它是一步步增长的,这比进程产生时直接建立一个更大的堆的成本要高。</target>
        </trans-unit>
        <trans-unit id="24878073b1b7f8b78f02e6ee00d8bf88d852b349" translate="yes" xml:space="preserve">
          <source>Although the options are described in a Unix-like format, the case of the options or commands is not relevant, and both character &quot;/&quot; and &quot;-&quot; can be used for options.</source>
          <target state="translated">虽然选项是以类似Unix的格式来描述的,但选项或命令的大小写并不相关,字符&quot;/&quot;和&quot;-&quot;都可以用于选项。</target>
        </trans-unit>
        <trans-unit id="bce09f2137d6fc334364eda633d224f186c26d70" translate="yes" xml:space="preserve">
          <source>Although the program is located together with files specific to the emulator version, it is not expected to be specific to the emulator version. The release handler does &lt;strong&gt;not&lt;/strong&gt; change option &lt;code&gt;-machine&lt;/code&gt; to &lt;code&gt;erlsrv&lt;/code&gt; during emulator restart. Locate the (possibly customized) &lt;code&gt;start_erl&lt;/code&gt; program so that it is not overwritten during upgrade.</source>
          <target state="translated">尽管程序与特定于仿真器版本的文件一起放置，但是预期它并不特定于仿真器版本。发布处理器并&lt;strong&gt;没有&lt;/strong&gt;选择改变 &lt;code&gt;-machine&lt;/code&gt; 到 &lt;code&gt;erlsrv&lt;/code&gt; 模拟器重启过程中。找到（可能是自定义的） &lt;code&gt;start_erl&lt;/code&gt; 程序，以使其在升级过程中不会被覆盖。</target>
        </trans-unit>
        <trans-unit id="3f57a9d4c00bcaabefc52fe8a80642733e554720" translate="yes" xml:space="preserve">
          <source>Although the record syntax is used, it is still hard to read and even harder to write. The first element of the tuple, &lt;code&gt;#emp{empno = '$1', dept = sales, _='_'}&lt;/code&gt;, tells what to match. Elements not matching this are not returned, as in the &lt;code&gt;ets:match/2&lt;/code&gt; example. The second element, the empty list, is a list of guard expressions, which we do not need. The third element is the list of expressions constructing the return value (in ETS this is almost always a list containing one single term). In our case &lt;code&gt;'$1'&lt;/code&gt; is bound to the employee number in the head (first element of the tuple), and hence the employee number is returned. The result is &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt;, as in the &lt;code&gt;ets:foldr/3&lt;/code&gt; example, but the result is retrieved much more efficiently in terms of execution speed and memory consumption.</source>
          <target state="translated">尽管使用了记录语法，但仍然很难阅读甚至难以编写。元组的第一个元素 &lt;code&gt;#emp{empno = '$1', dept = sales, _='_'}&lt;/code&gt; 告诉要匹配的内容。不匹配此元素的元素不会返回，如 &lt;code&gt;ets:match/2&lt;/code&gt; 示例中所示。第二个元素，空列表，是不需要的保护表达式列表。第三个元素是构成返回值的表达式的列表（在ETS中，这几乎总是一个包含一个单项的列表）。在我们的例子中， &lt;code&gt;'$1'&lt;/code&gt; 绑定到头部（元组的第一个元素）的雇员编号，因此返回雇员编号。结果为 &lt;code&gt;[&quot;011103&quot;,&quot;076324&quot;]&lt;/code&gt; ，如 &lt;code&gt;ets:foldr/3&lt;/code&gt; 所示 例如，但是就执行速度和内存消耗而言，结果检索效率更高。</target>
        </trans-unit>
        <trans-unit id="2efab97f3a7a5d8ce0a89e59cc48828bf99d33d8" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;binary()&lt;/code&gt; when used as return value</source>
          <target state="translated">用作返回值时始终为 &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92fdd4e6d9d913fcd655491ab0c7675897f9b7ef" translate="yes" xml:space="preserve">
          <source>Always a back reference</source>
          <target state="translated">始终是一个反向参考</target>
        </trans-unit>
        <trans-unit id="34df78fa84d9ab6d470efe918d9b6fe7aa623768" translate="yes" xml:space="preserve">
          <source>Always a tab</source>
          <target state="translated">总是一个标签</target>
        </trans-unit>
        <trans-unit id="a4786c7c8c425f21c582ab746681367ee698691a" translate="yes" xml:space="preserve">
          <source>Always derefrence aliases.</source>
          <target state="translated">总是贬低别名。</target>
        </trans-unit>
        <trans-unit id="f8137d77147791c2cdd31baefa8bf6fa8cd8ceff" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;ok&lt;/code&gt;, regardless of the validity of each individual &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">始终返回 &lt;code&gt;ok&lt;/code&gt; ，无论每个 &lt;code&gt;Dir&lt;/code&gt; 的有效性如何。</target>
        </trans-unit>
        <trans-unit id="27f040498856798609fee3be2f41e6c84980a8f5" translate="yes" xml:space="preserve">
          <source>Always use this function instead of the BIF for processes started using &lt;code&gt;proc_lib&lt;/code&gt; functions.</source>
          <target state="translated">对于使用 &lt;code&gt;proc_lib&lt;/code&gt; 函数启动的进程，始终使用此函数而不是BIF 。</target>
        </trans-unit>
        <trans-unit id="1816d6498b5f2b91f67cb09f0eef413cb5e709bf" translate="yes" xml:space="preserve">
          <source>An  &lt;strong id=&quot;analyzed_module&quot;&gt;analyzed module&lt;/strong&gt; is a module that has been added to an Xref server together with its module data. A  &lt;strong id=&quot;library_module&quot;&gt;library module&lt;/strong&gt; is a module located in some directory mentioned in the  &lt;strong id=&quot;library_path&quot;&gt;library path&lt;/strong&gt;. A library module is said to be used if some of its exported functions are used by some analyzed module. An  &lt;strong id=&quot;unknown_module&quot;&gt;unknown module&lt;/strong&gt; is a module that is neither an analyzed module nor a library module, but whose exported functions are used by some analyzed module. An  &lt;strong id=&quot;unknown_function&quot;&gt;unknown function&lt;/strong&gt; is a used function that is neither local or exported by any analyzed module nor exported by any library module. An  &lt;strong id=&quot;undefined_function&quot;&gt;undefined function&lt;/strong&gt; is an externally used function that is not exported by any analyzed module or library module. With this notion, a local function can be an undefined function, namely if it is externally used from some module. All unknown functions are also undefined functions; there is a &lt;code&gt;&lt;a href=&quot;xref_chapter#venn2&quot;&gt;figure&lt;/a&gt;&lt;/code&gt; in the User's Guide that illustrates this relationship.</source>
          <target state="translated">一个 &lt;strong id=&quot;analyzed_module&quot;&gt;分析模块&lt;/strong&gt;是已经用其模块的数据添加到外部参照服务器一起的模块。一个 &lt;strong id=&quot;library_module&quot;&gt;库模块&lt;/strong&gt;是位于中提到的一些目录中的模块 &lt;strong id=&quot;library_path&quot;&gt;库路径&lt;/strong&gt;。如果某个分析模块使用了某些导出功能，则可以说使用了库模块。一个 &lt;strong id=&quot;unknown_module&quot;&gt;未知模块&lt;/strong&gt;是一个模块，其既不是分析模块，也不是一个库模块，但其导出的函数由一些分析模块被使用。一个 &lt;strong id=&quot;unknown_function&quot;&gt;未知功能&lt;/strong&gt;是一个用函数既不是本地或通过任何分析模块导出，也没有通过任何库模块导出。一个 &lt;strong id=&quot;undefined_function&quot;&gt;未定义功能&lt;/strong&gt;是外部使用的函数，任何分析的模块或库模块都不会导出该函数。使用此概念，局部函数可以是未定义的函数，即，是否从某个模块外部使用它。所有未知函数也是未定义函数；用户指南中有一张 &lt;code&gt;&lt;a href=&quot;xref_chapter#venn2&quot;&gt;figure&lt;/a&gt;&lt;/code&gt; 说明了这种关系。</target>
        </trans-unit>
        <trans-unit id="61d493bfba03f3650f2161ca9afdcc61c11c1f50" translate="yes" xml:space="preserve">
          <source>An &quot;electric&quot; command is a character that in addition to just inserting the character performs some type of action. For example the &quot;;&quot; character is typed in a situation where is ends a function clause a new function header is generated. The electric commands are as follows:</source>
          <target state="translated">一个 &quot;电 &quot;命令是一个字符,除了插入字符外,还执行某种类型的动作。例如&quot;;&quot;字符是在结束一个函数子句的情况下输入的,一个新的函数头就会生成。电动命令如下。</target>
        </trans-unit>
        <trans-unit id="6226e0305af70826bf5fe3ce4b1308a84190ed32" translate="yes" xml:space="preserve">
          <source>An &quot;index.html&quot; page is written for each test run (that is, stored in the &lt;code&gt;ct_run&lt;/code&gt; directory tagged with node name, date, and time). This file provides an overview of all individual tests performed in the same test run. The test names follow the following convention:</source>
          <target state="translated">每次测试运行都会写入一个&amp;ldquo; index.html&amp;rdquo;页面（即，存储在 &lt;code&gt;ct_run&lt;/code&gt; 目录中，该目录标记有节点名称，日期和时间）。该文件提供了在同一测试运行中执行的所有单个测试的概述。测试名称遵循以下约定：</target>
        </trans-unit>
        <trans-unit id="00e6ea986b63d5c9739d49f4c3238bab97235630" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a0395f6f1fbeee27182938ba0839ebfac3dc6b9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#n_ary_relation&quot;&gt;n-ary relation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一 &lt;code&gt;&lt;a href=&quot;#n_ary_relation&quot;&gt;n-ary relation&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ad952e4eb8fcd79b39f9d7f3056d23ad1340548" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;ordered set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;ordered set&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f732501fb2f351bec1b39a9b35f38cdddbe7895e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; of unordered sets.</source>
          <target state="translated">一 &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; 的无序集。</target>
        </trans-unit>
        <trans-unit id="abe550712a0e6ae829a57ff7d8dfef218ca5d4e5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;#sets_definition&quot;&gt;unordered set&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0255682239807b3289c234495e03c8b41192e931" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Event&lt;/code&gt; may be an action performed by one single actor (blue text label) or it may involve two actors and is then depicted as an arrow directed from one actor to another (red text label). Details of an &lt;code&gt;Event&lt;/code&gt; can be shown by clicking (press and release the mouse button 1) on the event label text or on the arrow. When doing that a &lt;code&gt;Contents Viewer&lt;/code&gt; window pops up. It may look like this:</source>
          <target state="translated">一个 &lt;code&gt;Event&lt;/code&gt; 可以是由一个单一的演员（蓝色文本标签）执行的动作，或者其可以包括两个行动者，然后描绘为箭头从一个行动者引导到另一个（红色文本标签）。单击事件标签文本或箭头上的（按下并释放鼠标按钮1），可以显示 &lt;code&gt;Event&lt;/code&gt; 详细信息。这样做时，将弹出&amp;ldquo; &lt;code&gt;Contents Viewer&lt;/code&gt; 窗口。它可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="0255b57e28b30c83aed0be71d9a37eb90b3506e9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;FTP&lt;/code&gt; client.</source>
          <target state="translated">一个 &lt;code&gt;FTP&lt;/code&gt; 客户端。</target>
        </trans-unit>
        <trans-unit id="3fb173ebbce3795b42d50041e455d5925eea1573" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Instantiator&lt;/code&gt; function receives the same value as the &lt;code&gt;Cleanup&lt;/code&gt; function, i.e., the value returned by the &lt;code&gt;Setup&lt;/code&gt; function. It should then behave much like a generator (see &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt;), and return a test set whose tests have been &lt;strong&gt;instantiated&lt;/strong&gt; with the given value. A special case is the syntax &lt;code&gt;{with, [AbstractTestFun]}&lt;/code&gt; which represents an instantiator function that distributes the value over a list of unary functions; see &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;{with, X, [...]}&lt;/code&gt; for more details.</source>
          <target state="translated">一个 &lt;code&gt;Instantiator&lt;/code&gt; 函数接收相同的值 &lt;code&gt;Cleanup&lt;/code&gt; 功能，即，由返回的值 &lt;code&gt;Setup&lt;/code&gt; 功能。然后，它的行为应类似于生成器（请参见 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; ），并返回已使用给定值&lt;strong&gt;实例化&lt;/strong&gt;其测试的测试集。一种特殊情况是语法 &lt;code&gt;{with, [AbstractTestFun]}&lt;/code&gt; ，它表示实例化函数，该函数将值分配到一元函数列表上。有关更多详细信息 &lt;code&gt;{with, X, [...]}&lt;/code&gt; 请参见基 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; ：{with，X，[...]}。</target>
        </trans-unit>
        <trans-unit id="616e10ae1a8e1fb39bdb912ebeef6ab5ca6b40b1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;accept_callback()&lt;/code&gt; will be called and the boolean return value &lt;code&gt;true&lt;/code&gt; will make the client accept the Host Key. A return value of &lt;code&gt;false&lt;/code&gt; will make the client to reject the Host Key and as a result the connection will be closed. The arguments to the fun are:</source>
          <target state="translated">一个 &lt;code&gt;accept_callback()&lt;/code&gt; 将被调用，布尔返回值为 &lt;code&gt;true&lt;/code&gt; 会令客户接受该主机密钥。返回值 &lt;code&gt;false&lt;/code&gt; 将使客户端拒绝主机密钥，结果将关闭连接。有趣的参数是：</target>
        </trans-unit>
        <trans-unit id="413cf6d7a307b2b9673ad27e8dbed416e9a8cd0b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;atom&lt;/code&gt;, defaults to &lt;code&gt;megaco_pretty_text_encoder&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;atom&lt;/code&gt; ，默认为 &lt;code&gt;megaco_pretty_text_encoder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa860461448cf61fc6c4412f7dfeeae18b2f5502" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;atom&lt;/code&gt;, defaults to &lt;code&gt;megaco_tcp&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;atom&lt;/code&gt; ，默认为 &lt;code&gt;megaco_tcp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51e3e48053897de71e5e9525b4fac400d5d8b48f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;boolean&lt;/code&gt;, default is true.</source>
          <target state="translated">一个 &lt;code&gt;boolean&lt;/code&gt; ，默认为true。</target>
        </trans-unit>
        <trans-unit id="a54f797ba37540946ac0de61f8e73f6a99a9bc1c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;boolean&lt;/code&gt;, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;boolean&lt;/code&gt; ，默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7304f44642298f3032f1c5b607dd7eafc4c3c8ed" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval&lt;/code&gt; term for the node and &lt;code&gt;startup_functions&lt;/code&gt; in the &lt;code&gt;node_start&lt;/code&gt; options list can be specified. In this case, the node is started first, then the &lt;code&gt;startup_functions&lt;/code&gt; are executed, and finally functions specified with &lt;code&gt;eval&lt;/code&gt; are called.</source>
          <target state="translated">一个 &lt;code&gt;eval&lt;/code&gt; 为节点和期限 &lt;code&gt;startup_functions&lt;/code&gt; 在 &lt;code&gt;node_start&lt;/code&gt; 选项列表可以指定。在这种情况下，首先启动节点，然后执行 &lt;code&gt;startup_functions&lt;/code&gt; ，最后调用用 &lt;code&gt;eval&lt;/code&gt; 指定的函数。</target>
        </trans-unit>
        <trans-unit id="8cf0639c1fa382f7a371e1fb9d74d243f730a9ec" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_cookie&lt;/code&gt; is the cookie expected to be used by another node when communicating with us, so that &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; corresponds with &lt;code&gt;B&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt;. Below the function &lt;code&gt;in_cookie(Node)&lt;/code&gt; returns the current node's &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;in_cookie&lt;/code&gt; 是预期与我们通信时要由另一个节点所使用的饼干，使 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;in_cookie&lt;/code&gt; 为 &lt;code&gt;B&lt;/code&gt; 相当于与 &lt;code&gt;B&lt;/code&gt; s'的 &lt;code&gt;out_cookie&lt;/code&gt; 为 &lt;code&gt;A&lt;/code&gt; 。下面的函数 &lt;code&gt;in_cookie(Node)&lt;/code&gt; 返回当前节点的 &lt;code&gt;in_cookie&lt;/code&gt; 的 &lt;code&gt;Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d7e048e19b245a7755b67de29c724332d234fef" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;install&lt;/code&gt; program that can take multiple file names.</source>
          <target state="translated">可以采用多个文件名的 &lt;code&gt;install&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="dc1cc59f23e31d3f2faabd0e06404fca41020443" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer()&lt;/code&gt; representing a valid ISO Latin-1 character (0-255).</source>
          <target state="translated">代表有效的ISO Latin-1字符（0-255）的 &lt;code&gt;integer()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1e0bac35dea3f1f84ddba60032770d90571b70a9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, default is 1.</source>
          <target state="translated">一个 &lt;code&gt;integer&lt;/code&gt; ，默认值为1。</target>
        </trans-unit>
        <trans-unit id="873fbda47245c24d2fb8c42c588854a5bbbe1999" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 0.</source>
          <target state="translated">一个 &lt;code&gt;integer&lt;/code&gt; ，默认为0。</target>
        </trans-unit>
        <trans-unit id="0db32e18586f2823cb1832056d1faf59a25ee88d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 10.</source>
          <target state="translated">一个 &lt;code&gt;integer&lt;/code&gt; ，默认为10。</target>
        </trans-unit>
        <trans-unit id="be7525ff96efc958521012096b0629c32d985beb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt;, defaults to 2048.</source>
          <target state="translated">一个 &lt;code&gt;integer&lt;/code&gt; ，默认为2048。</target>
        </trans-unit>
        <trans-unit id="226fe72bb662892694081c7e4669e49ce4dfb607" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ok&lt;/code&gt; return value only means that &lt;code&gt;sanity_check/0&lt;/code&gt; did not find any issues, &lt;strong&gt;not&lt;/strong&gt; that no issues exist.</source>
          <target state="translated">一个 &lt;code&gt;ok&lt;/code&gt; 的返回值仅意味着 &lt;code&gt;sanity_check/0&lt;/code&gt; 没有发现任何问题，&lt;strong&gt;不&lt;/strong&gt;存在任何问题。</target>
        </trans-unit>
        <trans-unit id="cb144d37fcad9dec67a783fea0c08715340b0e47" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ordered_set&lt;/code&gt; only guarantees that objects are processed in &lt;strong&gt;key&lt;/strong&gt; order. Results from functions such as &lt;code&gt;ets:select/2&lt;/code&gt; appear in &lt;strong&gt;key&lt;/strong&gt; order even if the key is not included in the result.</source>
          <target state="translated">一个 &lt;code&gt;ordered_set&lt;/code&gt; 只能保证对象在处理&lt;strong&gt;关键&lt;/strong&gt;顺序。即使没有将键包含在结果中，例如 &lt;code&gt;ets:select/2&lt;/code&gt; 之类的函数的结果也会以&lt;strong&gt;键&lt;/strong&gt;顺序显示。</target>
        </trans-unit>
        <trans-unit id="1ac32ce0e6bfa96623b07134d73e1a74a678a422" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;other_error()&lt;/code&gt;, indicates some other error such as timeout.</source>
          <target state="translated">一个 &lt;code&gt;other_error()&lt;/code&gt; ，表示一些其它错误，例如超时。</target>
        </trans-unit>
        <trans-unit id="c055e209749d7630d0667a2b7111dd1440c4439d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;other_reason()&lt;/code&gt;, indicates some other error such as:</source>
          <target state="translated">一个 &lt;code&gt;other_reason()&lt;/code&gt; ，表示一些其它错误，例如：</target>
        </trans-unit>
        <trans-unit id="894fd973b7b8b5b01a93ed5aca695081618b3394" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;out_cookie&lt;/code&gt; is the cookie used in outgoing communication to a certain node, so that &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; is to correspond with &lt;code&gt;B&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; and conversely. &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt;'s &lt;code&gt;in_cookie&lt;/code&gt; for &lt;code&gt;B&lt;/code&gt; need &lt;strong&gt;not&lt;/strong&gt; be the same. Below the function &lt;code&gt;out_cookie(Node)&lt;/code&gt; returns the current node's &lt;code&gt;out_cookie&lt;/code&gt; for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;out_cookie&lt;/code&gt; 是在传出通信中使用到某个节点的饼干，使 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;out_cookie&lt;/code&gt; 为 &lt;code&gt;B&lt;/code&gt; 是与对应 &lt;code&gt;B&lt;/code&gt; 的 &lt;code&gt;in_cookie&lt;/code&gt; 对 &lt;code&gt;A&lt;/code&gt; 反之亦然。 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;out_cookie&lt;/code&gt; 对 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; S' &lt;code&gt;in_cookie&lt;/code&gt; 为 &lt;code&gt;B&lt;/code&gt; 需要&lt;strong&gt;不&lt;/strong&gt;相同。下面的函数 &lt;code&gt;out_cookie(Node)&lt;/code&gt; 返回当前节点的 &lt;code&gt;out_cookie&lt;/code&gt; 的 &lt;code&gt;Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7eef5074a9774a00c738e43d74f620a383d53d0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ssl_options&lt;/code&gt; list must be specified if and only if the transport in question has set &lt;code&gt;Inband-Security-Id&lt;/code&gt; to 1 (&lt;code&gt;TLS&lt;/code&gt;), as specified to either &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt;, so that the transport process will receive notification of whether or not to commence with a TLS handshake following capabilities exchange. Failing to specify an options list on a TLS-capable transport for which TLS is negotiated will cause TLS handshake to fail. Failing to specify TLS capability when &lt;code&gt;ssl_options&lt;/code&gt; has been specified will cause the transport process to wait for a notification that will not be forthcoming, which will eventually cause the RFC 3539 watchdog to take down the connection.</source>
          <target state="translated">仅在所讨论的传输将 &lt;code&gt;ssl_options&lt;/code&gt; &lt;code&gt;Inband-Security-Id&lt;/code&gt; 为1（ &lt;code&gt;TLS&lt;/code&gt; ）时，才必须指定ssl_options列表，并且将其指定为 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; ，以便传输过程将接收到进行功能交换后是否以TLS握手开始的通知。未能在支持TLS的传输上指定经过协商的TLS的选项列表将导致TLS握手失败。 &lt;code&gt;ssl_options&lt;/code&gt; 时未指定TLS功能 已指定将导致传输过程等待将不会出现的通知，最终将导致RFC 3539看门狗断开连接。</target>
        </trans-unit>
        <trans-unit id="5953af02f70fe1bd6cb42949e24f0078af4d3ff4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;{outstream, Id}&lt;/code&gt; tuple in the &lt;code&gt;transport_data&lt;/code&gt; field of a outgoing diameter_packet record sets the outbound stream on which the message is sent, modulo the negotiated number of outbound streams. Any other value causes successive such sends to cycle though all outbound streams.</source>
          <target state="translated">传出diameter_packet记录的 &lt;code&gt;transport_data&lt;/code&gt; 字段中的 &lt;code&gt;{outstream, Id}&lt;/code&gt; 元组设置了在其上发送消息的出站流，以协商出站流的数量为模。任何其他值都会导致连续的此类发送循环通过所有出站流。</target>
        </trans-unit>
        <trans-unit id="d5fa362d0f65e987c4b8318080cab175e37513ad" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;acyclic_digraph&quot;&gt;acyclic digraph&lt;/strong&gt; is a digraph without cycles.</source>
          <target state="translated">一个&lt;strong id=&quot;acyclic_digraph&quot;&gt;无环有向图&lt;/strong&gt;是无环有向图。</target>
        </trans-unit>
        <trans-unit id="c3aa68fd8d0814a5d205c457e0d32e4bc17b0175" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;arborescence&quot;&gt;arborescence&lt;/strong&gt; is an acyclic digraph with a vertex V, the &lt;strong id=&quot;root&quot;&gt;root&lt;/strong&gt;, such that there is a unique path from V to every other vertex of G.</source>
          <target state="translated">的&lt;strong id=&quot;arborescence&quot;&gt;树状结构&lt;/strong&gt;是无环有向图具有顶点V，该&lt;strong id=&quot;root&quot;&gt;根&lt;/strong&gt;，使得存在从V到G的每一个其他顶点的唯一路径</target>
        </trans-unit>
        <trans-unit id="742a6d0f8438c960e1610deecf0bc0fce6d56d78" translate="yes" xml:space="preserve">
          <source>An &lt;strong id=&quot;external_set&quot;&gt;external set&lt;/strong&gt; is an element of the range of Sets.</source>
          <target state="translated">一个&lt;strong id=&quot;external_set&quot;&gt;外部组&lt;/strong&gt;是集的范围的元件。</target>
        </trans-unit>
        <trans-unit id="edf6ff8399e6bc41f3e349775438bc0fb18b7111" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;embedded target system&lt;/strong&gt; where there is also support for logging output from the system to file for later inspection, and where the system can be started automatically at boot time.</source>
          <target state="translated">一个&lt;strong&gt;嵌入式目标系统&lt;/strong&gt;，其中也有用于记录从系统输出到文件供以后检查的支持，并在该系统可以在开机时自动启动。</target>
        </trans-unit>
        <trans-unit id="380c35ec1379b2732006ec744451c0160e09d7d7" translate="yes" xml:space="preserve">
          <source>An ASN.1 compiler for Erlang, which generates encode and decode functions to be used by Erlang programs sending and receiving ASN.1 specified data.</source>
          <target state="translated">用于Erlang的ASN.1编译器,生成编码和解码函数,供Erlang程序发送和接收ASN.1指定数据时使用。</target>
        </trans-unit>
        <trans-unit id="2072c4a338574b8129ce6b5952267c903a250059" translate="yes" xml:space="preserve">
          <source>An Alarm Handling Process</source>
          <target state="translated">报警处理流程</target>
        </trans-unit>
        <trans-unit id="23ba32dda2e50be421eaa9dbe7743df19b802a29" translate="yes" xml:space="preserve">
          <source>An Erlang code preprocessor.</source>
          <target state="translated">一个Erlang代码预处理程序。</target>
        </trans-unit>
        <trans-unit id="163e8de0a613994fca6438b452c975b50aeb03f4" translate="yes" xml:space="preserve">
          <source>An Erlang crash dump is produced with &lt;code&gt;Status&lt;/code&gt; as slogan. Then the runtime system exits with status code &lt;code&gt;1&lt;/code&gt;. The string will be truncated if longer than 200 characters.</source>
          <target state="translated">产生一个Erlang故障转储， &lt;code&gt;Status&lt;/code&gt; 为口号。然后，运行系统退出，状态码为 &lt;code&gt;1&lt;/code&gt; 。如果长度超过200个字符，则字符串将被截断。</target>
        </trans-unit>
        <trans-unit id="4512b1e2b9f7565d7aad070a59e6db442ba6e364" translate="yes" xml:space="preserve">
          <source>An Erlang driver is a library containing a set of native driver callback functions that the Erlang Virtual Machine calls when certain events occur. There can be multiple instances of a driver, each instance is associated with an Erlang port.</source>
          <target state="translated">Erlang 驱动程序是一个包含一组本地驱动程序回调函数的库,当某些事件发生时,Erlang 虚拟机会调用这些函数。一个驱动可以有多个实例,每个实例都与一个Erlang端口相关联。</target>
        </trans-unit>
        <trans-unit id="46d02d2d1f7bf010b89b68c50051d352cdf1f1c7" translate="yes" xml:space="preserve">
          <source>An Erlang driver is a native code module written in C (or assembler), which serves as an interface for some special operating system service. This is a general mechanism that is used throughout the Erlang emulator for all kinds of I/O. An Erlang driver can be dynamically linked (or loaded) to the Erlang emulator at runtime by using the &lt;code&gt;erl_ddll&lt;/code&gt; Erlang module. Some of the drivers in OTP are however statically linked to the runtime system, but that is more an optimization than a necessity.</source>
          <target state="translated">Erlang驱动程序是用C（或汇编程序）编写的本机代码模块，用作某些特殊操作系统服务的接口。这是在Erlang仿真器中用于各种I / O的通用机制。通过使用 &lt;code&gt;erl_ddll&lt;/code&gt; Erlang模块，可以在运行时将Erlang驱动程序动态链接（或加载）到Erlang仿真器。但是，OTP中的某些驱动程序是静态链接到运行时系统的，但这更多的是优化而非必要。</target>
        </trans-unit>
        <trans-unit id="e9d5ba03efbb958aec77ffebac7f1f229efa740a" translate="yes" xml:space="preserve">
          <source>An Erlang driver only exports one function: the driver entry function. This is defined with a macro, &lt;code&gt;DRIVER_INIT&lt;/code&gt;, which returns a pointer to a C &lt;code&gt;struct&lt;/code&gt; containing the entry points that are called from the emulator. The &lt;code&gt;struct&lt;/code&gt; defines the entries that the emulator calls to call the driver, with a &lt;code&gt;NULL&lt;/code&gt; pointer for entries that are not defined and used by the driver.</source>
          <target state="translated">Erlang驱动程序仅导出一个功能：驱动程序入口功能。这由宏 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 定义，该宏返回指向C &lt;code&gt;struct&lt;/code&gt; 的指针，该C 结构包含从仿真器调用的入口点。该 &lt;code&gt;struct&lt;/code&gt; 定义了仿真器调用以调用驱动程序的条目，并使用 &lt;code&gt;NULL&lt;/code&gt; 指针表示未由驱动程序定义和使用的条目。</target>
        </trans-unit>
        <trans-unit id="bd548a3ef940c79c88bddfa47cccbd8fb1829c8b" translate="yes" xml:space="preserve">
          <source>An Erlang module containing a collection of test cases for a specific functional area.</source>
          <target state="translated">一个包含特定功能领域测试用例集合的Erlang模块。</target>
        </trans-unit>
        <trans-unit id="ad9ae30d2c55cc4178422772dd42ca73a04b1365" translate="yes" xml:space="preserve">
          <source>An Erlang node acting as a client to another Erlang node typically sends a request and waits for a reply. Such a request is included in a function call at a remote node and is called a remote procedure call.</source>
          <target state="translated">作为客户端的Erlang节点向另一个Erlang节点发送请求并等待回复。这种请求包含在远程节点的函数调用中,称为远程过程调用。</target>
        </trans-unit>
        <trans-unit id="56710ac893f31a54d4164ee165dd753222462531" translate="yes" xml:space="preserve">
          <source>An Erlang node is started using command-line flag &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt;:</source>
          <target state="translated">使用命令行标志 &lt;code&gt;-name&lt;/code&gt; 或 &lt;code&gt;-sname&lt;/code&gt; 启动一个Erlang节点：</target>
        </trans-unit>
        <trans-unit id="599c98b38dfe8d71da51449f0bdd899eee1b39d4" translate="yes" xml:space="preserve">
          <source>An Erlang node name has the form host@shortname or host@longname. The node name is used as an atom within the system, so the maximum size of 255 holds also for the node name.</source>
          <target state="translated">Erlang节点名的形式是host@shortname或host@longname。节点名在系统中作为一个原子使用,所以节点名的最大大小为255也是如此。</target>
        </trans-unit>
        <trans-unit id="1e0759134862f9ad1e90191482caa5537f8967ba" translate="yes" xml:space="preserve">
          <source>An Erlang pattern is a term that can contain unbound variables or &lt;code&gt;&quot;do not care&quot;&lt;/code&gt; symbols. Such a pattern can be matched against a term and, if the match is successful, any unbound variables in the pattern will be bound as a side effect. The content of a bound variable can then be retrieved:</source>
          <target state="translated">Erlang模式是一个可以包含未绑定变量或 &lt;code&gt;&quot;do not care&quot;&lt;/code&gt; 符号的术语。可以将这种模式与术语进行匹配，如果匹配成功，则该模式中的任何未绑定变量都将作为副作用进行绑定。然后可以检索绑定变量的内容：</target>
        </trans-unit>
        <trans-unit id="1200c0da52a399921a5c78fb7e044cea6d860a20" translate="yes" xml:space="preserve">
          <source>An Erlang process (conceptually) runs until it does a &lt;code&gt;receive&lt;/code&gt; and there is no message which it wants to receive in the message queue. &quot;conceptually&quot; is used here because the Erlang system shares the CPU time between the active processes in the system.</source>
          <target state="translated">一个Erlang进程（从概念上讲）一直运行到 &lt;code&gt;receive&lt;/code&gt; 消息并且消息队列中没有要接收的消息为止。这里使用&amp;ldquo;概念上&amp;rdquo;是因为Erlang系统在系统中活动进程之间共享CPU时间。</target>
        </trans-unit>
        <trans-unit id="51ffaec9560fba4d779993b121c3d8e77dcf2ff0" translate="yes" xml:space="preserve">
          <source>An Erlang process can set up links to other Erlang processes. If a process calls &lt;code&gt;link(Other_Pid)&lt;/code&gt; it sets up a bidirectional link between itself and the process called &lt;code&gt;Other_Pid&lt;/code&gt;. When a process terminates, it sends something called a &lt;strong&gt;signal&lt;/strong&gt; to all the processes it has links to.</source>
          <target state="translated">一个Erlang进程可以建立到其他Erlang进程的链接。如果某个进程调用 &lt;code&gt;link(Other_Pid)&lt;/code&gt; ,它将在自身与名为 &lt;code&gt;Other_Pid&lt;/code&gt; 的进程之间建立双向链接。进程终止时，它会向与其链接的所有进程发送一个称为&lt;strong&gt;信号的消息&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9970a8a7b56df81fb08ac05a8463925914e6cf12" translate="yes" xml:space="preserve">
          <source>An Erlang process is lightweight compared to threads and processes in operating systems.</source>
          <target state="translated">与操作系统中的线程和进程相比,Erlang进程是轻量级的。</target>
        </trans-unit>
        <trans-unit id="09a9e4871d3bc24cfef4abf9dd5b18af33c141ab" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system internal memory allocator library.</source>
          <target state="translated">一个Erlang运行时系统内部内存分配器库。</target>
        </trans-unit>
        <trans-unit id="e0378125a458b38016849cc67d1615f3807c8d9e" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system is made a distributed Erlang node by giving it a name. A distributed Erlang node can connect to, and monitor, other nodes. It can also spawn processes at other nodes. Message passing and error handling between processes at different nodes are transparent. A number of useful STDLIB modules are available in a distributed Erlang system. For example, &lt;code&gt;global&lt;/code&gt;, which provides global name registration. The distribution mechanism is implemented using TCP/IP sockets.</source>
          <target state="translated">通过为Erlang运行时系统命名，可以使它成为分布式Erlang节点。分布式Erlang节点可以连接并监视其他节点。它还可以在其他节点处生成进程。在不同节点上的进程之间的消息传递和错误处理是透明的。分布式Erlang系统中提供了许多有用的STDLIB模块。例如， &lt;code&gt;global&lt;/code&gt; ，它提供全局名称注册。分发机制是使用TCP / IP套接字实现的。</target>
        </trans-unit>
        <trans-unit id="04046988b941940151b9b5fc8a82309ae841ddb6" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system is started with command &lt;code&gt;erl&lt;/code&gt;:</source>
          <target state="translated">使用命令 &lt;code&gt;erl&lt;/code&gt; 启动一个Erlang运行时系统：</target>
        </trans-unit>
        <trans-unit id="3393487efc373a12bc45e05f1eacb861280e2ede" translate="yes" xml:space="preserve">
          <source>An Erlang runtime system to be monitored by a heart program is to be started with command-line flag &lt;code&gt;-heart&lt;/code&gt; (see also &lt;code&gt;erl(1)&lt;/code&gt;). The &lt;code&gt;heart&lt;/code&gt; process is then started automatically:</source>
          <target state="translated">要由心脏程序监视的Erlang运行时系统将使用命令行标志 &lt;code&gt;-heart&lt;/code&gt; 启动（另请参见 &lt;code&gt;erl(1)&lt;/code&gt; ）。然后， &lt;code&gt;heart&lt;/code&gt; 过程自动开始：</target>
        </trans-unit>
        <trans-unit id="f733ec70702901146b379fda30a66a57a35b70fb" translate="yes" xml:space="preserve">
          <source>An Erlang script file must always contain the &lt;code&gt;main/1&lt;/code&gt; function. When the script is run, the &lt;code&gt;main/1&lt;/code&gt; function is called with a list of strings representing the arguments specified to the script (not changed or interpreted in any way).</source>
          <target state="translated">Erlang脚本文件必须始终包含 &lt;code&gt;main/1&lt;/code&gt; 函数。运行脚本时，将使用表示代表脚本指定参数的字符串列表调用 &lt;code&gt;main/1&lt;/code&gt; 函数（不以任何方式更改或解释）。</target>
        </trans-unit>
        <trans-unit id="73dec7304e5c6b791062b7b3aca15db293d62078" translate="yes" xml:space="preserve">
          <source>An Erlang session must be started and a &lt;code&gt;Mnesia&lt;/code&gt; directory must be specified for the database.</source>
          <target state="translated">必须启动Erlang会话，并且必须为数据库指定 &lt;code&gt;Mnesia&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="ce5518b8587007e4c494155014d3a550a3741ae1" translate="yes" xml:space="preserve">
          <source>An Erlang term is represented by a C structure of type &lt;code&gt;ETERM&lt;/code&gt;. Applications should not reference any fields in this structure directly, as it can be changed in future releases to provide faster and more compact term storage. Instead, applications should use the macros and functions provided.</source>
          <target state="translated">Erlang术语由 &lt;code&gt;ETERM&lt;/code&gt; 类型的C结构表示。应用程序不应直接引用此结构中的任何字段，因为在将来的发行版中可以对其进行更改，以提供更快，更紧凑的术语存储。而是，应用程序应使用提供的宏和函数。</target>
        </trans-unit>
        <trans-unit id="164c80b922f57a9bdd50001a74df476a789dbd1f" translate="yes" xml:space="preserve">
          <source>An Erlang/OTP installation.</source>
          <target state="translated">Erlang/OTP安装。</target>
        </trans-unit>
        <trans-unit id="1054640745b3e48822c3fd2338dfbcd899d7c1b8" translate="yes" xml:space="preserve">
          <source>An Erlang/OTP source tree containing the updated applications that you want to patch into the existing Erlang/OTP installation.</source>
          <target state="translated">一个Erlang/OTP的源码树,包含了你想打补丁到现有Erlang/OTP安装中的更新应用程序。</target>
        </trans-unit>
        <trans-unit id="33e5f51ee47766fa568bcc250e6552444bf87f73" translate="yes" xml:space="preserve">
          <source>An Ets table is a single-key table (either a hash table or a tree ordered by the key) and is to be used as one. In other words, use the key to look up things whenever possible. A lookup by a known key in a &lt;code&gt;set&lt;/code&gt; Ets table is constant and for an &lt;code&gt;ordered_set&lt;/code&gt; Ets table it is O(logN). A key lookup is always preferable to a call where the whole table has to be scanned. In the previous examples, the field &lt;code&gt;idno&lt;/code&gt; is the key of the table and all lookups where only the name is known result in a complete scan of the (possibly large) table for a matching result.</source>
          <target state="translated">Ets表是单键表（哈希表或由键排序的树），将被用作一个表。换句话说，尽可能使用键查找内容。在 &lt;code&gt;set&lt;/code&gt; Ets表中通过已知键进行的查找是恒定的，对于 &lt;code&gt;ordered_set&lt;/code&gt; Ets表而言，它为O（logN）。与必须扫描整个表的调用相比，键查找总是更好的选择。在前面的示例中，字段 &lt;code&gt;idno&lt;/code&gt; 是表的关键字，并且仅查找名称的所有查找都会对（可能是较大的）表进行完整扫描以查找匹配结果。</target>
        </trans-unit>
        <trans-unit id="a7cf253c697b4afabd6dffd4bbe2047b45daa497" translate="yes" xml:space="preserve">
          <source>An Extensible multi-lingual SNMP agent, which understands SNMPv1 (RFC1157), SNMPv2c (RFC1901, 1905, 1906 and 1907), SNMPv3 (RFC2271, 2272, 2273, 2274 and 2275), or any combination of these protocols.</source>
          <target state="translated">一个可扩展的多语言SNMP代理,它能理解SNMPv1(RFC1157)、SNMPv2c(RFC1901、1905、1906和1907)、SNMPv3(RFC2271、2272、2273、2274和2275)或这些协议的任意组合。</target>
        </trans-unit>
        <trans-unit id="05553bae8eb36ff1c70b542ddf36a56af29990c8" translate="yes" xml:space="preserve">
          <source>An FTP client can be started in two ways. One is using the &lt;code&gt;&lt;a href=&quot;#service_start&quot;&gt;service_start&lt;/a&gt;&lt;/code&gt; function, the other is to start it directly as a standalone process using function &lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP客户端可以通过两种方式启动。一种是使用 &lt;code&gt;&lt;a href=&quot;#service_start&quot;&gt;service_start&lt;/a&gt;&lt;/code&gt; 函数，另一种是使用 &lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 函数将其作为独立进程直接启动。</target>
        </trans-unit>
        <trans-unit id="142111236af13f256edac0459b9be958dddb9369" translate="yes" xml:space="preserve">
          <source>An HTTP client and server</source>
          <target state="translated">一个HTTP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="2afe7b47404b7ad13ca9bd0ff2a980472ed68c85" translate="yes" xml:space="preserve">
          <source>An HTTP client can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application or started dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpc, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpc, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options are as follows:</source>
          <target state="translated">可以将HTTP客户端配置为在启动 &lt;code&gt;Inets&lt;/code&gt; 应用程序时启动，或者通过调用 &lt;code&gt;Inets&lt;/code&gt; 应用程序API &lt;code&gt;inets:start(httpc, ServiceConfig)&lt;/code&gt; 或 &lt;code&gt;inets:start(httpc, ServiceConfig, How)&lt;/code&gt; 在运行时动态启动，请参见 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 。配置选项如下：</target>
        </trans-unit>
        <trans-unit id="ac94cd7f217b34f41616cfaaff0e53eb269f96bc" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 client</source>
          <target state="translated">一个HTTP/1.1客户端</target>
        </trans-unit>
        <trans-unit id="42eecf40b49071e953314f2ad636039400fdbb0d" translate="yes" xml:space="preserve">
          <source>An I/O device, either &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, a registered name, or a pid handling I/O protocols (returned from &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">一个I / O设备，可以是 &lt;code&gt;standard_io&lt;/code&gt; ， &lt;code&gt;standard_error&lt;/code&gt; ，注册名称或用于处理I / O协议的pid（从 &lt;code&gt;file:open/2&lt;/code&gt; 返回）。</target>
        </trans-unit>
        <trans-unit id="ae711fee4d3a7baed5f9d46d07c066788a61f314" translate="yes" xml:space="preserve">
          <source>An I/O server in binary mode affects the data sent to the client, so that it must be able to handle binary data. For convenience, the modes of an I/O server can be set and retrieved using the following I/O requests:</source>
          <target state="translated">二进制模式下的I/O服务器会影响发送到客户端的数据,因此它必须能够处理二进制数据。为了方便起见,I/O服务器的模式可以通过以下I/O请求进行设置和检索。</target>
        </trans-unit>
        <trans-unit id="b62015dba8d016181c61cc4f29681a2a099c1f41" translate="yes" xml:space="preserve">
          <source>An I/O server is any process capable of handling the I/O protocol. There is no generic I/O server behavior, but could well be. The framework is simple, a process handling incoming requests, usually both I/O-requests and other I/O device-specific requests (positioning, closing, and so on).</source>
          <target state="translated">I/O服务器是任何能够处理I/O协议的进程。没有通用的I/O服务器行为,但很可能是。框架很简单,就是一个处理传入请求的进程,通常包括I/O-请求和其他I/O设备特定的请求(定位、关闭等)。</target>
        </trans-unit>
        <trans-unit id="71aa558a385dde730a823188e9e6c5a3a9ad8c43" translate="yes" xml:space="preserve">
          <source>An I/O vector containing &lt;code&gt;iovcnt&lt;/code&gt;&lt;code&gt;SysIOVec&lt;/code&gt;s pointing to the data. It is used by &lt;code&gt;&lt;a href=&quot;#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enif_ioq_enqv&quot;&gt;enif_ioq_enqv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个包含指向数据的 &lt;code&gt;iovcnt&lt;/code&gt; &lt;code&gt;SysIOVec&lt;/code&gt; 的I / O向量。由 &lt;code&gt;&lt;a href=&quot;#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enif_ioq_enqv&quot;&gt;enif_ioq_enqv&lt;/a&gt;&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="41130f0f20d700a7cd9c6bd00e3e478bc7b4d3be" translate="yes" xml:space="preserve">
          <source>An IP datagram header is of variable length. This length is measured in the number of 32-bit words and is given in the segment corresponding to &lt;code&gt;HLen&lt;/code&gt;. The minimum value of &lt;code&gt;HLen&lt;/code&gt; is 5. It is the segment corresponding to &lt;code&gt;Opts&lt;/code&gt; that is variable, so if &lt;code&gt;HLen&lt;/code&gt; is equal to 5, &lt;code&gt;Opts&lt;/code&gt; becomes an empty binary.</source>
          <target state="translated">IP数据报头的长度可变。该长度以32位字的数量为单位，并在对应于 &lt;code&gt;HLen&lt;/code&gt; 的段中给出。的最小值 &lt;code&gt;HLen&lt;/code&gt; 是5。它是对应于段 &lt;code&gt;Opts&lt;/code&gt; 是可变的，因此，如果 &lt;code&gt;HLen&lt;/code&gt; 等于5， &lt;code&gt;Opts&lt;/code&gt; 成为空的二进制。</target>
        </trans-unit>
        <trans-unit id="8b34d40f0dbe3b588d3da6f27a42d0abb207e154" translate="yes" xml:space="preserve">
          <source>An LALR-1 parser generator for Erlang, similar to &lt;code&gt;yacc&lt;/code&gt;. Takes a BNF grammar definition as input, and produces Erlang code for a parser.</source>
          <target state="translated">一个用于Erlang的LALR-1解析器生成器，类似于 &lt;code&gt;yacc&lt;/code&gt; 。将BNF语法定义作为输入，并为解析器生成Erlang代码。</target>
        </trans-unit>
        <trans-unit id="7f4de0ab059529b74fa404e77bd9bce10ca57adb" translate="yes" xml:space="preserve">
          <source>An MGC must initiate its transport service in order to listen to MG's trying to connect. How the actual transport is initiated is outside the scope of this application. However a send handle (typically a socket id or host and port) must be provided from the transport service in order to enable us to send the message to the correct destination. We do however not assume anything about this, from our point of view, opaque handle. Hopefully it is rather small since it will passed around the system between processes rather frequently.</source>
          <target state="translated">MGC必须启动其传输服务,以便监听试图连接的MG。如何启动实际的传输服务不在本应用的范围内,但必须从传输服务中提供一个发送句柄(通常是套接字id或主机和端口),以便我们能够向MG发送。然而,必须从传输服务中提供一个发送句柄(通常是一个套接字id或主机和端口),以使我们能够将消息发送到正确的目的地。然而,我们并不假设任何关于这个,从我们的角度来看,不透明的句柄。希望它是相当小的,因为它将在系统中相当频繁地在进程之间传递。</target>
        </trans-unit>
        <trans-unit id="3f19384fb5f4be8e031ef20ebc7f31d2d84b520a" translate="yes" xml:space="preserve">
          <source>An MIB view is a collection of included and excluded sub-trees. A sub-tree is identified by an OBJECT IDENTIFIER. A mask is associated with each sub-tree.</source>
          <target state="translated">一个MIB视图是一个包含和排除的子树的集合。一个子树由一个 OBJECT IDENTIFIER 识别。每个子树都有一个掩码。</target>
        </trans-unit>
        <trans-unit id="a21abf65ff184b2ac5dfa83b3fd2726d82ff5f71" translate="yes" xml:space="preserve">
          <source>An RFC 3539 watchdog state machine has changed state.</source>
          <target state="translated">一个RFC 3539看门狗状态机已经改变状态。</target>
        </trans-unit>
        <trans-unit id="3111bfc27ffe841290b619c09a5ae5ead1e40f85" translate="yes" xml:space="preserve">
          <source>An RSA private key encrypted with a password can look as follows:</source>
          <target state="translated">用密码加密的RSA私钥可以如下所示。</target>
        </trans-unit>
        <trans-unit id="bc7347d7de31b66546bd97686f70b5b899b1f5d0" translate="yes" xml:space="preserve">
          <source>An SFTP client (&lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftp&lt;/a&gt;&lt;/code&gt;) and server (&lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftpd&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">SFTP客户端（ &lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftp&lt;/a&gt;&lt;/code&gt; ）和服务器（ &lt;code&gt;&lt;a href=&quot;ssh_sftp&quot;&gt;ssh_sftpd&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c30ebe58cf85f0d3449f206c0fc62e2bc8c29633" translate="yes" xml:space="preserve">
          <source>An SNMP &lt;strong&gt;community&lt;/strong&gt; is a relationship between an SNMP agent and a set of SNMP managers that defines authentication, access control and proxy characteristics.</source>
          <target state="translated">SNMP &lt;strong&gt;社区&lt;/strong&gt;是SNMP代理与一组SNMP管理器之间的关系，该关系定义了身份验证，访问控制和代理特征。</target>
        </trans-unit>
        <trans-unit id="5c02aa7e99ca473f6341708b73eb0f8e28713993" translate="yes" xml:space="preserve">
          <source>An SNMPv3 agent must implement the SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB. These MIBs are loaded by default, if the agent is configured for SNMPv3. These MIBs can be loaded for other versions as well.</source>
          <target state="translated">一个SNMPv3代理必须实现SNMP-FRAMEWORK-MIB和SNMP-MPD-MIB。如果代理是为SNMPv3配置的,那么这些MIB会被默认加载。这些MIB也可以为其他版本加载。</target>
        </trans-unit>
        <trans-unit id="7e6913d726a46e4ef23b14ab9fbfca01ba07d162" translate="yes" xml:space="preserve">
          <source>An abstract character-based &quot;document&quot; representing a number of possible layouts, which can be processed to produce a single concrete layout. A concrete layout can then be rendered as a sequence of characters containing linebreaks, which can be passed to a printer or terminal that uses a fixed-width font.</source>
          <target state="translated">基于抽象字符的 &quot;文件&quot;,代表若干可能的布局,可对其进行处理,以产生单一的具体布局。然后,可以将具体布局呈现为包含换行符的字符序列,可将其传递给使用固定宽度字体的打印机或终端。</target>
        </trans-unit>
        <trans-unit id="5ec400c22d9bf133e13c29bd14a5a46147f57249" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree. See the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module for details.</source>
          <target state="translated">抽象语法树。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="1d7ca6b5f69a072fd3b2d3d406795b2d4821be23" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree. The &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; &quot;parse tree&quot; representation is a proper subset of the &lt;code&gt;syntaxTree()&lt;/code&gt; representation.</source>
          <target state="translated">抽象语法树。所述 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; &amp;ldquo;的语法分析树&amp;rdquo;表示是所述的适当子集 &lt;code&gt;syntaxTree()&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="e5d3cde78159d4684ac47feb70581b71c34485ec" translate="yes" xml:space="preserve">
          <source>An additional filter, &lt;code&gt;integer(X)&lt;/code&gt;, can be added to restrict the result to integers:</source>
          <target state="translated">可以添加另一个过滤器 &lt;code&gt;integer(X)&lt;/code&gt; ，以将结果限制为整数：</target>
        </trans-unit>
        <trans-unit id="ce6cdc456e7459d3c957081ebfa2dcff54001d0a" translate="yes" xml:space="preserve">
          <source>An address list is available to the start function of a &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt;, which can return a new list for use in the subsequent CER or CEA. Host-IP-Address need not be specified if the transport module in question communicates an address list as described in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">地址列表可用于 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; 的启动功能，该模块可以返回新列表以供后续的CER或CEA使用。如果所讨论的传输模块按照 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 描述传送地址列表，则无需指定主机IP地址</target>
        </trans-unit>
        <trans-unit id="d1e1407ae2e41532b81ffc2fdaec5e23d7093e2d" translate="yes" xml:space="preserve">
          <source>An agent can have many MIBs loaded at the same time.</source>
          <target state="translated">一个代理可以同时加载多个MIB。</target>
        </trans-unit>
        <trans-unit id="f492d7625cc14110ff6afa2865fa5e903887bda9" translate="yes" xml:space="preserve">
          <source>An agent responds to commands from the manager, and sends notification to the manager. There are potentially many agents in a system.</source>
          <target state="translated">代理商响应管理者的命令,并向管理者发送通知。一个系统中可能有许多代理。</target>
        </trans-unit>
        <trans-unit id="ca2e691f8fc810a8b8ce022a203ae58e956a286d" translate="yes" xml:space="preserve">
          <source>An algorithm is selected for computing a secret encryption key. Among examples are: the old nowadays week &lt;code&gt;'diffie-hellman-group-exchange-sha1'&lt;/code&gt; and the very strong and modern &lt;code&gt;'ecdh-sha2-nistp512'&lt;/code&gt;.</source>
          <target state="translated">选择用于计算秘密加密密钥的算法。例子包括：如今的旧时代 &lt;code&gt;'ecdh-sha2-nistp512'&lt;/code&gt; &lt;code&gt;'diffie-hellman-group-exchange-sha1'&lt;/code&gt; 和非常强大而又现代的'ecdh-sha2-nistp512'。</target>
        </trans-unit>
        <trans-unit id="40a51c62e24096d5cc5decd65a67cd1b36502a80" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;utf8&lt;/code&gt;, as this is the preferred encoding for Unicode characters in binaries.</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; 的别名，因为这是二进制文件中Unicode字符的首选编码。</target>
        </trans-unit>
        <trans-unit id="e889063dded89fc29b40235f1212d83a1c277549" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;{utf16,big}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{utf16,big}&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="2d83d259ee7d8e8db95f58d4f28b7d2b435fc514" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;{utf32,big}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{utf32,big}&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="77817f9811fa0bbd6bf15b9e08ba9162578eb833" translate="yes" xml:space="preserve">
          <source>An alias for debug.</source>
          <target state="translated">调试的别称。</target>
        </trans-unit>
        <trans-unit id="44d338f0d6e24a84de02e7eea09361912aac703c" translate="yes" xml:space="preserve">
          <source>An alias for none.</source>
          <target state="translated">无的别称。</target>
        </trans-unit>
        <trans-unit id="47cdcc943c5527c2b6d51204fba8e07c3ec38fe4" translate="yes" xml:space="preserve">
          <source>An allocator manages multiple areas, called carriers, in which memory blocks are placed. A carrier is either placed in a separate memory segment (allocated through &lt;code&gt;mseg_alloc&lt;/code&gt;), or in the heap segment (allocated through &lt;code&gt;sys_alloc&lt;/code&gt;).</source>
          <target state="translated">分配器管理多个区域（称为载体），在这些区域中放置了内存块。载体可以放在单独的内存段中（通过 &lt;code&gt;mseg_alloc&lt;/code&gt; 分配），也可以放在堆段中（通过 &lt;code&gt;sys_alloc&lt;/code&gt; 分配）。</target>
        </trans-unit>
        <trans-unit id="6febbd430369646d426d8b717469d67277d0bee6" translate="yes" xml:space="preserve">
          <source>An alternative &lt;code&gt;RequestURI&lt;/code&gt; has been generated.</source>
          <target state="translated">备用 &lt;code&gt;RequestURI&lt;/code&gt; 已生成。</target>
        </trans-unit>
        <trans-unit id="ef675fb1db408db7ca8ad5c68c12c4eb53d35683" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use named parentheses instead. The Perl syntax for this is (?&amp;amp;name). The earlier PCRE syntax (?P&amp;gt;name) is also supported. We can rewrite the above example as follows:</source>
          <target state="translated">另一种方法是改用命名括号。Perl的语法是（？＆name）。还支持早期的PCRE语法（？P&amp;gt; name）。我们可以将上面的示例重写如下：</target>
        </trans-unit>
        <trans-unit id="5e8ca0dc7201fb7d51c9dde7758788591e257936" translate="yes" xml:space="preserve">
          <source>An alternative approach using this &quot;branch reset&quot; feature is to use duplicate named subpatterns, as described in the next section.</source>
          <target state="translated">使用这种 &quot;分支重置 &quot;功能的另一种方法是使用重复命名的子模式,如下一节所述。</target>
        </trans-unit>
        <trans-unit id="a0a954e9d1a777f3530d50c8cc1016f12452336b" translate="yes" xml:space="preserve">
          <source>An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string.</source>
          <target state="translated">另一种描述是,这种类型的子模式匹配一个相同的独立模式所匹配的字符字符串,如果锚定在主题字符串的当前点。</target>
        </trans-unit>
        <trans-unit id="9ba8c75b43a6385ab4627c92aea25e2d33f00302" translate="yes" xml:space="preserve">
          <source>An alternative to links are &lt;strong&gt;monitors&lt;/strong&gt;. A process &lt;code&gt;Pid1&lt;/code&gt; can create a monitor for &lt;code&gt;Pid2&lt;/code&gt; by calling the BIF &lt;code&gt;erlang:monitor(process, Pid2)&lt;/code&gt;. The function returns a reference &lt;code&gt;Ref&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;监视器&lt;/strong&gt;的替代方法是&lt;strong&gt;监视器&lt;/strong&gt;。进程 &lt;code&gt;Pid1&lt;/code&gt; 可以通过调用BIF &lt;code&gt;erlang:monitor(process, Pid2)&lt;/code&gt; 为 &lt;code&gt;Pid2&lt;/code&gt; 创建监视器。该函数返回参考 &lt;code&gt;Ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8533112274eb7c989f917717ae151564846d5862" translate="yes" xml:space="preserve">
          <source>An alternative to the &lt;code&gt;rsh&lt;/code&gt; program can be specified on the command line to &lt;code&gt;erl(1)&lt;/code&gt; as follows:</source>
          <target state="translated">可以在 &lt;code&gt;erl(1)&lt;/code&gt; 的命令行上指定 &lt;code&gt;rsh&lt;/code&gt; 程序的替代方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="a41af40dfe8039be24689b8d9fa5a4dec7a7425d" translate="yes" xml:space="preserve">
          <source>An application &lt;code&gt;myapp&lt;/code&gt; is to run at the node &lt;code&gt;cp1@cave&lt;/code&gt;. If this node goes down, &lt;code&gt;myapp&lt;/code&gt; is to be restarted at &lt;code&gt;cp2@cave&lt;/code&gt; or &lt;code&gt;cp3@cave&lt;/code&gt;. A system configuration file &lt;code&gt;cp1.config&lt;/code&gt; for &lt;code&gt;cp1@cave&lt;/code&gt; can look as follows:</source>
          <target state="translated">&lt;code&gt;myapp&lt;/code&gt; 应用程序将在节点 &lt;code&gt;cp1@cave&lt;/code&gt; 上运行。如果此节点发生故障， &lt;code&gt;cp2@cave&lt;/code&gt; 在cp2 @ cave或 &lt;code&gt;cp3@cave&lt;/code&gt; 处重新启动 &lt;code&gt;myapp&lt;/code&gt; 。系统配置文件 &lt;code&gt;cp1.config&lt;/code&gt; 为 &lt;code&gt;cp1@cave&lt;/code&gt; 可以看看如下：</target>
        </trans-unit>
        <trans-unit id="476b23116cd9f8d3580ef27603fba21f5399f9c3" translate="yes" xml:space="preserve">
          <source>An application archive file and a regular application directory can coexist. This can be useful when it is needed to have parts of the application as regular files. A typical case is the &lt;code&gt;priv&lt;/code&gt; directory, which must reside as a regular directory to link in drivers dynamically and start port programs. For other applications that do not need this, directory &lt;code&gt;priv&lt;/code&gt; can reside in the archive and the files under the directory &lt;code&gt;priv&lt;/code&gt; can be read through &lt;code&gt;erl_prim_loader&lt;/code&gt;.</source>
          <target state="translated">应用程序存档文件和常规应用程序目录可以共存。当需要将应用程序的某些部分作为常规文件使用时，这很有用。典型的情况是 &lt;code&gt;priv&lt;/code&gt; 目录，该目录必须作为常规目录驻留才能动态链接驱动程序并启动端口程序。对于不需要此功能的其他应用程序，目录 &lt;code&gt;priv&lt;/code&gt; 可以位于存档中，并且可以通过 &lt;code&gt;erl_prim_loader&lt;/code&gt; 读取目录 &lt;code&gt;priv&lt;/code&gt; 下的文件。</target>
        </trans-unit>
        <trans-unit id="81e9ecb32e44895786dfebfa55679adffcc065bb" translate="yes" xml:space="preserve">
          <source>An application can &lt;strong&gt;include&lt;/strong&gt; other applications. An &lt;strong&gt;included application&lt;/strong&gt; has its own application directory and &lt;code&gt;.app&lt;/code&gt; file, but it is started as part of the supervisor tree of another application.</source>
          <target state="translated">一个应用程序可以&lt;strong&gt;包括&lt;/strong&gt;其他应用程序。一个&lt;strong&gt;包含应用程序&lt;/strong&gt;有它自己的应用程序目录和 &lt;code&gt;.app&lt;/code&gt; 文件，但它开始作为另一个应用的监督树的一部分。</target>
        </trans-unit>
        <trans-unit id="bbba1c85e48e64885f006fdefa341a6cc281a7c7" translate="yes" xml:space="preserve">
          <source>An application can always be stopped explicitly by calling &lt;code&gt;application:stop/1&lt;/code&gt;. Regardless of the mode, no other applications are affected.</source>
          <target state="translated">始终可以通过调用 &lt;code&gt;application:stop/1&lt;/code&gt; 显式停止应用程序。无论采用哪种模式，都不会影响其他应用程序。</target>
        </trans-unit>
        <trans-unit id="4237e4a4e71361c449280ec1eb5b5ab2013b9c88" translate="yes" xml:space="preserve">
          <source>An application can be configured using &lt;strong&gt;configuration parameters&lt;/strong&gt;. These are a list of &lt;code&gt;{Par,Val}&lt;/code&gt; tuples specified by a key &lt;code&gt;env&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">可以使用&lt;strong&gt;配置参数&lt;/strong&gt;来配置应用程序。这些名单 &lt;code&gt;{Par,Val}&lt;/code&gt; 由键指定的元组 &lt;code&gt;env&lt;/code&gt; 中 &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="2e4737552f8acb83cea1b0aaa1c749b9a4b1bebd" translate="yes" xml:space="preserve">
          <source>An application can only be included by one other application.</source>
          <target state="translated">一个应用只能被一个其他应用所包含。</target>
        </trans-unit>
        <trans-unit id="1b998578ccefe4ab3f65c6754297234509b764f6" translate="yes" xml:space="preserve">
          <source>An application can use the atom &lt;code&gt;asn1_DEFAULT&lt;/code&gt; to indicate that the encoding is to be omitted for that position in the &lt;code&gt;SEQUENCE&lt;/code&gt;.</source>
          <target state="translated">应用程序可以使用原子 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 表示要在 &lt;code&gt;SEQUENCE&lt;/code&gt; 中的该位置省略编码。</target>
        </trans-unit>
        <trans-unit id="610dd49b9ed69c0fcdd8e4b86353cb6bb81aba12" translate="yes" xml:space="preserve">
          <source>An application directory &lt;code&gt;AppDir&lt;/code&gt; under a library directory is recognized by the existence of an &lt;code&gt;AppDir/ebin&lt;/code&gt; directory. If this does not exist, Reltool will not consider &lt;code&gt;AppDir&lt;/code&gt; at all when looking for applications.</source>
          <target state="translated">库目录下的应用程序目录 &lt;code&gt;AppDir&lt;/code&gt; 通过存在 &lt;code&gt;AppDir/ebin&lt;/code&gt; 目录来识别。如果不存在，Reltool 在寻找应用程序时将根本不考虑 &lt;code&gt;AppDir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11790a3abc0ee5cdb260b3defc07c38712b24580" translate="yes" xml:space="preserve">
          <source>An application has an invalid &lt;code&gt;.app&lt;/code&gt; file. The second element identifies the application which has the invalid &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">应用程序包含无效的 &lt;code&gt;.app&lt;/code&gt; 文件。第二个元素标识具有无效的 &lt;code&gt;.app&lt;/code&gt; 文件的应用程序。</target>
        </trans-unit>
        <trans-unit id="b872a6c7b25b61b98a67c571917b77e9c18745dd" translate="yes" xml:space="preserve">
          <source>An application has an invalid application version. The second element identifies the application version that is invalid.</source>
          <target state="translated">应用程序的版本无效。第二个元素标识无效的应用程序版本。</target>
        </trans-unit>
        <trans-unit id="f6f21f5a29839ae0eb3a520c3267f5725a862871" translate="yes" xml:space="preserve">
          <source>An application is defined by an &lt;strong&gt;application specification&lt;/strong&gt;. The specification is normally located in an &lt;strong&gt;application resource file&lt;/strong&gt; named &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. For details about the application specification, see &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">应用程序由&lt;strong&gt;应用程序规范&lt;/strong&gt;定义。该规范通常位于名为 &lt;code&gt;Application.app&lt;/code&gt; 的&lt;strong&gt;应用程序资源文件中&lt;/strong&gt;，其中 &lt;code&gt;Application&lt;/code&gt; 是应用程序名称。有关应用程序规范的详细信息，请参见 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35cc8d34265eba507b77d8ce059b8e74c5366d40" translate="yes" xml:space="preserve">
          <source>An application is missing &lt;code&gt;runtime dependencies&lt;/code&gt;. The second element identifies the application (with version) that has missing dependencies. The third element contains the missing dependencies.</source>
          <target state="translated">应用程序缺少 &lt;code&gt;runtime dependencies&lt;/code&gt; 。第二个元素标识缺少依赖项的应用程序（带有版本）。第三个元素包含缺少的依赖项。</target>
        </trans-unit>
        <trans-unit id="de2d6a9e6ff979b71cea277fe00e98011788f397" translate="yes" xml:space="preserve">
          <source>An application is started by calling:</source>
          <target state="translated">一个应用程序是通过调用来启动的。</target>
        </trans-unit>
        <trans-unit id="2fec5bb7dc2630ef6ad69450c1671267747da522" translate="yes" xml:space="preserve">
          <source>An application is stopped, but not unloaded, by calling:</source>
          <target state="translated">通过调用,应用程序会被停止,但不会被卸载。</target>
        </trans-unit>
        <trans-unit id="bce15355fd14cfb6694d5cb7ccae2f7417ded65c" translate="yes" xml:space="preserve">
          <source>An application started the function &lt;code&gt;&lt;a href=&quot;mnesia#report_event-1&quot;&gt;mnesia:report_event(Event)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Event&lt;/code&gt; can be any Erlang data structure. When tracing a system of &lt;code&gt;Mnesia&lt;/code&gt; applications, it is useful to be able to interleave own events of &lt;code&gt;Mnesia&lt;/code&gt; with application-related events that give information about the application context. Whenever the application starts with a new and demanding &lt;code&gt;Mnesia&lt;/code&gt; activity, or enters a new and interesting phase in its execution, it can be a good idea to use &lt;code&gt;mnesia:report_event/1&lt;/code&gt;.</source>
          <target state="translated">应用程序启动了功能 &lt;code&gt;&lt;a href=&quot;mnesia#report_event-1&quot;&gt;mnesia:report_event(Event)&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;Event&lt;/code&gt; 可以是任何Erlang数据结构。跟踪 &lt;code&gt;Mnesia&lt;/code&gt; 应用程序系统时，能够将 &lt;code&gt;Mnesia&lt;/code&gt; 自己的事件与提供与应用程序上下文有关的应用程序相关事件进行交织是很有用的。每当应用程序以新的要求苛刻的 &lt;code&gt;Mnesia&lt;/code&gt; 活动开始，或者在执行过程中进入新的有趣的阶段时，最好使用 &lt;code&gt;mnesia:report_event/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f14ca986d2f7db147026ee6782679a5a03b84408" translate="yes" xml:space="preserve">
          <source>An application that has been stopped, or has never been started, can be unloaded. The information about the application is erased from the internal database of the application controller.</source>
          <target state="translated">可卸载已停止或未启动的应用程序。应用程序的信息会从应用程序控制器的内部数据库中删除。</target>
        </trans-unit>
        <trans-unit id="c9401bc6499ac0973c3774424958a83ea895fc37" translate="yes" xml:space="preserve">
          <source>An application that is not included by any other application is called a &lt;strong&gt;primary application&lt;/strong&gt;.</source>
          <target state="translated">任何其他应用程序未包含的应用程序称为&lt;strong&gt;主应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6d9139252544974ea454236628ab9eb7e354e643" translate="yes" xml:space="preserve">
          <source>An application that needs to import this MIB into another MIB is to use the &lt;code&gt;il&lt;/code&gt; option to the SNMP MIB compiler:</source>
          <target state="translated">需要将此MIB导入另一个MIB的应用程序是对SNMP MIB编译器使用 &lt;code&gt;il&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="aedbc71f0d851c4a267d3a1c0c5aaf62f7d4dba9" translate="yes" xml:space="preserve">
          <source>An application version or an OTP version identifies source code versions. That is, it implies nothing about how the application or OTP has been built.</source>
          <target state="translated">应用程序版本或OTP版本标识了源代码版本。也就是说,它并不意味着应用程序或OTP是如何构建的。</target>
        </trans-unit>
        <trans-unit id="0f4a2e38a016cb917aa540b614b135781aa21ea6" translate="yes" xml:space="preserve">
          <source>An application with processes is easiest implemented as a supervision tree using the standard behaviours.</source>
          <target state="translated">一个带过程的应用程序最容易用标准行为实现为监督树。</target>
        </trans-unit>
        <trans-unit id="66dea70011adf556837c53a3cf0529342b0737a2" translate="yes" xml:space="preserve">
          <source>An arbitrary term of meaning only to the transport process in question, as documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">仅对所讨论的传输过程有意义的任意术语，如 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd2f0e142f69d7ddafd6b4e615512721bf634753" translate="yes" xml:space="preserve">
          <source>An archive file for an application can, for example, be created like this:</source>
          <target state="translated">例如,一个应用程序的存档文件可以这样创建。</target>
        </trans-unit>
        <trans-unit id="893f8dfc800bfa1b0e951f0e6684d0ff5c925843" translate="yes" xml:space="preserve">
          <source>An arithmetic expression can be used within a pattern if it meets both of the following two conditions:</source>
          <target state="translated">如果一个算术表达式满足以下两个条件,就可以在一个模式中使用。</target>
        </trans-unit>
        <trans-unit id="c099d0285433de3759b9f43727e0ca89ef8d8154" translate="yes" xml:space="preserve">
          <source>An assertion is a test on the characters following or preceding the current matching point that does not consume any characters. The simple assertions coded as \b, \B, \A, \G, \Z, \z, ^, and $ are described in the previous sections.</source>
          <target state="translated">断言是对当前匹配点之后或之前的字符的测试,不消耗任何字符。简单的断言编码为\b、\B、\A、\G、\Z、\z、^和$,在前面的章节中已经介绍过。</target>
        </trans-unit>
        <trans-unit id="978ae9153d3b935114d56f1e2ba916c150175de4" translate="yes" xml:space="preserve">
          <source>An association A is one of the following:</source>
          <target state="translated">某社团A属于下列情况之一。</target>
        </trans-unit>
        <trans-unit id="fdf937e643d3d794f4dfc3d3b0be30aaa9ddfa6d" translate="yes" xml:space="preserve">
          <source>An atom is a literal, a constant with name. An atom is to be enclosed in single quotes (') if it does not begin with a lower-case letter or if it contains other characters than alphanumeric characters, underscore (_), or @.</source>
          <target state="translated">原子是一个文字,一个有名称的常量。如果一个原子不是以小写字母开头,或者如果它包含除字母数字字符、下划线(_)或@以外的其他字符,则用单引号(')括起来。</target>
        </trans-unit>
        <trans-unit id="8c8ee9420b38206282974e3cd3d3b4d8640789fe" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 1 byte unsigned length, followed by &lt;code&gt;Len&lt;/code&gt; bytes containing the &lt;code&gt;AtomName&lt;/code&gt; encoded in UTF-8. Longer atoms encoded in UTF-8 can be represented using &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">原子以1字节无符号长度存储，后跟包含以UTF-8编码的 &lt;code&gt;AtomName&lt;/code&gt; 的 &lt;code&gt;Len&lt;/code&gt; 字节。可以使用 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 表示以UTF-8编码的更长原子。</target>
        </trans-unit>
        <trans-unit id="f5b4b168d4917cd1441088fb0d3d767f247862aa" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 1 byte unsigned length, followed by &lt;code&gt;Len&lt;/code&gt; numbers of 8-bit Latin-1 characters that forms the &lt;code&gt;AtomName&lt;/code&gt;.</source>
          <target state="translated">一个原子以1个字节的无符号长度存储，后跟8个 &lt;code&gt;Len&lt;/code&gt; -1字符的Len编号构成 &lt;code&gt;AtomName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07c34b58920482b4d31c13cdc559df7d2359423e" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 2 byte unsigned length in big-endian order, followed by &lt;code&gt;Len&lt;/code&gt; bytes containing the &lt;code&gt;AtomName&lt;/code&gt; encoded in UTF-8.</source>
          <target state="translated">原子以大端顺序存储，具有2字节无符号长度，其后是包含以UTF-8编码的 &lt;code&gt;AtomName&lt;/code&gt; 的 &lt;code&gt;Len&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="025e110ec6c6fcee1721f7cbcbad132a16cef024" translate="yes" xml:space="preserve">
          <source>An atom is stored with a 2 byte unsigned length in big-endian order, followed by &lt;code&gt;Len&lt;/code&gt; numbers of 8-bit Latin-1 characters that forms the &lt;code&gt;AtomName&lt;/code&gt;. The maximum allowed value for &lt;code&gt;Len&lt;/code&gt; is 255.</source>
          <target state="translated">以大端顺序将原子存储为2字节无符号长度，然后存储构成 &lt;code&gt;AtomName&lt;/code&gt; 的8位Latin-1字符的 &lt;code&gt;Len&lt;/code&gt; 数。 &lt;code&gt;Len&lt;/code&gt; 的最大允许值为255。</target>
        </trans-unit>
        <trans-unit id="b431bae2fda8c033fdb39409998689e38c1c1e1e" translate="yes" xml:space="preserve">
          <source>An atom refers into an atom table, which also consumes memory. The atom text is stored once for each unique atom in this table. The atom table is &lt;strong&gt;not&lt;/strong&gt; garbage-collected.</source>
          <target state="translated">原子引用到原子表中，原子表也消耗内存。对于此表中的每个唯一原子，原子文本存储一次。原子表&lt;strong&gt;不是&lt;/strong&gt;垃圾收集的。</target>
        </trans-unit>
        <trans-unit id="8a0191848aafc2915da6d60330900193c80a5474" translate="yes" xml:space="preserve">
          <source>An atom that is named from the POSIX error codes used in Unix, and in the runtime libraries of most C compilers.</source>
          <target state="translated">一个从Unix中使用的POSIX错误代码和大多数C编译器的运行时库中命名的原子。</target>
        </trans-unit>
        <trans-unit id="96460aed347ebf24b2ed9071452af314293b4756" translate="yes" xml:space="preserve">
          <source>An atom that is named from the POSIX error codes used in Unix, and in the runtime libraries of most C compilers. See section &lt;code&gt;&lt;a href=&quot;#error_codes&quot;&gt;POSIX Error Codes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从Unix中使用的POSIX错误代码和大多数C编译器的运行时库中命名的原子。请参阅 &lt;code&gt;&lt;a href=&quot;#error_codes&quot;&gt;POSIX Error Codes&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="9e8843a0acaa52daf81257b21ad8836b998c8089" translate="yes" xml:space="preserve">
          <source>An earlier application version to downgrade to. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</source>
          <target state="translated">要降级到的早期应用程序版本。如果是字符串,则解释为一个特定的版本号。如果是二进制,则解释为可以匹配多个版本号的正则表达式。</target>
        </trans-unit>
        <trans-unit id="63ac8cc2733af5ba4520a25e1a0a5d26e1de0048" translate="yes" xml:space="preserve">
          <source>An earlier application version to upgrade from. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</source>
          <target state="translated">要升级的早期应用程序版本。如果是字符串,它被解释为一个特定的版本号。如果是二进制,则解释为可以匹配多个版本号的正则表达式。</target>
        </trans-unit>
        <trans-unit id="86d25cc1b1c119f7c9ce21b1b20f631ca251d2b2" translate="yes" xml:space="preserve">
          <source>An earlier example pointed out that the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;:</source>
          <target state="translated">前面有一个例子指出,下面的模式符合 &quot;感觉与感性 &quot;和 &quot;反应与责任&quot;,但不符合 &quot;感觉与责任&quot;。</target>
        </trans-unit>
        <trans-unit id="c42c79091566f1fa867808f3997379fa20e2ae07" translate="yes" xml:space="preserve">
          <source>An easier way to do this is to use &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-1&quot;&gt;erlang:monotonic_time/1&lt;/a&gt;&lt;/code&gt; with the desired time unit. However, you can then lose accuracy and precision.</source>
          <target state="translated">一种更简单的方法是将 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-1&quot;&gt;erlang:monotonic_time/1&lt;/a&gt;&lt;/code&gt; 与所需的时间单位一起使用。但是，您可能会失去准确性和精度。</target>
        </trans-unit>
        <trans-unit id="f3e6d13ae9ee54a2968464f59c022d1a0a22fec2" translate="yes" xml:space="preserve">
          <source>An edge e = (v, w) is said to &lt;strong id=&quot;emanate&quot;&gt;emanate&lt;/strong&gt; from vertex v and to be &lt;strong id=&quot;incident&quot;&gt;incident&lt;/strong&gt; on vertex w.</source>
          <target state="translated">边缘e =（v，w）被认为从顶点v &lt;strong id=&quot;emanate&quot;&gt;发出并入&lt;/strong&gt;&lt;strong id=&quot;incident&quot;&gt;射到&lt;/strong&gt;顶点w上。</target>
        </trans-unit>
        <trans-unit id="172599b2aba9fdd5cd8e0641d69258937859fbb4" translate="yes" xml:space="preserve">
          <source>An employee works at a department, hence the &lt;code&gt;at_dep&lt;/code&gt; relationship.</source>
          <target state="translated">员工在部门工作，因此存在 &lt;code&gt;at_dep&lt;/code&gt; 关系。</target>
        </trans-unit>
        <trans-unit id="536601c2cbcd6150b3784edaf6a33c2948983d16" translate="yes" xml:space="preserve">
          <source>An empty list &lt;code&gt;[]&lt;/code&gt;. This is equivalent to passing &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">空列表 &lt;code&gt;[]&lt;/code&gt; 。这相当于不传递 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da49af945864fc175e1244b31cb186e75a716158" translate="yes" xml:space="preserve">
          <source>An empty map is constructed by not associating any terms with each other:</source>
          <target state="translated">通过不将任何术语相互关联来构建一个空图。</target>
        </trans-unit>
        <trans-unit id="20bc15d4624ad61f2625ada525d5ff17ad373837" translate="yes" xml:space="preserve">
          <source>An empty match spec deactivates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">空匹配规范将取消对 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 的调用的跟踪</target>
        </trans-unit>
        <trans-unit id="f0f2a6b5cf3bee32b54e68dd8605481238a3fa00" translate="yes" xml:space="preserve">
          <source>An empty schema must be initialized on all the participating nodes.</source>
          <target state="translated">必须在所有参与节点上初始化一个空模式。</target>
        </trans-unit>
        <trans-unit id="82d8e46ec9a0b6406017d5e01235b4160883931e" translate="yes" xml:space="preserve">
          <source>An empty string is interpreted as local time. The values &lt;code&gt;&quot;Z&quot;&lt;/code&gt;, &lt;code&gt;&quot;z&quot;&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; are interpreted as Universal Coordinated Time (UTC).</source>
          <target state="translated">空字符串被解释为本地时间。值 &lt;code&gt;&quot;Z&quot;&lt;/code&gt; ， &lt;code&gt;&quot;z&quot;&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 解释为世界标准时间（UTC）。</target>
        </trans-unit>
        <trans-unit id="67b4376e4a5d5d2b6491c06b36b24207239ad5a6" translate="yes" xml:space="preserve">
          <source>An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails.</source>
          <target state="translated">如果指定了这个选项,空字符串将不被认为是有效的匹配。如果模式中存在替代选项,则会对其进行尝试。如果所有的选项都与空字符串匹配,那么整个匹配就会失败。</target>
        </trans-unit>
        <trans-unit id="ede47d5a8df58bc759c031e79f49d50dd3d6152e" translate="yes" xml:space="preserve">
          <source>An emulation of the &lt;code&gt;get_line&lt;/code&gt; request can be (inefficiently) implemented using the following functions:</source>
          <target state="translated">可以使用以下函数来（无效地）模拟 &lt;code&gt;get_line&lt;/code&gt; 请求：</target>
        </trans-unit>
        <trans-unit id="769ee572886ec7114895ada8db85a98957037066" translate="yes" xml:space="preserve">
          <source>An engine could among other tasks provide a storage for private or public keys. Such a storage could be made safer than the normal file system. Thoose techniques are not described in this User's Guide. Here we concentrate on how to use private or public keys stored in such an engine.</source>
          <target state="translated">除其他任务外,一个引擎可以为私人或公共钥匙提供一个存储空间。这种存储可以比普通的文件系统更安全。这些技术在本用户指南中没有介绍。在这里,我们集中讨论如何使用存储在这种引擎中的私钥或公钥。</target>
        </trans-unit>
        <trans-unit id="de3c35730fbd4317113e17cb1a8316aa1ba146c4" translate="yes" xml:space="preserve">
          <source>An entry &lt;code&gt;init&lt;/code&gt; is called when the driver is loaded. However, we do not use this, as it is executed only once, and we want to have the possibility of several instances of the driver.</source>
          <target state="translated">加载驱动程序时，将调用条目 &lt;code&gt;init&lt;/code&gt; 。但是，我们不使用它，因为它仅执行一次，并且我们希望有驱动程序的多个实例的可能性。</target>
        </trans-unit>
        <trans-unit id="f8c9e3c9a42748333730203820467c57427c23cd" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpNotifyTable&lt;/code&gt; selects a set of management targets, which should receive notifications, as well as the type (trap or inform) of notification that should be sent to each selected management target. When an application sends a notification using the function &lt;code&gt;send_notification/5&lt;/code&gt; or the function &lt;code&gt;send_trap&lt;/code&gt; the parameter &lt;code&gt;NotifyName&lt;/code&gt;, specified in the call, is used as an index in the table. The notification is sent to the management targets selected by that entry.</source>
          <target state="translated">&lt;code&gt;snmpNotifyTable&lt;/code&gt; 中的条目选择一组管理目标，这些目标应接收通知以及应发送到每个选定管理目标的通知的类型（陷阱或通知）。当应用程序使用功能 &lt;code&gt;send_notification/5&lt;/code&gt; 或功能 &lt;code&gt;send_trap&lt;/code&gt; 发送通知时，在调用中指定的参数 &lt;code&gt;NotifyName&lt;/code&gt; 将用作表中的索引。通知将发送到该条目选择的管理目标。</target>
        </trans-unit>
        <trans-unit id="d30f9a9d06d4cdda3d95205ef3f8e3559b78ed6a" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; defines transport parameters (such as IP address and UDP port) for each management target. Each row in the &lt;code&gt;snmpNotifyTable&lt;/code&gt; refers to potentially many rows in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt;. Each row in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; refers to an entry in the &lt;code&gt;snmpTargetParamsTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 中的一项为每个管理目标定义了传输参数（例如IP地址和UDP端口）。在每一行 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 是指在可能的许多行 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 。在每一行 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 是指在一个条目 &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c864a3c020fb7453c6c9230310fc8c808b2ea57f" translate="yes" xml:space="preserve">
          <source>An entry in the &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; defines which SNMP version to use, and which security parameters to use.</source>
          <target state="translated">&lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 中的一项定义了要使用的SNMP版本以及要使用的安全参数。</target>
        </trans-unit>
        <trans-unit id="c6d027e6ae888a87324f48f2f95ccca79a8943b4" translate="yes" xml:space="preserve">
          <source>An enum is defined for the different types of ports:</source>
          <target state="translated">为不同类型的端口定义了一个枚举。</target>
        </trans-unit>
        <trans-unit id="112db680b6814a15cbebf4072e243401d2d30dc2" translate="yes" xml:space="preserve">
          <source>An enumeration of the options that can be specified to &lt;code&gt;&lt;a href=&quot;#enif_binary_to_term&quot;&gt;enif_binary_to_term&lt;/a&gt;&lt;/code&gt;. For default behavior, use value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">可以指定给 &lt;code&gt;&lt;a href=&quot;#enif_binary_to_term&quot;&gt;enif_binary_to_term&lt;/a&gt;&lt;/code&gt; 的选项的枚举。对于默认行为，请使用值 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6252cac5ba4fabe28fb4f86a057202e9f901cf22" translate="yes" xml:space="preserve">
          <source>An enumeration of the properties that can be requested from &lt;code&gt;&lt;a href=&quot;#enif_make_unique_integer&quot;&gt;enif_make_unique_integer&lt;/a&gt;&lt;/code&gt;. For default properties, use value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">可以从 &lt;code&gt;&lt;a href=&quot;#enif_make_unique_integer&quot;&gt;enif_make_unique_integer&lt;/a&gt;&lt;/code&gt; 请求的属性的枚举。对于默认属性，请使用值 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65635c741693783b8faf9619014d7e4c157b5504" translate="yes" xml:space="preserve">
          <source>An enumeration of the supported hash types that can be generated using &lt;code&gt;&lt;a href=&quot;#enif_hash&quot;&gt;enif_hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#enif_hash&quot;&gt;enif_hash&lt;/a&gt;&lt;/code&gt; 生成的受支持的哈希类型的枚举。</target>
        </trans-unit>
        <trans-unit id="a0579ec30b9bde18751f5dc44f0719d4615425a5" translate="yes" xml:space="preserve">
          <source>An enumeration of time units supported by the NIF API:</source>
          <target state="translated">NIF API支持的时间单位枚举。</target>
        </trans-unit>
        <trans-unit id="168bb5a8fd94c8cd10d8ed3f141a0191574b88ed" translate="yes" xml:space="preserve">
          <source>An enumeration of time units supported by the driver API:</source>
          <target state="translated">驱动程序API支持的时间单位的枚举。</target>
        </trans-unit>
        <trans-unit id="5667406f6f2878a322440a8811e0537af3474b50" translate="yes" xml:space="preserve">
          <source>An erroneous port driver causes the entire Erlang runtime system to leak memory, hang or crash.</source>
          <target state="translated">错误的端口驱动程序会导致整个 Erlang 运行时系统泄漏内存、挂起或崩溃。</target>
        </trans-unit>
        <trans-unit id="a25480ae66be12a6963d7a72edaa77057ebfd25a" translate="yes" xml:space="preserve">
          <source>An erroneously implemented driver callback can cause a VM internal state inconsistency, which can cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the driver callback.</source>
          <target state="translated">错误实现的驱动回调会导致虚拟机内部状态不一致,从而导致虚拟机的崩溃,或者在调用驱动回调后的任何一点上,虚拟机出现杂乱的行为。</target>
        </trans-unit>
        <trans-unit id="b8892af8dce296a6140e1075e6fda16d2be53087" translate="yes" xml:space="preserve">
          <source>An erroneously implemented native function can cause a VM internal state inconsistency, which can cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the native function.</source>
          <target state="translated">错误实现的原生函数会导致虚拟机内部状态不一致,从而导致虚拟机崩溃,或者在调用原生函数后的任何时候都会导致虚拟机的杂乱行为。</target>
        </trans-unit>
        <trans-unit id="7e29ee9045f599d9ba3e88fde145184df3fac58d" translate="yes" xml:space="preserve">
          <source>An error (preferably &lt;code&gt;enotsup&lt;/code&gt;) is to be expected if the option is not supported by the I/O server (like if an &lt;code&gt;echo&lt;/code&gt; option is sent in a &lt;code&gt;setopts&lt;/code&gt; request to a plain file).</source>
          <target state="translated">如果I / O服务器不支持该选项（例如，在 &lt;code&gt;setopts&lt;/code&gt; 请求中将 &lt;code&gt;echo&lt;/code&gt; 选项发送到纯文件）， &lt;code&gt;enotsup&lt;/code&gt; 发生错误（最好是enotsup）。</target>
        </trans-unit>
        <trans-unit id="ef53805af65d4aec1042beb62bf786a927bf0949" translate="yes" xml:space="preserve">
          <source>An error in the token, &lt;code&gt;ErrString&lt;/code&gt; is a string describing the error.</source>
          <target state="translated">令牌中的错误 &lt;code&gt;ErrString&lt;/code&gt; 是描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="9675f812e2ec4204b8069b26c2c16fc3d11e7e72" translate="yes" xml:space="preserve">
          <source>An error is generated if a POSIX character class (see below) or an escape sequence other than one that defines a single character appears at a point where a range ending character is expected. For example, [z-\xff] is valid, but [A-\d] and [A-[:digit:]] are not.</source>
          <target state="translated">如果一个POSIX字符类(见下文)或除定义单个字符以外的转义序列出现在一个预期的范围结束字符的位置,就会产生错误。例如,[z-\xff]有效,但[A-\d]和[A-[:digit:]]无效。</target>
        </trans-unit>
        <trans-unit id="70ffc117acf0983da95ec8d6661c1771f05359ce" translate="yes" xml:space="preserve">
          <source>An error is returned if the file is inaccessible, badly damaged, or not produced with &lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果文件不可访问，损坏严重或不是由 &lt;code&gt;&lt;a href=&quot;#tab2file-2&quot;&gt;tab2file/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 生成的，则返回错误。</target>
        </trans-unit>
        <trans-unit id="f4fccfc1950a3f6ff91e3d72c1993a335c05397b" translate="yes" xml:space="preserve">
          <source>An error message from Yecc will be shown if the grammar is not of the LALR type (for example too ambiguous). Shift/reduce conflicts are resolved in favor of shifting if there are no operator precedence declarations. Refer to the &lt;code&gt;yacc&lt;/code&gt; documentation on the use of operator precedence.</source>
          <target state="translated">如果语法不是LALR类型（例如，模棱两可），将显示Yecc的错误消息。如果没有运算符优先级声明，则通过移动来解决移位/减少冲突。有关使用运算符优先级的信息，请参见 &lt;code&gt;yacc&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="31c2414153ba301793b3dd12a7fe55e753d09f20" translate="yes" xml:space="preserve">
          <source>An error occurred and parameter &lt;code&gt;What&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">发生错误，参数 &lt;code&gt;What&lt;/code&gt; 给出了有关该错误的提示。</target>
        </trans-unit>
        <trans-unit id="b554e8c8ed24e5d9bc17d2154801582fa6248c31" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang expressions in the file. To convert the three-element tuple to an English description of the error, use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释文件中的Erlang表达式时发生错误。要将三元素元组转换为错误的英文描述，请使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767d840af8cc500417913c45ac5faa2d43fc36cf" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang expressions in the file. Use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; to convert the three-element tuple to an English description of the error.</source>
          <target state="translated">解释文件中的Erlang表达式时发生错误。使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 将三元素元组转换为错误的英文描述。</target>
        </trans-unit>
        <trans-unit id="08fb924c8d5034ec7f5547cd83f8fcb4ccca9d79" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang terms in the file. To convert the three-element tuple to an English description of the error, use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释文件中的Erlang术语时发生错误。要将三元素元组转换为错误的英文描述，请使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33ce206664f8a29d19d98811cc9c199fb73695df" translate="yes" xml:space="preserve">
          <source>An error occurred when interpreting the Erlang terms in the file. Use &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; to convert the three-element tuple to an English description of the error.</source>
          <target state="translated">解释文件中的Erlang术语时发生错误。使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 将三元素元组转换为错误的英文描述。</target>
        </trans-unit>
        <trans-unit id="d42f0460cf512a9c365e9827248b96d2dd4f4f2b" translate="yes" xml:space="preserve">
          <source>An error occurred when opening the file or reading it. For a list of typical error codes, see &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打开文件或读取文件时发生错误。有关典型错误代码的列表，请参见 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="865e7e88d043baea59e5a9ce2c7bdc0ec2a285ad" translate="yes" xml:space="preserve">
          <source>An error occurred while tokenizing or parsing.</source>
          <target state="translated">标记化或解析时发生错误。</target>
        </trans-unit>
        <trans-unit id="4c273a93c70896df1c5d70c89b20ce9bedbd1cc9" translate="yes" xml:space="preserve">
          <source>An error occurred while tokenizing.</source>
          <target state="translated">标记化时发生错误。</target>
        </trans-unit>
        <trans-unit id="bccc6f1f5cca72606032b0c35b12d1e01e8749d0" translate="yes" xml:space="preserve">
          <source>An error occurred.</source>
          <target state="translated">发生了一个错误。</target>
        </trans-unit>
        <trans-unit id="956fbfe776acc43caa6cf6b2b6cd39d20367cfeb" translate="yes" xml:space="preserve">
          <source>An error occurred. &lt;code&gt;ErrorLocation&lt;/code&gt; is the first location after the erroneous token.</source>
          <target state="translated">发生错误。 &lt;code&gt;ErrorLocation&lt;/code&gt; 是错误令牌之后的第一个位置。</target>
        </trans-unit>
        <trans-unit id="b5debc76cc659427400c33c7089e9a450f8d6749" translate="yes" xml:space="preserve">
          <source>An error occurred. &lt;code&gt;LeftOverChars&lt;/code&gt; is the remaining characters of the input data, starting from &lt;code&gt;EndLocation&lt;/code&gt;.</source>
          <target state="translated">发生错误。 &lt;code&gt;LeftOverChars&lt;/code&gt; 是输入数据的其余字符，从 &lt;code&gt;EndLocation&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="b04e7309a02162567e2429e9aecf5da14464d91f" translate="yes" xml:space="preserve">
          <source>An error with this reason is caused by the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function either returning an error or an invalid value.</source>
          <target state="translated">此原因导致的错误是由用户 &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; 回调函数返回错误或无效值引起的。</target>
        </trans-unit>
        <trans-unit id="6c4ed44541e86a0e82fda185481726a9fa534460" translate="yes" xml:space="preserve">
          <source>An error with this reason is generated by the megaco application itself.</source>
          <target state="translated">这个原因的错误是由megaco应用程序本身产生的。</target>
        </trans-unit>
        <trans-unit id="40f386a85299f082984b2271fcfb815a37ab5075" translate="yes" xml:space="preserve">
          <source>An escape such as \d or \pL that matches a single character</source>
          <target state="translated">匹配单个字符的转义词,如/d或/pL。</target>
        </trans-unit>
        <trans-unit id="3dbab65b35422e9a5f18088ebc06d25e9fad346a" translate="yes" xml:space="preserve">
          <source>An escript without header can be created as follows:</source>
          <target state="translated">一个不含标题的脚本可以创建如下。</target>
        </trans-unit>
        <trans-unit id="caa651d62e89a3194457422deac44f5099468104" translate="yes" xml:space="preserve">
          <source>An event handler that logs events to disk.</source>
          <target state="translated">一个将事件记录到磁盘的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="5819d554802a07971f53d1cb6535b01dfcbb09e8" translate="yes" xml:space="preserve">
          <source>An event manager can also be stopped by calling:</source>
          <target state="translated">也可以通过拨打电话停止活动经理。</target>
        </trans-unit>
        <trans-unit id="f0e3aa08515364f27e3115f4b2dbde9ad919a3bf" translate="yes" xml:space="preserve">
          <source>An event manager implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">使用此模块实现的事件管理器具有一组标准的接口功能，并且包括用于跟踪和错误报告的功能。它也适合OTP监管树。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="886ccc722947fa7b5754f99dcfc5af3986ac55e6" translate="yes" xml:space="preserve">
          <source>An event manager is implemented as a process and each event handler is implemented as a callback module.</source>
          <target state="translated">一个事件管理器是作为一个进程来实现的,而每个事件处理程序是作为一个回调模块来实现的。</target>
        </trans-unit>
        <trans-unit id="f09b12972f030994c4bc8f915a66c78fbd4519e1" translate="yes" xml:space="preserve">
          <source>An event message sent to processes that have subscribed to these using &lt;code&gt;&lt;a href=&quot;#subscribe-1&quot;&gt;subscribe/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">事件消息发送到已使用 &lt;code&gt;&lt;a href=&quot;#subscribe-1&quot;&gt;subscribe/1&lt;/a&gt;&lt;/code&gt; 订阅了这些进程的进程。</target>
        </trans-unit>
        <trans-unit id="7912692308fccb18e880ce6533510b32643ba616" translate="yes" xml:space="preserve">
          <source>An event of type &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;internal&lt;/a&gt;&lt;/code&gt; is to be used when you want to reliably distinguish an event inserted this way from any external event.</source>
          <target state="translated">当您要可靠地将以这种方式插入的事件与任何外部事件区分开来时，将使用 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;internal&lt;/a&gt;&lt;/code&gt; 类型的事件。</target>
        </trans-unit>
        <trans-unit id="a40597cb2b6a0fd7a5b617f8cfce1e45596c4fc9" translate="yes" xml:space="preserve">
          <source>An event record consists of the following fields:</source>
          <target state="translated">一个事件记录由以下字段组成:</target>
        </trans-unit>
        <trans-unit id="c961b5dc628efa399b055d52eefc6a02b7a6cc27" translate="yes" xml:space="preserve">
          <source>An event time-out is cancelled by any other event so you either get some other event or the time-out event. It is therefore not possible nor needed to cancel or restart an event time-out. Whatever event you act on has already cancelled the event time-out...</source>
          <target state="translated">一个事件超时会被任何其他事件取消,所以你要么得到其他事件,要么得到超时事件。因此,不可能也不需要取消或重新启动事件超时。无论你执行的是什么事件,都已经取消了事件超时...。</target>
        </trans-unit>
        <trans-unit id="a3e4ac702417db8112a904d57243c3232ddfe095" translate="yes" xml:space="preserve">
          <source>An event_handler tuple in argument &lt;code&gt;Opts&lt;/code&gt; has the following definition (see &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">在参数的event_handler元组 &lt;code&gt;Opts&lt;/code&gt; 具有如下定义（参见 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3a969467552c52e537f903625bc429c6574d2c9a" translate="yes" xml:space="preserve">
          <source>An example command line doing the same as the example in the previous section can now look as follows (line breaks in the command are for readability, and shall not be there when typed):</source>
          <target state="translated">一个与上一节中的例子相同的命令行可以如下所示(命令中的换行符是为了便于阅读,输入时不应出现)。</target>
        </trans-unit>
        <trans-unit id="24e3e494ce66660334a3ee83d7103bc438d96d0c" translate="yes" xml:space="preserve">
          <source>An example command line with this option would look like this:</source>
          <target state="translated">使用该选项的命令行示例如下。</target>
        </trans-unit>
        <trans-unit id="3a72f95d3b2dbe62f799c4b641925aa95c266cbd" translate="yes" xml:space="preserve">
          <source>An example implementation of a distribution module can be found in &lt;code&gt;$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl&lt;/code&gt;. It implements the distribution over TCP/IP using the &lt;code&gt;gen_tcp&lt;/code&gt; API with distribution controllers implemented by processes. This instead of using port distribution controllers as the ordinary TCP/IP distribution uses.</source>
          <target state="translated">分发模块的示例实现可在 &lt;code&gt;$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl&lt;/code&gt; 。它使用 &lt;code&gt;gen_tcp&lt;/code&gt; API通过进程实现的分发控制器来实现TCP / IP 上的分发。而不是像常规的TCP / IP分发一样使用端口分发控制器。</target>
        </trans-unit>
        <trans-unit id="f25cec01bb097ac34ef114606afd83d4604845c7" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;&amp;lt;MibName&amp;gt;&lt;/code&gt; is &lt;code&gt;RFC1213-MIB&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;MibName&amp;gt;&lt;/code&gt; 的示例是 &lt;code&gt;RFC1213-MIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd190ce9f4e4adebb4a1e9e43f55af888513aa13" translate="yes" xml:space="preserve">
          <source>An example of a connection string: &lt;code&gt;&quot;DSN=sql-server;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; where DSN is your ODBC Data Source Name, UID is a database user id and PWD is the password for that user. These are usually the attributes required in the connection string, but some drivers have other driver specific attributes, for example &lt;code&gt;&quot;DSN=Oracle8;DBQ=gandalf;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; where DBQ is your TNSNAMES.ORA entry name e.g. some Oracle specific configuration attribute.</source>
          <target state="translated">连接字符串的示例： &lt;code&gt;&quot;DSN=sql-server;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; ，其中DSN是您的ODBC数据源名称，UID是数据库用户ID，PWD是该用户的密码。这些通常是连接字符串中所需的属性，但是某些驱动程序具有其他特定于驱动程序的属性，例如 &lt;code&gt;&quot;DSN=Oracle8;DBQ=gandalf;UID=aladdin;PWD=sesame&quot;&lt;/code&gt; ，其中DBQ是您的TNSNAMES.ORA条目名称，例如一些Oracle特定的配置属性。</target>
        </trans-unit>
        <trans-unit id="4c63ca8ea69582d13ba623fe7884e3eaf6dde10a" translate="yes" xml:space="preserve">
          <source>An example of a simple server written in plain Erlang is provided in &lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt;. The server can be reimplemented using &lt;code&gt;gen_server&lt;/code&gt;, resulting in this callback module:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;des_princ#ch1&quot;&gt;Overview&lt;/a&gt;&lt;/code&gt; 提供了用普通的Erlang编写的简单服务器的示例。可以使用 &lt;code&gt;gen_server&lt;/code&gt; 重新实现服务器，从而产生以下回调模块：</target>
        </trans-unit>
        <trans-unit id="766c8ed5398a618e0ab57071580f3ae767ca73f1" translate="yes" xml:space="preserve">
          <source>An example of a simple test function could be the following:</source>
          <target state="translated">一个简单的测试函数的例子可以是以下内容。</target>
        </trans-unit>
        <trans-unit id="fc8a1c6616df7bc9e05cd29f7f66081b9d15ab3e" translate="yes" xml:space="preserve">
          <source>An example of a test case information function follows:</source>
          <target state="translated">下面是一个测试用例信息函数的例子。</target>
        </trans-unit>
        <trans-unit id="263edddce7f8f5ac177f18b46f0285f0e12e001a" translate="yes" xml:space="preserve">
          <source>An example of a typical ordering function is less than or equal to: &lt;code&gt;=&amp;lt;/2&lt;/code&gt;.</source>
          <target state="translated">典型排序函数的一个示例小于或等于： &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0cfd15cad67827179545aee45fbe9cd3e6e0b77" translate="yes" xml:space="preserve">
          <source>An example of a value that can be encoded as type &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;{12,&quot;hello&quot;}&lt;/code&gt;.</source>
          <target state="translated">可以编码为类型 &lt;code&gt;T1&lt;/code&gt; 的值的示例是 &lt;code&gt;{12,&quot;hello&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="641b3d8cec6c829548d6cff0640c2452dac92d4d" translate="yes" xml:space="preserve">
          <source>An example of an XML configuration file follows:</source>
          <target state="translated">下面是一个XML配置文件的例子。</target>
        </trans-unit>
        <trans-unit id="3c953ad1d3b8e0a028a4a0e50272f51e08c62029" translate="yes" xml:space="preserve">
          <source>An example of branched versions: The version &lt;code&gt;6.0.2.1&lt;/code&gt; is a branched version from the base version &lt;code&gt;6.0.2&lt;/code&gt;. Versions on the form &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; can be compared with normal versions smaller than or equal to &lt;code&gt;6.0.2&lt;/code&gt;, and other versions on the form &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt;. The version &lt;code&gt;6.0.2.1&lt;/code&gt; will include all changes in &lt;code&gt;6.0.2&lt;/code&gt;. However, &lt;code&gt;6.0.3&lt;/code&gt; will most likely &lt;strong&gt;not&lt;/strong&gt; include all changes in &lt;code&gt;6.0.2.1&lt;/code&gt; (note that these versions have no order). A second branched version from the base version &lt;code&gt;6.0.2&lt;/code&gt; will be version &lt;code&gt;6.0.2.0.1&lt;/code&gt;, and a third branched version will be &lt;code&gt;6.0.2.0.0.1&lt;/code&gt;.</source>
          <target state="translated">分支版本的示例：版本 &lt;code&gt;6.0.2.1&lt;/code&gt; 是来自基本版本 &lt;code&gt;6.0.2&lt;/code&gt; 的分支版本。可以将格式为 &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; 版本与小于或等于 &lt;code&gt;6.0.2&lt;/code&gt; 的普通版本以及格式为 &lt;code&gt;6.0.2.&amp;lt;X&amp;gt;&lt;/code&gt; 其他版本进行比较。 &lt;code&gt;6.0.2.1&lt;/code&gt; 版将包含 &lt;code&gt;6.0.2&lt;/code&gt; 中的所有更改。但是， &lt;code&gt;6.0.3&lt;/code&gt; 很可能&lt;strong&gt;不会&lt;/strong&gt;包括 &lt;code&gt;6.0.2.1&lt;/code&gt; 中的所有更改（请注意，这些版本没有顺序）。基本版本 &lt;code&gt;6.0.2&lt;/code&gt; 的第二个分支版本将是 &lt;code&gt;6.0.2.0.1&lt;/code&gt; 版本，而第三个分支版本将是 &lt;code&gt;6.0.2.0.0.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d2b79780a92a75d625b2977e20ae40bf2d1dc5d" translate="yes" xml:space="preserve">
          <source>An example of how to compile code with debug information from the Erlang shell:</source>
          <target state="translated">一个关于如何从Erlang shell中编译带有调试信息的代码的例子。</target>
        </trans-unit>
        <trans-unit id="283dddecff25e45c32ff2ee6dc6f7deae1f48787" translate="yes" xml:space="preserve">
          <source>An example of how to compile code with debug information using &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">如何使用 &lt;code&gt;erlc&lt;/code&gt; 使用调试信息编译代码的示例：</target>
        </trans-unit>
        <trans-unit id="0b041b3192c84c6c42972b6454b8d190b043db34" translate="yes" xml:space="preserve">
          <source>An example of how to replace the standard handler with a disk_log handler at startup is found in the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; manual.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 手册中找到了如何在启动时用disk_log处理程序替换标准处理程序的示例。</target>
        </trans-unit>
        <trans-unit id="ad7a08deebfc0de42e62f5ac0c0a37270a88259d" translate="yes" xml:space="preserve">
          <source>An example of how to use function &lt;code&gt;seq_trigger_ms/0,1&lt;/code&gt; follows:</source>
          <target state="translated">以下是如何使用函数 &lt;code&gt;seq_trigger_ms/0,1&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="52a1c522c256f4824c6c143ccc112c9b3e8d1721" translate="yes" xml:space="preserve">
          <source>An example of process tracing of &lt;code&gt;os_mon&lt;/code&gt; and friends.</source>
          <target state="translated">&lt;code&gt;os_mon&lt;/code&gt; 和好友的进程跟踪的示例。</target>
        </trans-unit>
        <trans-unit id="d183a4063c6f62966aa70116abbdb5e2ed3c3fa0" translate="yes" xml:space="preserve">
          <source>An example of the suite information function follows:</source>
          <target state="translated">下面以套房信息功能为例。</target>
        </trans-unit>
        <trans-unit id="71b617f2d4fc8a3ed842c6355b6026c8ba8babba" translate="yes" xml:space="preserve">
          <source>An example of this is the SFTP support in &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt;. This function opens a tar file on a remote machine using an SFTP channel.</source>
          <target state="translated">例如 &lt;code&gt;ssh_sftp:open_tar/3&lt;/code&gt; 中的SFTP支持。此功能使用SFTP通道在远程计算机上打开tar文件。</target>
        </trans-unit>
        <trans-unit id="623a8785811ca24208a4398108f7f9357baa4841" translate="yes" xml:space="preserve">
          <source>An example with an implicit match specification:</source>
          <target state="translated">一个具有隐式匹配规范的例子。</target>
        </trans-unit>
        <trans-unit id="b77a79055b4c741418b72739ec8b6223e715e638" translate="yes" xml:space="preserve">
          <source>An example with implicit match specification:</source>
          <target state="translated">一个具有隐式匹配规范的例子。</target>
        </trans-unit>
        <trans-unit id="8f768fcb2e6876510a24de877e85b8f46f23c3ca" translate="yes" xml:space="preserve">
          <source>An exception (such as &lt;code&gt;badarg&lt;/code&gt;) in the &lt;code&gt;MatchCondition&lt;/code&gt; part, which resembles an Erlang guard, generates immediate failure.</source>
          <target state="translated">&lt;code&gt;MatchCondition&lt;/code&gt; 部分中的异常（例如 &lt;code&gt;badarg&lt;/code&gt; ）类似于Erlang防护，会立即产生故障。</target>
        </trans-unit>
        <trans-unit id="c55f6f36b8c26386f173147d732e092f93370b5b" translate="yes" xml:space="preserve">
          <source>An exception consists of its class, an exit reason (see &lt;code&gt;&lt;a href=&quot;#exit_reasons&quot;&gt;Exit Reason&lt;/a&gt;&lt;/code&gt;), and a stack trace (which aids in finding the code location of the exception).</source>
          <target state="translated">异常由其类，退出原因（请参见 &lt;code&gt;&lt;a href=&quot;#exit_reasons&quot;&gt;Exit Reason&lt;/a&gt;&lt;/code&gt; ）和堆栈跟踪（有助于查找异常的代码位置）组成。</target>
        </trans-unit>
        <trans-unit id="786ccd01cb23da0a273209436d12e92170626910" translate="yes" xml:space="preserve">
          <source>An exception in the &lt;code&gt;MatchBody&lt;/code&gt; part, which resembles the body of an Erlang function, is implicitly caught and results in the single atom &lt;code&gt;'EXIT'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MatchBody&lt;/code&gt; 部分中的异常类似于Erlang函数的主体，被隐式捕获，并导致单个原子 &lt;code&gt;'EXIT'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eea16817ebabde2bb1160184fce27148bc39b259" translate="yes" xml:space="preserve">
          <source>An exception is if the application has the &lt;code&gt;start_phases&lt;/code&gt; key defined (see &lt;code&gt;&lt;a href=&quot;included_applications&quot;&gt;Included Applications&lt;/a&gt;&lt;/code&gt;). The application is then instead started by calling:</source>
          <target state="translated">如果应用程序定义了 &lt;code&gt;start_phases&lt;/code&gt; 键，则是一个例外（请参阅 &lt;code&gt;&lt;a href=&quot;included_applications&quot;&gt;Included Applications&lt;/a&gt;&lt;/code&gt; ）。然后，通过调用以下命令来启动该应用程序：</target>
        </trans-unit>
        <trans-unit id="ccfc7a550c54e8241796ed0b6744cf68e3304ef5" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;fun_expr_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">如果 &lt;code&gt;fun_expr_clauses(Node)&lt;/code&gt; 返回一个空列表，或者该列表的第一个元素不是类型为 &lt;code&gt;clause&lt;/code&gt; 的语法树 &lt;code&gt;C&lt;/code&gt; ，从而使得 &lt;code&gt;clause_patterns(C)&lt;/code&gt; 是一个非空列表，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="b82407baecc4ff5b4d3851e388407e7da330afd7" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;function_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">如果 &lt;code&gt;function_clauses(Node)&lt;/code&gt; 返回一个空列表，或者该列表的第一个元素不是 &lt;code&gt;clause&lt;/code&gt; 类型的语法树 &lt;code&gt;C&lt;/code&gt; ，则该子句将 &lt;code&gt;clause_patterns(C)&lt;/code&gt; ，从而Claus_patterns（C）是一个非空列表。</target>
        </trans-unit>
        <trans-unit id="f52143a4be751dfd326004be48fd5e21eb1bb7aa" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;named_fun_expr_clauses(Node)&lt;/code&gt; returns an empty list, or if the first element of that list is not a syntax tree &lt;code&gt;C&lt;/code&gt; of type &lt;code&gt;clause&lt;/code&gt; such that &lt;code&gt;clause_patterns(C)&lt;/code&gt; is a nonempty list.</source>
          <target state="translated">如果 &lt;code&gt;named_fun_expr_clauses(Node)&lt;/code&gt; 返回一个空列表，或者该列表的第一个元素不是type &lt;code&gt;clause&lt;/code&gt; 的语法树 &lt;code&gt;C&lt;/code&gt; ，从而 &lt;code&gt;clause_patterns(C)&lt;/code&gt; 是一个非空列表，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="e847ae794f483b76a1568dd706204639135518bf" translate="yes" xml:space="preserve">
          <source>An exception occurring during the evaluation of &lt;code&gt;Body&lt;/code&gt; is not caught.</source>
          <target state="translated">没有捕获在评估 &lt;code&gt;Body&lt;/code&gt; 期间发生的异常。</target>
        </trans-unit>
        <trans-unit id="7b5eab4cdd40c5d5e4cc289495dd5e5e68d0fea2" translate="yes" xml:space="preserve">
          <source>An exception of class &lt;code&gt;error&lt;/code&gt; is also known as a run-time error.</source>
          <target state="translated">类 &lt;code&gt;error&lt;/code&gt; 的异常也称为运行时错误。</target>
        </trans-unit>
        <trans-unit id="4450a7ddfc454818593e6096f098ce6aa2d7511c" translate="yes" xml:space="preserve">
          <source>An exception to the above is if the exit reason is &lt;code&gt;kill&lt;/code&gt;, that is if &lt;code&gt;exit(Pid,kill)&lt;/code&gt; has been called. This unconditionally terminates the process, regardless of if it is trapping exit signals.</source>
          <target state="translated">上面的一个例外是退出原因是 &lt;code&gt;kill&lt;/code&gt; ，即是否已调用 &lt;code&gt;exit(Pid,kill)&lt;/code&gt; 。无论是否捕获退出信号，这都会无条件终止该过程。</target>
        </trans-unit>
        <trans-unit id="d07cbfc2bcd69590e32840931392d6ea6afd078a" translate="yes" xml:space="preserve">
          <source>An exception will be thrown if a preset dictionary is required for further decompression. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果需要进一步解压缩的预设字典，则会抛出异常。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1c641f1b9af49cd4d1923ca86b8594f8f949e59" translate="yes" xml:space="preserve">
          <source>An exception within the callback will be treated as a validation failure.</source>
          <target state="translated">回调中的异常将被视为验证失败。</target>
        </trans-unit>
        <trans-unit id="f30fc06164cbf07d72025eed006de40eb4481362" translate="yes" xml:space="preserve">
          <source>An executable line contains an Erlang expression such as a matching or a function call. A blank line or a line containing a comment, function head or pattern in a &lt;code&gt;case&lt;/code&gt;- or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">可执行行包含一个Erlang表达式，例如匹配或函数调用。空行或在 &lt;code&gt;case&lt;/code&gt; 包含注释，函数头或模式的行-或 &lt;code&gt;receive&lt;/code&gt; 语句不可执行。</target>
        </trans-unit>
        <trans-unit id="8606c5f9fe59cd2685a78631470346707ae72155" translate="yes" xml:space="preserve">
          <source>An expected CEA was not received within &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; of connection establishment.</source>
          <target state="translated">连接建立的 &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; 内未收到预期的CEA 。</target>
        </trans-unit>
        <trans-unit id="0cfddc07c615cb5d5e6262a7a3331cc836bbb0c2" translate="yes" xml:space="preserve">
          <source>An expected CER was not received within &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; of connection establishment.</source>
          <target state="translated">连接建立的 &lt;code&gt;&lt;a href=&quot;#capx_timeout&quot;&gt;capx_timeout&lt;/a&gt;&lt;/code&gt; 内未收到预期的CER 。</target>
        </trans-unit>
        <trans-unit id="d1e9be959321b894a2874f0c88caf59a243a800d" translate="yes" xml:space="preserve">
          <source>An explicit match specification is here used to traverse the table:</source>
          <target state="translated">这里采用显式匹配规范来遍历表。</target>
        </trans-unit>
        <trans-unit id="057acda345b8319968a51559e553710109f3e800" translate="yes" xml:space="preserve">
          <source>An expression E is one of the following:</source>
          <target state="translated">表达式E是下列之一:</target>
        </trans-unit>
        <trans-unit id="79ec765b52e5254ae35be2bfa0a2b1b7402af860" translate="yes" xml:space="preserve">
          <source>An expression defining the map to be updated, is put in front of the expression defining the keys to be updated and their respective values:</source>
          <target state="translated">定义要更新的地图的表达式,放在定义要更新的键和它们各自的值的表达式前面。</target>
        </trans-unit>
        <trans-unit id="4c5709bbd83330fdb0802325f414deebc289f34a" translate="yes" xml:space="preserve">
          <source>An expression that can be evaluated as a function in the following sense.</source>
          <target state="translated">在以下意义上,可以作为函数进行评估的表达式。</target>
        </trans-unit>
        <trans-unit id="b3ffd3c48acbdb730fd9ee6452c9c6da8b28f7c0" translate="yes" xml:space="preserve">
          <source>An extendible array can be made fixed-size later:</source>
          <target state="translated">一个可扩展的数组可以在以后变成固定大小。</target>
        </trans-unit>
        <trans-unit id="8053c45d586487397b53559d19e27dd0eec873c5" translate="yes" xml:space="preserve">
          <source>An identity parse transform.</source>
          <target state="translated">一种身份解析变换。</target>
        </trans-unit>
        <trans-unit id="ecdfc6b7cd9818342bbf2008fadc35280070bfc8" translate="yes" xml:space="preserve">
          <source>An implementation of an HTTP 1.1 compliant web server, as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Provides web server start options, administrative functions, and an Erlang callback API.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 中定义的，符合HTTP 1.1的Web服务器的实现。提供Web服务器启动选项，管理功能和Erlang回调API。</target>
        </trans-unit>
        <trans-unit id="bccff937aee314a7a7bbe2e29ed38d05e459fc04" translate="yes" xml:space="preserve">
          <source>An important aspect of these functions is that the system can access a table while it is being reconfigured. For example, it is possible to move a table and simultaneously perform write operations to the same table. This feature is essential for applications that require continuous service.</source>
          <target state="translated">这些功能的一个重要方面是,系统可以在重新配置一个表的同时对其进行访问。例如,可以移动一个表,同时对同一个表进行写操作。这一功能对于需要连续服务的应用来说是必不可少的。</target>
        </trans-unit>
        <trans-unit id="8103190c74242180849af27697a68cc90031c667" translate="yes" xml:space="preserve">
          <source>An important feature of the Erlang programming language is the ability to change module code in runtime, &lt;strong&gt;code replacement&lt;/strong&gt;, as described in the Erlang Reference Manual.</source>
          <target state="translated">Erlang编程语言的一个重要功能是可以在运行时更改模块代码，&lt;strong&gt;替换代码&lt;/strong&gt;，如《 Erlang参考手册》中所述。</target>
        </trans-unit>
        <trans-unit id="b984515f043cbeceb35298b231ea0fb8cdbe98e2" translate="yes" xml:space="preserve">
          <source>An important notion is that of  &lt;strong id=&quot;conversion&quot;&gt;conversion&lt;/strong&gt; of expressions. The syntax of a cast expression is:</source>
          <target state="translated">一个重要的概念是 表达式&lt;strong id=&quot;conversion&quot;&gt;转换&lt;/strong&gt;。强制转换表达式的语法为：</target>
        </trans-unit>
        <trans-unit id="e7373b7e60caa76da4c06b8f17342dc9bd893d3f" translate="yes" xml:space="preserve">
          <source>An inbound Diameter message.</source>
          <target state="translated">一个入站的Diameter信息。</target>
        </trans-unit>
        <trans-unit id="27e2e729d2af483eadb06f0f20ab32c601a79adb" translate="yes" xml:space="preserve">
          <source>An included application can include other applications.</source>
          <target state="translated">一个包含的应用程序可以包括其他应用程序。</target>
        </trans-unit>
        <trans-unit id="6fad7fec6bf12045b5bbf5068c4c8a4f43bff8d4" translate="yes" xml:space="preserve">
          <source>An incoming CEA contained errors and has been rejected. &lt;code&gt;Caps&lt;/code&gt; contains only values for the local node. &lt;code&gt;Pkt&lt;/code&gt; contains the CEA in question.</source>
          <target state="translated">传入的CEA包含错误，已被拒绝。 &lt;code&gt;Caps&lt;/code&gt; 仅包含本地节点的值。 &lt;code&gt;Pkt&lt;/code&gt; 包含有问题的CEA。</target>
        </trans-unit>
        <trans-unit id="59cee863f9f3f47fe8ac63e3064c6869185c82bc" translate="yes" xml:space="preserve">
          <source>An incoming CEA has been rejected for the indicated reason. An integer-valued &lt;code&gt;Result&lt;/code&gt; indicates the result code sent by the peer. &lt;code&gt;Caps&lt;/code&gt; contains pairs of values for the local node and remote peer. &lt;code&gt;Pkt&lt;/code&gt; contains the CEA in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</source>
          <target state="translated">出于指示的原因，传入的CEA已被拒绝。整数值 &lt;code&gt;Result&lt;/code&gt; 表示对等方发送的结果代码。 &lt;code&gt;Caps&lt;/code&gt; 包含本地节点和远程对等方的值对。 &lt;code&gt;Pkt&lt;/code&gt; 包含有问题的CEA。在功能回调拒绝的情况下，元组包含拒绝回调。</target>
        </trans-unit>
        <trans-unit id="b1def14681d1943bacda3c612720c72d742fb87a" translate="yes" xml:space="preserve">
          <source>An incoming CER contained errors and has been answered with the indicated result code. &lt;code&gt;Caps&lt;/code&gt; contains values for the local node only. &lt;code&gt;Pkt&lt;/code&gt; contains the CER in question.</source>
          <target state="translated">传入的CER包含错误，并已通过指示的结果代码回答。 &lt;code&gt;Caps&lt;/code&gt; 包含本地节点的值。 &lt;code&gt;Pkt&lt;/code&gt; 包含有问题的CER。</target>
        </trans-unit>
        <trans-unit id="44f0c3ff8baccd820cf7209b6da707bb1df632ba" translate="yes" xml:space="preserve">
          <source>An incoming CER has been answered with the indicated result code, or discarded. &lt;code&gt;Caps&lt;/code&gt; contains pairs of values, for the local node and remote peer respectively. &lt;code&gt;Pkt&lt;/code&gt; contains the CER in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</source>
          <target state="translated">输入的CER已用指示的结果代码回答，或被丢弃。 &lt;code&gt;Caps&lt;/code&gt; 包含分别用于本地节点和远程对等点的值对。 &lt;code&gt;Pkt&lt;/code&gt; 包含有问题的CER。在功能回调拒绝的情况下，元组包含拒绝回调。</target>
        </trans-unit>
        <trans-unit id="c010a7263cd57740edb22b37dcc807299770bfbd" translate="yes" xml:space="preserve">
          <source>An index number. Each fun within a module has an unique index. &lt;code&gt;Index&lt;/code&gt; is stored in big-endian byte order.</source>
          <target state="translated">索引号。模块中的每个乐趣都有一个唯一的索引。 &lt;code&gt;Index&lt;/code&gt; 以big-endian字节顺序存储。</target>
        </trans-unit>
        <trans-unit id="e0917d687832d3450bdf1dd4a6ec48cbe0e0d9e3" translate="yes" xml:space="preserve">
          <source>An index table for the table in the previous examples would have to be a bag (as keys would appear more than once) and can have the following contents:</source>
          <target state="translated">前面例子中的表的索引表必须是一个袋子(因为键会出现不止一次),可以有以下内容。</target>
        </trans-unit>
        <trans-unit id="f3a716603d7f6fd090e2b620d82712d6086ee98c" translate="yes" xml:space="preserve">
          <source>An info report is written when the upgrade is completed. To programmatically determine if the upgrade is complete, call &lt;code&gt;&lt;a href=&quot;release_handler#which_releases-0&quot;&gt;release_handler:which_releases/0,1&lt;/a&gt;&lt;/code&gt; and check if the expected release has status &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">升级完成后，将写入信息报告。要以编程方式确定升级是否完成，请调用 &lt;code&gt;&lt;a href=&quot;release_handler#which_releases-0&quot;&gt;release_handler:which_releases/0,1&lt;/a&gt;&lt;/code&gt; 并检查期望的发行版是否具有 &lt;code&gt;current&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="4c23fa577741650a0b90f37b9ba01e57e91c10bd" translate="yes" xml:space="preserve">
          <source>An info report is written when the upgrade is completed. To programmatically find out if the upgrade is complete, call &lt;code&gt;release_handler:which_releases(current)&lt;/code&gt; and check if it returns the expected (that is, the new) release.</source>
          <target state="translated">升级完成后，将写入信息报告。要以编程方式确定升级是否完成，请调用 &lt;code&gt;release_handler:which_releases(current)&lt;/code&gt; 并检查其是否返回预期的（即新的）发行版。</target>
        </trans-unit>
        <trans-unit id="54c7f8a299a2c3884adcc720f6b4c75f5057c0ab" translate="yes" xml:space="preserve">
          <source>An initial megaco_receive_handle record may be obtained with megaco:user_info(UserMid, receive_handle)</source>
          <target state="translated">一个初始的megaco_receive_handle记录可以通过megaco:user_info(UserMid,receive_handle)来获得。</target>
        </trans-unit>
        <trans-unit id="1540a39cc27f66083ac255242e015830b64ff885" translate="yes" xml:space="preserve">
          <source>An installed, but not permanent, release can be &lt;strong&gt;removed&lt;/strong&gt;. Information about the release is then deleted from &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; and the release-specific code, that is, the new application directories and the &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; directory, are removed.</source>
          <target state="translated">可以&lt;strong&gt;删除&lt;/strong&gt;已安装但不是永久的发行版。然后从 &lt;code&gt;$ROOT/releases/RELEASES&lt;/code&gt; 删除有关发行版的信息，并删除发行版专用代码，即新的应用程序目录和 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="543b81b3ca97b671430c105dbe9f1ef27cc417d9" translate="yes" xml:space="preserve">
          <source>An instance of the global group server, &lt;code&gt;global_group&lt;/code&gt;, must be running on each node. The processes are automatically started and synchronized when a node is started.</source>
          <target state="translated">全局组服务器实例 &lt;code&gt;global_group&lt;/code&gt; 必须在每个节点上运行。启动节点后，进程将自动启动并同步。</target>
        </trans-unit>
        <trans-unit id="37e43d40c9bbabdd039d304ba4e86e08e3ffdef1" translate="yes" xml:space="preserve">
          <source>An instrumentation function is associated with each managed object. This is the function, which actually implements the operations and will be called by the agent when it receives a request from the management station.</source>
          <target state="translated">每个被管理对象都有一个工具函数。这个函数实际上是实现操作的函数,当代理收到管理站的请求时,它将被调用。</target>
        </trans-unit>
        <trans-unit id="c415bc220831ee9b6e63013e939f47504d9e06e6" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt; 1.</source>
          <target state="translated">大于1的整数。</target>
        </trans-unit>
        <trans-unit id="02913d17fb755af0fd3c86a0adae0000c2d01a6b" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt; 16#10FFFF (the maximum Unicode character)</source>
          <target state="translated">整数&amp;gt; 16＃10FFFF（最大Unicode字符）</target>
        </trans-unit>
        <trans-unit id="ad0ece817502015092c7dcb2a91f78120a1b145a" translate="yes" xml:space="preserve">
          <source>An integer &amp;gt;= 0, defaults to 5000 (= 5 seconds).</source>
          <target state="translated">&amp;gt; = 0的整数，默认为5000（= 5秒）。</target>
        </trans-unit>
        <trans-unit id="20367003fe74f6da823d6b30bb16e4e87af78658" translate="yes" xml:space="preserve">
          <source>An integer (1-3) that together with the node name identifies a specific instance of the node.</source>
          <target state="translated">一个整数(1-3),与节点名称一起标识节点的特定实例。</target>
        </trans-unit>
        <trans-unit id="2b542080580abe037742a55ddf14a6930d08becf" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Uniq&lt;/code&gt; is the hash value of the parse for the fun.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 编码的整数。 &lt;code&gt;Uniq&lt;/code&gt; 是乐趣分析的哈希值。</target>
        </trans-unit>
        <trans-unit id="1e4efa5efcaeac48981fcfd626c607b83f7f9504" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Uniq&lt;/code&gt; is the hash value of the parse tree for the fun.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 编码的整数。 &lt;code&gt;Uniq&lt;/code&gt; 是乐趣的解析树的哈希值。</target>
        </trans-unit>
        <trans-unit id="6a456c7d96d3be7599b8cda2609e6963d6b1de33" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. Is typically a small index into the module's fun table.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 编码的整数。通常是模块的fun表中的​​一个小索引。</target>
        </trans-unit>
        <trans-unit id="6847ab27f51bb9e93819111b69d00c639f57f360" translate="yes" xml:space="preserve">
          <source>An integer encoded using &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt;. It is typically a small index into the module's fun table.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#SMALL_INTEGER_EXT&quot;&gt;SMALL_INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#INTEGER_EXT&quot;&gt;INTEGER_EXT&lt;/a&gt;&lt;/code&gt; 编码的整数。它通常是模块的fun表中的​​一个小索引。</target>
        </trans-unit>
        <trans-unit id="52ca0689079aeaec22ad11a25c6606e5822f73a2" translate="yes" xml:space="preserve">
          <source>An integer in base 2-36 with Erlang-style base prefix (for example, &lt;code&gt;&quot;16#ffff&quot;&lt;/code&gt;) is expected.</source>
          <target state="translated">在2-36的基数中应为整数，带有Erlang样式的基前缀（例如 &lt;code&gt;&quot;16#ffff&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0baa0e36919cfd4cb52692449c99e08703eaa7db" translate="yes" xml:space="preserve">
          <source>An integer in the range 16#D800 to 16#DFFF (invalid range reserved for UTF-16 surrogate pairs)</source>
          <target state="translated">16#D800至16#DFFF范围内的整数(为UTF-16代用对保留的无效范围)。</target>
        </trans-unit>
        <trans-unit id="bb1ed6dc3882ba274f91970e7d75def0f49d509c" translate="yes" xml:space="preserve">
          <source>An integer time-out value means that the supervisor tells the child process to terminate by calling &lt;code&gt;exit(Child, shutdown)&lt;/code&gt; and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using &lt;code&gt;exit(Child, kill)&lt;/code&gt;.</source>
          <target state="translated">整数超时值表示主管通过调用 &lt;code&gt;exit(Child, shutdown)&lt;/code&gt; 告诉子进程终止，然后等待退出信号返回。如果在指定时间内没有收到退出信号，则使用 &lt;code&gt;exit(Child, kill)&lt;/code&gt; 无条件终止子进程。</target>
        </trans-unit>
        <trans-unit id="dabb549e21a83ec6de830a51776d90cd83956482" translate="yes" xml:space="preserve">
          <source>An integer value must be at least 6000 as required by RFC 3539. Defaults to 30000.</source>
          <target state="translated">按照RFC 3539的要求,整数值必须至少为6000。默认值为30000。</target>
        </trans-unit>
        <trans-unit id="d78dcbf8380694136f9fe0e5e3000d89748b331e" translate="yes" xml:space="preserve">
          <source>An integer() =&amp;lt; byte_size(Replacement)</source>
          <target state="translated">一个integer（）= &amp;lt;byte_size（Replacement）</target>
        </trans-unit>
        <trans-unit id="eae8aee5e13d9ea04bc6a6da3331604fadfde37c" translate="yes" xml:space="preserve">
          <source>An integer, defaults to 10.</source>
          <target state="translated">一个整数,默认为10。</target>
        </trans-unit>
        <trans-unit id="aaa8bce129155fc26fcd48a021b1aba6aab1fe3e" translate="yes" xml:space="preserve">
          <source>An interesting case is if the client terminates before the server links to it. This is taken care of because linking to a non-existent process causes an exit signal, &lt;code&gt;{'EXIT',From,noproc}&lt;/code&gt;, to be automatically generated. This is as if the process terminated immediately after the link operation.</source>
          <target state="translated">一个有趣的情况是客户端在服务器链接之前终止。这样做是因为链接到不存在的进程会导致自动生成退出信号 &lt;code&gt;{'EXIT',From,noproc}&lt;/code&gt; 。好像该过程在链接操作后立即终止。</target>
        </trans-unit>
        <trans-unit id="ee03f04c6056f21df390b2f5c06e43f9b491765e" translate="yes" xml:space="preserve">
          <source>An interface to the BEAM file format.</source>
          <target state="translated">BEAM文件格式的接口。</target>
        </trans-unit>
        <trans-unit id="4ca4ff078056e9ca1ab23144711d3518ee5bc785" translate="yes" xml:space="preserve">
          <source>An interval timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_interval-4&quot;&gt;apply_interval/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_interval-3&quot;&gt;send_interval/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#send_interval-2&quot;&gt;send_interval/2&lt;/a&gt;&lt;/code&gt; is linked to the process to which the timer performs its task.</source>
          <target state="translated">间隔计时器，即通过评估函数 &lt;code&gt;&lt;a href=&quot;#apply_interval-4&quot;&gt;apply_interval/4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#send_interval-3&quot;&gt;send_interval/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#send_interval-2&quot;&gt;send_interval/2&lt;/a&gt;&lt;/code&gt; 中的任何一个而创建的计时器，与该计时器执行其任务的进程相关联。</target>
        </trans-unit>
        <trans-unit id="627a27fca6a1a1ae0460efe310199a632e472370" translate="yes" xml:space="preserve">
          <source>An introduction to release handling and an example is provided in &lt;code&gt;OTP Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;系统文档&lt;/strong&gt;中的 &lt;code&gt;OTP Design Principles&lt;/code&gt; 中提供了发行处理的介绍和示例。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="287260ebb6db5e5582d099b0dc6bfe58c59eb75e" translate="yes" xml:space="preserve">
          <source>An invalid filter is equivalent to &lt;code&gt;{any,[]}&lt;/code&gt;, a filter that matches no peer.</source>
          <target state="translated">无效的过滤器等效于 &lt;code&gt;{any,[]}&lt;/code&gt; ，该过滤器不匹配任何对等项。</target>
        </trans-unit>
        <trans-unit id="9e6dcd0df7d6d68a6b64b4961a4174415586bdf3" translate="yes" xml:space="preserve">
          <source>An invalid option will cause &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; to fail.</source>
          <target state="translated">无效的选项将导致 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="76b5573333f8a9fca96e5af38089644ca66d3800" translate="yes" xml:space="preserve">
          <source>An iterator representing the key value associations in a map.</source>
          <target state="translated">代表地图中键值关联的迭代器。</target>
        </trans-unit>
        <trans-unit id="14321e1cc5b6395a120d907a4630fb98a62c2d1a" translate="yes" xml:space="preserve">
          <source>An object has a DESCRIPTIONS field. The descriptions-field will not be included in the compiled mib by default. In order to get the description, the mib must be compiled with the option &lt;code&gt;description&lt;/code&gt;.</source>
          <target state="translated">对象具有DESCRIPTIONS字段。默认情况下，descriptions字段不会包含在编译的mib中。为了获得描述，mib必须使用选项 &lt;code&gt;description&lt;/code&gt; 进行编译。</target>
        </trans-unit>
        <trans-unit id="ee729cb9bca371486670bc70823bacf43371b316" translate="yes" xml:space="preserve">
          <source>An object is an instance of a class. An object set is a set containing objects of a specified class. A definition can look as follows:</source>
          <target state="translated">对象是一个类的实例。一个对象集是包含一个指定类的对象的集合。一个定义可以是这样的:</target>
        </trans-unit>
        <trans-unit id="e2b7535d7ca9a8df2239bf3e1efc196455c377ac" translate="yes" xml:space="preserve">
          <source>An object stored on the process heap, called a &lt;strong&gt;ProcBin&lt;/strong&gt;</source>
          <target state="translated">存储在进程堆上的对象，称为&lt;strong&gt;ProcBin&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3818f7783f7171a63429c22bb4302a762ba63b49" translate="yes" xml:space="preserve">
          <source>An on-the-fly FIPS mode change would thus have to be performed in a critical section protected from any concurrently running crypto operations. Furthermore in case of failure all crypto calls would have to be disabled from the Erlang or nif code. This would be too much effort put into this not too important feature.</source>
          <target state="translated">因此,FIPS模式的即时改变必须在一个关键的部分进行,以防止任何同时运行的加密操作。此外,在失败的情况下,所有的加密调用都必须在Erlang或nif代码中被禁用。这将会在这个不太重要的功能上投入太多精力。</target>
        </trans-unit>
        <trans-unit id="9371fdc5c24675c1a03db0e4febf59f3f93d39d8" translate="yes" xml:space="preserve">
          <source>An opaque continuation.</source>
          <target state="translated">一个不透明的延续。</target>
        </trans-unit>
        <trans-unit id="9edd135f1be094e9884cdcb725f6b9ae29fe3900" translate="yes" xml:space="preserve">
          <source>An opaque handle identifing a distribution channel.</source>
          <target state="translated">一个不透明的手柄,用于识别分销渠道。</target>
        </trans-unit>
        <trans-unit id="8c06de9b53b4d538ad0727d2caa8126ac3202325" translate="yes" xml:space="preserve">
          <source>An opaque term (a tuple) representing a trace token.</source>
          <target state="translated">一个不透明的术语(元组),代表一个跟踪标记。</target>
        </trans-unit>
        <trans-unit id="ffe2dac12bf2d4212d4d945b02bbd44d5376742d" translate="yes" xml:space="preserve">
          <source>An opaque term holding prepared code.</source>
          <target state="translated">一个不透明的术语,持有准备好的代码。</target>
        </trans-unit>
        <trans-unit id="03858ce2c3f12ebaf6e00e9dd03bc97d803626cb" translate="yes" xml:space="preserve">
          <source>An opaque term returned in, for example, &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt;, which identifies an association for an SCTP socket. The term is opaque except for the special value &lt;code&gt;0&lt;/code&gt;, which has a meaning such as &quot;the whole endpoint&quot; or &quot;all future associations&quot;.</source>
          <target state="translated">在 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 返回的不透明术语，用于标识SCTP套接字的关联。除特殊值 &lt;code&gt;0&lt;/code&gt; 以外，该术语是不透明的，特殊值0具有诸如&amp;ldquo;整个端点&amp;rdquo;或&amp;ldquo;所有将来的关联&amp;rdquo;之类的含义。</target>
        </trans-unit>
        <trans-unit id="1e180467754d1704f0a1df2c1b8933d6555d46e3" translate="yes" xml:space="preserve">
          <source>An open disk log that is not a distributed disk log is said to be a &lt;strong&gt;local disk log&lt;/strong&gt;. A local disk log is only accessible from the node where the disk log process runs, whereas a distributed disk log is accessible from all nodes in the Erlang system, except for those nodes where a local disk log with the same name as the distributed disk log exists. All processes on nodes that have access to a local or distributed disk log can log items or otherwise change, inspect, or close the log.</source>
          <target state="translated">不是分布式磁盘日志的打开磁盘日志被称为&lt;strong&gt;本地磁盘日志&lt;/strong&gt;。只能从运行磁盘日志过程的节点访问本地磁盘日志，而可以从Erlang系统中的所有节点访问分布式磁盘日志，但那些本地磁盘日志与分布式磁盘日志同名的节点除外存在。有权访问本地或分布式磁盘日志的节点上的所有进程都可以记录项目或更改，检查或关闭日志。</target>
        </trans-unit>
        <trans-unit id="663c631411ce98e587cb31bbdd92c54b2f404346" translate="yes" xml:space="preserve">
          <source>An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters.</source>
          <target state="translated">开头的大括号如果出现在不允许使用量化符的位置,或者不符合量化符语法的位置,则被视为文字字符。例如,{,6}不是量化符,而是由四个字符组成的文字串。</target>
        </trans-unit>
        <trans-unit id="6d91a90e980eb6fd08ac0210bb0e415b4c7d6aec" translate="yes" xml:space="preserve">
          <source>An opening square bracket introduces a character class, terminated by a closing square bracket. A closing square bracket on its own is not special by default. However, if option &lt;code&gt;PCRE_JAVASCRIPT_COMPAT&lt;/code&gt; is set, a lone closing square bracket causes a compile-time error. If a closing square bracket is required as a member of the class, it is to be the first data character in the class (after an initial circumflex, if present) or escaped with a backslash.</source>
          <target state="translated">右方括号引入了一个字符类，并以右方括号终止。默认情况下，右方括号本身并不特殊。但是，如果设置了选项 &lt;code&gt;PCRE_JAVASCRIPT_COMPAT&lt;/code&gt; ，则单独的右方括号会导致编译时错误。如果需要使用方括号作为该类的成员，则它将成为该类中的第一个数据字符（如果有初始抑扬符号，则在其后）或以反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="421ee4a2487ab9d284a55e10a7feef99df36fe1c" translate="yes" xml:space="preserve">
          <source>An operator &lt;code&gt;Op/A&lt;/code&gt; is called (this is handled as a call to function &lt;code&gt;erlang:Op/A&lt;/code&gt;).</source>
          <target state="translated">调用 &lt;code&gt;Op/A&lt;/code&gt; 符Op / A（这作为对函数 &lt;code&gt;erlang:Op/A&lt;/code&gt; 的调用来处理）。</target>
        </trans-unit>
        <trans-unit id="e3b3ea6fc52831c5fd41836eff34ba6b00be455a" translate="yes" xml:space="preserve">
          <source>An option change within a subpattern (see section &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt;) affects only that part of the subpattern that follows it. So, the following matches abc and aBc and no other strings (assuming &lt;code&gt;caseless&lt;/code&gt; is not used):</source>
          <target state="translated">子模式中的选项更改（请参见 &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt; 部分）仅影响子模式之后的部分。因此，下面的比赛ABC和ABC并没有其他的字符串（假设 &lt;code&gt;caseless&lt;/code&gt; 不使用）：</target>
        </trans-unit>
        <trans-unit id="551e2c1420f8fdac698ff16d393dbd32e2b136d1" translate="yes" xml:space="preserve">
          <source>An option is to have table columns that are not visible through the SNMP protocol. These columns must be the last columns of the table. In the previous example, the SNMP table could have columns &lt;code&gt;department&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; only. The application could then use column &lt;code&gt;telno&lt;/code&gt; internally, but it would not be visible to the SNMP managers.</source>
          <target state="translated">一种选择是使表列通过SNMP协议不可见。这些列必须是表的最后一列。在上一个示例中，SNMP表可以仅包含 &lt;code&gt;department&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 列。然后，该应用程序可以在内部使用 &lt;code&gt;telno&lt;/code&gt; 列，但是它对SNMP管理器不可见。</target>
        </trans-unit>
        <trans-unit id="251d94f1b858e81b3828d5510ef8d65b4159fa2d" translate="yes" xml:space="preserve">
          <source>An optional sign character is expected. A sign character &lt;code&gt;-&lt;/code&gt; gives return value &lt;code&gt;-1&lt;/code&gt;. Sign character &lt;code&gt;+&lt;/code&gt; or none gives &lt;code&gt;1&lt;/code&gt;. The field width parameter is ignored. Leading whitespace characters are not skipped.</source>
          <target state="translated">可选的符号字符。符号字符 &lt;code&gt;-&lt;/code&gt; 给出返回值 &lt;code&gt;-1&lt;/code&gt; 。符号字符 &lt;code&gt;+&lt;/code&gt; 或不给出 &lt;code&gt;1&lt;/code&gt; 。字段宽度参数将被忽略。前导空格字符不会被跳过。</target>
        </trans-unit>
        <trans-unit id="5bd063d57db649e289c855dd3e2315e3fa45b28a" translate="yes" xml:space="preserve">
          <source>An ordinary send operation has occurred and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">发生了普通的发送操作，并且 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 包含接收者的pid。该消息在 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="e1d95c4d5591cafb0876b899034ba6f76ed65f97" translate="yes" xml:space="preserve">
          <source>An outbound Diameter message.</source>
          <target state="translated">一个出站的Diameter信息。</target>
        </trans-unit>
        <trans-unit id="1e88996446c45983e274f354d9264bc09768f004" translate="yes" xml:space="preserve">
          <source>An overview and summary log file for one or more test suites.</source>
          <target state="translated">一个或多个测试套件的概述和摘要日志文件。</target>
        </trans-unit>
        <trans-unit id="07c751adb15fe1a4d90ad6b7ab4efbae14d0517a" translate="yes" xml:space="preserve">
          <source>An positive integer, Current default is 1.</source>
          <target state="translated">一个正整数,当前默认值为1。</target>
        </trans-unit>
        <trans-unit id="787be85125e87b09b59e0cb657acd9746aadc985" translate="yes" xml:space="preserve">
          <source>An small receive buffer may result in a peer having to resend incoming messages: set the &lt;code&gt;inet(3)&lt;/code&gt; option &lt;code&gt;recbuf&lt;/code&gt; to increase the buffer size.</source>
          <target state="translated">较小的接收缓冲区可能导致对等方不得不重新发送传入的消息：设置 &lt;code&gt;inet(3)&lt;/code&gt; 选项 &lt;code&gt;recbuf&lt;/code&gt; 以增加缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="b84da375fbfec2799e71fb40dea34b2a15da15f8" translate="yes" xml:space="preserve">
          <source>An small send buffer may result in outgoing messages being discarded: set the &lt;code&gt;inet(3)&lt;/code&gt; option &lt;code&gt;sndbuf&lt;/code&gt; to increase the buffer size.</source>
          <target state="translated">较小的发送缓冲区可能会导致传出消息被丢弃：设置 &lt;code&gt;inet(3)&lt;/code&gt; 选项 &lt;code&gt;sndbuf&lt;/code&gt; 可以增加缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="d96da95c5f83e85028d2b14bb4d255a0e3e94e02" translate="yes" xml:space="preserve">
          <source>An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline.</source>
          <target state="translated">在主题字符串的第一个换行之前或在第一个换行处需要匹配一个无锚模式,尽管匹配的文本可以在换行上继续。</target>
        </trans-unit>
        <trans-unit id="4b306841248c236a72e8f0555640ea69d77d6059" translate="yes" xml:space="preserve">
          <source>An unpacked release can be &lt;strong&gt;installed&lt;/strong&gt;. The release handler then evaluates the instructions in &lt;code&gt;relup&lt;/code&gt;, step by step:</source>
          <target state="translated">可以&lt;strong&gt;安装&lt;/strong&gt;解压后的发行版。然后，释放处理程序逐步评估 &lt;code&gt;relup&lt;/code&gt; 中的指令：</target>
        </trans-unit>
        <trans-unit id="e2a7a24dafaa1825d952fc1c97adf9898005d178" translate="yes" xml:space="preserve">
          <source>An unsigned integer in base 2-36 is expected. The field width parameter is used to specify base. Leading whitespace characters are not skipped.</source>
          <target state="translated">希望使用基数为2-36的无符号整数。字段宽度参数用于指定基数。不跳过前导空格字符。</target>
        </trans-unit>
        <trans-unit id="5286dbe6f7d10b81b53f17ba799c7e96413f6797" translate="yes" xml:space="preserve">
          <source>An unsigned integer type to be used as &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">一个无符号整数类型，用作 &lt;code&gt;size_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3acdebb60e03e4a5883afd990fc02df22667fa4" translate="yes" xml:space="preserve">
          <source>An unsigned number specifies an absolute reference without the ambiguity that is present in the older syntax. It is also useful when literal digits follow the reference. A negative number is a relative reference. Consider the following example:</source>
          <target state="translated">无符号数字指定了一个绝对引用,没有旧语法中的模糊性。当引用后面有数字时,它也很有用。负数是一个相对引用。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="a5a2acb9415f75900acb288ec02a5216db6932a2" translate="yes" xml:space="preserve">
          <source>An unsuccessful parse results in an error, which may be a tuple &lt;code&gt;{error,Reason}&lt;/code&gt; or an exit: &lt;code&gt;{'EXIT',Reason}&lt;/code&gt;. According to the XML 1.0 standard there are &lt;code&gt;fatal error&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; situations. The fatal errors &lt;strong&gt;must&lt;/strong&gt; be detected by a conforming parser while an error &lt;strong&gt;may&lt;/strong&gt; be detected. Both categories of errors are reported as fatal errors by this version of xmerl, most often as an exit.</source>
          <target state="translated">解析失败会导致错误，该错误可能是元组 &lt;code&gt;{error,Reason}&lt;/code&gt; 或退出： &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 。根据XML 1.0标准，存在 &lt;code&gt;fatal error&lt;/code&gt; 和 &lt;code&gt;error&lt;/code&gt; 情况。致命错误&lt;strong&gt;必须&lt;/strong&gt;由合格的解析器检测，而&lt;strong&gt;可能&lt;/strong&gt;会检测到错误。此版本的xmerl将这两种类型的错误都报告为致命错误，大多数情况下是作为出口。</target>
        </trans-unit>
        <trans-unit id="7163f714c0d7d3d9c32d044b0d111ec28a619786" translate="yes" xml:space="preserve">
          <source>An unsuccessful parse returns &lt;code&gt;fail&lt;/code&gt;.</source>
          <target state="translated">不成功的解析返回 &lt;code&gt;fail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02f4b27ab4513330d46be679798a210b6836a2bb" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;file/1&lt;/code&gt;, but takes a list of forms (in the Erlang abstract format representation) as first argument. Option &lt;code&gt;binary&lt;/code&gt; is implicit, that is, no object code file is produced. For options that normally produce a listing file, such as 'E', the internal format for that compiler pass (an Erlang term, usually not a binary) is returned instead of a binary.</source>
          <target state="translated">类似于 &lt;code&gt;file/1&lt;/code&gt; ，但是将格式列表（以Erlang抽象格式表示）作为第一个参数。选项 &lt;code&gt;binary&lt;/code&gt; 是隐式的，即不生成任何目标代码文件。对于通常会产生列表文件的选项，例如&amp;ldquo; E&amp;rdquo;，将返回该编译器通道的内部格式（Erlang术语，通常不是二进制），而不是二进制。</target>
        </trans-unit>
        <trans-unit id="3cfe04f04027764dce50d28f04c6ecdc62b2192c" translate="yes" xml:space="preserve">
          <source>Analyses raw profile data in the &lt;code&gt;fprof&lt;/code&gt; server. If called while there is no raw profile data available, &lt;code&gt;{error, no_profile}&lt;/code&gt; is returned.</source>
          <target state="translated">在 &lt;code&gt;fprof&lt;/code&gt; 服务器中分析原始配置文件数据。如果在没有可用的原始概要文件数据的情况下调用该命令 &lt;code&gt;{error, no_profile}&lt;/code&gt; 则返回{error，no_profile}。</target>
        </trans-unit>
        <trans-unit id="89317b6eabbaf1e93c0ba769bafe3e74241cb74f" translate="yes" xml:space="preserve">
          <source>Analysing; the raw profile data is sorted and dumped in text format either to file or console.</source>
          <target state="translated">分析;对原始数据进行分类并以文本格式转储到文件或控制台。</target>
        </trans-unit>
        <trans-unit id="d2cf6f5074202c6dffeb5df464d0d684dc5098ed" translate="yes" xml:space="preserve">
          <source>Analysing; the raw profile data is sorted, filtered and dumped in text format either to file or console. The text format intended to be both readable for a human reader, as well as parsable with the standard erlang parsing tools.</source>
          <target state="translated">分析;对原始资料进行分类、过滤,并以文本格式转存到文件或控制台。文本格式旨在使人类读者能够读懂,并能用标准的erlang解析工具进行解析。</target>
        </trans-unit>
        <trans-unit id="4263863a7deae978003d2e013055bda2bff811e8" translate="yes" xml:space="preserve">
          <source>Analysis and Utility Functions for Instrumentation</source>
          <target state="translated">仪表的分析和实用功能</target>
        </trans-unit>
        <trans-unit id="33f45b6fb7384ec22cc9390f7b457147372d66b4" translate="yes" xml:space="preserve">
          <source>Analysis of type &lt;code&gt;calls&lt;/code&gt; is used to find out how many times something has been called and is represented by an integer &lt;code&gt;Calls&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;calls&lt;/code&gt; 分析用于找出已被调用多少次并由整数 &lt;code&gt;Calls&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="48073b1fc4f77f2b869e441fa62a40b84feeabf7" translate="yes" xml:space="preserve">
          <source>Analysis of type &lt;code&gt;coverage&lt;/code&gt; is used to find out how much of the code has been executed and how much has not been executed. Coverage is represented by a tuple &lt;code&gt;{Cov,NotCov}&lt;/code&gt;, where &lt;code&gt;Cov&lt;/code&gt; is the number of executable lines that have been executed at least once and &lt;code&gt;NotCov&lt;/code&gt; is the number of executable lines that have not been executed.</source>
          <target state="translated">类型 &lt;code&gt;coverage&lt;/code&gt; 分析用于找出已执行了多少代码和未执行了多少代码。覆盖范围由元组 &lt;code&gt;{Cov,NotCov}&lt;/code&gt; 表示，其中 &lt;code&gt;Cov&lt;/code&gt; 是至少执行一次的可执行行的数量， &lt;code&gt;NotCov&lt;/code&gt; 是尚未执行的可执行行的数量。</target>
        </trans-unit>
        <trans-unit id="28ba17ebd62463c58ee41d92b0a1a95c3083533c" translate="yes" xml:space="preserve">
          <source>Analyzed Modules.</source>
          <target state="translated">分析的模块。</target>
        </trans-unit>
        <trans-unit id="460a405a1e58156272bea6a12fd732a955bce079" translate="yes" xml:space="preserve">
          <source>Analyzes a &quot;source code form&quot; node. If &lt;code&gt;Node&lt;/code&gt; is a &quot;form&quot; type (cf. &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt;), the returned value is a tuple &lt;code&gt;{Type, Info}&lt;/code&gt; where &lt;code&gt;Type&lt;/code&gt; is the node type and &lt;code&gt;Info&lt;/code&gt; depends on &lt;code&gt;Type&lt;/code&gt;, as follows:</source>
          <target state="translated">分析&amp;ldquo;源代码形式&amp;rdquo;节点。如果 &lt;code&gt;Node&lt;/code&gt; 是&amp;ldquo;表单&amp;rdquo;类型（参见 &lt;code&gt;erl_syntax:is_form/1&lt;/code&gt; ），则返回值是一个元组 &lt;code&gt;{Type, Info}&lt;/code&gt; ，其中 &lt;code&gt;Type&lt;/code&gt; 是节点类型，而 &lt;code&gt;Info&lt;/code&gt; 取决于 &lt;code&gt;Type&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="70965802de1cdb6b126e1b8a48df610079f9270c" translate="yes" xml:space="preserve">
          <source>Analyzes a sequence of &quot;program forms&quot;. The given &lt;code&gt;Forms&lt;/code&gt; may be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of &quot;program form&quot; syntax trees. The returned value is a list of pairs &lt;code&gt;{Key, Info}&lt;/code&gt;, where each value of &lt;code&gt;Key&lt;/code&gt; occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</source>
          <target state="translated">分析&amp;ldquo;程序形式&amp;rdquo;的序列。给定的 &lt;code&gt;Forms&lt;/code&gt; 可以是 &lt;code&gt;form_list&lt;/code&gt; 类型的单个语法树，也可以是&amp;ldquo;程序形式&amp;rdquo;语法树的列表。返回的值是一对 &lt;code&gt;{Key, Info}&lt;/code&gt; 对的列表，其中 &lt;code&gt;Key&lt;/code&gt; 的每个值在列表中最多出现一次；缺少特定密钥表示该密钥没有明确定义的值。</target>
        </trans-unit>
        <trans-unit id="125ee5a1deaa5b8939564769889b333464e04925" translate="yes" xml:space="preserve">
          <source>Analyzes an attribute node. If &lt;code&gt;Node&lt;/code&gt; represents a preprocessor directive, the atom &lt;code&gt;preprocessor&lt;/code&gt; is returned. Otherwise, if &lt;code&gt;Node&lt;/code&gt; represents a module attribute &quot;&lt;code&gt;-&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;...&lt;/code&gt;&quot;, a tuple &lt;code&gt;{Name, Info}&lt;/code&gt; is returned, where &lt;code&gt;Info&lt;/code&gt; depends on &lt;code&gt;Name&lt;/code&gt;, as follows:</source>
          <target state="translated">分析属性节点。如果 &lt;code&gt;Node&lt;/code&gt; 代表预处理程序指令，则返回原子 &lt;code&gt;preprocessor&lt;/code&gt; 。否则，如果 &lt;code&gt;Node&lt;/code&gt; 表示模块属性&amp;ldquo; &lt;code&gt;-&amp;lt;em&amp;gt;Name&amp;lt;/em&amp;gt;...&lt;/code&gt; &amp;rdquo;，则返回元组 &lt;code&gt;{Name, Info}&lt;/code&gt; ，其中 &lt;code&gt;Info&lt;/code&gt; 依赖于 &lt;code&gt;Name&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="ef0e889da6c5673f0c6c3783750b01ddef2430db" translate="yes" xml:space="preserve">
          <source>Anchoring a regular expression with &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; is not implemented in the current version of Leex and just generates a parse error.</source>
          <target state="translated">在当前版本的Leex中，未实现使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 锚定正则表达式，而只是生成解析错误。</target>
        </trans-unit>
        <trans-unit id="5aace8ed00b60bb7e100a0b020b8edb7ad2f3f46" translate="yes" xml:space="preserve">
          <source>And Erlang can, for example, be started as follows:</source>
          <target state="translated">而以Erlang为例,可以按如下方式启动。</target>
        </trans-unit>
        <trans-unit id="b8f34731c7287aa9d542ce40b48dcd5e89055c21" translate="yes" xml:space="preserve">
          <source>And Fred logs on at c3@gollum:</source>
          <target state="translated">而弗雷德在c3@gollum上登录。</target>
        </trans-unit>
        <trans-unit id="ad418175758dc89c620d8f9c8bf36148160d3cc4" translate="yes" xml:space="preserve">
          <source>And a callback module &lt;code&gt;ch2.erl&lt;/code&gt;:</source>
          <target state="translated">还有一个回调模块 &lt;code&gt;ch2.erl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc42de5f14df63fba8158204084452c3de1e9550" translate="yes" xml:space="preserve">
          <source>And a message is sent to &lt;code&gt;mess_client&lt;/code&gt;:</source>
          <target state="translated">然后一条消息发送到 &lt;code&gt;mess_client&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f85832be1eb32b29f34ce60cf06e70f7454181cc" translate="yes" xml:space="preserve">
          <source>And a registered process &lt;code&gt;call_server&lt;/code&gt; with &lt;code&gt;Pid == &amp;lt;0.31.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">并使用 &lt;code&gt;Pid == &amp;lt;0.31.0&amp;gt;&lt;/code&gt; 的注册进程 &lt;code&gt;call_server&lt;/code&gt; 像这样：</target>
        </trans-unit>
        <trans-unit id="016bfa826d5a0a1dc763d9d701f8d84a2f10cb83" translate="yes" xml:space="preserve">
          <source>And finally a print-out of the entire internal form:</source>
          <target state="translated">最后把整个内部表格打印出来。</target>
        </trans-unit>
        <trans-unit id="2dce29dbbed23249542b78338df490da31ae18ce" translate="yes" xml:space="preserve">
          <source>And for 32 bit MSYS2:</source>
          <target state="translated">而对于32位的MSYS2。</target>
        </trans-unit>
        <trans-unit id="18268da8563e564ff18a86c591d17c9624d33b67" translate="yes" xml:space="preserve">
          <source>And for &lt;code&gt;id_key_purpose()&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;id_key_purpose()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="768d8655abda5968a013c7a5532efc554753aa5e" translate="yes" xml:space="preserve">
          <source>And for a general range, with &lt;code&gt;N = 1&lt;/code&gt; for &lt;code&gt;exrop&lt;/code&gt;, and &lt;code&gt;N = 3&lt;/code&gt; for &lt;code&gt;exs1024s&lt;/code&gt;:</source>
          <target state="translated">和用于一般的范围内， &lt;code&gt;N = 1&lt;/code&gt; 为 &lt;code&gt;exrop&lt;/code&gt; ，和 &lt;code&gt;N = 3&lt;/code&gt; 为 &lt;code&gt;exs1024s&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="61f39e10b59f839d05bcb5b7c68284a73641ca05" translate="yes" xml:space="preserve">
          <source>And for a table:</source>
          <target state="translated">而对于一个表。</target>
        </trans-unit>
        <trans-unit id="f32a5379f3901539fad45723e5315643f98fc032" translate="yes" xml:space="preserve">
          <source>And in, for example, a test suite or a &lt;code&gt;Common Test Hook&lt;/code&gt; function:</source>
          <target state="translated">例如，在测试套件或 &lt;code&gt;Common Test Hook&lt;/code&gt; 函数中：</target>
        </trans-unit>
        <trans-unit id="b39e800fe601dd23ff96f3b954343b70886eba71" translate="yes" xml:space="preserve">
          <source>And now calculate the factorial of 4.</source>
          <target state="translated">而现在计算4的阶乘。</target>
        </trans-unit>
        <trans-unit id="ff53b326c9030dfc8cca6e6eeea89ed1bca8b120" translate="yes" xml:space="preserve">
          <source>And so on. This is an example of &quot;lazy embedding&quot;.</source>
          <target state="translated">以此类推。这就是 &quot;懒惰嵌入 &quot;的一个例子。</target>
        </trans-unit>
        <trans-unit id="3d04ebfadc776eff044e9ab17fb00bbb3672b0de" translate="yes" xml:space="preserve">
          <source>And some more missing time can be explained by the fact that &lt;code&gt;prim_file:open_int/4&lt;/code&gt; both calls &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; directly as well as through &lt;code&gt;prim_file:open_int_setopts/3&lt;/code&gt;, which complicates the picture.</source>
          <target state="translated">&lt;code&gt;prim_file:open_int/4&lt;/code&gt; 既直接调用 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 也通过 &lt;code&gt;prim_file:open_int_setopts/3&lt;/code&gt; 调用prim_file：drv_command / 2，这一事实使得图片复杂化了。</target>
        </trans-unit>
        <trans-unit id="8cf834b4e9e15474add0506b2ca7667f1657b7fc" translate="yes" xml:space="preserve">
          <source>And that the following &lt;code&gt;match_object/2&lt;/code&gt; call:</source>
          <target state="translated">然后下面的 &lt;code&gt;match_object/2&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="8f00d04a945f184b6b51fdfb0f37681af77ca055" translate="yes" xml:space="preserve">
          <source>And the &quot;ping&quot; process on kosken is started (from the code above you can see that a parameter of the &lt;code&gt;start_ping&lt;/code&gt; function is the node name of the Erlang system where &quot;pong&quot; is running):</source>
          <target state="translated">然后在kosken上启动&amp;ldquo; ping&amp;rdquo;进程（从上面的代码中，您可以看到 &lt;code&gt;start_ping&lt;/code&gt; 函数的参数是运行&amp;ldquo; pong&amp;rdquo;的Erlang系统的节点名称）：</target>
        </trans-unit>
        <trans-unit id="2693ffaa052313e03eb07995024a1c7e72e3275b" translate="yes" xml:space="preserve">
          <source>And the following is seen on (ping@gollum):</source>
          <target state="translated">而以下是在(ping@gollum)上看到的。</target>
        </trans-unit>
        <trans-unit id="ebfe1b54ebc30947606f5975c34d6ebe29e39c89" translate="yes" xml:space="preserve">
          <source>And the programmers view of the same message. First a list of ActionRequest records are constructed and then it is sent with one of the send functions in the API:</source>
          <target state="translated">而程序员对同一消息的看法。首先构造一个ActionRequest记录列表,然后用API中的一个发送函数进行发送。</target>
        </trans-unit>
        <trans-unit id="03698758048cbbb8b318d7515b41284328ea7526" translate="yes" xml:space="preserve">
          <source>And the result shows that the Diffie-Hellman Group1 is added at the head of the kex list</source>
          <target state="translated">而结果显示,Diffie-Hellman Group1被添加在kex列表的头部。</target>
        </trans-unit>
        <trans-unit id="677cd0a3c0fb90ee5c86c4248e6d3267ac590429" translate="yes" xml:space="preserve">
          <source>And then start the node like this (line breaks in the command are for readability, and shall not be there when typed):</source>
          <target state="translated">然后像这样启动节点(命令中的换行符是为了便于阅读,输入时不得有)。</target>
        </trans-unit>
        <trans-unit id="fde94e3ac5c46972cb11a3709289f9bf4a90825b" translate="yes" xml:space="preserve">
          <source>And waits for a reply from the server.</source>
          <target state="translated">并等待服务器的回复。</target>
        </trans-unit>
        <trans-unit id="f29a859de34d8206276e4fbe86c78577ef463680" translate="yes" xml:space="preserve">
          <source>And:</source>
          <target state="translated">And:</target>
        </trans-unit>
        <trans-unit id="ad0b0ead53d6b8fc85f3fce651e80aab826cba51" translate="yes" xml:space="preserve">
          <source>Anders Lindgren. The Erlang editing mode for Emacs. Ericsson, 1998.</source>
          <target state="translated">Anders Lindgren.Emacs的Erlang编辑模式。Ericsson,1998.</target>
        </trans-unit>
        <trans-unit id="3739bc370f12e87066b88cf2270e55e1c92949ae" translate="yes" xml:space="preserve">
          <source>Annotate as much of the Erlang VM as is practical.</source>
          <target state="translated">对Erlang VM进行尽可能多的注释。</target>
        </trans-unit>
        <trans-unit id="42f041d8d82dfcdd94c890b27d2f3e8b347c5ee7" translate="yes" xml:space="preserve">
          <source>Another (and quite common) case is where the regular expression matches all of the subject:</source>
          <target state="translated">另一种(也是很常见的)情况是,正则表达式匹配所有的主题。</target>
        </trans-unit>
        <trans-unit id="e1571b6f7c9e0a03f663d6275fdaf99d08ee31ce" translate="yes" xml:space="preserve">
          <source>Another (probably more) useful value is to calculate total scheduler utilization weighted against maximum amount of available CPU time:</source>
          <target state="translated">另一个(可能更有用)的值是计算调度器的总利用率与最大可用CPU时间的加权值。</target>
        </trans-unit>
        <trans-unit id="b99bcf832002b6fe6b87b103723c706b4bdbbefb" translate="yes" xml:space="preserve">
          <source>Another case where implicit anchoring is not applied is when the leading .* is inside an atomic group. Once again, a match at the start can fail where a later one succeeds. Consider the following pattern:</source>
          <target state="translated">另一种没有应用隐式锚定的情况是,当前导的.*位于原子组内。同样,开始时的匹配可能会失败,而后来的匹配则会成功。请看下面的模式。</target>
        </trans-unit>
        <trans-unit id="b6501d70d60a5f422101c69f878f9e7bfb3e72c3" translate="yes" xml:space="preserve">
          <source>Another change in OTP R16 is that the generated function &lt;code&gt;encode/2&lt;/code&gt; always returns a binary. Function &lt;code&gt;encode/2&lt;/code&gt; for the &lt;code&gt;BER&lt;/code&gt; back end used to return an iolist.</source>
          <target state="translated">OTP R16的另一个更改是，生成的函数 &lt;code&gt;encode/2&lt;/code&gt; 始终返回二进制。功能 &lt;code&gt;encode/2&lt;/code&gt; 为 &lt;code&gt;BER&lt;/code&gt; 后端用于返回iolist。</target>
        </trans-unit>
        <trans-unit id="b70c5cc0d369162e261ca81ea1735ca702bccb0d" translate="yes" xml:space="preserve">
          <source>Another class of warnings is generated by the compiler during optimization and code generation. They warn about patterns that will never match (such as &lt;code&gt;a=b&lt;/code&gt;), guards that always evaluate to false, and expressions that always fail (such as &lt;code&gt;atom+42&lt;/code&gt;).</source>
          <target state="translated">编译器在优化和代码生成期间会生成另一类警告。他们警告永远不会匹配的模式（例如 &lt;code&gt;a=b&lt;/code&gt; ），始终评估为false的守卫以及永远失败的表达式（例如 &lt;code&gt;atom+42&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59b4ff59fcdc233f63b2cf21983b15abb6faf95d" translate="yes" xml:space="preserve">
          <source>Another epmd module may return port and distribution protocol version as well.</source>
          <target state="translated">另一个epmd模块也可以返回端口和分配协议版本。</target>
        </trans-unit>
        <trans-unit id="ea09d8fd71909463182da1b49dfda6ea71b82be5" translate="yes" xml:space="preserve">
          <source>Another example is provided in the discussion of DEFINE earlier.</source>
          <target state="translated">另一个例子在前面对DEFINE的讨论中提供。</target>
        </trans-unit>
        <trans-unit id="3ea9622b1ad7af37a9c244233dff71af29dca1a6" translate="yes" xml:space="preserve">
          <source>Another example is the accented characters, where the same glyph has two different representations. The Swedish letter &quot;&amp;ouml;&quot; is one example. The Unicode standard has a code point for it, but you can also write it as &quot;o&quot; followed by &quot;U+0308&quot; (Combining Diaeresis, with the simplified meaning that the last letter is to have &quot;&amp;uml;&quot; above). They have the same glyph, user perceived character. They are for most purposes the same, but have different representations. For example, MacOS X converts all filenames to use Combining Diaeresis, while most other programs (including Erlang) try to hide that by doing the opposite when, for example, listing directories. However it is done, it is usually important to normalize such characters to avoid confusion.</source>
          <target state="translated">另一个例子是重音字符，其中相同的字形具有两种不同的表示形式。瑞典字母&amp;ldquo;&amp;ouml;&amp;rdquo;就是一个例子。 Unicode标准为此提供了一个代码点，但是您也可以将其写为&amp;ldquo; o&amp;rdquo;，后跟&amp;ldquo; U + 0308&amp;rdquo;（组合Diaeresis，其简化含义是最后一个字母在上面带有&amp;ldquo;&amp;uml;&amp;rdquo;）。它们具有相同的字形，用户感知的字符。在大多数情况下，它们是相同的，但是具有不同的表示形式。例如，MacOS X会将所有文件名都转换为使用Combining Diaeresis，而大多数其他程序（包括Erlang）尝试通过例如列出目录时执行相反的操作来隐藏该文件名。无论如何，标准化此类字符通常很重要，以避免混淆。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="10e22f420f5fb57de1efd47e3c06ac5d2818764b" translate="yes" xml:space="preserve">
          <source>Another format handler can be used to calculate the time spent by the garbage collector:</source>
          <target state="translated">另一个格式处理程序可以用来计算垃圾收集器花费的时间。</target>
        </trans-unit>
        <trans-unit id="e08d37d65c3f60aefa8f056e068de920de2ce50a" translate="yes" xml:space="preserve">
          <source>Another function, &lt;code&gt;FunctionName&lt;/code&gt;, written in the same module, can be passed as an argument, using the following syntax:</source>
          <target state="translated">可以使用以下语法将在同一模块中编写的另一个函数 &lt;code&gt;FunctionName&lt;/code&gt; 作为参数传递：</target>
        </trans-unit>
        <trans-unit id="309724e134f98c0df5fbbbce98193626ec467206" translate="yes" xml:space="preserve">
          <source>Another interesting category of test suites is the one checking that fixed bugs do not reoccur. When a bugfix is introduced, a test case that checks for that specific bug is written and submitted to the affected test suites.</source>
          <target state="translated">另一类有趣的测试套件是检查固定的bug是否再次发生的测试套件。当引入一个bugfix时,编写一个检查该特定bug的测试用例并提交给受影响的测试套件。</target>
        </trans-unit>
        <trans-unit id="cb92a0549dc41682e51c74824d96791888dae3f5" translate="yes" xml:space="preserve">
          <source>Another list-valued representation allows a message to be specified as a list whose head is a &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and whose tail is an &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt; list. This representation is used by diameter itself when relaying requests as directed by the return value of a &lt;code&gt;handle_request/3&lt;/code&gt; callback. It differs from the other two in that it bypasses the checks for messages that do not agree with their definitions in the dictionary in question: messages are sent exactly as specified.</source>
          <target state="translated">另一种列表值表示形式允许将消息指定为列表，其头部为 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; ，其尾部为 &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt; 列表。如 &lt;code&gt;handle_request/3&lt;/code&gt; 回调的返回值所指示的，在中继请求时，直径本身使用此表示形式。它与其他两个方法的不同之处在于，它绕过了对与所讨论字典中的定义不一致的消息的检查：消息完全按照指定的方式发送。</target>
        </trans-unit>
        <trans-unit id="3bc710dca2b3bdaba9f012e29980c13b5a971099" translate="yes" xml:space="preserve">
          <source>Another not uncommon scenario is to use the &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; to trigger hibernation after a certain time of inactivity. There is also a server start option &lt;code&gt;{hibernate_after, Timeout}&lt;/code&gt; for &lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">另一个不常见的情况是，在一定时间不活动之后，使用 &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; 来触发休眠模式。对于 &lt;code&gt;start/3,4&lt;/code&gt; 或 &lt;code&gt;start_link/3,4&lt;/code&gt; ，还有一个服务器启动选项 &lt;code&gt;{hibernate_after, Timeout}&lt;/code&gt; ，可用于自动使服务器休眠。</target>
        </trans-unit>
        <trans-unit id="044ae5d76a606877516f83b8c8933abd5c6a7076" translate="yes" xml:space="preserve">
          <source>Another obstacle is that some drivers do not support scrollable cursors which has the effect that the only way to traverse the result set is sequentially, with next, from the first row to the last, and once you pass a row you can not go back. This means that some functions in the interface will not work together with certain drivers. A similar problem is that not all drivers support &quot;row count&quot; for select queries, hence resulting in that the function &lt;code&gt;select_count/[3,4]&lt;/code&gt; will return &lt;code&gt;{ok, undefined}&lt;/code&gt; instead of &lt;code&gt;{ok, NrRows}&lt;/code&gt; where &lt;code&gt;NrRows&lt;/code&gt; is the number of rows in the result set.</source>
          <target state="translated">另一个障碍是，某些驱动程序不支持可滚动的游标，其结果是，遍历结果集的唯一方法是依次遍历下一个，从第一行到最后一行，并且一旦传递一行就无法返回。这意味着界面中的某些功能无法与某些驱动程序一起使用。一个类似的问题是并非所有驱动程序都支持选择查询的&amp;ldquo;行数&amp;rdquo;，因此导致函数 &lt;code&gt;select_count/[3,4]&lt;/code&gt; 将返回 &lt;code&gt;{ok, undefined}&lt;/code&gt; 而不是 &lt;code&gt;{ok, NrRows}&lt;/code&gt; ，其中 &lt;code&gt;NrRows&lt;/code&gt; 是结果集中的行。</target>
        </trans-unit>
        <trans-unit id="03ee6d9c0afb580323a804d3eab4b79501841ee3" translate="yes" xml:space="preserve">
          <source>Another option is to have an entire Erlang archive in the script. In an archive script, the interpretation of the script header is the same as in a script containing source code. This means that you can make an archive file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In an archive script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported. By default the &lt;code&gt;main/1&lt;/code&gt; function in the module with the same name as the basename of the &lt;code&gt;escript&lt;/code&gt; file is invoked. This behavior can be overridden by setting flag &lt;code&gt;-escript main Module&lt;/code&gt; as one of the emulator flags. &lt;code&gt;Module&lt;/code&gt; must be the name of a module that has an exported &lt;code&gt;main/1&lt;/code&gt; function. For more information about archives and code loading, see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">另一个选择是在脚本中包含整个Erlang存档。在存档脚本中，脚本头的解释与包含源代码的脚本中的解释相同。这意味着您可以通过在文件前添加以 &lt;code&gt;#!&lt;/code&gt; 开始的行来使归档文件可执行。和 &lt;code&gt;%%!&lt;/code&gt; 上文提到的。在存档脚本中，必须导出 &lt;code&gt;main/1&lt;/code&gt; 函数。默认情况下，将调用模块中与 &lt;code&gt;escript&lt;/code&gt; 文件的基本名称相同名称的 &lt;code&gt;main/1&lt;/code&gt; 函数。通过将标志 &lt;code&gt;-escript main Module&lt;/code&gt; 设置为仿真器标志之一，可以覆盖此行为。 &lt;code&gt;Module&lt;/code&gt; 必须是已导出 &lt;code&gt;main/1&lt;/code&gt; 的模块的名称功能。有关存档和代码加载的更多信息，请参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4546ea403c4311f977adb2b766d698fe32f245cc" translate="yes" xml:space="preserve">
          <source>Another option is to try to read the whole file in UTF-8 encoding and see if it fails. Here we need to read the file using function &lt;code&gt;io:get_chars/3&lt;/code&gt;, as we have to read characters with a code point &amp;gt; 255:</source>
          <target state="translated">另一个选择是尝试以UTF-8编码读取整个文件，然后查看它是否失败。这里我们需要使用函数 &lt;code&gt;io:get_chars/3&lt;/code&gt; 来读取文件，因为我们必须读取代码点&amp;gt; 255的字符：</target>
        </trans-unit>
        <trans-unit id="2021d9cc317b0927635ce1f21baa6d5c5c2fd2c7" translate="yes" xml:space="preserve">
          <source>Another reason to filter the state can be that the state is too large to print, as it fills the error log with uninteresting details.</source>
          <target state="translated">过滤状态的另一个原因可能是状态太大,无法打印,因为它用不感兴趣的细节填充了错误日志。</target>
        </trans-unit>
        <trans-unit id="7a115c72c46457e1cc897d74c27eca7f1027cedb" translate="yes" xml:space="preserve">
          <source>Another special case is &lt;code&gt;{message, true}&lt;/code&gt;, which sets the default behavior, as if the function had no match specification; trace message is sent with no extra information (if no other calls to &lt;code&gt;message&lt;/code&gt; are placed before &lt;code&gt;{message, true}&lt;/code&gt;, it is in fact a &quot;noop&quot;).</source>
          <target state="translated">另一个特殊情况是 &lt;code&gt;{message, true}&lt;/code&gt; ，它设置默认行为，就好像该函数没有匹配规范一样。跟踪消息的发送没有任何额外的信息（如果在 &lt;code&gt;{message, true}&lt;/code&gt; 之前没有其他 &lt;code&gt;message&lt;/code&gt; 调用，则实际上是&amp;ldquo;空转&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b328fda19cc7c09a7238c9e06a0a0739b5922118" translate="yes" xml:space="preserve">
          <source>Another thing that has been added to the messenger is a macro. The file &lt;code&gt;mess_config.hrl&lt;/code&gt; contains the definition:</source>
          <target state="translated">已添加到Messenger的另一件事是宏。文件 &lt;code&gt;mess_config.hrl&lt;/code&gt; 包含以下定义：</target>
        </trans-unit>
        <trans-unit id="99d5f93c71127e50ff2df112ec2940a1427d89fd" translate="yes" xml:space="preserve">
          <source>Another top type is &lt;code&gt;Window&lt;/code&gt; whose subcomponent actions in type &lt;code&gt;Status&lt;/code&gt; and the parts of component &lt;code&gt;buttonList&lt;/code&gt; are to be left undecoded. For this type, the function is named &lt;code&gt;decode__Window_exclusive&lt;/code&gt;. The complete &lt;code&gt;Exclusive_Decode_Instruction&lt;/code&gt; configuration is as follows:</source>
          <target state="translated">另一个顶部类型是 &lt;code&gt;Window&lt;/code&gt; ,其 &lt;code&gt;Status&lt;/code&gt; 类型中的子组件操作和组件 &lt;code&gt;buttonList&lt;/code&gt; 的各个部分将保持未解码状态。对于这种类型，该函数被命名为 &lt;code&gt;decode__Window_exclusive&lt;/code&gt; 。完整的 &lt;code&gt;Exclusive_Decode_Instruction&lt;/code&gt; 配置如下：</target>
        </trans-unit>
        <trans-unit id="13dcc540145f3717c4e3da385edb41a46331941d" translate="yes" xml:space="preserve">
          <source>Another typical overload situation is when the transaction manager cannot commit transactions at the same pace as the applications perform updates of disc resident tables. When this occurs, the message queue of the transaction manager continues to grow until the memory is exhausted or the load decreases.</source>
          <target state="translated">另一种典型的过载情况是,当事务管理器不能以与应用程序执行磁盘常驻表更新相同的速度提交事务。当这种情况发生时,事务管理器的消息队列会继续增长,直到内存耗尽或负载减少。</target>
        </trans-unit>
        <trans-unit id="98678e4d7ab8dd43533df21422a00a975cfb7ba2" translate="yes" xml:space="preserve">
          <source>Another use of backslash is for specifying generic character types:</source>
          <target state="translated">反斜杠的另一个用途是用于指定通用字符类型。</target>
        </trans-unit>
        <trans-unit id="d11989cebb406290ee365764c7d5bbc4cda6a5df" translate="yes" xml:space="preserve">
          <source>Another use of resource objects is to create binary terms with user-defined memory management. &lt;code&gt;&lt;a href=&quot;#enif_make_resource_binary&quot;&gt;enif_make_resource_binary&lt;/a&gt;&lt;/code&gt; creates a binary term that is connected to a resource object. The destructor of the resource is called when the binary is garbage collected, at which time the binary data can be released. An example of this can be a binary term consisting of data from a &lt;code&gt;mmap&lt;/code&gt;'ed file. The destructor can then do &lt;code&gt;munmap&lt;/code&gt; to release the memory region.</source>
          <target state="translated">资源对象的另一种用法是使用用户定义的内存管理来创建二进制术语。 &lt;code&gt;&lt;a href=&quot;#enif_make_resource_binary&quot;&gt;enif_make_resource_binary&lt;/a&gt;&lt;/code&gt; 创建一个连接到资源对象的二进制术语。当二进制文件被垃圾回收时，将调用资源的析构函数，此时可以释放二进制数据。这方面的一个示例可以是由来自 &lt;code&gt;mmap&lt;/code&gt; 文件的数据组成的二进制术语。然后，析构函数可以执行 &lt;code&gt;munmap&lt;/code&gt; 来释放内存区域。</target>
        </trans-unit>
        <trans-unit id="89a360b85a80ca71d493e71ccdbdd60966421147" translate="yes" xml:space="preserve">
          <source>Another usefull way to debug the agent is to pretty-print the content of all the tables and/or variables handled directly by the agent. This can be done by simply calling:</source>
          <target state="translated">另一个调试代理的有用方法是漂亮地打印所有表和/或代理直接处理的变量的内容。这可以通过简单的调用来完成。</target>
        </trans-unit>
        <trans-unit id="631c1a6022578e3dee77a77d5a201dbaf7fc890e" translate="yes" xml:space="preserve">
          <source>Another way of creating and giving a variable a value is by using the match operator = . So if you write &lt;code&gt;M = 5&lt;/code&gt;, a variable called &lt;code&gt;M&lt;/code&gt; is created with the value 5. If, in the same scope, you then write &lt;code&gt;M = 6&lt;/code&gt;, an error is returned. Try this out in the shell:</source>
          <target state="translated">创建和给变量赋值的另一种方法是使用match操作符=。因此，如果您写入 &lt;code&gt;M = 5&lt;/code&gt; ，则将创建一个名为 &lt;code&gt;M&lt;/code&gt; 的变量，其值是5。如果在相同范围内写入 &lt;code&gt;M = 6&lt;/code&gt; ，则将返回错误。在外壳中尝试一下：</target>
        </trans-unit>
        <trans-unit id="beaca871bb31a9b7342a385e8665dcccb5f095c3" translate="yes" xml:space="preserve">
          <source>Another way of measuring system load is to divide the number of busy CPU cycles by the total number of CPU cycles. This produces values in the 0-100 range immediately. However, this method hides the fact that a machine can be more or less saturated. CPU utilization is therefore a better name than system load for this measure.</source>
          <target state="translated">测量系统负载的另一种方法是用CPU的总周期数除以CPU的繁忙周期数。这样可以立即产生0-100范围内的数值。然而,这种方法掩盖了一个事实,即一台机器可以或多或少地处于饱和状态。因此,CPU利用率是比系统负载更好的测量名称。</target>
        </trans-unit>
        <trans-unit id="b77873668d8c56ac39491fa5217a49f4134bcf11" translate="yes" xml:space="preserve">
          <source>Another way of tracing from the shell is to explicitly start a &lt;strong&gt;tracer&lt;/strong&gt; and then set the &lt;strong&gt;trace flags&lt;/strong&gt; of your choice on the processes you want to trace, e.g. trace messages and process events:</source>
          <target state="translated">从外壳进行跟踪的另一种方法是显式启动&lt;strong&gt;跟踪器&lt;/strong&gt;，然后在要&lt;strong&gt;跟踪&lt;/strong&gt;的进程上设置您选择的&lt;strong&gt;跟踪标志&lt;/strong&gt;，例如，跟踪消息和进程事件：</target>
        </trans-unit>
        <trans-unit id="4b3ea1157a1e3ea0689f0faf146db56bad7d2042" translate="yes" xml:space="preserve">
          <source>Another way of writing an ASCII space</source>
          <target state="translated">ASCII空间的另一种写法</target>
        </trans-unit>
        <trans-unit id="a5bc6479b6ef5274ab93784eff95e33c9f88ddd5" translate="yes" xml:space="preserve">
          <source>Another way to avoid the ambiguity inherent in the use of digits following a backslash is to use the \g escape sequence. This escape must be followed by an unsigned number or a negative number, optionally enclosed in braces. The following examples are identical:</source>
          <target state="translated">另一种避免在反斜杠后使用数字时产生歧义的方法是使用\g转义序列。这个转义符后面必须是一个无符号的数字或负数,可以用括号括起来。下面的例子是相同的。</target>
        </trans-unit>
        <trans-unit id="f458a6491b77ecc59537584a0547eeea4ea55395" translate="yes" xml:space="preserve">
          <source>Another way to do it is through a convenience macro &lt;code&gt;?HANDLE_COMMON/0&lt;/code&gt;:</source>
          <target state="translated">另一种方法是通过便捷宏 &lt;code&gt;?HANDLE_COMMON/0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b35642aab3a9386c91529db83078918912ca068a" translate="yes" xml:space="preserve">
          <source>Another way to handle a late time-out can be to not cancel it, but to ignore it if it arrives in a state where it is known to be late.</source>
          <target state="translated">另一种处理迟到超时的方法可以是不取消它,但如果它到达一个已知迟到的状态,则忽略它。</target>
        </trans-unit>
        <trans-unit id="eab5fcb4424189a95f4719598653f6d7d5dc728f" translate="yes" xml:space="preserve">
          <source>Another way to shut down the Erlang system is by entering &lt;code&gt;halt()&lt;/code&gt;:</source>
          <target state="translated">关闭Erlang系统的另一种方法是输入 &lt;code&gt;halt()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92b1a017090fced695e7f6bcf9c838e8a0d3d945" translate="yes" xml:space="preserve">
          <source>Another way to to profile a specific function is to use &lt;code&gt;lcnt:apply/3&lt;/code&gt; or &lt;code&gt;lcnt:apply/1&lt;/code&gt; which does &lt;code&gt;lcnt:clear/0&lt;/code&gt; before the function and &lt;code&gt;lcnt:collect/0&lt;/code&gt; after its invocation. This method should only be used in micro-benchmarks since it sets &lt;code&gt;copy_save&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for the duration of the function call, which may cause the emulator to run out of memory if attempted under load.</source>
          <target state="translated">剖析特定功能的另一种方法是使用 &lt;code&gt;lcnt:apply/3&lt;/code&gt; 或 &lt;code&gt;lcnt:apply/1&lt;/code&gt; ，它在函数之前执行 &lt;code&gt;lcnt:clear/0&lt;/code&gt; ，在调用函数之后执行 &lt;code&gt;lcnt:collect/0&lt;/code&gt; 。此方法仅应在微基准测试中使用，因为它将在函数调用期间将 &lt;code&gt;copy_save&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，如果在负载下尝试，则可能导致模拟器内存​​不足。</target>
        </trans-unit>
        <trans-unit id="5c508f0c9fa83edd30ab43020e59877671989a88" translate="yes" xml:space="preserve">
          <source>Answer message are constructed by the user, except in the case of some protocol errors, in which case the procedures are followed.</source>
          <target state="translated">应答信息由用户自行构造,但在某些协议错误的情况下,则按程序进行。</target>
        </trans-unit>
        <trans-unit id="f990ff206be9a4e762b0a5b682dfe432e3832419" translate="yes" xml:space="preserve">
          <source>Answers are formulated by the user in most cases. Answers setting the E-bit can be sent by diameter itself in response to a request that cannot be handled by the user.</source>
          <target state="translated">在大多数情况下,答案由用户制定。设置E位的答案可以由直径自己发送,以响应用户不能处理的请求。</target>
        </trans-unit>
        <trans-unit id="169733414ac8e9f0faf1ef2e5d16061544324aa9" translate="yes" xml:space="preserve">
          <source>Answers sent by diameter set the E-bit in the Diameter Header. Since RFC 3588 allows only 3xxx result codes in an &lt;code&gt;answer-message&lt;/code&gt;, &lt;code&gt;answer&lt;/code&gt; has the same semantics as &lt;code&gt;answer_3xxx&lt;/code&gt; when the transport in question has been configured with &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; as its common dictionary. Since RFC 6733 allows both 3xxx and 5xxx result codes in an &lt;code&gt;answer-message&lt;/code&gt;, a transport with &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; as its common dictionary does distinguish between &lt;code&gt;answer_3xxx&lt;/code&gt; and &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">通过直径发送的答案将在直径标题中设置E位。由于RFC 3588在 &lt;code&gt;answer-message&lt;/code&gt; 仅允许使用3xxx结果代码，因此，当所讨论的传输已配置为 &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; 作为其通用字典时， &lt;code&gt;answer&lt;/code&gt; 具有与 &lt;code&gt;answer_3xxx&lt;/code&gt; 相同的语义。由于RFC 6733允许在 &lt;code&gt;answer-message&lt;/code&gt; 同时使用3xxx和5xxx结果代码，因此，使用 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 作为其通用字典的传输确实会在 &lt;code&gt;answer_3xxx&lt;/code&gt; 和 &lt;code&gt;answer&lt;/code&gt; 之间进行区分。</target>
        </trans-unit>
        <trans-unit id="9583537a8ed59cb672cc8682638edb7ea0041ae4" translate="yes" xml:space="preserve">
          <source>Answers with an unknown Hop-by-Hop Identifier are discarded.</source>
          <target state="translated">逐跳标识符未知的答案将被丢弃。</target>
        </trans-unit>
        <trans-unit id="3e81377569d145d2611633104ee94d8766283535" translate="yes" xml:space="preserve">
          <source>Any &quot;non-word&quot; character</source>
          <target state="translated">任何 &quot;非字 &quot;字符</target>
        </trans-unit>
        <trans-unit id="85b67100ee7b90e2d2abf4839ebeec56e0874f69" translate="yes" xml:space="preserve">
          <source>Any &quot;word&quot; character</source>
          <target state="translated">任何 &quot;字 &quot;字</target>
        </trans-unit>
        <trans-unit id="1da1afe530c2a09d5e4de484a6f1c75175270218" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; returned from this call are handled as if they were appended to the actions returned by the state callback that caused the state entry.</source>
          <target state="translated">从此调用返回的所有 &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 都将被处理，就像它们被追加到导致状态进入的状态回调返回的操作一样。</target>
        </trans-unit>
        <trans-unit id="0b7cf207a939aac0db4a1f7cbab14794dc67dd5e" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;{netmask,_}&lt;/code&gt;, &lt;code&gt;{broadaddr,_}&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; tuples that follow an &lt;code&gt;{addr,_}&lt;/code&gt; tuple concerns that address.</source>
          <target state="translated">在 &lt;code&gt;{addr,_}&lt;/code&gt; 元组之后的任何 &lt;code&gt;{netmask,_}&lt;/code&gt; ， &lt;code&gt;{broadaddr,_}&lt;/code&gt; 或 &lt;code&gt;{dstaddr,_}&lt;/code&gt; 元组都与该地址有关。</target>
        </trans-unit>
        <trans-unit id="9fe20daf09d18f48c6423a6e429a2fc557aba724" translate="yes" xml:space="preserve">
          <source>Any Erlang terms can be passed to a NIF as function arguments and be returned as function return values. The terms are of C-type &lt;code&gt;&lt;a href=&quot;#ERL_NIF_TERM&quot;&gt;ERL_NIF_TERM&lt;/a&gt;&lt;/code&gt; and can only be read or written using API functions. Most functions to read the content of a term are prefixed &lt;code&gt;enif_get_&lt;/code&gt; and usually return &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) if the term is of the expected type (or not). The functions to write terms are all prefixed &lt;code&gt;enif_make_&lt;/code&gt; and usually return the created &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;. There are also some functions to query terms, like &lt;code&gt;enif_is_atom&lt;/code&gt;, &lt;code&gt;enif_is_identical&lt;/code&gt;, and &lt;code&gt;enif_compare&lt;/code&gt;.</source>
          <target state="translated">任何Erlang术语都可以作为函数参数传递给NIF，并作为函数返回值返回。这些术语属于C类型的 &lt;code&gt;&lt;a href=&quot;#ERL_NIF_TERM&quot;&gt;ERL_NIF_TERM&lt;/a&gt;&lt;/code&gt; ，只能使用API​​函数读取或写入。大部分用于读取术语内容的函数都以 &lt;code&gt;enif_get_&lt;/code&gt; 为前缀，并且如果该术语属于预期类型（或非预期类型），则通常返回 &lt;code&gt;true&lt;/code&gt; （或 &lt;code&gt;false&lt;/code&gt; ）。编写术语的函数都 &lt;code&gt;enif_make_&lt;/code&gt; 前缀，通常返回创建的 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 。还有一些查询术语的函数，例如 &lt;code&gt;enif_is_atom&lt;/code&gt; ， &lt;code&gt;enif_is_identical&lt;/code&gt; 和 &lt;code&gt;enif_compare&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91ee5b553226d8e2804f2a9b1b852b4188f05b90" translate="yes" xml:space="preserve">
          <source>Any Perl &quot;word&quot; character. Matches the same characters as Xan, plus underscore.</source>
          <target state="translated">任何 Perl 的 &quot;word &quot;字符。匹配的字符与Xan相同,加上下划线。</target>
        </trans-unit>
        <trans-unit id="2a6ee9049397cf4af2bc8f42c671c9f43f3a14a3" translate="yes" xml:space="preserve">
          <source>Any Perl space character. Matches the same as Xps, except that vertical tab is excluded.</source>
          <target state="translated">任何 Perl 中的空格字符。匹配的字符与Xps相同,但不包括垂直制表符。</target>
        </trans-unit>
        <trans-unit id="226314c00726c9d0643044e7e14db2c1e0125f64" translate="yes" xml:space="preserve">
          <source>Any Posix space character. Matches the characters tab, line feed, vertical tab, form feed, carriage return, and any other character that has the Z (separator) property.</source>
          <target state="translated">任何Posix空格字符。匹配字符tab、换行符、垂直tab、换页符、回车符以及其他任何具有Z(分隔符)属性的字符。</target>
        </trans-unit>
        <trans-unit id="86c83cd82d7f4cc2cb73a7ce452f11a22f90230a" translate="yes" xml:space="preserve">
          <source>Any SNMP agent must implement the &lt;code&gt;system&lt;/code&gt; group and the &lt;code&gt;snmp&lt;/code&gt; group, defined in MIB-II. The definitions of these groups have changed from SNMPv1 to SNMPv2. MIBs and implementations for both of these versions are Provided in the distribution. The MIB file for SNMPv1 is called STANDARD-MIB, and the corresponding for SNMPv2 is called SNMPv2-MIB. If the agent is configured for SNMPv1 only, the STANDARD-MIB is loaded by default; otherwise, the SNMPv2-MIB is loaded by default. It is possible to override this default behavior, by explicitly loading another version of this MIB, for example, you could choose to implement the union of all objects in these two MIBs.</source>
          <target state="translated">任何SNMP代理都必须实现MIB-II中定义的 &lt;code&gt;system&lt;/code&gt; 组和 &lt;code&gt;snmp&lt;/code&gt; 组。这些组的定义已从SNMPv1更改为SNMPv2。发行版中提供了这两个版本的MIB和实现。SNMPv1的MIB文件称为STANDARD-MIB，而SNMPv2的对应文件称为SNMPv2-MIB。如果仅将代理配置为使用SNMPv1，则默认情况下会加载STANDARD-MIB；否则，默认情况下会加载STANDARD-MIB。否则，默认情况下会加载SNMPv2-MIB。通过显式加载此MIB的另一个版本，可以覆盖此默认行为，例如，您可以选择实现这两个MIB中所有对象的并集。</target>
        </trans-unit>
        <trans-unit id="196d50214eeaa49a69b1974dba346995c28a22e1" translate="yes" xml:space="preserve">
          <source>Any Unicode newline sequence</source>
          <target state="translated">任何Unicode换行序列</target>
        </trans-unit>
        <trans-unit id="a65ddd3bdd2944c171915eb7fa336f1a4c035808" translate="yes" xml:space="preserve">
          <source>Any alphanumeric character. Matches characters that have either the L (letter) or the N (number) property.</source>
          <target state="translated">任何字母数字字符。匹配具有L(字母)或N(数字)属性的字符。</target>
        </trans-unit>
        <trans-unit id="8e4c53abc141aa6a5505d99af2747ead8bf5f3b8" translate="yes" xml:space="preserve">
          <source>Any argument starting with character &lt;code&gt;+&lt;/code&gt; is interpreted as an &lt;code&gt;&lt;a href=&quot;#emu_flags&quot;&gt;emulator flag&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">任何以字符 &lt;code&gt;+&lt;/code&gt; 开头的参数都将被解释为 &lt;code&gt;&lt;a href=&quot;#emu_flags&quot;&gt;emulator flag&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ec0d985bf2bc312c2013a5109c14aa8377ee3b4" translate="yes" xml:space="preserve">
          <source>Any argument starting with character &lt;code&gt;-&lt;/code&gt; (hyphen) is interpreted as a &lt;code&gt;&lt;a href=&quot;#init_flags&quot;&gt;flag&lt;/a&gt;&lt;/code&gt;, which is to be passed to the Erlang part of the runtime system, more specifically to the &lt;code&gt;init&lt;/code&gt; system process, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">任何开始字符参数 &lt;code&gt;-&lt;/code&gt; （连字符）被解释为一个 &lt;code&gt;&lt;a href=&quot;#init_flags&quot;&gt;flag&lt;/a&gt;&lt;/code&gt; ，它被传递给运行时系统的Erlang的一部分，更具体地 &lt;code&gt;init&lt;/code&gt; 系统过程中，看到 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38632ef9e937e28c7efee903ba40a94fa4e2fdf" translate="yes" xml:space="preserve">
          <source>Any available SSL/TLS option can be specified in an options file, but note that options that take a &lt;code&gt;fun()&lt;/code&gt; has to use the syntax &lt;code&gt;fun Mod:Func/Arity&lt;/code&gt; since a function body can not be compiled when consulting a file.</source>
          <target state="translated">可以在选项文件中指定任何可用的SSL / TLS选项，但请注意，采用 &lt;code&gt;fun()&lt;/code&gt; 的选项必须使用语法 &lt;code&gt;fun Mod:Func/Arity&lt;/code&gt; ,因为在查阅文件时无法编译功能主体。</target>
        </trans-unit>
        <trans-unit id="01cf19500fd684b4fcd4ae4381bd475d059416c3" translate="yes" xml:space="preserve">
          <source>Any binaries in the input must be encoded with utf8 encoding.</source>
          <target state="translated">输入中的任何二进制文件必须用utf8编码。</target>
        </trans-unit>
        <trans-unit id="d4fbd6641fa6af8908c4acddf8ea7d500dda6804" translate="yes" xml:space="preserve">
          <source>Any character that \p{Nd} matches (decimal digit)</source>
          <target state="translated">任何符合(小数点)的字符。</target>
        </trans-unit>
        <trans-unit id="ea8d8e8635593d775e42e49ce0087f6c13f6687f" translate="yes" xml:space="preserve">
          <source>Any character that \p{Z} or \h or \v</source>
          <target state="translated">任何字符,如p{z}或h或v。</target>
        </trans-unit>
        <trans-unit id="5a07d4df31dba87893c12b1bbe3486e16831b58c" translate="yes" xml:space="preserve">
          <source>Any character that is not a decimal digit</source>
          <target state="translated">任何非小数点的字符</target>
        </trans-unit>
        <trans-unit id="a220eeb7e71547f74bdb672a46dbf62304938ae3" translate="yes" xml:space="preserve">
          <source>Any character that is not a horizontal whitespace character</source>
          <target state="translated">任何不是水平空格字符的字符。</target>
        </trans-unit>
        <trans-unit id="38b05e383aff7b661066a32cce33de8ce1d64c59" translate="yes" xml:space="preserve">
          <source>Any character that is not a vertical whitespace character</source>
          <target state="translated">任何不是垂直空白字符的字符。</target>
        </trans-unit>
        <trans-unit id="637eb6003dd0e91f78519cb1c04ebd5b49030962" translate="yes" xml:space="preserve">
          <source>Any character that is not a whitespace character</source>
          <target state="translated">任何非空格字符的字符。</target>
        </trans-unit>
        <trans-unit id="4f01080c6afb4764ff8a2fd9f3cf18325105c6f2" translate="yes" xml:space="preserve">
          <source>Any character that matches \p{L} or \p{N} matches, plus underscore</source>
          <target state="translated">凡是符合/p{L}或/p{N}的字符,加下划线。</target>
        </trans-unit>
        <trans-unit id="9e0fc4e31db4954506ff95018d4e32009cec2276" translate="yes" xml:space="preserve">
          <source>Any child process, static or dynamic, can be stopped in accordance with the shutdown specification:</source>
          <target state="translated">任何子进程,无论是静态的还是动态的,都可以按照关机规范停止。</target>
        </trans-unit>
        <trans-unit id="e61f1827d9b493037b4c65e46ae25e3793bc6166" translate="yes" xml:space="preserve">
          <source>Any decimal digit</source>
          <target state="translated">任何小数点</target>
        </trans-unit>
        <trans-unit id="319ee56af7d8c4842eef10b32506ec7273db2e2d" translate="yes" xml:space="preserve">
          <source>Any directory structure for development will suffice as long as the released directory structure adhere to the &lt;code&gt;&lt;a href=&quot;#app_dir_released&quot;&gt;description below&lt;/a&gt;&lt;/code&gt;, but it is encouraged that the same directory structure also be used in a development environment. The version number should be omitted from the application directory name since this is an artifact of the release step.</source>
          <target state="translated">只要发布的目录结构符合 &lt;code&gt;&lt;a href=&quot;#app_dir_released&quot;&gt;description below&lt;/a&gt;&lt;/code&gt; 的描述，任何用于开发的目录结构就足够了，但是鼓励在开发环境中使用相同的目录结构。应从应用程序目录名称中省略版本号，因为这是发布步骤的产物。</target>
        </trans-unit>
        <trans-unit id="0f8a0eebe69f32841c1055bf42eb38c869fc05ac" translate="yes" xml:space="preserve">
          <source>Any error responded from ssl:connect/3</source>
          <target state="translated">任何来自ssl:connect/3的错误响应</target>
        </trans-unit>
        <trans-unit id="dec33b5efd25869658a9a136d55b25ab0eb75ddb" translate="yes" xml:space="preserve">
          <source>Any event cancels an &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; so a zero time event time-out is only generated if the event queue is empty.</source>
          <target state="translated">任何事件都会取消 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; ,因此仅在事件队列为空时才生成零时间事件超时。</target>
        </trans-unit>
        <trans-unit id="f3230758bd2f1f41e208786128600a644fbcfaad" translate="yes" xml:space="preserve">
          <source>Any event that arrives cancels this time-out. Note that a retried or inserted event counts as arrived. So does a state time-out zero event, if it was generated before this time-out is requested.</source>
          <target state="translated">任何到达的事件都会取消这个超时。注意,重试或插入的事件也算作到达。如果一个状态超时零事件是在请求超时之前产生的,那么它也算作到达。</target>
        </trans-unit>
        <trans-unit id="8b1366eda009f3cb3ff94bd016d0c7d4a6262e2b" translate="yes" xml:space="preserve">
          <source>Any existing file &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created when &lt;code&gt;write_config/2&lt;/code&gt; is called. Option &lt;code&gt;append&lt;/code&gt; can be used to add something at the end of an existing configuration file, for example, &lt;code&gt;ttb:write_config(ConfigFile,What,[append])&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;write_config/2&lt;/code&gt; 时，将删除所有现有文件 &lt;code&gt;ConfigFile&lt;/code&gt; 并创建一个新文件。选项 &lt;code&gt;append&lt;/code&gt; 可用于在现有配置文件的末尾添加内容，例如 &lt;code&gt;ttb:write_config(ConfigFile,What,[append])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="566ef8318f6e8dea307d9a0b22e6f9fb3da4fcf5" translate="yes" xml:space="preserve">
          <source>Any field from the default object that is updated is not an integer.</source>
          <target state="translated">从默认对象更新的任何字段都不是整数。</target>
        </trans-unit>
        <trans-unit id="633c884f979bcb23bdcf6332835bc8f4a916554f" translate="yes" xml:space="preserve">
          <source>Any file in the archive can be compressed, but to speed up the access of frequently read files, it can be a good idea to store &lt;code&gt;beam&lt;/code&gt; and &lt;code&gt;app&lt;/code&gt; files uncompressed in the archive.</source>
          <target state="translated">可以压缩档案中的任何文件，但是为了加快对经常读取文件的访问，最好将未压缩的 &lt;code&gt;beam&lt;/code&gt; 和 &lt;code&gt;app&lt;/code&gt; 文件存储在档案中。</target>
        </trans-unit>
        <trans-unit id="c9e92376776fce4af3e899f17a6815d5de8767ca" translate="yes" xml:space="preserve">
          <source>Any further messages sent to the servers, after this function has returned, are received by all servers after this message.</source>
          <target state="translated">在此函数返回后,再向服务器发送的任何消息,都会被此消息后的所有服务器接收。</target>
        </trans-unit>
        <trans-unit id="05a7cdc632d004fced39b4b64081edd1072ad277" translate="yes" xml:space="preserve">
          <source>Any help module (that is, regular Erlang module with name not ending with &quot;_SUITE&quot;) that resides in the same test object directory as a suite, which is part of the test, is also automatically compiled. A help module is not mistaken for a test suite (unless it has a &quot;_SUITE&quot; name). All help modules in a particular test object directory are compiled, no matter if all or only particular suites in the directory are part of the test.</source>
          <target state="translated">任何帮助模块(也就是名称不以&quot;_SUITE &quot;结尾的普通Erlang模块),只要与测试套件驻留在同一个测试对象目录下,作为测试的一部分,也会被自动编译。帮助模块不会被误认为是测试套件(除非它的名字是&quot;_SUITE&quot;)。在特定的测试对象目录中的所有帮助模块都会被编译,不管该目录中的所有或只有特定的套件是测试的一部分。</target>
        </trans-unit>
        <trans-unit id="3a6931e3ecbbcf6123711ba9b45a1b2a389671aa" translate="yes" xml:space="preserve">
          <source>Any horizontal whitespace character</source>
          <target state="translated">任何水平空白字符</target>
        </trans-unit>
        <trans-unit id="59054d406899b9265407eef94618b3745ddccb9c" translate="yes" xml:space="preserve">
          <source>Any kind of set (also included are the atomic sets).</source>
          <target state="translated">任何一种集(也包括原子集)。</target>
        </trans-unit>
        <trans-unit id="3059e6bd637c2c7edbf7392d90b2b06549a0c4a4" translate="yes" xml:space="preserve">
          <source>Any message from an agent that is not registered is delivered to the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">来自未注册代理的任何消息都会传递给&lt;strong&gt;默认用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9e3cde1fa4436f7ff04b9991cb3b2f50c010632c" translate="yes" xml:space="preserve">
          <source>Any module attribute can be specified. The attributes are stored in the compiled code and can be retrieved by calling &lt;code&gt;Module:module_info(attributes)&lt;/code&gt;, or by using the module &lt;code&gt;beam_lib(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">可以指定任何模块属性。属性存储在编译后的代码中，可以通过调用 &lt;code&gt;Module:module_info(attributes)&lt;/code&gt; 或通过使用STDLIB中的 &lt;code&gt;beam_lib(3)&lt;/code&gt; 模块来检索属性。</target>
        </trans-unit>
        <trans-unit id="29b8882fa4dee978fed00f1684dc7ee4e8066671" translate="yes" xml:space="preserve">
          <source>Any more option that is applied is passed to the final step when the generated &lt;code&gt;.erl&lt;/code&gt; file is compiled.</source>
          <target state="translated">编译生成的 &lt;code&gt;.erl&lt;/code&gt; 文件时，将应用的所有其他选项都传递到最后一步。</target>
        </trans-unit>
        <trans-unit id="b639a0e3ab8cf373688218aa41c8bf04708e870b" translate="yes" xml:space="preserve">
          <source>Any node in &lt;code&gt;Tree&lt;/code&gt; whose node type is &lt;code&gt;variable&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;), and whose list of annotations (see &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt;) contains the atom &lt;code&gt;meta_var&lt;/code&gt;, will remain unchanged in the resulting tree, except that exactly one occurrence of &lt;code&gt;meta_var&lt;/code&gt; is removed from its annotation list.</source>
          <target state="translated">&lt;code&gt;Tree&lt;/code&gt; 中任何节点类型为 &lt;code&gt;variable&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; ）并且其批注列表（请参见 &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt; ）包含原子 &lt;code&gt;meta_var&lt;/code&gt; 的节点在结果树中将保持不变，只是从其中删除了一次 &lt;code&gt;meta_var&lt;/code&gt; 其注释列表。</target>
        </trans-unit>
        <trans-unit id="12506e60046e3f66a27e9d0f21bb59c5951fbf0d" translate="yes" xml:space="preserve">
          <source>Any nodes created outside of this module must have type tags distinct from those currently defined by this module; see &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; for a complete list.</source>
          <target state="translated">在此模块外部创建的任何节点都必须具有与该模块当前定义的类型标记不同的类型标记。有关完整列表，请参见 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dd390a9f5c9070fbf0caa7f7decb4d0243c2039" translate="yes" xml:space="preserve">
          <source>Any number of alternatives can appear, and an empty alternative is permitted (matching the empty string). The matching process tries each alternative in turn, from left to right, and the first that succeeds is used. If the alternatives are within a subpattern (defined in section &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt;), &quot;succeeds&quot; means matching the remaining main pattern and the alternative in the subpattern.</source>
          <target state="translated">可以出现任意数量的替代项，并且允许使用空替代项（匹配空字符串）。匹配过程从左到右依次尝试每个备选方案，并使用第一个成功的方案。如果替代方案在子模式中（在 &lt;code&gt;&lt;a href=&quot;#sect11&quot;&gt;Subpatterns&lt;/a&gt;&lt;/code&gt; 部分中定义），则&amp;ldquo;成功&amp;rdquo;表示匹配剩余的主模式和子模式中的替代方案。</target>
        </trans-unit>
        <trans-unit id="3b219ac3ab7183b58c39d339b6c5af13a6e6e890" translate="yes" xml:space="preserve">
          <source>Any number of test terms can be declared in sequence. &lt;code&gt;Common Test&lt;/code&gt; compiles by default the terms into one or more tests to be performed in one resulting test run. A term that specifies a set of test cases &quot;swallows&quot; one that only specifies a subset of these cases. For example, the result of merging one term specifying that all cases in suite S are to be executed, with another term specifying only test case X and Y in S, is a test of all cases in S. However, if a term specifying test case X and Y in S is merged with a term specifying case Z in S, the result is a test of X, Y, and Z in S. To disable this behavior, that is, to instead perform each test sequentially in a &quot;script-like&quot; manner, set term &lt;code&gt;merge_tests&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the test specification.</source>
          <target state="translated">可以依次声明任意数量的测试术语。默认情况下， &lt;code&gt;Common Test&lt;/code&gt; 将这些术语编译为一个或多个要在一次结果测试运行中执行的测试。指定一组测试用例的术语&amp;ldquo;吞噬&amp;rdquo;一个仅指定这些用例的子集。例如，合并一个将指定要执行套件S中所有案例的术语，而另一个仅指定S中的测试案例X和Y的术语的结果是对S中所有案例的检验。但是，如果一个术语指定了test将S中的case X和Y与指定S中的case Z的术语合并，结果是对S中的X，Y和Z进行测试。要禁用此行为，即改为在&amp;ldquo;脚本&amp;rdquo;中依次执行每个测试 &lt;code&gt;merge_tests&lt;/code&gt; &amp;rdquo;方式，在测试规范中将术语merge_tests设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f1d0eacfac7695ff6458e838ae9c63e075002a8" translate="yes" xml:space="preserve">
          <source>Any of &lt;code&gt;Pos&lt;/code&gt;, &lt;code&gt;Incr&lt;/code&gt;, &lt;code&gt;Threshold&lt;/code&gt;, or &lt;code&gt;SetValue&lt;/code&gt; is not an integer.</source>
          <target state="translated">任何的 &lt;code&gt;Pos&lt;/code&gt; ， &lt;code&gt;Incr&lt;/code&gt; ， &lt;code&gt;Threshold&lt;/code&gt; ，或 &lt;code&gt;SetValue&lt;/code&gt; 不是整数。</target>
        </trans-unit>
        <trans-unit id="a07471bf046332e50c16cdbf9fa2f0e4219c9dce" translate="yes" xml:space="preserve">
          <source>Any of the Boolean options can be set to &lt;code&gt;true&lt;/code&gt; by stating the name of the option. For example, &lt;code&gt;verbose&lt;/code&gt; is equivalent to &lt;code&gt;{verbose, true}&lt;/code&gt;.</source>
          <target state="translated">可以通过说明选项名称来将任何布尔选项设置为 &lt;code&gt;true&lt;/code&gt; 。例如， &lt;code&gt;verbose&lt;/code&gt; 等效于 &lt;code&gt;{verbose, true}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d0154918457ea334a0a14f2ca39bfe72abe9e56" translate="yes" xml:space="preserve">
          <source>Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</source>
          <target state="translated">上述任何一个换行序列,以及Unicode序列VT(垂直制表符,U+000B)、FF(格式进纸,U+000C)、NEL(下一行,U+0085)、LS(行分隔符,U+2028)和PS(段落分隔符,U+2029)。</target>
        </trans-unit>
        <trans-unit id="4e36b2886b60e8d8125482994d6c845a19875794" translate="yes" xml:space="preserve">
          <source>Any of the three above</source>
          <target state="translated">以上三项中的任何一项</target>
        </trans-unit>
        <trans-unit id="86ba96738491ceb49b98c521a1260c55ed5485fb" translate="yes" xml:space="preserve">
          <source>Any of the three preceding sequences is be recognized.</source>
          <target state="translated">前面三个序列中的任何一个都可以被识别。</target>
        </trans-unit>
        <trans-unit id="81ac719a424443fef6b057e36ab2fb49dfe28608" translate="yes" xml:space="preserve">
          <source>Any of the three preceding sequences is to be recognized.</source>
          <target state="translated">前面三个序列中的任何一个都要识别。</target>
        </trans-unit>
        <trans-unit id="58b743365bb43cbc12421219d500fe35e8ea844d" translate="yes" xml:space="preserve">
          <source>Any option can be added to the Erlang compiler when compiling the generated Erlang files. Any option unrecognized by the ASN.1 compiler is passed to the Erlang compiler.</source>
          <target state="translated">在编译生成的Erlang文件时,可以向Erlang编译器添加任何选项。任何未被ASN.1编译器识别的选项都会传递给Erlang编译器。</target>
        </trans-unit>
        <trans-unit id="d80bad487ffa73c04585c5699f22527d1888dc5c" translate="yes" xml:space="preserve">
          <source>Any other character literally, for example &lt;code&gt;\\&lt;/code&gt; for backslash, &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">字面上的其他任何字符，例如 &lt;code&gt;\\&lt;/code&gt; 代表反斜杠， &lt;code&gt;\&quot;&lt;/code&gt; 代表 &lt;code&gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2982c9337e5698148dd46ac21f02f3137461b4a8" translate="yes" xml:space="preserve">
          <source>Any other return values (including exit signals or throw) and the &lt;code&gt;DefaultED&lt;/code&gt; will be used.</source>
          <target state="translated">将使用任何其他返回值（包括退出信号或抛出）和 &lt;code&gt;DefaultED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="249dc2b99b732aa6241eec01386b07432c7788b4" translate="yes" xml:space="preserve">
          <source>Any other return values (including exit signals or throw) will result in an error descriptor with code 500 (internal gateway error) and the module name (of the callback module) as reason.</source>
          <target state="translated">任何其他的返回值(包括退出信号或抛出)将导致一个错误描述符,代码为500(内部网关错误)和模块名称(回调模块的)作为原因。</target>
        </trans-unit>
        <trans-unit id="a942dcaa5bd45f30971473c45442d68ed922cbd5" translate="yes" xml:space="preserve">
          <source>Any other value &lt;code&gt;OtherValue&lt;/code&gt; returned by &lt;code&gt;Fun&lt;/code&gt; terminates the traversal and is returned immediately.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 返回的任何其他值 &lt;code&gt;OtherValue&lt;/code&gt; 都会终止遍历并立即返回。</target>
        </trans-unit>
        <trans-unit id="f4d82480914c3ee14ba49d105622133bf704f763" translate="yes" xml:space="preserve">
          <source>Any other value is immediately returned as value of the current call to &lt;code&gt;sort&lt;/code&gt; or &lt;code&gt;keysort&lt;/code&gt;. Each input function is called exactly once. If an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">其他任何值都将立即作为 &lt;code&gt;sort&lt;/code&gt; 或 &lt;code&gt;keysort&lt;/code&gt; 当前调用的值返回。每个输入函数仅被调用一次。如果发生错误，将使用参数 &lt;code&gt;close&lt;/code&gt; 调用最后一个函数，忽略其答复。</target>
        </trans-unit>
        <trans-unit id="f850a68f9f85d9da673e19d77155ac0b55fea37c" translate="yes" xml:space="preserve">
          <source>Any other variable needed by the test</source>
          <target state="translated">测试所需的任何其他变量</target>
        </trans-unit>
        <trans-unit id="9d0e66f20ad63939bfb7baf4ceddb82fb6504347" translate="yes" xml:space="preserve">
          <source>Any parameters are of the wrong type.</source>
          <target state="translated">任何参数都是错误的类型。</target>
        </trans-unit>
        <trans-unit id="933ef808931a1467e93c9ed25ccfb4780e6ed6ed" translate="yes" xml:space="preserve">
          <source>Any process can probe a blocked log with &lt;code&gt;info/1&lt;/code&gt; or close it with &lt;code&gt;close/1&lt;/code&gt;. The blocking process can also use functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, &lt;code&gt;chunk_step/3&lt;/code&gt;, and &lt;code&gt;unblock/1&lt;/code&gt; without being affected by the block. Any other attempt than those mentioned so far to update or read a blocked log suspends the calling process until the log is unblocked or returns error message &lt;code&gt;{blocked_log, Log}&lt;/code&gt;, depending on whether the value of &lt;code&gt;QueueLogRecords&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;QueueLogRecords&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;, which is used by &lt;code&gt;block/1&lt;/code&gt;.</source>
          <target state="translated">任何进程都可以使用 &lt;code&gt;info/1&lt;/code&gt; 探测被阻止的日志，或者使用 &lt;code&gt;close/1&lt;/code&gt; 来关闭它。阻塞过程也可以使用功能 &lt;code&gt;chunk/2,3&lt;/code&gt; ， &lt;code&gt;bchunk/2,3&lt;/code&gt; ， &lt;code&gt;chunk_step/3&lt;/code&gt; 和 &lt;code&gt;unblock/1&lt;/code&gt; ，而不受块的影响。根据 &lt;code&gt;QueueLogRecords&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，到目前为止，除更新或读取被阻止的日志外，任何其他尝试都将暂停调用过程，直到该日志被解除阻止或返回错误消息 &lt;code&gt;{blocked_log, Log}&lt;/code&gt; 为止。 &lt;code&gt;QueueLogRecords&lt;/code&gt; 默认为 &lt;code&gt;true&lt;/code&gt; ，由 &lt;code&gt;block/1&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="08eca955417b5ab22bebcc976cc21d89efe94422" translate="yes" xml:space="preserve">
          <source>Any process can read or write to the table.</source>
          <target state="translated">任何进程都可以对该表进行读写。</target>
        </trans-unit>
        <trans-unit id="782da514823c3f76e59a01f8bc9028c411c82cda" translate="yes" xml:space="preserve">
          <source>Any process, in any application, with &lt;code&gt;Module&lt;/code&gt; as residence module, is killed when the instruction is evaluated. The user must therefore ensure that all such processes are terminated before deleting the module, to avoid a situation with failing supervisor restarts.</source>
          <target state="translated">在评估指令时，以 &lt;code&gt;Module&lt;/code&gt; 为驻留模块的任何应用程序中的任何进程都会被杀死。因此，用户必须确保在删除模块之前终止所有此类过程，以避免主管重启失败的情况。</target>
        </trans-unit>
        <trans-unit id="89c73d072c780c8bd405077821b4399412adb61c" translate="yes" xml:space="preserve">
          <source>Any record, containing type information or not, once defined, can be used as a type using the following syntax:</source>
          <target state="translated">任何包含类型信息或不包含类型信息的记录,一旦被定义,就可以使用以下语法作为类型使用。</target>
        </trans-unit>
        <trans-unit id="4b9ac647f7a1c06663cb2845807c8bed2b8a0381" translate="yes" xml:space="preserve">
          <source>Any relative paths, specified in the test specification, are relative to the directory containing the test specification file if &lt;code&gt;ct_run -spec TestSpecFile ...&lt;/code&gt; or &lt;code&gt;ct:run:test([{spec,TestSpecFile},...])&lt;/code&gt; executes the test.</source>
          <target state="translated">如果 &lt;code&gt;ct_run -spec TestSpecFile ...&lt;/code&gt; 或 &lt;code&gt;ct:run:test([{spec,TestSpecFile},...])&lt;/code&gt; 执行测试，则在测试规范中指定的任何相对路径都相对于包含测试规范文件的目录。。</target>
        </trans-unit>
        <trans-unit id="b95b8d2f2c5d4e842e94679e4847a285aed6e939" translate="yes" xml:space="preserve">
          <source>Any required padding is added by diameter when encoding outgoing messages.</source>
          <target state="translated">任何所需的padding都会在编码外发消息时按直径添加。</target>
        </trans-unit>
        <trans-unit id="6a9a8124f1b80519c1f040df8df911b83b4c84b7" translate="yes" xml:space="preserve">
          <source>Any start flags to the Erlang runtime system (application ERTS) can also be passed as parameters to &lt;code&gt;ct_run&lt;/code&gt;. It is, for example, useful to be able to pass directories to be added to the Erlang code server search path with flag &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt;. If you have common help- or library modules for test suites (separately compiled), stored in other directories than the test suite directories, these &lt;code&gt;help/lib&lt;/code&gt; directories are preferably added to the code path this way.</source>
          <target state="translated">Erlang运行时系统（应用程序ERTS）的任何启动标志也可以作为参数传递给 &lt;code&gt;ct_run&lt;/code&gt; 。例如，使用标记 &lt;code&gt;-pa&lt;/code&gt; 或 &lt;code&gt;-pz&lt;/code&gt; 传递要添加到Erlang代码服务器搜索路径的目录很有用。如果您有用于测试套件的通用帮助或库模块（单独编译），并且存储在测试套件目录以外的其他目录中，则最好以这种方式将这些 &lt;code&gt;help/lib&lt;/code&gt; 目录添加到代码路径中。</target>
        </trans-unit>
        <trans-unit id="f182f567f67c83a2ce8839de78f5dd9c2331c337" translate="yes" xml:space="preserve">
          <source>Any term, defaults to the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">任何术语，默认为原子 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05f2f648b8aa07f43583597f53b95459b0d86b71" translate="yes" xml:space="preserve">
          <source>Any test or test set &lt;code&gt;T&lt;/code&gt; can be annotated with a title, by wrapping it in a pair &lt;code&gt;{Title, T}&lt;/code&gt;, where &lt;code&gt;Title&lt;/code&gt; is a string. For convenience, any test which is normally represented using a tuple can simply be given a title string as the first element, i.e., writing &lt;code&gt;{&quot;The Title&quot;, ...}&lt;/code&gt; instead of adding an extra tuple wrapper as in &lt;code&gt;{&quot;The Title&quot;, {...}}&lt;/code&gt;.</source>
          <target state="translated">将任何测试或测试集 &lt;code&gt;T&lt;/code&gt; 包裹在 &lt;code&gt;{Title, T}&lt;/code&gt; ，其中 &lt;code&gt;Title&lt;/code&gt; 是一个字符串，即可用标题注释。为了方便起见，通常使用元组表示的任何测试都可以简单地获得标题字符串作为第一个元素，即编写 &lt;code&gt;{&quot;The Title&quot;, ...}&lt;/code&gt; 而不是像 &lt;code&gt;{&quot;The Title&quot;, {...}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdfd965642f53e0b7729140f8c9073111a331ea3" translate="yes" xml:space="preserve">
          <source>Any transport option except &lt;code&gt;applications&lt;/code&gt; or &lt;code&gt;capabilities&lt;/code&gt;. Used as defaults for transport configuration, values passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; overriding values configured on the service.</source>
          <target state="translated">除 &lt;code&gt;applications&lt;/code&gt; 或 &lt;code&gt;capabilities&lt;/code&gt; 之外的任何传输选项。用作传输配置的默认值，传递给 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 的值将覆盖服务上配置的值。</target>
        </trans-unit>
        <trans-unit id="36287aab00e4133075843c606c024c1da69b5da0" translate="yes" xml:space="preserve">
          <source>Any undocumented functions in &lt;code&gt;string&lt;/code&gt; are not to be used.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 中未记录的任何功能都不得使用。</target>
        </trans-unit>
        <trans-unit id="4472d33a875806b4fa8c5622d64ebe7f23ffe886" translate="yes" xml:space="preserve">
          <source>Any unspecified fields are assumed to have the type in the original record declaration.</source>
          <target state="translated">任何未指定的字段都被假定为具有原始记录声明中的类型。</target>
        </trans-unit>
        <trans-unit id="f8b06f554103b0e00f9de05aa58d618718ce1b34" translate="yes" xml:space="preserve">
          <source>Any variables that are defined before the list comprehension, and that are used in filters, have the values they had before the list comprehension.</source>
          <target state="translated">任何在列表理解之前定义的变量,以及在过滤器中使用的变量,都有其在列表理解之前的值。</target>
        </trans-unit>
        <trans-unit id="f184dfb123fe5531382db694e54de8fc62711d8d" translate="yes" xml:space="preserve">
          <source>Any vertical whitespace character</source>
          <target state="translated">任何垂直空白字符</target>
        </trans-unit>
        <trans-unit id="dc95992a9a8880a458bf0ac420ad7827afd47252" translate="yes" xml:space="preserve">
          <source>Any whitespace character</source>
          <target state="translated">任何空格字符</target>
        </trans-unit>
        <trans-unit id="7d41ee854a3d2e6ed49f2b637df36ad7f9e23190" translate="yes" xml:space="preserve">
          <source>Apart from the ordinary allocators described above, some pre-allocators are used for some specific data types. These pre-allocators pre-allocate a fixed amount of memory for certain data types when the runtime system starts. As long as pre-allocated memory is available, it is used. When no pre-allocated memory is available, memory is allocated in ordinary allocators. These pre-allocators are typically much faster than the ordinary allocators, but can only satisfy a limited number of requests.</source>
          <target state="translated">除了上述的普通分配器外,还有一些预分配器用于某些特定的数据类型。这些预分配器在运行时系统启动时为某些数据类型预先分配了固定数量的内存。只要有预分配的内存,就会使用。当没有可用的预分配内存时,就用普通分配器分配内存。这些预分配器通常比普通分配器快得多,但只能满足有限的请求。</target>
        </trans-unit>
        <trans-unit id="b6fbecd567654b9cb7f086f33e2e4b65e3a20dbc" translate="yes" xml:space="preserve">
          <source>Appart from the reply message, the &lt;code&gt;{asynchronous, ReplyTag}&lt;/code&gt; option behaves exactly the same as the &lt;code&gt;asynchronous&lt;/code&gt; option without reply tag.</source>
          <target state="translated">Appart从回复消息开始， &lt;code&gt;{asynchronous, ReplyTag}&lt;/code&gt; 选项的行为与没有回复标签的 &lt;code&gt;asynchronous&lt;/code&gt; 选项完全相同。</target>
        </trans-unit>
        <trans-unit id="e3e791b60ddfbf72d731c8a8fbb0e6ea943e25bd" translate="yes" xml:space="preserve">
          <source>Appears when option &lt;code&gt;reload&lt;/code&gt; is specified. The driver &lt;code&gt;Name&lt;/code&gt; is not in the system. Only drivers loaded by this process can be reloaded.</source>
          <target state="translated">指定选项 &lt;code&gt;reload&lt;/code&gt; 时出现。驱动程序 &lt;code&gt;Name&lt;/code&gt; 不在系统中。只有通过此过程加载的驱动程序可以重新加载。</target>
        </trans-unit>
        <trans-unit id="49cc99a35d08f4016ff481d7d8153734e5631682" translate="yes" xml:space="preserve">
          <source>Appears when option &lt;code&gt;reload&lt;/code&gt; is specified. The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">指定选项 &lt;code&gt;reload&lt;/code&gt; 时出现。驱动程序 &lt;code&gt;Name&lt;/code&gt; 存在于系统中，但是在此过程中没有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ca9605c2bfb20ec231ac66a12bdad85113549dc" translate="yes" xml:space="preserve">
          <source>Append or prepend supported but not enabled algorithm(s) to the list of algorithms. If the wanted algorithms already are in &lt;code&gt;A&lt;/code&gt; they will first be removed and then appended or prepended,</source>
          <target state="translated">将支持但未启用的算法添加或添加到算法列表中。如果所需的算法已经存在于 &lt;code&gt;A&lt;/code&gt; 中，则将其首先删除，然后附加或前置，</target>
        </trans-unit>
        <trans-unit id="0eee5e3eef37b4e12873f20fbe9bf8c113511624" translate="yes" xml:space="preserve">
          <source>Append the agents config to the current manager agents config file.</source>
          <target state="translated">将代理配置添加到当前经理代理配置文件中。</target>
        </trans-unit>
        <trans-unit id="670ede32b75903ea1e527f007ab3467a091effc0" translate="yes" xml:space="preserve">
          <source>Append the community config to the current agent community config file.</source>
          <target state="translated">将社区配置添加到当前代理社区配置文件中。</target>
        </trans-unit>
        <trans-unit id="7f98e246919d3685a6470b54ee550be705b1a20d" translate="yes" xml:space="preserve">
          <source>Append the config to the current agent config file.</source>
          <target state="translated">将配置添加到当前代理配置文件中。</target>
        </trans-unit>
        <trans-unit id="5b99d7bbf0744498145642e57ca0d9bbc5019b3e" translate="yes" xml:space="preserve">
          <source>Append the config to the current manager config file.</source>
          <target state="translated">将配置添加到当前管理器配置文件中。</target>
        </trans-unit>
        <trans-unit id="4715714a265ef18003ce3a95c049a6579c5fdc19" translate="yes" xml:space="preserve">
          <source>Append the context config to the current agent context config file.</source>
          <target state="translated">将上下文配置添加到当前代理上下文配置文件中。</target>
        </trans-unit>
        <trans-unit id="098b355d60044dcd195c72fb3d8921d6f5c79432" translate="yes" xml:space="preserve">
          <source>Append the notify config to the current agent notify config file.</source>
          <target state="translated">将notify config附加到当前代理的notify config文件中。</target>
        </trans-unit>
        <trans-unit id="eacde046205397e77177cf51c65a5911a57b8615" translate="yes" xml:space="preserve">
          <source>Append the standard config to the current agent standard config file.</source>
          <target state="translated">将标准配置添加到当前代理标准配置文件中。</target>
        </trans-unit>
        <trans-unit id="10e85fc06cc23b8efed1d3e1c3fb54a94ebffb97" translate="yes" xml:space="preserve">
          <source>Append the target_addr config to the current agent target_addr config file.</source>
          <target state="translated">将 target_addr config 添加到当前代理的 target_addr config 文件中。</target>
        </trans-unit>
        <trans-unit id="87b72ce0520ffbff2c18e79fe54c87ebbca4b2fe" translate="yes" xml:space="preserve">
          <source>Append the target_params config to the current agent target_params config file.</source>
          <target state="translated">将target_params配置添加到当前代理的target_params配置文件中。</target>
        </trans-unit>
        <trans-unit id="95a8435503ae194bc5982a16880db13756b12c3e" translate="yes" xml:space="preserve">
          <source>Append the users config to the current manager users config file.</source>
          <target state="translated">将用户配置添加到当前管理器用户配置文件中。</target>
        </trans-unit>
        <trans-unit id="20d781b651b76cd62733934321351ec945be0a2a" translate="yes" xml:space="preserve">
          <source>Append the usm config to the current agent vacm config file.</source>
          <target state="translated">将usm配置添加到当前代理vacm配置文件中。</target>
        </trans-unit>
        <trans-unit id="57c21804df817ec8d20c17ff38774329e716571b" translate="yes" xml:space="preserve">
          <source>Append the usm config to the current manager usm config file.</source>
          <target state="translated">将usm配置添加到当前管理器usm配置文件中。</target>
        </trans-unit>
        <trans-unit id="5ed7647b353b68ed84afe6fde045a7489b9154cc" translate="yes" xml:space="preserve">
          <source>Append the vacm config to the current agent vacm config file.</source>
          <target state="translated">将 vacm config 添加到当前代理 vacm config 文件中。</target>
        </trans-unit>
        <trans-unit id="85d8a97e8351cb485e2588c8ecfff62c9d854b68" translate="yes" xml:space="preserve">
          <source>Appending to a binary in an efficient way can be done as follows:</source>
          <target state="translated">对二进制进行有效的追加,可以按照以下方式进行。</target>
        </trans-unit>
        <trans-unit id="ea77b245b41191501f470789eca4aba72934b9e1" translate="yes" xml:space="preserve">
          <source>Appending to a binary or bitstring is specially optimized by the &lt;strong&gt;runtime system&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;运行时系统&lt;/strong&gt;特别优化了附加到二进制或位串的&lt;strong&gt;方法&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="6eda043cc568cf13970a30ffbc0034adfa99e03f" translate="yes" xml:space="preserve">
          <source>Appendix A describes the conversion of SNMPv2 to SNMPv1 error messages.</source>
          <target state="translated">附录A描述了SNMPv2到SNMPv1错误信息的转换。</target>
        </trans-unit>
        <trans-unit id="ee91e579fc45ec4f74f6a038125846de007b671e" translate="yes" xml:space="preserve">
          <source>Appendix B contains the RFC1903 text on &lt;code&gt;RowStatus&lt;/code&gt;.</source>
          <target state="translated">附录B在RFC1903文本 &lt;code&gt;RowStatus&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df0c86c3bdb24e665fb2b6f20747db8d823ab88c" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Comments&lt;/code&gt; to the post-comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Comments&lt;/code&gt; 附加到 &lt;code&gt;Node&lt;/code&gt; 的后注释。</target>
        </trans-unit>
        <trans-unit id="f2d60430814dd0a0d3f29b110da1184762bf96c4" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Comments&lt;/code&gt; to the pre-comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">向 &lt;code&gt;Node&lt;/code&gt; 的预注释添加 &lt;code&gt;Comments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a59eafb92455934508f727a752eaa14a058cbb57" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Directory&lt;/code&gt; to the code path in the invoked Erlang emulator.</source>
          <target state="translated">将 &lt;code&gt;Directory&lt;/code&gt; 附加到被调用的Erlang仿真器中的代码路径。</target>
        </trans-unit>
        <trans-unit id="f1ae1ca945105d0b0412c9d33c6ca6cdfd36c3ed" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;Directory&lt;/code&gt; to the front of the code path in the invoked Erlang emulator. This can be used to invoke another compiler than the default one.</source>
          <target state="translated">将 &lt;code&gt;Directory&lt;/code&gt; 附加到被调用的Erlang仿真器中代码路径的前面。这可以用来调用默认编译器以外的其他编译器。</target>
        </trans-unit>
        <trans-unit id="cb49cdd164f55f2c7a30cfc667b98571effb1dc9" translate="yes" xml:space="preserve">
          <source>Appends a list of values &lt;code&gt;ValList&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;. An exception is generated if the initial value associated with &lt;code&gt;Key&lt;/code&gt; is not a list of values.</source>
          <target state="translated">将值列表 &lt;code&gt;ValList&lt;/code&gt; 追加到与 &lt;code&gt;Key&lt;/code&gt; 关联的当前值列表中。如果与 &lt;code&gt;Key&lt;/code&gt; 关联的初始值不是值列表，则会生成一个异常。</target>
        </trans-unit>
        <trans-unit id="598f89859880c8e0c4b7b657bbbf567d531c94b2" translate="yes" xml:space="preserve">
          <source>Appends a new &lt;code&gt;Value&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">将新 &lt;code&gt;Value&lt;/code&gt; 追加到与 &lt;code&gt;Key&lt;/code&gt; 关联的当前值列表中。</target>
        </trans-unit>
        <trans-unit id="84026150b614acc7231607e9aad74b0ddcd360b0" translate="yes" xml:space="preserve">
          <source>Appends a new &lt;code&gt;Value&lt;/code&gt; to the current list of values associated with &lt;code&gt;Key&lt;/code&gt;. An exception is generated if the initial value associated with &lt;code&gt;Key&lt;/code&gt; is not a list of values.</source>
          <target state="translated">将新 &lt;code&gt;Value&lt;/code&gt; 追加到与 &lt;code&gt;Key&lt;/code&gt; 关联的当前值列表中。如果与 &lt;code&gt;Key&lt;/code&gt; 关联的初始值不是值列表，则会生成一个异常。</target>
        </trans-unit>
        <trans-unit id="cc8c687a22dd5ccfe5def8e49d349b9718a5a0ba" translate="yes" xml:space="preserve">
          <source>Appends data at the end of buffer &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将数据追加到缓冲区 &lt;code&gt;x&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="394be8930f77fa3eaca7c0be83cce9cd9e021402" translate="yes" xml:space="preserve">
          <source>Appends items to a single file, which size can be limited by the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">将项目追加到一个文件中，该文件的大小可以由 &lt;code&gt;disk_log&lt;/code&gt; 模块限制。</target>
        </trans-unit>
        <trans-unit id="cdc7f1a4511966dfd1a8a1b210a23216447ca621" translate="yes" xml:space="preserve">
          <source>Appends the comments of &lt;code&gt;Source&lt;/code&gt; to the current comments of &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Source&lt;/code&gt; 的注释追加到 &lt;code&gt;Target&lt;/code&gt; 的当前注释。</target>
        </trans-unit>
        <trans-unit id="ea301cbca7c8ac46cf5931d51f42837ef8522c8f" translate="yes" xml:space="preserve">
          <source>Appends the term &lt;code&gt;Annotation&lt;/code&gt; to the list of user annotations of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">将术语 &lt;code&gt;Annotation&lt;/code&gt; 附加到 &lt;code&gt;Node&lt;/code&gt; 的用户注释列表中。</target>
        </trans-unit>
        <trans-unit id="42124fae91a7c7b871162f34d0590a73350f98e4" translate="yes" xml:space="preserve">
          <source>Application - skeletons for the OTP application behavior</source>
          <target state="translated">应用-OTP应用行为的骨架。</target>
        </trans-unit>
        <trans-unit id="b92e83d37579fa02e707537bdedda6f2347cdd94" translate="yes" xml:space="preserve">
          <source>Application ::= Atom</source>
          <target state="translated">应用 ::=Atom</target>
        </trans-unit>
        <trans-unit id="3101ceef607cbc0ae4473ea0836a862c09e72c75" translate="yes" xml:space="preserve">
          <source>Application Edges. All application calls.</source>
          <target state="translated">应用边缘。所有应用程序调用。</target>
        </trans-unit>
        <trans-unit id="3925a6e948fb7872d335532f8d20c939d631d4b3" translate="yes" xml:space="preserve">
          <source>Application Identifiers</source>
          <target state="translated">应用标识符</target>
        </trans-unit>
        <trans-unit id="d291c82890b136b5e80c48e67c846c73663b4e1e" translate="yes" xml:space="preserve">
          <source>Application dependencies</source>
          <target state="translated">应用依赖性</target>
        </trans-unit>
        <trans-unit id="cf171227ff1428401819ab3800da2acc36ae658c" translate="yes" xml:space="preserve">
          <source>Application name.</source>
          <target state="translated">应用名称:</target>
        </trans-unit>
        <trans-unit id="8c7c4bdcb550a019467191f10d8c79d46c9076de" translate="yes" xml:space="preserve">
          <source>Application parameter &lt;code&gt;schema_location&lt;/code&gt; controls where &lt;code&gt;Mnesia&lt;/code&gt; searches for its schema. The parameter can be one of the following atoms:</source>
          <target state="translated">应用程序参数 &lt;code&gt;schema_location&lt;/code&gt; 控制 &lt;code&gt;Mnesia&lt;/code&gt; 在何处搜索其架构。该参数可以是以下原子之一：</target>
        </trans-unit>
        <trans-unit id="1c8d3536642343f82c03359ee86f1e6c6ed51cdc" translate="yes" xml:space="preserve">
          <source>Application programs can access the values of the command-line arguments by calling the function &lt;code&gt;init:get_argument(Key)&lt;/code&gt; or &lt;code&gt;init:get_arguments()&lt;/code&gt;. See the &lt;code&gt;init(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">应用程序可以通过调用函数 &lt;code&gt;init:get_argument(Key)&lt;/code&gt; 或 &lt;code&gt;init:get_arguments()&lt;/code&gt; 来访问命令行参数的值。请参阅ERTS中的 &lt;code&gt;init(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9a3c99c39895beeb540f03e2907eaa65e2e3d13b" translate="yes" xml:space="preserve">
          <source>Application resource file</source>
          <target state="translated">应用资源文件</target>
        </trans-unit>
        <trans-unit id="75ccf582ca3ec68d22db59ba1f474b3c7e769bc8" translate="yes" xml:space="preserve">
          <source>Application resource file.</source>
          <target state="translated">应用资源文件。</target>
        </trans-unit>
        <trans-unit id="d7df03c04ece2fd1b98a72e8d327f0eca8e79615" translate="yes" xml:space="preserve">
          <source>Application settings</source>
          <target state="translated">应用设置</target>
        </trans-unit>
        <trans-unit id="e32c3cf432797b7c1d1e8a63e8761c1703d72948" translate="yes" xml:space="preserve">
          <source>Application specific configuration. An application has a mandatory name and application level options that are described below.</source>
          <target state="translated">应用程序的具体配置。一个应用程序有一个强制性的名称和应用程序级别的选项,这些选项将在下面描述。</target>
        </trans-unit>
        <trans-unit id="ae55983f0b6d7e237d6c21df4a6fc064eb76c1b8" translate="yes" xml:space="preserve">
          <source>Application upgrade file</source>
          <target state="translated">应用升级文件</target>
        </trans-unit>
        <trans-unit id="781ef14400b810abfadd4a95a97b21db97359040" translate="yes" xml:space="preserve">
          <source>Application-specific error reason that is to be checked by the &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">特定于应用程序的错误原因，将由 &lt;code&gt;verify_fun&lt;/code&gt; 检查。</target>
        </trans-unit>
        <trans-unit id="4507ffa27565890275789b83392e39507e0ef155" translate="yes" xml:space="preserve">
          <source>Application-specific records are defined in the hrl files resulting from dictionary file compilation.</source>
          <target state="translated">应用程序特定的记录定义在由字典文件编译产生的 hrl 文件中。</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="5dd7e803139ba20c70acea8fa0e0d5743ed7b495" translate="yes" xml:space="preserve">
          <source>Applications are not required to be located under directory &lt;code&gt;$ROOT/lib&lt;/code&gt;. Several installation directories, which contain different parts of a system, can thus exist. For example, the previous example can be extended as follows:</source>
          <target state="translated">应用程序不需要位于目录 &lt;code&gt;$ROOT/lib&lt;/code&gt; 。因此可以存在几个包含系统不同部分的安装目录。例如，前面的示例可以扩展如下：</target>
        </trans-unit>
        <trans-unit id="362b31da52f21329511e4763851061ec08ac4166" translate="yes" xml:space="preserve">
          <source>Applications that access databases or log files often write a tiny data fragment (for example, one line in a log file) and then call &lt;code&gt;fsync()&lt;/code&gt; immediately to ensure that the written data is physically stored on the hard disk. Unfortunately, &lt;code&gt;fsync()&lt;/code&gt; always initiates two write operations: one for the newly written data and another one to update the modification time stored in the &lt;code&gt;inode&lt;/code&gt;. If the modification time is not a part of the transaction concept, &lt;code&gt;fdatasync()&lt;/code&gt; can be used to avoid unnecessary &lt;code&gt;inode&lt;/code&gt; disk write operations.</source>
          <target state="translated">访问数据库或日志文件的应用程序通常会写一个很小的数据片段（例如，日志文件中的一行），然后立即调用 &lt;code&gt;fsync()&lt;/code&gt; 以确保所写的数据物理上存储在硬盘上。不幸的是， &lt;code&gt;fsync()&lt;/code&gt; 总是启动两个写入操作：一个用于新写入的数据，另一个用于更新存储在 &lt;code&gt;inode&lt;/code&gt; 中的修改时间。如果修改时间不是事务概念的一部分，则可以使用 &lt;code&gt;fdatasync()&lt;/code&gt; 来避免不必要的 &lt;code&gt;inode&lt;/code&gt; 磁盘写操作。</target>
        </trans-unit>
        <trans-unit id="36e5e3b3c875b142ebb079646179db76a16ac509" translate="yes" xml:space="preserve">
          <source>Applications that merely need a look-up dictionary that can be stored to disc. Those applications use the standard library module &lt;code&gt;dets&lt;/code&gt;, which is a disc-based version of the module &lt;code&gt;ets&lt;/code&gt;. For information about &lt;code&gt;dets&lt;/code&gt;, see the &lt;code&gt;dets&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">仅需要可以将其存储到磁盘的查找字典的应用程序。这些应用程序使用标准库模块 &lt;code&gt;dets&lt;/code&gt; ，它是模块 &lt;code&gt;ets&lt;/code&gt; 的基于磁盘的版本。有关 &lt;code&gt;dets&lt;/code&gt; 的信息，请参阅STDLIB中的 &lt;code&gt;dets&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="08caa89c85c4c4b67db04b49770e72f7b261a582" translate="yes" xml:space="preserve">
          <source>Applications that need disc logging facilities. Those applications can use the module &lt;code&gt;disk_log&lt;/code&gt; by preference. For information about &lt;code&gt;disk_log&lt;/code&gt;, see the &lt;code&gt;disk_log&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">需要光盘记录工具的应用程序。这些应用程序可以优先使用 &lt;code&gt;disk_log&lt;/code&gt; 模块。有关 &lt;code&gt;disk_log&lt;/code&gt; 的信息，请参见内核中的 &lt;code&gt;disk_log&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d65e8afb7e2d8dc2f453fde746bc143e776e7bfd" translate="yes" xml:space="preserve">
          <source>Applications that need to replicate data.</source>
          <target state="translated">需要复制数据的应用。</target>
        </trans-unit>
        <trans-unit id="0a893d683aa9bd2d820b6ec80f57f8073df0221a" translate="yes" xml:space="preserve">
          <source>Applications that need to use atomic transactions to update several records simultaneously.</source>
          <target state="translated">需要使用原子事务同时更新多个记录的应用。</target>
        </trans-unit>
        <trans-unit id="b472e8ea80b9c154d3b89eb9393528fe5e667863" translate="yes" xml:space="preserve">
          <source>Applications that perform complicated searches on data.</source>
          <target state="translated">对数据进行复杂搜索的应用。</target>
        </trans-unit>
        <trans-unit id="218beaf6e33b2c2bfe36be6da2b6bedcdac994cd" translate="yes" xml:space="preserve">
          <source>Applications that use soft real-time characteristics.</source>
          <target state="translated">使用软实时特性的应用。</target>
        </trans-unit>
        <trans-unit id="e2d9778da73c053006242c383a365963dcdf2431" translate="yes" xml:space="preserve">
          <source>Applications.</source>
          <target state="translated">Applications.</target>
        </trans-unit>
        <trans-unit id="fa321d507b3a35d5a25a7182b72ba551d90893aa" translate="yes" xml:space="preserve">
          <source>Applies &lt;code&gt;Fun&lt;/code&gt; to each object stored in table &lt;code&gt;Name&lt;/code&gt; in some unspecified order. Different actions are taken depending on the return value of &lt;code&gt;Fun&lt;/code&gt;. The following &lt;code&gt;Fun&lt;/code&gt; return values are allowed:</source>
          <target state="translated">将 &lt;code&gt;Fun&lt;/code&gt; 以未指定的顺序应用于存储在表 &lt;code&gt;Name&lt;/code&gt; 中的每个对象。根据 &lt;code&gt;Fun&lt;/code&gt; 的返回值采取不同的操作。允许以下 &lt;code&gt;Fun&lt;/code&gt; 返回值：</target>
        </trans-unit>
        <trans-unit id="c175a40ddabcc4446ea6e7c02e64574ef36699b4" translate="yes" xml:space="preserve">
          <source>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node.</source>
          <target state="translated">对语法树的每个直属子树应用一个函数。每个应用的结果都会替换相应的原始节点。</target>
        </trans-unit>
        <trans-unit id="a163f49988d544f596168407c81d1f2429198f1c" translate="yes" xml:space="preserve">
          <source>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up.</source>
          <target state="translated">对语法树的每个节点应用一个函数。每个应用的结果都会替换相应的原始节点。遍历的顺序是自下而上。</target>
        </trans-unit>
        <trans-unit id="2f3b02962a0c819c60e2a8cb9eea77ed6172b4d6" translate="yes" xml:space="preserve">
          <source>Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by &lt;code&gt;Continuation&lt;/code&gt;, which is returned by a previous call to &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将匹配规范应用于存储在表中的某些对象，并返回结果的非空列表。该表，匹配规范以及匹配的对象数均由 &lt;code&gt;Continuation&lt;/code&gt; 定义，这由上一次对 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 的调用返回。</target>
        </trans-unit>
        <trans-unit id="4c464d5076dfa5b81db106edd89f699c8ab10fb5" translate="yes" xml:space="preserve">
          <source>Applies argument &lt;code&gt;Fun&lt;/code&gt; to all records in the table. &lt;code&gt;Fun&lt;/code&gt; is a function that takes a record of the old type and returns a transformed record of the new type. Argument &lt;code&gt;Fun&lt;/code&gt; can also be the atom &lt;code&gt;ignore&lt;/code&gt;, which indicates that only the metadata about the table is updated. Use of &lt;code&gt;ignore&lt;/code&gt; is not recommended, but included as a possibility for the user do to an own transformation.</source>
          <target state="translated">将参数 &lt;code&gt;Fun&lt;/code&gt; 应用于表中的所有记录。 &lt;code&gt;Fun&lt;/code&gt; 是一个函数，它接收旧类型的记录并返回新类型的转换记录。参数 &lt;code&gt;Fun&lt;/code&gt; 也可以是atom &lt;code&gt;ignore&lt;/code&gt; ，它指示仅有关表的元数据被更新。不建议使用 &lt;code&gt;ignore&lt;/code&gt; ，但是它可以让用户进行自己的转换。</target>
        </trans-unit>
        <trans-unit id="cf3f39b03019ec061c371b31fff84840bf62260f" translate="yes" xml:space="preserve">
          <source>Applies file extension specific rules to find the source file for a given object file relative to the object directory. For example, for a file with the extension &lt;code&gt;.beam&lt;/code&gt;, the default rule is to look for a file with a corresponding extension &lt;code&gt;.erl&lt;/code&gt; by replacing the suffix &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; of the object directory path with &lt;code&gt;&quot;src&quot;&lt;/code&gt; or &lt;code&gt;&quot;src/*&quot;&lt;/code&gt;. The file search is done through &lt;code&gt;&lt;a href=&quot;#find_file-3&quot;&gt;find_file/3&lt;/a&gt;&lt;/code&gt;. The directory of the object file is always tried before any other directory specified by the rules.</source>
          <target state="translated">应用特定于文件扩展名的规则来查找相对于对象目录的给定对象文件的源文件。例如，对于扩展名为 &lt;code&gt;.beam&lt;/code&gt; 的文件，默认规则是通过将对象目录路径的后缀 &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; 替换为 &lt;code&gt;&quot;src&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;src/*&quot;&lt;/code&gt; 来查找具有相应扩展名 &lt;code&gt;.erl&lt;/code&gt; 的文件。文件搜索通过 &lt;code&gt;&lt;a href=&quot;#find_file-3&quot;&gt;find_file/3&lt;/a&gt;&lt;/code&gt; 完成。始终在规则指定的任何其他目录之前尝试对象文件的目录。</target>
        </trans-unit>
        <trans-unit id="e8f326da15ffb7ae813d23c15eec50f7c444699f" translate="yes" xml:space="preserve">
          <source>Applying an &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;&lt;code&gt;E&lt;/code&gt; to an argument list &lt;code&gt;A&lt;/code&gt; is meant in the sense of &lt;code&gt;eval([E|A])&lt;/code&gt;.</source>
          <target state="translated">施加 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; &lt;code&gt;E&lt;/code&gt; 参数列表 &lt;code&gt;A&lt;/code&gt; 中的意义是指 &lt;code&gt;eval([E|A])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b14b38298fd4bda910b4630394ad60fbf3511557" translate="yes" xml:space="preserve">
          <source>Applying an exported function (&lt;code&gt;Mod:Name()&lt;/code&gt;, &lt;code&gt;apply(Mod, Name, [])&lt;/code&gt;) is about twice as expensive as calling a fun or about &lt;strong&gt;six times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">应用导出的函数（ &lt;code&gt;Mod:Name()&lt;/code&gt; ， &lt;code&gt;apply(Mod, Name, [])&lt;/code&gt; ）的成本大约是调用fun的两倍，或者是调用本地函数的&lt;strong&gt;六倍&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="953254328751bb2f8e674cc873b7ff2bdf1e5334" translate="yes" xml:space="preserve">
          <source>Approach to Extensibility</source>
          <target state="translated">可扩展性方法</target>
        </trans-unit>
        <trans-unit id="0d9fa01dbd526bfbb910c0a4cf194e3ddc6ecb6f" translate="yes" xml:space="preserve">
          <source>Approximate consumed fraction of a full time-slice in percent.</source>
          <target state="translated">一个完整时间片的大约消耗分数,单位为%。</target>
        </trans-unit>
        <trans-unit id="3c77ccb79f8b6f72613400296314a0c96ee58298" translate="yes" xml:space="preserve">
          <source>Approximation of '$1' | '$2' | '$3' | ...</source>
          <target state="translated">'$1'|'$2'|'$3'|...的近似值。</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="9a1bdf411ab1c83198eecd5f0731a5c27bbb4381" translate="yes" xml:space="preserve">
          <source>Arabic Letter Mark</source>
          <target state="translated">阿拉伯字母标记</target>
        </trans-unit>
        <trans-unit id="594b76f0b7b11a63e0ba97c983e39193011c18c1" translate="yes" xml:space="preserve">
          <source>Arbitrary derived data formats are supported by the dictionary interface.</source>
          <target state="translated">字典接口支持任意派生数据格式。</target>
        </trans-unit>
        <trans-unit id="a286f7c446f5fbd534896a188edddbc7d7a34e76" translate="yes" xml:space="preserve">
          <source>Arbitrary term state</source>
          <target state="translated">任意条款状态</target>
        </trans-unit>
        <trans-unit id="b4ea29fb4d4c1648e6d2e3c64705a89e987e421d" translate="yes" xml:space="preserve">
          <source>Are there other ways to do this that are equivalent and more efficient?</source>
          <target state="translated">还有没有其他同等的、效率更高的方法?</target>
        </trans-unit>
        <trans-unit id="c7427a7532716d8ddc0f775b7a270adc70ce506b" translate="yes" xml:space="preserve">
          <source>Args :: term(),</source>
          <target state="translated">Args ::term()。</target>
        </trans-unit>
        <trans-unit id="0fde5a51f492378b1ac1c7a090a3a9a9c4d7e9b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Args&lt;/code&gt; is a list of &lt;code&gt;{Key, Val}&lt;/code&gt; tuples, where the following values are allowed:</source>
          <target state="translated">参数 &lt;code&gt;Args&lt;/code&gt; 是 &lt;code&gt;{Key, Val}&lt;/code&gt; 元组的列表，其中允许以下值：</target>
        </trans-unit>
        <trans-unit id="2a8f4ad3dae9bd362edcdfe9517b3ed392fd27ef" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Args&lt;/code&gt; is used to set &lt;code&gt;erl&lt;/code&gt; command-line arguments. If provided, it is passed to the new node and can be used for a variety of purposes; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;Args&lt;/code&gt; 用于设置 &lt;code&gt;erl&lt;/code&gt; 命令行参数。如果提供的话，它将被传递到新节点，并且可以用于多种用途。参见 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528cc3f851bb138092b3a54cd9007848b26b85a1" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Beam&lt;/code&gt;, which can be a string or an atom, specifies either the module name or the path to the source code, with or without extension &lt;code&gt;&quot;.erl&quot;&lt;/code&gt;. In either case, the module must be known by the code server, that is, &lt;code&gt;code:which(Module)&lt;/code&gt; must succeed.</source>
          <target state="translated">参数 &lt;code&gt;Beam&lt;/code&gt; （可以是字符串或原子）可以指定模块名称或源代码的路径，带或不带扩展名 &lt;code&gt;&quot;.erl&quot;&lt;/code&gt; 。无论哪种情况，代码服务器都必须知道该模块，也就是说， &lt;code&gt;code:which(Module)&lt;/code&gt; 必须成功。</target>
        </trans-unit>
        <trans-unit id="e0c91ae2ecb7961a54a5e641d90a053be1d77b62" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Category&lt;/code&gt; in the previous example can have the value (atom) &lt;code&gt;sys_config&lt;/code&gt; (blue background), &lt;code&gt;sys_state&lt;/code&gt; (yellow background), or &lt;code&gt;error&lt;/code&gt; (white text on red background).</source>
          <target state="translated">上一个示例中的&amp;ldquo; 参数 &lt;code&gt;Category&lt;/code&gt; &amp;rdquo;可以具有值（原子） &lt;code&gt;sys_config&lt;/code&gt; （蓝色背景）， &lt;code&gt;sys_state&lt;/code&gt; （黄色背景）或 &lt;code&gt;error&lt;/code&gt; （红色背景上的白色文本）。</target>
        </trans-unit>
        <trans-unit id="cf43e2c4fa0b2acf4779f5e6cae85724db020b9a" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ExtraOptions&lt;/code&gt; is added to the options found in the configuration file. If the same options are specified, the values from the configuration file overwrite &lt;code&gt;ExtraOptions&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ExtraOptions&lt;/code&gt; 已添加到配置文件中的选项中。如果指定了相同的选项，则配置文件中的值将覆盖 &lt;code&gt;ExtraOptions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6e370d885f073ebe4056fc20b4ead3d6c0bc12b" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;FlagList&lt;/code&gt; must be &lt;code&gt;[]&lt;/code&gt; for receive tracing.</source>
          <target state="translated">参数 &lt;code&gt;FlagList&lt;/code&gt; 必须为 &lt;code&gt;[]&lt;/code&gt; 才能进行跟踪。</target>
        </trans-unit>
        <trans-unit id="63c68c228727c0c08a966c916cd09a8193ea4126" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;FlagList&lt;/code&gt; must be &lt;code&gt;[]&lt;/code&gt; for send tracing.</source>
          <target state="translated">参数 &lt;code&gt;FlagList&lt;/code&gt; 必须为 &lt;code&gt;[]&lt;/code&gt; 才能进行发送跟踪。</target>
        </trans-unit>
        <trans-unit id="5969bfd1f2a4922bae1c797825bd94636e7492ca" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Fun&lt;/code&gt; can also be the atom &lt;code&gt;ignore&lt;/code&gt;, which indicates that only the metadata about the table is updated. Use of &lt;code&gt;ignore&lt;/code&gt; is not recommended (as it creates inconsistencies between the metadata and the actual data) but it is included as a possibility for the user do to an own (offline) transform.</source>
          <target state="translated">参数 &lt;code&gt;Fun&lt;/code&gt; 也可以是atom &lt;code&gt;ignore&lt;/code&gt; ，它指示仅有关表的元数据被更新。不建议使用 &lt;code&gt;ignore&lt;/code&gt; （因为它会在元数据和实际数据之间造成不一致），但是它被包括在内，以供用户进行自己的（离线）转换。</target>
        </trans-unit>
        <trans-unit id="ede8746fe6cfaaaacae3ce131c1347e609e2da3f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Importance&lt;/code&gt; specifies a level of importance that, compared to a verbosity level (general and/or set per category), determines if the printout is to be visible. &lt;code&gt;Importance&lt;/code&gt; is any integer in the range 0..99. Predefined constants exist in the &lt;code&gt;ct.hrl&lt;/code&gt; header file. The default importance level, &lt;code&gt;?STD_IMPORTANCE&lt;/code&gt; (used if argument &lt;code&gt;Importance&lt;/code&gt; is not provided), is 50. This is also the importance used for standard I/O, for example, from printouts made with &lt;code&gt;io:format/2&lt;/code&gt;, &lt;code&gt;io:put_chars/1&lt;/code&gt;, and so on.</source>
          <target state="translated">自变量 &lt;code&gt;Importance&lt;/code&gt; 指定了一个重要级别，该级别与详细级别（常规和/或每个类别设置）相比，确定打印输出是否可见。 &lt;code&gt;Importance&lt;/code&gt; 是0..99范围内的任何整数。预定义的常量存在于 &lt;code&gt;ct.hrl&lt;/code&gt; 头文件中。默认重要性级别 &lt;code&gt;?STD_IMPORTANCE&lt;/code&gt; （如果未提供参数 &lt;code&gt;Importance&lt;/code&gt; 时使用）为50。这也是用于标准I / O的重要性，例如，使用 &lt;code&gt;io:format/2&lt;/code&gt; ， &lt;code&gt;io:put_chars/1&lt;/code&gt; 进行的打印输出， 等等。</target>
        </trans-unit>
        <trans-unit id="a74c242839b6e17cec6e9fda29e9cd4d39199929" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Length&lt;/code&gt; is meaningful only when the socket is in mode &lt;code&gt;raw&lt;/code&gt; and denotes the number of bytes to read. If &lt;code&gt;Length&lt;/code&gt; = 0, all available bytes are returned. If &lt;code&gt;Length&lt;/code&gt; &amp;gt; 0, exactly &lt;code&gt;Length&lt;/code&gt; bytes are returned, or an error; possibly discarding less than &lt;code&gt;Length&lt;/code&gt; bytes of data when the socket gets closed from the other side.</source>
          <target state="translated">仅当套接字处于 &lt;code&gt;raw&lt;/code&gt; 模式时，参数 &lt;code&gt;Length&lt;/code&gt; 才有意义，它表示要读取的字节数。如果 &lt;code&gt;Length&lt;/code&gt; = 0，则返回所有可用字节。如果 &lt;code&gt;Length&lt;/code&gt; &amp;gt; 0，则精确返回 &lt;code&gt;Length&lt;/code&gt; 字节，否则返回错误；否则，返回0 。当套接字从另一侧关闭时，可能会丢弃少于 &lt;code&gt;Length&lt;/code&gt; 字节的数据。</target>
        </trans-unit>
        <trans-unit id="cbac04ffb93617fd9cb7fd3fdb28dcbec27f1793" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Length&lt;/code&gt; is only meaningful when the socket is in &lt;code&gt;raw&lt;/code&gt; mode and denotes the number of bytes to read. If &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, all available bytes are returned. If &lt;code&gt;Length&lt;/code&gt; &amp;gt; &lt;code&gt;0&lt;/code&gt;, exactly &lt;code&gt;Length&lt;/code&gt; bytes are returned, or an error; possibly discarding less than &lt;code&gt;Length&lt;/code&gt; bytes of data when the socket is closed from the other side.</source>
          <target state="translated">参数 &lt;code&gt;Length&lt;/code&gt; 仅在套接字处于 &lt;code&gt;raw&lt;/code&gt; 模式时才有意义，它表示要读取的字节数。如果 &lt;code&gt;Length&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则返回所有可用字节。如果 &lt;code&gt;Length&lt;/code&gt; &amp;gt; &lt;code&gt;0&lt;/code&gt; ，则返回确切的 &lt;code&gt;Length&lt;/code&gt; 字节，否则返回错误；否则，返回0。从另一侧关闭套接字时，可能会丢弃少于 &lt;code&gt;Length&lt;/code&gt; 字节的数据。</target>
        </trans-unit>
        <trans-unit id="7df54cbc41d8be6702a7d18339b129a60b117176" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;MFA&lt;/code&gt; is to be a tuple, such as &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;, or the atom &lt;code&gt;on_load&lt;/code&gt; (described below). It can be the module, function, and arity for a function (or a BIF in any module). The atom &lt;code&gt;'_'&lt;/code&gt; can be used as a wildcard in any of the following ways:</source>
          <target state="translated">参数 &lt;code&gt;MFA&lt;/code&gt; 将是一个元组，例如 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 或原子 &lt;code&gt;on_load&lt;/code&gt; （如下所述）。它可以是功能（或任何模块中的BIF）的模块，功能和属性。原子 &lt;code&gt;'_'&lt;/code&gt; 可以通过以下任何一种方式用作通配符：</target>
        </trans-unit>
        <trans-unit id="9c5ab418823236be2e40f29077d515164f418559" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;MatchSpec&lt;/code&gt; can take the following forms:</source>
          <target state="translated">参数 &lt;code&gt;MatchSpec&lt;/code&gt; 可以采用以下形式：</target>
        </trans-unit>
        <trans-unit id="632db5ffef7ffbf7896b027d5a4845557c315e16" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Misc&lt;/code&gt; can be used to save internal data in a process, for example, its state. It is sent to &lt;code&gt;Module:system_continue/3&lt;/code&gt; or &lt;code&gt;Module:system_terminate/4&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;Misc&lt;/code&gt; 可用于保存流程中的内部数据，例如其状态。它被发送到 &lt;code&gt;Module:system_continue/3&lt;/code&gt; 或 &lt;code&gt;Module:system_terminate/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f490daf6a024205229629ca457c94764493e4043" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Modes&lt;/code&gt; is a list of possible modes, see &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, and defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;Modes&lt;/code&gt; 是可能模式的列表，请参见 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ，默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c41785291fefd33e5c56b0234e5a635c5016d3b1" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;NodesOrDist&lt;/code&gt; can either be a list of nodes or the result from the function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;NodesOrDist&lt;/code&gt; is assumed to be a sorted list with the best nodes to host new replicas first in the list. The new fragment gets the same number of replicas as the first fragment (see &lt;code&gt;n_ram_copies&lt;/code&gt;, &lt;code&gt;n_disc_copies&lt;/code&gt;, and &lt;code&gt;n_disc_only_copies&lt;/code&gt;). The &lt;code&gt;NodesOrDist&lt;/code&gt; list must at least contain one element for each replica that needs to be allocated.</source>
          <target state="translated">参数 &lt;code&gt;NodesOrDist&lt;/code&gt; 可以是节点列表，也可以是函数 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, frag_dist)&lt;/a&gt;&lt;/code&gt; 。参数 &lt;code&gt;NodesOrDist&lt;/code&gt; 被认为是一个排序的列表与以承载新的副本出现在列表的最佳节点。新片段的副本数量与第一个片段相同（请参见 &lt;code&gt;n_ram_copies&lt;/code&gt; ， &lt;code&gt;n_disc_copies&lt;/code&gt; 和 &lt;code&gt;n_disc_only_copies&lt;/code&gt; ）。该 &lt;code&gt;NodesOrDist&lt;/code&gt; 列表必须至少包含每个副本所要分配需要一个元素。</target>
        </trans-unit>
        <trans-unit id="46d85843a85d8a0d52723585742b11afd0899160" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;OptionList&lt;/code&gt; can be used to specify certain behavior regarding ports and triggering monitors under certain conditions:</source>
          <target state="translated">参数 &lt;code&gt;OptionList&lt;/code&gt; 可用于指定在某些情况下有关端口和触发监视器的某些行为：</target>
        </trans-unit>
        <trans-unit id="de736e1203b55111eca5eccfabbf9c9e91ef73a2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Options&lt;/code&gt; is a list of &lt;code&gt;{Key, Val}&lt;/code&gt; tuples, where the following values are allowed:</source>
          <target state="translated">参数 &lt;code&gt;Options&lt;/code&gt; 是 &lt;code&gt;{Key, Val}&lt;/code&gt; 元组的列表，其中允许以下值：</target>
        </trans-unit>
        <trans-unit id="f846b2639fdccdd7fe83e5494fa41e5843c66eb2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;PreArgs&lt;/code&gt; is a list of tagged values. There are two tags, &lt;code&gt;parent_value&lt;/code&gt; and &lt;code&gt;stop_fun&lt;/code&gt;, used by Mnesia for managing transactions.</source>
          <target state="translated">参数 &lt;code&gt;PreArgs&lt;/code&gt; 是标记值的列表。Mnesia使用两个标签， &lt;code&gt;parent_value&lt;/code&gt; 和 &lt;code&gt;stop_fun&lt;/code&gt; 来管理事务。</target>
        </trans-unit>
        <trans-unit id="63f20a5312d5f256e87436cce6c76d1a556dfbb0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Server&lt;/code&gt; in the SFTP functions is only to be used for SFTP sessions that have been started on existing SSH connections (that is, when the original connection type is &lt;code&gt;ssh&lt;/code&gt;). Whenever the connection type is &lt;code&gt;sftp&lt;/code&gt;, use the SSH connection reference only.</source>
          <target state="translated">SFTP功能中的Argument &lt;code&gt;Server&lt;/code&gt; 仅用于在现有SSH连接上启动的SFTP会话（即，当原始连接类型为 &lt;code&gt;ssh&lt;/code&gt; 时）。只要连接类型为 &lt;code&gt;sftp&lt;/code&gt; ，就只能使用SSH连接参考。</target>
        </trans-unit>
        <trans-unit id="127495432a40845ab9ada867dc7fc2fee4865175" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SnmpStruct&lt;/code&gt; is a list of SNMP information. Currently, the only information needed is information about the key types in the table. Multiple keys cannot be handled in Mnesia, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is &lt;code&gt;fix_string&lt;/code&gt;. This means that a string has a fixed size.</source>
          <target state="translated">参数 &lt;code&gt;SnmpStruct&lt;/code&gt; 是SNMP信息的列表。当前，唯一需要的信息是有关表中键类型的信息。Mnesia中无法处理多个密钥，但是许多SNMP表具有多个密钥。因此，使用以下约定：如果一个表具有多个键，则这些键必须始终存储为键的元组。有关键类型的信息被指定为描述这些类型的原子的元组。唯一有效的类型是 &lt;code&gt;fix_string&lt;/code&gt; 。这意味着字符串的大小固定。</target>
        </trans-unit>
        <trans-unit id="134ccc578ec25f4a1b41da580e909377b6e00202" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SpawnOpts&lt;/code&gt;, if specified, is passed as the last argument to the &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF.</source>
          <target state="translated">&lt;code&gt;SpawnOpts&lt;/code&gt; 参数（如果已指定）作为最后一个参数传递给 &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF。</target>
        </trans-unit>
        <trans-unit id="e3cedb4f6297db65a16db517b2fa86b4c83da9c5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;State&lt;/code&gt; is a tuple &lt;code&gt;{ShellState,ExprState}&lt;/code&gt;. The return value &lt;code&gt;NewState&lt;/code&gt; has the same form. This can be used to carry a state between calls to the callback functions. Data saved in &lt;code&gt;ShellState&lt;/code&gt; lives through an entire shell session. Data saved in &lt;code&gt;ExprState&lt;/code&gt; lives only through the evaluation of the current expression.</source>
          <target state="translated">参数 &lt;code&gt;State&lt;/code&gt; 是一个元组 &lt;code&gt;{ShellState,ExprState}&lt;/code&gt; 。返回值 &lt;code&gt;NewState&lt;/code&gt; 具有相同的形式。这可用于在对回调函数的调用之间传递状态。保存在 &lt;code&gt;ShellState&lt;/code&gt; 中的数据贯穿整个Shell会话。保存在 &lt;code&gt;ExprState&lt;/code&gt; 中的数据只能通过对当前表达式求值来生存。</target>
        </trans-unit>
        <trans-unit id="4b4b0aee165785dc7cf379568e4015cc77271225" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented float (the digits are ASCII values). Remaining characters in the string after the float are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;String&lt;/code&gt; 应以代表浮点数的有效文本开头（数字为ASCII值）。浮点数之后的字符串中的其余字符在 &lt;code&gt;Rest&lt;/code&gt; 中返回。</target>
        </trans-unit>
        <trans-unit id="99bddf0ad5e13463903ca5db19b6f229eaaa62d0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented integer (the digits are ASCII values). Remaining characters in the string after the integer are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;String&lt;/code&gt; 应以有效的文本表示的整数开头（数字为ASCII值）。整数之后的字符串中剩余的字符将在 &lt;code&gt;Rest&lt;/code&gt; 中返回。</target>
        </trans-unit>
        <trans-unit id="8f022d7270d5362d0771335ef05b9154a045868e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Type&lt;/code&gt; specifies the type of the application. If omitted, it defaults to &lt;code&gt;temporary&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;Type&lt;/code&gt; 指定应用程序的类型。如果省略，则默认为 &lt;code&gt;temporary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52529ec5b3dbe90218521bf7062ae0ba51481ae8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; identifies the event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket, pipe or other file descriptor object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use.</source>
          <target state="translated">参数 &lt;code&gt;event&lt;/code&gt; 标识事件对象。在Unix系统上，使用 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 功能。事件对象必须是 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 可以使用的套接字，管道或其他文件描述符对象。</target>
        </trans-unit>
        <trans-unit id="8c82d16dce6414cf83d8d93f8e672741f4d9ca8a" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; is not a valid OS event object.</source>
          <target state="translated">参数 &lt;code&gt;event&lt;/code&gt; 不是有效的OS事件对象。</target>
        </trans-unit>
        <trans-unit id="7980baebdda9326ef971ef864a7e3442b2b16145" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;index&lt;/code&gt; is updated, that is, this function can be viewed as a decode function that decodes a term into a human-readable format.</source>
          <target state="translated">参数 &lt;code&gt;index&lt;/code&gt; 已更新，也就是说，可以将此功能视为将术语解码为人类可读格式的解码功能。</target>
        </trans-unit>
        <trans-unit id="a75ce9ef93d0395faba2903cbdd1f49f30b2929e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;init&lt;/code&gt; is a pointer to an &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; structure that contains the function pointers for destructor, down and stop callbacks for the resource type.</source>
          <target state="translated">参数 &lt;code&gt;init&lt;/code&gt; 是指向 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; 结构的指针，该结构包含用于析构函数的函数指针，针对资源类型的down和stop回调。</target>
        </trans-unit>
        <trans-unit id="9dfed7a573331b550431a030fa57b0d3e26d11e8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;mode&lt;/code&gt; describes the type of events to wait for. It can be &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt;, &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; or a bitwise OR combination to wait for both. It can also be &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; which is described further below. When a read or write event is triggered, a notification message like this is sent to the process identified by &lt;code&gt;pid&lt;/code&gt;:</source>
          <target state="translated">参数 &lt;code&gt;mode&lt;/code&gt; 描述了要等待的事件类型。它可以是 &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt; ， &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; 或按位或的组合来等待两者。也可以是 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; ，将在下面进一步描述。触发读取或写入事件时，将向 &lt;code&gt;pid&lt;/code&gt; 标识的进程发送类似通知消息：</target>
        </trans-unit>
        <trans-unit id="5a90058d12d7cac1628a470a0a7fcf5ea024b094" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is a resource object obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. The purpose of the resource objects is as a container of the event object to manage its state and lifetime. A handle to the resource is received in the notification message as &lt;code&gt;Obj&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;obj&lt;/code&gt; 是从 &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; 获得的资源对象。资源对象的目的是作为事件对象的容器来管理其状态和生存期。在通知消息中以 &lt;code&gt;Obj&lt;/code&gt; 接收资源的句柄。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
