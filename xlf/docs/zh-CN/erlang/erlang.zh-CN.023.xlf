<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">在一个ReferenceID并从一个CN值之间的匹配操作的情况下 &lt;code&gt;Subject&lt;/code&gt; 字段中，第一个参数的乐趣是从ReferenceID所提取的主机名，并且所述第二参数是元组 &lt;code&gt;{cn, string()}&lt;/code&gt; 从所拍摄的 &lt;code&gt;Subject&lt;/code&gt; 领域。这样就可以从&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 字段和&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段中为呈现的ID设置单独的匹配规则。</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果发生错误（例如， &lt;code&gt;addr_unreachable&lt;/code&gt; ），则字段 &lt;code&gt;error&lt;/code&gt; 提供更多诊断信息。在这种情况下，事件 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 将自动转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。可以使用 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;error&lt;/code&gt; 字段值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">发生错误时，所有检测功能都可能返回SNMPv1或SNMPv2错误代码。如果它返回SNMPv2代码，则在将其发送到SNMPv1管理器之前，它将转换为SNMPv1代码。建议对所有检测功能使用SNMPv2错误代码，因为它们提供了更多详细信息。有关错误代码转换的说明，请参见 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">对于列表，只有百分比编码。但是，在二进制文件中，应同时考虑二进制编码和百分比编码。 &lt;code&gt;transcode/2&lt;/code&gt; 提供了一种在支持的编码之间进行转换的方法，它采用 &lt;code&gt;uri_string()&lt;/code&gt; 和指定入站和出站编码的选项列表。</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">在加载的情况下，监测可以&lt;strong&gt;不&lt;/strong&gt;只会收到使用选项触发 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; ，而且在特殊情况下，加载错误是短暂的。因此， &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 基本上将在&lt;strong&gt;所有&lt;/strong&gt;现实情况下使用。</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果从&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 证书字段中获取&amp;ldquo;呈现的ID&amp;rdquo; ，则名称可能包含通配符。该函数 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 定义处理此问题。</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在OctetString（）和派生类型的string（）和binary（）类型之间进行选择，则表示形式取决于 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; 的值：service_opt（） &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">在已知主题字符串不包含换行符的情况下，值得设置 &lt;code&gt;dotall&lt;/code&gt; 以获得此优化，或者使用^来明确表示锚定。</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">如果要重定向标准输入和/或标准输出或在管道中使用Erlang，则 &lt;code&gt;werl&lt;/code&gt; 不适合，而应使用 &lt;code&gt;erl&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">在某些输出函数和shell中的返回值输出中,Erlang会尝试用启发式的方式检测列表和二进制文件中的字符串数据。通常你会在这样的情况下看到启发式检测。</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">在某些情况下，尤其是在重定向标准输出时，可以方便地访问特定于错误消息的I / O服务器。I / O设备 &lt;code&gt;standard_error&lt;/code&gt; 可用于将输出定向到当前操作系统认为适合用于错误输出的任何I / O设备。类似于Unix的操作系统上的示例：</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">与 &lt;code&gt;{locations, true}&lt;/code&gt; 结合使用时，此选项将打印锁定操作源文件和行号入口点以及每个入口的统计信息。</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 一起，为每个依赖项添加一个假目标。</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 结合使用，将发出的规则的名称更改为 &lt;code&gt;Target&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 结合使用，会将丢失的标头视为生成的文件，并将其添加到依赖项中。</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">与RPC相比,多路调用是指从一个客户端并发发送到多个服务器的RPC。这对于收集一组节点的信息,或者在一组节点上调用一个函数来实现一些副作用是很有用的。它在语义上与在所有节点上反复进行一系列RPC是一样的,但多呼的速度更快,因为所有的请求都是同时发送的,并且在返回时逐一收集。</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">与大多数其他回调函数相比， &lt;code&gt;stop_select&lt;/code&gt; 的调用独立于任何端口。没有 &lt;code&gt;ErlDrvData&lt;/code&gt; 参数传递给该函数。不能保证持有任何驱动程序锁或端口锁。该端口称为 &lt;code&gt;driver_select&lt;/code&gt; 甚至在当时被关闭 &lt;code&gt;stop_select&lt;/code&gt; 被调用。但它也可以是案件 &lt;code&gt;stop_select&lt;/code&gt; 被直接调用 &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">与此相反,对编号子模式的子程序调用总是指模式中第一个给定编号的子模式。下面的模式符合 &quot;abcabc &quot;或 &quot;defabc&quot;。</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">在崩溃转储中,堆栈、消息和进程字典被省略。</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">在肮脏的上下文中，即 &lt;code&gt;sync_dirty&lt;/code&gt; 或 &lt;code&gt;async_dirty&lt;/code&gt; ，修改后的记录不会存储在本地副本中。而是，每个记录分别更新。如果表在另一个节点上具有副本，则会产生大量网络流量，并且具有脏操作所具有的所有其他缺点。特别是对于命令 &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; ，与前面针对 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; 所述的缺点相同，即在迭代过程中无需写入表。</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">在每一个 &lt;code&gt;Viewer&lt;/code&gt; ，只有一个过滤器，是活动和全部跟踪 &lt;code&gt;Events&lt;/code&gt; 的 &lt;code&gt;Viewer&lt;/code&gt; 从得到 &lt;code&gt;Collector&lt;/code&gt; 将直通该过滤器。通过编写巧妙的过滤器，可以自定义 &lt;code&gt;Events&lt;/code&gt; 在查看器中的外观。 &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; 中的以下过滤器替换了角色名称 &lt;code&gt;mnesia_tm&lt;/code&gt; 和 &lt;code&gt;mnesia_locker&lt;/code&gt; ,并将其他所有内容保留在记录中：</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">在每次迭代中,二进制中的前8位将被跳过,而不是匹配出来。</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">在早期的Erlang / OTP版本中，对太大的二进制文件进行操作通常会失败或给出错误的结果。在将来的版本中，其他创建二进制文件的操作（例如 &lt;code&gt;list_to_binary/1&lt;/code&gt; ）也可能会实施相同的限制。</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">在这两种情况下，代理都不会执行任何操作，但会返回检索到的ManagerEngineID（有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; ），并可能继续进行发现过程的第二阶段。</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">在嵌入式模式下,所有的代码都是在系统启动时根据引导脚本加载的。(也可以通过明确地命令代码服务器在之后加载代码)。</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">在嵌入式模式下，首先加载所有模块。然后，将调用所有 &lt;code&gt;on_load&lt;/code&gt; 函数。除非所有 &lt;code&gt;on_load&lt;/code&gt; 函数都返回 &lt;code&gt;ok&lt;/code&gt; ,否则系统将终止。</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">在嵌入式模式下,模块不会自动加载。试图使用一个未加载的模块会导致错误。当启动脚本加载所有模块时,建议使用这种模式,因为通常在OTP版本中是这样做的。(以后仍然可以通过明确命令代码服务器加载代码)。</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">在RAM数量有限且没有虚拟内存的嵌入式系统中，您可能希望通过将 &lt;code&gt;Number&lt;/code&gt; 设置为零来保留内存。（该值可以全局设置，请参见 &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">本质上，该函数执行与 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 相同的操作，但该函数期望使用指向字符指针（ &lt;code&gt;mbufp&lt;/code&gt; ）的指针，该字符指针指向由 &lt;code&gt;malloc&lt;/code&gt; 分配的存储区，而不是使用 &lt;code&gt;ei_x_buff&lt;/code&gt; 。参数 &lt;code&gt;bufsz&lt;/code&gt; 将是一个指向整数的指针，该整数包含内存区域的确切大小（以字节为单位）。该函数可以重新分配内存区域，在这种情况下，会将新大小放入 &lt;code&gt;*bufsz&lt;/code&gt; 并更新 &lt;code&gt;*mbufp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">用户可以在 &lt;code&gt;DocumentRoot&lt;/code&gt; 下或 &lt;code&gt;Alias&lt;/code&gt; 下的每个目录中放置一个访问文件。访问文件是纯文本文件，用于指定在Web服务器响应请求之前要考虑的限制。如果所请求资产的路径中有多个访问文件，那么将使用该资产中最靠近目录的访问文件中的指令。</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">其实由于随机数据是被缓存的,所以如果你尝试的话,一些数字可能会被复制,但这是不可预知的。</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">在幸运的情况下,不一致只在属于特定应用的表中可见。然而,如果一个模式事务因为强制事务恢复决定而不一致地恢复,那么不一致的影响可能是致命的。然而,如果更高的优先级是可用性而不是一致性,那么它可能值得冒这个风险。</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">通常，错误仅在最新 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; 修复，而新功能将在正在开发的即将发布的版本中引入。但是，当我们由于内部原因而修复较旧版本的错误时，这些错误也将发布并宣布。</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">通常，当 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;index&lt;/code&gt; 时，在匹配项中未分配值的子模式将作为元组 &lt;code&gt;{-1,0}&lt;/code&gt; 返回。对于其他返回类型，未分配的子模式分别作为空二进制或列表返回。考虑以下正则表达式：</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">一般来说,有比使用超时监督分布式Erlang系统的部分更好的方法。超时通常适用于监督外部事件,例如,如果你期望在指定的时间内从某个外部系统得到一条消息。例如,如果用户有十分钟没有访问Messenger系统,超时可以用来将其注销。</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">一般来说,在其他语言中使用 &quot;记录 &quot;或 &quot;结构 &quot;时,会使用tuple。另外,在表示大小不一的事物时,也就是在其他语言中使用链接列表时,也会使用列表。</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">通常，版本可以包含三个以上的部分。然后仅部分订购这些版本。此类版本仅在特殊情况下使用。将多余的部分（正常三部分中的一部分）添加到版本号后，将创建一个新的版本分支。新分支相对于基本版本具有线性顺序。但是，不同分支上的版本没有顺序，因此只能得出结论，它们都包含最接近的共同祖先中包含的内容。从同一基本版本多次分支时，将在基本版本和最低有效 &lt;code&gt;1&lt;/code&gt; 部分之间添加 &lt;code&gt;0&lt;/code&gt; 个部分，直到找到唯一的版本。具有订单的版本可以按照上一段所述进行比较。</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">在全局跟踪模式下,采集器会自动开始对所有连接的Erlang节点进行跟踪。当一个节点连接后,将在该节点上启动端口跟踪器,并在收集器节点上启动相应的跟踪客户端。</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">在交互模式下,代码在第一次引用时是动态加载的。当调用某个模块中的函数,而模块没有被加载时,代码服务器会搜索代码路径,将模块加载到系统中。</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">在交互模式下，代码服务器维护一个搜索路径，通常称为&lt;strong&gt;代码路径&lt;/strong&gt;，它由目录列表组成，在尝试加载模块时会顺序搜索该目录。</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">在交互模式下,也就是默认情况下,系统启动时只加载部分代码,基本上是运行时系统需要的模块。其他代码在第一次引用时,会被动态加载。当调用某个模块中的函数,而该模块没有被加载时,代码服务器会搜索并尝试加载该模块。</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">&lt;code&gt;match_spec&lt;/code&gt; 的最简单形式如下所示：</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">在本地模式下,代码只在当前节点解释。在全局模式下,代码在所有已知节点上进行解释。在其他节点上执行解释代码的进程会自动显示在Monitor窗口中,并且可以像其他调试进程一样被附加到。</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">在低内存系统（尤其是没有虚拟内存）中，将该值设置为 &lt;code&gt;0&lt;/code&gt; 可以帮助节省内存。</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">在许多应用中,处理事务的开销会导致性能的损失。脏操作是绕过大部分处理工作并提高事务速度的捷径。</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">在许多系统中，过载队列的瞬时状态是正常的。尽管此函数返回 &lt;code&gt;false&lt;/code&gt; 并不意味着保证另一个节点无响应，但它可能是暂时的重载。同样，返回值为 &lt;code&gt;true&lt;/code&gt; 只是意味着可以在（TCP）通道上发送消息而不会阻塞；不能保证该消息到达远程节点。对于断开连接的无响应节点，返回值为 &lt;code&gt;true&lt;/code&gt; （模拟operator &lt;code&gt;!&lt;/code&gt; 的行为）。函数返回 &lt;code&gt;false&lt;/code&gt; 时的预期行为和采取的措施是特定于应用程序和硬件的。</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">在匹配中,这个默认值只对最后一个元素有效。匹配中的所有其他位串或二进制元素必须有一个大小规格。</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">单位:微秒</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;verify_none&lt;/code&gt; 模式下，默认行为是允许所有x509路径验证错误。另请参阅选项 &lt;code&gt;verify_fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">用更多的技术术语来说， &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 丢弃该进程的调用堆栈，然后垃圾收集该进程。此后，所有活动数据都位于一个连续的堆中。然后将堆压缩到与其所保存的实时数据完全相同的大小（即使该大小小于该进程的最小堆大小）。</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">在可以使用此地址族的大多数API函数中，端口号必须为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;RootDir&lt;/code&gt; 中参数应该被设置为一样的 &lt;code&gt;root_dir&lt;/code&gt; 在呼叫用于配置参数 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; （或 &lt;code&gt;code:root_dir()&lt;/code&gt; 如果配置参数没有被设置）。在某些情况下，针对不同的根目录评估相同的目标规范可能很有用。但是，应格外小心，因为它要求在所有根目录下都具有等效的文件结构。</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">在正常模式下，用户的击键由 &lt;code&gt;tty&lt;/code&gt; 收集和解释。支持大多数&lt;strong&gt;Emacs的&lt;/strong&gt;行编辑命令。以下是受支持的行编辑命令的完整列表。</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">在正常操作中， &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 调用几乎是免费的。需要跟踪时，可以显式激活这些功能上的跟踪。或者，您可以将 &lt;code&gt;trace_global&lt;/code&gt; 的用法与 &lt;code&gt;trace_pattern&lt;/code&gt; 的用法结合起来。设置后， &lt;code&gt;trace_pattern&lt;/code&gt; 将在所有连接的节点上自动激活。</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">为了使实施能够充分利用增强的SNMPv2错误代码,在发生错误时,仪器功能必须始终返回SNMPv2错误代码。如有必要,这些错误代码将由代理翻译成相应的SNMPv1错误代码。</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">为了使Erlang驱动程序线程API起作用，必须在运行时系统中启用线程支持。 Erlang驱动程序可以使用 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 检查是否启用了线程支持。请注意，只有在运行时系统具有SMP支持时，Erlang驱动程序API中的某些函数才是线程安全的，并且可以通过 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 检索此信息。还要注意，无论是否启用了SMP支持，Erlang驱动程序API中的许多功能&lt;strong&gt;都不是&lt;/strong&gt;线程安全的。如果某个函数未记录为线程安全的，则它&lt;strong&gt;不是&lt;/strong&gt;线程安全的。</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">为了使中断/继续功能起作用， &lt;code&gt;Common Test&lt;/code&gt; 必须释放控制 &lt;code&gt;stdin&lt;/code&gt; 的外壳程序。这是通过将启动选项 &lt;code&gt;release_shell&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来完成的。有关详细信息，请参阅《用户指南》中的 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">为了使运行时系统能够绑定调度程序，必须知道CPU拓扑。如果运行系统无法自动检测到CPU拓扑，则可以对其进行定义。有关如何定义CPU拓扑的更多信息，请参见命令行标志 &lt;code&gt;+sct&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">为了使其正常工作,用户必须确保满足以下两个要求。</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">为了将这些数据追加到 motorcycles.xml 文档的结尾,你必须对文件进行解析,并将 Data 添加到根元素内容的结尾。</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">为了编译Erlang代码，必须构建一个小的Erlang引导系统，或者必须在 &lt;code&gt;$PATH&lt;/code&gt; 提供与正在构建的版本相同版本的Erlang / OTP系统。将使用此Erlang系统以及提供的交叉编译工具来构建目标系统的Erlang / OTP。</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">为了充分理解内部形式,你必须掌握Megaco/H.248协议的ASN.1规范,并应用上述规则。请参阅Erlang/OTP中ASN.1编译器的文档,以了解ASN.1和相应内部形式之间的语义映射的更多细节。</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">为了进一步简化跟踪，可以使用 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 函数。当您的应用程序中需要突出显示有趣的 &lt;code&gt;Events&lt;/code&gt; 时，可以从其他应用程序调用这些功能。这些函数非常轻巧，因为它们除了返回原子之外什么也不做。这些功能是专门为跟踪而设计的。由于调用方显式提供了&amp;ldquo; &lt;code&gt;Event Record&lt;/code&gt; 字段的值，因此默认的 &lt;code&gt;Collector Filter&lt;/code&gt; 能够自动提供自定义的&amp;ldquo; &lt;code&gt;Event Record&lt;/code&gt; 而无需任何用户定义的过滤器功能。</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">为了使Xref易于使用,有一些预定义的分析来执行一些常见的任务。通常,一个模块或一个版本可以被检查是否有对未定义函数的调用。对于更高级的用户来说,有一种小型但相当灵活的语言,可以用来选择被分析系统的部分,并对选定的调用进行一些简单的图表分析。</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">为了准备好MG发送初始消息(希望是服务变更请求),需要完成以下工作。</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">为了让MGC准备好接收最初的信息,希望是服务变更请求,需要完成以下工作。</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">为了提供MG和MGC的可扩展实现的解决方案,一个用户可以分布在几个Erlang节点上。其中一个Erlang节点连接到物理网络接口上,但消息可以从其他节点发送,并且回复会自动转发回发起节点。</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">为了看到的细节问题细节 &lt;code&gt;Event&lt;/code&gt; ，你可以点击 &lt;code&gt;Event&lt;/code&gt; ，以启动 &lt;code&gt;Contents Viewer&lt;/code&gt; 为 &lt;code&gt;Event&lt;/code&gt; 。在 &lt;code&gt;Contents Viewer&lt;/code&gt; 中，还有一个过滤器菜单，该菜单允许从查看器中未选择的其他视图检查 &lt;code&gt;Event&lt;/code&gt; 。单击 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; 将导致一个 &lt;code&gt;Contents Viewer&lt;/code&gt; 窗口弹出，在 &lt;code&gt;mgr_actors&lt;/code&gt; 视图中显示该 &lt;code&gt;Event&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">为了使用标签系统，必须创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件。该文件可以看作是项目中所有文件中所有功能，记录和宏的数据库。该 &lt;code&gt;TAGS&lt;/code&gt; 文件可以使用Erlang的两种不同的方法来创建。第一个是标准的Emacs实用程序&amp;ldquo; etags&amp;rdquo;，第二个是通过使用Erlang模块 &lt;code&gt;tags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">在我们的测量中,我们看到ASN.1误码率和紧凑文本格式之间的消息大小没有显著差异。当使用漂亮的文本样式时,应该采取一些谨慎的态度(在协议规范中包含的所有例子中都使用了这种样式,并且在调试环节中更喜欢使用这种样式),因为这样的话,消息就会相当大。如果消息的大小真的是一个严重的问题,应该使用我们的per编码器,因为ASN.1 PER格式比所有其他的选择更加紧凑。它的主要缺点是它还没有被批准为有效的Megaco/H.248信息编码。</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">在实践中,对象集通常被声明为可扩展的,以便以后可以向对象集添加更多的对象。可扩展性表示如下:</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">在 &lt;code&gt;file&lt;/code&gt; 的早期版本中，将模式指定为 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 原子之一，而不是列表。出于向后兼容的原因，仍然允许这样做，但不得用于新代码。另请注意，模式列表中不允许 &lt;code&gt;read_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">原则上，此函数通过 &lt;code&gt;spawn&lt;/code&gt; 调用 &lt;code&gt;process_received_message/4&lt;/code&gt; 函数以执行实际处理。</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">在支持客户端启动的重新协商的协议中，服务器的这种操作的资源成本比客户端高。这可以充当拒绝服务攻击的媒介。SSL应用程序已采取措施来抵消此类尝试，但是可以通过将此选项设置为 &lt;code&gt;false&lt;/code&gt; 来严格禁用客户端启动的重新协商。默认值为 &lt;code&gt;true&lt;/code&gt; 。请注意，由于底层密码套件可以加密的消息数量受到限制，因此禁用重新协商可能会导致长期连接无法使用。</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">在极少数情况下,这个函数在Unix上可能会失败,如果当前目录的父目录不存在读取权限,就会出现这种情况。如果当前目录的父目录不存在读取权限,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">实际上，数据模型很少完全标准化。规范化数据库模型的现实替代方案是甚至不采用第一范式的数据模型。 &lt;code&gt;Mnesia&lt;/code&gt; 适用于电信等应用，因为它易于以灵活的方式组织数据。一个 &lt;code&gt;Mnesia&lt;/code&gt; 的数据库总是被组织为一组表。每个表都充满行，对象和记录。什么套 &lt;code&gt;Mnesia&lt;/code&gt; 的与众不同的是，在一个记录中的各个字段可以包含任何类型的化合物的数据结构。记录中的单个字段可以包含列表，元组，函数，甚至记录代码。</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">在方案1中，在 &lt;code&gt;case A&lt;/code&gt; 完成执行其测试代码而未检测到任何错误之后，测试案例过程通常终止。测试用例函数返回一个值， &lt;code&gt;Common Test&lt;/code&gt; 将测试用例记录为成功。</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">在方案2中，在测试用例 &lt;code&gt;case B&lt;/code&gt; 执行期间检测到错误。这导致测试用例 &lt;code&gt;case B&lt;/code&gt; 函数生成异常，结果，测试用例进程由于非正常原因退出。 &lt;code&gt;Common Test&lt;/code&gt; 将此记录为失败（失败）的测试用例。</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在有关神话的章节中，揭示了以下神话： &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">简而言之， &lt;code&gt;DebugType&lt;/code&gt; 仅用于调试。使用标准的Erlang测井工具可以更好地生产生产过程中的原木。</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">在某些应用程序中，忽略来自单个日志的答复可能是不可接受的。在这种情况下，一种替代方法是使用许多本地磁盘日志而不是一个分布式磁盘日志，并在不使用 &lt;code&gt;disk_log&lt;/code&gt; 模块的情况下实现分发。</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">在某些方面,Erlang MIB编译器没有完全遵循或实现SMI。以下是两者的区别。</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">在某些方面,代理没有完全实现SNMP。以下是两者的区别。</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">在某些情况下,Erlang的语法规则使得你无法直接将元变量放在你想要的地方。例如,你不能写。</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">在某些情况下，选择/匹配操作不需要扫描整个表。例如，如果在搜索 &lt;code&gt;ordered_set&lt;/code&gt; 表时绑定了键的一部分，或者该键是Mnesia表，并且选择/匹配的字段上存在辅助索引。如果键是完全绑定的，则没有必要进行选择/匹配，除非您有一个包表并且只对具有特定键的元素子集感兴趣。</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">在某些情况下，仅允许使用字符串或整数。例如，指令 &lt;code&gt;-file(Name, Line)&lt;/code&gt; 要求 &lt;code&gt;Name&lt;/code&gt; 是字符串文字，而 &lt;code&gt;Line&lt;/code&gt; 是整数文字：</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;locked&lt;/code&gt; 状态下，当按下按钮时，将使用最后按下的按钮收集该按钮，直到达到正确代码的长度，然后与正确代码进行比较。根据结果​​，门要么被解锁， &lt;code&gt;gen_statem&lt;/code&gt; 进入 &lt;code&gt;open&lt;/code&gt; 状态，要么门保持在 &lt;code&gt;locked&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">在状态 &lt;code&gt;open&lt;/code&gt; 中，按钮事件通过保持相同状态而被忽略。这也可以通过返回 &lt;code&gt;{keep_state, Data}&lt;/code&gt; 来完成，或者在这种情况下，因为 &lt;code&gt;Data&lt;/code&gt; 甚至可以通过返回 &lt;code&gt;keep_state_and_data&lt;/code&gt; 来保持不变。</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">在具有多个进程的系统中，可以将运行时间短的计算任务派生到具有更高最小堆大小的新进程中。该过程完成后，它将计算结果发送到另一个过程并终止。如果正确计算了最小堆大小，则该过程可能根本不必进行任何垃圾收集。&lt;strong&gt;如果没有适当的测量，请勿尝试这种优化。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">在电信应用中,有不同于传统DBMS所提供的功能的需求。现在用Erlang实现的应用需要混合广泛的功能,而这些功能一般是传统DBMS无法满足的。Mnesia在设计时就考虑到了以下这样的需求。</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">在Erlang的32位实现中，536,870,911字节是可以使用位语法构造或匹配的最大二进制文件。在64位实现中，最大大小为2,305,843,009,213,693,951字节。如果超出了限制，则位语法构造会失败，并带有 &lt;code&gt;system_limit&lt;/code&gt; 异常，而任何尝试匹配太大的二进制文件的尝试都会失败。此限制从R11B-4开始实施。</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">在 &lt;code&gt;MatchBody&lt;/code&gt; 和 &lt;code&gt;MatchCondition&lt;/code&gt; 部分中，只能使用先前绑定的变量。</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">在 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 部分中，不允许使用未绑定的变量，因此 &lt;code&gt;'_'&lt;/code&gt; 被解释为本身（一个原子）。变量只能在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中绑定。</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">在 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 部分中，解释在某些方面有所不同。这些部分中的文字可以&amp;ldquo;按原样&amp;rdquo;编写，适用于除元组以外的所有文字，也可以使用特殊形式 &lt;code&gt;{const, T}&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是任何Erlang术语。</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中，所有文字（上面的变量除外）都按&amp;ldquo;原样&amp;rdquo;解释。</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;do_perm&lt;/code&gt; 中,我们对在 &lt;code&gt;output&lt;/code&gt; 中分配的结构进行操作。</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">在上面的 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 示例中，需要在源代码中包含 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，因为这会触发 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 调用对有效匹配规范的解析转换。这也意味着转换是在编译时完成的（从shell调用时除外），因此在运行时不占用任何资源。也就是说，尽管您使用了更直观的fun语法，但是它在运行时的效率与手工编写匹配规范一样有效。</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数中，C程序将侦听来自Erlang的消息，并根据所选的编码/解码方案，使用第一个字节确定要调用的函数，并使用第二个字节作为该函数的参数。然后，调用该函数的结果将发送回Erlang：</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">在 &lt;code&gt;ready_async&lt;/code&gt; 函数中，输出被发送回仿真器。我们使用驱动器术语格式而不是 &lt;code&gt;ei&lt;/code&gt; 。这是直接将Erlang术语直接发送到驱动程序，而无需使用Erlang代码来调用 &lt;code&gt;binary_to_term/1&lt;/code&gt; 的唯一方法。在简单的示例中，这很好用，我们不需要使用 &lt;code&gt;ei&lt;/code&gt; 来处理二进制术语格式。</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">在Megaco的API中,用户可以明确地发送动作请求,但交易标识符的生成、编码和消息到远程用户的实际传输是由协议引擎根据实际连接配置自动处理的。Megaco的消息在API中并不暴露。</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">在Erlang运行时系统中，只有在有多个调度程序时，实体才并行运行。因此，在许多内核上使用许多调度程序的系统上， &lt;code&gt;lcnt&lt;/code&gt; 将显示更多争用点（因此会更有用）。</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">在内核应用中。</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">在Mnesia表中,两个键列以两个元素的元组形式存储。因此,该表的arity为3。</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">在4.4BSD Unix中包含的POSIX.2兼容库中，丑陋的语法[[：&amp;lt;：]]和[[：&amp;gt;：]]用于匹配&amp;ldquo;单词开头&amp;rdquo;和&amp;ldquo;单词结尾&amp;rdquo;。PCRE将这些项目处理如下：</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">在PRF(伪随机函数)中,在不使用PFS的密码套件中生成密钥材料。</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">在SSL应用程序中，可以使用一个额外的分发模块 &lt;code&gt;inet_tls_dist&lt;/code&gt; 作为替代。所有分发连接将使用TLS，并且分布式系统中的所有参与的Erlang节点必须使用此分发模块。</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">在STDLIB应用程序中。</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">在上面的示例中，首先创建了&amp;ldquo; pong&amp;rdquo;，以便在启动&amp;ldquo; ping&amp;rdquo;时能够给出&amp;ldquo; pong&amp;rdquo;的标识。也就是说，以某种方式&amp;ldquo; ping&amp;rdquo;必须能够知道&amp;ldquo; pong&amp;rdquo;的身份才能向其发送消息。有时需要彼此了解身份的过程是彼此独立地启动的。因此，Erlang提供了一种为进程指定名称的机制，以便这些名称可以用作标识而不是pid。这可以通过使用 &lt;code&gt;register&lt;/code&gt; BIF 来完成：</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">在基本方案中,每个用户在开始使用驱动之前都会加载驱动,完成后再卸载驱动。参考计数会跟踪进程和每个进程的加载次数。这样驱动只有在没人要的时候才会被卸载(它没有用户)。驱动程序还跟踪对它开放的端口。这样就可以延迟卸载,直到所有端口都关闭,或者在卸载时杀死所有使用该驱动的端口。</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">在上面的例子中,该文件与Messenger例子中的所有其他文件一样,都是从同一个目录中获取的。(*manual*)。</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">在升级的情况下， &lt;code&gt;OldVsn&lt;/code&gt; 为 &lt;code&gt;Vsn&lt;/code&gt; ，在降级的情况下， &lt;code&gt;OldVsn&lt;/code&gt; 为 &lt;code&gt;{down,Vsn}&lt;/code&gt; 。 &lt;code&gt;Vsn&lt;/code&gt; 由旧版本的回调模块 &lt;code&gt;Module&lt;/code&gt; 的 &lt;code&gt;vsn&lt;/code&gt; 属性定义。如果未定义此类属性，则版本为BEAM文件的校验和。</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于回复，megaco将取消回复，并且其信息将通过调用回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 返回给用户。</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于请求，megaco将以与调用 &lt;code&gt;megaco:cancel&lt;/code&gt; 相同的方式取消消息（成功发送之后）。信息将根据发出请求的方式不同地传播回用户：对于使用 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 发出的请求，信息将以返回值的形式传递。对于使用 &lt;code&gt;megaco:cast&lt;/code&gt; 发出的请求，信息将通过调用回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Destination&lt;/code&gt; 为 &lt;code&gt;File&lt;/code&gt; ，则可打印的megaco跟踪事件将使用普通 &lt;code&gt;io:format/2&lt;/code&gt; 打印到文件 &lt;code&gt;File&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Destination&lt;/code&gt; 为 &lt;code&gt;io&lt;/code&gt; 的情况下，可打印的megaco跟踪事件将使用普通 &lt;code&gt;io:format/2&lt;/code&gt; 打印在stdout上。</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">如果pdu类型为 &lt;code&gt;report&lt;/code&gt; ，则 &lt;code&gt;MsgData&lt;/code&gt; 可以为 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">在本节开头的代码片段中，追加到 &lt;code&gt;Bin&lt;/code&gt; 将很便宜，而追加到 &lt;code&gt;Bin0&lt;/code&gt; 将强制创建新的二进制文件并复制 &lt;code&gt;Bin0&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">在封面规范文件中，您还可以指定所需的代码覆盖率分析级别；例如， &lt;code&gt;details&lt;/code&gt; 或 &lt;code&gt;overview&lt;/code&gt; 。在详细模式下，您会获得一个覆盖率概述页面，其中显示了每个模块和总覆盖率百分比。您还将为分析中包括的每个模块打印一个HTML文件，确切显示测试过程中已执行了哪些代码部分。在概述模式下，仅打印代码覆盖率概述页面。</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">在当前的 &lt;code&gt;Common Test&lt;/code&gt; 版本中， &lt;code&gt;silent_connections&lt;/code&gt; 功能仅适用于Telnet和SSH连接。将来的 &lt;code&gt;Common Test&lt;/code&gt; 版本中可以添加对其他连接类型的支持。</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Erlang / SCTP绑定的当前实现中，此事件在内部转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">在当前的实现中,每一次对象插入和查找操作都会产生一个对象的副本。</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">在当前版本的 &lt;code&gt;CurVsn&lt;/code&gt; 中， &lt;code&gt;myapp&lt;/code&gt; 的应用程序目录为 &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; 。一个新版本的 &lt;code&gt;NewVsn&lt;/code&gt; 在发布处理程序外部被解压缩，并通过如下调用通知发布处理程序：</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">在数据目录 &lt;code&gt;data_dir&lt;/code&gt; 中，测试模块具有自己的测试所需的文件。名称 &lt;code&gt;data_dir&lt;/code&gt; 是测试套件之后的名称 &lt;code&gt;&quot;_data&quot;&lt;/code&gt; 。例如， &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; 具有数据目录 &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; 。使用此目录可移植，即避免对套件中的目录名进行硬编码。由于数据目录与测试套件存储在同一目录中，因此即使测试套件目录的路径在测试套件实现和执行之间发生了变化，也可以在运行时依靠它的存在。</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">在后面的说明中,列出了用于更改默认值的形式。</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">在节点的详细信息窗口中，将显示原始节点和连接的节点上的进程之间的所有现有链接和监视器。&lt;strong&gt;Extra Info&lt;/strong&gt;可以包含调试信息（即，如果仿真器是调试编译的，则包含特殊信息）或错误信息。</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">在事件管理器中，安装了零个，一个或多个&lt;strong&gt;事件处理&lt;/strong&gt;程序。当事件管理器收到事件通知时，所有已安装的事件处理程序都会处理该事件。例如，默认情况下，用于处理错误的事件管理器可以安装处理程序，该处理程序将错误消息写入终端。如果一定时间内的错误消息也要保存到文件中，则用户将添加另一个执行此操作的事件处理程序。当不再需要记录到文件时，将删除此事件处理程序。</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">在上面的示例中，有效 &lt;code&gt;keys&lt;/code&gt; 可以是 &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; 和 &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; ，而 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; ， &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; 和 &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; 将无效。</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">在下面的例子中,第2,4,6,8和11行是可执行行。</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">在上一节的示例中，通过调用 &lt;code&gt;ch3:start_link()&lt;/code&gt; 来启动 &lt;code&gt;gen_server&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">在上一节的示例中， &lt;code&gt;gen_statem&lt;/code&gt; 通过调用 &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; 来启动：</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">在示例中，显示的ID为 &lt;code&gt;example.com&lt;/code&gt; 以及与 &lt;code&gt;*.example.com&lt;/code&gt; 匹配的主机名。例如 &lt;code&gt;foo.example.com&lt;/code&gt; 和 &lt;code&gt;bar.example.com&lt;/code&gt; 都匹配，但不匹配 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 。名称 &lt;code&gt;erlang.org&lt;/code&gt; 不匹配，因为它不是CN。</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">在示例中，为每个传入和传出消息调用 &lt;code&gt;handle_debug&lt;/code&gt; 。格式函数 &lt;code&gt;Func&lt;/code&gt; 是函数 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; ，它使用 &lt;code&gt;io:format/3&lt;/code&gt; 打印消息。</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在该示例中，选择了 &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; 中的第一个编码元素的组件 &lt;code&gt;number&lt;/code&gt; 。这适用于&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 部分中的ASN.1规范。</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">在该示例中，运算符 &lt;code&gt;==/2&lt;/code&gt; 的处理方式与 &lt;code&gt;=:=/2&lt;/code&gt; 的处理方式完全相同。但是，如果无法在编译时确定某个常量没有整数，并且在比较键是否相等时该表使用 &lt;code&gt;=:=/2&lt;/code&gt; （请参阅选项 &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;qlc&lt;/code&gt; 模块不会尝试查找该常量。 。原因是在通常情况下，可以比较的常量的键值数量没有上限。必须查询整数和浮点数的每种组合：</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">在该示例中，使用了同步启动。该过程通过调用 &lt;code&gt;ch4:start_link()&lt;/code&gt; 开始：</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">在此示例中，纯节点名称为 &lt;code&gt;c1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">在这个例子中:</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">在示例中，您可以看到默认的Erlang Shell仅将ISO Latin1范围内的字符解释为可打印，并且仅检测具有这些&amp;ldquo;可打印&amp;rdquo;字符的列表或二进制文件包含字符串数据。包含俄语单词&amp;ldquo;Юникод&amp;rdquo;的有效UTF-8二进制文件未打印为字符串。当使用所有可打印的Unicode字符（ &lt;code&gt;+pc unicode&lt;/code&gt; ）启动时，shell将包含可打印的Unicode数据（二进制，UTF-8或字节编码）的任何内容输出为字符串数据。</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">在提供非匿名PFS(完美前向保密)的密码套件中DH参数的交换中。</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">在函数调用的第一种形式 &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; 中， &lt;code&gt;ExprM&lt;/code&gt; 和 &lt;code&gt;ExprF&lt;/code&gt; 中的每一个都必须是原子或计算结果为原子的表达式。据说该函数是通过使用&lt;strong&gt;完全限定的函数名&lt;/strong&gt;来调用的。这通常称为&lt;strong&gt;远程&lt;/strong&gt;或&lt;strong&gt;外部函数调用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">在第一部分中， &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; 动作是一般状态机模型的一部分。这些常规操作由回调模块 &lt;code&gt;gen_statem&lt;/code&gt; 在返回 &lt;code&gt;gen_statem&lt;/code&gt; 引擎之前在事件处理回调函数中执行的代码实现。</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">在 &lt;code&gt;ID&lt;/code&gt; 的第一个字（4个字节）中，只有18位有效，其余为0。在 &lt;code&gt;Creation&lt;/code&gt; 中，只有两位有效，其余为0。</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">在下面的描述中使用的词&lt;strong&gt;点&lt;/strong&gt;手段：&amp;ldquo;点可以被看作是所述光标的位置更精确地，该点两个字符之间的位置，而光标绘制在以下点处的字符。&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">在以下描述中，&lt;strong&gt;组节点&lt;/strong&gt;是与本地节点属于同一全局组的节点。</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">在以下描述中，如果未启动 &lt;code&gt;heart&lt;/code&gt; ，则所有功能都会失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">在以下示例中，已插入QLC &lt;code&gt;V2&lt;/code&gt; 以显示联接的生成器和选择的联接方法。查找联接使用约定：第一个生成器（ &lt;code&gt;G2&lt;/code&gt; ）被遍历，第二个生成器（ &lt;code&gt;G1&lt;/code&gt; ）是在其中查找常量的表。</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，对 &lt;code&gt;A&lt;/code&gt; 的每个值遍历合并联接的缓存结果。请注意，如果没有选项 &lt;code&gt;cache&lt;/code&gt; 则联接将执行3次，对于每个 &lt;code&gt;A&lt;/code&gt; 值一次。</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">在下面的例子中,创建了两个进程,它们互相发送了多次消息。</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，仅插入两个简单的QLC来保存选项 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">在下面使用这个程序的例子中,节点是在四台不同的计算机上启动的。如果你的网络上没有那么多机器可用,你可以在同一台机器上启动几个节点。</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">在以下示例中， &lt;code&gt;Common Test&lt;/code&gt; 查找并执行了两个测试，一个测试从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 到 &lt;code&gt;sub21&lt;/code&gt; 的路径，另一个从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 到 &lt;code&gt;sub22&lt;/code&gt; 的路径：</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">在以下示例中， &lt;code&gt;{Pid, hello_world}&lt;/code&gt; 被发送到已注册的进程 &lt;code&gt;my_server&lt;/code&gt; 。该消息由 &lt;code&gt;erl_send()&lt;/code&gt; 编码：</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">在以下示例中，通过指定唯一路径 &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; ，仅执行一个测试。从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 的第二条可能路径（来自前面的示例）被丢弃：</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">在以下示例中，函数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 用作顺序跟踪的触发器：</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">在下面的例子中,第2、4、6、8、11行是可执行行。</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">在以下示例中，使用模块 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">在下面的示例中，BIF &lt;code&gt;self()&lt;/code&gt; 返回调用过程的pid：</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">在下面的例子中,Erlang shell是接收通道回复的客户端进程。</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">在下面的例子中,使用了这个ASN.1规范。</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">在以下示例中，安装了两个 &lt;code&gt;my_SUITE&lt;/code&gt; 测试事件处理程序：</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">在下面的示例中，使用 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 部分中的 &lt;code&gt;gb_table&lt;/code&gt; 模块，有六个要查找的键： &lt;code&gt;{1,a}&lt;/code&gt; ， &lt;code&gt;{1,b}&lt;/code&gt; ， &lt;code&gt;{1,c}&lt;/code&gt; ， &lt;code&gt;{2,a}&lt;/code&gt; ， &lt;code&gt;{2,b}&lt;/code&gt; 和 &lt;code&gt;{2,c}&lt;/code&gt; 。原因是键 &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; 的两个元素被分别比较。</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">在下面的例子中,我们使用XML文件 &quot;motorcycles.xml &quot;和相应的DTD &quot;motorcycles.dtd&quot;。motorcycles.xml的样子。</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">在下图中， &lt;code&gt;selected_decode_Window2&lt;/code&gt; 仅解码标记的元素：</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">下图中,方格代表主管,圆圈代表工人。</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">在下面的列表中，初始化标志被标记为&amp;ldquo;（初始化标志）&amp;rdquo;。除非另有说明，否则所有其他标志都是用户标志，可以通过调用 &lt;code&gt;init:get_argument/1&lt;/code&gt; 来获取其值。请注意，用户标志的列表并不详尽，可以有更多特定于应用程序的标志，而不是在相应的应用程序文档中进行描述。</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">以下各节将介绍这些专题。</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">在下面的章节中,我们已经尽可能地描述了所需工具的安装。一旦工具安装完毕,构建工作就相当容易了。我们也尽量使这些说明对于Unix经验有限的人来说是可以理解的。Cygwin/MSYS/MSYS2对一些Windows用户来说是一个全新的环境,为什么要对环境变量等进行仔细的解释呢?</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">在以下情况下，您可以轻松避免调用 &lt;code&gt;lists:flatten/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">在以下示例表中， &lt;code&gt;Data&lt;/code&gt; 必须是I / O列表。I / O列表是二进制或（可能是较深的）二进制列表或整数列表（范围为0..255）：</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">在下面定义的函数中,使用了以下类型。</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">将来，调试功能可能会与Erlang驱动程序线程API集成在一起。所有创建实体的函数都使用 &lt;code&gt;name&lt;/code&gt; 参数。当前， &lt;code&gt;name&lt;/code&gt; 参数尚未使用，但是在实现调试功能时将使用它。如果您命名创建良好的所有实体，则调试功能将能够为您提供更好的错误报告。</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">在生成的启动脚本中，所有应用程序目录的结构都为 &lt;code&gt;App-Vsn/ebin&lt;/code&gt; 。假定它们位于 &lt;code&gt;$ROOT/lib&lt;/code&gt; ，其中 &lt;code&gt;$ROOT&lt;/code&gt; 是已安装发行版的根目录。如果指定了选项 &lt;code&gt;local&lt;/code&gt; ，那么将使用在其中找到应用程序的实际目录。这是在本地测试生成的启动脚本的有用方法。</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">在最后一个示例中，要分析的模块作为 &lt;code&gt;m/1&lt;/code&gt; 的参数给出，并且代码路径（隐式地）用作 &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 。在此示例中，将使用 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; ，这使得分析应用程序和发行版以及明确选择库路径成为可能。</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">在最后一行中，请注意，元组{256,10，-2}是特殊符号中的实数2.56，其编码速度比简单地将数字表示为 &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; 快。三个三元组是 &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; ，即，尾数* Base ^ Exponent。</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">在针对两个方向（参见 &lt;code&gt;cipher&lt;/code&gt; ）一分为二的列表中，可以一次更改两个方向：</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">在针对两个方向（参见 &lt;code&gt;cipher&lt;/code&gt; ）一分为二的列表中，仅可以更改以下方向之一：</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">在处理请求的循环中,现在可以检测到发送超时。</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">在Messenger的例子中,没有假设发送的消息是什么。它可以是任何有效的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">监视消息中的 &lt;code&gt;MonitorRef&lt;/code&gt; 和 &lt;code&gt;Type&lt;/code&gt; 与前面所述相同，并且：</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">通常情况下，版本构造为 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; 是最重要的部分。</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">在存在字段初始值的情况下,必须在初始化后声明类型,如下所示。</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">在前面的示例中，没有指示期望使用哪些协议。因此，客户端无法指示它是连接到的Web服务器，ldap服务器还是sip服务器。证书中的某些字段可以表明这一点。更确切地说，rfc 在 &lt;code&gt;X509v3 extensions&lt;/code&gt; 字段中引入了 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 的用法：</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">在前面的示例中，&amp;ldquo; ping&amp;rdquo;和&amp;ldquo; pong&amp;rdquo;是从两个单独的Erlang节点的外壳开始的。 &lt;code&gt;spawn&lt;/code&gt; 还可以用于启动其他节点中的进程。</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">在上一个示例中，如果 &lt;code&gt;all/0&lt;/code&gt; 以 &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; 的顺序返回组名引用，则配置函数和测试用例的顺序如下（注意 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 和 &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 总是被调用，但为简单起见，未包含在此示例中）：</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">在前面的示例中，主管通过调用 &lt;code&gt;ch_sup:start_link()&lt;/code&gt; 启动：</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">在前面的例子中，新的变量名称来代替再利用旧的，： &lt;code&gt;First&lt;/code&gt; ， &lt;code&gt;TheRest&lt;/code&gt; ， &lt;code&gt;E1&lt;/code&gt; ， &lt;code&gt;E2&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ，和 &lt;code&gt;C&lt;/code&gt; 。这样做的原因是，变量只能在其上下文（范围）中被赋值一次。稍后再详细介绍。</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">在具有SMP支持的运行时系统中，驱动程序被锁定在驱动程序级别或端口级别（驱动程序实例级别）上。默认情况下，将使用驱动程序级别锁定，也就是说，一次只有一个仿真器线程将在驱动程序中执行代码。如果使用端口级锁定，则多个仿真器线程可以同时在驱动程序中执行代码。但是，一次仅一个线程将调用对应于同一端口的驱动程序回调。要启用端口级别锁定，请在 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 使用的 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 中设置 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; 驱动程序标志。使用端口级别锁定时，驱动程序编写器负责同步对端口（驱动程序实例）共享的数据的所有访问。</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">在第二个示例中，我们使用默认的跟踪处理程序功能。该处理程序通过将IO请求发送到 &lt;code&gt;user&lt;/code&gt; 进程来打印到tty 。在旧模式下启动Erlang时，在此示例中，shell进程将以 &lt;code&gt;user&lt;/code&gt; 作为其组长，而跟踪程序进程也将以该组领导。由于 &lt;code&gt;user&lt;/code&gt; 调用 &lt;code&gt;lists&lt;/code&gt; 函数，因此一旦发送第一个IO请求，我们就会陷入死锁。</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">在第二种形式的函数调用 &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; 中， &lt;code&gt;ExprF&lt;/code&gt; 必须是一个原子或计算为一个乐趣。</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">在序列图中，参与者（象征性地执行 &lt;code&gt;Event&lt;/code&gt; ）显示为命名的竖线。可以通过拖动（在操作过程中按住鼠标按钮1的方式）演员的名称标签并将其拖放到其他位置来更改演员的顺序：</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">在外壳中，如果使用Unicode输入设备，或者在存储在UTF-8中的源代码中，则 &lt;code&gt;$&lt;/code&gt; 后面可以直接跟一个产生整数的Unicode字符。在以下示例中，输出西里尔字母 &lt;code&gt;с&lt;/code&gt; 的代码点：</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">在一个节点失去了与全局组中其他节点的连接,但与其他全局组中的节点有连接的情况下,来自另一个全局组的请求可能会产生不正确或误导的结果。例如,被隔离的节点在其全局组中的注册名称信息可能不准确。</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">在目标目录中，读取文件 &lt;code&gt;releases/start_erl.data&lt;/code&gt; 以查找Erlang运行时系统版本（&amp;ldquo; 5.10.4&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">在文本编码中,实现者可以选择混合使用长短关键词。也可以添加白色空间来提高可读性。我们使用 &quot;紧凑 &quot;一词来表示尽可能短的关键字和没有可选的空白的文本信息,使用 &quot;漂亮 &quot;一词来表示使用长关键字和像Megaco/H.248规范中的文本示例那样的缩进风格的良好文本格式)。)</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">在xmerl_xs函数中，可以提供select（String）调用，这是 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 功能。有关更多详细信息，请参见xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">在这些情况下,ProtocolVersion默认版本是从静态连接配置中获取的。</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">在此代理程序系统中，有两种方法可以动态安装管理信息。最常见的方法是将MIB加载到代理中。另一种方法是使用子代理，该子代理由应用程序控制并且能够注册和注销自身。子代理可以注册自身以管理子树（不要与 &lt;code&gt;erlang:register&lt;/code&gt; 混淆）。子树由对象标识符标识。注册子代理程序后，它将接收对该特定子树的所有请求，并负责回答这些请求。还应注意，子代理可以随时启动和停止。</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">在此调用中， &lt;code&gt;[1, 1]&lt;/code&gt; 是 &lt;code&gt;RowIndex&lt;/code&gt; ，其中键1的值为1，键2的值为1， &lt;code&gt;[3, 5]&lt;/code&gt; 是请求的列的列表。该函数现在应按字典顺序返回下一个元素：</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">在这种情况下，它具有一个新的分量 &lt;code&gt;b&lt;/code&gt; 。因此，被解码的传入消息可能比该消息具有更多或发烧成分。</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">在这种情况下，测试套件中的 &lt;code&gt;ct_hooks&lt;/code&gt; 语句可以如下所示：</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">在这种情况下,配置文件必须至少包含:</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">在这种情况下，将滤波器一次应用于 &lt;code&gt;QH1&lt;/code&gt; 和 &lt;code&gt;QH2&lt;/code&gt; 的每个可能的答案对。如果对 &lt;code&gt;QH1&lt;/code&gt; 有M个答案，对 &lt;code&gt;QH2&lt;/code&gt; 有 N个答案，则过滤器将运行M * N次。</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">在这种情况下， &lt;code&gt;CTH&lt;/code&gt; 可以只是CTH的模块名称，也可以是具有模块名称和初始参数的元组，还可以是CTH的挂接优先级。例如，以下之一：</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，可以使用编译器选项 &lt;code&gt;encrypt_debug_info&lt;/code&gt; ，请参阅 &lt;code&gt;compile(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">在这种情况下，除第一个参数外的所有参数都将被忽略，并且该函数将再次简单地返回内部状态。如果仅扩展了代码，这就足够了。如果改为更改内部状态（类似于 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 的示例），则在此函数中完成此操作并返回 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; 中的一个或多个可以是未绑定变量。</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">在这种情况下，简单的代码替换是不够的。在切换到新版本的回调模块之前，该进程必须使用回调函数 &lt;code&gt;code_change&lt;/code&gt; 显式转换其状态。因此，使用了同步代码替换。</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">在这种情况下,简单的代码替换是不够的。当加载一个特殊进程的新版本的居住模块时,该进程必须对其循环函数进行完全限定的调用,以切换到新的代码。因此,必须使用同步代码替换。</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">在这种情况下,调用进程是shell,所以收到了以下结果。</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">在这种情况下,该函数必须从相关模块导出。</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，将返回键 &lt;code&gt;Key&lt;/code&gt; ，该键可在随后的调用 &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; 中使用,以检索节点 &lt;code&gt;Node&lt;/code&gt; 上的评估 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">在这种情况下，新状态是可用频道 &lt;code&gt;Chs2&lt;/code&gt; 的更新列表。该 &lt;code&gt;gen_server&lt;/code&gt; 现在已经准备好了新的要求。</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">在这种情况下，无需指定 &lt;code&gt;.appup&lt;/code&gt; 文件，即可使用具有自动打包和解包发布软件包，自动路径更新等功能的发布处理程序框架。</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，答复是分配的信道 &lt;code&gt;Ch&lt;/code&gt; ，新状态是剩余可用信道 &lt;code&gt;Chs2&lt;/code&gt; 的集合。</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，主管未注册。而是必须使用其pid。可以通过调用 &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; 或 &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">在这种情况下，您可以分别释放两个术语。释放术语 &lt;code&gt;ep&lt;/code&gt; 和 &lt;code&gt;ep2&lt;/code&gt; 的顺序并不重要，因为 &lt;code&gt;Erl_Interface&lt;/code&gt; 库使用引用计数来确定何时安全地删除对象。</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">在这个例子中,考虑到你想检查XML文件中的一个特定数据的情况。例如,你想检查每辆摩托车被记录了多长时间。</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">在这个例子中,Pea应用程序已经被改变了,ERTS、Kernel、STDLIB和SASL等应用程序也被改变了。</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">在此示例中，数字是整数，并且代码 &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 中的函数中的参数称为变量。变量必须以大写字母开头（请参见 &lt;code&gt;Variables&lt;/code&gt; ）。变量的示例是 &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;ShoeSize&lt;/code&gt; 和 &lt;code&gt;Age&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">在此示例中，您将遍历列表&amp;ldquo;携带&amp;rdquo;一个值，在本例中为 &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;list_max/1&lt;/code&gt; 只是假定列表的最大值是列表的开头，然后调用 &lt;code&gt;list_max/2&lt;/code&gt; 以及列表的其余部分和列表的开头的值。上面是 &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; 。如果您尝试将 &lt;code&gt;list_max/1&lt;/code&gt; 与一个空列表一起使用，或者尝试将其与完全不是列表的东西一起使用，则会导致错误。请注意，Erlang的原则不是在发生错误的函数中处理此类错误，而是在其他地方进行处理。稍后再详细介绍。</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">在此示例中， &lt;code&gt;suite/0&lt;/code&gt; 告诉 &lt;code&gt;Common Test&lt;/code&gt; 禁止Telnet和SSH连接打印输出。这对于所有测试用例均有效。但是， &lt;code&gt;my_testcase1/0&lt;/code&gt; 指定对于此测试用例，仅SSH将处于静默状态。结果是 &lt;code&gt;my_testcase1&lt;/code&gt; 获得了在日志中打印的Telnet信息（如果有），而不是SSH信息。 &lt;code&gt;my_testcase2&lt;/code&gt; 从打印的任何连接中均未获取任何信息。</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">在此示例中，收到 &lt;code&gt;{Pid, Something}&lt;/code&gt; 。接收到的pid然后用于返回 &lt;code&gt;{goodbye,Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">在此示例中，从外部源接收到一系列字节，然后将这些字节解码为有效的Erlang术语。这是通过调用 &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; 实现的，它返回了ASN.1类型 &lt;code&gt;Person&lt;/code&gt; 的Erlang值。然后使用 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; 构造和编码答案，该答案采用已定义的ASN.1类型的实例，并根据BER或PER编码规则将其转换为二进制。</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">在此示例中，具有NIF后端的跟踪器模块为每个仅包含发送者和接收者的 &lt;code&gt;send&lt;/code&gt; 跟踪标签发送一条消息。使用此跟踪器模块，可以使用轻量级消息跟踪器，该跟踪器仅记录谁向谁发送了消息。</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">在此示例中，使用环境变量 &lt;code&gt;DISPLAY&lt;/code&gt; 设置为 &lt;code&gt;gin:0&lt;/code&gt; 来启动Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">在此示例中，尝试使用字符串格式指令 &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 〜s &amp;rdquo;输出单个字符65 。</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">在这个例子中,当io:format调用完成后,在调用过程中设置的任何用户标签都会被传播到I/O服务器上。</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">在这个例子中,每个运行时系统都有两个调度器在线,所有在线的调度器将运行在不同的内核上。如果我们将一个运行时系统改为一个调度器在线,另一个运行时系统改为三个调度器在线,那么所有在线的调度器仍然会运行在不同的内核上。</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">在此示例中，如果打开了门，则函数 &lt;code&gt;terminate/3&lt;/code&gt; 会将门锁定，因此，当监视树终止时，我们不会意外地使门保持打开状态：</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">在此示例中，如果第一个元素是键，则在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中匹配该键比在 &lt;code&gt;MatchConditions&lt;/code&gt; 部分中匹配该键要有效得多。表的搜索空间在 &lt;code&gt;MatchHead&lt;/code&gt; 方面受到限制，因此仅搜索具有匹配键的对象。</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">在此示例中，我们可以将其推迟，然后将它们排队并在 &lt;code&gt;locked&lt;/code&gt; 状态下处理，而不是在 &lt;code&gt;open&lt;/code&gt; 状态下忽略按钮事件：</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">在本例中,执行以下操作。</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">在本示例中，使用了与&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 节中相同的ASN.1规范。以下是有效的选择性解码指令：</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">在这个例子中,文件 &quot;b.spec &quot;和 &quot;c.spec &quot;中定义的测试术语与源规范 &quot;a.spec &quot;中的术语(如果有的话)结合在一起。包含规格 &quot;d.spec &quot;和 &quot;e.spec &quot;的结果是两个单独和独立的测试运行(每个包含的规格都有一个)。</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">在此示例中，如果二进制文件引用的二进制文件大于我们要保留的数据大小的两倍，我们选择先复制二进制文件内容，然后再将其插入 &lt;code&gt;gb_sets:set()&lt;/code&gt; 。当然，复制到不同程序时将应用不同的规则。</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">在此示例中，我们首先将 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; -group1-sha1'放在首位，然后将'ecdh-sha2-nistp521'移至kex列表的末尾，即 &lt;code&gt;append&lt;/code&gt; 它。</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">在此示例中，我们同时使用了两个选项（ &lt;code&gt;preferred_algorithms&lt;/code&gt; 和 &lt;code&gt;modify_algorithms&lt;/code&gt; ），并且还尝试在不支持的算法之前添加前缀。任何不受支持的算法都会被悄悄删除。</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">在这个例子中,使用了以下ASN.1规范的定义。</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，密码为 &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">在这种模式下,可以进行以下操作。</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">在此模块中，V可以为空。这样获得的唯一有向图称为&lt;strong id=&quot;empty_digraph&quot;&gt;空有向图&lt;/strong&gt;。顶点和边均由唯一的Erlang术语表示。</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">在本模块中,只考虑了一些集X的子集的族;在下文中,&quot;族 &quot;这个词是用于这种子集的族。</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">在这种特殊情况下，我们不需要取消超时，因为超时事件是将状态从&amp;ldquo; &lt;code&gt;open&lt;/code&gt; 更改为&amp;ldquo; &lt;code&gt;locked&lt;/code&gt; 的唯一可能原因。</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">在这种特殊情况下，命令 &lt;code&gt;i&lt;/code&gt; （&amp;ldquo;中断&amp;rdquo;）终止循环程序，命令 &lt;code&gt;c&lt;/code&gt; 重新连接到外壳。由于该进程在终止之前在后台运行，因此在显示消息&amp;ldquo; &lt;code&gt;** exception exit: killed&lt;/code&gt; &amp;rdquo; 之前，会出现更多的打印输出。</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">在这种情况下，用于保护ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; 的锁已花费了大部分等待时间。在运行60秒的测试中，这是1.8秒。时间也分布在八个不同的调度程序线程上。</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">在此部分中，&amp;ldquo; &lt;code&gt;Domain&lt;/code&gt; 字段是传输域，即 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 之一，而 &lt;code&gt;Addr&lt;/code&gt; 字段是 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">在此部分中， &lt;code&gt;Address&lt;/code&gt; 字段是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 元组，其中 &lt;code&gt;Domain&lt;/code&gt; 是 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; ，而 &lt;code&gt;Addr&lt;/code&gt; 是 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">在本节中,列出了所有有效的Erlang表达式。在编写Erlang程序时,也允许使用宏和记录表达式。但是,这些表达式在编译过程中会被展开,在这个意义上,它们不是真正的Erlang表达式。宏表达式和记录表达式将在单独的章节中介绍。</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">在本节中，假定用户名是 &lt;code&gt;otpuser&lt;/code&gt; ,并且该用户的主目录是：</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">在本节中,使用了以下术语:</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">在这种简单的情况下,就可读性而言,前一种表达方式可能更可取。</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">这样，您可以使用链接将事务中的所有流程连接在一起。如果其中一个进程异常退出，那么事务中的所有进程都会被杀死。由于经常需要创建一个流程并同时链接到该流程，因此有一个特殊的BIF &lt;code&gt;spawn_link&lt;/code&gt; 与 &lt;code&gt;spawn&lt;/code&gt; 一样，但是也创建了一个到生成的流程的链接。</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">在传统的关系数据库术语中,这种操作称为选择,然后是投影。</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;StartMessage&lt;/code&gt; 类型中，字段 &lt;code&gt;content&lt;/code&gt; 后面的约束表明，在 &lt;code&gt;StartMessage&lt;/code&gt; 类型的值中，字段 &lt;code&gt;content&lt;/code&gt; 的值必须来自字段 &lt;code&gt;msgId&lt;/code&gt; 选择的同一对象。</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在megaco标准的版本3中，引入了Segmentation软件包。简而言之，此程序包定义了一个过程，用于在使用不会自动执行此操作的传输程序（例如UDP）时，分割megaco消息（事务答复）。另请参见 &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; 引入了哪个OTP版本？</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">在您自己的跟踪处理程序函数中，调用 &lt;code&gt;erlang:display/1&lt;/code&gt; 而不是 &lt;code&gt;io&lt;/code&gt; 函数；或者，如果未将 &lt;code&gt;user&lt;/code&gt; 用作组长，则打印给 &lt;code&gt;user&lt;/code&gt; 而不是默认组长。示例： &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">Inband-Security-Id AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">Inband-Security-Id AVP(代码299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id默认为空列表,相当于一个只包含0(NO_INBAND_SECURITY)的列表。如果指定了1(TLS),那么如果从对等体收到的CER/CEA提供了TLS,那么就会选择TLS。</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">二进制文件中的入站二进制编码</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">列表和二进制中的入站百分比编码。</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">顺便说一句，当纠正了测试用例时，确实应该发现 &lt;code&gt;channel&lt;/code&gt; 的错误。</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">在Erlang路径中包含 &lt;code&gt;dir&lt;/code&gt; 。在分析具有 &lt;code&gt;-include_lib()&lt;/code&gt; 指令的文件时，这很有用。</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包含目录也可以在测试规范中指定，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">包含文件</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">包含文件通常用于由几个模块共享的记录和宏定义。建议对包含文件使用文件扩展名 &lt;code&gt;.hrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">在标记注释中包含标记文本。文本是输入中与标记对应的部分。</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">包含对忽略结构化返回值或不与许多可能的返回值之一匹配的函数调用的警告。</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">为那些只通过异常返回的函数加入警告。</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">包括对可能的竞赛条件的警告。注意,发现数据竞赛的分析会执行程序内数据流分析,有时会及时爆炸。启用它,风险自负。</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">包括测试信息</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">包括一个包含所有呼叫统计的部分,无论进程如何,在分析中。</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中都包含时间戳记。时间戳（Ts）具有与 &lt;code&gt;erlang:now()&lt;/code&gt; 返回的形式相同的形式。</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中都包含一个 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 戳记。时间戳（Ts）与 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; 产生的格式和值相同。该标志覆盖标志 &lt;code&gt;cpu_timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中包括一个时间戳，该时间戳由 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 和一个单调递增的整数组成。时间戳（Ts）与 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;,&lt;/code&gt; erlang：unique_integer（[monotonic]） &lt;code&gt;}&lt;/code&gt; 产生的格式和值相同。该标志覆盖标志 &lt;code&gt;cpu_timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">包括以的形式自定义调试信息 &lt;code&gt;Backend&lt;/code&gt; 模块与定制 &lt;code&gt;Data&lt;/code&gt; 编译光束模块中。给定的模块必须实现一个 &lt;code&gt;debug_info/4&lt;/code&gt; 的功能和负责生成不同的代码表示，如在所描述的 &lt;code&gt;debug_info&lt;/code&gt; 下 &lt;code&gt;beam_lib(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">在已编译Beam模块的 &lt;code&gt;debug_info&lt;/code&gt; 块中以 &lt;code&gt;Erlang Abstract Format&lt;/code&gt; 的形式包含调试信息。诸如Debugger，Xref和Cover之类的工具需要包含调试信息。</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">包括调试信息，但会对其进行加密，以便在不提供密钥的情况下无法对其进行访问。（也可以提供 &lt;code&gt;debug_info&lt;/code&gt; 选项，但不是必须的。）使用此选项是一种在测试过程中始终使调试信息可用且保护源代码的好方法。</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">包括属性 &lt;code&gt;{role, client | server}&lt;/code&gt; 。当前，这是唯一的预定义属性，也可以有用户定义的属性。另请参见应用程序环境变量 &lt;code&gt;session_cb_init_args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">传入连接</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">传入的Diameter消息在被传递给 &lt;code&gt;diameter_app(3)&lt;/code&gt; 回调之前，从binary（）进行解码。同样，传出的Diameter消息在传递到适当的 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 模块进行传输之前，被编码为binary（）。此处记录的功能实现默认的编码/解码。</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">收到的消息由megaco:receive_message/4传递,通常会成功解码。但是如果解码失败,这个函数被调用,以决定发信人是否应该收到回复信息(reply),或者是否应该默默地丢弃回复信息(no_reply)。</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">传入的消息由megaco:receive_message/4传递并成功解码。通常消息中包含一个事务列表,这个函数会对消息中的每个事务请求进行调用。</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">收到的消息由megaco:receive_message/4传送并成功解码。通常一条消息包含一个交易列表,但也可能在消息的顶层包含一个ErrorDescriptor。</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">不同版本之间可能会发生不兼容的变化。</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">流状态不一致。</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">UTF编码不正确。</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">增加了暂停对标识的进程数 &lt;code&gt;Suspendee&lt;/code&gt; 并把它处于暂停状态，如果它不是已经在该州。在恢复进程之前，不会安排已挂起的进程执行。</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">当对Erlang运行时系统进行NIF库不兼容的更改时，此值增加。通常，当 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 更改时，足以重新编译NIF库，但是在极少数情况下，这意味着必须对NIF库进行略微修改。如果是这样，当然会记录在案。</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">在增加新功能时增加。运行时系统使用次要版本来决定使用什么功能。</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">用 &lt;code&gt;N&lt;/code&gt; 递增MIB中的变量，如果未指定 &lt;code&gt;N&lt;/code&gt; 则递增1 。</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">增加映射迭代器,指向下一个键值条目。</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">增加作为参数（ &lt;code&gt;pdl&lt;/code&gt; ）传递的端口数据锁的引用计数。</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">递增 &lt;code&gt;bin&lt;/code&gt; 上的引用计数，并返回递增后达到的引用计数。</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">递增与丢弃的pdu相关的变量。当net_if过程接收，可以使用此功能 &lt;code&gt;discarded_pdu&lt;/code&gt; 从代理消息。</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">在文档的右边缩进多个字符位置。请注意， &lt;code&gt;N&lt;/code&gt; 可以为负，可以将文本向左移动或为零，在这种情况下， &lt;code&gt;D&lt;/code&gt; 将保持不变。</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">索引不是免费的。它们占用的空间与表的大小成正比,而且它们会导致插入表的速度稍慢。</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">表中的索引必须是对象,而不是类型(仅与SMIv1有所偏离)。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">表示断开的链接。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 包含链接进程的pid。</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">指示用户可能要使用的自定义序言文件，而不是默认文件 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; ，否则该文件将包含在结果解析器文件的开头。&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;Includefile&lt;/code&gt; 是按原样包含在解析器文件中的，因此它必须没有自己的模块声明，也不应编译。但是，它必须包含必要的出口声明。默认值由 &lt;code&gt;&quot;&quot;&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">指示在关联 &lt;code&gt;assoc_id&lt;/code&gt; 中由 &lt;code&gt;addr&lt;/code&gt; 指定的对等方的IP地址状态的更改。 &lt;code&gt;state&lt;/code&gt; 可能值（主要是不言自明的）包括：</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">表示字符范围</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指示是要更新所有应用程序代码路径（ &lt;code&gt;Bool==true&lt;/code&gt; ），还是仅要更新已修改应用程序的代码路径（ &lt;code&gt;Bool==false&lt;/code&gt; ，默认值）。这个选项只对其他应用程序目录比默认的效果 &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; ，即在参数中指定的应用程序目录 &lt;code&gt;AppDirs&lt;/code&gt; 在一个呼叫 &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">指示是否要收集过程信息。如果 &lt;code&gt;PI = true&lt;/code&gt; （默认值），则每个进程标识符 &lt;code&gt;Pid&lt;/code&gt; 将替换为元组 &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; ，其中 &lt;code&gt;ProcessInfo&lt;/code&gt; 是已注册进程名称，其全局注册名称或其初始功能。要关闭此功能，请设置 &lt;code&gt;PI = false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">表示该表是否被压缩。</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">表示该表是否被任何程序固定。</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">表示该表是否已命名。</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">从主管的角度指示孩子终止于哪个阶段。可以是 &lt;code&gt;start_error&lt;/code&gt; ， &lt;code&gt;child_terminated&lt;/code&gt; 或 &lt;code&gt;shutdown_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">表示已加载&lt;strong&gt;在&lt;/strong&gt;启动任何进程&lt;strong&gt;之前&lt;/strong&gt;&lt;strong&gt;必须&lt;/strong&gt;加载的所有模块。在交互模式下，在此命令之后解释的所有 &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; 命令都将被忽略，并且这些模块将按需加载。在嵌入式模式下， &lt;code&gt;kernel_load_completed&lt;/code&gt; 被忽略，并且所有模块在系统启动期间均已加载。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">表示发生了普通的发送操作。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 包含接收者的pid（C节点）。</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">表示不再发送数据。</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">表示为执行命令而启动的 &lt;code&gt;ssh_client_channel&lt;/code&gt; 已关闭。</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">表示客户端要尝试执行下一个协议协商。</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">表示如果Telnet客户端空闲（即，如果未接收到任何数据）超过 &lt;code&gt;IdleTimeout&lt;/code&gt; 毫秒，则该函数必须返回。默认超时为10秒。</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">表示不按时间戳合并日志,而是一个文件一个文件地处理(这样可以快一点)。</target>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指示另一端不再发送数据。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">指示在 &lt;code&gt;MSec&lt;/code&gt; 毫秒后将自动停止跟踪。如果已指定， &lt;code&gt;StopOpts&lt;/code&gt; 将传递给命令 &lt;code&gt;ttb:stop/2&lt;/code&gt; （默认为 &lt;code&gt;[]&lt;/code&gt; ）。请注意，该时间是近似的，因为始终存在与网络通信相关的延迟。计时器在 &lt;code&gt;ttb:p/2&lt;/code&gt; 后开始计时，因此您可以在之前设置跟踪模式。</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">表示有足够的​​输入数据可获得结果。 &lt;code&gt;Result&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">表示此调用从驱动程序中删除了最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，但仍有使用它的开放端口。当所有端口都关闭且没有新 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 到达时，将重新加载驱动程序并回收名称和内存。</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">表示在停止跟踪后不收集跟踪日志。</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">指示在跟踪过程中接收到跟踪消息时，将在控制台上打印跟踪消息。这意味着跟踪客户端 &lt;code&gt;{local, File}&lt;/code&gt; 。如果 &lt;code&gt;ShellSpec&lt;/code&gt; 是 &lt;code&gt;only&lt;/code&gt; （而不是 &lt;code&gt;true&lt;/code&gt; ），没有跟踪日志被存储。</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">表示文件所有者。对于非Unix文件系统,忽略。</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">表示inets版本。</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">表示文件的所有者。在非Unix文件系统中,该字段为零。</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">指示返回值将是 &lt;code&gt;{stopped, Dir}&lt;/code&gt; ，而不仅仅是 &lt;code&gt;stopped&lt;/code&gt; 。这意味着 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">表示服务器将尝试执行应用层协议协商(ALPN)。</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">表示跟踪停止后要格式化的跟踪日志。fetch目录下的所有日志都会被合并。</target>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">指示表是否使用 &lt;code&gt;read_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">指示表是否使用 &lt;code&gt;write_concurrency&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">指示功能交换是否已使用TLS选择带内安全性。 &lt;code&gt;Ref&lt;/code&gt; 是必须在 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 到传输的父进程的回复消息中包含的reference（）（请参阅下文）。 &lt;code&gt;Type&lt;/code&gt; 是 &lt;code&gt;connect&lt;/code&gt; 还是 &lt;code&gt;accept&lt;/code&gt; ,分别取决于是否已针对连接传输或侦听传输启动了进程。 &lt;code&gt;Bool&lt;/code&gt; 是一个boolean（），指示是否应将传输连接升级到TLS。</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">各个模式的代表如下:</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">从起源-状态-ID推断会话终止。</target>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">无限循环可以通过遵循一个子模式来构造,例如,可以用一个没有上限的量化符来匹配没有字符。</target>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">告知交付结果。</target>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">告知目标地址。</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">通知父级 &lt;code&gt;Type=accept&lt;/code&gt; 的传输过程已与对等方建立连接。如果传输过程具有 &lt;code&gt;Type=connect&lt;/code&gt; ,则不发送。</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通知父级 &lt;code&gt;Type=connect&lt;/code&gt; 的传输过程已与对等方建立连接。如果传输过程具有 &lt;code&gt;Type=accept&lt;/code&gt; ,则不发送。 &lt;code&gt;Remote&lt;/code&gt; 是一个任意术语，用于唯一标识传输已连接到的远程端点。一个 &lt;code&gt;LocalAddr&lt;/code&gt; 列表具有相同的语义，一个从返回 &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">非正式地讲,I/O列表是一个可以发送到Erlang端口的字符和二进制文件的深度列表。在 BNF 中,I/O 列表的正式定义如下。</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">信息对象类、信息对象和信息对象集(以下分别称为类、对象和对象集)在标准定义X.681中进行了定义。这里只做简单的解释。</target>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">关于所有被调试的进程的信息,即所有在解释模块中已经或正在执行代码的进程。</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">当进行升级或降级时,会从脚本中获取应用程序的信息。</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">例如,关于Erlang的实现信息可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">与崩溃进程相关联的进程的信息,并且不捕捉退出。这些进程就是因为这个进程崩溃而终止的邻居。收集到的信息与上一项中介绍的Crasher的信息相同。</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">关于崩溃过程的信息,如初始函数调用、退出原因、消息队列等。</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">可以使用选项 &lt;code&gt;--add_to_plt&lt;/code&gt; 将信息添加到现有的PLT中。如果您还希望将Erlang编译器包含在PLT中并将其放置在新的PLT中，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">返回测试用例属性列表的信息函数。(可选)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">信息函数,用于返回测试用例组的属性。(可选)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">用于返回该套房属性的信息函数。(可选)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">信息功能也可以用于函数 &lt;code&gt;init_per_suite&lt;/code&gt; ， &lt;code&gt;end_per_suite&lt;/code&gt; ， &lt;code&gt;init_per_group&lt;/code&gt; 和 &lt;code&gt;end_per_group&lt;/code&gt; ，它们的作用方式与 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 。例如，这对于设置时间陷阱并要求仅与所讨论的配置功能相关的外部配置数据有用（不影响为套件中的组和测试用例设置的属性）。</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">信息通过对回调函数 &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; 调用传递给接收器。</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">通过调用提供的fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; 将信息传递给接收器。</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">有关当前主要对等地址的信息（有关 &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; 的格式，请参见下文）</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">信息以 &lt;code&gt;Allowed&lt;/code&gt; 通过 &lt;code&gt;accept_connection/5&lt;/code&gt; 传递。仅当远程节点启动连接时，此字段才是必填字段。也就是说，当通过 &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 建立连接时。</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 将信息添加到跟踪信息文件中。请注意， &lt;code&gt;ValueList&lt;/code&gt; 始终是一个列表，并且如果您使用相同的 &lt;code&gt;Key&lt;/code&gt; 多次调用 &lt;code&gt;write_trace_info/2&lt;/code&gt; ，则 &lt;code&gt;ValueList&lt;/code&gt; 都会用新值扩展ValueList。</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">参考资料</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">测试用例的初始化/结束配置功能</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">测试用例组的启动/结束配置功能。</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">测试套件的启动/结束配置功能</target>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">可以使用测试规范术语 &lt;code&gt;init&lt;/code&gt; 在测试目标节点上自动启动并执行初始操作。</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">初始回调状态。占主导地位的状态被传递给一些 &lt;code&gt;diameter_app(3)&lt;/code&gt; 回调，然后这些回调可以返回新状态。默认为 &lt;code&gt;alias&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">用户的初始配置</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">基准的初始配置已经完成。现在是时候对实际的基准和Mnesia进行配置了。</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">最初的标点符号</target>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; 读取的初始化结构。</target>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">初始化 &lt;code&gt;Config&lt;/code&gt; 以进行属性测试。</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">初始化zlib流的解压会话。</target>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">初始化一个zlib流进行压缩。</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">初始化zlib流进行解压。</target>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">在 &lt;code&gt;*pid&lt;/code&gt; 处初始化 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 变量以表示调用过程。</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">初始化 &lt;code&gt;ec&lt;/code&gt; 结构，以标识服务器的节点名称和cookie。必须先调用其中一个，然后才能使用适用于 &lt;code&gt;ei_cnode&lt;/code&gt; 类型的其他函数或使用与到另一个节点的连接关联的文件描述符。</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">初始化 &lt;code&gt;erl_connect&lt;/code&gt; 模块。特别是，这些函数用于标识从中调用它们的C节点的名称。在使用 &lt;code&gt;erl_connect&lt;/code&gt; 模块中的任何其他功能之前，必须先调用这些功能之一。</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">从指定的字节序列初始化压缩字典,但不产生任何压缩输出。</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">初始化流HMAC操作的上下文。 &lt;code&gt;Type&lt;/code&gt; 确定在HMAC操作中使用哪个哈希函数。 &lt;code&gt;Key&lt;/code&gt; 是认证密钥。密钥可以是任何长度。</target>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">初始化流哈希操作的上下文。 &lt;code&gt;Type&lt;/code&gt; 确定要使用的摘要。返回的上下文应用作 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">从指定的未压缩字节序列初始化解压缩字典。必须将此函数作为对返回 &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; 的膨胀操作（例如 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; ）的响应，或者在不推荐使用的函数的情况下，抛出 &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; 例外。</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">初始化要在RC4流加密中使用的状态 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用计数器模式（CTR）初始化用于流AES加密的状态。 &lt;code&gt;Key&lt;/code&gt; 是AES密钥，并且必须为128、192或256位长。 &lt;code&gt;IVec&lt;/code&gt; 是128位（16字节）的任意初始化向量。此状态用于 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">使用连续的缓冲区初始化 &lt;code&gt;bin&lt;/code&gt; 指向的结构，该缓冲区的字节内容与 &lt;code&gt;iolist&lt;/code&gt; 相同。与 &lt;code&gt;inspect_binary&lt;/code&gt; 一样， &lt;code&gt;bin&lt;/code&gt; 指向的数据是瞬态的，不需要释放。</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">使用有关二进制项 &lt;code&gt;bin_term&lt;/code&gt; 的信息初始化 &lt;code&gt;bin&lt;/code&gt; 指向的结构。</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">初始化 &lt;code&gt;Erl_Interface&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">初始化数据库</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">初始化一个新的数据库模式,该模式有一个属性,该属性指定了该数据库要在哪个节点或哪些节点上运行。</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">初始768字+每个元素的大小(6字+Erlang数据的大小)。必要时表格会增长。</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">最初，代码路径包括当前工作目录和库目录 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 下的所有Erlang对象代码目录，其中 &lt;code&gt;$OTPROOT&lt;/code&gt; 是Erlang / OTP的安装目录， &lt;code&gt;code:root_dir()&lt;/code&gt; 。目录可以命名为 &lt;code&gt;Name[-Vsn]&lt;/code&gt; ，默认情况下，代码服务器从具有相同 &lt;code&gt;Name&lt;/code&gt; 的目录中选择版本号最高的目录。后缀 &lt;code&gt;-Vsn&lt;/code&gt; 是可选的。如果 &lt;code&gt;ebin&lt;/code&gt; 目录位于 &lt;code&gt;Name[-Vsn]&lt;/code&gt; ，则此目录将添加到代码路径。</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">最初，代码路径由当前工作目录和 &lt;code&gt;ROOT/lib&lt;/code&gt; 下的所有目标代码目录组成，其中 &lt;code&gt;ROOT&lt;/code&gt; 是Erlang / OTP的安装目录。目录可以命名为 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 。默认情况下，代码服务器从具有相同 &lt;code&gt;Name&lt;/code&gt; 的目录中选择版本号最高的目录。该 &lt;code&gt;-Vsn&lt;/code&gt; 后缀是可选的。如果 &lt;code&gt;ebin&lt;/code&gt; 目录存在于 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 目录下，则将该目录添加到代码路径中。</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">使用通知 &lt;code&gt;Notification&lt;/code&gt; 由 &lt;code&gt;TargetName&lt;/code&gt; 标识的管理器启动发现过程。</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">启动传输服务,并为其提供一个从megaco:user_info/2获得的接收句柄。</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Addr&lt;/code&gt; 和 &lt;code&gt;Port&lt;/code&gt; 指定的对等方（SCTP服务器套接字）启动套接字 &lt;code&gt;Socket&lt;/code&gt; 的新关联。</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">启动新的握手。一个显着的返回值是 &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; 指示对等方拒绝进行重新协商，但是使用先前协商的会话，连接仍然处于活动状态。</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">启动zlib流进行压缩。</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">立即启动心脏跳动</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">启动事件处理程序。返回 &lt;code&gt;Args&lt;/code&gt; ，该参数将在对 &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; 的调用中使用。</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 功能来完成对管理者的发现。 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; 文件中目标（管理器）条目的 &lt;code&gt;EngineId&lt;/code&gt; 字段必须具有 &lt;code&gt;discovery&lt;/code&gt; 值。请注意，如果管理器不响应，则 &lt;code&gt;Timeout&lt;/code&gt; 和 &lt;code&gt;RetryCount&lt;/code&gt; 字段将决定函数在返回之前将挂起多长时间。</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统跟踪程序的启动。当使用 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 启动跟踪端口时，将自动完成此操作。</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">内联不一定能改善运行时间。例如,内联会增加Beam栈的使用量,这可能会对递归函数的性能造成损害。</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">内联从来都不是默认值。必须在源模块中使用编译器选项或 &lt;code&gt;-compile()&lt;/code&gt; 属性显式启用它。</target>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输入的是 &lt;code&gt;modify_algs_list()&lt;/code&gt; 和一组算法 &lt;code&gt;A&lt;/code&gt; (如果存在），它们是从 &lt;code&gt;preferred_algorithms&lt;/code&gt; 选项获得的，或者是从 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 获得的。</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">在ssl应用程序本地缓存中插入CRL。</target>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">插入一个字典条目,并向所有注册用户发送一个{et,{dict_insert,Key,Val}}元组。</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">不管表的大小如何，在 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; 和 &lt;code&gt;duplicate_bag&lt;/code&gt; 类型的表中的插入和查找时间都是恒定的。对于 &lt;code&gt;ordered_set&lt;/code&gt; 数据类型，时间与对象数的（二进制）对数成正比。</target>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">插入以前杀死的文本</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">插入一些数据</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">插入事件取代了调用自己的状态处理函数的技巧，而在 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 中，您通常必须诉诸这种状态处理函数，以便在其他事件之前强制处理插入的事件。</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">在抽象的 Erlang 语法树中插入注释。</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">在抽象的 Erlang 语法树中插入注释。</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">对于大表来说,插入和删除的效率很低。</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">插入 &lt;code&gt;Item&lt;/code&gt; 作为队列 &lt;code&gt;Q1&lt;/code&gt; 的尾项。返回新队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的前面。返回结果队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的开头。返回新队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Item&lt;/code&gt; 插入队列 &lt;code&gt;Q1&lt;/code&gt; 的后面。返回结果队列 &lt;code&gt;Q2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">将具有值 &lt;code&gt;Value&lt;/code&gt; 的 &lt;code&gt;Key&lt;/code&gt; 插入 &lt;code&gt;Tree1&lt;/code&gt; 并返回新树。假定树中不存在密钥，否则崩溃。</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">插入 &lt;code&gt;Key&lt;/code&gt; 与价值 &lt;code&gt;Value&lt;/code&gt; 到 &lt;code&gt;Tree1&lt;/code&gt; ，如果关键是不存在的树状结构，否则更新 &lt;code&gt;Key&lt;/code&gt; 价值 &lt;code&gt;Value&lt;/code&gt; 在 &lt;code&gt;Tree1&lt;/code&gt; 。返回新树。</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">插入 &lt;code&gt;Sep&lt;/code&gt; 在各元件之间 &lt;code&gt;List1&lt;/code&gt; 。对空列表和单例列表没有影响。例如：</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">将新的键值元组插入索引结构。如果已经存在具有相同键的项，则新 &lt;code&gt;Value&lt;/code&gt; 覆盖旧值。</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">将配置文件中的所有数据插入数据库，并销毁所有旧数据，包括具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 的行。从配置文件创建的行将具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">将配置文件中的所有数据插入到数据库中,并销毁所有旧数据。</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">将配置文件中的所有数据插入数据库，并使用StorageType &lt;code&gt;volatile&lt;/code&gt; 销毁所有旧行。从配置文件创建的行将具有StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">将一个或多个对象插入表 &lt;code&gt;Name&lt;/code&gt; 。如果已经存在某个键与任何指定对象的键匹配的对象，则不更新表，并返回 &lt;code&gt;false&lt;/code&gt; 。否则，将插入对象并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">将一个或多个对象插入表 &lt;code&gt;Name&lt;/code&gt; 中。如果已经存在一个对象且其键与某些给定对象的键匹配，并且表类型已 &lt;code&gt;set&lt;/code&gt; ，则旧对象将被替换。</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">将列表 &lt;code&gt;ObjectOrObjects&lt;/code&gt; 中的对象或所有对象插入表 &lt;code&gt;Tab&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">将 &lt;code&gt;EtsTab&lt;/code&gt; 表 &lt;code&gt;Name&lt;/code&gt; 的对象插入ETS表EtsTab中。没有插入对象的顺序。除非覆盖，否则将保留ETS表的现有对象。</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">在一个字符类中,/b有不同的含义;它匹配的是退格字符。如果这些断言中的任何其他断言出现在一个字符类中,默认情况下,它与相应的文字字符相匹配(例如,/B与字母B相匹配)。</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">在字符类内部，或者\后面的十进制数字&amp;gt; 7并且没有太多捕获子模式，PCRE将\ 8和\ 9当作文字字符&amp;ldquo; 8&amp;rdquo;和&amp;ldquo; 9&amp;rdquo;处理，否则重新读取到反斜杠后的三个八进制数字，并使用它们生成数据字符。随后的任何数字都代表自己。例如：</target>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">检查选项和收集表格的信息。因此,在优化阶段要修改限定词。</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">检查流程的消息队列。该队列显示在Evaluator区域。</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">检查堆栈上的下一个函数调用,显示位置和变量绑定。</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">检查堆栈上的前一个函数调用,显示位置和变量绑定。</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">安装 &lt;code&gt;Common Test Hooks&lt;/code&gt; （类似于 &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">安装 &lt;code&gt;event_handler&lt;/code&gt; 插件（类似于 &lt;code&gt;ct_run -event_handler&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">安装Microsofts Windows SDK 8.1。</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">安装Visual Studio 12.0 (2013)</target>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">安装已创建的目标系统</target>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">将其安装或解压缩到pgm文件夹中：Cygwin： &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS： &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2： &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">一定需要安装很多东西，尤其是现代的用户界面组件。在我的情况下，将 &lt;code&gt;makensis&lt;/code&gt; 放在您的路径中：</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;release&lt;/code&gt; 目标进行安装。您可以使用 &lt;code&gt;release&lt;/code&gt; 目标在所需的任何目录中创建安装，然后自己运行 &lt;code&gt;Install&lt;/code&gt; 脚本，而不用进行 &lt;code&gt;make install&lt;/code&gt; 。 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 用于指定应在其中创建安装的目录。如果使用 &lt;code&gt;make install&lt;/code&gt; 进行安装，则默认情况下这就是 &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; 下的内容。 &lt;code&gt;configure&lt;/code&gt; 阶段中提供的所有安装路径以及 &lt;code&gt;DESTDIR&lt;/code&gt; 和 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 都将被忽略。如果您想要来自特定 &lt;code&gt;bin&lt;/code&gt; 链接目录到安装目录，您必须自己进行设置。一个示例，其中Erlang / OTP应该位于 &lt;code&gt;/home/me/OTP&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">手动安装</target>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">使用配置确定的路径进行安装。</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">安装后备是分布式操作，&lt;strong&gt;仅对&lt;/strong&gt;所有 &lt;code&gt;db_nodes&lt;/code&gt; 执行。回退将在下次启动系统时还原数据库。如果安装了回退的 &lt;code&gt;Mnesia&lt;/code&gt; 节点检测到另一个节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 已死，则它会无条件终止。</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">如果系统中有许多进程,安装一个新版本可能会很耗时。原因是在清除模块之前,必须检查每个进程对旧代码的引用。这种检查可能会导致垃圾收集和复制数据。</target>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">安装嵌入式系统</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">在应用程序os_mon中安装模块os_sup。</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">安装备份作为后备。在下次启动的时候,用这个备份来恢复数据库。安装后备需要在所有涉及的节点上运行Erlang,但Mnesia是否运行并不重要。如果本地节点不是备份中的磁盘驻留节点之一,那么回退的安装就会失败。</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">在发行结构中安装与发行相关的文件。安装新发行版时，与发行版相关的文件必须位于发行结构中： &lt;code&gt;start.boot&lt;/code&gt; ， &lt;code&gt;relup&lt;/code&gt; 和 &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">安装配置文件和事件处理程序。</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">安装发行版的指定版本 &lt;code&gt;Vsn&lt;/code&gt; 。首先查找 &lt;code&gt;Vsn&lt;/code&gt; 的 &lt;code&gt;relup&lt;/code&gt; 文件和此文件中的脚本 &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; ，以从当前版本升级。如果未找到，该函数将查找当前版本的 &lt;code&gt;relup&lt;/code&gt; 文件，并在该文件中查找脚本 &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; 以降级为 &lt;code&gt;Vsn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">建议使用 &lt;code&gt;information object class&lt;/code&gt; ， &lt;code&gt;table constraints&lt;/code&gt; 和 &lt;code&gt;parameterization&lt;/code&gt; 来代替 &lt;code&gt;ANY&lt;/code&gt; 和 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 。特别是，构造 &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; 与已弃用的 &lt;code&gt;ANY&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">与其纠结于何时取消超时,不如在已知超时的状态下,对迟到的超时事件进行忽略处理。</target>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">该选项不是提取到目录，而是将结果显示为元组列表 &lt;code&gt;{Filename, Binary}&lt;/code&gt; ，其中 &lt;code&gt;Binary&lt;/code&gt; 是二进制 &lt;code&gt;Filename&lt;/code&gt; ，包含tar文件中名为Filename的文件的提取数据。</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">结果不是提取到当前目录，而是给出一个元组列表 &lt;code&gt;{Filename, Binary}&lt;/code&gt; ，其中 &lt;code&gt;Binary&lt;/code&gt; 是一个二进制文件，其中包含zip存档中 &lt;code&gt;Filename&lt;/code&gt; 文件的提取数据。</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">代替发明编码/解码方案，将使用 &lt;code&gt;term_to_binary/1&lt;/code&gt; 和 &lt;code&gt;binary_to_term/1&lt;/code&gt; BIF。</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">将事件写入文件后不保留,而是可以在事件成功写入文件后删除所有存储的事件(清除)。</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">无需进行两次&lt;strong&gt;完整的解码&lt;/strong&gt;（正常情况下的解码），一次在服务器中，一次在收件人中，而只需要进行一次&lt;strong&gt;专门的解码&lt;/strong&gt;（在服务器中）而另一次进行完整的解码（在收件人中）。本节描述了以下两种专用解码，它们支持解决此问题和类似问题：</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">建议测试用例不要在测试用例之间传递数据,而是从SUT中读取状态,并执行断言(即如果状态符合预期,就让测试用例运行,否则复位或失败)。同时建议使用状态来设置测试用例正常执行所需的变量。常见的动作通常可以实现为测试用例调用的库函数,以将SUT设置为所需的状态。如果有必要的话,也可以对这种常用动作进行单独测试,以确保它们按照预期工作)。有时也可以(但并不总是可取的)在一个测试用例中把测试分组,即让一个测试用例执行一个 &quot;场景 &quot;测试(由子测试组成的测试)。</target>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">与其说是收发信息,还不如说是使用一些BIF。</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">代替使用 &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; 来检索调用堆栈回溯，而使用以下语法：</target>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">F中不写(x,y),也不写x F y,而是写F(x)=y,当F是一个函数时,我们说F把x映射到y上,或者说F在x处的值是y。</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">而是使用STDLIB中的 &lt;code&gt;ordsets&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">而是可以从头开始或通过编辑生成的版本来手动创建正确的 &lt;code&gt;relup&lt;/code&gt; 文件。启动/停止 &lt;code&gt;ch_app&lt;/code&gt; 的说明已替换为加载/卸载应用程序的说明：</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">反之,则写成:</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">指示网络接口进程向信息请求发送响应(确认)。</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">有关说明已按上述顺序添加到 &lt;code&gt;relup&lt;/code&gt; 文件中。可从相关的应用程序升级文件 &lt;code&gt;App.appup&lt;/code&gt; 获取有关在应用程序版本之间进行升级或降级的说明，这些文件的排序与生成引导脚本时的排序顺序相同，请参见 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; 。将高级指令转换为低级指令，并将结果打印到 &lt;code&gt;relup&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">指示编译器在 &lt;code&gt;Directory&lt;/code&gt; 中搜索包含文件。当遇到 &lt;code&gt;-include&lt;/code&gt; 或 &lt;code&gt;-include_lib&lt;/code&gt; 指令时，编译器会在以下目录中搜索头文件：</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">指示服务器在客户端声称符合HTTP / 1.1时是否使用持久连接。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">仪表标志</target>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">SNMP-COMMUNITY-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">SNMP-FRAMEWORK-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">SNMP-NOTIFICATION-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">SNMP-TARGET-MIB的仪表功能</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">STANDARD-MIB和SNMPv2-MIB的仪表功能。</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">Instrumentation可以使用分布式Erlang与应用程序进行通信。</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">必须为标量变量和表的 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 以及为表的 &lt;code&gt;get-next&lt;/code&gt; 编写检测函数。该 &lt;code&gt;get-bulk&lt;/code&gt; 操作被翻译成一系列调用的 &lt;code&gt;get-next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">系统存储空间不足[452]。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">整数(24位无符号)。用于限制有效的TLS握手数据包的大小,以避免DoS攻击。默认值为256*1024。</target>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">整数 &lt;code&gt;PreviousSerial&lt;/code&gt; 表示在最后一个接收到的带有跟踪令牌的消息中传递的串行计数器。如果该过程是新顺序跟踪中的第一个，则将 &lt;code&gt;PreviousSerial&lt;/code&gt; 设置为过程内部&amp;ldquo;跟踪时钟&amp;rdquo;的值。</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">整数 &lt;code&gt;ThisSerial&lt;/code&gt; 是进程在传出消息上设置的串行计数器。它基于进程内部的&amp;ldquo;跟踪时钟&amp;rdquo;，在将其附加到消息中的跟踪令牌之前，将其递增1。</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">整数除法</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">X/Y的整数剩余部分</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">整数表示有效的单码点。</target>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">例如，在 &lt;code&gt;SIZE&lt;/code&gt; 表达式中的整数值必须以十进制语法而不是十六进制或位语法输入。</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">与base &lt;strong&gt; &lt;code&gt;base&lt;/code&gt; &lt;/strong&gt;的整数，必须为2..36范围内的整数。</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">整数必须以微秒为单位，这意味着偏移量 &lt;code&gt;7200000000&lt;/code&gt; 等效于 &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">整数超出范围。</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">以909开头的整数，例如 &lt;code&gt;9091&lt;/code&gt; 或 &lt;code&gt;909123&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">目的是为了方便测试。</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当升级ERTS，内核，STDLIB或SASL时使用。当 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成 &lt;code&gt;relup&lt;/code&gt; 文件时，它将自动添加。它在所有其他升级指令之前执行。有关此指令的更多信息，请参见《 &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_new_emulator（低级）。</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">故意不出示证件。</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">呼叫间图形边缘(*)。</target>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">交互数据强制执行模块依赖性,并且要尽可能避免。这意味着模块属性中的模块顺序很重要。</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">安全套接层的接口功能</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">SNMP工具箱MIB编译器的接口函数</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">与SNMP工具箱代理的接口功能</target>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">客户端和信使之间的接口定义。</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">SNMP工具箱的接口功能</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">与SNMP工具箱管理器的接口功能</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">XML Schema验证的接口模块。</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">XML模式验证的接口模块。它处理2004年10月28日发布的XML Schema第二版的W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; 。有关XML Schema研究的 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; 的介绍。XML结构通过xmerl_xsd：validate / [2,3]进行验证。</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 应用程序的接口模块。</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">事件追踪(ET)应用的接口模块</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Megaco应用的接口模块</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248的TPKT传输协议接口模块。</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248的UDP传输协议接口模块。</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">驱动程序中链接到柔性扫描仪的接口模块。</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">与操作系统系统信息的接口</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">连接TCP/IP套接字的接口。</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">连接UDP套接字的接口。</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">与Windows事件日志的接口</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">动态跟踪的接口</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">标准Erlang I/O服务器的接口</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Erlang内置术语存储BIF的接口</target>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">内部的Erlang定义。</target>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">锁的内部id,并不总是唯一的。这可以是ets表的表名(db_tab),端口的端口ID,分配器的整数标识符等。</target>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">服务器内部的错误记录在错误日志文件中。该文件的格式比使用通用日志文件格式的日志更无计划,但符合以下语法。</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">通道的内部状态。</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 内部使用几种提交协议。所选协议取决于事务中已更新的表。如果对称地复制了所有涉及的表（也就是说，它们都具有当前可从协调器节点访问的相同的 &lt;code&gt;ram_nodes&lt;/code&gt; ， &lt;code&gt;disc_nodes&lt;/code&gt; 和 &lt;code&gt;disc_only_nodes&lt;/code&gt; ），那么将使用轻量级事务提交协议。</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">在内部，称为 &lt;code&gt;alloc_util&lt;/code&gt; 的框架用于实现分配器。 &lt;code&gt;sys_alloc&lt;/code&gt; 和 &lt;code&gt;mseg_alloc&lt;/code&gt; 不使用此框架，所以下面也&lt;strong&gt;不能&lt;/strong&gt;适用于他们。</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">在每个优先级的内部,进程以循环的方式进行调度。</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">在Erlang运行时系统内部,锁是用来保护资源不被多个线程以致命的方式更新。锁是保证运行时系统正常工作的必要条件,但它也引入了一些限制。锁的争用和锁的开销。</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">在运行时系统内部，Erlang单调时间是&amp;ldquo;时间引擎&amp;rdquo;，用于或多或少地与时间有关的所有事情。所有计时器，无论它是 &lt;code&gt;receive ... after&lt;/code&gt; 计时器，BIF计时器还是在 &lt;code&gt;timer(3)&lt;/code&gt; 模块中的计时器之后的接收...，都被触发相对的Erlang单调时间。甚至 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 也基于Erlang单调时间。通过将当前的Erlang单调时间与当前时间偏移量相加，可以获得当前的Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">在内部，二进制文件和位串以相同的方式实现。在本节中，它们被称为&lt;strong&gt;二进制文件，&lt;/strong&gt;因为这就是它们在模拟器源代码中的名称。</target>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">在内部,记录使用标记的元组来表示。</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">在内部，主管还跟踪PID的 &lt;code&gt;Child&lt;/code&gt; 的孩子的过程中，或者 &lt;code&gt;undefined&lt;/code&gt; 如果没有PID存在。</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">不支持国际化域名。</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">可解释的模块是其中模块 &lt;code&gt;.beam&lt;/code&gt; 文件，用选项编译 &lt;code&gt;debug_info&lt;/code&gt; 组，位于相同的目录中的源代码，或在 &lt;code&gt;ebin&lt;/code&gt; 旁边目录。</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">解释器接口。</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">将其解释为普遍时间。</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">无论模式属性的值是多少,都会对escript进行解释。</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">解释指定的模块。 &lt;code&gt;i/1&lt;/code&gt; 仅在当前节点上解释模块。 &lt;code&gt;ni/1&lt;/code&gt; 解释所有已知节点上的模块。</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释指定的模块。 &lt;code&gt;ii/1&lt;/code&gt; 仅在当前节点上解释模块，请参见 &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ini/1&lt;/code&gt; 解释所有已知节点上的模块，请参阅 &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">将设定的时间解释为本地时间。</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">与空家族相交会退出，并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">与一组空集相交会退出，并显示 &lt;code&gt;badarg&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">在ERTS 8.1.2(Erlang/OTP 19.2)中引入。</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">在ERTS 8.3中引入(Erlang/OTP 19.3)。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">无效的主题备选名称扩展。</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">无效的Unicode码点是指0xd800到0xdfff(所谓的 &quot;代用 &quot;码点)的范围,以及0xffef。</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">无效的参数： &lt;code&gt;to&lt;/code&gt; 不是有效的Erlang pid。</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">无效的用户名或密码。</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">使mib服务器缓存无效。</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">反转量词的&amp;ldquo;贪婪度&amp;rdquo;，以便默认情况下它们不是贪婪的，但是如果后面跟有&amp;ldquo;？&amp;rdquo;，则变成贪婪的。它与Perl不兼容。也可以通过图案中的 &lt;code&gt;(?U)&lt;/code&gt; 选项设置进行设置。</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">为每个交易请求调用</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">当连接被关闭时调用。</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">建立新连接时调用</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">当收到的消息有语法错误时调用。</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">当收到的消息只包含一个错误而不是交易列表时调用。</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">当交易请求被中止时调用。</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">收到意外信息时调用</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">当文件传输中止时调用。</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;et:trace_me/5&lt;/code&gt; 并将 &lt;code&gt;From&lt;/code&gt; 和 &lt;code&gt;To&lt;/code&gt; 都设置为 &lt;code&gt;FromTo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">调用内存检查，并将生成的，与系统相关的数据作为带标签的元组的列表返回，其中， &lt;code&gt;Tag&lt;/code&gt; 可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">调用 Erlang/OTP 3.3 中的旧版 Erlang shell。旧的shell仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">调用 &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; 可能会失败，静默生成次优代码或静默生成错误代码。</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">是 &lt;code&gt;0&lt;/code&gt; 用于常规NIF（并且因此可以用于静态初始化被省略其值 &lt;code&gt;ErlNifFunc&lt;/code&gt; 实例）。</target>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">对于 &lt;code&gt;get&lt;/code&gt; 操作，是列号的列表，对于 &lt;code&gt;set&lt;/code&gt; 操作，是列号和值的列表。</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">最好是通过修改工具提供的 meas.sh.skel skeleton 脚本来运行。</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">最好是通过修改工具提供的mstone1.sh.skel skeleton脚本来运行。</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;height&lt;/code&gt; 则忽略。</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;width&lt;/code&gt; 则忽略。</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">是否可以减少函数的调用次数?</target>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">是实际的协议版本。在大多数情况下,协议版本是从处理过的消息中获取的,但也有例外。</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">挠性扫描仪到底是不是再进入。</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; 相同（表格，[详细，report_errors，report_warnings]）。</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">是被客户端通道进程调用,要求在服务器端执行用户默认shell(通常在Unix系统的/etc/passwd中定义)。</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">是由客户端-通道进程调用,用于请求在服务器上执行预定义的子系统。</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">由客户端通道进程调用，以请求服务器开始执行给定命令。结果是根据以下模式的几条消息。最后一条消息是通道关闭消息，因为 &lt;code&gt;exec&lt;/code&gt; 请求是一次性执行，执行完成后将关闭通道。</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">是由服务器通道进程调用,向客户端发送命令的退出状态。</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">是由客户端和服务器通道进程相互调用来发送数据。</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将用作 &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 参数 将是 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;get next&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;get&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">发出同步SNMP &lt;code&gt;set&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;tracer/2&lt;/code&gt; 指定了选项 &lt;code&gt;timer&lt;/code&gt; 则发出此命令将启动此跟踪的计时器。</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">如果F是一个家庭，则认为F是 &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; 的子集。如果 &lt;code&gt;union_of_family(F)&lt;/code&gt; 是 &lt;code&gt;domain(F)&lt;/code&gt; 的子集，则相等成立。</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">它允许其他表复制到这个节点。</target>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">它还初始化了一些SNMP计数器。</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">它调用 &lt;code&gt;run_erl&lt;/code&gt; ，它进行设置，以便操作员可以连接到系统。</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">它调用 &lt;code&gt;start_erl&lt;/code&gt; ，它使用正确的 &lt;code&gt;boot&lt;/code&gt; 和 &lt;code&gt;config&lt;/code&gt; 文件调用正确版本的 &lt;code&gt;erlexec&lt;/code&gt; （位于 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">也可以从Erlang程序内部使用它。如果在ASN.1模块 &lt;code&gt;Values&lt;/code&gt; 中定义了该ASN.1代码，则可以通过对 &lt;code&gt;'Values':tt()&lt;/code&gt; 的函数调用从Erlang 获取ASN.1值 &lt;code&gt;tt&lt;/code&gt; ，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">它可以通过以下方式进入:</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">对于一个经常读取数据,但很少写入数据的分布式应用来说,创建表复制是很有优势的,可以实现本地节点的快速读取操作。复制的主要缺点是增加了写数据的时间。如果一个表有两个副本,那么每个写操作都必须访问两个表的副本。由于这些写操作中必须有一个是网络操作,所以对复制表进行写操作的成本要比对非复制表进行写操作的成本高得多。</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">在调用 &lt;code&gt;sign&lt;/code&gt; 或 &lt;code&gt;verify&lt;/code&gt; 之前计算消息摘要，然后将 &lt;code&gt;none&lt;/code&gt; 用作第二个参数可能是合适的：</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">可能要求您的代码必须在不同OTP版本的各种OTP安装上运行。如果是这样，你不能使用新的API开箱即用，因为它不会是可利用的版本OTP 18之前的解决方案是&lt;strong&gt;不&lt;/strong&gt;以避免使用新的API，为您的代码会那么不从可扩展性和准确性的改善中受益制作。相反，请使用新的API（如果可用），并在新的API不可用时使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">可以看出,DBMS是由一个普通的文本文件启动的。</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">在这样的列表中查找最高和最低温度是很有用的。在扩展程序来做这件事之前,我们先来看看用于查找列表中元素最大值的函数。</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">可以验证,如果将数据插入到Ets表中,共享将丢失。</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">它可以是。</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">它还可以选择导出以下部分或全部内容:</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">有时能够对您自己的状态机生成事件可能会有所帮助。这可以通过 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">在指定的时间段内启用跟踪有时会很有用（例如，监视系统24小时或半秒）。这可以通过选项 &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; 。如果 &lt;code&gt;TimerSpec&lt;/code&gt; 的格式为 &lt;code&gt;MSec&lt;/code&gt; ，则使用 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;MSec&lt;/code&gt; 毫秒后停止跟踪。如果提供了更多的选择（ &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ）， &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 改为调用 &lt;code&gt;Opts&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">选择性/完全解码或独占性/部分解码的组合是最快的,这可以根据具体情况而定。</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">它不能通过URL引用检索互联网上的外部实体,只能检索本地文件系统中的资源。</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">这会导致 &lt;code&gt;Mnesia&lt;/code&gt; 在光盘满节点启动时尝试联系该节点。</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">也可能是对同步请求的延迟回复。</target>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">它本身并没有真正实现任何管理功能。这取决于&lt;strong&gt;用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它不设置任何 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，而是回复调用方，以等待 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 中的回复。 &lt;code&gt;From&lt;/code&gt; 必须是来自对 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 的调用中参数 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 的术语。</target>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">它是在用户数据报协议(UDP)的基础上实现的,因此它可以用来在实施UDP的不同网络上的机器之间移动文件。它的设计是小型和易于实现的。因此,它缺乏常规FTP的大部分功能。它唯一能做的就是从远程服务器读写文件(或邮件)。它不能列出目录,目前也没有用户认证的规定。</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">先前已经证明，每个表都具有许多系统属性，例如 &lt;code&gt;index&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;true&lt;/code&gt; ，如果在列表应用于所有元素的谓词是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">它是一个通道回调模块，用于实现外壳程序和命令执行。可以使用选项 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 定制shell的read-eval-print循环。与实现自己的CLI通道相比，这意味着更少的工作。如果 &lt;code&gt;ssh_cli&lt;/code&gt; 设置为 &lt;code&gt;no_cli&lt;/code&gt; ，则禁用诸如 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 之类的CLI通道，并且仅允许子系统通道。</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">这是一个旧版OTP的转储,其中没有写这个项目。</target>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">如果 &lt;code&gt;deterministic&lt;/code&gt; 选项受用户支持并且由用户提供，建议编译器删除所有非确定性信息。</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">允许省略 &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Stacktrace&lt;/code&gt; 。省略的 &lt;code&gt;Class&lt;/code&gt; 是 &lt;code&gt;throw&lt;/code&gt; 的简写：</target>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">还假定在 &lt;code&gt;otpuser&lt;/code&gt; 的主目录中有一个名为 &lt;code&gt;otp&lt;/code&gt; 的目录，其完整路径为：</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">还必须注意 &lt;code&gt;ERL_ERROR&lt;/code&gt; （发生错误）和 &lt;code&gt;ERL_TICK&lt;/code&gt; （来自其他节点的有效检查，将被忽略）类型。其他可能的类型指示过程事件，例如链接，取消链接和退出：</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">还有趣的是，知道在完整解码，排他解码之后是排除部分中的 &lt;code&gt;decode_part&lt;/code&gt; 和选择性解码之后是完整解码之间的关系。可以将某些情况与此模拟进行比较，例如，检查子值，然后再检查整个值。下表显示了该测试的数据。循环数和时间单位与之前的测试相同。</target>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">也可以直接从普通的Erlang Shell提示符下调用 &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">也有可能进行更深入的挖掘，例如，根据各种原因跳过或失败进行模式匹配。请注意， &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 元组已转换为 &lt;code&gt;{error,Reason}&lt;/code&gt; 。还请注意，如果收到 &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; 结果，则说明该测试用例成功，但该案例的 &lt;code&gt;end_per_testcase&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">也可以用xmerl对解析后的XML做进一步的处理。如果你想改变XML文档的格式,例如HTML,文本或其他XML格式,你可以转换它。xmerl支持这种转换。</target>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">也可以使用带有 &lt;code&gt;il&lt;/code&gt; 选项的方式以 &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; 形式从OTP应用程序导入MIB 。例：</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">如果使用下面的调用格式,也可以让解析器在需要时要求更多的输入标记。</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">通过使用Erlang仿真器中的内置跟踪支持，还可以对正在运行的系统进行实时跟踪。这些Erlang跟踪可以定向到文件或端口。有关更多信息，请参见 &lt;code&gt;erlang:trace/4&lt;/code&gt; ， &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; ， &lt;code&gt;dbg&lt;/code&gt; 和 &lt;code&gt;ttb&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">也可以用以下的回车方式将字符推回到输入字符中。</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">也可以引用一个在不同模块中定义的函数,其语法如下。</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">也可以通过写引用,如(?+2)来引用后面打开的小括号。然而,这些不能是递归的,因为引用不在被引用的小括号内。它们总是非递归的子程序调用,如下一节所述。</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">也可以指定应该在通知中发送的额外变量的名称和值,但在通知规范中没有定义。</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">也可以立即跟踪到创建原始剖析数据的剖析进程中,也就是将跟踪和剖析步骤短路,使文件系统不被使用。</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">也可以编写自己的Net if进程,本节介绍如何编写。</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">也可以编写自己的Net if过程。默认的Net if进程在模块 &lt;code&gt;snmpa_net_if&lt;/code&gt; 中实现，它使用UDP作为传输协议，即传输域 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 和/或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">在 &lt;code&gt;end_per_group/2&lt;/code&gt; 中，还可以检查子组的状态（也许确定当前组要返回什么状态）。这就像前面的示例中所示的那样简单，只有组名存储在元组 &lt;code&gt;{group_result,GroupName}&lt;/code&gt; 中，可以在状态列表中进行搜索。</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">还建议所有测试套件模块中都包含 &lt;code&gt;ct.hrl&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">如果多个进程同时更新同一记录，则更新事务内的数据库也很有用。例如，功能 &lt;code&gt;raise(Name, Amount)&lt;/code&gt; ，这增加 &lt;code&gt;Amount&lt;/code&gt; 到的人的工资字段，就是被如下实现：</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">同样值得注意的是,带有定时器的程序在调试时可能会有不同的表现。尤其是当停止执行一个进程时(例如,在断点处)。然后,超时可能发生在其他继续正常执行的进程中。</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">如果不是所有的 &lt;code&gt;String&lt;/code&gt; 字符都被消耗掉，那将是一个错误。</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">它在Erlang中的赋值如下。</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">假设驱动程序不访问其他驱动程序。如果驱动程序之间相互访问,它们必须提供自己的线程安全同步机制。这种 &quot;驱动程序之间的通信 &quot;是非常不鼓励的。</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">假设读者已经做过一些编程,对数据类型和编程语言语法等概念比较熟悉。</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">假设读者熟悉Erlang编程语言,对使用公钥和数字证书的概念有基本了解。</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">假定读者熟悉Erlang编程语言，&lt;strong&gt;OTP的&lt;/strong&gt;概念，并对&lt;strong&gt;公共密钥&lt;/strong&gt;有基本的了解。</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并具备SNMP的基本知识。</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对关系型数据库和SQL有基本了解。</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对和HTTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对FTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对TFTP协议有基本了解。</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并熟悉ASN.1符号。ASN.1符号被记录在标准定义X.680中,这是主要文本。阅读标准定义X.681、X.682、X.683、X.690和X.691也会有帮助,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、系统开发原理和数据库管理系统。</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">假设读者熟悉Erlang编程语言、OTP的概念,并对SSL/TLS/DTLS有基本了解。</target>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">假设读者熟悉Erlang编程语言。</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">假定已启用跟踪（请参见上面的 &lt;code&gt;enable_trace&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">假设你是一个熟练的Erlang程序员,熟悉Erlang数据类型、进程、消息和错误处理等概念。</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">假设你已经熟悉了Erlang编程语言和OTP概念。</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">假设你对司机有一定的了解。</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">假设你有一个工作的Erlang/OTP系统,按照OTP的设计原则进行架构。</target>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">它在方案字符串转换为方案原子之前被调用,因此可以防止可能的原子泄漏。</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">ASN.1模块从另一个ASN.1模块导入定义的类型、值和其他实体是很常见的。</target>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">设计使用SNMP来操纵和控制系统的应用程序很容易。 &lt;code&gt;Mnesia&lt;/code&gt; 提供了组成SNMP控制应用程序的逻辑表和组成 &lt;code&gt;Mnesia&lt;/code&gt; 表的物理数据之间的直接映射。默认值为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">在注册子代理时很容易出错,这项活动应谨慎进行。例如,以下配置会导致一种奇怪的行为:</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">如果使用非规范化数据模型而不是规范化模型，则很容易显示出执行速度更快的代码示例。主要原因是需要较少的表。因此，来自不同表的数据可以更轻松地合并到联接操作中。在前面的示例中，功能 &lt;code&gt;get_emps/2&lt;/code&gt; 从联接操作转换为简单查询，该查询由一个选择和一个表上的投影组成。</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">鼓励省略空目录。</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">为每个驱动程序实例初始化一次 &lt;code&gt;myKey&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">可以预期的是，本节中描述的类型语言将取代并替换 &lt;code&gt;@spec&lt;/code&gt; 使用的纯基于注释的 &lt;code&gt;@type&lt;/code&gt; 和@spec声明。</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">写一个生成器是相当容易的,每次调用它时,如果完成了,就生成一个空列表,否则就生成一个包含一个测试用例的列表,再加上一个新的生成器,生成其余的测试。这演示了基本的模式。</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">确保宏定义是有效的Erlang语法形式是良好的编程实践,但不是强制性的。</target>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">重要的是，表必须有足够数量的对象插槽。如果不是这样，则当 &lt;code&gt;init_table/2&lt;/code&gt; 返回时，哈希列表开始增长，这会在一段时间内显着减慢对表的访问。最小插槽数由 &lt;code&gt;open_file/2&lt;/code&gt; 选项 &lt;code&gt;min_no_slots&lt;/code&gt; 设置，并由 &lt;code&gt;info/2&lt;/code&gt; 项 &lt;code&gt;no_slots&lt;/code&gt; 返回。另请参见下面的选项 &lt;code&gt;min_no_slots&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">重要的是，返回的数据取决于选项集的正确类型。因此，在返回之前，&lt;strong&gt;如果可能&lt;/strong&gt;，我们将列表转换为采用正确编码的二进制文件。 &lt;code&gt;get_until&lt;/code&gt; 请求元组中提供的函数可以返回任何最终结果，因此只有返回列表的函数才能将它们转换为二进制。如果请求包含编码标签 &lt;code&gt;unicode&lt;/code&gt; ，则列表可以包含所有Unicode代码点，并且二进制文件应使用UTF-8。如果编码标签是 &lt;code&gt;latin1&lt;/code&gt; ，则客户端只能获取 &lt;code&gt;0..255&lt;/code&gt; 范围内的字符。功能 &lt;code&gt;check/2&lt;/code&gt; 如果将编码指定为 &lt;code&gt;latin1&lt;/code&gt; ,则注意不要在列表中返回任意Unicode代码点。如果该功能未返回列表，则无法执行检查，结果是未更改所提供功能的结果。</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">对脏作业进行正确分类很重要。I/O绑定作业应该这样分类,CPU绑定作业也应该这样分类。如果你应该把CPU绑定的作业分类为I/O绑定的作业,那么脏I/O调度器可能会饿坏普通调度器。I/O绑定作业预计要么阻塞等待I/O,和/或花费有限的时间移动数据。</target>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">需要理解的是,限制匹配时所说的 &quot;递归 &quot;并不是在Erlang机器的C栈或Erlang进程栈上的递归。编译到Erlang虚拟机中的PCRE版本使用机器 &quot;堆 &quot;内存来存储正则表达式匹配中必须保持递归的值。</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">使用没有分支的 &lt;code&gt;receive..after&lt;/code&gt; 表达式是合法的：</target>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">在归一化数据库中进行归一化搜索的效率更高。在归一化的数据模型上,有些操作也更容易执行。例如,可以很容易地删除一个项目,如下例所示:</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">设置一个本地锁比设置一个网络锁更有效率。因此,粘性锁可以使一个使用复制表的应用程序受益,并且只在其中一个节点上执行大部分工作。</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">它的效率更高。</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">能够在示例中进行格式化输出真是太好了，因此下一个示例展示了一种使用 &lt;code&gt;io:format&lt;/code&gt; 函数的简单方法。像所有其他导出的函数一样，您可以在shell中测试 &lt;code&gt;io:format&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">使用全局变量不是一个好主意,因为 port 驱动程序可以由多个 Erlang 进程生成。这个驱动结构要被多次实例化。</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">不允许从 &lt;code&gt;stop_select&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; 中的任何函数。此严格限制是因为可以调用 &lt;code&gt;stop_select&lt;/code&gt; 的易失上下文。</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">一旦在一个被跟踪的节点之一中激活了过载保护，就不允许更改跟踪详细信息（使用 &lt;code&gt;ttb:p&lt;/code&gt; 和 &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ）。这是为了避免节点之间的跟踪设置不一致。</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">不允许加载具有相同名称但具有不同 &lt;code&gt;Path&lt;/code&gt; 参数的多个驱动程序。</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">不允许引用未声明为导出的类型。</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">不允许将原子 &lt;code&gt;asn1_VALUE&lt;/code&gt; 和 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 与地图一起使用。</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">普通括号实现两个功能并不总是有用的。通常情况下,需要一个没有捕获要求的分组子模式。如果开头的小括号后面是一个问号和一个冒号,那么这个子模式就不做任何捕获,在计算任何后续捕获子模式的数量时也不会被计算在内。例如,如果将字符串 &quot;the white queen &quot;与下面的模式进行匹配,捕获的子串是 &quot;white queen &quot;和 &quot;queen&quot;,编号为1和2。</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">将传输添加到尚未配置的服务中并不是一个错误:服务可以在配置其传输后启动。</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">从尚不存在的服务中订阅事件不会出错。在添加传输之前,需要这样做,以保证接收所有传输相关的事件。</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">不检查表单是否符合 &lt;code&gt;AbstVersion&lt;/code&gt; 指示的抽象格式。 &lt;code&gt;no_abstract_code&lt;/code&gt; 表示存在块 &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; ，但为空。</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">它的设计不是为了被应用程序直接调用,而是通过i/o系统使用,在应用程序中通常可以通过以下方式调用它。</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">不能保证分布式磁盘日志的所有日志文件都包含相同的日志项。没有尝试同步文件的内容。但是，只要每次至少有一个涉及的节点处于活动状态，就会记录所有项目。在将项目记录到分布式日志中或尝试更改日志时，将忽略来自单个日志的答复。如果所有节点都已关闭，则磁盘日志功能 &lt;code&gt;nonode&lt;/code&gt; 错误答复。</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">即使表是固定的，也不能保证对 &lt;code&gt;first/1&lt;/code&gt; ， &lt;code&gt;next/2&lt;/code&gt; 或select and match函数的调用按预期工作。Dets尚未提供 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 模块提供的对并发的有限支持。当前修复表仅会禁用表的哈希列表的大小调整。</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">不难猜测该程序将数字的值加倍。该代码的前两行将在后面介绍。让我们编译程序。可以在Erlang shell中按如下方式完成此操作，其中 &lt;code&gt;c&lt;/code&gt; 表示编译：</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">并非必须实现 &lt;code&gt;Module:format_status/2&lt;/code&gt; 函数。如果不这样做，则使用默认实现，该实现与本示例函数相同，但不过滤 &lt;code&gt;Data&lt;/code&gt; 术语，即 &lt;code&gt;StateData = {State,Data}&lt;/code&gt; ，在此示例中包含敏感信息。</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">没有必要导出该函数。它在一个新生成的进程中被调用(该进程在函数返回后立即终止)。</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">不需要在发送的消息中明确地设置报头字段,因为 diameter 本身会设置适当的值。设置不合适的值对于测试来说是很有用的。</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">不需要将启动脚本链接到标准目录，例如 &lt;code&gt;/usr/local/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">使用此语法不可能对数字为10或更大的子模式使用数字&amp;ldquo;前向引用&amp;rdquo;，因为诸如\ 50之类的序列被解释为以八进制定义的字符。有关反斜杠后的数字处理的更多详细信息，请参阅前面的 &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; 一节。使用命名括号时没有这种问题。可以使用命名括号对任何子模式进行向后引用（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">除了表达式,其他地方不可能有未知形式的钩子函数。</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">通过测试无法证明程序是正确的。相反，已经正式证明不可能通过测试来证明程序。对于那些希望证明程序正确的人，理论上的程序证明或对代码的简单检查可能是可行的选择。基于测试的测试服务器不能用于认证。它的预期用途是（经济有效地）&lt;strong&gt;查找错误&lt;/strong&gt;。成功的测试套件可以揭示一个错误。如果测试套件的结果为&amp;ldquo; OK&amp;rdquo;，则说明我们之前所不知道的很少。</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">状态图没有规定如何处理图中某一特定状态中没有说明的事件是很常见的。希望在相关的文本中或从上下文中对此进行描述。</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">指定的开始时间晚于当前时间是无效的。如果指定 &lt;code&gt;StartTime&lt;/code&gt; 的时间早于日志可以支持的时间，则重播将从最早的可用通知开始。</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">现在可以很容易地检查释放对未定义函数的调用。</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">除非将 &lt;code&gt;long_request_timer&lt;/code&gt; （请参见上文）也设置为增量计时器（ &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ），否则将此值设置为&lt;strong&gt;true&lt;/strong&gt;当然是没有意义的。</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">当然,也可以更改多个列表。</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">当然,为什么有人愿意同时使用这两种方案是值得商榷的,但如果有意外的需要,也是可以的。</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">这个操作至关重要,不能长时间阻挡呼叫者。这是因为它是由连接主管调用的。</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">在这样的圆圈中标记查询变量通常是很清楚的。下图显示了一些预定义的分析。注意，仅由本地函数使用的本地函数未在 &lt;code&gt;locals_not_used&lt;/code&gt; 圆圈中标记。</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">在修改表格时,往往需要采取一些特定的行动。这可以通过一个工具函数来实现。当表被设置时,它会执行一些特定的代码,并将所有其他请求传递给预先定义的函数。</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">按原样使用Erlang/OTP系统往往是不可取的。开发者可以为某个特定的目的创建新的符合Erlang/OTP的应用,而原有的几个Erlang/OTP应用可能与相关目的无关。因此,需要能够在给定的Erlang/OTP系统的基础上创建一个新的系统,在这个系统中删除可有可无的应用程序,并包含新的应用程序。文档和源代码是不相关的,因此不包含在新系统中。</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">通常情况下,在escript中加入一个头是非常方便的,尤其是在Unix平台上。但是,头是可选的,所以你可以直接 &quot;执行 &quot;一个Erlang模块,Beam文件,或者存档文件,而不需要添加任何头。但是你必须调用脚本,如下所示。</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">在FIPS模式下， &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; 分别使用 &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; 和usmAesCfb128Protocol进行身份验证和隐私。但是，snmp应用程序不会以任何方式限制选择禁用的协议，使用它们会导致运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">它由状态转换动作 &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 或只是一个整数 &lt;code&gt;Time&lt;/code&gt; 排序，即使没有封闭动作列表（后者是从 &lt;code&gt;gen_fsm&lt;/code&gt; 继承的形式）。</target>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">通过这个选项,可以为状态提供早期验证的过程信息。</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">Emacs可以在显示缓冲区时使用颜色。我们所说的 &quot;语法高亮 &quot;是指语法成分,例如关键字和函数名,将被着色。</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">一个处理程序即使能够成功地处理高负载的峰值而不崩溃,也有可能建立一个大的消息队列,或者使用大量的内存。过载保护机制包括一个自动终止和重新启动的功能,目的是为了保证处理程序不会增长到超出边界的程度。该功能的配置参数如下。</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">可以将&lt;strong&gt;通知过滤器&lt;/strong&gt;添加到代理。发送通知时将调用这些过滤器。它们的目的是允许修改，抑制或其他类型的动作。</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">可以仅通过给出相应的进程标识来附加到被解释的进程。默认情况下,会显示一个附加窗口。其他 Erlang 节点的进程可以手动或自动附加。</target>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">可以将 &lt;code&gt;escript&lt;/code&gt; 与Erlang运行时系统捆绑在一起，以使其自给自足且可重定位。在这样的独立系统中， &lt;code&gt;escript&lt;/code&gt; 应位于独立系统的顶层 &lt;code&gt;bin&lt;/code&gt; 目录中，并以 &lt;code&gt;.escript&lt;/code&gt; 作为文件扩展名。此外，应将（内置） &lt;code&gt;escript&lt;/code&gt; 程序复制到同一目录，并赋予脚本原始名称（不带 &lt;code&gt;.escript&lt;/code&gt; 扩展名）。这将允许使用捆绑的Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">可以使匹配过程有条件地服从一个子模式,或者根据一个断言的结果,或者是否已经匹配了一个特定的捕获子模式,在两个备选子模式中进行选择。以下是条件子模式的两种可能形式。</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">可以配置一个3588字典,以获得3588语义,其中与6733不同。</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">可以调试应用程序的每个（非主管）进程（代理和管理器），可能是net_if模块的例外，这可以由应用程序的用户提供。这可以通过调用 &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; 和 &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; 函数和/或使用 &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。详细程度本身有几个&lt;strong&gt;层次&lt;/strong&gt;： &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; 。对于最低的详细度 &lt;code&gt;silence&lt;/code&gt; ，不会打印任何内容。详细程度越高，打印的越多。默认值为始终 &lt;code&gt;silence&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">可以生成一个 &lt;code&gt;.hrl&lt;/code&gt; 文件，其中包含来自已编译的MIB文件的Erlang常量的定义。然后可以将该文件包含在Erlang源代码中。该文件将包含以下常量：</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">可能在一个节点上具有 &lt;code&gt;disc_copies&lt;/code&gt; 类型的复制表，而在另一节点上具有另一种类型的复制表。默认值为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">可能在一个节点上具有 &lt;code&gt;disc_copies&lt;/code&gt; 类型的复制表，而在另一节点上将同一表存储为不同类型的表。默认值为 &lt;code&gt;[]&lt;/code&gt; 。如果需要以下操作特性，则此布置是理想的：</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">可以有以下ASN.1类型定义:</target>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">可以将mib加载到管理器中,但这不是正常运行所必需的,也不推荐。</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">可以修改进程的默认行为，以使其在收到异常退出信号时不会被杀死。而是将所有信号转换为格式为 &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; 普通消息，并将其添加到接收过程的消息队列的末尾。通过以下方式设置此行为：</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">除了预定义的宏,可以重载宏。一个重载宏有一个以上的定义,每个定义有不同的参数数。</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">通过使用选项 &lt;code&gt;{compress, What}&lt;/code&gt; 和 &lt;code&gt;{uncompress, What}&lt;/code&gt; 可以覆盖默认行为并控制要压缩的文件类型。也可以使用许多 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">可以对图形进行一些有限的操作。节点可以被移动、选择、锁定或删除。在按下鼠标左键的同时移动鼠标,可以移动单个节点或整个图形。松开鼠标左键时,按住shift键可以锁定一个节点的固定位置。在按下控制键和鼠标左键的同时移动鼠标,可选择多个节点。点击合适的按钮,可以锁定、解锁或删除所选节点。</target>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;catch&lt;/code&gt; 或 &lt;code&gt;try&lt;/code&gt; 可以防止运行时错误和其他异常导致进程终止，请参阅有关 &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">通过首先使用 &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 操作 &lt;code&gt;DataOrStats&lt;/code&gt; ,可以打印更多特定类型的统计信息。例如，如果要打印每个线程的运行时百分比，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">可以指定该模块是&lt;strong&gt;行为&lt;/strong&gt;的回调模块：</target>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">可以在IPv6而非IPv4上使用SSL / TLS分发。为此，请在命令行或 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 环境变量中启动Erlang时传递 &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; 选项而不是 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">可以根据某些原理用C编写驱动程序，并将其动态链接到Erlang运行时系统。从Erlang程序员的角度来看，链接的驱动程序看起来像是端口，被称为&lt;strong&gt;端口驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">可以在网络中的多个节点上以全局模式启动Debugger,但绝对不推荐,因为节点之间会相互干扰,导致行为不一致。</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">它主要用于 &lt;code&gt;ets:match/2&lt;/code&gt; 和 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 中，以将记录字段设置为原子 &lt;code&gt;'_'&lt;/code&gt; 。（这是 &lt;code&gt;ets:match/2&lt;/code&gt; 中的通配符。）</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">同时进行壁时钟测量和CPU时间测量可能是一个好主意。</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">休眠过程是相当昂贵的；参见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 。在每个事件之后，您都不希望这样做。</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">SSH连接协议建议发送此消息,但并非总是如此。</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">除非绝对必要，否则建议不要指定 &lt;code&gt;LogFileOpts&lt;/code&gt; 。处理程序用来打开文件进行日志记录的默认选项是 &lt;code&gt;raw&lt;/code&gt; ， &lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;delayed_write&lt;/code&gt; 。请注意，标准处理程序不支持循环日志记录。为此，请使用disk_log处理程序 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 采用与 &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 遵循与 &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议 &lt;code&gt;Report&lt;/code&gt; 遵循与 &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; 相同的结构。</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">建议将应用程序目录命名为应用程序，可能后跟短划线和版本号。例如 &lt;code&gt;myapp&lt;/code&gt; 或 &lt;code&gt;myapp-1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">建议在 &lt;code&gt;Mnesia&lt;/code&gt; 运行时不要篡改数据文件。虽然未被禁止，但 &lt;code&gt;Mnesia&lt;/code&gt; 的行为是无法预测的。</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">建议嵌入式环境由普通用户,也就是没有超级用户权限的用户来运行。</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">建议添加这几行以避免冲突。冲突会使系统无法启动。</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">建议只在需要与外部实体通信时使用外部编码。当在Erlang/OTP环境中工作时,当表示Unicode字符时,建议将二进制文件保持在UTF-8中。ISO Latin-1编码既支持向后兼容性,也支持与不支持Unicode字符集的外部实体进行通信。</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">建议在具有多个并发进程的系统上将此参数设置为 &lt;code&gt;false&lt;/code&gt; ，因为每次进程内存检查都会遍历整个进程列表。</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">为了便于阅读，建议尽可能使用 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 。然而，该功能将在兼容性的界面被保留，并且将&lt;strong&gt;不会&lt;/strong&gt;在以后的版本不事先通知被移除。</target>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">建议使用由Erlang / OTP MIB编译器创建的 &lt;code&gt;.hrl&lt;/code&gt; 文件来定义对象标识符（OID）。例如，要从OTP-MIB中的 &lt;code&gt;erlNodeTable&lt;/code&gt; 获取Erlang节点名称：</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">建议使用 &lt;code&gt;record_info/2&lt;/code&gt; 表示法，因为它可以更轻松地维护程序，并且程序在将来的记录更改方面也变得更强大。</target>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时创建用户定义的启动脚本很有用或必要。尤其是在嵌入式模式下运行Erlang时，这是正确的，请参阅 &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">强烈建议使用此功能,避免以非标准方式缩进行。一些动机是:</target>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">之后，调用者有责任释放数组。该函数已经通过对 &lt;code&gt;malloc()&lt;/code&gt; 的一次调用分配了，因此仅需一个 &lt;code&gt;free()&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">释放数组是调用者的责任。 &lt;code&gt;erl_global_names&lt;/code&gt; 使用对 &lt;code&gt;malloc()&lt;/code&gt; 的一次调用分配数组和所有字符串，因此 &lt;code&gt;free(names)&lt;/code&gt; 就是必需的。</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">释放返回的 &lt;code&gt;ETERM&lt;/code&gt; 结构和 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 指向的内存是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">释放 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; ， &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 指向的内存是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">然后可以分配如下数值:</target>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">因此，重要的是，赋予 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; 的Fun中的代码是纯净的。例如，如果消息是通过事务Fun发送的，则可能会产生一些奇怪的结果。以下示例说明了这种情况：</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">因此,建议尽可能小步骤地修改代码,并始终保持向后兼容。</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">它将是(或导致)对下列任何一项的调用:</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">通常，使用匹配而不是调用 &lt;code&gt;split_binary/2&lt;/code&gt; 函数来拆分二进制文件更为有效。此外，混合使用位语法匹配和 &lt;code&gt;split_binary/2&lt;/code&gt; 可以阻止对位语法匹配的某些优化。</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">从源代码构建有效的OpenSSL FIPS对象模块和库非常容易。但是，如果未正确遵循安全策略中的众多限制，则它&lt;strong&gt;不&lt;/strong&gt;符合FIPS 140-2验证的条件。</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">了解编码和Unicode字符之间的区别是至关重要的。根据Unicode标准,Unicode字符是代码点,而编码是表示这些代码点的方法。编码只是一种表示标准。例如,UTF-8可以用来表示Unicode字符集中非常有限的一部分(例如ISO-Latin-1)或整个Unicode范围。它只是一种编码格式。</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">它将一组备选方案本地化。例如,以下模式匹配 &quot;cataract&quot;、&quot;caterpillar &quot;或 &quot;cat&quot;。</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">它使调试变得困难(因为故障可能是由不同的测试用例中的问题造成的,而不是失败的测试用例)。</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">这使得测试用例无法以不同的顺序运行。</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">这使得它无法单独运行测试用例。</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">它与主语 &quot;ab &quot;中的 &quot;ab &quot;相匹配。使用回溯控制动词(*PRUNE)和(*SKIP)也会使这种优化失效。</target>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">如果底层OpenSSL实现中没有引擎支持,它也可能抛出异常notsup。</target>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">似乎在没有事先知道元素数量的情况下无法创建列表。但是确实有办法。请注意，列表 &lt;code&gt;[a, b, c]&lt;/code&gt; 可以写为 &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; b | c] 。[b | [c]]。使用此功能，可以将清单写为简略。</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">为了解决安全问题,可能需要引入不兼容的变更。这种不兼容的情况可能发生在补丁中。</target>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">进行两步升级而不是仅使用所有应用程序的新版本重新启动模拟器似乎很奇怪。做出此设计决定的原因是允许 &lt;code&gt;code_change&lt;/code&gt; 函数具有副作用，例如，更改磁盘上的数据。它还可以确保非核心应用程序的升级机制不会因核心应用程序是否同时更改而有所不同。</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">你写不写已经不重要了(从性能的角度看)。</target>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">它的作用如下:</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">它需要在配置文件中加入以下内容。</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">它返回通过对列表中的每个参数应用函数得到的列表。</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">除非评估期间发生异常 &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; 否则它将返回 &lt;code&gt;Exprs&lt;/code&gt; 的值（表达式序列Expr1，...，ExprN）。在这种情况下，将捕获 &lt;code&gt;ExceptionPattern&lt;/code&gt; ，并且将具有正确异常类 &lt;code&gt;Class&lt;/code&gt; 的ExceptionPattern模式与捕获的异常顺序匹配。如果匹配成功，并且可选的保护序列 &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; 为true，则将评估对应的 &lt;code&gt;ExceptionBody&lt;/code&gt; 以使其成为返回值。</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">它将 &lt;code&gt;io_reply&lt;/code&gt; 元组发送回客户端，提供请求中接收到的元素 &lt;code&gt;ReplyAs&lt;/code&gt; 以及请求的结果，如前所述。</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它将子模式设置为捕获子模式。也就是说，当完整模式匹配时，与子模式匹配的主题字符串部分将通过 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的返回值传递回调用方。</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">它启动跟踪服务器，然后设置适当的匹配规范（根据 &lt;code&gt;Level&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">它采用32位salt值，并在 &lt;code&gt;0..2^32-1&lt;/code&gt; 内生成哈希值。</target>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">它只使用数字或位运算符。</target>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">当此回复到达时，它会写上&amp;ldquo; Ping收到的Pong&amp;rdquo;，然后&amp;ldquo; ping&amp;rdquo; 再次调用 &lt;code&gt;ping&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">假定读者熟悉 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; 。为了能够修补应用程序，必须存在以下内容：</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">不过,它使用的是原生实现,不在堆上建立垃圾,性能稍好。</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">Item (?p{...})在运行时对Perl代码进行插值,在这种情况下,递归地引用它出现的模式。</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">可以使用功能 &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; &lt;strong&gt;同步&lt;/strong&gt;记录项目。对于这些功能中的每一个，调用者都将保持等待状态，直到记录项目为止（但不一定要写入，请使用 &lt;code&gt;sync/1&lt;/code&gt; 来确保）。通过为每个提及的函数名称添加 &lt;code&gt;a&lt;/code&gt; ，我们获得了&lt;strong&gt;异步&lt;/strong&gt;记录项目的函数。异步函数不等待磁盘日志过程将项目写入文件，而是将控件立即或多或少地返回给调用者。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">对当前存储的事件进行迭代。</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">对备份进行迭代,将其转换为新的备份,或读取它。这里简要解释了参数。详情请参见用户指南。</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">对当前存储的事件进行迭代,并对每个事件应用一个函数。迭代可以向前或向后进行,并且可以限制事件的最大数量(abs(Limit))。</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">遍历表 &lt;code&gt;Table&lt;/code&gt; 并为表中的每个 &lt;code&gt;Record&lt;/code&gt; 调用 &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; 。从 &lt;code&gt;Function&lt;/code&gt; 返回的术语在下一次调用 &lt;code&gt;Function&lt;/code&gt; 时用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">其语法如下:</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">它的值在遵守时可以评价为一个常数。</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">詹姆斯登录c2@kosken。</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">詹姆斯现在试图给弗雷德发信息。</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-从Erlang/OTP R7B中移除。</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jive在Erlang程序和Java程序之间提供了一个简单的接口。</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">作业控制模式 &lt;code&gt;JCL&lt;/code&gt; ，可以在其中启动，终止，分离和连接作业</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">加入的规范共享通用的配置设置，例如 &lt;code&gt;config&lt;/code&gt; 文件列表或 &lt;code&gt;include&lt;/code&gt; 目录。对于无法组合的配置，例如 &lt;code&gt;logdir&lt;/code&gt; 或 &lt;code&gt;verbosity&lt;/code&gt; 的设置，由用户确保加入测试规范时不会发生冲突。 &lt;code&gt;separate&lt;/code&gt; 选项中包含的规范不与源规范共享配置设置。例如，这在包含的规范中配置配置冲突时很有用，使其无法加入。</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">将多个规格加入,或者分别运行,也可以通过(可以结合)测试规格文件的收录来实现。</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">用目录分隔符连接文件名 &lt;code&gt;Components&lt;/code&gt; 列表。如果 &lt;code&gt;Components&lt;/code&gt; 的元素之一包括绝对路径，例如 &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; ，则从结果中删除前面的元素（如果有）。</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">加入一个多播组。</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">加入具有相对文件名的绝对目录。与 &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; 相似，但在对原始文件名长度有严格限制且不支持符号链接的平台上（阅读：VxWorks）， &lt;code&gt;Filename&lt;/code&gt; 中的主要父目录组件与 &lt;code&gt;Dir&lt;/code&gt; 中的尾随目录组件匹配，因此可以从结果中删除它们。 -最小化其长度。</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">将单个注释行合并为多行注释。输入是代表条目的列表，&lt;strong&gt;以行号递减的顺序&lt;/strong&gt;表示各个注释行；有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; 。结果是代表&lt;strong&gt;多行&lt;/strong&gt;注释的条目列表，&lt;strong&gt;仍按行号递减的顺序列出&lt;/strong&gt;，但是对于每个条目， &lt;code&gt;Text&lt;/code&gt; 是按行号&lt;strong&gt;递增的&lt;/strong&gt;顺序排列的连续注释行的列表（即，自上而下）。</target>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">将调用线程与另一个线程连接起来，也就是说，调用线程被阻塞，直到由 &lt;code&gt;tid&lt;/code&gt; 标识的线程终止。</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">将进程 &lt;code&gt;Pid&lt;/code&gt; 加入到组 &lt;code&gt;Name&lt;/code&gt; 中。一个进程可以多次加入一个组，然后必须离开该组相同的次数。</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">用目录分隔符连接两个文件名组件。等效于 &lt;code&gt;join([Name1, Name2])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">跳转函数:相当于2^512次调用</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">跳转函数:相当于2^64次调用</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">运行 &lt;code&gt;configure&lt;/code&gt; 脚本时，只需在命令中添加 &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; 选项即可。如果使用的是systemtap，则configure选项为 &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">只需打印一个显示当前文件和行号的标记。请注意，这是一个无参数的宏。结果总是 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">保持活动状态（如果连接空闲，则每8秒向服务器发送一次NOP）= &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">请记住，外部命令高度依赖于操作系统。您可以在测试生成器函数中使用标准库函数 &lt;code&gt;os:type()&lt;/code&gt; ，以根据当前操作系统生成不同的测试集。</target>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">监测过程中要保持整洁,不要把系统监测限值设置得太紧。</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">保留一个索引表,在表中插入记录时,会引入一些开销。因此,必须将从表中获得的操作数与在表中插入对象的操作数进行比较。然而,注意到当键可以用来查找元素时,收益是显著的。</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">Kernel-运行Erlang所需的功能。</target>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">密钥 &lt;code&gt;mod&lt;/code&gt; 对于实现为监督树的应用程序是必需的，否则应用程序控制器不知道如何启动它。对于没有进程的应用程序，通常是代码库，例如STDLIB，可以省略 &lt;code&gt;mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">交换钥匙;</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">密钥长度为128、192或256位</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">密钥长度为64位(在CBC模式下只使用8位)</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">线程特定数据可以关联的键。</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">键值字典为有序列表。</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">键值词典;</target>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">键和值之间用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 箭头分隔，关联之间用逗号 &lt;code&gt;,&lt;/code&gt; 。）分隔。</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">键是字符串，即以 &lt;code&gt;NULL&lt;/code&gt; 终止的字符数组，而值是任意对象。尽管注册表特别对待整数和浮点数，但是您可以将字符串或任何类型的二进制对象存储为指针。</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">切割线</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">杀死或暂停当前的外壳</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">杀死接收过程。</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">杀死运行 &lt;code&gt;epmd&lt;/code&gt; 如果只允许 &lt;code&gt;epmd -names&lt;/code&gt; 显示一个空数据库，或者 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 时的运行实例指定 &lt;code&gt;epmd&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">终止作业号 &lt;code&gt;nn&lt;/code&gt; 或当前作业。只要尚未评估 &lt;code&gt;group_leader/1&lt;/code&gt; BIF且位于本地计算机上，该作业中所有产生的进程都将被杀死。远程节点上产生的进程不会被杀死。</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">杀死当前正在运行的 &lt;code&gt;epmd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">已知主机-OpenSSH格式如下:</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">已知问题。当一个节点以相同节点名多次重启时,在较新节点上创建的引用可能会被误认为是在较旧节点上创建的相同节点名的引用。</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">已知节点</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">LALR-1解析器生成器</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAP客户端</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST:用户空间追踪库。</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-tools:一个控制跟踪会话的命令行接口。</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">事件的标签(类型)。</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">标签旨在提供一个简短的事件摘要。</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">标记测试运行（类似于 &lt;code&gt;ct_run -label&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">在OTP 21之前,标签被限制为小的有符号整数(28位)。如果跟踪令牌越过一个不支持标签的节点,它将被沉默地丢弃。</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">缺乏支持。如为HiPE编译模块加载NIF库。</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">不允许在匹配规范中使用诸如 &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 之类的语言构造。</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">在任何函数中都不考虑对输入的语言或语言环境的特定处理。</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">没有大写(或小写)概念的语言。</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">大文件支持</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">大型地图（&amp;gt; 32键）</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">大批量的日志事件--处理者在短时间内收到的许多事件--可能会造成潜在的问题,比如:。</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">大整数</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">大规模的自动化测试需要并行运行多个独立的测试会话。这可以通过在一个或多个主机上运行一些 &lt;code&gt;Common Test&lt;/code&gt; 节点，测试不同的目标系统来实现。独立配置，启动和控制测试节点可能是一项繁琐的操作。为了帮助进行这种自动化的大规模测试， &lt;code&gt;Common Test&lt;/code&gt; 提供了一个主测试节点组件 &lt;code&gt;Common Test&lt;/code&gt; Master，该组件在分布式 &lt;code&gt;Common Test&lt;/code&gt; 节点的系统中处理中央配置和控制。</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">较大的程序通常被写成一个文件的集合,各部分之间有一个明确的接口。</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">较大的测试用例在失败的情况下更难判断出了什么问题。另外,当错误发生时,大段的测试代码有可能被跳过。</target>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">最大（ &lt;code&gt;mseg_alloc&lt;/code&gt; ）多块载波大小（以千字节为单位）。请参阅 &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 部分中有关如何确定 &lt;code&gt;mseg_alloc&lt;/code&gt; 多块载波的大小的描述。在32位Unix风格的操作系统上，此限制不能设置为&amp;gt; 128 MB。</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start_link/4&lt;/code&gt; 的最后一个参数。</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">最后的交易ID:</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">最后,应用程序主程序终止。请注意,所有以应用主程序为组长的进程,即从属于应用的进程中产生的进程,也被终止。</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">后来,当你修复了应用程序my_app中的一个bug,你想更新PLT,使它在下次运行Dialyzer时变得新鲜。在这种情况下,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">在写文件之前,焦油成员名中的前导斜线将被删除。也就是说,绝对路径将变成相对路径。当以这种方式改变路径时,会有一条信息写入错误记录器。</target>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">离开多播组。</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">留给用户阅读和解释记录的数据。该 &lt;code&gt;disk_log&lt;/code&gt; 模块不能修复外部格式化日志。</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leex将添加扩展 &lt;code&gt;.hrl&lt;/code&gt; 到 &lt;code&gt;Includefile&lt;/code&gt; 名和扩展名 &lt;code&gt;.erl&lt;/code&gt; 到 &lt;code&gt;Scannerfile&lt;/code&gt; 名称，除非扩展已经存在。</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">左联想</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容的原因，具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的旧版API函数 &lt;code&gt;process_msg/7&lt;/code&gt; 仍像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">由于向后兼容的原因，具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的旧版API函数 &lt;code&gt;send_pdu/7&lt;/code&gt; 仍像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">旧版API函数 &lt;code&gt;add_addr/10&lt;/code&gt; (未指定传输域）以及具有单独的 &lt;code&gt;IpAddr&lt;/code&gt; 和 &lt;code&gt;PortNumber&lt;/code&gt; 参数的 &lt;code&gt;add_addr/11&lt;/code&gt; 仍然可以像往常一样工作，原因是向后兼容。</target>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">使用不带 &lt;code&gt;Domain&lt;/code&gt; 元素的元组以及所有 &lt;code&gt;TDomain&lt;/code&gt; ， &lt;code&gt;Ip&lt;/code&gt; 和 &lt;code&gt;Port&lt;/code&gt; 元素的旧配置仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">旧版网络接口筛选器模块使用 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 形式的参数代替 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ，如果运行SNMP代理而不更改配置以使用传输域，则使用网络接口筛选器仍然会得到旧的论点并像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">传统网络接口筛选器模块使用 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 形式的参数，而不是 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ，并且如果运行SNMP管理器而不更改配置以使用传输域，则网络接口筛选器仍然会得到旧的论点并像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">旧版通知传递信息接收器模块使用 &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; 而不是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 形式的目标参数，并且如果运行SNMP代理而不更改配置以使用传输域，则通知传递信息接收器仍将获得旧的论点，照旧工作。</target>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">遗留的解决方案最终可能需要取消。在这种情况下,它们将在足够长的时间内被逐步淘汰,以使用户有时间适应。在移除功能之前,至少会在一个版本中明确宣布即将移除的功能。新的弃用至少会在发行说明和文档中宣布。</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">CGI中使用的遗留字符串,忽略即可。</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">节点名称的长度</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">低于</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">小于或等于</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">令 &lt;code&gt;SetOfSets&lt;/code&gt; 为一组集合，让 &lt;code&gt;BinRel&lt;/code&gt; 为二进制关系。每个元素映射函数 &lt;code&gt;Set&lt;/code&gt; 的 &lt;code&gt;SetOfSets&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 下 &lt;code&gt;BinRel&lt;/code&gt; 由以下函数返回：</target>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">让每个进程都有两个计数器 &lt;code&gt;prev_cnt&lt;/code&gt; 和 &lt;code&gt;curr_cnt&lt;/code&gt; ，在创建进程时都将它们设置为 &lt;code&gt;0&lt;/code&gt; 。计数器在以下情况下更新：</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">让Megaco堆栈启动柔性扫描仪(加载驱动程序)。</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">让跟踪令牌的序列为 &lt;code&gt;tprev&lt;/code&gt; 和 &lt;code&gt;tcurr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">让此过程通过调用 &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; 函数启动Flex扫描器。</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">让我们(再次)打印城市列表中的温度。</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">我们假设有两台计算机,分别叫gollum和kosken。首先在kosken上启动一个节点,称为ping,然后在gollum上启动一个节点,称为pong。</target>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">让我们继续往下打印寻找。</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">让我们找到 &lt;code&gt;suspend&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">我们先来看看如何不做。</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">我们来看看运行后的打印结果。</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">让我们利用一些有趣的功能直接跳入深渊的例子。</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">让我们现在打电话。</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">现在让我们定义一个乐趣,可以用来通过一个城市和温度的列表,并将它们全部转化为摄氏度。</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">现在让我们回到测试代码。</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">现在，让我们使用这个重写乒乓球例子，有的名称 &lt;code&gt;pong&lt;/code&gt; 到&amp;ldquo;傍&amp;rdquo;的过程：</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">让我们回到信使程序,并添加修改,使其更加强大。</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">让我们再来看看上一节开头的例子。</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">让我们在不同的计算机上用&amp;ldquo; ping&amp;rdquo;和&amp;ldquo; pong&amp;rdquo;重写乒乓程序。首先，需要进行一些设置才能使其正常运行。分布式Erlang实现提供了非常基本的身份验证机制，以防止意外访问另一台计算机上的Erlang系统。互相交谈的Erlang系统必须具有相同的&lt;strong&gt;魔术cookie&lt;/strong&gt;。实现此目的最简单的方法是在要运行彼此通信的Erlang系统的所有计算机上的主目录中都有一个名为 &lt;code&gt;.erlang.cookie&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">让我们看看在 &lt;code&gt;convert&lt;/code&gt; 函数中输入 &lt;code&gt;centimeter&lt;/code&gt; 或 &lt;code&gt;inch&lt;/code&gt; 以外的值会发生什么：</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">让我们使用 &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 示例中描述的示例数据库 &lt;code&gt;Company&lt;/code&gt; 来说明如何在两个单独的节点 &lt;code&gt;a@gin&lt;/code&gt; 和 &lt;code&gt;b@skeppet&lt;/code&gt; 上运行数据库。在启动 &lt;code&gt;Mnesia&lt;/code&gt; 之前，这些节点中的每个节点都必须具有 &lt;code&gt;Mnesia&lt;/code&gt; 目录和已初始化的架构。有两种方法可以指定要使用的 &lt;code&gt;Mnesia&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">让关于未知函数和类型的警告影响命令行版本的退出状态。在设置退出状态时,默认是忽略关于未知函数和类型的警告。当使用来自Erlang的Dialyzer时,会返回关于未知函数和类型的警告,默认情况下是不返回这些警告。</target>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">让所有被跟踪的进程创建的进程继承跟踪进程的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">每当被跟踪的进程链接到 &lt;code&gt;P2&lt;/code&gt; 时，让另一个进程 &lt;code&gt;P2&lt;/code&gt; 继承被跟踪的进程的跟踪标志。</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">让我们来详细了解一下。</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">那我们走吧！我们将从安装程序的简短版本开始，然后是一些常见问题解答，然后我们将详细介绍安装程序。</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;epmd&lt;/code&gt; 的此实例仅侦听以逗号分隔的IP地址列表和回送地址（如果未指定，则隐式添加到列表中）。也可以使用环境变量 &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; 进行设置；请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;epmd&lt;/code&gt; 的该实例侦听默认值4369以外的另一个TCP端口。也可以使用环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 进行设置。请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">字号</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">字母和数字</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">模式中的字母与大写字母和小写字母都匹配。它等效于Perl选项 &lt;code&gt;/i&lt;/code&gt; ,并且可以通过 &lt;code&gt;(?i)&lt;/code&gt; 选项设置在模式内进行更改。大写和小写字母的定义与ISO 8859-1字符集相同。</target>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">第1级:函数头、保留字、注释、字符串、引用的原子和字符常量将被着色。</target>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">第2级:以上,属性、Erlang bif:s、guards以及注释中用单引号括起来的词都会被着色。</target>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">第3层:上面的,变量,记录,宏都会有颜色。这个级别也被称为圣诞树级别)。</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Erlang的词汇分析生成器</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">可以添加，编辑或删除库目录。这是通过选择显示库目录路径的行并单击鼠标右键来完成的。在弹出的菜单中选择添加，编辑或删除。通过选择&amp;ldquo; &lt;code&gt;Library directories&lt;/code&gt; &amp;rdquo;行并单击鼠标右键，也可以添加新的库目录。在弹出的菜单中选择添加。</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">处理二进制数据的库</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">用于处理二进制数据的库。</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">库模块--没有实现流程的模块的骨架。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">像 &lt;code&gt;#&lt;/code&gt; 一样，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 一样，但是列表从右到左遍历。</target>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; ，但是解压缩没有更多的数据比将适合在通过被配置在缓冲 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; 。在对具有高压缩率的流进行解压缩时非常有用，这样少量的压缩输入可以扩展到1000倍。</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 一样，但是一旦它扩展到实现定义的较小阈值，它就会返回。当解压缩不受信任的输入时很有用，该输入可能被恶意制作以扩展直到系统用尽内存。</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; ，但仅插入顶级注释。函数定义或声明（&amp;ldquo;表单&amp;rdquo;）中的注释将被忽略。</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;@custom_types&lt;/code&gt; 类似,但要求指定的模块导出 &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; 而不是 &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">类似于 &lt;code&gt;B&lt;/code&gt; ，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">与 &lt;code&gt;B&lt;/code&gt; 相似，但使用以Erlang样式 &lt;code&gt;#&lt;/code&gt; 分隔的基本前缀打印数字。例：</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">类似于 &lt;code&gt;B&lt;/code&gt; ，但是使用一个额外的参数，该参数是要在数字之前但在前导破折号（如果有）之后插入的前缀。</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">类似于 &lt;code&gt;X&lt;/code&gt; ，但显示小写字母。</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">像 &lt;code&gt;any&lt;/code&gt; 一样，但在有匹配项的第一个过滤器处停止，如果有多个对等项，效率会高得多。例如，以下过滤器将仅导致与主机过滤器和领域过滤器最匹配的对等设备。</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">类似于 &lt;code&gt;debugVal(Expr)&lt;/code&gt; ，但打印截断到给定深度的术语。</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">类似于 &lt;code&gt;lists:foldl/3&lt;/code&gt; ，但位于列表列表上方。</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">类似于 &lt;code&gt;lists:mapfoldl/3&lt;/code&gt; ，但位于列表列表上方。结果中的列表列表与给定的列表列表具有相同的结构。</target>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">类似于 &lt;code&gt;new_variable_name/1&lt;/code&gt; ，但生成 &lt;code&gt;N&lt;/code&gt; 个新名称的列表。</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">类似于 &lt;code&gt;new_variable_name/2&lt;/code&gt; ，但生成 &lt;code&gt;N&lt;/code&gt; 个新名称的列表。</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">与 &lt;code&gt;notempty&lt;/code&gt; 相似，除了允许在主题的开头以外的空字符串匹配之外。如果模式已锚定，则只有模式包含\ K时，才可以进行这种匹配。</target>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">类似于 &lt;code&gt;{inparallel, Tests}&lt;/code&gt; ，但同时运行不超过 &lt;code&gt;N&lt;/code&gt; 个子测试。</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">类似于 &lt;code&gt;{spawn, Tests}&lt;/code&gt; ，但是在给定的Erlang节点上运行指定的测试。</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">就像端口程序一样，端口与Erlang进程通信。所有通信都通过一个Erlang进程进行，该&lt;strong&gt;进程&lt;/strong&gt;是端口驱动程序的&lt;strong&gt;连接进程&lt;/strong&gt;。终止此过程将关闭端口驱动程序。</target>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">像大多数 &lt;code&gt;gen_&lt;/code&gt; 行为一样， &lt;code&gt;gen_statem&lt;/code&gt; 除了状态外还保留服务器 &lt;code&gt;Data&lt;/code&gt; 。因此，由于对状态数量（假设有足够的虚拟机内存）或不同输入事件的数量没有限制，因此具有此行为的状态机实际上是图灵完成的。但是，感觉就像是事件驱动的Mealy机器。</target>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">和sub/2一样,但不会将模板的结果转换为树。如果你想进行多个独立的替换,这很有用。</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; 的宏，但除非返回的状态值是生成异常 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">和上面一样,如果您必须保持与UTAR兼容,您还必须确保符号/硬链接的路径不超过100字节,否则将使用PAX头。</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">同样，可以从 &lt;code&gt;Mnesia&lt;/code&gt; 表中还原注册表：</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">限制：命令字符串 &lt;code&gt;Cmd&lt;/code&gt; 以ISO Latin-1或UTF-8编码的二进制格式发送到 &lt;code&gt;heart&lt;/code&gt; 程序，具体取决于模拟器的文件名编码模式（请参阅 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; ）。编码二进制文件的大小必须小于2047字节。</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">将 &lt;code&gt;run/3&lt;/code&gt; 限制为在第一个匹配位置进行匹配。如果模式编译时 &lt;code&gt;anchored&lt;/code&gt; ，或变成了凭借其内容被锚定，因此不能进行未锚定在匹配时，因此不存在 &lt;code&gt;unanchored&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">将语法树限制为指定的深度。用 &lt;code&gt;Node&lt;/code&gt; 替换给定 &lt;code&gt;Depth&lt;/code&gt; 处 &lt;code&gt;Tree&lt;/code&gt; 中的所有非叶子子树。如果 &lt;code&gt;Depth&lt;/code&gt; 为负，则即使 &lt;code&gt;Tree&lt;/code&gt; 没有子树，结果也始终是 &lt;code&gt;Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">以特定于实现的方式限制匹配的执行时间和内存消耗，与 &lt;code&gt;match_limit&lt;/code&gt; 非常相似。PCRE文档对此进行了如下描述：</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">以特定的实现方式限制匹配的执行时间。PCRE文件对其描述如下:</target>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">限制在Erlang运行时系统中为读操作优化的读/写锁所使用的读者组的数量。默认情况下,读取器组的限制是64个。</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">限制可以支持的同时请求数。默认值为 &lt;code&gt;150&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">限制HTTP请求URI的大小。默认值是没有限制。</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">限制HTTP请求的消息体的大小。默认值是没有限制。</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">限制HTTP请求的消息标头的大小。默认值是 &lt;code&gt;10240&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">限制客户在diffie-hellman-group-exchange中的要求。限制为 &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; ，其中 &lt;code&gt;MaxClient&lt;/code&gt; 和 &lt;code&gt;MinClient&lt;/code&gt; 是连接客户端建议的值。</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">第1行（用 &lt;code&gt;%% 1&lt;/code&gt; 注释标记）将 &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; 分配给 &lt;code&gt;Bin0&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">第2行是追加操作。由于 &lt;code&gt;Bin0&lt;/code&gt; 尚未参与追加操作，新的 &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; 被创建和内容 &lt;code&gt;Bin0&lt;/code&gt; 被复制到它。refc二进制文件的&lt;strong&gt;ProcBin&lt;/strong&gt;部分的大小设置为存储在二进制文件中的数据的大小，而二进制对象分配了额外的空间。二进制对象的大小是 &lt;code&gt;Bin1&lt;/code&gt; 或256 的大小的两倍，以较大者为准。在这种情况下为256。</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">第3行更有趣。 &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;已经&lt;/strong&gt;在附加操作中使用，并且它具有252个字节在末端未使用的存储空间，所以3个新字节被存储在那里。</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">第4行。这里也是如此。还剩249个字节,所以再存储3个字节没有问题。</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">第5行。在这里，发生了一些&lt;strong&gt;有趣的&lt;/strong&gt;事情。请注意，结果不追加到以前的结果 &lt;code&gt;Bin3&lt;/code&gt; ，但 &lt;code&gt;Bin1&lt;/code&gt; 。预期 &lt;code&gt;Bin4&lt;/code&gt; 赋值 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; 。还可以预期 &lt;code&gt;Bin3&lt;/code&gt; 将保留其值（ &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; ）。显然，运行时系统无法将字节 &lt;code&gt;17&lt;/code&gt; 写入二进制文件，因为这会将 &lt;code&gt;Bin3&lt;/code&gt; 的值更改为 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">线路供给</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">线路馈电(LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">线路输入(十六进制0A)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">分线器</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">包含注释的行根据使用的%字符数不同而缩进。</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">带有一个％字符的行在代码的右侧缩进。该列由变量 &lt;code&gt;comment-column&lt;/code&gt; 指定，默认情况下使用列48。</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">有三个以上%字符的行会缩进到左边的空白处。</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">有两个%字符的行将被缩进到与代码在相同情况下的深度。</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">Linked-in驱动涉及到用C语言编写一定的回调函数,这需要很好的技术,因为代码是和Erlang运行时系统链接的。</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">链接代码。</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">链接是双向的，两个进程之间只能有一个链接。重复调用 &lt;code&gt;link(Pid)&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">链接用于监视其他进程的行为，请参阅 &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">支持Linux(Aurora)。</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">支持Linux(黄狗)和OS X 10.4。</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (需要2.6.15-2054或更新的内核)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">支持UTRACE的Linux内核</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">支持Linux。</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">通过SystemTap兼容Linux。请参阅 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; 了解更多详细信息。</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">支持Linux。支持Fedora Core。支持32位和64位模式。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
