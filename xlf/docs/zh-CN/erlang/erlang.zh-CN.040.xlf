<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f15766776f9f8c25cf7a58ac94784f1f3ead7adc" translate="yes" xml:space="preserve">
          <source>The isolation property is in particular useful if the following circumstances occur where an employee (with employee number 123) and two processes (P1 and P2) are concurrently trying to raise the salary for the employee:</source>
          <target state="translated">如果出现以下情况,一个员工(员工编号为123)和两个进程(P1和P2)同时试图为该员工加薪,那么隔离属性就特别有用。</target>
        </trans-unit>
        <trans-unit id="284c773ace5ac2a66861a95faee4480ce7506813" translate="yes" xml:space="preserve">
          <source>The issuer id consists of the serial number and the issuers name.</source>
          <target state="translated">签发人ID由序列号和签发人名称组成。</target>
        </trans-unit>
        <trans-unit id="afc376918231468e613617267d35779bd5d5d659" translate="yes" xml:space="preserve">
          <source>The item was not present in the system at the point of failure.</source>
          <target state="translated">该项目在故障点时不在系统中。</target>
        </trans-unit>
        <trans-unit id="d57c675d8a8485a1824af8a77e5919d6b9669f2e" translate="yes" xml:space="preserve">
          <source>The items in this menu are used to create and delete breakpoints. For details, see section &lt;code&gt;&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此菜单中的项目用于创建和删除断点。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="481eae0056ff6c417a15e2d26dc9dfb9c5c8016d" translate="yes" xml:space="preserve">
          <source>The join is to be expressed as a guard filter. The filter must be placed immediately after the two joined generators, possibly after guard filters that use variables from no other generators but the two joined generators. The &lt;code&gt;qlc&lt;/code&gt; module inspects the operands of &lt;code&gt;=:=/2&lt;/code&gt;, &lt;code&gt;==/2&lt;/code&gt;, &lt;code&gt;is_record/2&lt;/code&gt;, &lt;code&gt;element/2&lt;/code&gt;, and logical operators (&lt;code&gt;and/2&lt;/code&gt;, &lt;code&gt;or/2&lt;/code&gt;, &lt;code&gt;andalso/2&lt;/code&gt;, &lt;code&gt;orelse/2&lt;/code&gt;, &lt;code&gt;xor/2&lt;/code&gt;) when determining which joins to consider.</source>
          <target state="translated">联接将表示为保护过滤器。过滤器必须紧接在两个联合生成器之后，可能放置在使用两个联合生成器之外的其他生成器变量的保护过滤器之后。所述 &lt;code&gt;qlc&lt;/code&gt; 模块检查的操作数 &lt;code&gt;=:=/2&lt;/code&gt; ， &lt;code&gt;==/2&lt;/code&gt; ， &lt;code&gt;is_record/2&lt;/code&gt; ， &lt;code&gt;element/2&lt;/code&gt; ，和逻辑运算符（ &lt;code&gt;and/2&lt;/code&gt; ， &lt;code&gt;or/2&lt;/code&gt; ， &lt;code&gt;andalso/2&lt;/code&gt; ， &lt;code&gt;orelse/2&lt;/code&gt; ， &lt;code&gt;xor/2&lt;/code&gt; ）确定要考虑的联接时。</target>
        </trans-unit>
        <trans-unit id="7998e0f8f473184cf8f66a20c879bd6d78ddaa4c" translate="yes" xml:space="preserve">
          <source>The keep_secrets functionality is disabled (&lt;code&gt;false&lt;/code&gt;) by default.</source>
          <target state="translated">默认情况下，keep_secrets功能处于禁用状态（ &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="90b36f2ace473010b2db9075b6ab6adecda8977a" translate="yes" xml:space="preserve">
          <source>The kernel supervisor has detected a failure, usually that the &lt;code&gt;application_controller&lt;/code&gt; has shut down (&lt;code&gt;Who&lt;/code&gt; = &lt;code&gt;application_controller&lt;/code&gt;, &lt;code&gt;Why&lt;/code&gt; = &lt;code&gt;shutdown&lt;/code&gt;). The application controller can have shut down for many reasons, the most usual is that the node name of the distributed Erlang node is already in use. A complete supervisor tree &quot;crash&quot; (that is, the top supervisors have exited) gives about the same result. This message comes from the Erlang code and not from the virtual machine itself. It is always because of some failure in an application, either within OTP or a &quot;user-written&quot; one. Looking at the error log for your application is probably the first step to take.</source>
          <target state="translated">内核管理程序已检测到故障，通常是 &lt;code&gt;application_controller&lt;/code&gt; 已关闭（ &lt;code&gt;Who&lt;/code&gt; = &lt;code&gt;application_controller&lt;/code&gt; ， &lt;code&gt;Why&lt;/code&gt; = &lt;code&gt;shutdown&lt;/code&gt; ）。应用程序控制器可能由于多种原因而关闭，最常见的原因是分布式Erlang节点的节点名称已在使用中。完整的主管树&amp;ldquo;崩溃&amp;rdquo;（即高级主管已退出）给出了相同的结果。此消息来自Erlang代码，而不是虚拟机本身。总是由于OTP或&amp;ldquo;用户编写&amp;rdquo;的应用程序中的某些故障。查看应用程序的错误日志可能是第一步。</target>
        </trans-unit>
        <trans-unit id="87cfd3cdc21e12ece215da1ff3c7bd0778edf3ae" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;mod&lt;/code&gt; defines the callback module and start argument of the application, in this case &lt;code&gt;ch_app&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, respectively. This means that the following is called when the application is to be started:</source>
          <target state="translated">密钥 &lt;code&gt;mod&lt;/code&gt; 定义了应用程序的回调模块和start参数，在本例中为 &lt;code&gt;ch_app&lt;/code&gt; 和 &lt;code&gt;[]&lt;/code&gt; 。这意味着在启动应用程序时将调用以下命令：</target>
        </trans-unit>
        <trans-unit id="63c37d9d912063a1a57159881898bac71cffe007" translate="yes" xml:space="preserve">
          <source>The key above can be written as &lt;code&gt;&quot;\\hklm\\software\\ericsson\\erlang\\5.0&quot;&lt;/code&gt;.</source>
          <target state="translated">上面的密钥可以写为 &lt;code&gt;&quot;\\hklm\\software\\ericsson\\erlang\\5.0&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4de5a958aeabffb38a49fbf124f00c275f5ea14" translate="yes" xml:space="preserve">
          <source>The key can be provided in the following two ways:</source>
          <target state="translated">钥匙可以通过以下两种方式提供。</target>
        </trans-unit>
        <trans-unit id="5045f02ba25dc74e0e6fe07e143c22ebb18972d2" translate="yes" xml:space="preserve">
          <source>The key files could be generated with OpenSSH's ssh-keygen command.</source>
          <target state="translated">密钥文件可以用OpenSSH的ssh-keygen命令生成。</target>
        </trans-unit>
        <trans-unit id="2e475f564fef24efe7c2edd2e65ff61b8004f591" translate="yes" xml:space="preserve">
          <source>The key position is obtained by calling &lt;code&gt;InfoFun(keypos)&lt;/code&gt; and the indexed positions by calling &lt;code&gt;InfoFun(indices)&lt;/code&gt;. If the key position can be used for lookup, it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions, the one occurring first in the list returned by &lt;code&gt;InfoFun&lt;/code&gt; is chosen. Positions requiring more than &lt;code&gt;&lt;a href=&quot;#max_lookup&quot;&gt;max_lookup&lt;/a&gt;&lt;/code&gt; lookups are ignored.</source>
          <target state="translated">关键位置是通过调用获得 &lt;code&gt;InfoFun(keypos)&lt;/code&gt; 通过调用和索引位置 &lt;code&gt;InfoFun(indices)&lt;/code&gt; 。如果关键位置可用于查找，则始终选择该位置，否则，选择需要最少查找次数的索引位置。如果两个索引位置之间有平局，则选择 &lt;code&gt;InfoFun&lt;/code&gt; 返回的列表中最先出现的那个。需要超过 &lt;code&gt;&lt;a href=&quot;#max_lookup&quot;&gt;max_lookup&lt;/a&gt;&lt;/code&gt; 查找的位置将被忽略。</target>
        </trans-unit>
        <trans-unit id="06c2324ad19db22f732f87371d50b783de7c2324" translate="yes" xml:space="preserve">
          <source>The key position.</source>
          <target state="translated">关键位置。</target>
        </trans-unit>
        <trans-unit id="a8b10ddac8355f7a246ab0ac12d610b134228817" translate="yes" xml:space="preserve">
          <source>The key's password</source>
          <target state="translated">钥匙的密码</target>
        </trans-unit>
        <trans-unit id="f88e9f9a4e85f1b89fcef9e232ae2c64409d89a5" translate="yes" xml:space="preserve">
          <source>The key-value pairs of a map have no defined iteration order. The only guarantee is that the iteration order of a single map instance is preserved during the lifetime of the environment that the map belongs to.</source>
          <target state="translated">地图的键值对没有确定的迭代顺序。唯一的保证是,在地图所属环境的生命周期内,单个地图实例的迭代顺序会得到保留。</target>
        </trans-unit>
        <trans-unit id="e64b8f95a5f079901b89db2a9fb2daa26e73a227" translate="yes" xml:space="preserve">
          <source>The keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; are optional in the supervisor flags map. If they are not given, they default to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;, respectively.</source>
          <target state="translated">键 &lt;code&gt;intensity&lt;/code&gt; 和 &lt;code&gt;period&lt;/code&gt; 在主管标志图中是可选的。如果未指定，则默认分别为 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a715eaeca461686c2d011a0989c495c1be24a00f" translate="yes" xml:space="preserve">
          <source>The keys and some other data are by default stored in files in the directory &lt;code&gt;.ssh&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">默认情况下，密钥和其他一些数据存储在用户主目录中 &lt;code&gt;.ssh&lt;/code&gt; 目录中的文件中。</target>
        </trans-unit>
        <trans-unit id="e270d4cb9c5a1f53027b9df8a800abde232726f8" translate="yes" xml:space="preserve">
          <source>The keys are by default stored in files:</source>
          <target state="translated">密钥默认存储在文件中。</target>
        </trans-unit>
        <trans-unit id="66af8fb8940dc217a32c86c117d958eb57768c52" translate="yes" xml:space="preserve">
          <source>The keys for the symmetric encryption are generated uniquely for each connection and are based on a secret negotiated in the TLS/DTLS handshake.</source>
          <target state="translated">对称加密的密钥是为每个连接唯一生成的,并基于在TLS/DTLS握手中协商的秘密。</target>
        </trans-unit>
        <trans-unit id="aff18d7af60baca2c26521c99fcf528391bc0c76" translate="yes" xml:space="preserve">
          <source>The label is intended to provide a brief summary of the event. It is preferred to use an atom but a string would also do.</source>
          <target state="translated">该标签旨在提供该事件的简要概述。最好使用原子,但也可使用字符串。</target>
        </trans-unit>
        <trans-unit id="edeb86123112824d83ee0303c271a4cb682dd647" translate="yes" xml:space="preserve">
          <source>The language setting in the operating system mainly affects the shell. The terminal (that is, the group leader) operates with &lt;code&gt;{encoding, unicode}&lt;/code&gt; only if the environment tells it that UTF-8 is allowed. This setting is to correspond to the terminal you are using.</source>
          <target state="translated">操作系统中的语言设置主要影响外壳。仅当环境告知它允许使用UTF-8时，终端（即组长）才使用 &lt;code&gt;{encoding, unicode}&lt;/code&gt; 进行操作。此设置对应于您所使用的终端。</target>
        </trans-unit>
        <trans-unit id="3d5867e4e848137cec6dd146c4e2783ad319840b" translate="yes" xml:space="preserve">
          <source>The last &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; that can be represented internally in the current Erlang runtime system instance. The time between the &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;start time&lt;/a&gt;&lt;/code&gt; and the end time is at least a quarter of a millennium.</source>
          <target state="translated">以 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 表示的最后一个 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; ，可以在当前Erlang运行时系统实例中内部表示。 &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;start time&lt;/a&gt;&lt;/code&gt; 和结束时间之间的时间至少为千年的四分之一。</target>
        </trans-unit>
        <trans-unit id="cbf7bc8595fbcb78ce027c719bffd4ff1c3073de" translate="yes" xml:space="preserve">
          <source>The last column is the internal column. When performing a &lt;code&gt;set&lt;/code&gt; operation, which creates a row, we must give a value to the internal column. The instrumentation functions will now look as follows:</source>
          <target state="translated">最后一列是内部列。在执行 &lt;code&gt;set&lt;/code&gt; 操作（创建一行）时，我们必须为内部列提供一个值。仪表功能现在将如下所示：</target>
        </trans-unit>
        <trans-unit id="184226eab517900aa5e104f77b408fc4703f673c" translate="yes" xml:space="preserve">
          <source>The last group in the specified path is the terminating group in the test, that is, no subgroups following this group are executed. In the previous example, &lt;code&gt;g4&lt;/code&gt; is the terminating group. Hence, &lt;code&gt;Common Test&lt;/code&gt; executes a test that calls all &lt;code&gt;init&lt;/code&gt; configuration functions in the path to &lt;code&gt;g4&lt;/code&gt;, that is, &lt;code&gt;g1..g3..g4&lt;/code&gt;. It then calls test cases &lt;code&gt;tc1&lt;/code&gt; and &lt;code&gt;tc5&lt;/code&gt; in &lt;code&gt;g4&lt;/code&gt;, and finally all &lt;code&gt;end&lt;/code&gt; configuration functions in order &lt;code&gt;g4..g3..g1&lt;/code&gt;.</source>
          <target state="translated">指定路径中的最后一个组是测试中的终止组，即，不执行此组之后的子组。在前面的示例中， &lt;code&gt;g4&lt;/code&gt; 是终止组。因此， &lt;code&gt;Common Test&lt;/code&gt; 执行一个测试，该测试调用 &lt;code&gt;g4&lt;/code&gt; 路径（即 &lt;code&gt;g1..g3..g4&lt;/code&gt; )中的所有 &lt;code&gt;init&lt;/code&gt; 配置函数。然后，它调用测试用例 &lt;code&gt;tc1&lt;/code&gt; 和 &lt;code&gt;tc5&lt;/code&gt; 在 &lt;code&gt;g4&lt;/code&gt; ，最后全部 &lt;code&gt;end&lt;/code&gt; ，以便配置功能 &lt;code&gt;g4..g3..g1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fa1840cc2c30d96ac21156af3e40270a8d80935" translate="yes" xml:space="preserve">
          <source>The last line is generated due to internal message passing in the Erlang shell. The process id's will vary.</source>
          <target state="translated">最后一行是由于Erlang shell的内部消息传递而产生的。进程的id会有所不同。</target>
        </trans-unit>
        <trans-unit id="e64b76cd01b4823944e2365efd79f7ca4112521f" translate="yes" xml:space="preserve">
          <source>The last part of the grammar file is an optional section with Erlang code (= function definitions) which is included 'as is' in the resulting parser file. This section must start with the pseudo declaration, or key words</source>
          <target state="translated">语法文件的最后一部分是包含Erlang代码(=函数定义)的可选部分,它被 &quot;原样 &quot;包含在生成的解析器文件中。这一部分必须以伪声明开始,或者说是关键词</target>
        </trans-unit>
        <trans-unit id="a6f5d3a54465773e89b4c8e688e662aaa9749ae4" translate="yes" xml:space="preserve">
          <source>The last step is to create boot scripts to make the protocol implementation available at boot time. The implementation can be debugged by starting the distribution when all the system is running, but in a real system the distribution is to start very early, why a boot script and some command-line parameters are necessary.</source>
          <target state="translated">最后一步是创建启动脚本,使协议的实现在启动时可用。当所有系统都在运行时,可以通过启动发行版来调试协议的实现,但在实际系统中,发行版是要很早启动的,因此需要一个启动脚本和一些命令行参数。</target>
        </trans-unit>
        <trans-unit id="45a35c1b9bd211b68b47957d2e49a6e71571d068" translate="yes" xml:space="preserve">
          <source>The last test to run is for system &lt;code&gt;t3&lt;/code&gt;. Here, all suites are skipped and this is explicitly noted in the log files.</source>
          <target state="translated">最后运行的测试是针对系统 &lt;code&gt;t3&lt;/code&gt; 的。在这里，所有套件都将被跳过，这在日志文件中已明确指出。</target>
        </trans-unit>
        <trans-unit id="8852e7914b224a1a777608407ab41bad01ca2077" translate="yes" xml:space="preserve">
          <source>The last time the file was read.</source>
          <target state="translated">最后一次读取文件的时间。</target>
        </trans-unit>
        <trans-unit id="791648c90deaadf98f3326f3b6bcff45e17be84e" translate="yes" xml:space="preserve">
          <source>The last time the file was written.</source>
          <target state="translated">最后一次写文件的时间。</target>
        </trans-unit>
        <trans-unit id="072e3449b89f599c8bc8ba1995b3f4a85ad87776" translate="yes" xml:space="preserve">
          <source>The latter example is equivalent to the former, which can be verified using function &lt;code&gt;qlc:info/1&lt;/code&gt;:</source>
          <target state="translated">后一个示例与前一个示例等效，可​​以使用功能 &lt;code&gt;qlc:info/1&lt;/code&gt; 进行验证：</target>
        </trans-unit>
        <trans-unit id="3ba708046f3a5ea5ae482709704f7c918ddacbf9" translate="yes" xml:space="preserve">
          <source>The latter functions are needed only when new config directives are to be introduced. For details, see &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">仅在引入新的配置指令时才需要使用后者的功能。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfe702a557aaf2b0af643fec45c2fbcc306adfbd" translate="yes" xml:space="preserve">
          <source>The latter specification says that the function takes some tuple and returns some tuple. The specification with the &lt;code&gt;X&lt;/code&gt; type variable specifies that the function takes a tuple and returns &lt;strong&gt;the same&lt;/strong&gt; tuple.</source>
          <target state="translated">后一个规范说该函数接受一些元组并返回一些元组。带有 &lt;code&gt;X&lt;/code&gt; 类型变量的规范指定该函数采用一个元组并返回&lt;strong&gt;相同的&lt;/strong&gt;元组。</target>
        </trans-unit>
        <trans-unit id="4e60740c974cd4ca31f6898f4c908ec03d194026" translate="yes" xml:space="preserve">
          <source>The least maximum packet size that the daemon will accept in channel open requests from the client. The default value is 0.</source>
          <target state="translated">守护进程将接受来自客户端的通道开放请求中的最小最大数据包大小。默认值为0。</target>
        </trans-unit>
        <trans-unit id="0dde3cfeba08df09564d97f09effbfe3c18694c1" translate="yes" xml:space="preserve">
          <source>The least significant bit in that half byte is flag &lt;code&gt;LongAtoms&lt;/code&gt;. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header.</source>
          <target state="translated">该半字节中的最低有效位是标志 &lt;code&gt;LongAtoms&lt;/code&gt; 。如果设置，原子长度将使用2个字节，而不是分配头中使用1个字节。</target>
        </trans-unit>
        <trans-unit id="10c687faf784f36e13b6f57d77f566d81227f644" translate="yes" xml:space="preserve">
          <source>The left associative arithmetic operators are evaluated left to right:</source>
          <target state="translated">左联算术运算符从左到右进行评价。</target>
        </trans-unit>
        <trans-unit id="16a5e87b76355a265a2acff30311f789fd728096" translate="yes" xml:space="preserve">
          <source>The left hand side is a non-terminal category. The right hand side is a sequence of one or more non-terminal or terminal symbols with spaces between. The associated code is a sequence of zero or more Erlang expressions (with commas &lt;code&gt;','&lt;/code&gt; as separators). If the associated code is empty, the separating colon &lt;code&gt;':'&lt;/code&gt; is also omitted. A final dot marks the end of the rule.</source>
          <target state="translated">左侧是非终端类别。右侧是一个或多个非终端符号或终端符号之间的序列。关联的代码是一个零个或多个Erlang表达式的序列（以逗号 &lt;code&gt;','&lt;/code&gt; 作为分隔符）。如果关联的代码为空，则也将省略分号 &lt;code&gt;':'&lt;/code&gt; 。最后一个点标志规则的结束。</target>
        </trans-unit>
        <trans-unit id="a5f3610313eb0cb79c27e16133bf4ee746007dd5" translate="yes" xml:space="preserve">
          <source>The left side of the arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) is a pattern. If the pattern matches, the matching instructions will be replaced by the instructions on the right side. Variables in a pattern must start with an uppercase letter just as in Erlang. A pattern variable may be followed &lt;code&gt;=&lt;/code&gt; and one or more type letters to constrain the match to one of those types. The variables that are bound on the left side can be used on the right side.</source>
          <target state="translated">箭头（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）的左侧是一个图案。如果模式匹配，则匹配的说明将被右侧的说明代替。就像在Erlang中一样，模式中的变量必须以大写字母开头。可以在 &lt;code&gt;=&lt;/code&gt; 和一个或多个类型字母后跟一个模式变量，以将匹配限制为这些类型之一。左侧绑定的变量可以在右侧使用。</target>
        </trans-unit>
        <trans-unit id="49288816f1b3f6cd05a6cce55bb9af9a3c8f9a7c" translate="yes" xml:space="preserve">
          <source>The legacy &lt;code&gt;Item = cipher_suite&lt;/code&gt; was removed in OTP-23. Previously it returned the cipher suite on its (undocumented) legacy format. It is replaced by &lt;code&gt;selected_cipher_suite&lt;/code&gt;.</source>
          <target state="translated">旧版 &lt;code&gt;Item = cipher_suite&lt;/code&gt; 已在OTP-23中删除。以前，它以（未记录的）旧格式返回密码套件。它由 &lt;code&gt;selected_cipher_suite&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="2d15c8b505512cf7ef5ed3725e558edb04ee8e3f" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; are still supported so old configurations will work.</source>
          <target state="translated">仍然支持旧变量和中间变量的 &lt;code&gt;address&lt;/code&gt; 和 &lt;code&gt;domain&lt;/code&gt; ，因此旧配置可以使用。</target>
        </trans-unit>
        <trans-unit id="0d5b31ada6fd921f21fd7ea3a8c8a6e7b646094e" translate="yes" xml:space="preserve">
          <source>The legacy and intermediate variables &lt;code&gt;intAgentIpAddress&lt;/code&gt; and &lt;code&gt;intAgentTransportDomain&lt;/code&gt; are still supported so old &lt;code&gt;agent.conf&lt;/code&gt; files will work.</source>
          <target state="translated">仍支持旧变量和中间变量 &lt;code&gt;intAgentIpAddress&lt;/code&gt; 和 &lt;code&gt;intAgentTransportDomain&lt;/code&gt; ，因此旧的 &lt;code&gt;agent.conf&lt;/code&gt; 文件将起作用。</target>
        </trans-unit>
        <trans-unit id="4544ea5bcba9a54bca20006006b59bdb9618fafb" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">原子 &lt;code&gt;t&lt;/code&gt; 的长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="7315fe138888586d2580dc24cb36b5eccee73131" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of binary object &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">二进制对象 &lt;code&gt;t&lt;/code&gt; 的长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="ddba0164da7862c7ff2f4f524f8c9cbb1852156f" translate="yes" xml:space="preserve">
          <source>The length (in bytes) of field &lt;code&gt;NodeName&lt;/code&gt;.</source>
          <target state="translated">字段 &lt;code&gt;NodeName&lt;/code&gt; 的长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="31080ac8eb9821d87bfa8097d8cf1b74183eeb9a" translate="yes" xml:space="preserve">
          <source>The length of a list with the first element &lt;code&gt;First&lt;/code&gt; and the remaining elements &lt;code&gt;Rest&lt;/code&gt; is 1 + the length of &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">具有第一个元素 &lt;code&gt;First&lt;/code&gt; 和其余元素 &lt;code&gt;Rest&lt;/code&gt; 的列表的长度是1 + &lt;code&gt;Rest&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="f96f13301619a2d2b302b2c22fb4b20b1a059059" translate="yes" xml:space="preserve">
          <source>The length of an empty list is obviously 0.</source>
          <target state="translated">空列表的长度显然是0。</target>
        </trans-unit>
        <trans-unit id="d1de7130de2bc092009b6447a54b5cc56f2e0ac6" translate="yes" xml:space="preserve">
          <source>The length of field &lt;code&gt;Extra&lt;/code&gt;.</source>
          <target state="translated">字段的长度 &lt;code&gt;Extra&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6031d07abc01be3ec4d2fad520f49b18ab9f57ce" translate="yes" xml:space="preserve">
          <source>The length of the message queue for the process.</source>
          <target state="translated">进程的消息队列长度。</target>
        </trans-unit>
        <trans-unit id="15fbacbdc36d9fa85ce6b119e70f9944e34bbef9" translate="yes" xml:space="preserve">
          <source>The library &lt;code&gt;ei&lt;/code&gt; contains macros and functions to encode and decode the Erlang binary term format.</source>
          <target state="translated">库 &lt;code&gt;ei&lt;/code&gt; 包含用于对Erlang二进制术语格式进行编码和解码的宏和函数。</target>
        </trans-unit>
        <trans-unit id="d1a396fcf8bb30c9c4e81871da3298d0c3af7de9" translate="yes" xml:space="preserve">
          <source>The library did not fulfill the requirements as a NIF library of the calling module.</source>
          <target state="translated">该库没有满足作为调用模块的NIF库的要求。</target>
        </trans-unit>
        <trans-unit id="4000d6b2656172da8f1ebb8bb8da55bc7e83a2fc" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;load&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;load&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt; if initialization is not needed.</source>
          <target state="translated">如果 &lt;code&gt;load&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; 以外的值，则库无法加载。如果不需要初始化，则 &lt;code&gt;load&lt;/code&gt; 可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7c36356b1ef653f4eb93e620c175a01deae68b6" translate="yes" xml:space="preserve">
          <source>The library fails to load if &lt;code&gt;upgrade&lt;/code&gt; returns anything other than &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;upgrade&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;upgrade&lt;/code&gt; 返回的值不是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;upgrade&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ,则库无法加载。</target>
        </trans-unit>
        <trans-unit id="7d68ce185719476197d42f3853f9b5b1affcf038" translate="yes" xml:space="preserve">
          <source>The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a &lt;code&gt;badarg&lt;/code&gt; exception is thrown from any of the functions in this module.</source>
          <target state="translated">该库处理面向字节的数据。对于不是二进制的位串（不包含位的整个八位字节），此模块中的任何函数都会抛出 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="58751b20a63ee8ce5dffe3bf1fdb22852c369253" translate="yes" xml:space="preserve">
          <source>The library initialization callbacks &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;upgrade&lt;/code&gt; are thread-safe even for shared state data.</source>
          <target state="translated">即使对于共享状态数据，库初始化回调的 &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;upgrade&lt;/code&gt; 也是线程安全的。</target>
        </trans-unit>
        <trans-unit id="525c752158ef80bf2ab4b174acb04d2294619c57" translate="yes" xml:space="preserve">
          <source>The library path  &lt;code id=&quot;code_path&quot;&gt;code_path&lt;/code&gt; is used by the functions &lt;code&gt;m/1&lt;/code&gt; and &lt;code&gt;d/1&lt;/code&gt;, but can also be set explicitly. Note however that the code path will be traversed once for each used &lt;code&gt;&lt;a href=&quot;#library_module&quot;&gt;library module&lt;/a&gt;&lt;/code&gt; while setting up module data. On the other hand, if there are only a few modules that are used but not analyzed, using &lt;code&gt;code_path&lt;/code&gt; may be faster than setting the library path to &lt;code&gt;code:get_path()&lt;/code&gt;.</source>
          <target state="translated">库路径 &lt;code id=&quot;code_path&quot;&gt;code_path&lt;/code&gt; 由 &lt;code&gt;m/1&lt;/code&gt; 和 &lt;code&gt;d/1&lt;/code&gt; 函数使用，但也可以显式设置。但是请注意，在设置模块数据时，将为每个使用的 &lt;code&gt;&lt;a href=&quot;#library_module&quot;&gt;library module&lt;/a&gt;&lt;/code&gt; 遍历一次代码路径。另一方面，如果仅使用了少数模块但未进行分析，则使用 &lt;code&gt;code_path&lt;/code&gt; 可能比将库路径设置为 &lt;code&gt;code:get_path()&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="72d5d28aae4fd1fc9e01fcb3c39ddb230755733d" translate="yes" xml:space="preserve">
          <source>The line and column where the token begins, or just the line if the column is unknown.</source>
          <target state="translated">标记开始的行和列,如果列未知,则只显示该行。</target>
        </trans-unit>
        <trans-unit id="dd717874ea3240b0b38b2c08672e875398395026" translate="yes" xml:space="preserve">
          <source>The line ends in &lt;code&gt;;&lt;/code&gt; (to avoid messing up the indentation in Emacs).</source>
          <target state="translated">该行的结尾处 &lt;code&gt;;&lt;/code&gt; （以避免弄乱Emacs中的缩进）。</target>
        </trans-unit>
        <trans-unit id="360684cf560fc66328b23d2a88ed263288ae0193" translate="yes" xml:space="preserve">
          <source>The line number where the token occurred.</source>
          <target state="translated">发生令牌的行号。</target>
        </trans-unit>
        <trans-unit id="32ef4a94e615116b5f15d93da06b8801c1438276" translate="yes" xml:space="preserve">
          <source>The line where the token begins.</source>
          <target state="translated">令牌开始的那一行。</target>
        </trans-unit>
        <trans-unit id="06982a696a56059b28dcc90e39b170a06c23c36e" translate="yes" xml:space="preserve">
          <source>The lines where functions are defined (more precisely: where the first clause begins) and the lines where functions are used are available in &lt;code&gt;functions&lt;/code&gt; mode. The line numbers refer to the files where the functions are defined. This holds also for files included with the &lt;code&gt;-include&lt;/code&gt; and &lt;code&gt;-include_lib&lt;/code&gt; directives, which may result in functions defined apparently in the same line. The &lt;strong&gt;line operators&lt;/strong&gt; are used for assigning line numbers to functions and for assigning sets of line numbers to function calls. The syntax is similar to the one of the cast operator:</source>
          <target state="translated">其中功能定义（更精确地：第一条开始的地方）的线和其中使用函数的线是可用的 &lt;code&gt;functions&lt;/code&gt; 模式。行号指的是定义功能的文件。这也适用于 &lt;code&gt;-include&lt;/code&gt; 和 &lt;code&gt;-include_lib&lt;/code&gt; 指令包含的文件，这可能导致函数显然在同一行中定义。在&lt;strong&gt;固网运营商&lt;/strong&gt;用于向功能分配行号和到函数调用分配组的行号。语法类似于强制转换运算符之一：</target>
        </trans-unit>
        <trans-unit id="d24fd42f9853b856c640811e28979dbf854c2b78" translate="yes" xml:space="preserve">
          <source>The lines where the external calls of the example before last are made.</source>
          <target state="translated">前面例子的外部调用的线路。</target>
        </trans-unit>
        <trans-unit id="d24fdb17e4fea5eb7628e12a6c79e2f53029142b" translate="yes" xml:space="preserve">
          <source>The lines where the local calls of the last example are made.</source>
          <target state="translated">上一例的本地通话的线路。</target>
        </trans-unit>
        <trans-unit id="f52c1d8ffe6f58fdcf01c3d2f4156580e6150699" translate="yes" xml:space="preserve">
          <source>The link will not be activated for the calling process until the spawn operation has succeeded. The link can not be removed before the operation has succeeded. An exit signal due to the link is guaranteed not to be delivered before a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; that corresponds to the spawn operation. If the spawn operation fails, no exit signal due to the link will be delivered to the caller of &lt;code&gt;spawn_request()&lt;/code&gt;.</source>
          <target state="translated">在生成操作成功之前，不会为调用过程激活链接。操作成功之前，无法删除链接。保证由于链接导致的退出信号不会在与派生操作相对应的 &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 之前传递。如果spawn操作失败，则不会由于链接而将退出信号传递给 &lt;code&gt;spawn_request()&lt;/code&gt; 的调用方。</target>
        </trans-unit>
        <trans-unit id="f2e317995e860f4cf19c85bed428103e5fa4c987" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;&lt;a href=&quot;xref#representation&quot;&gt;representation of graphs&lt;/a&gt;&lt;/code&gt; is used analyzing direct calls, while the &lt;code&gt;digraph&lt;/code&gt; representation is suited for analyzing indirect calls. The restriction operators (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;|||&lt;/code&gt;) are the only operators that accept both representations. This means that in order to analyze indirect calls using restriction, the &lt;code&gt;closure&lt;/code&gt; operator (which creates the &lt;code&gt;digraph&lt;/code&gt; representation of graphs) has to be applied explicitly.</source>
          <target state="translated">图的列表 &lt;code&gt;&lt;a href=&quot;xref#representation&quot;&gt;representation of graphs&lt;/a&gt;&lt;/code&gt; 用于分析直接调用，而 &lt;code&gt;digraph&lt;/code&gt; 表示法适合于分析间接调用。限制运算符（ &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;|||&lt;/code&gt; ）是唯一接受两种表示形式的运算符。这意味着，为了使用限制分析间接调用，必须显式应用 &lt;code&gt;closure&lt;/code&gt; 运算符（用于创建 &lt;code&gt;digraph&lt;/code&gt; 表示）。</target>
        </trans-unit>
        <trans-unit id="ffd5b9d0b2da7f031376ce2e3f4de1790dbcb873" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;Args&lt;/code&gt; no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is &lt;code&gt;'Argument__1'&lt;/code&gt;, the second &lt;code&gt;'Argument__2'&lt;/code&gt;, and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module.</source>
          <target state="translated">列表 &lt;code&gt;Args&lt;/code&gt; 不再包含自变量，而是与自变量数量相同的原子数。第一个原子是 &lt;code&gt;'Argument__1'&lt;/code&gt; ，第二个 &lt;code&gt;'Argument__2'&lt;/code&gt; ，依此类推。原因是参数列表可能浪费大量内存，并且如果参数列表包含很多乐趣，则可能无法升级模块代码。</target>
        </trans-unit>
        <trans-unit id="9fe5976fc2a1ed8cd95c6aebc522dfac26e44839" translate="yes" xml:space="preserve">
          <source>The list can also include any of the flags allowed in &lt;code&gt;erlang:trace/3&lt;/code&gt;</source>
          <target state="translated">该列表还可以包含 &lt;code&gt;erlang:trace/3&lt;/code&gt; 中允许的任何标志</target>
        </trans-unit>
        <trans-unit id="e6c4e4f178218163e196c4932cd2becb59369100" translate="yes" xml:space="preserve">
          <source>The list can be modified by all scheduler threads simultaneously. During modifications the double linked list is allowed to get a bit &quot;out of shape&quot;. For example, following the &lt;code&gt;next&lt;/code&gt; pointer to the next element and then following the &lt;code&gt;prev&lt;/code&gt; pointer does not always take you back to were you started. The following is however always true:</source>
          <target state="translated">可以由所有调度程序线程同时修改该列表。在修改过程中，允许双链表有些&amp;ldquo;变形&amp;rdquo;。例如，下面的 &lt;code&gt;next&lt;/code&gt; 指针指向下一个元素，然后之后的 &lt;code&gt;prev&lt;/code&gt; 指针并不总是把你带回了你开始。但是，以下情况始终正确：</target>
        </trans-unit>
        <trans-unit id="da6db7b25a7a041b2bd8a84f4bc3822e1da0eef8" translate="yes" xml:space="preserve">
          <source>The list can be retrieved with &lt;code&gt;&lt;a href=&quot;#env_compiler_options-0&quot;&gt;env_compiler_options/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#env_compiler_options-0&quot;&gt;env_compiler_options/0&lt;/a&gt;&lt;/code&gt; 检索该列表。</target>
        </trans-unit>
        <trans-unit id="9f867b0a6e2ade5a232d4c40764e78cd0cbf33e8" translate="yes" xml:space="preserve">
          <source>The list concatenation operator &lt;code&gt;++&lt;/code&gt; appends its second argument to its first and returns the resulting list.</source>
          <target state="translated">列表串联运算符 &lt;code&gt;++&lt;/code&gt; 将其第二个参数附加到其第一个参数，并返回结果列表。</target>
        </trans-unit>
        <trans-unit id="32f8386d87e909841366c0d0ccad694e85e74074" translate="yes" xml:space="preserve">
          <source>The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order if these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">该列表包含两个元组，其中 &lt;code&gt;Key&lt;/code&gt; 为第一个元素， &lt;code&gt;Value&lt;/code&gt; 为第二个元素。这些元组的顺序是不确定的。以下元组可以成为列表的一部分，但将来可以引入更多的元组：</target>
        </trans-unit>
        <trans-unit id="5bc5c462d98877bb9c514868bfdf3357046746f6" translate="yes" xml:space="preserve">
          <source>The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">该列表包含两个元组，其中 &lt;code&gt;Key&lt;/code&gt; 为第一个元素， &lt;code&gt;Value&lt;/code&gt; 为第二个元素。这些元组的顺序是不确定的。以下元组可以成为列表的一部分，但是将来可以引入更多的元组：</target>
        </trans-unit>
        <trans-unit id="9bdaf0305629367e99487e912564f15660d944d8" translate="yes" xml:space="preserve">
          <source>The list is appended to any options given to &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/2&lt;/a&gt;&lt;/code&gt;. Use the alternative functions &lt;code&gt;&lt;a href=&quot;#noenv_file-2&quot;&gt;noenv_file/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#noenv_forms-2&quot;&gt;noenv_forms/2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#noenv_output_generated-1&quot;&gt;noenv_output_generated/2&lt;/a&gt;&lt;/code&gt; if you do not want the environment variable to be consulted, for example, if you are calling the compiler recursively from inside a parse transform.</source>
          <target state="translated">该列表被附加到 &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#forms-2&quot;&gt;forms/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#output_generated-1&quot;&gt;output_generated/2&lt;/a&gt;&lt;/code&gt; 给出的任何选项上。如果不想查询环境变量，例如，如果要从解析转换内部递归调用编译器，请使用替代函数 &lt;code&gt;&lt;a href=&quot;#noenv_file-2&quot;&gt;noenv_file/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#noenv_forms-2&quot;&gt;noenv_forms/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#noenv_output_generated-1&quot;&gt;noenv_output_generated/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3b32daab7fb1e19913c070d23e0ea4b8468b157" translate="yes" xml:space="preserve">
          <source>The list of (visible) nodes currently connected to is returned by &lt;code&gt;nodes()&lt;/code&gt;.</source>
          <target state="translated">当前连接到的（可见）节点列表由 &lt;code&gt;nodes()&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="b60dab1d9d95dba89e1bcb54a37f2a68e4f7112c" translate="yes" xml:space="preserve">
          <source>The list of applications must contain the Kernel and STDLIB applications.</source>
          <target state="translated">应用程序列表必须包含Kernel和STDLIB应用程序。</target>
        </trans-unit>
        <trans-unit id="1993372f86c3ca2fcdaa4d4bdbaa44aa452f9b73" translate="yes" xml:space="preserve">
          <source>The list of arguments to the &lt;code&gt;init&lt;/code&gt; function of the callback module.</source>
          <target state="translated">回调模块的 &lt;code&gt;init&lt;/code&gt; 函数的参数列表。</target>
        </trans-unit>
        <trans-unit id="4a7dbd6dc14496e939ba002f5d8d58309bf69a66" translate="yes" xml:space="preserve">
          <source>The list of attributes becomes empty if the module is stripped with the &lt;code&gt;beam_lib(3)&lt;/code&gt; module (in STDLIB).</source>
          <target state="translated">如果使用 &lt;code&gt;beam_lib(3)&lt;/code&gt; 模块剥离模块（在STDLIB中），则属性列表将为空。</target>
        </trans-unit>
        <trans-unit id="9e28c0b378c7e30234825e4c28e09987fea8b7d5" translate="yes" xml:space="preserve">
          <source>The list of attributes is sorted on &lt;code&gt;Attribute&lt;/code&gt; (in &lt;code&gt;attrib_entry()&lt;/code&gt;) and each attribute name occurs once in the list. The attribute values occur in the same order as in the file. The lists of functions are also sorted.</source>
          <target state="translated">属性列表按 &lt;code&gt;Attribute&lt;/code&gt; （在 &lt;code&gt;attrib_entry()&lt;/code&gt; 中）排序，并且每个属性名称在列表中出现一次。属性值的出现顺序与文件中的顺序相同。功能列表也进行了排序。</target>
        </trans-unit>
        <trans-unit id="2ab8914ad054b49e90cc2dd0c7617689deb0ec65" translate="yes" xml:space="preserve">
          <source>The list of binaries used for search alternatives must be flat and proper.</source>
          <target state="translated">用于搜索替代物的二进制列表必须是平坦和适当的。</target>
        </trans-unit>
        <trans-unit id="4aa24e9ead310fa857b3ae54bebbc5e4c77a275b" translate="yes" xml:space="preserve">
          <source>The list of column names is ordered in the same way as the list of values of a row, e.g. the first &lt;code&gt;ColName&lt;/code&gt; is associated with the first &lt;code&gt;Value&lt;/code&gt; in a &lt;code&gt;Row&lt;/code&gt;.</source>
          <target state="translated">列名的列表以同样的方式作为行的值列表，例如，第一是有序 &lt;code&gt;ColName&lt;/code&gt; 与第一相关 &lt;code&gt;Value&lt;/code&gt; 的 &lt;code&gt;Row&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e441bd917def7eab6debc68f650fc15899ecb1b8" translate="yes" xml:space="preserve">
          <source>The list of examples can be made long. One need a kind of knowledge that was not needed when programs only considered one or two languages. The complexity of human languages and scripts has certainly made this a challenge when constructing a universal standard. Supporting Unicode properly in your program will require effort.</source>
          <target state="translated">例子的清单可以做得很长。我们需要一种知识,而这种知识在程序只考虑一种或两种语言时是不需要的。人类语言和脚本的复杂性无疑使构建通用标准时面临挑战。在你的程序中正确地支持Unicode需要付出努力。</target>
        </trans-unit>
        <trans-unit id="e9263bcdcc9a4162758b1c2d0636a8277b41c8e1" translate="yes" xml:space="preserve">
          <source>The list of protocols is in order of preference. The protocol negotiated will be the first in the list that matches one of the protocols advertised by the client. If no protocol matches, the server will fail the connection with a &quot;no_application_protocol&quot; alert.</source>
          <target state="translated">协议列表是按优先顺序排列的。协商好的协议将是列表中第一个与客户端公布的协议匹配的协议。如果没有匹配的协议,服务器将以 &quot;no_application_protocol &quot;警告失败连接。</target>
        </trans-unit>
        <trans-unit id="4a34fbb4766ea85a1f9d8f22cb9859cc99bb888c" translate="yes" xml:space="preserve">
          <source>The list of protocols must not contain an empty binary.</source>
          <target state="translated">协议列表不得包含一个空的二进制。</target>
        </trans-unit>
        <trans-unit id="c9fbf59d4843615920d8035868251705ea8faee6" translate="yes" xml:space="preserve">
          <source>The list of protocols supported by the client to be sent to the server to be used for an Application-Layer Protocol Negotiation (ALPN). If the server supports ALPN then it will choose a protocol from this list; otherwise it will fail the connection with a &quot;no_application_protocol&quot; alert. A server that does not support ALPN will ignore this value.</source>
          <target state="translated">客户端支持的协议列表,发送给服务器用于应用层协议协商(ALPN)。如果服务器支持ALPN,那么它将从这个列表中选择一个协议;否则它将以 &quot;no_application_protocol &quot;的警告来终止连接。不支持ALPN的服务器将忽略这个值。</target>
        </trans-unit>
        <trans-unit id="d7ac87c7d4335021ee1fa77bdee81b3d2fc28da7" translate="yes" xml:space="preserve">
          <source>The list of scheduler information is unsorted and can appear in different order between calls.</source>
          <target state="translated">调度器信息列表是不排序的,在调用之间可以以不同的顺序出现。</target>
        </trans-unit>
        <trans-unit id="53177127ac53807caaec1a5f4ac0ff7d969ee202" translate="yes" xml:space="preserve">
          <source>The list of thread information is unsorted and can appear in different order between calls.</source>
          <target state="translated">线程信息列表是不排序的,在不同的调用之间可以以不同的顺序出现。</target>
        </trans-unit>
        <trans-unit id="2f6ff9051ce3adf391b324c7141d157fd50f0f8f" translate="yes" xml:space="preserve">
          <source>The list structure is invalid (a number as tail).</source>
          <target state="translated">列表结构无效(以数字为尾)。</target>
        </trans-unit>
        <trans-unit id="90359ff88196faa6388683deff22b771581b0f36" translate="yes" xml:space="preserve">
          <source>The list subtraction operator &lt;code&gt;--&lt;/code&gt; produces a list that is a copy of the first argument. The procedure is a follows: for each element in the second argument, the first occurrence of this element (if any) is removed.</source>
          <target state="translated">列表减法运算符 &lt;code&gt;--&lt;/code&gt; 产生一个列表，该列表是第一个参数的副本。该过程如下：对于第二个参数中的每个元素，将删除该元素的第一次出现（如果有）。</target>
        </trans-unit>
        <trans-unit id="015b99d661bab28e17445e0783bc50c17f9fd517" translate="yes" xml:space="preserve">
          <source>The listed applications are not only original Erlang/OTP applications but possibly also new applications that you have written (here exemplified by the application Pea (&lt;code&gt;pea&lt;/code&gt;)).</source>
          <target state="translated">列出的应用程序不仅是原始的Erlang / OTP应用程序，而且还可能是您编写的新应用程序（在这里以应用程序Pea（ &lt;code&gt;pea&lt;/code&gt; ）为例）。</target>
        </trans-unit>
        <trans-unit id="b1a6d7b7d2505dd4415caa1c747f640e87d05200" translate="yes" xml:space="preserve">
          <source>The listing shows &lt;code&gt;mnesia_locker&lt;/code&gt;, a process, has highly contended locks.</source>
          <target state="translated">清单显示了 &lt;code&gt;mnesia_locker&lt;/code&gt; 这个进程具有高度竞争的锁。</target>
        </trans-unit>
        <trans-unit id="7824d7fdf06f507845f19aac3e93cad24e62691c" translate="yes" xml:space="preserve">
          <source>The lists are (named as in the SSH application's options):</source>
          <target state="translated">这些列表是(在SSH应用程序的选项中命名)。</target>
        </trans-unit>
        <trans-unit id="e47f7860f16d8f455b34192361d141ea74928549" translate="yes" xml:space="preserve">
          <source>The literal character &quot;]&quot; cannot be the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if &quot;]&quot; is escaped with a backslash, it is interpreted as the end of range, so [W-\]46] is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range.</source>
          <target state="translated">字符&quot;]&quot;不能作为一个范围的结束符。像[W-]46]这样的模式被解释为两个字符(&quot;W &quot;和&quot;-&quot;)的类别,后面是一个字面字符串 &quot;46]&quot;,所以它将与 &quot;W46]&quot;或&quot;-46]&quot;匹配。但是,如果用反斜杠转义&quot;]&quot;,则被解释为范围的结束,所以[W-/\]46]被解释为包含一个范围的类,后面跟着另外两个字符。八进制或十六进制表示的&quot;]&quot;也可以用来结束一个范围。</target>
        </trans-unit>
        <trans-unit id="22d69bddbebc6f4d77e88a7b45adec0c593cecc4" translate="yes" xml:space="preserve">
          <source>The load balancing functionality is triggered at repeated fixed intervals. The load balancing more or less strives to even out run queue lengths over the system. When balancing is triggered, information about every run queue is gathered, migrations paths and run queue length limits are set up. Migration paths and limits are fixed until the next balancing has been done. The most important information about each run queue is the maximum run queue length since last balancing. All of this information were previously stored in the run queues themselves.</source>
          <target state="translated">负载均衡功能是以反复固定的时间间隔触发的。负载均衡或多或少会努力使系统中的运行队列长度趋于均匀。当平衡被触发时,会收集每个运行队列的信息,设置迁移路径和运行队列长度限制。迁移路径和限制是固定的,直到下一次平衡完成。每个运行队列最重要的信息是上次平衡以来的最大运行队列长度。所有这些信息之前都存储在运行队列本身中。</target>
        </trans-unit>
        <trans-unit id="7a151d7c8c495b43d8c9ca28cb4fd22e5563c1c3" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded (open ports use it). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;mostly&lt;/strong&gt; occurs when options &lt;code&gt;{reload,pending_driver}&lt;/code&gt; or &lt;code&gt;{reload,pending}&lt;/code&gt; are used, but &lt;strong&gt;can&lt;/strong&gt; occur when another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is unloading a driver in parallel and driver option &lt;code&gt;kill_ports&lt;/code&gt; is set. In other words, this return value always needs to be handled.</source>
          <target state="translated">加载请求已注册，但是加载被延迟，因为驱动程序的较早实例仍在等待卸载（开放端口使用它）。尽管如此，在完成驱动程序后仍需要卸载。此返回值&lt;strong&gt;通常&lt;/strong&gt;在使用选项 &lt;code&gt;{reload,pending_driver}&lt;/code&gt; 或 &lt;code&gt;{reload,pending}&lt;/code&gt; 时发生，但在另一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 并行卸载驱动程序并设置了驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 时，&lt;strong&gt;可能&lt;/strong&gt;会出现此返回值。换句话说，始终需要处理此返回值。</target>
        </trans-unit>
        <trans-unit id="93816305e042fa9b1290121579e7bab7986a2b27" translate="yes" xml:space="preserve">
          <source>The load request is registered, but the loading is delayed because an earlier instance of the driver is still waiting to get unloaded by another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (not only by a port, in which case &lt;code&gt;{ok,pending_driver}&lt;/code&gt; would have been returned). Still, unload is expected when you are done with the driver. This return value &lt;strong&gt;only&lt;/strong&gt; occurs when option &lt;code&gt;{reload,pending}&lt;/code&gt; is used.</source>
          <target state="translated">加载请求已注册，但是加载被延迟了，因为驱动程序的较早实例仍在等待其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 卸载（不仅是通过端口，在这种情况下 &lt;code&gt;{ok,pending_driver}&lt;/code&gt; 将返回{ok，pending_driver}）。尽管如此，在完成驱动程序后仍需要卸载。&lt;strong&gt;仅&lt;/strong&gt;当使用选项 &lt;code&gt;{reload,pending}&lt;/code&gt; 时，此返回值&lt;strong&gt;才会&lt;/strong&gt;出现。</target>
        </trans-unit>
        <trans-unit id="82d30f913008685e194b4636bf5269a0b248f283" translate="yes" xml:space="preserve">
          <source>The load values are proportional to how long time a runnable Unix process has to spend in the run queue before it is scheduled. Accordingly, higher values mean more system load. The returned value divided by 256 produces the figure displayed by &lt;code&gt;rup&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt;. What is displayed as 2.00 in &lt;code&gt;rup&lt;/code&gt;, is displayed as load up to the second mark in &lt;code&gt;xload&lt;/code&gt;.</source>
          <target state="translated">负载值与可运行的Unix进程在调度之前必须在运行队列中花费的时间成比例。因此，较高的值意味着更多的系统负载。返回值除以256会生成由 &lt;code&gt;rup&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 显示的数字。显示为2.00 &lt;code&gt;rup&lt;/code&gt; ，显示为加载到 &lt;code&gt;xload&lt;/code&gt; 中的第二个标记。</target>
        </trans-unit>
        <trans-unit id="a895d99596ae4fec168069b6d71a4c5ac6061486" translate="yes" xml:space="preserve">
          <source>The loader reads and decodes one instruction at a time from the BEAM code and creates a generic instruction. Many transformation rules must look at multiple instructions, so the loader will keep multiple generic instructions in a linked list.</source>
          <target state="translated">装载器每次从BEAM代码中读取和解码一条指令,并创建一条通用指令。许多转换规则必须查看多条指令,所以加载器会将多条通用指令保存在一个链接列表中。</target>
        </trans-unit>
        <trans-unit id="3898db6a5e9bf7e942d14850978ee9647119b33c" translate="yes" xml:space="preserve">
          <source>The loader runs the packing engine to pack multiple operands into a single word. The packing engine is controlled by a small program, which is a string where each character is an instruction. For example, the code to pack the operands for &lt;code&gt;move_xy&lt;/code&gt; is &lt;code&gt;&quot;22#&quot;&lt;/code&gt; (on a 64-bit machine). That program will pack the byte offsets for both registers into the same word as the pointer to C code.</source>
          <target state="translated">加载程序运行打包引擎，将多个操作数打包到一个单词中。打包引擎由一个小程序控制，该程序是一个字符串，其中每个字符都是一条指令。例如，包装 &lt;code&gt;move_xy&lt;/code&gt; 操作数的代码是 &lt;code&gt;&quot;22#&quot;&lt;/code&gt; （在64位计算机上）。该程序会将两个寄存器的字节偏移量打包到与C代码指针相同的字中。</target>
        </trans-unit>
        <trans-unit id="1636e7c78e617f12c2486272c7556c4aa503ae74" translate="yes" xml:space="preserve">
          <source>The loader translates each operand to a machine word and stores it in the code area. The operand type for the selected specific instruction guides the translation. For example, if the type is &lt;code&gt;e&lt;/code&gt;, the value of the operand is an index into an arry of external functions and will be translated to a pointer to the export entry for the function to call. If the type is &lt;code&gt;x&lt;/code&gt;, the number of the X register will be multiplied by the word size to produce a byte offset.</source>
          <target state="translated">加载程序将每个操作数转换为一个机器字，并将其存储在代码区中。所选特定指令的操作数类型指导翻译。例如，如果类型为 &lt;code&gt;e&lt;/code&gt; ，则操作数的值是指向外部函数的索引，并且将其转换为指向导出入口的指针，以供函数调用。如果类型为 &lt;code&gt;x&lt;/code&gt; ，则X寄存器的数量将乘以字长，以产生字节偏移量。</target>
        </trans-unit>
        <trans-unit id="3294a5460ea176dd8b509e858541bce0c6bcbfaa" translate="yes" xml:space="preserve">
          <source>The loader tries to apply transformation rules against the generic instructions in the linked list. If a rule matches, the matched instructions will be removed and replaced with new generic instructions constructed from the right side of the transformation.</source>
          <target state="translated">装载器尝试针对链接列表中的通用指令应用转换规则。如果规则匹配,则匹配的指令将被删除,并被从转换的右侧构造的新通用指令所取代。</target>
        </trans-unit>
        <trans-unit id="3ce1aa5ed5bc9f754c6c81a17bb279f4b22f83b7" translate="yes" xml:space="preserve">
          <source>The loader will convert a &lt;code&gt;{list,[...]}&lt;/code&gt; operand to an &lt;code&gt;u&lt;/code&gt; operand whose value is the number of elements in the list, followed by each element in the list. The instruction above would be translated to the following generic instruction:</source>
          <target state="translated">加载程序会将 &lt;code&gt;{list,[...]}&lt;/code&gt; 操作数转换为 &lt;code&gt;u&lt;/code&gt; 操作数，其值是列表中元素的数量，后跟列表中的每个元素。上面的指令将转换为以下通用指令：</target>
        </trans-unit>
        <trans-unit id="a41ef282bdfc20a96cb41104793bfac46092c327" translate="yes" xml:space="preserve">
          <source>The loader would swap the operands forever. To avoid the loop, we must rename the instruction. For example:</source>
          <target state="translated">载入器将永远交换操作数。为了避免循环,我们必须重新命名指令。例如:</target>
        </trans-unit>
        <trans-unit id="6581196701c6f827b4369629a09fe0551406c81d" translate="yes" xml:space="preserve">
          <source>The loading of a module is divided into two phases; a &lt;strong&gt;prepare phase&lt;/strong&gt; and a &lt;strong&gt;finishing phase&lt;/strong&gt;. The prepare phase contains reading the BEAM file format and all the preparations of the loaded code that can easily be done without interference with the running code. The finishing phase will make the loaded (and prepared) code accessible from the running code. Old module versions (replaced or deleted) will also be made inaccessible by the finishing phase.</source>
          <target state="translated">模块的加载分为两个阶段：一个&lt;strong&gt;准备阶段&lt;/strong&gt;和&lt;strong&gt;结束阶段&lt;/strong&gt;。准备阶段包括读取BEAM文件格式和已加载代码的所有准备工作，这些工作可以很容易地完成而不会干扰正在运行的代码。完成阶段将使正在运行的代码可以访问已加载（和准备好的）代码。在完成阶段，也将无法访问旧模块版本（被替换或删除）。</target>
        </trans-unit>
        <trans-unit id="e778b9f1baa2ba78c9a8b99dac7d82d4dd62545a" translate="yes" xml:space="preserve">
          <source>The local address of the socket.</source>
          <target state="translated">套接字的本地地址。</target>
        </trans-unit>
        <trans-unit id="2cbe8d9027d2e67a3221c97411a93a55c403aba2" translate="yes" xml:space="preserve">
          <source>The local hostname.</source>
          <target state="translated">本地主机名。</target>
        </trans-unit>
        <trans-unit id="0d70c0c380895bb03a1a2bbd03acd9232797565f" translate="yes" xml:space="preserve">
          <source>The local mid (of the connection, i.e. the own mid). &lt;code&gt;megaco_mid()&lt;/code&gt;.</source>
          <target state="translated">本地中间（连接的中间，即自己的中间）。 &lt;code&gt;megaco_mid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ca9eb8c2f734b6ef1d76976ee366124ff598fcc" translate="yes" xml:space="preserve">
          <source>The local node is not alive.</source>
          <target state="translated">本地节点不存在。</target>
        </trans-unit>
        <trans-unit id="9da45befb57e0a6e8d60cb2a231a07186dafa5dc" translate="yes" xml:space="preserve">
          <source>The local process was monitoring the remote process at the time of the crash.</source>
          <target state="translated">崩溃时,本地进程正在监控远程进程。</target>
        </trans-unit>
        <trans-unit id="0faaeec49d245a46502b8c7536db4c7e2f24fafe" translate="yes" xml:space="preserve">
          <source>The location of the Erlang emulator. The default is the &lt;code&gt;erl.exe&lt;/code&gt; located in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. Do not specify &lt;code&gt;werl.exe&lt;/code&gt; as this emulator, it will not work.</source>
          <target state="translated">Erlang仿真器的位置。默认值是 &lt;code&gt;erl.exe&lt;/code&gt; 位于同一目录中 &lt;code&gt;erlsrv.exe&lt;/code&gt; 。不要将 &lt;code&gt;werl.exe&lt;/code&gt; 指定为该模拟器，它将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="94ca339fcbea0bf957948c562687f39b4e2a7718" translate="yes" xml:space="preserve">
          <source>The location of the file &lt;code&gt;start_erl.data&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;start_erl.data&lt;/code&gt; 的位置</target>
        </trans-unit>
        <trans-unit id="67a812bb246705dde14edb442f878d3a06f58d28" translate="yes" xml:space="preserve">
          <source>The lock is acquired on &lt;code&gt;LockItem&lt;/code&gt; on all nodes in the node list.</source>
          <target state="translated">在节点列表中所有节点上的 &lt;code&gt;LockItem&lt;/code&gt; 上获取锁定。</target>
        </trans-unit>
        <trans-unit id="d1c1720c2d219fd54fa11d813133b968889b2d05" translate="yes" xml:space="preserve">
          <source>The log archives are named &lt;code&gt;FileName.0&lt;/code&gt;, &lt;code&gt;FileName.1&lt;/code&gt;, ... &lt;code&gt;FileName.N&lt;/code&gt;, where &lt;code&gt;FileName&lt;/code&gt; is the name of the current log file. &lt;code&gt;FileName.0&lt;/code&gt; is the newest of the archives. The maximum value for &lt;code&gt;N&lt;/code&gt; is the value of &lt;code&gt;max_no_files&lt;/code&gt; minus 1.</source>
          <target state="translated">日志归档文件名为 &lt;code&gt;FileName.0&lt;/code&gt; ， &lt;code&gt;FileName.1&lt;/code&gt; ，... &lt;code&gt;FileName.N&lt;/code&gt; ，其中 &lt;code&gt;FileName&lt;/code&gt; 是当前日志文件的名称。 &lt;code&gt;FileName.0&lt;/code&gt; 是最新的档案。为最大值 &lt;code&gt;N&lt;/code&gt; 是的值 &lt;code&gt;max_no_files&lt;/code&gt; 减1。</target>
        </trans-unit>
        <trans-unit id="fb95c03b38e9e250b3764b1b69a94cf910fd3f1f" translate="yes" xml:space="preserve">
          <source>The log can be either a &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; or a &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">日志可以是 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8084a2197c0ae9cceee71abbb7d30557e1d027d1" translate="yes" xml:space="preserve">
          <source>The log event used in the examples is:</source>
          <target state="translated">例子中使用的日志事件是:</target>
        </trans-unit>
        <trans-unit id="c59a13290ca648d96e5d3e746b0a0a2f930b73d8" translate="yes" xml:space="preserve">
          <source>The log events are handled using a &lt;code&gt;Logger&lt;/code&gt; handler called cth_log_redirect. The formatting and level is copied from the current &lt;code&gt;default&lt;/code&gt; handler when the cth is started. If you want to use another level either change the &lt;code&gt;default&lt;/code&gt; handler level before starting common_test, or use the &lt;code&gt; logger:set_handler_config/3&lt;/code&gt; API.</source>
          <target state="translated">日志事件使用称为cth_log_redirect的 &lt;code&gt;Logger&lt;/code&gt; 处理程序进行处理。启动cth时，将从当前的 &lt;code&gt;default&lt;/code&gt; 处理程序复制格式和级别。如果要使用其他级别，请在启动common_test之前更改 &lt;code&gt;default&lt;/code&gt; 处理程序级别，或者使用 &lt;code&gt; logger:set_handler_config/3&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="33cf2a0cd54fceab0e5adde86b3ea4f3d0186889" translate="yes" xml:space="preserve">
          <source>The log file grows continuously and must be dumped at regular intervals. &quot;Dumping the log file&quot; means that &lt;code&gt;Mnesia&lt;/code&gt; performs all the operations listed in the log and place the records in the corresponding &lt;code&gt;.DAT&lt;/code&gt;, &lt;code&gt;.DCD&lt;/code&gt;, and &lt;code&gt;.DCL&lt;/code&gt; data files. For example, if the operation &quot;write record &lt;code&gt;{foo, 4, elvis, 6}&lt;/code&gt;&quot; is listed in the log, &lt;code&gt;Mnesia&lt;/code&gt; inserts the operation into the file &lt;code&gt;foo.DCL&lt;/code&gt;. Later, when &lt;code&gt;Mnesia&lt;/code&gt; thinks that the &lt;code&gt;.DCL&lt;/code&gt; file is too large, the data is moved to the &lt;code&gt;.DCD&lt;/code&gt; file. The dumping operation can be time consuming if the log is large. Notice that the &lt;code&gt;Mnesia&lt;/code&gt; system continues to operate during log dumps.</source>
          <target state="translated">日志文件不断增长，必须定期转储。 &amp;ldquo;转储日志文件&amp;rdquo;意味着 &lt;code&gt;Mnesia&lt;/code&gt; 将执行日志中列出的所有操作，并将记录放入相应的 &lt;code&gt;.DAT&lt;/code&gt; ， &lt;code&gt;.DCD&lt;/code&gt; 和 &lt;code&gt;.DCL&lt;/code&gt; 数据文件中。例如，如果日志中列出了&amp;ldquo;写记录 &lt;code&gt;{foo, 4, elvis, 6}&lt;/code&gt; &amp;rdquo; 操作，则 &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;foo.DCL&lt;/code&gt; 操作插入文件foo.DCL中。以后，当 &lt;code&gt;Mnesia&lt;/code&gt; 认为 &lt;code&gt;.DCL&lt;/code&gt; 文件太大时，数据将移至 &lt;code&gt;.DCD&lt;/code&gt; 文件。如果日志很大，转储操作可能很耗时。请注意， &lt;code&gt;Mnesia&lt;/code&gt; 系统在日志转储期间继续运行。</target>
        </trans-unit>
        <trans-unit id="05378e99ad67de335df2edd4587676257847240f" translate="yes" xml:space="preserve">
          <source>The log files are written continuously during a test run and links are always created initially when a test starts. Thevtest progress can therefore be followed simply by refreshing pages in the HTML browser. Statistics totals are not presented until a test is complete however.</source>
          <target state="translated">日志文件在测试运行过程中不断被写入,并且在测试开始时总是先创建链接。因此,只需在HTML浏览器中刷新页面,就可以跟踪测试进度。然而,统计总数在测试结束前不会显示。</target>
        </trans-unit>
        <trans-unit id="09d8292095f3c463951aa3a38fcb81bdb1a77b22" translate="yes" xml:space="preserve">
          <source>The log files, that is:</source>
          <target state="translated">日志文件,就是。</target>
        </trans-unit>
        <trans-unit id="5dbdf4f4a2f484ace5b99188170053805f051195" translate="yes" xml:space="preserve">
          <source>The log function takes three arguments, &lt;code&gt;fun(Level, FormatString, [FormatArg]) end&lt;/code&gt;.</source>
          <target state="translated">log函数采用三个参数， &lt;code&gt;fun(Level, FormatString, [FormatArg]) end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70e83f6de81bba1e8369d3fb4c74e2e701680bf9" translate="yes" xml:space="preserve">
          <source>The log is also dumped at startup and whenever a schema operation is performed.</source>
          <target state="translated">在启动时和每当执行模式操作时,日志也会被转储。</target>
        </trans-unit>
        <trans-unit id="3e63f405b602b189c562910f99bbf0f61b97eb9a" translate="yes" xml:space="preserve">
          <source>The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">日志级别可以更改为错误或信息，请参阅 &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52f3c1c01d0caa39ade0e63e03754a32f5ea8746" translate="yes" xml:space="preserve">
          <source>The log level for a module overrides the primary log level of Logger for log events originating from the module in question. Notice, however, that it does not override the level configuration for any handler.</source>
          <target state="translated">模块的日志级别会覆盖Logger的主日志级别,用于处理来自相关模块的日志事件。但是,请注意,它不会覆盖任何处理程序的级别配置。</target>
        </trans-unit>
        <trans-unit id="5ef6ed5dbe5f350a3677cd9b499598f99164de3e" translate="yes" xml:space="preserve">
          <source>The log level indicates the severity of a event. In accordance with the Syslog protocol, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5424.txt&quot;&gt;RFC 5424&lt;/a&gt;&lt;/code&gt;, eight log levels can be specified. The following table lists all possible log levels by name (atom), integer value, and description:</source>
          <target state="translated">日志级别指示事件的严重性。根据Syslog协议 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5424.txt&quot;&gt;RFC 5424&lt;/a&gt;&lt;/code&gt; ，可以指定八个日志级别。下表按名称（原子），整数值和描述列出了所有可能的日志级别：</target>
        </trans-unit>
        <trans-unit id="61474d540d4f938d40a8057dde050564bb9fee18" translate="yes" xml:space="preserve">
          <source>The log level is specified when adding the handler, or changed during runtime with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">日志级别是在添加处理程序时指定的，或者在运行时使用 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="1fc6320a2d9c1fb41416707d45873416f2a21be8" translate="yes" xml:space="preserve">
          <source>The log level is specified when adding the handler, or changed during runtime with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">日志级别是在添加处理程序时指定的，或者在运行时通过 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,level,Level)&lt;/a&gt;&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="21c56bbe5854873ac255ff079279c9dff663d1fe" translate="yes" xml:space="preserve">
          <source>The log message can also be provided through a fun for lazy evaluation. The fun is only evaluated if the primary log level check passes, and is therefore recommended if it is expensive to generate the message. The lazy fun must return a string, a report, or a tuple with format string and arguments.</source>
          <target state="translated">日志消息也可以通过一个fun来提供,以便进行懒惰评估。只有当主日志级别检查通过时,才会评估该 fun,因此,如果生成消息的成本很高,建议使用该 fun。懒惰函数必须返回一个字符串、一个报告或一个带有格式字符串和参数的元组。</target>
        </trans-unit>
        <trans-unit id="92a360c2f4c64ad84649417ba872aba09a495dca" translate="yes" xml:space="preserve">
          <source>The log message contains the information to be logged. The message can consist of a format string and arguments (given as two separate parameters in the Logger API), a string or a report. The latter, which is either a map or a key-value list, can be accompanied by a &lt;strong&gt;report callback&lt;/strong&gt; specified in the log event's &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt;. The report callback is a convenience function that the &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; can use to convert the report to a format string and arguments, or directly to a string. The formatter can also use its own conversion function, if no callback is provided, or if a customized formatting is desired.</source>
          <target state="translated">日志消息包含要记录的信息。该消息可以包含格式字符串和参数（在Logger API中作为两个单独的参数提供），字符串或报告。后者（可以是映射或键值列表）可以与在日志事件的 &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt; 指定的&lt;strong&gt;报告回调一起&lt;/strong&gt;使用。报表回调是一种便捷功能， &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; 可用于将报表转换为格式字符串和参数，或直接转换为字符串。如果没有提供回调，或者需要自定义格式，则格式化程序还可以使用其自己的转换功能。</target>
        </trans-unit>
        <trans-unit id="148877212af3299aabd6e2e80464a605727cd9f4" translate="yes" xml:space="preserve">
          <source>The log message contains the information to be logged. The message can consist of a format string and arguments (given as two separate parameters in the Logger API), a string or a report. The latter, which is either a map or a key-value list, can be accompanied by a &lt;strong&gt;report callback&lt;/strong&gt; specified in the log event's &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt;. The report callback is a convenience function that the &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; can use to convert the report to a format string and arguments. The formatter can also use its own conversion function, if no callback is provided, or if a customized formatting is desired.</source>
          <target state="translated">日志消息包含要记录的信息。该消息可以包含格式字符串和参数（在Logger API中作为两个单独的参数提供），字符串或报告。后者（可以是映射或键值列表）可以与在日志事件的 &lt;code&gt;&lt;a href=&quot;#metadata&quot;&gt;metadata&lt;/a&gt;&lt;/code&gt; 指定的&lt;strong&gt;报告回调一起&lt;/strong&gt;使用。报表回调是一种方便的功能， &lt;code&gt;&lt;a href=&quot;#formatters&quot;&gt;formatter&lt;/a&gt;&lt;/code&gt; 可用于将报表转换为格式字符串和参数。如果没有提供回调，或者需要自定义格式，则格式化程序还可以使用其自己的转换功能。</target>
        </trans-unit>
        <trans-unit id="8e0c9afffef01563d1e914bbb564b164c5c43598" translate="yes" xml:space="preserve">
          <source>The log type. Defaults to &lt;code&gt;halt&lt;/code&gt;.</source>
          <target state="translated">日志类型。默认为 &lt;code&gt;halt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e28a2d8b5a958d67c48ee8bc4c5069e252d9e6f6" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpa#log_to_txt&quot;&gt;snmpa:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">日志使用原始数据格式（基本上是BER编码的消息），以最小化日志机制所需的CPU负载。这意味着该日志不是人类可读的，但需要脱机格式化后才能对其进行读取。 &lt;code&gt;&lt;a href=&quot;snmpa#log_to_txt&quot;&gt;snmpa:log_to_txt&lt;/a&gt;&lt;/code&gt; ，请使用函数snmpa：log_to_txt。</target>
        </trans-unit>
        <trans-unit id="286976b20277382019a10c4770aeb782c67d3c09" translate="yes" xml:space="preserve">
          <source>The log uses a raw data format (basically the BER encoded message), in order to minimize the CPU load needed for the log mechanism. This means that the log is not human readable, but needs to be formatted off-line before it can be read. Use the function &lt;code&gt;&lt;a href=&quot;snmpm#log_to_txt&quot;&gt;snmpm:log_to_txt&lt;/a&gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">日志使用原始数据格式（基本上是BER编码的消息），以最小化日志机制所需的CPU负载。这意味着该日志不是人类可读的，但需要脱机格式化后才能对其进行读取。 &lt;code&gt;&lt;a href=&quot;snmpm#log_to_txt&quot;&gt;snmpm:log_to_txt&lt;/a&gt;&lt;/code&gt; ，请使用函数snmpm：log_to_txt。</target>
        </trans-unit>
        <trans-unit id="96b3fd02f414c107ec8f4bbb84dfc360fb88eb27" translate="yes" xml:space="preserve">
          <source>The long synonyms for property names supported by Perl (such as \p{Letter}) are not supported by PCRE. It is not permitted to prefix any of these properties with &quot;Is&quot;.</source>
          <target state="translated">PCRE 不支持 Perl 支持的属性名的长同义词(如 \p{Letter})。不允许在这些属性的前面加上 &quot;Is&quot;。</target>
        </trans-unit>
        <trans-unit id="bf1f5fae62661eca849a838d180479af9bffc0a1" translate="yes" xml:space="preserve">
          <source>The look and feel on an Erlang shell inside Emacs should be the same as in a normal Erlang shell. There is just one major difference, the cursor keys will actually move the cursor around just like in any normal Emacs buffer. The command line history can be accessed by the following commands:</source>
          <target state="translated">Emacs内部的Erlang shell的外观和感觉应该和普通的Erlang shell一样。只是有一个主要的区别,光标键实际上会像在任何正常的Emacs缓冲区一样移动光标。命令行历史记录可以通过以下命令来访问。</target>
        </trans-unit>
        <trans-unit id="0df7a98e001c7e4a5d47744bc177ec50ac6e7aac" translate="yes" xml:space="preserve">
          <source>The lookup fun is to defined as follows:</source>
          <target state="translated">查找乐趣定义如下。</target>
        </trans-unit>
        <trans-unit id="026bec80693d2fc446353c2345ce4713bd83e4e1" translate="yes" xml:space="preserve">
          <source>The lookup function is optional. It is assumed that the lookup function always finds values much faster than it would take to traverse the table. The first argument is the position of the key. As &lt;code&gt;qlc_next/1&lt;/code&gt; returns the objects as &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, the position is 1. Notice that the lookup function is to return &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; pairs, as the traversal function does.</source>
          <target state="translated">查找功能是可选的。假定查找功能始终比遍历表更快地找到值。第一个参数是密钥的位置。当 &lt;code&gt;qlc_next/1&lt;/code&gt; 以 &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; 对的形式返回对象时，位置为1。请注意，查找函数将像遍历函数一样返回 &lt;code&gt;{Key,&amp;nbsp;Value}&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="fabd07160cb884d874c4f9a6b01df339b79b9bb2" translate="yes" xml:space="preserve">
          <source>The lookup method &lt;code&gt;string&lt;/code&gt; tries to parse the hostname as an IPv4 or IPv6 string and return the resulting IP address. It is automatically tried first when &lt;code&gt;native&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; in the &lt;code&gt;Methods&lt;/code&gt; list. To skip it in this case, the pseudo lookup method &lt;code&gt;nostring&lt;/code&gt; can be inserted anywhere in the &lt;code&gt;Methods&lt;/code&gt; list.</source>
          <target state="translated">查找方法 &lt;code&gt;string&lt;/code&gt; 尝试将主机名解析为IPv4或IPv6字符串，并返回结果IP地址。它会自动第一次尝试时， &lt;code&gt;native&lt;/code&gt; 是&lt;strong&gt;不是&lt;/strong&gt;在 &lt;code&gt;Methods&lt;/code&gt; 列表中。要在这种情况下跳过它，可以在&amp;ldquo; &lt;code&gt;Methods&lt;/code&gt; 列表中的任何位置插入伪查找方法 &lt;code&gt;nostring&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c044c1e777396e3daac623dcbd7b6aa51c86d5ee" translate="yes" xml:space="preserve">
          <source>The lowest distribution version that this node can handle. Should be 5 to support connections to nodes older than OTP 23.</source>
          <target state="translated">这个节点能处理的最低分发版本。应该是5,以支持连接到比OTP 23更老的节点。</target>
        </trans-unit>
        <trans-unit id="97cdecdfe5db74108a6e54e74406dd0b623db1c5" translate="yes" xml:space="preserve">
          <source>The lowest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="translated">这个节点能够处理的最低发行版本。在Erlang/OTP R6B及以后的版本中,这个值是5。</target>
        </trans-unit>
        <trans-unit id="24eb6a8d27375e91cdfd660b6fa7ee2293d38deb" translate="yes" xml:space="preserve">
          <source>The lowest possible value an atomic in this array can hold.</source>
          <target state="translated">在这个数组中,一个原子所能容纳的最低值。</target>
        </trans-unit>
        <trans-unit id="f0b970e479bf0315a32496d0381fe4d1214762f9" translate="yes" xml:space="preserve">
          <source>The machine name, &lt;code&gt;'BEAM'&lt;/code&gt;.</source>
          <target state="translated">机器名称 &lt;code&gt;'BEAM'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afb285d4f389b85ea26f3cda19e5a047be514a48" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text)&lt;/code&gt; expands to &lt;code&gt;merl:quote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="translated">宏 &lt;code&gt;?Q(Text)&lt;/code&gt; 扩展为 &lt;code&gt;merl:quote(?LINE, Text, Env)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="111750be1ff5da23f444d310ece95b7d465283a5" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;?Q(Text, Env)&lt;/code&gt; expands to &lt;code&gt;merl:qquote(?LINE, Text, Env)&lt;/code&gt;.</source>
          <target state="translated">宏 &lt;code&gt;?Q(Text, Env)&lt;/code&gt; 扩展为 &lt;code&gt;merl:qquote(?LINE, Text, Env)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab9e862588129d877f212f0bfde0ba3a46758cc8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;ENSURE&lt;/code&gt; (line 5-10) is used to ensure that the buffer is large enough for the answer. We switch on the command and take actions. We always have read select active on a port in &lt;code&gt;data&lt;/code&gt; mode (achieved by calling &lt;code&gt;do_recv&lt;/code&gt; on line 45), but we turn off read selection in &lt;code&gt;intermediate&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt; modes (line 27 and 36).</source>
          <target state="translated">宏 &lt;code&gt;ENSURE&lt;/code&gt; （第5-10行）用于确保缓冲区足够大，可以容纳答案。我们打开命令并采取措施。我们总是在 &lt;code&gt;data&lt;/code&gt; 模式下（通过在第45行调用 &lt;code&gt;do_recv&lt;/code&gt; 来实现）在端口上处于活动状态的读取选择，但是我们在 &lt;code&gt;intermediate&lt;/code&gt; 模式和 &lt;code&gt;command&lt;/code&gt; 模式（第27和36 行）中关闭了读取选择。</target>
        </trans-unit>
        <trans-unit id="dfa60ec98993e6c63f6b1ebab600c7c27efb5263" translate="yes" xml:space="preserve">
          <source>The macro directives cannot be used inside functions.</source>
          <target state="translated">宏指令不能在函数内部使用。</target>
        </trans-unit>
        <trans-unit id="d5c84a81d3e29ec48f2e8baa4f7a70afaa858f2c" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;ERL_ATOM_PTR&lt;/code&gt; and &lt;code&gt;ERL_INT_VALUE&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt; can be used to obtain the actual values of the atom and the integer. The atom value is represented as a string. By comparing this value with the strings &quot;foo&quot; and &quot;bar&quot;, it can be decided which function to call:</source>
          <target state="translated">宏 &lt;code&gt;ERL_ATOM_PTR&lt;/code&gt; 和 &lt;code&gt;ERL_INT_VALUE&lt;/code&gt; 从 &lt;code&gt;erl_eterm&lt;/code&gt; 可以用于获得原子和整数的实际值。原子值表示为字符串。通过将该值与字符串&amp;ldquo; foo&amp;rdquo;和&amp;ldquo; bar&amp;rdquo;进行比较，可以确定要调用哪个函数：</target>
        </trans-unit>
        <trans-unit id="bae8ce14b127e8cb8fe803fcfaa7780c8c2e819c" translate="yes" xml:space="preserve">
          <source>The macros are defined in &lt;code&gt;logger.hrl&lt;/code&gt;, which is included in a module with the directive</source>
          <target state="translated">宏在 &lt;code&gt;logger.hrl&lt;/code&gt; 中定义，该文件包含在带有指令的模块中</target>
        </trans-unit>
        <trans-unit id="7e6a4c157f57c6d503002b41adbc5bd71b9008ba" translate="yes" xml:space="preserve">
          <source>The magic cookie of the local node is retrieved by calling &lt;code&gt;erlang:get_cookie()&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;erlang:get_cookie()&lt;/code&gt; 检索本地节点的魔术cookie 。</target>
        </trans-unit>
        <trans-unit id="9a05f6bcadc54f796f0b1fd5def2686d750e1700" translate="yes" xml:space="preserve">
          <source>The main (outer) loop for a process &lt;strong&gt;must&lt;/strong&gt; be tail-recursive. Otherwise, the stack grows until the process terminates.</source>
          <target state="translated">流程的主（外部）循环&lt;strong&gt;必须&lt;/strong&gt;是尾递归的。否则，堆栈会增长，直到进程终止。</target>
        </trans-unit>
        <trans-unit id="255b30701b0f9daa4744f53b6adde340892fc688" translate="yes" xml:space="preserve">
          <source>The main advantage of dividing systems into global groups is that the background load decreases while the number of nodes to be updated is reduced when manipulating globally registered names.</source>
          <target state="translated">将系统划分为全局组的主要优点是,在操作全局注册名称时,后台负载降低,同时需要更新的节点数量减少。</target>
        </trans-unit>
        <trans-unit id="8bac27c9210ec680873a11c4354804a354e76059" translate="yes" xml:space="preserve">
          <source>The main advantage of using records rather than tuples is that fields in a record are accessed by name, whereas fields in a tuple are accessed by position. To illustrate these differences, suppose that you want to represent a person with the tuple &lt;code&gt;{Name, Address, Phone}&lt;/code&gt;.</source>
          <target state="translated">使用记录而不是元组的主要优点是，记录中的字段按名称访问，而元组中的字段按位置访问。为了说明这些差异，假设您想用元组 &lt;code&gt;{Name, Address, Phone}&lt;/code&gt; 代表一个人。</target>
        </trans-unit>
        <trans-unit id="b014077cb1006ff99f29813775f91d4f9609fb7b" translate="yes" xml:space="preserve">
          <source>The main benefit of constants is that they can be used to reduce the size (and avoid repetition) of long strings, such as file paths.</source>
          <target state="translated">常量的主要好处是可以用来减少长字符串(如文件路径)的大小(并避免重复)。</target>
        </trans-unit>
        <trans-unit id="a935bee785d5a929b8af32300cdaed69bbcdc5fe" translate="yes" xml:space="preserve">
          <source>The main execution threads that do most of the work. See &lt;code&gt;erl +S&lt;/code&gt; for more details.</source>
          <target state="translated">主要执行线程完成大部分工作。有关更多详细信息，请参见 &lt;code&gt;erl +S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44bd22c67eb6433073dc2e343a3a6d7e1322b4de" translate="yes" xml:space="preserve">
          <source>The main features of SNMPv2 compared to SNMPv1 are:</source>
          <target state="translated">与SNMPv1相比,SNMPv2的主要特点是:1.</target>
        </trans-unit>
        <trans-unit id="f987baf10d1a6cef3c887c260f84f36bcc967860" translate="yes" xml:space="preserve">
          <source>The main idea in the model is that it is not tied to any specific management protocol. An Application Programming Interface (API) is defined, which can be used to write adaptations for specific management protocols.</source>
          <target state="translated">该模型的主要思想是,它不与任何特定的管理协议挂钩。定义了一个应用程序接口(API),可用于为具体的管理协议编写适配程序。</target>
        </trans-unit>
        <trans-unit id="79d206b097b388ff06479821f31341df73bd37fd" translate="yes" xml:space="preserve">
          <source>The main idea is that the resource sends the notifications as Erlang terms to a dedicated &lt;code&gt;gen_event&lt;/code&gt; process. Into this process, handlers for the different management protocols are installed. When an event is received by this process, it is forwarded to each installed handler. The handlers are responsible for translating the event into a notification to be sent over the management protocol. For example, a handler for SNMP translates each event into an SNMP trap.</source>
          <target state="translated">主要思想是资源将通知作为Erlang术语发送到专用的 &lt;code&gt;gen_event&lt;/code&gt; 进程。在此过程中，安装了用于不同管理协议的处理程序。当该过程接收到事件时，该事件将转发到每个已安装的处理程序。处理程序负责将事件转换为要通过管理协议发送的通知。例如，SNMP的处理程序将每个事件转换为SNMP陷阱。</target>
        </trans-unit>
        <trans-unit id="47a8cc665e1c479e686529aed490a0ed53790936" translate="yes" xml:space="preserve">
          <source>The main idea with the &lt;code&gt;erts_alloc&lt;/code&gt; library is to separate memory blocks that are used differently into different memory areas, to achieve less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</source>
          <target state="translated">&lt;code&gt;erts_alloc&lt;/code&gt; 库的主要思想是将不同使用的内存块分离到不同的内存区域，以减少内存碎片。与为那些不经常分配的存储块相比，通过花费更少的精力寻找适合于频繁分配的存储块的方法，可以提高性能。</target>
        </trans-unit>
        <trans-unit id="68792cbe81e714a76ce3bda5abbbd3fd1ba75cb7" translate="yes" xml:space="preserve">
          <source>The main loop receives messages from the client (which can use the the &lt;code&gt;io&lt;/code&gt; module to send requests). For each request, the function &lt;code&gt;request/2&lt;/code&gt; is called and a reply is eventually sent using function &lt;code&gt;reply/3&lt;/code&gt;.</source>
          <target state="translated">主循环从客户端接收消息（可以使用 &lt;code&gt;io&lt;/code&gt; 模块发送请求）。对于每个请求，将调用功能 &lt;code&gt;request/2&lt;/code&gt; 并最终使用功能 &lt;code&gt;reply/3&lt;/code&gt; 发送回复。</target>
        </trans-unit>
        <trans-unit id="a881d2bf8e074a4ba8b926654caec623f66ddd76" translate="yes" xml:space="preserve">
          <source>The main purpose of benchmarking is to find out which implementation of a given algorithm or function is the fastest. Benchmarking is far from an exact science. Today's operating systems generally run background tasks that are difficult to turn off. Caches and multiple CPU cores does not facilitate benchmarking. It would be best to run UNIX computers in single-user mode when benchmarking, but that is inconvenient to say the least for casual testing.</source>
          <target state="translated">基准测试的主要目的是找出某个算法或函数的哪个实现速度最快。基准测试远不是一门精确的科学。今天的操作系统一般都会运行难以关闭的后台任务。缓存和多个CPU核并不方便进行基准测试。基准测试时,最好以单用户模式运行UNIX计算机,但这至少可以说是不方便的休闲测试。</target>
        </trans-unit>
        <trans-unit id="2d7cf0f3407ae9a11f3bfd8fb13ccb306f69fca2" translate="yes" xml:space="preserve">
          <source>The main purpose of the history buffer is the possibility to create configuration files. Any function stored in the history buffer can be written to a configuration file and used for creating a specific configuration at any time with a single function call.</source>
          <target state="translated">历史缓冲区的主要目的是可以创建配置文件。存储在历史缓冲区的任何函数都可以写入配置文件,并在任何时候通过一个函数调用来创建特定的配置。</target>
        </trans-unit>
        <trans-unit id="a3a2d3d740cc729d95dfc1aed7685f23aefe5460" translate="yes" xml:space="preserve">
          <source>The main purpose of this verb is to track how a match was arrived at, although it also has a secondary use in with advancing the match starting point (see (*SKIP) below).</source>
          <target state="translated">这个动词的主要目的是跟踪比赛是如何到达的,虽然它也有一个次要的用途,与推进比赛的起点(见下面的(*SKIP))。</target>
        </trans-unit>
        <trans-unit id="944d5d0eccccb0b12f4b4534569f94fbf95946bc" translate="yes" xml:space="preserve">
          <source>The main reason for using &lt;code&gt;assertMatch&lt;/code&gt; also for simple matches, instead of matching with &lt;code&gt;=&lt;/code&gt;, is that it produces more detailed error messages.</source>
          <target state="translated">使用 &lt;code&gt;assertMatch&lt;/code&gt; 进行简单匹配而不是与 &lt;code&gt;=&lt;/code&gt; 匹配的主要原因是，它会产生更详细的错误消息。</target>
        </trans-unit>
        <trans-unit id="36e19f27d5fcd9a14663b0e9dd365354ee344321" translate="yes" xml:space="preserve">
          <source>The main start function is &lt;code&gt;et_viewer:start/1&lt;/code&gt;. By default it will start both an &lt;code&gt;et_collector&lt;/code&gt; and an &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">主要的启动功能是 &lt;code&gt;et_viewer:start/1&lt;/code&gt; 。默认情况下，它将同时启动一个 &lt;code&gt;et_collector&lt;/code&gt; 和一个 &lt;code&gt;et_viewer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5f65eff5d9e1575c086bd894c5f5751be08ad7ae" translate="yes" xml:space="preserve">
          <source>The main structure of an ETS table was originally managed using reference counting. Already a long time ago we replaced this strategy since the reference counter caused contention on each access of the table. The solution used was to schedule &quot;confirm deletion&quot; jobs on each scheduler in order to know when it was safe to deallocate the table structure of a removed table. These confirm deletion jobs needed to be allocated. That is, we had to allocate and deallocate as many blocks as schedulers in order to deallocate one block. This of course was a quite an expensive operation, but we only needed to do this once when removing a table. It was more important to get rid of the contention on the reference counter which was present on every operation on the table.</source>
          <target state="translated">ETS表的主要结构最初是用参考计数来管理的。很久以前,我们就已经替换了这种策略,因为引用计数器在表的每次访问中都会引起争论。我们使用的解决方案是在每个调度器上调度 &quot;确认删除 &quot;作业,以便知道什么时候可以安全地重新分配被删除表的表结构。这些确认删除作业需要进行分配。也就是说,为了deallocate一个块,我们必须分配和deallocate尽可能多的调度器块。当然这是一个相当昂贵的操作,但我们只需要在删除一张表时做一次。更重要的是要摆脱参考计数器上的争用,因为在表上的每一次操作都会出现这种争用。</target>
        </trans-unit>
        <trans-unit id="1a97901ec3926c3174291fa1e27d3f66bbc8d7ec" translate="yes" xml:space="preserve">
          <source>The main use of the function &lt;code&gt;meta/1&lt;/code&gt; is to transform a data structure &lt;code&gt;Tree&lt;/code&gt;, which represents a piece of program code, into a form that is &lt;strong&gt;representation independent when printed&lt;/strong&gt;. E.g., suppose &lt;code&gt;Tree&lt;/code&gt; represents a variable named &quot;V&quot;. Then (assuming a function &lt;code&gt;print/1&lt;/code&gt; for printing syntax trees), evaluating &lt;code&gt;print(abstract(Tree))&lt;/code&gt; - simply using &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot;&lt;code&gt;{tree, variable, ..., &quot;V&quot;, ...}&lt;/code&gt;&quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using &lt;code&gt;print(meta(Tree))&lt;/code&gt; instead would output a &lt;strong&gt;representation independent&lt;/strong&gt; syntax tree generating expression; in the above case, something like &quot;&lt;code&gt;erl_syntax:variable(&quot;V&quot;)&lt;/code&gt;&quot;.</source>
          <target state="translated">函数 &lt;code&gt;meta/1&lt;/code&gt; 的主要用途是将表示一段程序代码的数据结构 &lt;code&gt;Tree&lt;/code&gt; 转换为&lt;strong&gt;在打印时独立于表示&lt;/strong&gt;的形式。例如，假设 &lt;code&gt;Tree&lt;/code&gt; 表示一个名为&amp;ldquo; V&amp;rdquo;的变量。然后（假设函数 &lt;code&gt;print/1&lt;/code&gt; 用于打印语法树），评估 &lt;code&gt;print(abstract(Tree))&lt;/code&gt; -仅使用 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 将实际的数据结构映射到语法树表示形式，将输出一个字符串，该字符串可能类似于&amp;ldquo; &lt;code&gt;{tree, variable, ..., &quot;V&quot;, ...}&lt;/code&gt; &amp;ldquo;，这显然取决于抽象语法树的实现。例如，这对于在文件中缓存语法树很有用。但是，在某些情况下，例如在程序生成器生成器（带有两个&amp;ldquo;生成器&amp;rdquo;）中，它可能相反，使用 &lt;code&gt;print(meta(Tree))&lt;/code&gt; 会输出与&lt;strong&gt;表示形式无关的&lt;/strong&gt;语法树生成表达式；在上述情况下，类似&amp;ldquo; &lt;code&gt;erl_syntax:variable(&quot;V&quot;)&lt;/code&gt; &amp;ldquo;。</target>
        </trans-unit>
        <trans-unit id="25d3b04084d73d8cdfe2e775719ca547748c8126" translate="yes" xml:space="preserve">
          <source>The main use of the function &lt;code&gt;meta/1&lt;/code&gt; is to transform a data structure &lt;code&gt;Tree&lt;/code&gt;, which represents a piece of program code, into a form that is &lt;strong&gt;representation independent when printed&lt;/strong&gt;. E.g., suppose &lt;code&gt;Tree&lt;/code&gt; represents a variable named &quot;V&quot;. Then (assuming a function &lt;code&gt;print/1&lt;/code&gt; for printing syntax trees), evaluating &lt;code&gt;print(abstract(Tree))&lt;/code&gt; - simply using &lt;code&gt;abstract/1&lt;/code&gt; to map the actual data structure onto a syntax tree representation - would output a string that might look something like &quot;&lt;code&gt;{var, ..., 'V'}&lt;/code&gt;&quot;, which is obviously dependent on the implementation of the abstract syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in some situations like in a program generator generator (with two &quot;generator&quot;), it may be unacceptable. Using &lt;code&gt;print(meta(Tree))&lt;/code&gt; instead would output a &lt;strong&gt;representation independent&lt;/strong&gt; syntax tree generating expression; in the above case, something like &quot;&lt;code&gt;cerl:c_var('V')&lt;/code&gt;&quot;.</source>
          <target state="translated">函数 &lt;code&gt;meta/1&lt;/code&gt; 的主要用途是将表示一段程序代码的数据结构 &lt;code&gt;Tree&lt;/code&gt; 转换为&lt;strong&gt;在打印时&lt;/strong&gt;与&lt;strong&gt;表示无关&lt;/strong&gt;的形式。例如，假设 &lt;code&gt;Tree&lt;/code&gt; 表示一个名为&amp;ldquo; V&amp;rdquo;的变量。然后（假设函数 &lt;code&gt;print/1&lt;/code&gt; 用于打印语法树），评估 &lt;code&gt;print(abstract(Tree))&lt;/code&gt; -仅使用 &lt;code&gt;abstract/1&lt;/code&gt; 将实际的数据结构映射到语法树表示形式，将输出一个字符串，该字符串可能类似于&amp;ldquo; &lt;code&gt;{var, ..., 'V'}&lt;/code&gt; &amp;ldquo;，这显然取决于抽象语法树的实现。例如，这对于在文件中缓存语法树很有用。但是，在某些情况下，例如在程序生成器生成器（带有两个&amp;ldquo;生成器&amp;rdquo;）中，它可能会相反，使用 &lt;code&gt;print(meta(Tree))&lt;/code&gt; 会输出一个与&lt;strong&gt;表示形式无关的&lt;/strong&gt;语法树生成表达式；在上述情况下，类似于&amp;ldquo; &lt;code&gt;cerl:c_var('V')&lt;/code&gt; &amp;ldquo;。</target>
        </trans-unit>
        <trans-unit id="5cc7ab3d8930133e6c9f32ae9603597733b45c75" translate="yes" xml:space="preserve">
          <source>The main user interface consists of the functions &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename/3&lt;/a&gt;&lt;/code&gt;. See also the function &lt;code&gt;&lt;a href=&quot;#parse_transform-2&quot;&gt;parse_transform/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">主用户界面由功能 &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename/3&lt;/a&gt;&lt;/code&gt; 。另请参见函数 &lt;code&gt;&lt;a href=&quot;#parse_transform-2&quot;&gt;parse_transform/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf690a3ba48e5ab54f3129fdb73083e8aa1ffc60" translate="yes" xml:space="preserve">
          <source>The major advantage of dirty operations is that they execute much faster than equivalent operations that are processed as functional objects within a transaction.</source>
          <target state="translated">脏操作的主要优点是,它们的执行速度比在事务中作为功能对象处理的等价操作快得多。</target>
        </trans-unit>
        <trans-unit id="0c3f1a7bfd03b2e26984b55900c5f5a003f06a78" translate="yes" xml:space="preserve">
          <source>The major log file shows a detailed report of the test run. It includes test suite and test case names, execution time, the exact reason for failures, and so on. The information is available in both a file with textual and with HTML representation. The HTML file shows a summary that gives a good overview of the test run. It also has links to each individual test case log file for quick viewing with an HTML browser.</source>
          <target state="translated">主要日志文件显示了测试运行的详细报告。它包括测试套件和测试用例名称、执行时间、失败的确切原因等。这些信息既可以用文本文件也可以用HTML表示。HTML文件显示了一个总结,提供了测试运行的一个很好的概述。它也有链接到每个单独的测试案例日志文件,以便用HTML浏览器快速查看。</target>
        </trans-unit>
        <trans-unit id="75ff18089a46d332c47b58a78759522e28ba0f11" translate="yes" xml:space="preserve">
          <source>The management information is defined in a &lt;strong&gt;Management Information Base (MIB)&lt;/strong&gt;. It is a formal definition of which information the agent makes available to the manager. The manager accesses the MIB through a management protocol, such as SNMP, CMIP, HTTP, or CORBA. Each protocol has its own MIB definition language. In SNMP, it is a subset of ASN.1, in CMIP it is GDMO, in HTTP it is implicit, and using CORBA, it is IDL.</source>
          <target state="translated">管理信息在&lt;strong&gt;管理信息库（MIB）中定义&lt;/strong&gt;。它是座席向经理提供哪些信息的正式定义。管理器通过管理协议（例如SNMP，CMIP，HTTP或CORBA）访问MIB。每个协议都有其自己的MIB定义语言。在SNMP中，它是ASN.1的子集；在CMIP中，它是GDMO；在HTTP中，它是隐式的；使用CORBA，它是IDL。</target>
        </trans-unit>
        <trans-unit id="b3ad91073d713476eff5d4cf8dadc04c76b79f8f" translate="yes" xml:space="preserve">
          <source>The management of data in telecommunications system has many aspects, thereof some, but not all, are addressed by traditional commercial Database Management Systems (DBMSs). In particular the high level of fault tolerance that is required in many nonstop systems, combined with requirements on the DBMS to run in the same address space as the application, have led us to implement a new DBMS, called Mnesia.</source>
          <target state="translated">电信系统中的数据管理有很多方面,传统的商业数据库管理系统(DBMSs)可以解决其中的一些问题,但不是全部。特别是许多不间断系统所要求的高水平的容错能力,再加上对DBMS的要求,即在与应用程序相同的地址空间中运行,使我们实现了一种新的DBMS,称为Mnesia。</target>
        </trans-unit>
        <trans-unit id="febc54d5d2b9c5b21af431123017ea615fe431a5" translate="yes" xml:space="preserve">
          <source>The manager information should be stored in a file called &lt;code&gt;manager.conf&lt;/code&gt;.</source>
          <target state="translated">管理员信息应存储在名为 &lt;code&gt;manager.conf&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="1781b487b48a4f52fe09daa2b7145718574c6144" translate="yes" xml:space="preserve">
          <source>The manager is often referred to as the &lt;strong&gt;Network Management System (NMS)&lt;/strong&gt;, to emphasize that it usually is realized as a program that presents data to an operator.</source>
          <target state="translated">管理器通常被称为&lt;strong&gt;网络管理系统（NMS）&lt;/strong&gt;，以强调它通常被实现为向操作员显示数据的程序。</target>
        </trans-unit>
        <trans-unit id="f2e6c9c5cfab679c1965d0d5bc8b363294a83d30" translate="yes" xml:space="preserve">
          <source>The manager issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="translated">管理器发出以下 &lt;code&gt;getNext&lt;/code&gt; 请求：</target>
        </trans-unit>
        <trans-unit id="dca59b908ffe28e5cc68a3e4e9de1faaa52c370b" translate="yes" xml:space="preserve">
          <source>The manager now issues the following &lt;code&gt;getNext&lt;/code&gt; request:</source>
          <target state="translated">管理器现在发出以下 &lt;code&gt;getNext&lt;/code&gt; 请求：</target>
        </trans-unit>
        <trans-unit id="b8c05d8e33ba91352ab1e91a3f375a5f712ff8b9" translate="yes" xml:space="preserve">
          <source>The manager provided with the tool is a lightweight manager that basically provides a means to communicate with agents.</source>
          <target state="translated">该工具提供的管理器是一个轻量级的管理器,基本上提供了与代理沟通的手段。</target>
        </trans-unit>
        <trans-unit id="5c1c074734e843dc6952bf33ee471b27c50c0033" translate="yes" xml:space="preserve">
          <source>The mapping between an instrumentation function and a resource is not necessarily 1-1. It is also possible to write one instrumentation function for each resource, and use that function from different protocols.</source>
          <target state="translated">仪器仪表函数和资源之间的映射不一定是1-1。也可以为每个资源编写一个仪器仪表函数,并从不同的协议中使用该函数。</target>
        </trans-unit>
        <trans-unit id="939bc74abf6eec16a8f49e8849ab6b0eec6106c5" translate="yes" xml:space="preserve">
          <source>The mapping from identifier to slot or index into the array gets a bit more complicated than before. Instead of a &lt;code&gt;shift&lt;/code&gt; and a bitwise &lt;code&gt;and&lt;/code&gt;, we get two &lt;code&gt;shift&lt;/code&gt;s, two bitwise &lt;code&gt;and&lt;/code&gt;s, and an &lt;code&gt;add&lt;/code&gt; (see implementation of &lt;code&gt;erts_ptab_data2pix()&lt;/code&gt; in &lt;code&gt;erl_ptab.h&lt;/code&gt;). However, by storing this information optimized for lookup we only need a &lt;code&gt;shift&lt;/code&gt; and a bitwise &lt;code&gt;and&lt;/code&gt; on 32-bit platforms. On 64-bit platforms we got enough room for the 28-bit identifier in the least significant halfword, and the index in the most significant halfword, in other words, we just need to read the most significant halfword to get the index. That is, this operation is as fast, or faster than before. The downside is that on 32-bit platforms we need to convert this information into the 28-bit identifier number when printing, or when ordering identifiers from the same node. These operations are, however, extremely infrequent compared to lookups.</source>
          <target state="translated">从标识符到插槽或索引到数组的映射比以前复杂一些。而不是 &lt;code&gt;shift&lt;/code&gt; 和按位 &lt;code&gt;and&lt;/code&gt; ，我们得到两个 &lt;code&gt;shift&lt;/code&gt; s，两个按位 &lt;code&gt;and&lt;/code&gt; s和一个 &lt;code&gt;add&lt;/code&gt; （请参阅 &lt;code&gt;erts_ptab_data2pix()&lt;/code&gt; 的 &lt;code&gt;erl_ptab.h&lt;/code&gt; ）。然而，通过存储这些信息用于查询优化，我们只需要一个 &lt;code&gt;shift&lt;/code&gt; 和按位 &lt;code&gt;and&lt;/code&gt; 在32位平台上。在64位平台上，我们为最低有效半字中的28位标识符和最高有效半字中的索引留有足够的空间，换句话说，我们只需要读取最高有效半字即可获得索引。也就是说，此操作与以前一样快，或更快。缺点是在32位平台上，我们需要在打印时或从同一节点订购标识符时将这些信息转换为28位标识符编号。但是，与查找相比，这些操作非常少见。</target>
        </trans-unit>
        <trans-unit id="998850a8c8eb8546e7768e95697db1697df937aa" translate="yes" xml:space="preserve">
          <source>The master node failed to get in contact with the slave node. This can occur in a number of circumstances:</source>
          <target state="translated">主节点未能与从节点取得联系。这可能发生在一些情况下。</target>
        </trans-unit>
        <trans-unit id="9e8a3dc76b35e83a289af92700b545a4ad79beb4" translate="yes" xml:space="preserve">
          <source>The master node must be alive.</source>
          <target state="translated">主节点必须是活的。</target>
        </trans-unit>
        <trans-unit id="14b34e7f97d388e649ae66acf54b7298a330905d" translate="yes" xml:space="preserve">
          <source>The master node setting is always local. It can be changed regardless if Mnesia is started or not.</source>
          <target state="translated">主节点设置始终是本地的,无论Mnesia是否启动,它都可以改变。无论Mnesia是否启动,它都可以被改变。</target>
        </trans-unit>
        <trans-unit id="38a3c861dd367c28c4c17a1c39eefe8dd878d733" translate="yes" xml:space="preserve">
          <source>The master nodes &lt;code&gt;Masters&lt;/code&gt; are not alive.</source>
          <target state="translated">主节点 &lt;code&gt;Masters&lt;/code&gt; 是不是活的。</target>
        </trans-unit>
        <trans-unit id="58c3b06d8afda9470de94fad6ad989bbb0cc70c8" translate="yes" xml:space="preserve">
          <source>The match function can also be used to check the equality of different attributes. For example, to find all employees with an employee number equal to their room number:</source>
          <target state="translated">匹配函数也可以用来检查不同属性的平等性。例如,找到所有员工号与房间号相等的员工。</target>
        </trans-unit>
        <trans-unit id="01db01bdcf4f0ead878b2024575a51c69acd4f98" translate="yes" xml:space="preserve">
          <source>The match of &lt;code&gt;Dgram&lt;/code&gt; fails if one of the following occurs:</source>
          <target state="translated">如果发生以下情况之一， &lt;code&gt;Dgram&lt;/code&gt; 的匹配将失败：</target>
        </trans-unit>
        <trans-unit id="2c78419f0c88d5eda3fb5ff5b511ec776a98797e" translate="yes" xml:space="preserve">
          <source>The match specification function &lt;code&gt;{return_trace}&lt;/code&gt; works with meta-trace and sends its trace message to the same tracer.</source>
          <target state="translated">匹配规范函数 &lt;code&gt;{return_trace}&lt;/code&gt; 与meta-trace一起使用，并将其跟踪消息发送到同一跟踪器。</target>
        </trans-unit>
        <trans-unit id="5153c93179a582efee4cbb10c8790c7726a7e986" translate="yes" xml:space="preserve">
          <source>The match specification has to return the atom &lt;code&gt;true&lt;/code&gt; if the object is to be deleted. No other return value gets the object deleted. So one cannot use the same match specification for looking up elements as for deleting them.</source>
          <target state="translated">如果要删除对象，则匹配规范必须返回原子 &lt;code&gt;true&lt;/code&gt; 。没有其他返回值会删除该对象。因此，不能使用与删除元素相同的匹配规范来查找元素。</target>
        </trans-unit>
        <trans-unit id="98c4807426673ae3f3cbf5adfe4d22a81aa12f6b" translate="yes" xml:space="preserve">
          <source>The match specifications in the file are &lt;strong&gt;merged&lt;/strong&gt; with the current match specifications, so that no duplicates are generated. Use &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; to see what numbers were assigned to the specifications from the file.</source>
          <target state="translated">文件中的匹配规范&lt;strong&gt;将&lt;/strong&gt;与当前匹配规范&lt;strong&gt;合并&lt;/strong&gt;，因此不会生成任何重复项。使用 &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 查看文件中为规范指定了哪些编号。</target>
        </trans-unit>
        <trans-unit id="d55c9805b9483fe33032d7ae9cde54896150634e" translate="yes" xml:space="preserve">
          <source>The match specifiction must be guaranteed to &lt;strong&gt;retain the key&lt;/strong&gt; of any matched object. If not, &lt;code&gt;select_replace&lt;/code&gt; will fail with &lt;code&gt;badarg&lt;/code&gt; without updating any objects.</source>
          <target state="translated">必须确保匹配规范以&lt;strong&gt;保留&lt;/strong&gt;任何匹配对象&lt;strong&gt;的键&lt;/strong&gt;。如果没有， &lt;code&gt;select_replace&lt;/code&gt; 将失败，并 &lt;code&gt;badarg&lt;/code&gt; 没有更新任何对象。</target>
        </trans-unit>
        <trans-unit id="ee0a15736607c624569021f76ff9d3298f79570e" translate="yes" xml:space="preserve">
          <source>The match-and-replace operation for each individual object is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;select_replace&lt;/code&gt; table iteration as a whole, like all other select functions, does not give such guarantees.</source>
          <target state="translated">保证每个对象的匹配和替换操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;select_replace&lt;/code&gt; 表迭代作为一个整体，就像所有其他的选择功能，不给这样的保证。</target>
        </trans-unit>
        <trans-unit id="944665ed4f1242a6f22c3f844a6e8b7a742ead4b" translate="yes" xml:space="preserve">
          <source>The match-and-replace operation for each individual object is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;select_replace&lt;/code&gt; table traversal as a whole, like all other select functions, does not give such guarantees.</source>
          <target state="translated">保证每个单独对象的匹配和替换操作是 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;select_replace&lt;/code&gt; 表遍历作为一个整体，就像所有其他的选择功能，不给这样的保证。</target>
        </trans-unit>
        <trans-unit id="4ca8026082eee2ad7e64557de104f28a642c57fb" translate="yes" xml:space="preserve">
          <source>The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here.</source>
          <target state="translated">库的匹配算法是基于PCRE库的,但并不是所有的PCRE库都是对接的,有些部分超出了PCRE提供的范围。目前使用的是PCRE 8.40版本(发布日期2017-01-11)。这里包括PCRE文档中与本模块相关的部分。</target>
        </trans-unit>
        <trans-unit id="fbd21ba9310055b64610ab1a5c2a142134aa443f" translate="yes" xml:space="preserve">
          <source>The matching is executed on each element in &lt;code&gt;List&lt;/code&gt; and the function returns a list containing all results. If an element in &lt;code&gt;List&lt;/code&gt; does not match, nothing is returned for that element. The length of the result list is therefore equal or less than the length of parameter &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">匹配在 &lt;code&gt;List&lt;/code&gt; 中的每个元素上执行，该函数返回包含所有结果的列表。如果 &lt;code&gt;List&lt;/code&gt; 中的元素不匹配，则该元素不返回任何内容。因此，结果列表的长度等于或小于参数 &lt;code&gt;List&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="198df020548452f3363e4fa559534d8078bfc86b" translate="yes" xml:space="preserve">
          <source>The matching operations in &lt;code&gt;Mnesia&lt;/code&gt; can either lock the entire table or only a single record (when the key is bound in the pattern).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 中的匹配操作可以锁定整个表或仅锁定单个记录（当键绑定在模式中时）。</target>
        </trans-unit>
        <trans-unit id="1c7432182c4d5c9b15c8c14cd2adab865e6ade5c" translate="yes" xml:space="preserve">
          <source>The max &lt;code&gt;MacLength&lt;/code&gt; is documented in &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">最大 &lt;code&gt;MacLength&lt;/code&gt; 记录在《用户指南》的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; &amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="334b3e2d6b3a53d5d4f23d6292533ac9fed61406" translate="yes" xml:space="preserve">
          <source>The maximum number of allowed characters in an atom is 255. In the UTF-8 case, each character can need 4 bytes to be encoded.</source>
          <target state="translated">一个原子中允许的最大字符数是255。在UTF-8的情况下,每个字符可能需要4个字节来编码。</target>
        </trans-unit>
        <trans-unit id="19294f2a8c14a8b4f31f643e9f2b22734d7e410e" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes that has been allocated during the lifetime of the originating node. This is only shown if the Erlang runtime system is run instrumented.</source>
          <target state="translated">在始发节点的生命周期内被分配的最大字节数。只有当Erlang运行时系统是以工具运行时才会显示。</target>
        </trans-unit>
        <trans-unit id="139d6633f301a60c8cd9a458fcbc51c168888bf8" translate="yes" xml:space="preserve">
          <source>The maximum number of capturing subpatterns is 65535.</source>
          <target state="translated">捕获子模式的最大数量为65535。</target>
        </trans-unit>
        <trans-unit id="b9e4da31684e055b1fb93d08f64615fcb600a8f2" translate="yes" xml:space="preserve">
          <source>The maximum number of channels that are accepted for each connection. The default is unlimited.</source>
          <target state="translated">每个连接接受的最大通道数。默认值是无限的。</target>
        </trans-unit>
        <trans-unit id="1bc4329e4ceb57ba9547a9f48f399278acde7346" translate="yes" xml:space="preserve">
          <source>The maximum number of channels with active remote subsystem that are accepted for each connection to this daemon</source>
          <target state="translated">每个连接到该守护进程的活动远程子系统接受的最大通道数。</target>
        </trans-unit>
        <trans-unit id="b534caa8ed29360c9c0c9252aae63ac15ba8de99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements in a tuple is 16,777,215 (24-bit unsigned integer).</source>
          <target state="translated">一个元组的最大元素数是16,777,215(24位无符号整数)。</target>
        </trans-unit>
        <trans-unit id="aa82ab7bf0492deb21a60217a14e1da088287537" translate="yes" xml:space="preserve">
          <source>The maximum number of ports that can be open at the same time can be configured by passing command-line flag &lt;code&gt;&lt;a href=&quot;erl#max_ports&quot;&gt;+Q&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">可以通过将命令行标志 &lt;code&gt;&lt;a href=&quot;erl#max_ports&quot;&gt;+Q&lt;/a&gt;&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 来配置可以同时打开的最大端口数。</target>
        </trans-unit>
        <trans-unit id="364851e20b3d3baac09ccbd2901df833d89219b3" translate="yes" xml:space="preserve">
          <source>The maximum number of repetitions of the timer.</source>
          <target state="translated">计时器的最大重复次数。</target>
        </trans-unit>
        <trans-unit id="aefae34749517c169c9627f37f381f0e13c03a1a" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. The default is that an unlimited number of simultaneous sessions are allowed. It is a good candidate to set if the capacity of the server is low or a capacity margin is needed.</source>
          <target state="translated">该守护进程在任何时候接受的最大同时会话数。这包括正在授权的会话。默认值是允许无限数量的同时会话。如果服务器的容量较低或需要容量余量,则很适合设置。</target>
        </trans-unit>
        <trans-unit id="b52d3e36551290057fbd3fa69d9e51f68308bed8" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. Thus, if set to &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;N&lt;/code&gt; clients have connected but not started the login process, connection attempt &lt;code&gt;N+1&lt;/code&gt; is aborted. If &lt;code&gt;N&lt;/code&gt; connections are authenticated and still logged in, no more logins are accepted until one of the existing ones log out.</source>
          <target state="translated">此守护程序在任何时间都接受的最大同时会话数。这包括正在授权的会话。因此，如果设置为 &lt;code&gt;N&lt;/code&gt; ，并且 &lt;code&gt;N&lt;/code&gt; 个客户端已连接但尚未启动登录过程，则连接尝试 &lt;code&gt;N+1&lt;/code&gt; 将中止。如果对 &lt;code&gt;N&lt;/code&gt; 个连接进行了身份验证并仍在登录，则在现有登录之一注销之前，将不再接受其他登录。</target>
        </trans-unit>
        <trans-unit id="33f9e2efd4e8f4d95b154e45a6aa836475444a9a" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously alive Erlang processes is by default 262,144. This limit can be configured at startup. For more information, see the &lt;code&gt;+P&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">默认情况下，同时运行的Erlang进程的最大数量为262,144。可以在启动时配置此限制。有关更多信息，请参见ERTS 的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页中的 &lt;code&gt;+P&lt;/code&gt; 命令行标志。</target>
        </trans-unit>
        <trans-unit id="3ea78efb7aa811663d27fe73cd13c0c8fb0d40a3" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously connected nodes is limited by either the maximum number of simultaneously known remote nodes, &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of (Erlang) ports&lt;/a&gt;&lt;/code&gt; available, or &lt;code&gt;&lt;a href=&quot;#files_sockets&quot;&gt;the maximum number of sockets&lt;/a&gt;&lt;/code&gt; available.</source>
          <target state="translated">同时连接的节点的最大数量受同时已知的远程节点 &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of (Erlang) ports&lt;/a&gt;&lt;/code&gt; 可用的（Erlang）端口 &lt;code&gt;&lt;a href=&quot;#files_sockets&quot;&gt;the maximum number of sockets&lt;/a&gt;&lt;/code&gt; 或可用的套接字的最大数量限制。</target>
        </trans-unit>
        <trans-unit id="5d7d8a949becb40e83e6c856df21937f4d5e2fc4" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open Erlang ports is often by default 16,384. This limit can be configured at startup. For more information, see the &lt;code&gt;+Q&lt;/code&gt; command-line flag in the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">默认情况下，同时打开的Erlang端口的最大数目通常为16,384。可以在启动时配置此限制。有关更多信息，请参见ERTS 的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页中的 &lt;code&gt;+Q&lt;/code&gt; 命令行标志。</target>
        </trans-unit>
        <trans-unit id="dce3aefe9378fbdd7c23ba61275213a9e8f16e3c" translate="yes" xml:space="preserve">
          <source>The maximum number of simultaneously open files and sockets depends on &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of Erlang ports&lt;/a&gt;&lt;/code&gt; available, as well as on operating system-specific settings and limits.</source>
          <target state="translated">同时打开的文件和套接字 &lt;code&gt;&lt;a href=&quot;#ports&quot;&gt;the maximum number of Erlang ports&lt;/a&gt;&lt;/code&gt; 取决于可用的Erlang端口的最大数量，以及特定于操作系统的设置和限制。</target>
        </trans-unit>
        <trans-unit id="8a1ac7256c6f13dbae7b5e1d4141100c06ba3c37" translate="yes" xml:space="preserve">
          <source>The maximum size in words of the process. If set to zero, the heap size limit is disabled. &lt;code&gt;badarg&lt;/code&gt; is be thrown if the value is smaller than &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt; min_heap_size&lt;/a&gt;&lt;/code&gt;. The size check is only done when a garbage collection is triggered.</source>
          <target state="translated">该过程的最大字数。如果设置为零，则禁用堆大小限制。如果该值小于 &lt;code&gt;badarg&lt;/code&gt; 则抛出 &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt; min_heap_size&lt;/a&gt;&lt;/code&gt; 。仅当触发垃圾回收时才进行大小检查。</target>
        </trans-unit>
        <trans-unit id="b9d46ab9b300e30ac3d0d3879401107e372584e8" translate="yes" xml:space="preserve">
          <source>The maximum size in words of the process. If set to zero, the heap size limit is disabled. &lt;code&gt;badarg&lt;/code&gt; is be thrown if the value is smaller than &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt;min_heap_size&lt;/a&gt;&lt;/code&gt;. The size check is only done when a garbage collection is triggered.</source>
          <target state="translated">该过程的最大字数。如果设置为零，则禁用堆大小限制。如果该值小于 &lt;code&gt;badarg&lt;/code&gt; 则抛出 &lt;code&gt;&lt;a href=&quot;#process_flag_min_heap_size&quot;&gt;min_heap_size&lt;/a&gt;&lt;/code&gt; 。仅当触发垃圾回收时才进行大小检查。</target>
        </trans-unit>
        <trans-unit id="d4b6db39ece8aee304cbcf9157b862c4fb5ad3c9" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. See the &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; documentation for more details.</source>
          <target state="translated">&lt;code&gt;os:cmd&lt;/code&gt; 调用返回的最大数据大小。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="5ac1dd4626b925c247f9422c7d93ee30b6d58305" translate="yes" xml:space="preserve">
          <source>The maximum size of the data returned by the &lt;code&gt;os:cmd&lt;/code&gt; call. This option is a safety feature that should be used when the command executed can return a very large, possibly infinite, result.</source>
          <target state="translated">&lt;code&gt;os:cmd&lt;/code&gt; 调用返回的最大数据大小。此选项是一项安全功能，当执行的命令可以返回非常大的（可能是无限的）结果时，应使用该选项。</target>
        </trans-unit>
        <trans-unit id="585b754a1ab975e434f0ece6fc3dc6117a6bfa95" translate="yes" xml:space="preserve">
          <source>The maximum time that &lt;code&gt;Mnesia&lt;/code&gt; waits for other nodes to respond with a transaction recovery decision can be specified. The configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; defaults to &lt;code&gt;infinity&lt;/code&gt;, which can cause the indefinite hanging as mentioned earlier. However, if the parameter is set to a definite time period (for example, three minutes), &lt;code&gt;Mnesia&lt;/code&gt; then enforces a transaction recovery decision, if needed, to allow &lt;code&gt;Mnesia&lt;/code&gt; to continue with its startup procedure.</source>
          <target state="translated">可以指定 &lt;code&gt;Mnesia&lt;/code&gt; 等待其他节点响应事务恢复决策的最长时间。配置参数 &lt;code&gt;max_wait_for_decision&lt;/code&gt; 默认为 &lt;code&gt;infinity&lt;/code&gt; ，这可能导致无限期的挂起，如前所述。但是，如果将参数设置为确定的时间段（例如三分钟），则 &lt;code&gt;Mnesia&lt;/code&gt; 会在必要时执行事务恢复决策，以允许 &lt;code&gt;Mnesia&lt;/code&gt; 继续其启动过程。</target>
        </trans-unit>
        <trans-unit id="9c5051bd43e740038041f2bf25ed5638f7d0e3f3" translate="yes" xml:space="preserve">
          <source>The maximum total amount of memory allocated since the emulator was started. This tuple is only present when the emulator is run with instrumentation.</source>
          <target state="translated">仿真器启动后分配的最大内存总量。这个元组只在仿真器运行时存在。</target>
        </trans-unit>
        <trans-unit id="28e274b5f8dfecfd5eae3c1b1cfa72d55e0d6e66" translate="yes" xml:space="preserve">
          <source>The meaning of dollar can be changed so that it matches only at the very end of the string, by setting option &lt;code&gt;dollar_endonly&lt;/code&gt; at compile time. This does not affect the \Z assertion.</source>
          <target state="translated">通过在编译时设置选项 &lt;code&gt;dollar_endonly&lt;/code&gt; ，可以更改dollar的含义，使其仅在字符串的最后匹配。这不会影响\ Z断言。</target>
        </trans-unit>
        <trans-unit id="db8e327530c8b9b6b5b186cd76cf404392297a30" translate="yes" xml:space="preserve">
          <source>The meaning of the various quantifiers is not otherwise changed, only the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. As it has two uses, it can sometimes appear doubled, as in</source>
          <target state="translated">各个量词的含义并没有其他改变,只是优先匹配的数量。不要把问号的这种用法与它本身作为量词的用法相混淆。由于它有两种用法,有时会出现双倍的情况,如在</target>
        </trans-unit>
        <trans-unit id="f1fc58f8c2a19d894912d06c0debf88001c2723f" translate="yes" xml:space="preserve">
          <source>The meanings of the circumflex and dollar characters are changed if option &lt;code&gt;multiline&lt;/code&gt; is set. When this is the case, a circumflex matches immediately after internal newlines and at the start of the subject string. It does not match after a newline that ends the string. A dollar matches before any newlines in the string, and at the very end, when &lt;code&gt;multiline&lt;/code&gt; is set. When newline is specified as the two-character sequence CRLF, isolated CR and LF characters do not indicate newlines.</source>
          <target state="translated">如果设置了选项 &lt;code&gt;multiline&lt;/code&gt; 则更改了抑扬音符和美元字符的含义。在这种情况下，抑扬符会在内部换行符之后和主题字符串的开头立即匹配。在以字符串结尾的换行符之后，它不匹配。设置 &lt;code&gt;multiline&lt;/code&gt; 行时，一美元匹配字符串中的任何换行符，最后匹配。当将换行符指定为两个字符的序列CRLF时，孤立的CR和LF字符不表示换行符。</target>
        </trans-unit>
        <trans-unit id="8d91b3d8b6609ca598d50d85473759e345b88f58" translate="yes" xml:space="preserve">
          <source>The meanings of the packet types are as follows:</source>
          <target state="translated">数据包类型的含义如下:</target>
        </trans-unit>
        <trans-unit id="978fd2c6d0a38bb48b2e443f83d298392afa53c5" translate="yes" xml:space="preserve">
          <source>The measured node.</source>
          <target state="translated">被测节点。</target>
        </trans-unit>
        <trans-unit id="b3fced30f9f09acd4ae489f7a4cde9db12cd9cfb" translate="yes" xml:space="preserve">
          <source>The measurement (meas) module(s)</source>
          <target state="translated">测量(meas)模块</target>
        </trans-unit>
        <trans-unit id="9d1886cf663e0cdc7dac0d21c48bb994286f92d0" translate="yes" xml:space="preserve">
          <source>The measurement is done by iterating over the decode/encode function for approx 2 seconds per message and counting the number of decodes/encodes.</source>
          <target state="translated">测量是通过迭代每个消息的解码/编码功能约2秒,并计算解码/编码的数量来完成的。</target>
        </trans-unit>
        <trans-unit id="aec8fc6af742975da8742323e5863ba3c2976265" translate="yes" xml:space="preserve">
          <source>The measurements has been performed on a HP xw4600 Workstation with a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. Software versions was open source OTP R13B04 (megaco-3.14).</source>
          <target state="translated">测量是在惠普xw4600工作站上进行的,该工作站采用英特尔(R)酷睿(TM)2四核CPU Q9550 @ 2.83GHz,内存4GB,运行Ubuntu 10.04 x86_64,内核2.6.32-22-generic。软件版本为开源OTP R13B04(megaco-3.14)。</target>
        </trans-unit>
        <trans-unit id="da27fa76e8fffb1057bf1f02dde90d043e002af6" translate="yes" xml:space="preserve">
          <source>The meat of an instruction definition file are macro definitions. We have seen this macro definition before:</source>
          <target state="translated">指令定义文件的肉是宏定义。我们之前已经看过这个宏定义。</target>
        </trans-unit>
        <trans-unit id="11fdab7f175e9cbdaedcec8086470f147804557b" translate="yes" xml:space="preserve">
          <source>The mechanism for &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; as described in this section is also kept for backwards compatibility. However, the new logging API also introduces &lt;code&gt; logger_disk_log_h(3)&lt;/code&gt;, which is a logger handler that can print to multiple files using &lt;code&gt;disk_log(3)&lt;/code&gt;.</source>
          <target state="translated">还保留了本节中描述的 &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; 机制，以实现向后兼容。但是，新的日志记录API还引入了 &lt;code&gt; logger_disk_log_h(3)&lt;/code&gt; ，它是一个记录器处理程序，可以使用 &lt;code&gt;disk_log(3)&lt;/code&gt; 打印到多个文件。</target>
        </trans-unit>
        <trans-unit id="3cc922c4e05bd2a334377ee02802a916cd403417" translate="yes" xml:space="preserve">
          <source>The mechanism for &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; as described in this section is also kept for backwards compatibility. However, the new logging API also introduces &lt;code&gt;logger_disk_log_h(3)&lt;/code&gt;, which is a logger handler that can print to multiple files using &lt;code&gt;disk_log(3)&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，还将保留本节中描述的 &lt;code&gt;&lt;a href=&quot;#multi_file_logging&quot;&gt;multi-file error report logging&lt;/a&gt;&lt;/code&gt; 机制。但是，新的日志记录API还引入了 &lt;code&gt;logger_disk_log_h(3)&lt;/code&gt; ，它是一个记录器处理程序，可以使用 &lt;code&gt;disk_log(3)&lt;/code&gt; 打印到多个文件。</target>
        </trans-unit>
        <trans-unit id="aa0f7032a10e00f5b731f6ddebd729a428e75839" translate="yes" xml:space="preserve">
          <source>The mechanism for passing data is called &lt;code&gt;save_config&lt;/code&gt;. The idea is that one test case (or suite) can save the current value of &lt;code&gt;Config&lt;/code&gt;, or any list of key-value tuples, so that the next executing test case (or test suite) can read it. The configuration data is not saved permanently but can only be passed from one case (or suite) to the next.</source>
          <target state="translated">传递数据的机制称为 &lt;code&gt;save_config&lt;/code&gt; 。这个想法是，一个测试用例（或套件）可以保存 &lt;code&gt;Config&lt;/code&gt; 的当前值或任何键值元组列表，以便下一个正在执行的测试用例（或测试套件）可以读取它。配置数据不会永久保存，只能从一个案例（或套件）传递到下一个案例。</target>
        </trans-unit>
        <trans-unit id="d4a82246982edacf43dfbd803e39adbeb1684356" translate="yes" xml:space="preserve">
          <source>The mechanism is easiest explained by an example:</source>
          <target state="translated">这个机制最容易用一个例子来解释。</target>
        </trans-unit>
        <trans-unit id="8fa97754d61962935bb76075b6dc85939e815dbc" translate="yes" xml:space="preserve">
          <source>The memory allocated by the node in kilobytes.</source>
          <target state="translated">节点分配的内存,单位为千字节。</target>
        </trans-unit>
        <trans-unit id="298ac153c29e1852aa628eb9371283caf21dbef1" translate="yes" xml:space="preserve">
          <source>The memory allocated for code storage.</source>
          <target state="translated">分配给代码存储的内存。</target>
        </trans-unit>
        <trans-unit id="59e5363544c056808c214b7d5c9c6474a917a3b4" translate="yes" xml:space="preserve">
          <source>The memory allocation strategy used for multiblock carriers by an allocator can be configured using parameter &lt;code id=&quot;strategy&quot;&gt;&lt;a href=&quot;#M_as&quot;&gt;as&lt;/a&gt;&lt;/code&gt;. The following strategies are available:</source>
          <target state="translated">分配器用于多块载波的内存分配策略可以使用参数配置 &lt;code id=&quot;strategy&quot;&gt;&lt;a href=&quot;#M_as&quot;&gt;as&lt;/a&gt;&lt;/code&gt; 。可以使用以下策略：</target>
        </trans-unit>
        <trans-unit id="4d89b19b32b0be509163619bb6121106c1088a73" translate="yes" xml:space="preserve">
          <source>The memory consumption inflicted by both &lt;code&gt;write_concurrency&lt;/code&gt; and &lt;code&gt;read_concurrency&lt;/code&gt; is a constant overhead per table for &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt; and &lt;code&gt;duplicate_bag&lt;/code&gt;. For &lt;code&gt;ordered_set&lt;/code&gt; the memory overhead depends on the number of inserted objects and the amount of actual detected concurrency in runtime. The memory overhead can be especially large when both options are combined.</source>
          <target state="translated">通过既造成的内存消耗 &lt;code&gt;write_concurrency&lt;/code&gt; 和 &lt;code&gt;read_concurrency&lt;/code&gt; 是每个表的恒定开销 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; 和 &lt;code&gt;duplicate_bag&lt;/code&gt; 。对于 &lt;code&gt;ordered_set&lt;/code&gt; ，内存开销取决于插入的对象数和运行时实际检测到的并发量。当两个选项结合使用时，内存开销可能会特别大。</target>
        </trans-unit>
        <trans-unit id="8d175bff5507dd3c92a81b43fddcde2ca548264d" translate="yes" xml:space="preserve">
          <source>The memory use is in bytes.</source>
          <target state="translated">内存使用量以字节为单位。</target>
        </trans-unit>
        <trans-unit id="a3a1ae2cae0473b354552d179be5126c3e3c48c2" translate="yes" xml:space="preserve">
          <source>The menu bar contains a &lt;strong&gt;File&lt;/strong&gt; menu and a &lt;strong&gt;Help&lt;/strong&gt; menu. From the &lt;strong&gt;File&lt;/strong&gt; menu, a new crashdump can be loaded or the tool can be terminated. From the &lt;strong&gt;Help&lt;/strong&gt; menu, this User's Guide and section &quot;How to interpret the Erlang crash dumps&quot; from the ERTS application can be opened. &quot;How to interpret the Erlang crash dumps&quot; describes the raw crashdumps in detail and includes information about each field in the information pages.&quot;How to interpret the Erlang crash dumps&quot; is also available in the OTP online documentation.</source>
          <target state="translated">菜单栏包含&lt;strong&gt;文件&lt;/strong&gt;菜单和&lt;strong&gt;帮助&lt;/strong&gt;菜单。从&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;菜单中，可以加载新的崩溃转储或可以终止该工具。从&amp;ldquo; &lt;strong&gt;帮助&amp;rdquo;&lt;/strong&gt;菜单中，可以打开ERTS应用程序的本用户指南和&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;部分。&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;详细描述了原始的崩溃转储，并在信息页面中包含有关每个字段的信息。OTP联机文档中也提供了&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1da2ec9bc11a5f3d2243b7edb144004648c44860" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is received.</source>
          <target state="translated">收到消息 &lt;code&gt;Msg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bef16814b598901c6478a3fbd2f3f7dcb03410e5" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;Msg&lt;/code&gt; is sent to process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">消息 &lt;code&gt;Msg&lt;/code&gt; 被发送到进程 &lt;code&gt;Pid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d1b57d10ed917aa22d0a9edcd287e55b9528651" translate="yes" xml:space="preserve">
          <source>The message contains an &lt;code&gt;AncData&lt;/code&gt; field if any of the socket &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; are active, otherwise it does not.</source>
          <target state="translated">如果套接字 &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; 中的任何一个处于活动状态，则该消息都包含一个 &lt;code&gt;AncData&lt;/code&gt; 字段，否则它不处于活动状态。</target>
        </trans-unit>
        <trans-unit id="71ae0d247f0e17a4386f36f8054f2467e2f57cfc" translate="yes" xml:space="preserve">
          <source>The message environment &lt;code&gt;msg_env&lt;/code&gt; with all its terms (including &lt;code&gt;msg&lt;/code&gt;) is invalidated by a successful call to &lt;code&gt;enif_send&lt;/code&gt;. The environment is to either be freed with &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt; enif_free_env&lt;/a&gt;&lt;/code&gt; or cleared for reuse with &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt;. An unsuccessful call will leave &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;msg_env&lt;/code&gt; still valid.</source>
          <target state="translated">成功调用 &lt;code&gt;enif_send&lt;/code&gt; 会使消息环境 &lt;code&gt;msg_env&lt;/code&gt; 及其所有术语（包括 &lt;code&gt;msg&lt;/code&gt; ）失效。环境是要么与释放 &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt; enif_free_env&lt;/a&gt;&lt;/code&gt; 或清除与重用 &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt; 。调用失败将使 &lt;code&gt;msg&lt;/code&gt; 和 &lt;code&gt;msg_env&lt;/code&gt; 仍然有效。</target>
        </trans-unit>
        <trans-unit id="c2f87f0f2be084c26692c04f5569df347bc82216" translate="yes" xml:space="preserve">
          <source>The message environment &lt;code&gt;msg_env&lt;/code&gt; with all its terms (including &lt;code&gt;msg&lt;/code&gt;) is invalidated by a successful call to &lt;code&gt;enif_send&lt;/code&gt;. The environment is to either be freed with &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt;enif_free_env&lt;/a&gt;&lt;/code&gt; of cleared for reuse with &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;enif_send&lt;/code&gt; 将使消息环境 &lt;code&gt;msg_env&lt;/code&gt; 及其所有术语（包括 &lt;code&gt;msg&lt;/code&gt; ）失效。环境是要么与释放 &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt;enif_free_env&lt;/a&gt;&lt;/code&gt; 的清除与再利用 &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69095ad9f243cb8ca62108dfb3eb20c26f31c02d" translate="yes" xml:space="preserve">
          <source>The message is delivered as an Erlang binary and is decoded by the encoding module stated in the receive handle together with its encoding config (also in the receive handle). Depending of the outcome of the decoding various callback functions will be invoked. See megaco_user for more info about the callback arguments.</source>
          <target state="translated">消息以Erlang二进制的形式传递,并由接收句柄中所述的编码模块及其编码配置(也在接收句柄中)进行解码。根据解码的结果,各种回调函数将被调用。关于回调参数的更多信息请参见 megaco_user。</target>
        </trans-unit>
        <trans-unit id="53e2b8f523369c83642e4048ab82a3185ec3b76f" translate="yes" xml:space="preserve">
          <source>The message is to be sent unordered</source>
          <target state="translated">信息要无序发送</target>
        </trans-unit>
        <trans-unit id="f0a211d0180d304363ef532b16b38c1c8ed96d5c" translate="yes" xml:space="preserve">
          <source>The message provided by the caller is printed. This function is simply a wrapper for &lt;code&gt;fprintf()&lt;/code&gt;.</source>
          <target state="translated">将显示呼叫者提供的消息。该函数只是 &lt;code&gt;fprintf()&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="ffe40f2f91536a9ce70e2059a8564f8fe209a6da" translate="yes" xml:space="preserve">
          <source>The message queue is on the heap depending on the process flag &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt; message_queue_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息队列在堆上，具体取决于进程标志 &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt; message_queue_data&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="188062935a333dac8b9cbce97db717469f7ef85a" translate="yes" xml:space="preserve">
          <source>The message queue is on the heap depending on the process flag &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;message_queue_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息队列在堆上，具体取决于进程标志 &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;message_queue_data&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6d253006487349bbc06f18a3a3218a8846cc6f2" translate="yes" xml:space="preserve">
          <source>The message sent to another node using the '!' (in external format). Notice that &lt;code&gt;Message&lt;/code&gt; is only passed in combination with a &lt;code&gt;ControlMessage&lt;/code&gt; encoding a send ('!').</source>
          <target state="translated">使用&amp;ldquo;！&amp;rdquo;发送到另一个节点的消息 （以外部格式）。请注意，仅将 &lt;code&gt;Message&lt;/code&gt; 与编码发送（'！'）的 &lt;code&gt;ControlMessage&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="43778572593837e13ffe28e2a3efbd5850e3ed3d" translate="yes" xml:space="preserve">
          <source>The message sent to another node using the '!' or the reason for a EXIT, EXIT2 or DOWN signal using the external term format.</source>
          <target state="translated">使用'!'向另一个节点发送的信息,或者使用外部术语格式发送EXIT、EXIT2或DOWN信号的原因。</target>
        </trans-unit>
        <trans-unit id="70abf2b1b2393e6b5fc45fd84159e35d396bc02e" translate="yes" xml:space="preserve">
          <source>The message size is limited according to the values of configuration parameters &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt; chars_limit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息大小受配置参数 &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt; chars_limit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt; 的值限制。</target>
        </trans-unit>
        <trans-unit id="2508ed4b299c2e2a914cd2e173689088380e01ae" translate="yes" xml:space="preserve">
          <source>The message size is limited according to the values of configuration parameters &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt;chars_limit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息大小受配置参数 &lt;code&gt;&lt;a href=&quot;#chars_limit&quot;&gt;chars_limit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#depth&quot;&gt;depth&lt;/a&gt;&lt;/code&gt; 的值限制。</target>
        </trans-unit>
        <trans-unit id="6aa5e3b5fe2a2c9211425bda03965c4fecd38672" translate="yes" xml:space="preserve">
          <source>The message term to be appended to the trace message</source>
          <target state="translated">要附加到跟踪信息中的信息项。</target>
        </trans-unit>
        <trans-unit id="e0a0e8de3b2b246c6805a721cd7aa635b44ea3ae" translate="yes" xml:space="preserve">
          <source>The message term to send.</source>
          <target state="translated">要发送的信息术语。</target>
        </trans-unit>
        <trans-unit id="3ce448634c2b22e55f351fb0b4136cb15acbbb45" translate="yes" xml:space="preserve">
          <source>The message term to send. The same limitations apply as on the payload to &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要发送的消息项。相同的限制与对 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 的有效负载相同。</target>
        </trans-unit>
        <trans-unit id="fb35a1112b2aba4bb7f59c7ef2bd29e811541e66" translate="yes" xml:space="preserve">
          <source>The message term to send. The same limitations apply as on the payload to &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要发送的消息项。限制与 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 的有效负载相同。</target>
        </trans-unit>
        <trans-unit id="25ff1263e12ec9b56844ab9f45da012f6df9fa30" translate="yes" xml:space="preserve">
          <source>The message to be sent.</source>
          <target state="translated">要发送的信息。</target>
        </trans-unit>
        <trans-unit id="662e1568be87a93705ec3d52e5be7681c3dcae9b" translate="yes" xml:space="preserve">
          <source>The message transformation is done by the transformation module. It is used to transform a set of messages encoded with one codec into the other base codec's.</source>
          <target state="translated">信息转换是由转换模块完成的。它用于将一组用一种编解码器编码的信息转换为其他基础编解码器的信息。</target>
        </trans-unit>
        <trans-unit id="a6b6c69d826e90440ef04c40da105e31f980d5f0" translate="yes" xml:space="preserve">
          <source>The message will be delivered in the form of a &lt;code&gt;msghdr()&lt;/code&gt;, which may contain the source address (if socket not connected), a list of &lt;code&gt;cmsghdr_recv()&lt;/code&gt; (depends on what socket options have been set and what the protocol and platform supports) and also a set of flags, providing further info about the read.</source>
          <target state="translated">该消息将以 &lt;code&gt;msghdr()&lt;/code&gt; 的形式传递，其中可能包含源地址（如果未连接套接字）， &lt;code&gt;cmsghdr_recv()&lt;/code&gt; 列表（取决于已设置的套接字选项以及协议和平台支持的内容）还有一组标志，提供有关读取的更多信息。</target>
        </trans-unit>
        <trans-unit id="5f330d0749b4288239218bfd8721d9cc50f2048e" translate="yes" xml:space="preserve">
          <source>The messages used by the different tools are contained in single message package file (see below for more info). The messages in this file is encoded with just one codec. During measurement initiation, the messages are read and then transformed to all codec formats used in the measurement.</source>
          <target state="translated">不同工具所使用的信息包含在单一的信息包文件中(更多信息见下文)。该文件中的信息只用一个编解码器编码。在测量开始时,信息被读取,然后转换为测量中使用的所有编解码器格式。</target>
        </trans-unit>
        <trans-unit id="92b306bf0e70c78b5d09e95ccf216abcbe6cd2ba" translate="yes" xml:space="preserve">
          <source>The messenger is set up by allowing &quot;clients&quot; to connect to a central server and say who and where they are. That is, a user does not need to know the name of the Erlang node where another user is located to send a message.</source>
          <target state="translated">信使的设置是让 &quot;客户端 &quot;连接到中心服务器,并说出自己是谁,在哪里。也就是说,用户不需要知道另一个用户所在的Erlang节点的名字就可以发送消息。</target>
        </trans-unit>
        <trans-unit id="1b08f3d25f362366adcd8ed69b48375b76af1ceb" translate="yes" xml:space="preserve">
          <source>The messenger server traps exits. If it receives an exit signal, &lt;code&gt;{'EXIT',From,Reason}&lt;/code&gt;, this means that a client process has terminated or is unreachable for one of the following reasons:</source>
          <target state="translated">Messenger服务器陷阱出口。如果它收到退出信号 &lt;code&gt;{'EXIT',From,Reason}&lt;/code&gt; ，则表示客户端进程已终止或由于以下原因之一而无法访问：</target>
        </trans-unit>
        <trans-unit id="d73c2514c79c3ab7ddf5f518405430d4594740a9" translate="yes" xml:space="preserve">
          <source>The method used to implement distributed tables with this SNMP tool is to implement a table coordinator process responsible for coordinating the processes, which hold the table data and they are called table holders. All table holders must in some way be known by the coordinator; the structure of the table data determines how this is achieved. The coordinator may require that the table holders explicitly register themselves and specify their information. In other cases, the table holders can be determined once at compile time.</source>
          <target state="translated">用这种SNMP工具实现分布式表的方法是实现一个表协调器进程,负责协调各进程,这些进程持有表数据,它们被称为表持有者。所有的表持有者必须以某种方式被协调器所知道;表数据的结构决定了如何实现这一点。协调者可以要求表持有者明确地注册自己,并说明他们的信息。在其他情况下,表持有者可以在编译时确定一次。</target>
        </trans-unit>
        <trans-unit id="9aeb4d59c4a528fedb146161bc65731c3aab1a8a" translate="yes" xml:space="preserve">
          <source>The method used to present a distributed table is strongly application dependent. The use of different masking techniques is only valid for a small subset of problems and registering every row in a distributed table makes it non-distributed.</source>
          <target state="translated">用于呈现分布式表的方法强烈依赖于应用。使用不同的掩蔽技术只对一小部分问题有效,在分布式表中注册每一行都会使其成为非分布式表。</target>
        </trans-unit>
        <trans-unit id="63514a43185163391d03ee090dbfddf650488f7c" translate="yes" xml:space="preserve">
          <source>The mib storage is used by the agent to store internal mib- related information. The mib storage module is used by several entities, not just the mib-server.</source>
          <target state="translated">mib存储被代理用来存储内部mib相关信息。mib存储模块由多个实体使用,而不仅仅是mib服务器。</target>
        </trans-unit>
        <trans-unit id="ad8b1241bbc2dca232a25981fc82c4488c8627af" translate="yes" xml:space="preserve">
          <source>The middlebox compatibility mode is enabled (&lt;code&gt;true&lt;/code&gt;) by default.</source>
          <target state="translated">默认情况下，启用了中间盒兼容模式（ &lt;code&gt;true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="22c3dd445cc6fc863b70e9b3499332bc0735098f" translate="yes" xml:space="preserve">
          <source>The minimal setup is not the most secure setup of SSL/TLS/DTLS.</source>
          <target state="translated">最小化设置并不是SSL/TLS/DTLS最安全的设置。</target>
        </trans-unit>
        <trans-unit id="fae823e82c7b90be1db777854e986f26648c80a1" translate="yes" xml:space="preserve">
          <source>The minimal setup is not the most secure setup of TLS/DTLS.</source>
          <target state="translated">最小化设置并不是TLS/DTLS最安全的设置。</target>
        </trans-unit>
        <trans-unit id="1a717b6f86847b74e42485f2bb9e93125c968160" translate="yes" xml:space="preserve">
          <source>The minimal system based on Erlang/OTP, enabling release handling, thus consists of the Kernel, STDLIB, and SASL applications.</source>
          <target state="translated">基于Erlang/OTP的最小系统,实现发布处理,因此由Kernel、STDLIB和SASL应用组成。</target>
        </trans-unit>
        <trans-unit id="07c2b5af828a95564e2ccf73c84d39aeac748a78" translate="yes" xml:space="preserve">
          <source>The minimum size of the receive buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; to retrieve the size set by your operating system.</source>
          <target state="translated">用于套接字的接收缓冲区的最小大小。建议您使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 来检索操作系统设置的大小。</target>
        </trans-unit>
        <trans-unit id="8abc7d7fd3d2b168dd30ef9b33fd46de95e55a93" translate="yes" xml:space="preserve">
          <source>The minimum size of the send buffer to use for the socket. You are encouraged to use &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;, to retrieve the size set by your operating system.</source>
          <target state="translated">用于套接字的发送缓冲区的最小大小。建议您使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 来检索操作系统设置的大小。</target>
        </trans-unit>
        <trans-unit id="93c141a41e5c2b8def9103d7ce340d86a71ca3c9" translate="yes" xml:space="preserve">
          <source>The minor log files contain full details of every single test case, each in a separate file. This way, it is straightforward to compare the latest results to that of previous test runs, even if the set of test cases changes. If application SASL is running, its logs are also printed to the current minor log file by the &lt;code&gt; cth_log_redirect built-in hook&lt;/code&gt;.</source>
          <target state="translated">次要日志文件包含每个测试用例的完整详细信息，每个都在单独的文件中。这样，即使测试用例集发生了变化，也可以将最新结果与以前的测试结果进行比较。如果应用程序SASL正在运行，则还可以通过 &lt;code&gt; cth_log_redirect built-in hook&lt;/code&gt; 的cth_log_redirect钩子将其日志打印到当前的次要日志文件中。</target>
        </trans-unit>
        <trans-unit id="3eddcd151845fa0f558f92cf054830bab732faab" translate="yes" xml:space="preserve">
          <source>The minor log files contain full details of every single test case, each in a separate file. This way, it is straightforward to compare the latest results to that of previous test runs, even if the set of test cases changes. If application SASL is running, its logs are also printed to the current minor log file by the &lt;code&gt;cth_log_redirect built-in hook&lt;/code&gt;.</source>
          <target state="translated">次要日志文件包含每个测试用例的完整详细信息，每个都在单独的文件中。这样，即使测试用例集发生了变化，也可以将最新结果与以前的测试结果进行比较。如果应用程序SASL正在运行，则还可以通过 &lt;code&gt;cth_log_redirect built-in hook&lt;/code&gt; 的cth_log_redirect钩子将其日志打印到当前的次要日志文件中。</target>
        </trans-unit>
        <trans-unit id="3658d2cb7add73fe309b90a8d098bef38a4ef76d" translate="yes" xml:space="preserve">
          <source>The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class, or immediately after a range. For example, [b-d-z] matches letters in the range b to d, a hyphen character, or z.</source>
          <target state="translated">减号(连字符)字符可以用来指定字符类中的字符范围。例如,[d-m]匹配d和m之间的任何字母,包括在内。如果在一个类中需要使用减号,那么它必须用反斜线转义,或者出现在一个不能被解释为表示范围的位置,通常是作为类中的第一个或最后一个字符,或者紧接在一个范围之后。例如,[b-d-z]匹配范围为b到d的字母、连字符或z。</target>
        </trans-unit>
        <trans-unit id="9af303642ed501803e879dc12b0614d63b8151b7" translate="yes" xml:space="preserve">
          <source>The missing time can be found in the paragraph for &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; where it is evident that not only &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; is called but also a fun:</source>
          <target state="translated">缺少的时间可以在 &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 的段落中找到，很明显不仅 &lt;code&gt;prim_file:drv_command/2&lt;/code&gt; 还很有趣：</target>
        </trans-unit>
        <trans-unit id="606631313d3f4e567c75d609d36257f0ff021b82" translate="yes" xml:space="preserve">
          <source>The mode enables the use of non-atom states, for example, complex states or even hierarchical states. See section &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt;. If, for example, a state diagram is largely alike for the client side and the server side of a protocol, you can have a state &lt;code&gt;{StateName,server}&lt;/code&gt; or &lt;code&gt;{StateName,client}&lt;/code&gt;, and make &lt;code&gt;StateName&lt;/code&gt; determine where in the code to handle most events in the state. The second element of the tuple is then used to select whether to handle special client-side or server-side events.</source>
          <target state="translated">该模式允许使用非原子状态，例如，复杂状态甚至是分层状态。请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 部分。例如，如果协议的客户端和服务器端的状态图在很大程度上相似，则可以有一个状态 &lt;code&gt;{StateName,server}&lt;/code&gt; 或 &lt;code&gt;{StateName,client}&lt;/code&gt; ，并让 &lt;code&gt;StateName&lt;/code&gt; 确定代码中要处理的位置该州的大多数事件。然后，该元组的第二个元素用于选择处理特殊的客户端事件还是服务器端事件。</target>
        </trans-unit>
        <trans-unit id="3df12d375f53e99cfbf07745ca874b2ef99ea054" translate="yes" xml:space="preserve">
          <source>The mode flag &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; and the return flags &lt;code&gt;ERL_NIF_SELECT_READ_CANCELLED&lt;/code&gt; and &lt;code&gt;ERL_NIF_SELECT_WRITE_CANCELLED&lt;/code&gt; were introduced in erts-11.0 (OTP-22.0).</source>
          <target state="translated">在erts-11.0（OTP-22.0）中引入了模式标志 &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; 和返回标志 &lt;code&gt;ERL_NIF_SELECT_READ_CANCELLED&lt;/code&gt; 和 &lt;code&gt;ERL_NIF_SELECT_WRITE_CANCELLED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b970edef5d2db822eb3139eed01662d797b2d6c5" translate="yes" xml:space="preserve">
          <source>The mode properties are as follows:</source>
          <target state="translated">模式属性如下:</target>
        </trans-unit>
        <trans-unit id="c74fbe5e44daec131d6f8bb6c1035938c0451e49" translate="yes" xml:space="preserve">
          <source>The mode where data is pumped through the port and the &lt;code&gt;uds_command&lt;/code&gt; routine regards every call as a call where sending is wanted. In this mode, all input available is read and sent to Erlang when it arrives on the socket, much like in the active mode of a &lt;code&gt;gen_tcp&lt;/code&gt; socket.</source>
          <target state="translated">通过端口和 &lt;code&gt;uds_command&lt;/code&gt; 例程泵送数据的模式将每个调用视为需要发送的调用。在这种模式下，所有可用的输入都会在到达套接字时被读取并发送给Erlang，就像在 &lt;code&gt;gen_tcp&lt;/code&gt; 套接字的活动模式下一样。</target>
        </trans-unit>
        <trans-unit id="881eb04bb7f343c8b06f98508313f6d367c9da3f" translate="yes" xml:space="preserve">
          <source>The modes are as follows:</source>
          <target state="translated">这些模式如下:</target>
        </trans-unit>
        <trans-unit id="22f36ac434028664a5e69ab508016c7df24b7383" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; provides an alternate compilation interface.</source>
          <target state="translated">模块 &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; 提供了一个备用编译接口。</target>
        </trans-unit>
        <trans-unit id="9d77399e5aec1944b1adc6c9df8b906d840bfd80" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Mod&lt;/code&gt; referred to must be found in the code path and data returned by the function &lt;code&gt;Func&lt;/code&gt; is passed back to the client. Data returned from the function must take the form as specified in the CGI specification. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须在代码路径中找到所引用的模块 &lt;code&gt;Mod&lt;/code&gt; ，并将功能 &lt;code&gt;Func&lt;/code&gt; 返回的数据传递回客户端。从函数返回的数据必须采用CGI规范中指定的格式。有关ESI回调函数的实现细节，请参见 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29ac46e3b904139d6e66b6ec6030181dc36b417e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;Module&lt;/code&gt; referred to must be found in the code path, and it must define a function &lt;code&gt;Function&lt;/code&gt; with an arity of two or three. It is preferable to implement a function with arity three, as it permits to send chunks of the web page to the client during the generation phase instead of first generating the whole web page and then sending it to the client. The option to implement a function with arity two is only kept for backwards compatibility reasons. For implementation details of the ESI callback function, see &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所引用的模块 &lt;code&gt;Module&lt;/code&gt; 必须在代码路径中找到，并且必须定义一个具有两个或三个Arity的功能 &lt;code&gt;Function&lt;/code&gt; 。最好实现具有三项的功能，因为它允许在生成阶段将网页的大块内容发送给客户端，而不是先生成整个网页然后再将其发送给客户端。仅出于向后兼容的原因保留保留使用Arity 2的功能的选项。有关ESI回调函数的实现细节，请参见 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="982c2295d64987c5a6f9815d8a88586d4220b412" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1ct&lt;/code&gt;, which provides the compile-time functions (including the compiler)</source>
          <target state="translated">模块 &lt;code&gt;asn1ct&lt;/code&gt; ，提供编译时函数（包括编译器）</target>
        </trans-unit>
        <trans-unit id="a79e4d001488233c5a176bdd084c0905e60ecc9c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;asn1rt_nif&lt;/code&gt;, which provides the runtime functions for the ASN.1 decoder for the BER back end</source>
          <target state="translated">模块 &lt;code&gt;asn1rt_nif&lt;/code&gt; ，为BER后端的ASN.1解码器提供运行时功能</target>
        </trans-unit>
        <trans-unit id="9ef07ceefb72a3876e128fd3d25802cdcc467713" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;code&gt;&lt;a href=&quot;#lines&quot;&gt;executable line&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">模块 &lt;code&gt;cover&lt;/code&gt; 提供了一组用于Erlang程序的覆盖率分析的功能，计算了每个 &lt;code&gt;&lt;a href=&quot;#lines&quot;&gt;executable line&lt;/a&gt;&lt;/code&gt; 的执行次数。</target>
        </trans-unit>
        <trans-unit id="781caf54426d4fb478a304a7844ea80922cfcec9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;cover&lt;/code&gt; provides a set of functions for coverage analysis of Erlang programs, counting how many times each &lt;strong&gt;executable line&lt;/strong&gt; of code is executed when a program is run.</source>
          <target state="translated">模块 &lt;code&gt;cover&lt;/code&gt; 提供了一组用于Erlang程序的覆盖率分析的功能，计算了程序运行时每个&lt;strong&gt;可执行&lt;/strong&gt;代码&lt;strong&gt;行&lt;/strong&gt;执行了多少次。</target>
        </trans-unit>
        <trans-unit id="0f91e217601b1dc046c35185750c3cff89af0626" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;eprof&lt;/code&gt; provides a set of functions for time profiling of Erlang programs to find out how the execution time is used. The profiling is done using the Erlang trace BIFs. Tracing of local function calls for a specified set of processes is enabled when profiling is begun, and disabled when profiling is stopped.</source>
          <target state="translated">&lt;code&gt;eprof&lt;/code&gt; 模块提供了一组用于对Erlang程序进行时间分析的功能，以了解如何使用执行时间。使用Erlang跟踪BIF完成分析。在开始分析时启用对指定进程集的本地函数调用的跟踪，而在停止分析时禁用跟踪。</target>
        </trans-unit>
        <trans-unit id="c504d09107327f4319315c36b9c3bb90edddcb97" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_display_demo.erl&lt;/code&gt; illustrates how it can be used:</source>
          <target state="translated">&lt;code&gt;et/examples/et_display_demo.erl&lt;/code&gt; 模块说明了如何使用它：</target>
        </trans-unit>
        <trans-unit id="259f6a111f8e10963d253f6c20a7ce32cd0fbcc2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;et/examples/et_trace_demo.erl&lt;/code&gt; achieves this.</source>
          <target state="translated">模块 &lt;code&gt;et/examples/et_trace_demo.erl&lt;/code&gt; 实现了此目的。</target>
        </trans-unit>
        <trans-unit id="2e6fc57c9903415812e7aa14d0de98a4a3c76906" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;init&lt;/code&gt; contains functions for restarting, rebooting, and stopping the runtime system:</source>
          <target state="translated">模块 &lt;code&gt;init&lt;/code&gt; 包含用于重新启动，重新引导和停止运行时系统的功能：</target>
        </trans-unit>
        <trans-unit id="3abc6c505ceadd88e545ffef89881ad4330aca42" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;instrument&lt;/code&gt; contains support for studying the resource usage in an Erlang runtime system. Currently, only the allocation of memory can be studied.</source>
          <target state="translated">模块 &lt;code&gt;instrument&lt;/code&gt; 包含用于研究Erlang运行时系统中资源使用情况的支持。目前，只能研究内存的分配。</target>
        </trans-unit>
        <trans-unit id="941709a144919cb9d4879d80ca49d5703f70c432" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;lists&lt;/code&gt; contains many functions for manipulating lists, for example, for reversing them. So before writing a list-manipulating function it is a good idea to check if one not already is written for you (see the &lt;code&gt;lists(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">模块 &lt;code&gt;lists&lt;/code&gt; 包含许多用于操作列表的功能，例如用于反转它们。因此，在编写列表操作函数之前，最好检查一下是否尚未为您编写一个（请参见STDLIB中的 &lt;code&gt;lists(3)&lt;/code&gt; 手册页）。</target>
        </trans-unit>
        <trans-unit id="0b557c4c0674c40fdfca518a79b00693470cbb4b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;make&lt;/code&gt; provides a set of functions similar to the UNIX type &lt;code&gt;Make&lt;/code&gt; functions.</source>
          <target state="translated">模块 &lt;code&gt;make&lt;/code&gt; 提供了一组类似于UNIX类型的 &lt;code&gt;Make&lt;/code&gt; functions的函数。</target>
        </trans-unit>
        <trans-unit id="d33a6d96eeffbee10dd02fa8fc1a44592f775997" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;mod_cgi&lt;/code&gt; enables execution of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;CGI scripts&lt;/a&gt;&lt;/code&gt; on the server. A file matching the definition of a ScriptAlias config directive is treated as a CGI script. A CGI script is executed by the server and its output is returned to the client.</source>
          <target state="translated">模块 &lt;code&gt;mod_cgi&lt;/code&gt; 允许在服务器上执行 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;CGI scripts&lt;/a&gt;&lt;/code&gt; 。与ScriptAlias config指令的定义匹配的文件被视为CGI脚本。服务器执行CGI脚本，并将其输出返回给客户端。</target>
        </trans-unit>
        <trans-unit id="89aebd55be35237517f0292d086307a4abfce4d9" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp&lt;/code&gt; contains interface functions to the SNMP toolkit.</source>
          <target state="translated">&lt;code&gt;snmp&lt;/code&gt; 模块包含SNMP工具包的接口功能。</target>
        </trans-unit>
        <trans-unit id="a28864fb1efef12bf7914da0d813b6fa91aa2615" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_community_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-COMMUNITY-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_community_mib&lt;/code&gt; 实现SNMP-COMMUNITY-MIB的工具功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="ef3d7428030a1ee96b52a462582efaf9645f114a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_framework_mib&lt;/code&gt; implements instrumentation functions for the SNMP-FRAMEWORK-MIB, and functions for initializing and configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_framework_mib&lt;/code&gt; 实现SNMP-FRAMEWORK-MIB的检测功能，以及用于初始化和配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="095f5718c68bbc524071ea724e79d3350f41b68e" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_generic&lt;/code&gt; contains generic functions for implementing tables (and variables) using the SNMP built-in database or Mnesia. These default functions are used if no instrumentation function is provided for a managed object in a MIB. Sometimes, it might be necessary to customize the behaviour of the default functions. For example, in some situations a trap should be sent if a row is deleted or modified, or some hardware is to be informed, when information is changed.</source>
          <target state="translated">&lt;code&gt;snmp_generic&lt;/code&gt; 模块包含用于使用SNMP内置数据库或Mnesia实现表（和变量）的通用函数。如果没有为MIB中的管理对象提供检测功能，则使用这些默认功能。有时，可能有必要自定义默认功能的行为。例如，在某些情况下，如果在更改信息时删除或修改了行，或者要通知某些硬件，则应该发送陷阱。</target>
        </trans-unit>
        <trans-unit id="82a890681bf1941535370d5663cafcbba66ae605" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_index&lt;/code&gt; implements an Abstract Data Type (ADT) for an SNMP index structure for SNMP tables. It is implemented as an ets table of the ordered_set data-type, which means that all operations are O(log n). In the table, the key is an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">&lt;code&gt;snmp_index&lt;/code&gt; 模块为SNMP表的SNMP索引结构实现了抽象数据类型（ADT）。它被实现为ordered_set数据类型的ets表，这意味着所有操作都是O（log n）。在表中，密钥是ASN.1对象标识符。</target>
        </trans-unit>
        <trans-unit id="e2f9fd8895a2ad05f79cba6aa4a560674948ff16" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_notification_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-NOTIFICATION-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_notification_mib&lt;/code&gt; 实现SNMP-NOTIFICATION-MIB的检测功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="4f8a67bb8f067e1a717000055707220ab821c05a" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_pdus&lt;/code&gt; contains functions for encoding and decoding of SNMP protocol data units (PDUs). In short, this module converts a list of bytes to Erlang record representations and vice versa. The record definitions can be found in the file &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt;. If snmpv3 is used, the module that includes &lt;code&gt;snmp_types.hrl&lt;/code&gt; must define the constant &lt;code&gt;SNMP_USE_V3&lt;/code&gt; before the header file is included. Example:</source>
          <target state="translated">&lt;code&gt;snmp_pdus&lt;/code&gt; 模块包含用于SNMP协议数据单元（PDU）的编码和解码的功能。简而言之，该模块将字节列表转换为Erlang记录表示，反之亦然。记录定义可以在文件 &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt; 中找到。如果使用snmpv3，则在包含头文件之前，包含 &lt;code&gt;snmp_types.hrl&lt;/code&gt; 的模块必须定义常量 &lt;code&gt;SNMP_USE_V3&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="5725f0842bc0666fa7d375bd7f8ddd2c680d73f4" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_standard_mib&lt;/code&gt; implements the instrumentation functions for the STANDARD-MIB and SNMPv2-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 实现了STANDARD-MIB和SNMPv2-MIB的检测功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="9794cfac19d7a807e63c08b3a5fe1b5a39649e0d" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_target_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-TARGET-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_target_mib&lt;/code&gt; 实现SNMP-TARGET-MIB的检测功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="3f6c026f9e309eb46ab31fc9b2d89fed73cf8841" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_user_based_sm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-USER-BASED-SM-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_user_based_sm_mib&lt;/code&gt; 实现SNMP-USER-BASED-SM-MIB的检测功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="57a4fcf0421c558f55d4b62d7f4d570a983d47de" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmp_view_based_acm_mib&lt;/code&gt; implements the instrumentation functions for the SNMP-VIEW-BASED-ACM-MIB, and functions for configuring the database.</source>
          <target state="translated">模块 &lt;code&gt;snmp_view_based_acm_mib&lt;/code&gt; 实现SNMP-VIEW-BASED-ACM-MIB的检测功能，以及用于配置数据库的功能。</target>
        </trans-unit>
        <trans-unit id="cb84eb23430061b5d0ba52fb1f1dcb8cae6958c3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa&lt;/code&gt; contains interface functions to the SNMP agent.</source>
          <target state="translated">&lt;code&gt;snmpa&lt;/code&gt; 模块包含SNMP代理的接口功能。</target>
        </trans-unit>
        <trans-unit id="2cc8950e817bfb35a3a5269149811e72d9216ab2" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP agent.</source>
          <target state="translated">&lt;code&gt;snmpa_conf&lt;/code&gt; 模块包含各种实用程序功能，用于操纵（写入/附加/读取）SNMP代理的配置文件。</target>
        </trans-unit>
        <trans-unit id="9c00aa92168aea59cf4babd7411c60aa30b9bb12" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error&lt;/code&gt; contains two callback functions which are called if an error occurs at different times during agent operation. These functions in turn calls the corresponding function in the configured error report module, which implements the actual report functionality.</source>
          <target state="translated">&lt;code&gt;snmpa_error&lt;/code&gt; 模块包含两个回调函数，如果在代理操作期间的不同时间发生错误，则将调用这两个回调函数。这些功能依次调用已配置的错误报告模块中的相应功能，该模块实现了实际的报告功能。</target>
        </trans-unit>
        <trans-unit id="7764fca7b7977a857a18cfe1fc6018c7939c753c" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_io&lt;/code&gt; implements the &lt;code&gt;snmp_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="translated">模块 &lt;code&gt;snmpa_error_io&lt;/code&gt; 实现了 &lt;code&gt;snmp_error_report&lt;/code&gt; 行为（请参阅 &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt; ），该行为包含两个回调函数，这些函数被调用以报告SNMP错误。</target>
        </trans-unit>
        <trans-unit id="5fb427e1b1c2244f167076a6c28620f6bd0ca500" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_error_logger&lt;/code&gt; implements the &lt;code&gt;snmpa_error_report&lt;/code&gt; behaviour (see &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt;) containing two callback functions which are called in order to report SNMP errors.</source>
          <target state="translated">&lt;code&gt;snmpa_error_logger&lt;/code&gt; 模块实现 &lt;code&gt;snmpa_error_report&lt;/code&gt; 行为（请参阅 &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;snmpa_error_report&lt;/a&gt;&lt;/code&gt; ），该行为包含两个回调函数，这些函数被调用以报告SNMP错误。</target>
        </trans-unit>
        <trans-unit id="83bb96f4babc6a5eacc014cc415f81b568ec9857" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_local_db&lt;/code&gt; contains functions for implementing tables (and variables) using the SNMP built-in database. The database exists in two instances, one volatile and one persistent. The volatile database is implemented with ets. The persistent database is implemented with dets.</source>
          <target state="translated">&lt;code&gt;snmpa_local_db&lt;/code&gt; 模块包含用于使用SNMP内置数据库实现表（和变量）的函数。该数据库有两种情况，一种是易失性的，一种是持久性的。易失性数据库是用ets实现的。持久数据库是使用dets实现的。</target>
        </trans-unit>
        <trans-unit id="55631c2398416971197f57a07cee463eafb2a6d3" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpa_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the agent. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Definition of Agent Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;snmpa_mpd&lt;/code&gt; 模块在SNMP中为代理实现了版本无关的消息处理和调度功能。应该在网络接口过程中使用它（ &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Definition of Agent Net if&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="124a2b3f4d74eeec626680e394ad1513621980ef" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpc&lt;/code&gt; contains interface functions to the SNMP toolkit MIB compiler.</source>
          <target state="translated">&lt;code&gt;snmpc&lt;/code&gt; 模块包含SNMP工具包MIB编译器的接口功能。</target>
        </trans-unit>
        <trans-unit id="c53e4bdf4bb95582196719c70dc1fba81cd26c5b" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm&lt;/code&gt; contains interface functions to the SNMP manager.</source>
          <target state="translated">&lt;code&gt;snmpm&lt;/code&gt; 模块包含SNMP管理器的接口功能。</target>
        </trans-unit>
        <trans-unit id="9deea834f053c18dad6106ffd7fd172a36d88d96" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_conf&lt;/code&gt; contains various utility functions to used for manipulating (write/append/read) the config files of the SNMP manager.</source>
          <target state="translated">&lt;code&gt;snmpm_conf&lt;/code&gt; 模块包含各种实用程序功能，这些功能用于操纵（写入/附加/读取）SNMP管理器的配置文件。</target>
        </trans-unit>
        <trans-unit id="f85a168a189fdceec5a2d241d8dfe3e80b2124a7" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;snmpm_mpd&lt;/code&gt; implements the version independent Message Processing and Dispatch functionality in SNMP for the manager. It is supposed to be used from a Network Interface process (&lt;code&gt;&lt;a href=&quot;snmp_manager_netif&quot;&gt;Definition of Manager Net if&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;snmpm_mpd&lt;/code&gt; 模块为管理器在SNMP中实现了版本无关的消息处理和调度功能。应该从网络接口进程（ &lt;code&gt;&lt;a href=&quot;snmp_manager_netif&quot;&gt;Definition of Manager Net if&lt;/a&gt;&lt;/code&gt; ）中使用它。</target>
        </trans-unit>
        <trans-unit id="301e9d486412f01bcf2672b9abce6a87a421abaf" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;unicode&lt;/code&gt; even supports similar mixes with binaries containing other encodings than UTF-8, but that is a special case to allow for conversions to and from external data:</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 模块甚至还支持将二进制文件与UTF-8以外的其他二进制文件进行类似的混合，但这是允许与外部数据进行相互转换的一种特殊情况：</target>
        </trans-unit>
        <trans-unit id="36591fbbad4d0a32aa408280d9af7fb21f38f345" translate="yes" xml:space="preserve">
          <source>The module begins with the usual directives, a function to start the I/O server and a main loop handling the requests:</source>
          <target state="translated">该模块以通常的指令开始,一个启动I/O服务器的函数和一个处理请求的主循环。</target>
        </trans-unit>
        <trans-unit id="517094b39f1e8298c34a64523b0a81f6e27a7939" translate="yes" xml:space="preserve">
          <source>The module can be used as follows:</source>
          <target state="translated">该模块可用于以下方面:</target>
        </trans-unit>
        <trans-unit id="84b7dab89c3e12645bda4285fa81fa7ba3e89769" translate="yes" xml:space="preserve">
          <source>The module can now be checked for calls to &lt;code&gt;&lt;a href=&quot;xref#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;xref#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions:</source>
          <target state="translated">现在可以检查模块是否 &lt;code&gt;&lt;a href=&quot;xref#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;xref#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 以及未使用的本地函数：</target>
        </trans-unit>
        <trans-unit id="b501a9e25197a0d2d4d8c4d153e95197c1dc5515" translate="yes" xml:space="preserve">
          <source>The module check and the predefined analyses are useful, but limited. Sometimes more flexibility is needed, for instance one might not need to apply a graph analysis on all calls, but some subset will do equally well. That flexibility is provided with a simple language. Below are some expressions of the language with comments, focusing on elements of the language rather than providing useful examples. The analyzed system is assumed to be OTP, so in order to run the queries, first evaluate these calls:</source>
          <target state="translated">模块检查和预定义的分析是有用的,但有限。有时需要更多的灵活性,例如,人们可能不需要对所有的调用都应用图分析,但一些子集同样可以做到这一点。这种灵活性是用一种简单的语言提供的。下面是该语言的一些表达方式,并附有注释,重点是该语言的要素,而不是提供有用的例子。假设被分析的系统是OTP,所以为了运行查询,首先评估这些调用。</target>
        </trans-unit>
        <trans-unit id="9f34c93923a124126ae9987ed5ba7d0cd3a880a0" translate="yes" xml:space="preserve">
          <source>The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.</source>
          <target state="translated">该模块不属于任何一个应用程序Kernel、STDLIB、GS或Debugger。</target>
        </trans-unit>
        <trans-unit id="df43f32272eb4d398f8b34dc6bda83d31dc742c2" translate="yes" xml:space="preserve">
          <source>The module exports the following functions:</source>
          <target state="translated">该模块输出的功能如下:</target>
        </trans-unit>
        <trans-unit id="a8324f5d5b875808800ad4bfccc10ff9a5ba92ef" translate="yes" xml:space="preserve">
          <source>The module has an &lt;code&gt;-on_load function&lt;/code&gt; that failed when it was called.</source>
          <target state="translated">该模块具有 &lt;code&gt;-on_load function&lt;/code&gt; ，该函数在调用时失败。</target>
        </trans-unit>
        <trans-unit id="a549a328785c37eb26a4d0b0876090f69d89f62f" translate="yes" xml:space="preserve">
          <source>The module has been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="translated">该模块已使用选项 &lt;code&gt;debug_info&lt;/code&gt; 设置进行编译。</target>
        </trans-unit>
        <trans-unit id="4009d0d64b6afc399eea7069fcbf0bea4113eca2" translate="yes" xml:space="preserve">
          <source>The module has not been compiled with option &lt;code&gt;debug_info&lt;/code&gt; set.</source>
          <target state="translated">尚未使用选项 &lt;code&gt;debug_info&lt;/code&gt; 设置编译该模块。</target>
        </trans-unit>
        <trans-unit id="61d3758ed9d8815ae40a582326b2d576731c58d3" translate="yes" xml:space="preserve">
          <source>The module implementing the default user. See the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">实现默认用户的模块。请参阅 &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="fe23ad179f5f9873e787ab5795940184c64fca89" translate="yes" xml:space="preserve">
          <source>The module implementing this behaviour shall be supplied to to the servers configuration with the option &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt; customize&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">实现该行为的模块应通过 &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt; customize&lt;/a&gt;&lt;/code&gt; 选项提供给服务器配置</target>
        </trans-unit>
        <trans-unit id="c0b8a7cb2b22e6ad5a3d1b43145f3b8010311a6a" translate="yes" xml:space="preserve">
          <source>The module implementing this behaviour shall be supplied to to the servers configuration with the option &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt;customize&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">执行此行为的模块应通过 &lt;code&gt;&lt;a href=&quot;httpd#prop_customize&quot;&gt;customize&lt;/a&gt;&lt;/code&gt; 选项提供给服务器配置</target>
        </trans-unit>
        <trans-unit id="b66eedc6242758f2f48c0f5c1e1f06419d138c4f" translate="yes" xml:space="preserve">
          <source>The module is provided according to Erlang Enhancement Proposal (EEP) 31.</source>
          <target state="translated">该模块是根据Erlang增强提案(EEP)31提供的。</target>
        </trans-unit>
        <trans-unit id="e32c3dc9ba3ffd5afe1da65ac5bac03e04a15fd8" translate="yes" xml:space="preserve">
          <source>The module name of the event handler.</source>
          <target state="translated">事件处理程序的模块名称。</target>
        </trans-unit>
        <trans-unit id="329e9b070ed603033e7dd3e45d35cd86f7bb6554" translate="yes" xml:space="preserve">
          <source>The module needs to create some kind of listening entity (process or port) and an acceptor process that accepts incoming connections using the listening entity. For each connection, the module at least needs to create one connection supervisor process, which also is responsible for the handshake when setting up the connection, and a distribution controller (process or port) responsible for transport of data over the connection. The distribution controller and the connection supervisor process should be linked together so both of them are cleaned up when the connection is taken down.</source>
          <target state="translated">该模块需要创建某种监听实体(进程或端口)和使用监听实体接受传入连接的接受者进程。对于每个连接,模块至少需要创建一个连接监督者进程,该进程还负责建立连接时的握手,以及一个分配控制器(进程或端口),负责通过连接传输数据。分发控制器和连接监督进程应该连接在一起,这样当连接被关闭时,这两个进程就会被清理掉。</target>
        </trans-unit>
        <trans-unit id="776843428300b7454ef9f3b64437a0637201259c" translate="yes" xml:space="preserve">
          <source>The module supports &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; in the way that if a binary is present, or the filename cannot be interpreted according to the return value of &lt;code&gt; file:native_name_encoding/0&lt;/code&gt;, a raw filename is also returned. For example, &lt;code&gt;join/1&lt;/code&gt; provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">该模块以以下方式支持 &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; ：如果存在二进制文件，或者无法根据 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 的返回值解释文件名，则还返回原始文件名。例如， &lt;code&gt;join/1&lt;/code&gt; 所提供的路径组件是二进制文件（无法使用当前的本机文件名编码进行解释）会导致返回原始文件名（当然会执​​行join操作）。有关原始文件名的更多信息，请参见 &lt;code&gt;file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="5a0efe94bfa8ce9cd46e5764feb6320f9f30baae" translate="yes" xml:space="preserve">
          <source>The module supports &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; in the way that if a binary is present, or the filename cannot be interpreted according to the return value of &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, a raw filename is also returned. For example, &lt;code&gt;join/1&lt;/code&gt; provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">该模块以以下方式支持 &lt;code&gt;&lt;a href=&quot;unicode_usage#notes-about-raw-filenames&quot;&gt;raw filenames&lt;/a&gt;&lt;/code&gt; ：如果存在二进制文件，或者无法根据 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 的返回值解释文件名，则还返回原始文件名。例如， &lt;code&gt;join/1&lt;/code&gt; 提供的路径组件是二进制文件（无法使用当前的本地文件名编码进行解释）会导致返回原始文件名（当然会执​​行join操作）。有关原始文件名的更多信息，请参见 &lt;code&gt;file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="69b8aad69f452e4e151ee9bedf58e923325c5f2c" translate="yes" xml:space="preserve">
          <source>The module that implements the channel behaviour.</source>
          <target state="translated">实现通道行为的模块。</target>
        </trans-unit>
        <trans-unit id="334303a0b2e03a18e4f74196d147acdf2eda4f6c" translate="yes" xml:space="preserve">
          <source>The module that you specify gets passed down (eventually) into &lt;code&gt;Selector&lt;/code&gt;'s default &lt;code&gt;Filter&lt;/code&gt;. The format of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function call is hardcoded in that &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="translated">您指定的模块（最终）传递到 &lt;code&gt;Selector&lt;/code&gt; 的默认 &lt;code&gt;Filter&lt;/code&gt; 中。 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数调用的格式在该 &lt;code&gt;Filter&lt;/code&gt; 中进行了硬编码。</target>
        </trans-unit>
        <trans-unit id="e9b6419eaf88095b6d469b88c58301f91a2d21d9" translate="yes" xml:space="preserve">
          <source>The module which handles the network interface part for the SNMP manager. It must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">处理SNMP管理器的网络接口部分的模块。它必须实现 &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="37826e4d652c31b2a5adcd217c24fa50b695b568" translate="yes" xml:space="preserve">
          <source>The module which the &lt;code&gt;add_host_key&lt;/code&gt; and &lt;code&gt;is_host_key&lt;/code&gt; callbacks are delegated to. Defaults to the &lt;code&gt;ssh_file&lt;/code&gt; module.</source>
          <target state="translated">将 &lt;code&gt;add_host_key&lt;/code&gt; 和 &lt;code&gt;is_host_key&lt;/code&gt; 回调委派到的模块。默认为 &lt;code&gt;ssh_file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="523418eaa35d035f87ca00b206f2ef37af5e7c87" translate="yes" xml:space="preserve">
          <source>The module window is started by double clicking on an module name. The module window consists initially of two pages (tabs):</source>
          <target state="translated">双击一个模块名称可以启动模块窗口。模块窗口最初由两页(标签)组成。</target>
        </trans-unit>
        <trans-unit id="5f14cab5a9810db8644af6de1dc33fee56bf0da0" translate="yes" xml:space="preserve">
          <source>The modules added will not be members of any applications.</source>
          <target state="translated">添加的模块不会成为任何应用程序的成员。</target>
        </trans-unit>
        <trans-unit id="49c86e71c1ea6137a22400599bd617796af2cd26" translate="yes" xml:space="preserve">
          <source>The modules found in the given directory are checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">检查给定目录中找到的模块是否存在对 &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; 调用，对 &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 调用以及未使用的局部函数。代码路径用作 &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e420d1465bd766460e3f9194e1ada5445f2bda" translate="yes" xml:space="preserve">
          <source>The monitor functionality is expected to be extended. That is, other &lt;code&gt;Type&lt;/code&gt;s and &lt;code&gt;Item&lt;/code&gt;s are expected to be supported in a future release.</source>
          <target state="translated">监视器功能有望得到扩展。也就是说，将来的发行版将支持其他 &lt;code&gt;Type&lt;/code&gt; 和 &lt;code&gt;Item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2df469dc538ecc56583353d35b1798e5f963f917" translate="yes" xml:space="preserve">
          <source>The monitor is &lt;strong&gt;not&lt;/strong&gt; automatically removed after it has been triggered. That is, repeated changes of the time offset trigger the monitor repeatedly.</source>
          <target state="translated">监视器触发后&lt;strong&gt;不会&lt;/strong&gt;自动移除。即，时间偏移的重复改变会反复触发监视器。</target>
        </trans-unit>
        <trans-unit id="15ac3ec7a48d328efe660154448400a11004f42c" translate="yes" xml:space="preserve">
          <source>The monitor is triggered when the time offset is changed. This either if the time offset value is changed, or if the offset is changed from preliminary to final during &lt;code&gt;&lt;a href=&quot;#system_flag_time_offset&quot;&gt;finalization of the time offset&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used. When a change from preliminary to final time offset is made, the monitor is triggered once regardless of whether the time offset value was changed or not.</source>
          <target state="translated">更改时间偏移后，将触发监视器。当使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 时，如果更改了时间偏移值，或者在 &lt;code&gt;&lt;a href=&quot;#system_flag_time_offset&quot;&gt;finalization of the time offset&lt;/a&gt;&lt;/code&gt; 过程中将偏移量从初始更改为最终，则可能会发生这种情况。从初始时间偏移更改为最终时间偏移时，无论是否更改了时间偏移值，监视器都会触发一次。</target>
        </trans-unit>
        <trans-unit id="a9034b98321dccce18cf451d8ab9d47b947240ef" translate="yes" xml:space="preserve">
          <source>The monitor message is sent if the sum of the sizes of all memory blocks allocated for all heap generations after a garbage collection is equal to or higher than &lt;code&gt;Size&lt;/code&gt;.</source>
          <target state="translated">如果在垃圾回收之后为所有堆生成分配的所有内存块的大小总和等于或大于 &lt;code&gt;Size&lt;/code&gt; ,则发送监视消息。</target>
        </trans-unit>
        <trans-unit id="280bfd2e726362f1c09866455524beac7cfe5de9" translate="yes" xml:space="preserve">
          <source>The monitor request is an asynchronous signal. That is, it takes time before the signal reaches its destination.</source>
          <target state="translated">监控请求是一个异步信号。也就是说,信号到达目的地之前需要时间。</target>
        </trans-unit>
        <trans-unit id="4b32b393fd0afad77f1403e24066f7c431fc21ce" translate="yes" xml:space="preserve">
          <source>The monitor tag is always &lt;code&gt;driver&lt;/code&gt;, as this function can only be used to create driver monitors. In the future, driver monitors will be integrated with process monitors, why this parameter has to be specified for consistence.</source>
          <target state="translated">monitor标签始终是 &lt;code&gt;driver&lt;/code&gt; ，因为此功能只能用于创建驱动程序监视器。将来，驱动程序监视器将与过程监视器集成在一起，为什么必须为此参数指定一致性。</target>
        </trans-unit>
        <trans-unit id="be29116d55d7dfe82c5e11e2f4acffe31864278e" translate="yes" xml:space="preserve">
          <source>The monitor was found and removed. In this case, no &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor has been delivered and will not be delivered.</source>
          <target state="translated">找到并删除了监视器。在这种情况下，没有传送与此监视器对应的 &lt;code&gt;'DOWN'&lt;/code&gt; 消息，也不会传送。</target>
        </trans-unit>
        <trans-unit id="0337b55edbb713b6c9fbbc890aad45af45f21f06" translate="yes" xml:space="preserve">
          <source>The monitor was not found and could not be removed. This probably because someone already has placed a &lt;code&gt;'DOWN'&lt;/code&gt; message corresponding to this monitor in the caller message queue.</source>
          <target state="translated">找不到监视器，无法将其删除。这可能是因为有人已经在呼叫者消息队列中放置了与该监视器相对应的 &lt;code&gt;'DOWN'&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="c35e9498541b97f30a255b7a4962c3d364e631e2" translate="yes" xml:space="preserve">
          <source>The monitor will not be activated for the calling process until the spawn operation has succeeded. The monitor can not be &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitored&lt;/a&gt;&lt;/code&gt; before the operation has succeeded. A &lt;code&gt;'DOWN'&lt;/code&gt; message for the corresponding monitor is guaranteed not to be delivered before a &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; that corresponds to the spawn operation. If the spawn operation fails, no &lt;code&gt;'DOWN'&lt;/code&gt; message will be delivered.</source>
          <target state="translated">在生成操作成功之前，不会为调用过程激活监视器。显示器不能 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitored&lt;/a&gt;&lt;/code&gt; 操作成功了。阿 &lt;code&gt;'DOWN'&lt;/code&gt; 用于相应监视器消息保证不会一前交付 &lt;code&gt;&lt;a href=&quot;#spawn_request_success_message&quot;&gt;&lt;i&gt;success message&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 对应于产卵操作。如果生成操作失败，则不会传递任何 &lt;code&gt;'DOWN'&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="aab04c2416f519588a8e783d3297a16514c4e755" translate="yes" xml:space="preserve">
          <source>The monitored driver instance is now unloaded. As the unload can be a result of a &lt;code&gt;reload/2&lt;/code&gt; request, the driver can once again have been loaded when this message arrives.</source>
          <target state="translated">现在，已监视的驱动程序实例已卸载。由于卸载可能是 &lt;code&gt;reload/2&lt;/code&gt; 请求的结果，因此在此消息到达时可以再次加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="64d7c84598d002ae7b2cdc74963ff39c11423b77" translate="yes" xml:space="preserve">
          <source>The monitored entity, which triggered the event. When monitoring a local process or port, &lt;code&gt;Object&lt;/code&gt; will be equal to the &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; that was being monitored. When monitoring process or port by name, &lt;code&gt;Object&lt;/code&gt; will have format &lt;code&gt;{RegisteredName, Node}&lt;/code&gt; where &lt;code&gt;RegisteredName&lt;/code&gt; is the name which has been used with &lt;code&gt;monitor/2&lt;/code&gt; call and &lt;code&gt;Node&lt;/code&gt; is local or remote node name (for ports monitored by name, &lt;code&gt;Node&lt;/code&gt; is always local node name).</source>
          <target state="translated">触发事件的受监视实体。监视本地进程或端口时， &lt;code&gt;Object&lt;/code&gt; 等于正在监视的 &lt;code&gt;pid()&lt;/code&gt; 或 &lt;code&gt;port()&lt;/code&gt; 。在按名称监视进程或端口时， &lt;code&gt;Object&lt;/code&gt; 格式为 &lt;code&gt;{RegisteredName, Node}&lt;/code&gt; ，其中 &lt;code&gt;RegisteredName&lt;/code&gt; 是 &lt;code&gt;monitor/2&lt;/code&gt; 调用已使用的名称， &lt;code&gt;Node&lt;/code&gt; 是本地或远程节点名称（对于按名称监视的端口， &lt;code&gt;Node&lt;/code&gt; 始终是本地的节点名称）。</target>
        </trans-unit>
        <trans-unit id="6bf06e86189be19acddd04d200927d656e7dd37d" translate="yes" xml:space="preserve">
          <source>The most basic form of a batch is created by semicolons separated SQL queries, for example:</source>
          <target state="translated">例如,最基本的批处理形式是由分号分隔的SQL查询创建的。</target>
        </trans-unit>
        <trans-unit id="a59719eda6e9d01c978b1c0cfa6a96f9fcd184fa" translate="yes" xml:space="preserve">
          <source>The most common application of transaction mechanisms is to keep row operations together. Since our agent sorts row operations, the mechanism implemented in combination with the RowStatus (particularly 'createAndWait' value) solve most problems elegantly.</source>
          <target state="translated">事务机制最常见的应用是把行操作放在一起。由于我们的代理对行操作进行排序,所以结合RowStatus(特别是'createAndWait'值)实现的机制可以优雅地解决大多数问题。</target>
        </trans-unit>
        <trans-unit id="06ed60dfbd6cb519a1a7171c7cc31597b0e1c977" translate="yes" xml:space="preserve">
          <source>The most common operand on the right side is a variable that was bound while matching the left side. For example:</source>
          <target state="translated">右边最常见的操作数是在匹配左边的操作数时绑定的变量。例如:</target>
        </trans-unit>
        <trans-unit id="8a9c06d55eedc6a8d2f902ccf52e01e8b01e26ff" translate="yes" xml:space="preserve">
          <source>The most commonly used BIFs belonging to &lt;code&gt;erlang(3)&lt;/code&gt; are &lt;strong&gt;auto-imported&lt;/strong&gt;. They do not need to be prefixed with the module name. Which BIFs that are auto-imported is specified in the &lt;code&gt;erlang(3)&lt;/code&gt; module in ERTS. For example, standard-type conversion BIFs like &lt;code&gt;atom_to_list&lt;/code&gt; and BIFs allowed in guards can be called without specifying the module name.</source>
          <target state="translated">属于 &lt;code&gt;erlang(3)&lt;/code&gt; 的最常用BIF 是&lt;strong&gt;自动导入的&lt;/strong&gt;。它们不需要前缀模块名称。在ERTS 的 &lt;code&gt;erlang(3)&lt;/code&gt; 模块中指定了自动导入的BIF。例如，可以在不指定模块名称的情况下调用标准类型的转换 &lt;code&gt;atom_to_list&lt;/code&gt; （例如atom_to_list）和防护中允许的BIF。</target>
        </trans-unit>
        <trans-unit id="5f932fa2c48442351da05c7f82e31aff3efd5a23" translate="yes" xml:space="preserve">
          <source>The most commonly used types are &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;binary&lt;/code&gt;. See &lt;code&gt;Bit Syntax Expressions in the Reference Manual&lt;/code&gt; for a complete description.</source>
          <target state="translated">最常用的类型是 &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;binary&lt;/code&gt; 。有关完整说明，请参见 &lt;code&gt;Bit Syntax Expressions in the Reference Manual&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac9d64e469ef7ced56b3eabcbe1d40968b713a6c" translate="yes" xml:space="preserve">
          <source>The most flexible way to specify what to test, is to use a test specification, which is a sequence of Erlang terms. The terms are normally declared in one or more text files (see &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), but can also be passed to &lt;code&gt;Common Test&lt;/code&gt; on the form of a list (see &lt;code&gt;&lt;a href=&quot;ct#run_testspec-1&quot;&gt;ct:run_testspec/1&lt;/a&gt;&lt;/code&gt;). There are two general types of terms: configuration terms and test specification terms.</source>
          <target state="translated">指定测试内容的最灵活的方法是使用测试规范，该规范是Erlang术语的序列。这些术语通常在一个或多个文本文件中声明（请参阅 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ），但也可以列表形式（请参阅 &lt;code&gt;&lt;a href=&quot;ct#run_testspec-1&quot;&gt;ct:run_testspec/1&lt;/a&gt;&lt;/code&gt; ）传递给 &lt;code&gt;Common Test&lt;/code&gt; 。术语有两种常规类型：配置术语和测试规范术语。</target>
        </trans-unit>
        <trans-unit id="38a045ed78b9732cb4fcf0dfcaf6c5b02f786d54" translate="yes" xml:space="preserve">
          <source>The most frequently used of these structures is the export table that is accessed in run time for every executed external function call to get the address of the callee. For performance reasons, we want to access all these structures without any overhead from thread synchronization. Earlier this was solved with an emergency break. Stop the entire VM to mutate these code access structures, otherwise treat them as read-only.</source>
          <target state="translated">这些结构中最常用的是导出表,在运行时,每执行一次外部函数调用都会访问该表,以获取被调用者的地址。出于性能的考虑,我们希望在访问这些结构时,不需要线程同步带来任何开销。之前用紧急中断的方式解决了这个问题。停止整个虚拟机对这些代码访问结构进行突变,否则将其视为只读。</target>
        </trans-unit>
        <trans-unit id="c63e88fd2ffaffa754471ae2efc5aaf19cc51d66" translate="yes" xml:space="preserve">
          <source>The most notable difference between a match specification and an Erlang fun is the syntax. Match specifications are Erlang terms, not Erlang code. Also, a match specification has a strange concept of exceptions:</source>
          <target state="translated">匹配规范和Erlang fun最显著的区别是语法。匹配规范是Erlang术语,而不是Erlang代码。另外,匹配规范有一个奇怪的异常概念。</target>
        </trans-unit>
        <trans-unit id="a2a46d708256a890cc8c5bbd317f2b1f19c5bc43" translate="yes" xml:space="preserve">
          <source>The most recent log file is the rightmost in each row. That is, the most recent file is the one with the highest number, or if there are already four files, the one before the skip.</source>
          <target state="translated">最近的日志文件是每一行中最右边的文件。也就是说,最近的文件是数量最多的那个,如果已经有四个文件,则是跳过之前的那个。</target>
        </trans-unit>
        <trans-unit id="cd0e7640ef8705dad251d2e736a5efef30cdd300" translate="yes" xml:space="preserve">
          <source>The most significant bit is the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt;. If set, the corresponding cache reference is new. The three least significant bits are the &lt;code&gt;SegmentIndex&lt;/code&gt; of the corresponding atom cache entry. An atom cache consists of 8 segments, each of size 256, that is, an atom cache can contain 2048 entries.</source>
          <target state="translated">最重要的位是 &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 。如果设置，则相应的缓存引用是新的。这三个最低有效位是相应原子缓存条目的 &lt;code&gt;SegmentIndex&lt;/code&gt; 。原子缓存由8个段组成，每个段的大小为256，即原子缓存可以包含2048个条目。</target>
        </trans-unit>
        <trans-unit id="2788a4ce9749d7747a7b2405ff14fe489fb5bd3b" translate="yes" xml:space="preserve">
          <source>The most straightforward representation. Each character is stored in one single 32-bit number. There is no need for escapes or any variable number of entities for one character. All Unicode code points can be stored in one single 32-bit entity. As with UTF-16, there are byte-order issues. UTF-32 can be both big-endian and little-endian.</source>
          <target state="translated">最直接的表示方法。每个字符都存储在一个单一的32位数字中。不需要转义符,也不需要为一个字符提供任何可变数量的实体。所有Unicode码点都可以存储在一个单一的32位实体中。与UTF-16一样,存在字节顺序问题。UTF-32既可以是大字段,也可以是小字段。</target>
        </trans-unit>
        <trans-unit id="276f7c971b5e4ce251c40cb717c8adebadd70cf8" translate="yes" xml:space="preserve">
          <source>The most use of this function would be if one for example uses the &lt;code&gt;io&lt;/code&gt; module to communicate with an I/O-server for a regular file, like in the following example:</source>
          <target state="translated">如果例如使用 &lt;code&gt;io&lt;/code&gt; 模块与常规文件的I / O服务器进行通信，则该功能的最大用途是，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="750fc0fe85477bda2150e648c512e34c1afec03c" translate="yes" xml:space="preserve">
          <source>The most versatile way to handle time-outs is to use Erlang Timers; see &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt;. Most time-out tasks can be performed with the time-out features in &lt;code&gt;gen_statem&lt;/code&gt;, but an example of one that can not is if you should need the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;, that is; the remaining time of the timer.</source>
          <target state="translated">处理超时的最通用方法是使用Erlang计时器。参见 &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt; 。大多数超时任务都可以使用 &lt;code&gt;gen_statem&lt;/code&gt; 中的超时功能执行，但不能执行的一个示例是，是否需要 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 的返回值，即；计时器的剩余时间。</target>
        </trans-unit>
        <trans-unit id="07214bec22f079b6698191c51f7574ccbc4b91ea" translate="yes" xml:space="preserve">
          <source>The most versatile way to handle time-outs is to use Erlang Timers; see &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt;. Most time-out tasks can be performed with the time-out features in &lt;code&gt;gen_statem&lt;/code&gt;, but an example of one that cannot is if you should need the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;, that is; the remaining time of the timer.</source>
          <target state="translated">处理超时的最通用的方法是使用Erlang计时器。参见 &lt;code&gt;erlang:start_timer/3,4&lt;/code&gt; 。大多数超时任务都可以使用 &lt;code&gt;gen_statem&lt;/code&gt; 中的超时功能执行，但不能执行的一个示例是，是否需要 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 的返回值，即；计时器的剩余时间。</target>
        </trans-unit>
        <trans-unit id="8a0d9d7bcf952de8136817cdd4400566b2d55dbf" translate="yes" xml:space="preserve">
          <source>The motivation for alternate dictionaries is RFC 7683, Diameter Overload Indication Conveyance (DOIC), which defines AVPs to be piggybacked onto existing application messages rather than defining an application of its own. The DOIC dictionary is provided by the diameter application, as module &lt;code&gt;diameter_gen_doic_rfc7683&lt;/code&gt;, but alternate dictionaries can be used to encode/decode any set of AVPs not known to an application dictionary.</source>
          <target state="translated">备用字典的动机是RFC 7683，直径超载指示传送（DOIC），它定义了将被搭载在现有应用程序消息上的AVP，而不是定义自己的应用程序。DOIC词典由直径应用程序提供，作为模块 &lt;code&gt;diameter_gen_doic_rfc7683&lt;/code&gt; ，但是可以使用备用字典来编码/解码应用程序词典未知的任何AVP集。</target>
        </trans-unit>
        <trans-unit id="d91905ede33f8ff195d296077e558f92b868c336" translate="yes" xml:space="preserve">
          <source>The mouse buttons behave as expected. Use left-click to select objects, right-click to get a menu with the most used options, and double-click to display information about the selected object. In most viewers with many columns, you can change the sort order by left-clicking the column header.</source>
          <target state="translated">鼠标按钮的表现与预期一样。使用左键单击来选择对象,右键单击得到一个带有最常用选项的菜单,双击则显示所选对象的信息。在大多数有许多列的查看器中,您可以通过左键单击列头来改变排序顺序。</target>
        </trans-unit>
        <trans-unit id="d51d529839aa845352125415e30ac1e06dd6c469" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="translated">msg是二进制的 &quot;明文 &quot;数据,或者是 &quot;明文 &quot;的哈希值,即摘要(明文)。</target>
        </trans-unit>
        <trans-unit id="b14b4a3785c5957a50b987dae462b671878b64ca" translate="yes" xml:space="preserve">
          <source>The msg is either the binary &quot;cleartext&quot; data to be signed or it is the hashed value of &quot;cleartext&quot; i.e. the digest (plaintext).</source>
          <target state="translated">msg是要签名的二进制 &quot;明文 &quot;数据,或者是 &quot;明文 &quot;的哈希值,即摘要(明文)。</target>
        </trans-unit>
        <trans-unit id="06e39bf8c6d5c07789729bace985f7385be5bc7d" translate="yes" xml:space="preserve">
          <source>The mstone (mstone1 and mstone2) module(s)</source>
          <target state="translated">mstone(mstone1和mstone2)模块。</target>
        </trans-unit>
        <trans-unit id="b37835e9362863cab04224df2d6371e6a0fb053b" translate="yes" xml:space="preserve">
          <source>The multi-request tag (&lt;code&gt;requests&lt;/code&gt;) is handled in a separate loop function applying the requests in the list one after another, returning the last result.</source>
          <target state="translated">在一个单独的循环函数中处理多请求标记（ &lt;code&gt;requests&lt;/code&gt; ），该循环函数将请求依次应用到列表中，并返回最后一个结果。</target>
        </trans-unit>
        <trans-unit id="23debd07a945d566a02dcdb32a68d5943648993d" translate="yes" xml:space="preserve">
          <source>The multiblock carrier growth stages (&lt;code&gt;&lt;a href=&quot;#M_mbcgs&quot;&gt;mbcgs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">多 &lt;code&gt;&lt;a href=&quot;#M_mbcgs&quot;&gt;mbcgs&lt;/a&gt;&lt;/code&gt; 载波增长阶段（mbcgs）</target>
        </trans-unit>
        <trans-unit id="ff5eb8ef08d964ccf13b2991de15ea2b46a940f2" translate="yes" xml:space="preserve">
          <source>The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example, the following matches &quot;1&quot;, &quot;2&quot;, or any non-digit:</source>
          <target state="translated">&quot;word &quot;是Perl的扩展名,&quot;blank &quot;是Perl 5.8的GNU扩展名。另一个Perl扩展是否定式,它由冒号后的^字符表示。例如,下面的内容可以匹配 &quot;1&quot;、&quot;2 &quot;或任何非数字。</target>
        </trans-unit>
        <trans-unit id="f414a0fc6680e2dbcfe9f9956aebf12383da1b0d" translate="yes" xml:space="preserve">
          <source>The name (atom) of the group that the local node belongs to.</source>
          <target state="translated">本地节点所属组的名称(原子)。</target>
        </trans-unit>
        <trans-unit id="e804732505006dd7c7969c59d1f3efc6e15e1cf1" translate="yes" xml:space="preserve">
          <source>The name (atom) of the module.</source>
          <target state="translated">模块的名称(原子)。</target>
        </trans-unit>
        <trans-unit id="8ea5812b14b364e780d92efa7352e85d9c8094a1" translate="yes" xml:space="preserve">
          <source>The name (string) of the BEAM file, or the binary from which the information was extracted.</source>
          <target state="translated">BEAM文件的名称(字符串),或提取信息的二进制文件。</target>
        </trans-unit>
        <trans-unit id="a047d0ac2f80e6460c375c43c2970be9596025da" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;increment&lt;/code&gt; is the name of the group that the fragment belongs to. Note that it does not need to have the same name as the instruction. The group name is followed by &lt;code&gt;.&lt;/code&gt; and the name of the fragment. The name &lt;code&gt;head&lt;/code&gt; is pre-defined. The code in it will be placed at the beginning of a block, so that all fragments in the group can access it.</source>
          <target state="translated">名称 &lt;code&gt;increment&lt;/code&gt; 是该片段所属的组的名称。请注意，它不需要与指令相同的名称。组名后跟 &lt;code&gt;.&lt;/code&gt; 和片段的名称。名称 &lt;code&gt;head&lt;/code&gt; 是预定义的。其中的代码将放置在块的开头，以便组中的所有片段都可以访问它。</target>
        </trans-unit>
        <trans-unit id="2274c550ae5b13836076f9a7929fd688045c89dd" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;lait/1&lt;/code&gt; is a misspelling - do not use it anymore.</source>
          <target state="translated">名称 &lt;code&gt;lait/1&lt;/code&gt; 是拼写错误的-请勿再使用。</target>
        </trans-unit>
        <trans-unit id="681f8295155692465a1193bddef45679cf6d0d46" translate="yes" xml:space="preserve">
          <source>The name for a specific instruction is an identifier starting with a lowercase letter. A type is an lowercase or uppercase letter.</source>
          <target state="translated">特定指令的名称是一个以小写字母开头的标识符。类型是一个小写字母或大写字母。</target>
        </trans-unit>
        <trans-unit id="63f740169c092f330a56a6ac0c5a087138d89aff" translate="yes" xml:space="preserve">
          <source>The name of a generated dictionary module as generated by &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make#codec-2&quot;&gt;diameter_make:codec/2&lt;/a&gt;&lt;/code&gt;. The interface provided by a dictionary module is an implementation detail that may change.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;diameter_make#codec-2&quot;&gt;diameter_make:codec/2&lt;/a&gt;&lt;/code&gt; 生成的生成的字典模块的名称。词典模块提供的接口是可以更改的实现细节。</target>
        </trans-unit>
        <trans-unit id="cdd16490cd1c460a31b904b705bbc01a37d6d356" translate="yes" xml:space="preserve">
          <source>The name of a process group.</source>
          <target state="translated">流程组的名称。</target>
        </trans-unit>
        <trans-unit id="fe553f36c37e4dc0b840932349b35c736986e7b9" translate="yes" xml:space="preserve">
          <source>The name of a registered port, as an atom.</source>
          <target state="translated">注册端口的名称,作为一个原子。</target>
        </trans-unit>
        <trans-unit id="068c1e29898954da7dafd70c60c0281782bdf6c5" translate="yes" xml:space="preserve">
          <source>The name of a registered process, as an atom.</source>
          <target state="translated">作为原子的注册流程的名称。</target>
        </trans-unit>
        <trans-unit id="781b85e865fd06d99312a507847ed2319f617cf1" translate="yes" xml:space="preserve">
          <source>The name of a zip file.</source>
          <target state="translated">一个压缩文件的名称。</target>
        </trans-unit>
        <trans-unit id="14a3bc59edd8f43ed0656e84308b952ff50507a2" translate="yes" xml:space="preserve">
          <source>The name of all instrumentation functions must be the same as the corresponding managed object it implements.</source>
          <target state="translated">所有工具函数的名称必须与它所实现的相应管理对象相同。</target>
        </trans-unit>
        <trans-unit id="3fd2da7d7d7f0930e22b98a6d6e1a55d9b181147" translate="yes" xml:space="preserve">
          <source>The name of an executable program that can be used as an interface for specifying and running tests with &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">可执行程序的名称，可用作与 &lt;code&gt;Common Test&lt;/code&gt; 一起指定和运行测试的接口。</target>
        </trans-unit>
        <trans-unit id="ceba45d1b18e3dd3cc8da1a11142ef2efd79c65f" translate="yes" xml:space="preserve">
          <source>The name of the ASN.1 specification</source>
          <target state="translated">ASN.1规格的名称</target>
        </trans-unit>
        <trans-unit id="017669fbaeb7cca7f42900b9524557094afd427e" translate="yes" xml:space="preserve">
          <source>The name of the AVP as defined in the dictionary file in question, or &lt;code&gt;undefined&lt;/code&gt; if the AVP is unknown to the dictionary file in question.</source>
          <target state="translated">在所讨论的字典文件中定义的AVP的名称；如果所讨论的字典文件 &lt;code&gt;undefined&lt;/code&gt; 知道AVP，则未定义。</target>
        </trans-unit>
        <trans-unit id="eb19f7e4ed9ccee1886a04f755cad374e6bf2833" translate="yes" xml:space="preserve">
          <source>The name of the command set by &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:open_port/2&lt;/code&gt; 设置的命令名称。</target>
        </trans-unit>
        <trans-unit id="a69ba7d63607e672a0bddb87dd2b06b8084a0156" translate="yes" xml:space="preserve">
          <source>The name of the current function.</source>
          <target state="translated">当前函数的名称。</target>
        </trans-unit>
        <trans-unit id="5d5f02fcd54d2c4aea3c80c0f03903502a3ce2db" translate="yes" xml:space="preserve">
          <source>The name of the current module, as a string.</source>
          <target state="translated">当前模块的名称,为字符串。</target>
        </trans-unit>
        <trans-unit id="c44e0c83244028d9b0e30cf7a2d2504d40b0af59" translate="yes" xml:space="preserve">
          <source>The name of the current module.</source>
          <target state="translated">当前模块的名称。</target>
        </trans-unit>
        <trans-unit id="b706d162247dd36c2c34198513b7054a12041a8e" translate="yes" xml:space="preserve">
          <source>The name of the dumped table. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with &lt;code&gt;&lt;a href=&quot;#file2tab-2&quot;&gt;file2tab/2&lt;/a&gt;&lt;/code&gt;. If the table is not saved as a named table, this field has no significance when loading the table from file.</source>
          <target state="translated">转储表的名称。如果该表是一个命名表，那么当使用 &lt;code&gt;&lt;a href=&quot;#file2tab-2&quot;&gt;file2tab/2&lt;/a&gt;&lt;/code&gt; 从文件中加载该表时，该表将不存在。如果该表未另存为命名表，则从文件加载该表时该字段没有任何意义。</target>
        </trans-unit>
        <trans-unit id="b173e28eec1dbfe6b6a9acf56060edd59ce91a80" translate="yes" xml:space="preserve">
          <source>The name of the element is found in the &lt;code&gt;name&lt;/code&gt; field. In the &lt;code&gt;parents&lt;/code&gt; field is the names of the parent elements saved. Parents is a list of tuples where the first element in each tuple is the name of the parent element. The list is in reverse order.</source>
          <target state="translated">元素的 &lt;code&gt;name&lt;/code&gt; 在名称字段中找到。在 &lt;code&gt;parents&lt;/code&gt; 字段中是保存的父级元素的名称。父级是元组的列表，其中每个元组中的第一个元素是父级元素的名称。该列表是相反的顺序。</target>
        </trans-unit>
        <trans-unit id="9bdb35ccec0faa5ab435abc22ae894c98451909a" translate="yes" xml:space="preserve">
          <source>The name of the exclusive decode function</source>
          <target state="translated">独占性解码功能的名称</target>
        </trans-unit>
        <trans-unit id="86285c72be4427a4583ade3f13c715eec3f72092" translate="yes" xml:space="preserve">
          <source>The name of the executable as well as the arguments specifed in &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and &lt;code&gt;arg0&lt;/code&gt; are subject to Unicode filename translation if the system is running in Unicode filename mode. To avoid translation or to force, for example UTF-8, supply the executable and/or arguments as a binary in the correct encoding. For details, see the module &lt;code&gt;file(3)&lt;/code&gt;, the function &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; in Kernel, and the &lt;code&gt; Using Unicode in Erlang&lt;/code&gt; User's Guide.</source>
          <target state="translated">如果系统以Unicode文件名模式运行，则可执行文件的名称以及在 &lt;code&gt;cd&lt;/code&gt; ， &lt;code&gt;env&lt;/code&gt; ， &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;arg0&lt;/code&gt; 中指定的参数都应进行Unicode文件名转换。为了避免翻译或强制使用（例如UTF-8），请以正确的编码将可执行文件和/或参数作为二进制文件提供。有关详细信息，请参见模块 &lt;code&gt;file(3)&lt;/code&gt; ，函数 &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; 位于内核中）和《 &lt;code&gt; Using Unicode in Erlang&lt;/code&gt; 用户指南》）。</target>
        </trans-unit>
        <trans-unit id="c9cd1cfd2a7c75e9d469f30e6b8aa44633fee5f8" translate="yes" xml:space="preserve">
          <source>The name of the executable as well as the arguments specifed in &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and &lt;code&gt;arg0&lt;/code&gt; are subject to Unicode filename translation if the system is running in Unicode filename mode. To avoid translation or to force, for example UTF-8, supply the executable and/or arguments as a binary in the correct encoding. For details, see the module &lt;code&gt;file(3)&lt;/code&gt;, the function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; in Kernel, and the &lt;code&gt;Using Unicode in Erlang&lt;/code&gt; User's Guide.</source>
          <target state="translated">如果系统以Unicode文件名模式运行，则可执行文件的名称以及在 &lt;code&gt;cd&lt;/code&gt; ， &lt;code&gt;env&lt;/code&gt; ， &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;arg0&lt;/code&gt; 中指定的参数都将接受Unicode文件名转换。为避免翻译或强制执行（例如UTF-8），请以正确的编码形式将可执行文件和/或参数作为二进制文件提供。有关详细信息，请参见模块 &lt;code&gt;file(3)&lt;/code&gt; ，函数 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 内核中的native_name_encoding / 0和《 &lt;code&gt;Using Unicode in Erlang&lt;/code&gt; 用户指南》中的&amp;ldquo; 使用Unicode &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="145bef4824887ac958179d5dc67a74ef7822e376" translate="yes" xml:space="preserve">
          <source>The name of the file (actually a named pipe) that is to receive the information</source>
          <target state="translated">接收信息的文件名(实际上是一个命名的管道)。</target>
        </trans-unit>
        <trans-unit id="a03ff0e0c54f689b6ef65841c20ee8be07ab00cd" translate="yes" xml:space="preserve">
          <source>The name of the fragmented table</source>
          <target state="translated">零碎表格的名称</target>
        </trans-unit>
        <trans-unit id="e84326facd2f5685ce1620f764c65298c11a51af" translate="yes" xml:space="preserve">
          <source>The name of the module where the fun was defined.</source>
          <target state="translated">定义乐趣的模块名称。</target>
        </trans-unit>
        <trans-unit id="c300450378be4a7afe8d7c46495bd6f766c6ab41" translate="yes" xml:space="preserve">
          <source>The name of the originating node, encoded using &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">起始节点的名称，使用 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 进行编码。</target>
        </trans-unit>
        <trans-unit id="0d9aeed296de66746c856a81bf8f9ded5e43cdf7" translate="yes" xml:space="preserve">
          <source>The name of the program which started Erlang:</source>
          <target state="translated">启动Erlang的程序名称。</target>
        </trans-unit>
        <trans-unit id="98a9f43eda81f29bf9d5743946a9ea8fd9286582" translate="yes" xml:space="preserve">
          <source>The name of the remote node.</source>
          <target state="translated">远程节点的名称。</target>
        </trans-unit>
        <trans-unit id="c050e4fb9fc899bdfcbcbf709859cc750e6a455f" translate="yes" xml:space="preserve">
          <source>The name of the saved file is the same as the name of the schema, but with &lt;code&gt;.xss&lt;/code&gt; extension.</source>
          <target state="translated">保存文件的名称与架构的名称相同，但扩展名为 &lt;code&gt;.xss&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e86acd0ca5b48cdb98c4c075c4205c3b79b72431" translate="yes" xml:space="preserve">
          <source>The name of the service that started the machine.</source>
          <target state="translated">启动机器的服务名称。</target>
        </trans-unit>
        <trans-unit id="d1f79a45516e8d9666e0b4109e4162f8073d0a02" translate="yes" xml:space="preserve">
          <source>The name of the socket file (the path prefix removed), which allows for deletion (&lt;code&gt;unlink&lt;/code&gt;) when the socket is closed.</source>
          <target state="translated">套接字文件的名称（路径前缀已删除），当套接字关闭时，该文件允许删除（ &lt;code&gt;unlink&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5d325a204adba96bb16ee250d72f562304e27637" translate="yes" xml:space="preserve">
          <source>The name of the started node becomes &lt;code&gt;Name@Host&lt;/code&gt;. If no name is provided, the name becomes the same as the node that executes the call (except the host name part of the node name).</source>
          <target state="translated">启动的节点的名称为 &lt;code&gt;Name@Host&lt;/code&gt; 。如果未提供名称，则该名称将与执行调用的节点相同（节点名称的主机名部分除外）。</target>
        </trans-unit>
        <trans-unit id="e7bd7f6787400f7052ac4a578442d60601ba1079" translate="yes" xml:space="preserve">
          <source>The name of the test group.</source>
          <target state="translated">试验组的名称;</target>
        </trans-unit>
        <trans-unit id="ba203fc462e6b2138d3482cf4c5e8058aed6a57d" translate="yes" xml:space="preserve">
          <source>The name of the testcase function.</source>
          <target state="translated">测试案例函数的名称。</target>
        </trans-unit>
        <trans-unit id="ef518922fd516452499d2abfb02bdb4cf49f94a5" translate="yes" xml:space="preserve">
          <source>The name of the user function</source>
          <target state="translated">用户功能的名称</target>
        </trans-unit>
        <trans-unit id="39f567390152e02d37fe6a831a2b17a677f34378" translate="yes" xml:space="preserve">
          <source>The name of your server, normally a fully qualified domain name.</source>
          <target state="translated">你的服务器的名称,通常是一个完全合格的域名。</target>
        </trans-unit>
        <trans-unit id="c657342b93672825ac56ce5aad93896816b11389" translate="yes" xml:space="preserve">
          <source>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</source>
          <target state="translated">TFTP守护进程所在主机的名称或IP地址。这个选项只被客户端使用。</target>
        </trans-unit>
        <trans-unit id="efd3b9bd3feb790c69b6f53e83bb01160208a7e5" translate="yes" xml:space="preserve">
          <source>The name server also maintains a fully connected network. For example, if node &lt;code&gt;N1&lt;/code&gt; connects to node &lt;code&gt;N2&lt;/code&gt; (which is already connected to &lt;code&gt;N3&lt;/code&gt;), the global name servers on the nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; ensure that also &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; are connected. If this is not desired, command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; can be used (see also &lt;code&gt;erl(1)&lt;/code&gt;). In this case, the name registration service cannot be used, but the lock mechanism still works.</source>
          <target state="translated">名称服务器还维护一个完全连接的网络。例如，如果节点 &lt;code&gt;N1&lt;/code&gt; 连接到节点 &lt;code&gt;N2&lt;/code&gt; （已经连接到 &lt;code&gt;N3&lt;/code&gt; ），则节点 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N3&lt;/code&gt; 上的全局名称服务器将确保 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N3&lt;/code&gt; 也已连接。如果不希望这样做，则可以使用命令行标志 &lt;code&gt;-connect_all false&lt;/code&gt; （另请参见 &lt;code&gt;erl(1)&lt;/code&gt; ）。在这种情况下，不能使用名称注册服务，但是锁定机制仍然有效。</target>
        </trans-unit>
        <trans-unit id="70bbd5b825a0e3f16b591b2238348e211ea12fa7" translate="yes" xml:space="preserve">
          <source>The name(s) of the user-defined residence module(s) must be listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification for the special process. Otherwise the release handler cannot find the process.</source>
          <target state="translated">用户定义的驻留模块的名称必须在特殊过程的子规范的&amp;ldquo; &lt;code&gt;Modules&lt;/code&gt; 部分中列出。否则，发布处理程序将找不到该进程。</target>
        </trans-unit>
        <trans-unit id="55639d1e8772a94a0b0836a082a724c02665921b" translate="yes" xml:space="preserve">
          <source>The named file is a directory.</source>
          <target state="translated">命名的文件是一个目录。</target>
        </trans-unit>
        <trans-unit id="14d72b8811543846930a80f5f7f7859cd2878b00" translate="yes" xml:space="preserve">
          <source>The named pipe, usually &lt;code&gt;/tmp/&lt;/code&gt;. It must be suffixed by a &lt;code&gt;/&lt;/code&gt; (slash), that is, &lt;code&gt;/tmp/epipes/&lt;/code&gt;, not &lt;code&gt;/tmp/epipes&lt;/code&gt;.</source>
          <target state="translated">命名管道，通常是 &lt;code&gt;/tmp/&lt;/code&gt; 。它必须以 &lt;code&gt;/&lt;/code&gt; （斜杠）作为后缀，即 &lt;code&gt;/tmp/epipes/&lt;/code&gt; ，而不是 &lt;code&gt;/tmp/epipes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f0fcca13871e6412c5bb752140a8243dc65e989" translate="yes" xml:space="preserve">
          <source>The names of all fragments</source>
          <target state="translated">所有碎片的名称</target>
        </trans-unit>
        <trans-unit id="38f3d4f81f2a3fb4b6790bd99cb201c153f2cb7b" translate="yes" xml:space="preserve">
          <source>The naming of the service in a system that uses release handling must follow the convention &lt;strong id=&quot;001&quot;&gt;NodeName&lt;/strong&gt;_&lt;strong&gt;Release&lt;/strong&gt;, where &lt;strong&gt;NodeName&lt;/strong&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;strong&gt;Release&lt;/strong&gt; is the current release of the application.</source>
          <target state="translated">在使用发行版处理的系统中，服务的命名必须遵循约定&lt;strong id=&quot;001&quot;&gt;NodeName&lt;/strong&gt; _ &lt;strong&gt;Release&lt;/strong&gt;，其中&lt;strong&gt;NodeName&lt;/strong&gt;是Erlang节点名称的第一部分（最大但不包括&amp;ldquo; @&amp;rdquo;），而&lt;strong&gt;Release&lt;/strong&gt;是发行&lt;strong&gt;版&lt;/strong&gt;的当前版本。应用程序。</target>
        </trans-unit>
        <trans-unit id="865ddb889727f82a24bd4d5836d553df871c5cb5" translate="yes" xml:space="preserve">
          <source>The native code will be placed into the beam file and automatically loaded when the beam file is loaded.</source>
          <target state="translated">本机代码将被放入梁文件中,在梁文件加载时自动加载。</target>
        </trans-unit>
        <trans-unit id="099004f05e60e183a2f4c8c6bb366712c24740f5" translate="yes" xml:space="preserve">
          <source>The needed compiler environment variables are setup inside &lt;code&gt;otp_build&lt;/code&gt; via &lt;code&gt;erts/etc/win32/wsl_tools/SetupWSLcross.bat&lt;/code&gt;. It contains some hardcoded paths, if your installation path is different it can be added to that file.</source>
          <target state="translated">所需的编译器环境变量是通过 &lt;code&gt;erts/etc/win32/wsl_tools/SetupWSLcross.bat&lt;/code&gt; 在 &lt;code&gt;otp_build&lt;/code&gt; 中设置的。它包含一些硬编码的路径，如果您的安装路径不同，则可以将其添加到该文件中。</target>
        </trans-unit>
        <trans-unit id="7e0d9e387da412c6854e55d2ea6c29168d1cc99c" translate="yes" xml:space="preserve">
          <source>The negotiated protocol can be retrieved using the &lt;code&gt;negotiated_protocol/1&lt;/code&gt; function.</source>
          <target state="translated">可以使用协商的协议 &lt;code&gt;negotiated_protocol/1&lt;/code&gt; 函数来检索协商的协议。</target>
        </trans-unit>
        <trans-unit id="67cafe9894ea27f4431898cfd38a6c6c7c0adadf" translate="yes" xml:space="preserve">
          <source>The negotiation (session setup time) time can be limited with the</source>
          <target state="translated">协商(会话设置时间)的时间可以通过使用</target>
        </trans-unit>
        <trans-unit id="3d19b33d4325de1693405141a928c25d4f21b350" translate="yes" xml:space="preserve">
          <source>The negotiation is simple: both peers sends their list of supported alghorithms to the other part. The first algorithm on the client's list that also in on the server's list is selected. So it is the client's orderering of the list that gives the priority for the algorithms.</source>
          <target state="translated">协商很简单:对等体双方都向对方发送自己支持的算法列表。客户端列表中的第一个算法,同时也是服务器列表中的算法,就会被选中。所以是客户端对列表的排序给了算法的优先权。</target>
        </trans-unit>
        <trans-unit id="a0fb72997ab3557ef82a230bb3682011bf2c48d8" translate="yes" xml:space="preserve">
          <source>The net kernel is a system process, registered as &lt;code&gt;net_kernel&lt;/code&gt;, which must be operational for distributed Erlang to work. The purpose of this process is to implement parts of the BIFs &lt;code&gt;spawn/4&lt;/code&gt; and &lt;code&gt;spawn_link/4&lt;/code&gt;, and to provide monitoring of the network.</source>
          <target state="translated">网络内核是注册为 &lt;code&gt;net_kernel&lt;/code&gt; 的系统进程，必须运行才能使分布式Erlang正常工作。此过程的目的是实现 &lt;code&gt;spawn_link/4&lt;/code&gt; 部分 &lt;code&gt;spawn/4&lt;/code&gt; 和spawn_link / 4并提供对网络的监视。</target>
        </trans-unit>
        <trans-unit id="7b9ff73038bb4f2d73ed04274ea6798f021e1bdd" translate="yes" xml:space="preserve">
          <source>The network connection to the client is broken.</source>
          <target state="translated">与客户端的网络连接中断。</target>
        </trans-unit>
        <trans-unit id="627d3f85b6d775569c184e75c28525ed0d03a0a3" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;send_name&lt;/code&gt; is only sent from nodes supporting version 6 to nodes known to support version 6. &lt;code&gt;Flags&lt;/code&gt; are the &lt;code&gt;&lt;a href=&quot;#dflags&quot;&gt;capability flags&lt;/a&gt;&lt;/code&gt; of node &lt;code&gt;A&lt;/code&gt; in 64-bit big endian. The flag bit &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; must always be set. &lt;code&gt;Creation&lt;/code&gt; is the node incarnation identifier used by node &lt;code&gt;A&lt;/code&gt; to create its pids, ports and references. &lt;code&gt;Name&lt;/code&gt; is the full node name of &lt;code&gt;A&lt;/code&gt;, as a string of bytes. &lt;code&gt;Nlen&lt;/code&gt; is the byte length of the node name in 16-bit big endian. Any extra data after the node &lt;code&gt;Name&lt;/code&gt; must be accepted and ignored.</source>
          <target state="translated">新的 &lt;code&gt;send_name&lt;/code&gt; 仅从支持版本6的节点发送到已知支持版本6的节点。 &lt;code&gt;Flags&lt;/code&gt; 是64位big endian中节点 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#dflags&quot;&gt;capability flags&lt;/a&gt;&lt;/code&gt; 。标志位 &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; 必须始终置位。 &lt;code&gt;Creation&lt;/code&gt; 是节点 &lt;code&gt;A&lt;/code&gt; 用来创建其pid，端口和引用的节点化身标识符。 &lt;code&gt;Name&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的完整节点名称，以字节字符串表示。 &lt;code&gt;Nlen&lt;/code&gt; 是节点名称的字节长度，以16位大字节序表示。节点 &lt;code&gt;Name&lt;/code&gt; 之后的任何其他数据都必须接受并忽略。</target>
        </trans-unit>
        <trans-unit id="da852eb6d3cd7c2bee53433293d851328338d462" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">新的 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a02721e2497fbe700123fb9e3a729f740f43a941" translate="yes" xml:space="preserve">
          <source>The new API also consists of extensions of the following existing BIFs:</source>
          <target state="translated">新的API还包括以下现有BIF的扩展:</target>
        </trans-unit>
        <trans-unit id="14ce5a3ea27213da49e5b9bde3bdc06535343fd3" translate="yes" xml:space="preserve">
          <source>The new API consists of the following new BIFs:</source>
          <target state="translated">新的API由以下新的BIF组成:</target>
        </trans-unit>
        <trans-unit id="e2e000cc20f5ca067c8f3696f8838efc3f818b18" translate="yes" xml:space="preserve">
          <source>The new application version &lt;code&gt;ch_app-2&lt;/code&gt; is installed under &lt;code&gt;$ROOT/lib&lt;/code&gt; next to &lt;code&gt;ch_app-1&lt;/code&gt;. The &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt; directories are not affected, as they have not changed.</source>
          <target state="translated">新的应用程序版本 &lt;code&gt;ch_app-2&lt;/code&gt; 安装在 &lt;code&gt;ch_app-1&lt;/code&gt; 旁边的 &lt;code&gt;$ROOT/lib&lt;/code&gt; 下。该 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 和 &lt;code&gt;sasl&lt;/code&gt; 目录不会受到影响，因为他们并没有改变。</target>
        </trans-unit>
        <trans-unit id="4296e843fe7d1f9f3daacc474a680517cc7d8224" translate="yes" xml:space="preserve">
          <source>The new challenge message is sent from new &lt;code&gt;B&lt;/code&gt; nodes if node &lt;code&gt;A&lt;/code&gt; had capability flag &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt; DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; set. Any extra data after the node &lt;code&gt;Name&lt;/code&gt; must be accepted and ignored.</source>
          <target state="translated">如果节点 &lt;code&gt;A&lt;/code&gt; 设置了功能标志 &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt; DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; ,则从新的 &lt;code&gt;B&lt;/code&gt; 节点发送新的质询消息。节点 &lt;code&gt;Name&lt;/code&gt; 之后的任何其他数据都必须接受并忽略。</target>
        </trans-unit>
        <trans-unit id="59032a152ed589ec4feaf1322f673d94f7aaad6d" translate="yes" xml:space="preserve">
          <source>The new configuration is merged with the existing formatter configuration.</source>
          <target state="translated">新配置与现有的formatter配置合并。</target>
        </trans-unit>
        <trans-unit id="ef9dff32bec701e7bf2e4cdcd05fa7657f12d4e9" translate="yes" xml:space="preserve">
          <source>The new default behaviour is that the SASL application no longer affects which log events that are logged. &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; are logged via the default logger handler which is setup by Kernel. &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt; logger_level&lt;/code&gt;.</source>
          <target state="translated">新的默认行为是SASL应用程序不再影响所记录的日志事件。 &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; 通过默认的记录程序处理程序记录，该记录程序由内核设置。 &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; 默认情况下不会记录，但是可以通过将主日志级别设置为 &lt;code&gt;info&lt;/code&gt; 来启用，例如通过使用内核配置参数 &lt;code&gt; logger_level&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83d81766969865b40c9a40366463e9a12358c346" translate="yes" xml:space="preserve">
          <source>The new default behaviour is that the SASL application no longer affects which log events that are logged. &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; are logged via the default logger handler which is setup by Kernel. &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; are by default not logged, but can be enabled by setting the primary log level to &lt;code&gt;info&lt;/code&gt;, for example by using the Kernel configuration parameter &lt;code&gt;logger_level&lt;/code&gt;.</source>
          <target state="translated">新的默认行为是SASL应用程序不再影响所记录的日志事件。 &lt;code&gt;&lt;a href=&quot;#supervisor_report&quot;&gt;Supervisor reports&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#crash_report&quot;&gt;crash reports&lt;/a&gt;&lt;/code&gt; 通过默认的记录程序处理程序记录，该记录程序由内核设置。 &lt;code&gt;&lt;a href=&quot;#progress_report&quot;&gt;Progress reports&lt;/a&gt;&lt;/code&gt; 默认情况下不会记录，但是可以通过将主日志级别设置为 &lt;code&gt;info&lt;/code&gt; 来启用，例如通过使用内核配置参数 &lt;code&gt;logger_level&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92dc21a8d41e5c8b619380519d3b0f95e22551bd" translate="yes" xml:space="preserve">
          <source>The new functions for calculating a MAC of a single piece of text are:</source>
          <target state="translated">新的计算单篇文字MAC的功能是:</target>
        </trans-unit>
        <trans-unit id="5ee049049c7d7a80e073a4a592d747b3c561f3e3" translate="yes" xml:space="preserve">
          <source>The new functions for encrypting or decrypting one single binary are:</source>
          <target state="translated">加密或解密一个二进制的新功能是:</target>
        </trans-unit>
        <trans-unit id="90289d546aac89c2e80a44e2dc66fc3797c85bff" translate="yes" xml:space="preserve">
          <source>The new handler is added even if the the specified old event handler is not installed, in which case &lt;code&gt;Term=error&lt;/code&gt;, or if &lt;code&gt;Module1:terminate/2&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, in which case &lt;code&gt;Term={'EXIT',Reason}&lt;/code&gt;. The old handler is deleted even if &lt;code&gt;Module2:init/1&lt;/code&gt; fails.</source>
          <target state="translated">即使未安装指定的旧事件处理程序，也会添加新的处理程序，在这种情况下 &lt;code&gt;Term=error&lt;/code&gt; ，或者 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 失败并返回 &lt;code&gt;Reason&lt;/code&gt; ，在这种情况下 &lt;code&gt;Term={'EXIT',Reason}&lt;/code&gt; 。即使 &lt;code&gt;Module2:init/1&lt;/code&gt; 失败，旧处理程序也会被删除。</target>
        </trans-unit>
        <trans-unit id="bb6d60eb5086a616fa3a92d0005c10a9e8598b91" translate="yes" xml:space="preserve">
          <source>The new names follows the OpenSSL libcrypto names. The format is ALGORITM_KEYSIZE_MODE.</source>
          <target state="translated">新的名称沿用了OpenSSL的libcrypto名称,格式是ALGORITM_KEYSIZE_MODE。格式是ALGORITM_KEYSIZE_MODE。</target>
        </trans-unit>
        <trans-unit id="861a2e8c420a1842a7f2ab5f571c0efd4455430e" translate="yes" xml:space="preserve">
          <source>The new port owner gets linked to the port.</source>
          <target state="translated">新的端口所有者会被链接到这个端口。</target>
        </trans-unit>
        <trans-unit id="902088f9e762def66cfe8ee46deb82a6a7c3b707" translate="yes" xml:space="preserve">
          <source>The new process starts executing in &lt;code&gt;Module:Name(Arg1,...,ArgN)&lt;/code&gt; where the arguments are the elements of the (possible empty) &lt;code&gt;Args&lt;/code&gt; argument list.</source>
          <target state="translated">新过程开始在 &lt;code&gt;Module:Name(Arg1,...,ArgN)&lt;/code&gt; 中执行，其中参数是 &lt;code&gt;Args&lt;/code&gt; 参数列表（可能为空）的元素。</target>
        </trans-unit>
        <trans-unit id="01969408fe300767acbbb5a6a95d7a01999fe18a" translate="yes" xml:space="preserve">
          <source>The new profile has no proxy settings, so the connection is refused:</source>
          <target state="translated">新的配置文件没有代理设置,所以连接被拒绝。</target>
        </trans-unit>
        <trans-unit id="272d17b899e78f71208c1a6461cad1aeb1df67f2" translate="yes" xml:space="preserve">
          <source>The new release must still be made permanent after the upgrade is completed, otherwise the old emulator is started if there is an emulator restart.</source>
          <target state="translated">升级完成后,新的版本仍然必须是永久性的,否则如果有模拟器重启,就会启动旧的模拟器。</target>
        </trans-unit>
        <trans-unit id="5848daab5022f7091ecd71b8112f54b552d8ba95" translate="yes" xml:space="preserve">
          <source>The new release package now also contains version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt; and the &lt;code&gt;relup&lt;/code&gt; file:</source>
          <target state="translated">现在，新的发行包还包含 &lt;code&gt;ch_app&lt;/code&gt; 的版本&amp;ldquo; 2&amp;rdquo; 和 &lt;code&gt;relup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="151b13999b32ae6dd1c2edc6085a347c6f775003" translate="yes" xml:space="preserve">
          <source>The new release version must be made permanent when the new emulator is operational. Otherwise, the old version will be used if there is a new system reboot.</source>
          <target state="translated">当新的模拟器运行时,新的发布版本必须是永久性的,否则,如果有新的系统重启,旧的版本将被使用。否则,如果有新的系统重新启动,旧版本将被使用。</target>
        </trans-unit>
        <trans-unit id="dcca389ca88db583caeb0a8f28a9b042cb4dbdc7" translate="yes" xml:space="preserve">
          <source>The new supervisor process calls the callback function &lt;code&gt;ch_sup:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; shall return &lt;code&gt;{ok, {SupFlags, ChildSpecs}}&lt;/code&gt;:</source>
          <target state="translated">新的主管进程将调用回调函数 &lt;code&gt;ch_sup:init([])&lt;/code&gt; 。 &lt;code&gt;init&lt;/code&gt; 应返回 &lt;code&gt;{ok, {SupFlags, ChildSpecs}}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51319161abd02362f27a398a1fe31b0e9c37ac47" translate="yes" xml:space="preserve">
          <source>The new verbs make use of what was previously invalid syntax: an opening parenthesis followed by an asterisk. They are generally of the form (*VERB) or (*VERB:NAME). Some can take either form, possibly behaving differently depending on whether a name is present. A name is any sequence of characters that does not include a closing parenthesis. The maximum name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that is, if the closing parenthesis immediately follows the colon, the effect is as if the colon was not there. Any number of these verbs can occur in a pattern.</source>
          <target state="translated">新的动词使用了以前无效的语法:开头的小括号和后面的星号。它们的形式一般是(*VERB)或(*VERB:NAME)。有些可以采用其中一种形式,可能根据是否存在名称而表现不同。名称是指不包含括号的任何字符序列。在8位库中,名字的最大长度是255,在16位和32位库中是65535。如果名字是空的,也就是说,如果结尾小括号紧跟在冒号后面,效果就像冒号不在那里一样。这些动词的任意数量都可以出现在一个模式中。</target>
        </trans-unit>
        <trans-unit id="215b161818282063f148ff8da610c62e944bf7ef" translate="yes" xml:space="preserve">
          <source>The newline convention affects where the circumflex and dollar assertions are true. It also affects the interpretation of the dot metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set, and the behavior of \N. However, it does not affect what the \R escape sequence matches. By default, this is any Unicode newline sequence, for Perl compatibility. However, this can be changed; see the description of \R in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt;. A change of the \R setting can be combined with a change of the newline convention.</source>
          <target state="translated">换行约定会影响转折符和美元断言的正确位置。当未设置 &lt;code&gt;dotall&lt;/code&gt; 时，它还会影响点元字符的解释以及\ N的行为。但是，它不会影响\ R转义序列匹配的内容。默认情况下，这是任何Unicode换行符序列，以实现Perl兼容性。但是，可以更改。请参见\ R在 &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; 部分中的描述。\ R设置的更改可以与换行约定的更改结合使用。</target>
        </trans-unit>
        <trans-unit id="fa9ce37388c079f08c2d34d6dbefdaceaae17a26" translate="yes" xml:space="preserve">
          <source>The next example has both &lt;code&gt;Subject&lt;/code&gt; and &lt;code&gt;Subject Alternate Name&lt;/code&gt; present:</source>
          <target state="translated">下一个示例同时显示&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4312b6eb6f9623ee8f0dbf0acd84042778ca8185" translate="yes" xml:space="preserve">
          <source>The next example is the ping pong program, yet again, but this time &quot;ping&quot; is started in another node:</source>
          <target state="translated">下一个例子是ping pong程序,又是这样,但这次 &quot;ping &quot;是在另一个节点上启动的。</target>
        </trans-unit>
        <trans-unit id="7a489b889bb50acfc73253c688e246f84e36bfb1" translate="yes" xml:space="preserve">
          <source>The next few commands assume that &lt;code&gt;test1:demo(X)&lt;/code&gt; is defined as follows:</source>
          <target state="translated">接下来的几个命令假定 &lt;code&gt;test1:demo(X)&lt;/code&gt; 的定义如下：</target>
        </trans-unit>
        <trans-unit id="a78aa43091c6b8ceee531b79859ff361a0c70162" translate="yes" xml:space="preserve">
          <source>The next few commands show some record manipulation. It is assumed that &lt;code&gt;ex.erl&lt;/code&gt; defines a record as follows:</source>
          <target state="translated">接下来的几个命令显示了一些记录操作。假设 &lt;code&gt;ex.erl&lt;/code&gt; 定义一条记录如下：</target>
        </trans-unit>
        <trans-unit id="fb2f4c70a5ddd641a7c7cece836164fd20868016" translate="yes" xml:space="preserve">
          <source>The next template matches on the &lt;code&gt;bike&lt;/code&gt; element:</source>
          <target state="translated">下一个模板与 &lt;code&gt;bike&lt;/code&gt; 元素匹配：</target>
        </trans-unit>
        <trans-unit id="a16f244aabb2c027dad8ecd56e3339ed0a20d48b" translate="yes" xml:space="preserve">
          <source>The nif writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored by the runtime system, so &lt;code&gt;ErlNifMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on. To compare two monitors, &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt; enif_compare_monitors&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">nif &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt; 器将在调用enif_monitor_process时提供用于存储监视器的内存。数据的地址不是由运行时系统存储的，因此 &lt;code&gt;ErlNifMonitor&lt;/code&gt; 可以用作任何其他数据，可以将其复制，移动到内存中，遗忘等等。要比较两个监视器，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt; enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95db43fd70e2774066c2eb7f8160a4afc368f658" translate="yes" xml:space="preserve">
          <source>The nif writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored by the runtime system, so &lt;code&gt;ErlNifMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on. To compare two monitors, &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">nif &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 器将在调用enif_monitor_process时提供用于存储监视器的内存。数据的地址不是由运行时系统存储的，因此 &lt;code&gt;ErlNifMonitor&lt;/code&gt; 可以用作任何其他数据，可以将其复制，移动到内存中，遗忘等等。要比较两个监视器，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08409f3c21c53e70ad49f4d51fc6209994cfdfe6" translate="yes" xml:space="preserve">
          <source>The node can handle extended pids and ports. This is required today. If not present, the connection is refused.</source>
          <target state="translated">节点可以处理扩展的pids和端口。这在今天是必须的。如果不存在,连接将被拒绝。</target>
        </trans-unit>
        <trans-unit id="adf1b573a05c36f8b4bbc38dde3486e57ec7bb5f" translate="yes" xml:space="preserve">
          <source>The node identified by &lt;code&gt;Node&lt;/code&gt; does not support spawn operations issued by &lt;code&gt;spawn_request()&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;Node&lt;/code&gt; 标识的节点不支持 &lt;code&gt;spawn_request()&lt;/code&gt; 发出的生成操作。</target>
        </trans-unit>
        <trans-unit id="bc5a5b212db7cd4390e6199cd85d2036154a00d5" translate="yes" xml:space="preserve">
          <source>The node implements an atom cache (obsolete).</source>
          <target state="translated">节点实现了原子缓存(过时)。</target>
        </trans-unit>
        <trans-unit id="281b9f23f7b8d53d42a4c87c8c2ac676439952b2" translate="yes" xml:space="preserve">
          <source>The node implements atom cache in distribution header.</source>
          <target state="translated">节点在分布头中实现了原子缓存。</target>
        </trans-unit>
        <trans-unit id="1d081f7d6c9b36af20a121c7eb30cda4b27e3f40" translate="yes" xml:space="preserve">
          <source>The node implements distributed named process monitoring.</source>
          <target state="translated">节点实现分布式命名进程监控。</target>
        </trans-unit>
        <trans-unit id="e3fed8a46db41b2b3acc894e988a972c7e551cd4" translate="yes" xml:space="preserve">
          <source>The node implements distributed process monitoring.</source>
          <target state="translated">节点实现了分布式进程监控。</target>
        </trans-unit>
        <trans-unit id="c290f1695a97d158f0cca645bdaac52154a45a48" translate="yes" xml:space="preserve">
          <source>The node implements extended (3 &amp;times; 32 bits) references. This is required today. If not present, the connection is refused.</source>
          <target state="translated">该节点实现扩展（3&amp;times;32位）引用。今天这是必需的。如果不存在，则拒绝连接。</target>
        </trans-unit>
        <trans-unit id="220f04ba10adb170f6a597676f032142dfa5b439" translate="yes" xml:space="preserve">
          <source>The node in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">pid &lt;code&gt;t&lt;/code&gt; 中的节点。</target>
        </trans-unit>
        <trans-unit id="b04ef2a66fbcd0df01a238b3b604c182b6b0fdf3" translate="yes" xml:space="preserve">
          <source>The node in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">端口 &lt;code&gt;t&lt;/code&gt; 中的节点。</target>
        </trans-unit>
        <trans-unit id="75176ee78897d13c331b9db88b37a6e3a9d123c3" translate="yes" xml:space="preserve">
          <source>The node is accessible through a new pipe:</source>
          <target state="translated">节点可以通过新的管道访问。</target>
        </trans-unit>
        <trans-unit id="28fa0e5cd5fe4594591931d814b0c4ba1e753d94" translate="yes" xml:space="preserve">
          <source>The node is to be published and part of the global namespace.</source>
          <target state="translated">要发布的节点是全局命名空间的一部分。</target>
        </trans-unit>
        <trans-unit id="d54e976693fcf1e41748b27bf394174406184e6a" translate="yes" xml:space="preserve">
          <source>The node name &lt;code&gt;Node&lt;/code&gt; is to be the name of the C node. If short node names are used, the plain name of the node is &lt;code&gt;cN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. If long node names are used, there is no such restriction. An example of a C node name using short node names is thus &lt;code&gt;c1@idril&lt;/code&gt;, an example using long node names is &lt;code&gt;cnode@idril.ericsson.se&lt;/code&gt;.</source>
          <target state="translated">节点名称 &lt;code&gt;Node&lt;/code&gt; 将作为C节点的名称。如果使用短节点名，则该节点的纯名称为 &lt;code&gt;cN&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 为整数。如果使用长节点名，则没有这种限制。因此，使用短节点名称的C节点名称的示例为 &lt;code&gt;c1@idril&lt;/code&gt; ，使用长节点名称的示例为 &lt;code&gt;cnode@idril.ericsson.se&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec68e7e5a1c1e0362af0ba664dfbe218c891bbb8" translate="yes" xml:space="preserve">
          <source>The node name as an UTF-8 encoded string of &lt;code&gt;Nlen&lt;/code&gt; bytes.</source>
          <target state="translated">节点名称为 &lt;code&gt;Nlen&lt;/code&gt; 字节的UTF-8编码字符串。</target>
        </trans-unit>
        <trans-unit id="54e641481b78d40b7f0d13f44dc8ac44945e2bc1" translate="yes" xml:space="preserve">
          <source>The node name of the Erlang machine. Distribution is mandatory. Defaults to &lt;code&gt;-sname &amp;lt;service name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang机器的节点名称。分发是强制性的。缺省为 &lt;code&gt;-sname &amp;lt;service name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7013f821805350971680d8e2b7cebcb41595b7b3" translate="yes" xml:space="preserve">
          <source>The node name of this node.</source>
          <target state="translated">这个节点的节点名。</target>
        </trans-unit>
        <trans-unit id="d86c6e1ca2f04c51bd365df74dcf158fdb370851" translate="yes" xml:space="preserve">
          <source>The node name will be &lt;code&gt;Name@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified host name of the current host. For short names, use flag &lt;code&gt;-sname&lt;/code&gt; instead.</source>
          <target state="translated">节点名称将为 &lt;code&gt;Name@Host&lt;/code&gt; ，其中 &lt;code&gt;Host&lt;/code&gt; 是当前主机的标准主机名。对于短名称，请改用标志 &lt;code&gt;-sname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fca1953bdb5dbf94dcc8389d42b6cefbece8cd" translate="yes" xml:space="preserve">
          <source>The node name.</source>
          <target state="translated">节点名称。</target>
        </trans-unit>
        <trans-unit id="9bcf7d5cb8ed6df1804c572bc6bf038771c7e18c" translate="yes" xml:space="preserve">
          <source>The node on which the client process resides has gone down.</source>
          <target state="translated">客户端进程所在的节点出现了故障。</target>
        </trans-unit>
        <trans-unit id="41f458450045ddabec1cec2d090c135189e5c611" translate="yes" xml:space="preserve">
          <source>The node pool contains a list of nodes and can explicitly be set at table creation and later be changed with &lt;code&gt;{add_node, Node}&lt;/code&gt; or &lt;code&gt;{del_node, Node}&lt;/code&gt;. At table creation &lt;code&gt;Mnesia&lt;/code&gt; tries to distribute the replicas of each fragment evenly over all the nodes in the node pool. Hopefully all nodes end up with the same number of replicas. &lt;code&gt;node_pool&lt;/code&gt; defaults to the return value from the function &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(db_nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">节点池包含一个节点列表，可以在创建表时显式设置，然后使用 &lt;code&gt;{add_node, Node}&lt;/code&gt; 或 &lt;code&gt;{del_node, Node}&lt;/code&gt; 进行更改。创建表时， &lt;code&gt;Mnesia&lt;/code&gt; 会尝试将每个片段的副本均匀分布在节点池中的所有节点上。希望所有节点最终具有相同数量的副本。 &lt;code&gt;node_pool&lt;/code&gt; 默认为函数 &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(db_nodes)&lt;/a&gt;&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="bb18c8c170c30a02a3c704bc350cd058950a8fa7" translate="yes" xml:space="preserve">
          <source>The node supports the new connection setup handshake (version 6) introduced in OTP 23.</source>
          <target state="translated">节点支持OTP 23中引入的新的连接设置握手(版本6)。</target>
        </trans-unit>
        <trans-unit id="207f55f45138fa70f0de9e05412ca7fa4d942620" translate="yes" xml:space="preserve">
          <source>The node understand UTF-8 encoded atoms.</source>
          <target state="translated">该节点能理解UTF-8编码的原子。</target>
        </trans-unit>
        <trans-unit id="0361bcd66b03f6607ace0b0251db2af07f52cb88" translate="yes" xml:space="preserve">
          <source>The node understand big node creation.</source>
          <target state="translated">节点了解大节点创建。</target>
        </trans-unit>
        <trans-unit id="9bd7f509d096720411cce80a4c0204a3408b6f8e" translate="yes" xml:space="preserve">
          <source>The node understand new fun tags.</source>
          <target state="translated">节点了解新的趣味标签。</target>
        </trans-unit>
        <trans-unit id="894ceecec4e308228c7ad91a5d1bc07ff9266078" translate="yes" xml:space="preserve">
          <source>The node understand the &lt;code&gt;SMALL_ATOM_EXT&lt;/code&gt; tag.</source>
          <target state="translated">节点了解 &lt;code&gt;SMALL_ATOM_EXT&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="151f8180c3b312748f09057c417efde3a689457c" translate="yes" xml:space="preserve">
          <source>The node understand the map tag.</source>
          <target state="translated">节点了解地图标签。</target>
        </trans-unit>
        <trans-unit id="c7810a13abb77b29712cc6cfd1ea54c29e818c22" translate="yes" xml:space="preserve">
          <source>The node understands UTF-8 atoms encoded with &lt;code&gt;&lt;a href=&quot;erl_ext_dist#ATOM_UTF8_EXT&quot;&gt; ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_ext_dist#SMALL_ATOM_UTF8_EXT&quot;&gt; SMALL ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该节点可以理解用 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#ATOM_UTF8_EXT&quot;&gt; ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#SMALL_ATOM_UTF8_EXT&quot;&gt; SMALL ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 编码的UTF-8原子。</target>
        </trans-unit>
        <trans-unit id="3a4dd9f4e1704a375cae1726628772b7f46d3445" translate="yes" xml:space="preserve">
          <source>The node understands any term as the seqtrace label.</source>
          <target state="translated">节点将任何术语理解为seqtrace标签。</target>
        </trans-unit>
        <trans-unit id="0341c373d5405b7364701792bd5b46a26ac365a9" translate="yes" xml:space="preserve">
          <source>The node understands big node creation tags &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_PID_EXT&quot;&gt;NEW_PID_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_PORT_EXT&quot;&gt;NEW_PORT_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEWER_REFERENCE_EXT&quot;&gt;NEWER_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">节点了解大节点创建标签 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_PID_EXT&quot;&gt;NEW_PID_EXT&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_PORT_EXT&quot;&gt;NEW_PORT_EXT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEWER_REFERENCE_EXT&quot;&gt;NEWER_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e934f26ef40068597701c482448fa6fcf04ed31" translate="yes" xml:space="preserve">
          <source>The node understands new float format.</source>
          <target state="translated">该节点理解新的浮点格式。</target>
        </trans-unit>
        <trans-unit id="ad96637946dfd02b7738f78e4b8d85403aa57786" translate="yes" xml:space="preserve">
          <source>The node understands the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#BIT_BINARY_EXT&quot;&gt; BIT_BINARY_EXT&lt;/a&gt;&lt;/code&gt; tag.</source>
          <target state="translated">该节点了解 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#BIT_BINARY_EXT&quot;&gt; BIT_BINARY_EXT&lt;/a&gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="f01b00ceeb1e8abcca92d85dfefd11c259f05956" translate="yes" xml:space="preserve">
          <source>The node understands the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#EXPORT_EXT&quot;&gt; EXPORT_EXT&lt;/a&gt;&lt;/code&gt; tag.</source>
          <target state="translated">该节点理解 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#EXPORT_EXT&quot;&gt; EXPORT_EXT&lt;/a&gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="9990c11d1d0b07b243a9b0cdea936eb23b56b454" translate="yes" xml:space="preserve">
          <source>The node understands the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_FLOAT_EXT&quot;&gt; NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; tag.</source>
          <target state="translated">该节点理解 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_FLOAT_EXT&quot;&gt; NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="745bdffd1db649c69bf2d92c810818d8bc0e648e" translate="yes" xml:space="preserve">
          <source>The node understands the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_FUN_EXT&quot;&gt; NEW_FUN_EXT&lt;/a&gt;&lt;/code&gt; tag.</source>
          <target state="translated">该节点理解 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#NEW_FUN_EXT&quot;&gt; NEW_FUN_EXT&lt;/a&gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="5ac9602d892e211f57474be11cede72f100d6978" translate="yes" xml:space="preserve">
          <source>The node understands the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#SMALL_ATOM_EXT&quot;&gt; SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; tag.</source>
          <target state="translated">该节点理解 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#SMALL_ATOM_EXT&quot;&gt; SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="f7b476f54ad7c58a60a575f66f1444b8b35c64ad" translate="yes" xml:space="preserve">
          <source>The node understands the map tag &lt;code&gt;&lt;a href=&quot;erl_ext_dist#MAP_EXT&quot;&gt;MAP_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">节点了解地图标记 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#MAP_EXT&quot;&gt;MAP_EXT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91629496aa70f12f9dc344d8279c147f91e3a165" translate="yes" xml:space="preserve">
          <source>The node uses separate tag for funs (lambdas) in the distribution protocol.</source>
          <target state="translated">节点在分发协议中对funs(lambdas)使用单独的标签。</target>
        </trans-unit>
        <trans-unit id="f74fa1efb28b655576befa4c9558a73c950b9df2" translate="yes" xml:space="preserve">
          <source>The node where the table is stored. This field is no longer meaningful, as tables cannot be accessed from other nodes.</source>
          <target state="translated">存储表格的节点。该字段不再有意义,因为不能从其他节点访问表格。</target>
        </trans-unit>
        <trans-unit id="8ab9dd8f7f54478754ba9f39a29a916791467814" translate="yes" xml:space="preserve">
          <source>The nodes in a distributed Erlang system are loosely connected. The first time the name of another node is used, for example, if &lt;code&gt;spawn(Node,M,F,A)&lt;/code&gt; or &lt;code&gt;net_adm:ping(Node)&lt;/code&gt; is called, a connection attempt to that node is made.</source>
          <target state="translated">分布式Erlang系统中的节点是松散连接的。第一次使用另一个节点的名称时，例如，如果调用了 &lt;code&gt;spawn(Node,M,F,A)&lt;/code&gt; 或 &lt;code&gt;net_adm:ping(Node)&lt;/code&gt; ,则尝试与该节点建立连接。</target>
        </trans-unit>
        <trans-unit id="2ac2e00494210b4cb8b0c05904a98cf82ca69740" translate="yes" xml:space="preserve">
          <source>The nodes of the syntax tree must contain valid position information. This can be single integers, assumed to represent a line number, or 2- or 3-tuples where the first or second element is an integer, in which case the leftmost integer element is assumed to represent the line number. Line numbers less than one are ignored (usually, the default line number for newly created nodes is zero).</source>
          <target state="translated">语法树的结点必须包含有效的位置信息,可以是单个整数,假设代表行号,也可以是2或3元组,其中第一个或第二个元素是整数,在这种情况下,假设最左边的整数元素代表行号。这可以是单个整数,假设它代表行号,也可以是2-或3-元组,其中第一个或第二个元素是整数,在这种情况下,最左边的整数元素被假设为行号。小于1的行号会被忽略(通常,新创建节点的默认行号为0)。</target>
        </trans-unit>
        <trans-unit id="27b14beb9cceb4576be4663fcf085a80811579bb" translate="yes" xml:space="preserve">
          <source>The non-fragmented distribution header format is as follows:</source>
          <target state="translated">非碎片化的分发头格式如下:</target>
        </trans-unit>
        <trans-unit id="3a500c6b344c68f0a4b0eb600d18358a8deed739" translate="yes" xml:space="preserve">
          <source>The non-local function handler &lt;strong&gt;is&lt;/strong&gt; however called with the evaluated arguments of the call to &lt;code&gt;erlang:apply/2,3&lt;/code&gt;: &lt;code&gt;Func(Fun, Args)&lt;/code&gt; or &lt;code&gt;Func({Module, Function}, Args)&lt;/code&gt; (assuming that &lt;code&gt;{Module, Function}&lt;/code&gt; is not &lt;code&gt;{erlang, apply}&lt;/code&gt;).</source>
          <target state="translated">非本地函数处理器&lt;strong&gt;被&lt;/strong&gt;然而称为与该呼叫到的评价参数 &lt;code&gt;erlang:apply/2,3&lt;/code&gt; ： &lt;code&gt;Func(Fun, Args)&lt;/code&gt; 或 &lt;code&gt;Func({Module, Function}, Args)&lt;/code&gt; （假设 &lt;code&gt;{Module, Function}&lt;/code&gt; 不是 &lt;code&gt;{erlang, apply}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2104dfaf943c18e872cc21b511c0366a7ea1b0fb" translate="yes" xml:space="preserve">
          <source>The non-local function handler argument is probably not used as frequently as the local function handler argument. A possible use is to call &lt;code&gt;exit/1&lt;/code&gt; on calls to functions that for some reason are not allowed to be called.</source>
          <target state="translated">非本地函数处理程序参数可能不像本地函数处理程序参数那样频繁使用。一种可能的用法是在由于某些原因不允许调用的函数的调用上调用 &lt;code&gt;exit/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7c221c15b667bea31580924db95e510885f6679" translate="yes" xml:space="preserve">
          <source>The normal use is to call the function without checking the return value, as it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired and &lt;code&gt;ok&lt;/code&gt; if it was a read lock.</source>
          <target state="translated">通常的用法是在不检查返回值的情况下调用该函数，因为如果失败则退出并由事务管理器重新启动事务。如果写入锁被获取并返回所有锁定节点 &lt;code&gt;ok&lt;/code&gt; 它是否是一个读锁。</target>
        </trans-unit>
        <trans-unit id="80f684e59f18c37c44446b26508979681edb5449" translate="yes" xml:space="preserve">
          <source>The normal way to use the agent in a distributed environment is to use one master agent located at one node, and zero or more sub-agents located on other nodes. However, this configuration makes the master agent node a single point of failure. If that node goes down, the agent will not work.</source>
          <target state="translated">在分布式环境中使用代理的正常方式是使用一个位于一个节点上的主代理,以及位于其他节点上的零个或多个子代理。然而,这种配置使得主代理节点成为一个单一的故障点。如果该节点宕机,代理将无法工作。</target>
        </trans-unit>
        <trans-unit id="9ba563ac5d8211aacd6368767fc138e78d6d98e9" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map. Note that this notation is not a shorthand for the &lt;code&gt;map()&lt;/code&gt; type.</source>
          <target state="translated">符号 &lt;code&gt;#{}&lt;/code&gt; 指定空映射的单例类型。请注意，该符号不是 &lt;code&gt;map()&lt;/code&gt; 类型的简写。</target>
        </trans-unit>
        <trans-unit id="e364c347f33083c7e078a191aa40c2608ebe1b9f" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;X &amp;lt;- [1,2,a,...]&lt;/code&gt; is a generator and the expression &lt;code&gt;X &amp;gt; 3&lt;/code&gt; is a filter.</source>
          <target state="translated">符号 &lt;code&gt;X &amp;lt;- [1,2,a,...]&lt;/code&gt; 是发电机和表达式 &lt;code&gt;X &amp;gt; 3&lt;/code&gt; 是过滤器。</target>
        </trans-unit>
        <trans-unit id="81f71b8120e4071fbcebde5e7f6026aa6ec9c5ff" translate="yes" xml:space="preserve">
          <source>The notification is sent as an Inform-Request to each target address in &lt;code&gt;Addresses&lt;/code&gt; and if there are no targets for which an Inform-Request is sent, &lt;code&gt;Addresses&lt;/code&gt; is the empty list &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">该通知作为Inform-Request发送到 &lt;code&gt;Addresses&lt;/code&gt; 中的每个目标地址，如果没有针对其发送Inform-Request的目标，则 &lt;code&gt;Addresses&lt;/code&gt; 为空列表 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6615a13126440b2f301d9feef9169efe1884cd9" translate="yes" xml:space="preserve">
          <source>The notification is sent to all management targets found in the tables. However, make sure that each manager has access to the variables in the notification. If a variable is outside a manager's MIB view, this manager will not receive the notification.</source>
          <target state="translated">通知会被发送到表格中发现的所有管理目标。但是,要确保每个管理对象都能访问通知中的变量。如果一个变量在某个管理者的MIB视图之外,这个管理者将不会收到通知。</target>
        </trans-unit>
        <trans-unit id="e5c8e9a76a11f6a0d3766776061aee6dbbf3388a" translate="yes" xml:space="preserve">
          <source>The notifications are one-shot only. To receive further notifications of the same type (read or write), repeated calls to &lt;code&gt;enif_select&lt;/code&gt; must be made after receiving each notification.</source>
          <target state="translated">通知是一次性的。要接收更多相同类型的通知（读或写），必须在收到每个通知后重复调用 &lt;code&gt;enif_select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="753c93a00c0ec14ac60e9c970f897dd5f7002f80" translate="yes" xml:space="preserve">
          <source>The notion that every fourth year is a leap year is not completely true. By the Gregorian rule, a year Y is a leap year if one of the following rules is valid:</source>
          <target state="translated">每四年为一个闰年的说法并不完全正确。根据格里高利规则,如果下列规则之一有效,则Y年为闰年:</target>
        </trans-unit>
        <trans-unit id="bf37afb1bc5f9dfefc13bbbfc7a24bfd243d1fbf" translate="yes" xml:space="preserve">
          <source>The number (in this case 85) is an integer from 1 to 100 that specifies the &quot;detail level&quot; of the message. The higher the number, the more important it is. This provides a crude form of priority filtering.</source>
          <target state="translated">数字(在本例中为85)是一个从1到100的整数,指定了信息的 &quot;细节级别&quot;。数字越高,越重要。这提供了一种粗略的优先级过滤形式。</target>
        </trans-unit>
        <trans-unit id="75565d0bbaf52f34d1f2ba494d3d8320058b3d47" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;45&lt;/code&gt; in the example indicates the approximate number of objects that you expect to store in the registry. Internally the registry uses hash tables with collision chaining, so there is no absolute upper limit on the number of objects that the registry can contain, but if performance or memory usage is important, then you are to choose a number accordingly. The registry can be resized later.</source>
          <target state="translated">示例中的数字 &lt;code&gt;45&lt;/code&gt; 表示您希望存储在注册表中的对象的大概数量。在内部，注册表使用具有冲突链的哈希表，因此注册表可以包含的对象数量没有绝对上限，但是如果性能或内存使用很重要，则应相应选择一个数字。注册表可以在以后调整大小。</target>
        </trans-unit>
        <trans-unit id="09c8e0b1b88e54e9d131872b6cb4b6bea1201103" translate="yes" xml:space="preserve">
          <source>The number of &lt;strong&gt;bytes&lt;/strong&gt; pointed to by &lt;code&gt;*pp&lt;/code&gt;, which are part of the bit string, is &lt;code&gt;(*bitoffsp + *nbitsp + 7)/8&lt;/code&gt;. If &lt;code&gt;(*bitoffsp + *bitsp)%8 &amp;gt; 0&lt;/code&gt; then only &lt;code&gt;(*bitoffsp + *bitsp)%8&lt;/code&gt; bits of the last byte are used. Unused bits in the last byte are the least significant bits.</source>
          <target state="translated">&lt;code&gt;*pp&lt;/code&gt; 所指向的&lt;strong&gt;字节&lt;/strong&gt;数是 &lt;code&gt;(*bitoffsp + *nbitsp + 7)/8&lt;/code&gt; ，它是位字符串的一部分。如果 &lt;code&gt;(*bitoffsp + *bitsp)%8 &amp;gt; 0&lt;/code&gt; 则仅使用最后一个字节的 &lt;code&gt;(*bitoffsp + *bitsp)%8&lt;/code&gt; 位。最后一个字节中未使用的位是最低有效位。</target>
        </trans-unit>
        <trans-unit id="79ec78d782f41f740663e090268ce34602ccfb0f" translate="yes" xml:space="preserve">
          <source>The number of ETS tables visible in the dump.</source>
          <target state="translated">转储中可见的ETS表的数量。</target>
        </trans-unit>
        <trans-unit id="ed2f858d504fbf2ee02e66edd9c9a034cd3c8f0e" translate="yes" xml:space="preserve">
          <source>The number of allocated heap fragments.</source>
          <target state="translated">已分配的堆碎片数量。</target>
        </trans-unit>
        <trans-unit id="511df0ea6957d5c04e1b4408f5d45d7fc95571c7" translate="yes" xml:space="preserve">
          <source>The number of arguments &lt;code&gt;N&lt;/code&gt; is the &lt;strong&gt;arity&lt;/strong&gt; of the function. A function is uniquely defined by the module name, function name, and arity. That is, two functions with the same name and in the same module, but with different arities are two different functions.</source>
          <target state="translated">参数的数量 &lt;code&gt;N&lt;/code&gt; 是函数的&lt;strong&gt;稀疏&lt;/strong&gt;性。功能由模块名称，功能名称和属性唯一定义。也就是说，具有相同名称和相同模块但具有不同Arity的两个函数是两个不同的函数。</target>
        </trans-unit>
        <trans-unit id="e8a544d64f1bd1735966773b7c53b509f448f0d4" translate="yes" xml:space="preserve">
          <source>The number of async threads in the async thread pool used by &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt; erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; 使用的异步线程池中的异步线程数（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt; erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="4219e3c77fe7b6dbf3a9ad6d1ab7b70fa1c036f8" translate="yes" xml:space="preserve">
          <source>The number of async threads in the async thread pool used by &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt;erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; 使用的异步线程池中的异步线程数（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_thread_pool_size&quot;&gt;erlang:system_info(thread_pool_size)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="2bb773d02396909878bd5f6a199ddd7440662e11" translate="yes" xml:space="preserve">
          <source>The number of atomics in the array.</source>
          <target state="translated">阵列中的原子数。</target>
        </trans-unit>
        <trans-unit id="6aed86243ce3461adf935203775b82c23ba81f19" translate="yes" xml:space="preserve">
          <source>The number of atoms in the atom table</source>
          <target state="translated">原子表中的原子数。</target>
        </trans-unit>
        <trans-unit id="9f5063a380fd018a365840c2dbb66e83694f1aa7" translate="yes" xml:space="preserve">
          <source>The number of atoms in the system at the time of the crash is shown as &lt;strong&gt;Atoms: &amp;lt;number&amp;gt;&lt;/strong&gt;. Some ten thousands atoms is perfectly normal, but more can indicate that the BIF &lt;code&gt;erlang:list_to_atom/1&lt;/code&gt; is used to generate many &lt;strong&gt;different&lt;/strong&gt; atoms dynamically, which is never a good idea.</source>
          <target state="translated">崩溃时系统中的&lt;strong&gt;原子数&lt;/strong&gt;显示为&lt;strong&gt;Atoms：&amp;lt;number&amp;gt;&lt;/strong&gt;。大约一万个原子是完全正常的，但是更多的原子可以表明BIF &lt;code&gt;erlang:list_to_atom/1&lt;/code&gt; 用于动态生成许多&lt;strong&gt;不同的&lt;/strong&gt;原子，这绝不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="81cc5c0b1499ff4c5b3ebec69fbeedae90b697d7" translate="yes" xml:space="preserve">
          <source>The number of bytes encrypted or decrypted so far.</source>
          <target state="translated">到目前为止已加密或解密的字节数。</target>
        </trans-unit>
        <trans-unit id="ea3fcca2aba12760c02a1a76dc0666cf98e0e6d8" translate="yes" xml:space="preserve">
          <source>The number of bytes which is part of the bit string is &lt;code&gt;(bitoffs + nbits + 7)/8&lt;/code&gt;. If &lt;code&gt;(bitoffs + nbits)%8 &amp;gt; 0&lt;/code&gt; then only &lt;code&gt;(bitoffs + nbits)%8&lt;/code&gt; bits of the last byte are used. Unused bits in the last byte are the least significant bits.</source>
          <target state="translated">作为位字符串的一部分的字节数为 &lt;code&gt;(bitoffs + nbits + 7)/8&lt;/code&gt; 。如果 &lt;code&gt;(bitoffs + nbits)%8 &amp;gt; 0&lt;/code&gt; 则仅使用最后一个字节的 &lt;code&gt;(bitoffs + nbits)%8&lt;/code&gt; 位。最后一个字节中未使用的位是最低有效位。</target>
        </trans-unit>
        <trans-unit id="3d9211c3c41f9a0491a5cc3cd3b981543236ed4b" translate="yes" xml:space="preserve">
          <source>The number of bytes written (including terminating &lt;code&gt;NULL&lt;/code&gt; character)</source>
          <target state="translated">写入的字节数（包括终止 &lt;code&gt;NULL&lt;/code&gt; 字符）</target>
        </trans-unit>
        <trans-unit id="ae7a4579876ef85c9e9b38e1a9a4a8cc0f7ae5cf" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the current wrap log file.</source>
          <target state="translated">写入当前wrap日志文件的字节数。</target>
        </trans-unit>
        <trans-unit id="0001e454297af213d4f16647035ec6c8df13a4c0" translate="yes" xml:space="preserve">
          <source>The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing whitespace characters are not omitted as they are with &lt;code&gt;s&lt;/code&gt;. All characters are returned.</source>
          <target state="translated">读取等于字段宽度的字符数（默认为1），并作为Erlang字符串返回。但是，与 &lt;code&gt;s&lt;/code&gt; 一样，开头和结尾的空白字符也不会被忽略。返回所有字符。</target>
        </trans-unit>
        <trans-unit id="1137a738d4cfe43f2175847454d3ab0330b78877" translate="yes" xml:space="preserve">
          <source>The number of characters in the matched token.</source>
          <target state="translated">匹配标记中的字符数。</target>
        </trans-unit>
        <trans-unit id="28d997d875f7f8d0bd44b7c91e3ffe255434909a" translate="yes" xml:space="preserve">
          <source>The number of connections established depends on the user's configuration. Multiple connections per peer is possible.</source>
          <target state="translated">建立的连接数取决于用户的配置。每个对等体可以建立多个连接。</target>
        </trans-unit>
        <trans-unit id="56afc80d65345bb7425e660f84953f71835985c4" translate="yes" xml:space="preserve">
          <source>The number of counters in the array.</source>
          <target state="translated">阵列中的计数器数量。</target>
        </trans-unit>
        <trans-unit id="843b00b0f1b4bd5efff8041a104dc4a8c1ddc0ce" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads created cannot exceed the number of normal scheduler threads created.</source>
          <target state="translated">创建的脏CPU调度线程数不能超过创建的正常调度线程数。</target>
        </trans-unit>
        <trans-unit id="b3138269edadb8dc8d29f17322230f4a4a908849" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads is determined at emulator boot time and cannot be changed after that. However, the number of dirty CPU scheduler threads online can be changed at any time. The number of dirty CPU schedulers can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; or &lt;code&gt;+SDPcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">肮脏的CPU调度程序线程的数量是在模拟器启动时确定的，此后无法更改。但是，可以随时更改联机的肮脏CPU调度程序线程的数量。可以在启动时通过在 &lt;code&gt;erl(1)&lt;/code&gt; 中传递命令行标志 &lt;code&gt;+SDcpu&lt;/code&gt; 或 &lt;code&gt;+SDPcpu&lt;/code&gt; 来设置脏CPU调度程序的数量。</target>
        </trans-unit>
        <trans-unit id="b9da52b4c5d5ed584c408c7a1defe4da48427716" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU scheduler threads online cannot exceed the number of normal scheduler threads online.</source>
          <target state="translated">脏CPU调度线程的在线数量不能超过正常调度线程的在线数量。</target>
        </trans-unit>
        <trans-unit id="03808e9ad1a5bc412f55e40aed263839ec59bc4d" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can be set at startup by passing command-line flag &lt;code&gt;+SDcpu&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">可以在启动时通过在 &lt;code&gt;erl(1)&lt;/code&gt; 中传递命令行标志 &lt;code&gt;+SDcpu&lt;/code&gt; 来设置联机的肮脏CPU调度程序的数量。</target>
        </trans-unit>
        <trans-unit id="e91fedb2f48921c5c8faa40b4bcc9a3dfcee32c3" translate="yes" xml:space="preserve">
          <source>The number of dirty CPU schedulers online can change if the number of schedulers online changes. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">如果联机的调度程序数量发生更改，则联机的脏CPU调度程序的数量可能会更改。例如，如果12个调度程序和6个脏CPU调度程序处于联机状态，并且使用 &lt;code&gt;system_flag/2&lt;/code&gt; 将联机的调度程序数设置为6，则联机的脏CPU调度程序数也会自动减少一半，降至3。同样，联机的肮脏CPU调度程序的数量与联机调度程序的数量成比例地增加。</target>
        </trans-unit>
        <trans-unit id="296f215c8d873bb49890168fa9e88995a8c46221" translate="yes" xml:space="preserve">
          <source>The number of elements in the returned &lt;code&gt;OptionValues&lt;/code&gt; list does not necessarily correspond to the number of options asked for. If the operating system fails to support an option, it is left out in the returned list. An error tuple is returned only when getting options for the socket is impossible (that is, the socket is closed or the buffer size in a raw request is too large). This behavior is kept for backward compatibility reasons.</source>
          <target state="translated">返回的 &lt;code&gt;OptionValues&lt;/code&gt; 列表中的元素数量不一定与所要求的选项数量相对应。如果操作系统不支持某个选项，则在返回的列表中将其遗漏。仅当无法获取套接字选项时（即套接字已关闭或原始请求中的缓冲区大小太大），才返回错误元组。出于向后兼容的原因保留此行为。</target>
        </trans-unit>
        <trans-unit id="4cf38aefd99559296dffb26d07e3e9c61e6e9cb2" translate="yes" xml:space="preserve">
          <source>The number of elements in tuple &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">元组 &lt;code&gt;t&lt;/code&gt; 中的元素数。</target>
        </trans-unit>
        <trans-unit id="26ac4cc854d74b2c6762d35018676306c4817781" translate="yes" xml:space="preserve">
          <source>The number of file descriptors for sockets exceeds 1024 (Unix only). The limit on file descriptors in some Unix flavors can be set to over 1024, but only 1024 sockets/pipes can be used simultaneously by Erlang (because of limitations in the Unix &lt;code&gt;select&lt;/code&gt; call). The number of open regular files is not affected by this.</source>
          <target state="translated">套接字的文件描述符数量超过1024（仅Unix）。在某些Unix风格中，文件描述符的限制可以设置为超过1024，但是Erlang只能同时使用1024个套接字/管道（由于Unix &lt;code&gt;select&lt;/code&gt; 调用的限制）。打开的常规文件的数量不受此影响。</target>
        </trans-unit>
        <trans-unit id="b6877de2384845937a41dca03e443b8b2ef2f56b" translate="yes" xml:space="preserve">
          <source>The number of free blocks available to the Erlang runtime system. This gives a fair indication of how fragmented the memory is.</source>
          <target state="translated">Erlang运行时系统可用的空闲块数量。这可以很好地说明内存的碎片化程度。</target>
        </trans-unit>
        <trans-unit id="2302ea4b081c2465e0482782a8cfc33a6b390e01" translate="yes" xml:space="preserve">
          <source>The number of free variables.</source>
          <target state="translated">自由变量的数量;</target>
        </trans-unit>
        <trans-unit id="520aa8d21c613166906958a988904ef3774762d4" translate="yes" xml:space="preserve">
          <source>The number of funs visible in the dump.</source>
          <target state="translated">垃圾站中可见的趣味数量。</target>
        </trans-unit>
        <trans-unit id="b2f69372e36a07c28bf944db66a4eb608b5e6496" translate="yes" xml:space="preserve">
          <source>The number of intervals in the allocated block size histograms. Defaults to 18.</source>
          <target state="translated">分配的块大小直方图中的区间数。默认值为18。</target>
        </trans-unit>
        <trans-unit id="0b9e6ddbdccc43d4ce9130240064e22a9d65b0ef" translate="yes" xml:space="preserve">
          <source>The number of intervals in the free block size histograms. Defaults to 14.</source>
          <target state="translated">自由块大小直方图中的区间数。默认值为14。</target>
        </trans-unit>
        <trans-unit id="8443d0d1c03c60db5f3a78f878917394a94a0502" translate="yes" xml:space="preserve">
          <source>The number of items written to the current wrap log file, header inclusive.</source>
          <target state="translated">写入当前wrap日志文件的条数,包括头部。</target>
        </trans-unit>
        <trans-unit id="1d7b0fbb13153371168cb8b20a96211640b2aed4" translate="yes" xml:space="preserve">
          <source>The number of live argument registers. The argument registers if any are live will follow. These can contain the arguments of the function if they are not yet moved to the stack.</source>
          <target state="translated">活的参数寄存器的数量。如果有活的参数寄存器,将在后面列出。如果函数的参数还没有移动到堆栈中,这些参数可以包含在其中。</target>
        </trans-unit>
        <trans-unit id="eaa55c6a7661cbf8bcd105fb5ba2accf528f1e54" translate="yes" xml:space="preserve">
          <source>The number of loads and unloads by different &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; influences the loading and unloading of a driver file. The port killing therefore only occurs when the &lt;strong&gt;last&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads the driver, or when the last process having loaded the driver exits.</source>
          <target state="translated">不同 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 的加载和卸载次数会影响驱动程序文件的加载和卸载。因此，仅当&lt;strong&gt;最后一个&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 卸载驱动程序或退出最后一个已加载驱动程序的进程时，才会发生端口终止。</target>
        </trans-unit>
        <trans-unit id="24dcf08225a4cd44c2b72687111ada888affaff5" translate="yes" xml:space="preserve">
          <source>The number of messages in the process' message queue.</source>
          <target state="translated">进程消息队列中的消息数量。</target>
        </trans-unit>
        <trans-unit id="acf761f566ec0f6165b7b5bd0f0224040aa67d68" translate="yes" xml:space="preserve">
          <source>The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">总共处理的消息数量(对于所有进程)是mstone值。</target>
        </trans-unit>
        <trans-unit id="18ba056ef97bf335e6f0a4c98db5f6d989f8226b" translate="yes" xml:space="preserve">
          <source>The number of messages that the transaction coordinator and its participants need to exchange is few, as the &lt;code&gt;Mnesia&lt;/code&gt; table load mechanism takes care of the transaction recovery if the commit protocol gets interrupted. Since all involved tables are replicated symmetrically, the transaction is automatically recovered by loading the involved tables from the same node at startup of a failing node. It does not matter if the transaction was committed or terminated as long as the ACID properties can be ensured. The lightweight commit protocol is non-blocking, that is, the surviving participants and their coordinator finish the transaction, even if any node crashes in the middle of the commit protocol.</source>
          <target state="translated">事务协调器及其参与者需要交换的消息数量很少，因为如果提交协议被中断， &lt;code&gt;Mnesia&lt;/code&gt; 表加载机制将负责事务恢复。由于所有涉及的表都是对称复制的，因此通过在出现故障的节点启动时从同一节点加载涉及的表来自动恢复事务。只要可以确保ACID属性，事务是已提交还是终止都没有关系。轻量级提交协议是非阻塞的，也就是说，即使有任何节点在提交协议的中间崩溃，幸存的参与者及其协调者也会完成事务。</target>
        </trans-unit>
        <trans-unit id="6a9dd2a90b5afbfc3e6021a57e6d176d541df76e" translate="yes" xml:space="preserve">
          <source>The number of objects in the table when the table dump to file started. For a &lt;code&gt;public&lt;/code&gt; table, this number does not need to correspond to the number of objects saved to the file, as objects can have been added or deleted by another process during table dump.</source>
          <target state="translated">表转储到文件开始时表中的对象数。对于 &lt;code&gt;public&lt;/code&gt; 表，此数字不必与保存到文件中的对象数相对应，因为在表转储期间，对象可以由另一个进程添加或删除。</target>
        </trans-unit>
        <trans-unit id="e2b7a9263d52e986e0825e5ba3ea4f95ca6e0342" translate="yes" xml:space="preserve">
          <source>The number of objects in the table.</source>
          <target state="translated">表中对象的数量。</target>
        </trans-unit>
        <trans-unit id="c0d1d535423cfacf2174f955ce39067569b39d55" translate="yes" xml:space="preserve">
          <source>The number of objects inserted in the table.</source>
          <target state="translated">在表中插入的对象数量。</target>
        </trans-unit>
        <trans-unit id="df0564a1b8506f23aaa82646ab79be6e878922a7" translate="yes" xml:space="preserve">
          <source>The number of objects written to the file is noted in the file footer, so file truncation can be verified even if the file was updated during dump.</source>
          <target state="translated">写入文件的对象数量会在文件脚注中注明,所以即使文件在dump过程中被更新,也可以验证文件的截断情况。</target>
        </trans-unit>
        <trans-unit id="85699df12b894cf4882879c296b009b318c0eb18" translate="yes" xml:space="preserve">
          <source>The number of outbound and inbound streams can be set by giving an &lt;code&gt;sctp_initmsg&lt;/code&gt; option to &lt;code&gt;connect&lt;/code&gt; as in:</source>
          <target state="translated">出站和入站数据流的数量可以通过给一个设置 &lt;code&gt;sctp_initmsg&lt;/code&gt; 选项，以 &lt;code&gt;connect&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="1edbec7af58e779e6f3839b4b6e2a81fbb1ef2ff" translate="yes" xml:space="preserve">
          <source>The number of parts is to be a positive integer for a specific maximum number of parts, and &lt;code&gt;infinity&lt;/code&gt; for the maximum number of parts possible (the default). Specifying &lt;code&gt;{parts,0}&lt;/code&gt; gives as many parts as possible disregarding empty parts at the end, the same as specifying &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">对于特定的最大数量的零件，零件数应为正整数，对于可能的最大零件数（默认值）应为 &lt;code&gt;infinity&lt;/code&gt; 。指定 &lt;code&gt;{parts,0}&lt;/code&gt; 会给出尽可能多的零件，而不管最后的空零件，这与指定 &lt;code&gt;trim&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6b33306f737902a1c1e912a3c184717cdb9d7d38" translate="yes" xml:space="preserve">
          <source>The number of persistent terms.</source>
          <target state="translated">持久性条款的数量。</target>
        </trans-unit>
        <trans-unit id="2afdcddd62f1f4f544b050e244b0fb462484c316" translate="yes" xml:space="preserve">
          <source>The number of problems that arise when you always expect the wall clock time on the system to be correct can be immense. Erlang therefore introduced the &quot;corrected estimate of time&quot;, or the &quot;time correction&quot;, many years ago. The time correction relies on the fact that most operating systems have some kind of monotonic clock, either a real-time extension or some built-in &quot;tick counter&quot; that is independent of the wall clock settings. This counter can have microsecond resolution or much less, but it has a drift that cannot be ignored.</source>
          <target state="translated">如果你总是期望系统上的挂钟时间是正确的,那么会产生大量的问题。因此,Erlang在很多年前就引入了 &quot;时间的修正估计&quot;,也就是 &quot;时间修正&quot;。时间修正依赖于这样一个事实:大多数操作系统都有某种单调的时钟,要么是实时扩展,要么是一些内置的 &quot;滴答计数器&quot;,它独立于挂钟的设置。这个计数器的分辨率可以是微秒级,也可以更低,但它的漂移是不可忽视的。</target>
        </trans-unit>
        <trans-unit id="57e379e562f068c00ec3666a97b2b72ec4e1ae9a" translate="yes" xml:space="preserve">
          <source>The number of processes on the node.</source>
          <target state="translated">节点上的进程数。</target>
        </trans-unit>
        <trans-unit id="216d68b131398c4d5787004436814a5409c5c6b7" translate="yes" xml:space="preserve">
          <source>The number of processes that are ready to run.</source>
          <target state="translated">准备运行的进程数量。</target>
        </trans-unit>
        <trans-unit id="290cb25c487c21d6fb8fcc8db9708b6206bd9cb5" translate="yes" xml:space="preserve">
          <source>The number of processes visible in the dump.</source>
          <target state="translated">转储中可见的进程数。</target>
        </trans-unit>
        <trans-unit id="83a57a5a9d8d177f4eabd403df33513424ff9d76" translate="yes" xml:space="preserve">
          <source>The number of received messages in this example depends on which OS and which shell that is used on the machine running the &lt;code&gt;ssh&lt;/code&gt; daemon. See also &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在此示例中，接收到的消息数取决于运行 &lt;code&gt;ssh&lt;/code&gt; 守护程序的计算机上使用的操作系统和外壳程序。另请参见 &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="370052d660e4fe42c32d9343e6dadeb67604481b" translate="yes" xml:space="preserve">
          <source>The number of reductions a process is allowed to use before it is scheduled out is increased or reduced.</source>
          <target state="translated">增加或减少一个过程在排定出之前允许使用的减少次数。</target>
        </trans-unit>
        <trans-unit id="2bb198ca00ef4fce937de982b13112d9a0c04566" translate="yes" xml:space="preserve">
          <source>The number of reductions consumed by the process.</source>
          <target state="translated">流程所消耗的还原数;</target>
        </trans-unit>
        <trans-unit id="5a35a61b164da1ac8ca925205248deac1f49ddb0" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process.</source>
          <target state="translated">进程中执行的减少数量;</target>
        </trans-unit>
        <trans-unit id="9b6c91666c81709e6916aac4bcc7db2c019f1985" translate="yes" xml:space="preserve">
          <source>The number of reductions executed on the process. This can be presented as accumulated values or as values since the last update.</source>
          <target state="translated">流程中执行的减少次数。可以用累计值或上次更新以来的值表示。</target>
        </trans-unit>
        <trans-unit id="6e0994d6b82eb6222766c0e382dac55ae059c81e" translate="yes" xml:space="preserve">
          <source>The number of reductions performed before checking I/O is increased or reduced.</source>
          <target state="translated">增加或减少检查I/O前进行的还原次数。</target>
        </trans-unit>
        <trans-unit id="468ae60b67a8e1bd0720dab30af034d085e6396a" translate="yes" xml:space="preserve">
          <source>The number of references to the fun.</source>
          <target state="translated">趣的引用次数。</target>
        </trans-unit>
        <trans-unit id="407623cffa34482fa1d651acd67eee8403ccbecb" translate="yes" xml:space="preserve">
          <source>The number of replicas with storage type &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, and &lt;code&gt;disc_only_copies&lt;/code&gt;, respectively. The actual values are dynamically derived from the first fragment. The first fragment serves as a protype. When the actual values need to be computed (for example, when adding new fragments) they are determined by counting the number of each replica for each storage type. This means that when the functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; are applied on the first fragment, it affects the settings on &lt;code&gt;n_ram_copies&lt;/code&gt;, &lt;code&gt;n_disc_copies&lt;/code&gt;, and &lt;code&gt;n_disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">存储类型分别为 &lt;code&gt;ram_copies&lt;/code&gt; ， &lt;code&gt;disc_copies&lt;/code&gt; 和 &lt;code&gt;disc_only_copies&lt;/code&gt; 的副本数。实际值是从第一个片段动态得出的。第一个片段用作原型。当需要计算实际值时（例如，添加新片段时），可以通过计算每种存储类型的每个副本的数量来确定它们。这意味着，当将函数 &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; 应用于第一个片段时，它将影响 &lt;code&gt;n_ram_copies&lt;/code&gt; ， &lt;code&gt;n_disc_copies&lt;/code&gt; 和 &lt;code&gt;n_disc_only_copies&lt;/code&gt; 的设置。</target>
        </trans-unit>
        <trans-unit id="9a9702435fc48e2cb1af958102326978bfa82700" translate="yes" xml:space="preserve">
          <source>The number of requests that a client can do on one connection. When the server has responded to the number of requests defined by &lt;code&gt;max_keep_alive_requests&lt;/code&gt;, the server closes the connection. The server closes it even if there are queued request. Default is no limit.</source>
          <target state="translated">客户端可以在一个连接上执行的请求数。服务器响应 &lt;code&gt;max_keep_alive_requests&lt;/code&gt; 定义的请求数后，服务器将关闭连接。即使有排队的请求，服务器也会关闭它。默认值是没有限制。</target>
        </trans-unit>
        <trans-unit id="3e6e68ac95a410c172b5340729e962a534a2dd6f" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads is determined at emulator boot time and cannot be changed later. However, the number of schedulers online can be changed at any time.</source>
          <target state="translated">调度器线程的数量是在模拟器启动时确定的,以后不能更改。但是,在线的调度器数量可以在任何时候改变。</target>
        </trans-unit>
        <trans-unit id="8a1037d02b4f98b692b4fe305ad2d9c8798921f5" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads used by the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">运行时系统使用的调度程序线程数（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="5271e1c80bfa6c1f0d80364c70cd4221fb1fac88" translate="yes" xml:space="preserve">
          <source>The number of scheduler threads used by the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">运行时系统使用的调度程序线程数（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="32fda466767f8cc6473462d182e187e0d2a3c92f" translate="yes" xml:space="preserve">
          <source>The number of seconds the server waits for a subsequent request from the client before closing the connection. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">服务器在关闭连接之前等待客户端的后续请求的秒数。默认值为 &lt;code&gt;150&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd94e411933b9c1fa677dbde8d5b69166b1c7e8" translate="yes" xml:space="preserve">
          <source>The number of tables stored at one Erlang node &lt;strong&gt;used&lt;/strong&gt; to be limited. This is no longer the case (except by memory usage). The previous default limit was about 1400 tables and could be increased by setting the environment variable &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; or the command line option &lt;code&gt;+e&lt;/code&gt; before starting the Erlang runtime system. This hard limit has been removed, but it is currently useful to set the &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; anyway. It should be set to an approximate of the maximum amount of tables used. This since an internal table for named tables is sized using this value. If large amounts of named tables are used and &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; hasn't been increased, the performance of named table lookup will degrade.</source>
          <target state="translated">存储在一个Erlang节点上的表的数量&lt;strong&gt;曾经&lt;/strong&gt;受到限制。不再是这种情况（除了内存使用情况）。先前的默认限制约为1400个表，可以通过在启动Erlang运行时系统之前设置环境变量 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; 或命令行选项 &lt;code&gt;+e&lt;/code&gt; 来增加此限制。该硬限制已被删除，但是无论如何现在设置 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; 很有用。应该将其设置为所用表的最大数量的近似值。因为命名表的内部表使用此值确定大小。如果使用了大量命名表，并且未增加 &lt;code&gt;ERL_MAX_ETS_TABLES&lt;/code&gt; ，则命名表查找的性能将降低。</target>
        </trans-unit>
        <trans-unit id="6ee6cef5045ecfc684ba415cb4ca61311f9f1874" translate="yes" xml:space="preserve">
          <source>The number of used reference numbers in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 中使用的参考编号的数量。</target>
        </trans-unit>
        <trans-unit id="7b21087ec91e7492fc97a64907aa82ec4cec1d47" translate="yes" xml:space="preserve">
          <source>The number of whole megaseconds elapsed since the arbitrary point in time</source>
          <target state="translated">从任意时间点开始的整兆秒数。</target>
        </trans-unit>
        <trans-unit id="2ac856f3d61651add159fe85d25637849ee12830" translate="yes" xml:space="preserve">
          <source>The number of whole microseconds elapsed since the arbitrary point in time</source>
          <target state="translated">从任意时间点开始的整微秒数。</target>
        </trans-unit>
        <trans-unit id="7fc686361ce6577e49fbdfa1f7f9667a3114c986" translate="yes" xml:space="preserve">
          <source>The number of whole seconds elapsed since the arbitrary point in time</source>
          <target state="translated">从任意时间点开始的整数秒。</target>
        </trans-unit>
        <trans-unit id="54d5c18e70c70f565fba6a0087d94cc081284d10" translate="yes" xml:space="preserve">
          <source>The number of words (usually 4 bytes/word) allocated to data in the table.</source>
          <target state="translated">分配给表中数据的字数(通常为4字节/字)。</target>
        </trans-unit>
        <trans-unit id="f4367944af439fe4ab73bafeea4ad4ce2158f7b3" translate="yes" xml:space="preserve">
          <source>The number of words allocated to data in the table.</source>
          <target state="translated">分配给表中数据的字数。</target>
        </trans-unit>
        <trans-unit id="47eb13f9275d0915b77640cef69cc834d1d7a797" translate="yes" xml:space="preserve">
          <source>The number of words allocated to the table.</source>
          <target state="translated">分配给该表的字数。</target>
        </trans-unit>
        <trans-unit id="34f864a2059c77fad570ae2b8b9aa8d55bc831b6" translate="yes" xml:space="preserve">
          <source>The numeric value of option &lt;code&gt;TCP_INFO&lt;/code&gt;</source>
          <target state="translated">选项 &lt;code&gt;TCP_INFO&lt;/code&gt; 的数值</target>
        </trans-unit>
        <trans-unit id="fc80d9d15d1bbefd0794c4eb3dc7e83893ef6e5a" translate="yes" xml:space="preserve">
          <source>The numeric value of protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt;</source>
          <target state="translated">协议级别 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 的数值</target>
        </trans-unit>
        <trans-unit id="18b84a5716cb0140a4fa23575b7b99dd4e4ad89a" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;object1&lt;/code&gt; is an instance of the class &lt;code&gt;GENERAL-PROCEDURE&lt;/code&gt; and has one type field and one fixed type value field. The object &lt;code&gt;object2&lt;/code&gt; has also an optional field &lt;code&gt;ERROR&lt;/code&gt;, which is a type field. The field &lt;code&gt;ADDRESS&lt;/code&gt; is a &lt;code&gt;UNIQUE&lt;/code&gt; field. Objects in an object set must have unique values in their &lt;code&gt;UNIQUE&lt;/code&gt; field, as in &lt;code&gt;GENERAL-PROCEDURES&lt;/code&gt;:</source>
          <target state="translated">对象 &lt;code&gt;object1&lt;/code&gt; 是 &lt;code&gt;GENERAL-PROCEDURE&lt;/code&gt; 类的实例，并且具有一个类型字段和一个固定类型值字段。对象 &lt;code&gt;object2&lt;/code&gt; 还有一个可选字段 &lt;code&gt;ERROR&lt;/code&gt; ，它是一个类型字段。字段 &lt;code&gt;ADDRESS&lt;/code&gt; 是一个 &lt;code&gt;UNIQUE&lt;/code&gt; 字段。对象集中的对象在其 &lt;code&gt;UNIQUE&lt;/code&gt; 字段中必须具有唯一值，如 &lt;code&gt;GENERAL-PROCEDURES&lt;/code&gt; 所示：</target>
        </trans-unit>
        <trans-unit id="cbf8ca38a75143807f12207e1626da60e0683472" translate="yes" xml:space="preserve">
          <source>The object code can not be loaded because an old version of the code already exists.</source>
          <target state="translated">由于已经存在旧版本的代码,所以无法加载对象代码。</target>
        </trans-unit>
        <trans-unit id="96bec0794cc9606c306aa21f5a4f533e1cef6ea7" translate="yes" xml:space="preserve">
          <source>The object code cannot be loaded because an old version of the code already exists.</source>
          <target state="translated">由于已经存在旧版本的代码,所以无法加载对象代码。</target>
        </trans-unit>
        <trans-unit id="1e42f92b47527dda301da44c64b3f38f701eebfd" translate="yes" xml:space="preserve">
          <source>The object code could not be loaded because an old version of the code already existed.</source>
          <target state="translated">对象代码无法加载,因为已经存在旧版本的代码。</target>
        </trans-unit>
        <trans-unit id="f1c96d58c8d066eedb5b142300fba6386dd9f37a" translate="yes" xml:space="preserve">
          <source>The object code for all applications, structured according to the &lt;code&gt;&lt;a href=&quot;applications#app_dir&quot;&gt;application directory structure&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所有应用程序的目标代码，根据 &lt;code&gt;&lt;a href=&quot;applications#app_dir&quot;&gt;application directory structure&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="312de602ae6cab5b49378f20db6833b3ebf51e54" translate="yes" xml:space="preserve">
          <source>The object code has an incorrect format or the module name in the object code is not the expected module name.</source>
          <target state="translated">对象代码的格式不正确,或者对象代码中的模块名称不是预期的模块名称。</target>
        </trans-unit>
        <trans-unit id="b9f74288a78af8c662bf58b4bfec75119b65998d" translate="yes" xml:space="preserve">
          <source>The object code in &lt;code&gt;Binary&lt;/code&gt; has an incorrect format &lt;strong&gt;or&lt;/strong&gt; the object code contains code for another module than &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">在目标代码 &lt;code&gt;Binary&lt;/code&gt; 具有不正确的格式&lt;strong&gt;或&lt;/strong&gt;目标代码包含代码用于另一模块比 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d86c3849edb93463e5fde8f6001389a8a8a16d72" translate="yes" xml:space="preserve">
          <source>The object code must be &lt;strong&gt;loaded&lt;/strong&gt; into the Erlang runtime system. This is handled by the &lt;strong&gt;code server&lt;/strong&gt;, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">必须将目标代码&lt;strong&gt;加载&lt;/strong&gt;到Erlang运行时系统中。这由&lt;strong&gt;代码服务器&lt;/strong&gt;处理，请参见内核中的 &lt;code&gt;code(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="4f7d279e2bf494f71d13acb1a9c0428dae21af2e" translate="yes" xml:space="preserve">
          <source>The object code resides in a sticky directory.</source>
          <target state="translated">对象代码驻扎在一个粘稠的目录中。</target>
        </trans-unit>
        <trans-unit id="9034bf7170e48c51bdec7372e69a543233e72148" translate="yes" xml:space="preserve">
          <source>The object has the wrong arity.</source>
          <target state="translated">该对象有错误的arity。</target>
        </trans-unit>
        <trans-unit id="3ce289dd810ddc811f5f67ba5e6a9137c550f27b" translate="yes" xml:space="preserve">
          <source>The object is removed from the registry after a call to &lt;code&gt;ei_reg_dump()&lt;/code&gt; or &lt;code&gt;ei_reg_purge()&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 或 &lt;code&gt;ei_reg_purge()&lt;/code&gt; 之后，将从注册表中删除该对象。</target>
        </trans-unit>
        <trans-unit id="50a81e0e0ac3bfcd2994a6155ab70f493367ff09" translate="yes" xml:space="preserve">
          <source>The objects in these MIBs are implemented in the modules &lt;code&gt;snmp_framework_mib&lt;/code&gt; and &lt;code&gt;snmp_standard_mib&lt;/code&gt;, respectively. All objects reside in volatile memory, and the configuration files are always reread at start-up.</source>
          <target state="translated">这些MIB中的对象分别在模块 &lt;code&gt;snmp_framework_mib&lt;/code&gt; 和 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 中实现。所有对象都驻留在易失性存储器中，并且始终在启动时重新读取配置文件。</target>
        </trans-unit>
        <trans-unit id="f1f269a0ce7fdbd2a517508eb670b7eae55c54f4" translate="yes" xml:space="preserve">
          <source>The objects of a table are distributed among slots, starting with slot &lt;code&gt;0&lt;/code&gt; and ending with slot &lt;code&gt;n&lt;/code&gt;. Returns the list of objects associated with slot &lt;code&gt;I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; &amp;gt; &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">表的对象分布在各个插槽中，从插槽 &lt;code&gt;0&lt;/code&gt; 开始到插槽 &lt;code&gt;n&lt;/code&gt; 结束。返回与插槽 &lt;code&gt;I&lt;/code&gt; 相关的对象列表。如果 &lt;code&gt;I&lt;/code&gt; &amp;gt; &lt;code&gt;n&lt;/code&gt; ，则返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3cf193455ab85acb8426078bfa2d77fba608067" translate="yes" xml:space="preserve">
          <source>The octal value &lt;code&gt;ddd&lt;/code&gt;.</source>
          <target state="translated">八进制值 &lt;code&gt;ddd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10825eec8b9992856eefc5e7184bd2d3d8b5728b" translate="yes" xml:space="preserve">
          <source>The offset, either a string or an integer, to be included in the formatted string. An empty string, which is the default, is interpreted as local time. A non-empty string is included as is. The time unit of the integer is the same as the one of &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">要包含在格式化字符串中的偏移量，可以是字符串，也可以是整数。空字符串（默认）将解释为本地时间。包含一个非空字符串。该整数的时间单位是相同的一个 &lt;code&gt;Time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d661922c13a7026a70bf710f1f3e5ff84da384ab" translate="yes" xml:space="preserve">
          <source>The old &lt;code&gt;error_logger&lt;/code&gt; event handlers in STDLIB and SASL still exist, but they are not added by Erlang/OTP 21.0 or later.</source>
          <target state="translated">STDLIB和SASL中的旧 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序仍然存在，但是Erlang / OTP 21.0或更高版本未添加它们。</target>
        </trans-unit>
        <trans-unit id="f24d6b30c40ffcc2f600921f5b02bfeb14d2b158" translate="yes" xml:space="preserve">
          <source>The old &lt;code&gt;send_name&lt;/code&gt; format is sent from nodes only supporting version 5 or to nodes that might only support version 5. The &lt;code&gt;Version&lt;/code&gt; is a 16-bit big endian integer and &lt;strong&gt;must&lt;/strong&gt; always have the value 5, even if node &lt;code&gt;A&lt;/code&gt; supports version 6. &lt;code&gt;Flags&lt;/code&gt; are the &lt;code&gt;&lt;a href=&quot;#dflags&quot;&gt;capability flags&lt;/a&gt;&lt;/code&gt; of node &lt;code&gt;A&lt;/code&gt; in 32-bit big endian. The flag bit &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; should be set if node &lt;code&gt;A&lt;/code&gt; supports version 6. &lt;code&gt;Name&lt;/code&gt; is the full node name of &lt;code&gt;A&lt;/code&gt;, as a string of bytes (the packet length denotes how long it is).</source>
          <target state="translated">老 &lt;code&gt;send_name&lt;/code&gt; 格式从节点只支持5版本或可能只支持版本5节点发送的 &lt;code&gt;Version&lt;/code&gt; 是一个16位大端整数，&lt;strong&gt;必须&lt;/strong&gt;始终有值为5，即使节点 &lt;code&gt;A&lt;/code&gt; 支持版本6. &lt;code&gt;Flags&lt;/code&gt; 是32位大字节序中节点 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#dflags&quot;&gt;capability flags&lt;/a&gt;&lt;/code&gt; 。标志位 &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; 如果节点应设置 &lt;code&gt;A&lt;/code&gt; 支撑件6版 &lt;code&gt;Name&lt;/code&gt; 是的全部节点名 &lt;code&gt;A&lt;/code&gt; ，作为字节串（分组长度表示它有多长）。</target>
        </trans-unit>
        <trans-unit id="af05af633246d89510d44c0480b71acb691877d2" translate="yes" xml:space="preserve">
          <source>The old SASL error logging behaviour can be re-enabled by setting the Kernel configuration parameter &lt;code&gt; logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">通过将内核配置参数 &lt;code&gt; logger_sasl_compatible&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,可以重新启用旧的SASL错误日志记录行为。</target>
        </trans-unit>
        <trans-unit id="2e02582e73aee9b9d25f8eb0a27c6533b07e2b64" translate="yes" xml:space="preserve">
          <source>The old SASL error logging behaviour can be re-enabled by setting the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">通过将内核配置参数 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,可以重新启用旧的SASL错误日志记录行为。</target>
        </trans-unit>
        <trans-unit id="169571faa27c0998094ba22d7ebbc9d5c39edbe4" translate="yes" xml:space="preserve">
          <source>The old challenge message is sent from old &lt;code&gt;B&lt;/code&gt; nodes (supporting only version 5) or if node &lt;code&gt;A&lt;/code&gt; had not capability flag &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; set. The &lt;code&gt;Version&lt;/code&gt; is a 16-bit big endian integer and &lt;code&gt;must&lt;/code&gt; always have the value 5.</source>
          <target state="translated">旧质询消息是从旧 &lt;code&gt;B&lt;/code&gt; 节点（仅支持版本5）发送的，或者如果节点 &lt;code&gt;A&lt;/code&gt; 尚未设置功能标志 &lt;code&gt;&lt;a href=&quot;#DFLAG_HANDSHAKE_23&quot;&gt;DFLAG_HANDSHAKE_23&lt;/a&gt;&lt;/code&gt; ,则发送该旧质询消息。该 &lt;code&gt;Version&lt;/code&gt; 是一个16位大端整数， &lt;code&gt;must&lt;/code&gt; 始终具有值5。</target>
        </trans-unit>
        <trans-unit id="3a76e919cb31d567d70f0c1884a6bff75f85a4f4" translate="yes" xml:space="preserve">
          <source>The old event category &lt;code&gt;{table, Tab}&lt;/code&gt; is the same event category as &lt;code&gt;{table, Tab, simple}&lt;/code&gt;.</source>
          <target state="translated">旧事件类别 &lt;code&gt;{table, Tab}&lt;/code&gt; 与 &lt;code&gt;{table, Tab, simple}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee27cf1750001f295f781c4e9aebc39203e882c7" translate="yes" xml:space="preserve">
          <source>The old functions - not recommended for new programs - are for chipers:</source>
          <target state="translated">旧功能--不建议用于新程序--是为芯片商准备的。</target>
        </trans-unit>
        <trans-unit id="a59370df4f50113d09a51ecd53e02035ed19851a" translate="yes" xml:space="preserve">
          <source>The old heap is always one step ahead in the heap growth stages than the young heap.</source>
          <target state="translated">在堆的成长阶段,老堆总是比年轻堆领先一步。</target>
        </trans-unit>
        <trans-unit id="e92c7eb3266e1b2528d4a031775f3f7823afcb1c" translate="yes" xml:space="preserve">
          <source>The old legacy &lt;code&gt;erl_interface&lt;/code&gt; library (functions with prefix &lt;code&gt;erl_&lt;/code&gt;) is deprecated as of OTP 22. These parts of &lt;code&gt;erl_interface&lt;/code&gt; has been informally deprecated for a very long time. You typically want to replace the usage of the &lt;code&gt;erl_interface&lt;/code&gt; library with the use of the &lt;code&gt;ei&lt;/code&gt; library which also is part of the &lt;code&gt;erl_interface&lt;/code&gt; application. The old legacy &lt;code&gt;erl_interface&lt;/code&gt; library has also been scheduled for removal in OTP 23.</source>
          <target state="translated">旧的传统 &lt;code&gt;erl_interface&lt;/code&gt; 库（前缀功能 &lt;code&gt;erl_&lt;/code&gt; ）被弃用OTP 22的这些部件 &lt;code&gt;erl_interface&lt;/code&gt; 已非正式地废弃了很长一段时间。您通常希望使用 &lt;code&gt;ei&lt;/code&gt; 库代替 &lt;code&gt;erl_interface&lt;/code&gt; 库，而ei库也是 &lt;code&gt;erl_interface&lt;/code&gt; 应用程序的一部分。还计划将旧的旧版 &lt;code&gt;erl_interface&lt;/code&gt; 库在OTP 23中删除。</target>
        </trans-unit>
        <trans-unit id="59f7e677b9778b0fb1d66db7316174f828de7a9a" translate="yes" xml:space="preserve">
          <source>The old module is still available for compatibility, but should not be used for new programs. The old module will not be maintained except for some error corrections</source>
          <target state="translated">旧模块仍可兼容,但不应用于新程序。除了一些错误修正外,旧模块将不再保留。</target>
        </trans-unit>
        <trans-unit id="2798303d3236c875dc5adc849e5888243c7d63a2" translate="yes" xml:space="preserve">
          <source>The old names had by time lost any common naming convention which the new names now introduces. The new names include the key length which improves the error checking in the lower levels of the crypto application.</source>
          <target state="translated">旧的名称已经失去了任何共同的命名惯例,而新的名称现在引入了这种惯例。新的名称包括密钥长度,这改善了加密应用中低级别的错误检查。</target>
        </trans-unit>
        <trans-unit id="4311de06755abb4e51609dffbdd9331251a3c42a" translate="yes" xml:space="preserve">
          <source>The old port owner stays linked to the port and must call &lt;code&gt;unlink(Port)&lt;/code&gt; if this is not desired. Any process can set the port owner to be any process with &lt;code&gt;port_connect/2&lt;/code&gt;.</source>
          <target state="translated">旧的端口所有者保持与该端口的链接，并且如果不需要，必须调用 &lt;code&gt;unlink(Port)&lt;/code&gt; 。任何进程都可以使用 &lt;code&gt;port_connect/2&lt;/code&gt; 将端口所有者设置为任何进程。</target>
        </trans-unit>
        <trans-unit id="252509caf54119a65fc2fb237a753881b8ffad79" translate="yes" xml:space="preserve">
          <source>The old time API is based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; was intended to be used for many unrelated things. This tied these unrelated operations together and caused issues with performance, scalability, accuracy, and precision for operations that did not need to have such issues. To improve this, the new API spreads different functionality over multiple functions.</source>
          <target state="translated">旧时的API基于 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;erlang:now/0&lt;/code&gt; 用于许多不相关的事物。这将这些不相关的操作联系在一起，并为不需要这些问题的操作带来了性能，可伸缩性，准确性和精度方面的问题。为了改善这一点，新的API将不同的功能分散在多个功能上。</target>
        </trans-unit>
        <trans-unit id="0286a4a48dcade7c3397c916982a12af0309f49f" translate="yes" xml:space="preserve">
          <source>The old tuple format is kept for backwards compatibility, see &lt;code&gt;&lt;a href=&quot;#type-child_spec&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt;, but the map is preferred.</source>
          <target state="translated">保留旧的元组格式是为了向后兼容，请参见 &lt;code&gt;&lt;a href=&quot;#type-child_spec&quot;&gt;child_spec()&lt;/a&gt;&lt;/code&gt; ，但首选映射。</target>
        </trans-unit>
        <trans-unit id="5213f93470dcbb8caa4306da1f34f9dc9cde6c3f" translate="yes" xml:space="preserve">
          <source>The old tuple formats with &lt;code&gt;Ip&lt;/code&gt; address and &lt;code&gt;Udp&lt;/code&gt; port number found in old configurations still work.</source>
          <target state="translated">在旧配置中找到的具有 &lt;code&gt;Ip&lt;/code&gt; 地址和 &lt;code&gt;Udp&lt;/code&gt; 端口号的旧元组格式仍然有效。</target>
        </trans-unit>
        <trans-unit id="8c6a30a350aa9ef26562d44a342bd9fffb85daa0" translate="yes" xml:space="preserve">
          <source>The old user tag (if any) is returned, or &lt;code&gt;undefined&lt;/code&gt; if no user tag was present or dynamic tracing is not enabled.</source>
          <target state="translated">返回旧的用户标签（如果有），如果不存在用户标签或未启用动态跟踪，则返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="560418bd51e719aa06237064ddd18055f504721b" translate="yes" xml:space="preserve">
          <source>The only allowed driver option is &lt;code&gt;kill_ports&lt;/code&gt;, which means that all ports opened to the driver are killed with exit reason &lt;code&gt;driver_unloaded&lt;/code&gt; when no process any longer has the driver loaded. This situation arises either when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;, or when the last process having loaded the driver exits.</source>
          <target state="translated">唯一允许的驱动程序选项是 &lt;code&gt;kill_ports&lt;/code&gt; ，这意味着当不再加载驱动程序时，会以退出原因 &lt;code&gt;driver_unloaded&lt;/code&gt; 杀死向驱动程序打开的所有端口。当最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 时，或者当最后一个加载驱动程序的进程退出时，就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="b877b313b1006940c4cf41c60f09d3385fb04336" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;StateFunctionResult&lt;/code&gt; and &lt;code&gt;HandleEventResult&lt;/code&gt; is that for &lt;code&gt;StateFunctionResult&lt;/code&gt; the next state must be an atom, but for &lt;code&gt;HandleEventResult&lt;/code&gt; there is no restriction on the next state.</source>
          <target state="translated">&lt;code&gt;StateFunctionResult&lt;/code&gt; 和 &lt;code&gt;HandleEventResult&lt;/code&gt; 之间的唯一区别是，对于 &lt;code&gt;StateFunctionResult&lt;/code&gt; ，下一个状态必须是原子，但是对于 &lt;code&gt;HandleEventResult&lt;/code&gt; ，对下一个状态没有限制。</target>
        </trans-unit>
        <trans-unit id="0f50b6fea79bf8e8e2c3a8ded26b5d687ae24528" translate="yes" xml:space="preserve">
          <source>The only documentation that is recommended to be released in this way are the man pages. HTML and PDF will normally be distributed in some other manner.</source>
          <target state="translated">唯一建议以这种方式发布的文档是手册页,HTML和PDF通常会以其他方式发布。HTML和PDF通常会以其他方式发布。</target>
        </trans-unit>
        <trans-unit id="605ba52c7d82985a433cc561f290582494b9d731" translate="yes" xml:space="preserve">
          <source>The only exception is the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; common option. They are all applied in ascending level order on the set of algorithms. So a &lt;code&gt;modify_algorithms&lt;/code&gt; on level zero is applied before one of level one and so on.</source>
          <target state="translated">唯一的例外是 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 通用选项。它们都按升序顺序应用于算法集。因此，在级别1之一之前应用级别0的 &lt;code&gt;modify_algorithms&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="1130e04c19ee8513c73e7178d0ff68d3aa9b5d59" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is &lt;code&gt;error:undef&lt;/code&gt; which guarantees to include the Module, Function and Arity of the attempted function as the first stacktrace entry.</source>
          <target state="translated">该规则的唯一例外是 &lt;code&gt;error:undef&lt;/code&gt; ，它保证将尝试使用的函数的Module，Function和Arity包含为第一个stacktrace条目。</target>
        </trans-unit>
        <trans-unit id="bf2d1dc9bc29c7d67e629d6a36aab11ede21435f" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is the class &lt;code&gt;error&lt;/code&gt; with the reason &lt;code&gt;undef&lt;/code&gt; which is guaranteed to include the &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Arity&lt;/code&gt; of the attempted function as the first stacktrace entry.</source>
          <target state="translated">此规则的唯一例外是类 &lt;code&gt;error&lt;/code&gt; ，其原因为 &lt;code&gt;undef&lt;/code&gt; ，保证将尝试的函数的 &lt;code&gt;Module&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 和 &lt;code&gt;Arity&lt;/code&gt; 作为第一个stacktrace条目包括在内。</target>
        </trans-unit>
        <trans-unit id="cba16851052fe41ed6e022bc41a2dcd36c32376e" translate="yes" xml:space="preserve">
          <source>The only exported function from the driver is &lt;code&gt;driver_init&lt;/code&gt;. This function returns the &lt;code&gt;driver_entry&lt;/code&gt; structure that points to the other functions in the driver. The &lt;code&gt;driver_init&lt;/code&gt; function is declared with a macro, &lt;code&gt;DRIVER_INIT(drivername)&lt;/code&gt;. (This is because different operating systems have different names for it.)</source>
          <target state="translated">驱动程序唯一导出的函数是 &lt;code&gt;driver_init&lt;/code&gt; 。该函数返回 &lt;code&gt;driver_entry&lt;/code&gt; 结构，该结构指向驱动程序中的其他函数。该 &lt;code&gt;driver_init&lt;/code&gt; 功能都被定义宏， &lt;code&gt;DRIVER_INIT(drivername)&lt;/code&gt; 。（这是因为不同的操作系统为其使用了不同的名称。）</target>
        </trans-unit>
        <trans-unit id="1696dc38d1cf9a5d02abc823dd0e7fc5c6596e2d" translate="yes" xml:space="preserve">
          <source>The only feature that not is implemented is the &lt;code&gt;netascii&lt;/code&gt; transfer mode.</source>
          <target state="translated">唯一未实现的功能是 &lt;code&gt;netascii&lt;/code&gt; 传输模式。</target>
        </trans-unit>
        <trans-unit id="b5c833b89182cc5b90fce17ff719f78c8281aaac" translate="yes" xml:space="preserve">
          <source>The only new user interface function is the one provided by the user in the configuration file. The function is started by the &lt;code&gt;ModuleName:FunctionName&lt;/code&gt; notation.</source>
          <target state="translated">唯一的新用户界面功能是用户在配置文件中提供的功能。该函数由 &lt;code&gt;ModuleName:FunctionName&lt;/code&gt; 表示法启动。</target>
        </trans-unit>
        <trans-unit id="a4c6a2cba6db5082ab2b924d01428d176098f7b4" translate="yes" xml:space="preserve">
          <source>The only possible error reason &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;{&quot;global_groups definition error&quot;, Error}&lt;/code&gt;.</source>
          <target state="translated">唯一可能的错误原因 &lt;code&gt;Reason&lt;/code&gt; 是 &lt;code&gt;{&quot;global_groups definition error&quot;, Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4302c1a5eaa9921e04a9ee05f8db970b626954e6" translate="yes" xml:space="preserve">
          <source>The only reason to set it to &lt;code&gt;false&lt;/code&gt; is if you want to continue sending data to the socket after a close is detected, for example, if the peer uses &lt;code&gt;&lt;a href=&quot;gen_tcp#shutdown-2&quot;&gt;gen_tcp:shutdown/2&lt;/a&gt;&lt;/code&gt; to shut down the write side.</source>
          <target state="translated">将其设置为 &lt;code&gt;false&lt;/code&gt; 的唯一原因是，如果要在检测到关闭后继续向套接字发送数据，例如，对等方使用 &lt;code&gt;&lt;a href=&quot;gen_tcp#shutdown-2&quot;&gt;gen_tcp:shutdown/2&lt;/a&gt;&lt;/code&gt; 关闭写端。</target>
        </trans-unit>
        <trans-unit id="0bd2b35842e406e11aa99f3c06919005b7f0b40e" translate="yes" xml:space="preserve">
          <source>The only signal ordering guarantee given is the following: if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if &lt;code&gt;A&lt;/code&gt; sends a signal &lt;code&gt;S1&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, and later sends signal &lt;code&gt;S2&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;S1&lt;/code&gt; is guaranteed not to arrive after &lt;code&gt;S2&lt;/code&gt;.</source>
          <target state="translated">给出的唯一信号排序保证如下：如果实体将多个信号发送到同一目标实体，则保留该命令；也就是说，如果 &lt;code&gt;A&lt;/code&gt; 发送信号 &lt;code&gt;S1&lt;/code&gt; 至 &lt;code&gt;B&lt;/code&gt; ，后来发送信号 &lt;code&gt;S2&lt;/code&gt; 到 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;S1&lt;/code&gt; 保证不会之后到达 &lt;code&gt;S2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e25f07eac66ff46d41498e9c52f4e662f5d9c6" translate="yes" xml:space="preserve">
          <source>The only supported option is &lt;code&gt;{verify,boolean()}&lt;/code&gt;. If verification is turned on (by specifying &lt;code&gt;{verify,true}&lt;/code&gt;), the function uses whatever information is present in the file to assert that the information is not damaged. How this is done depends on which &lt;code&gt;extended_info&lt;/code&gt; was written using &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一受支持的选项是 &lt;code&gt;{verify,boolean()}&lt;/code&gt; 。如果启用了 &lt;code&gt;{verify,true}&lt;/code&gt; （通过指定{verify，true}），则该函数将使用文件中存在的任何信息来断言该信息没有损坏。如何完成取决于使用 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 编写了哪个 &lt;code&gt;extended_info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4d83fec128ceaff5533b8b8493896363c149eb7" translate="yes" xml:space="preserve">
          <source>The only supported usage is to generate one distinct random sequence from this start state.</source>
          <target state="translated">唯一支持的用法是从这个起始状态产生一个不同的随机序列。</target>
        </trans-unit>
        <trans-unit id="f32acd6c078a02af6a8141ee25a3cbecc6c24eae" translate="yes" xml:space="preserve">
          <source>The only syntactical limitation imposed by the preprocessor on the arguments to a macro application (viewed as sequences of tokens) is that they must be balanced with respect to parentheses, brackets, &lt;code&gt;begin ... end&lt;/code&gt;, &lt;code&gt;case ... end&lt;/code&gt;, etc. The &lt;code&gt;text&lt;/code&gt; node type can be used to represent arguments which are not regular Erlang constructs.</source>
          <target state="translated">预处理程序对宏应用程序的参数（视为标记序列）施加的唯一语法限制是，必须在括号，方括号， &lt;code&gt;begin ... end&lt;/code&gt; ， &lt;code&gt;case ... end&lt;/code&gt; 等方面保持平衡。 &lt;code&gt;text&lt;/code&gt; 节点类型可用于表示不是常规Erlang构造的参数。</target>
        </trans-unit>
        <trans-unit id="2f8e7babf3bfb1fc57fb314e546ee761000fd043" translate="yes" xml:space="preserve">
          <source>The only useful value for &lt;code&gt;release_number&lt;/code&gt; is currently &lt;code&gt;21&lt;/code&gt;. This will only be useful and have an effect if &lt;strong&gt;bit strings&lt;/strong&gt; or &lt;strong&gt;export funs&lt;/strong&gt; are received from a connected node. Before OTP 22, bit strings and export funs were not supported by &lt;code&gt;ei&lt;/code&gt;. They were instead encoded using an undocumented fallback tuple format when sent from the emulator to &lt;code&gt;ei&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;release_number&lt;/code&gt; 的唯一有用的值当前是 &lt;code&gt;21&lt;/code&gt; 。仅当从连接的节点接收&lt;strong&gt;到位字符串&lt;/strong&gt;或&lt;strong&gt;导出乐趣时，&lt;/strong&gt;这才有用并起作用。在OTP 22之前， &lt;code&gt;ei&lt;/code&gt; 不支持位字符串和导出功能。当从仿真器发送到 &lt;code&gt;ei&lt;/code&gt; 时，它们使用未记录的后备元组格式进行编码：</target>
        </trans-unit>
        <trans-unit id="5bcbae1f57b05af5cbe66ffd509cb1bd7d6129be" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">唯一会返回 &lt;code&gt;{register, UserId, TargetName, AgentConfig}&lt;/code&gt; 的&lt;strong&gt;用户&lt;/strong&gt;是&lt;strong&gt;默认用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c1b3a9187732633f1cf125b19158045930fb9262" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, AgentConfig}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">唯一会返回 &lt;code&gt;{register, UserId, TargetName2, AgentConfig}&lt;/code&gt; 的&lt;strong&gt;用户&lt;/strong&gt;是&lt;strong&gt;默认用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="856c8192723936f88433456a55a9d3e8225ac26b" translate="yes" xml:space="preserve">
          <source>The only user which would return &lt;code&gt;{register, UserId, TargetName2, agent_info()}&lt;/code&gt; is the &lt;strong&gt;default user&lt;/strong&gt;.</source>
          <target state="translated">唯一会返回 &lt;code&gt;{register, UserId, TargetName2, agent_info()}&lt;/code&gt; 的&lt;strong&gt;用户&lt;/strong&gt;是&lt;strong&gt;默认用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="66ccb0d98fc09fa8872b21645b16bf70dd169beb" translate="yes" xml:space="preserve">
          <source>The only valid values for &lt;code&gt;&amp;lt;range&amp;gt;&lt;/code&gt; are &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;unicode&lt;/code&gt;. &lt;code&gt;latin1&lt;/code&gt; means that only code points &amp;lt; 256 (except control characters, and so on) are considered printable. &lt;code&gt;unicode&lt;/code&gt; means that all printable characters in all Unicode character ranges are considered printable by the I/O functions.</source>
          <target state="translated">为唯一有效值 &lt;code&gt;&amp;lt;range&amp;gt;&lt;/code&gt; 是 &lt;code&gt;latin1&lt;/code&gt; 和 &lt;code&gt;unicode&lt;/code&gt; 的。 &lt;code&gt;latin1&lt;/code&gt; 表示只有&amp;lt;256个代码点（控制字符等除外）才被视为可打印。 &lt;code&gt;unicode&lt;/code&gt; 表示I / O功能将所有Unicode字符范围内的所有可打印字符视为可打印。</target>
        </trans-unit>
        <trans-unit id="02b1141f03eddf910011a4ff2a58eb780a8ab4e0" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从该函数返回的不透明 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用在调用此模块中的任何其他函数时可用作客户端标识符。但是，如果 &lt;code&gt;KeyOrName&lt;/code&gt; 是 &lt;code&gt;target_name()&lt;/code&gt; ，即，如果服务器是通过调用 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或测试套件中的 &lt;code&gt;require&lt;/code&gt; 语句来命名的，则可以使用该名称代替 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216692fe587eacd8f1cf30a3339eb308bb1cb50e" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as client identifier when calling any other function in this module. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is used and it is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从该函数返回的不透明 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用在调用此模块中的任何其他函数时可用作客户端标识符。但是，如果使用 &lt;code&gt;KeyOrName&lt;/code&gt; 并且它是 &lt;code&gt;target_name()&lt;/code&gt; ，即，如果服务器是通过调用 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或测试套件中的 &lt;code&gt;require&lt;/code&gt; 语句来命名的，则可以使用该名称代替 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab51a13d4ecc21e5671204ca36e445fd1f3de37" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过此连接打开会话时，从此函数返回的opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用可用作连接标识符，请参见 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 。但是，如果 &lt;code&gt;KeyOrName&lt;/code&gt; 是 &lt;code&gt;target_name()&lt;/code&gt; ，即，如果服务器是通过调用 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或测试套件中的 &lt;code&gt;require&lt;/code&gt; 语句来命名的，则可以使用该名称代替 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2674e5b9ec19d6d04a95ad16ec44eac2f99a451" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function can be used as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;. However, if &lt;code&gt;KeyOrName&lt;/code&gt; is a &lt;code&gt;target_name()&lt;/code&gt;, that is, if the server is named through a call to &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement in the test suite, then this name can be used instead of &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过此连接打开会话时，从此函数返回的opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用可用作连接标识符，请参阅 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; 。但是，如果 &lt;code&gt;KeyOrName&lt;/code&gt; 是 &lt;code&gt;target_name()&lt;/code&gt; ，即，如果服务器是通过调用 &lt;code&gt;&lt;a href=&quot;ct#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 或测试套件中的 &lt;code&gt;require&lt;/code&gt; 语句来命名的，则可以使用该名称代替 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a66edf19af62a3385d416b41ffcad011c88ad9a" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as client identifier when calling any other function in this module.</source>
          <target state="translated">调用此模块中的任何其他函数时，需要从此函数返回的不透明 &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用作为客户端标识符。</target>
        </trans-unit>
        <trans-unit id="dbb23ff6963a9fa5daa339e7b22a266927eaf0fb" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过此连接打开会话时，需要此函数返回的opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用作为连接标识符，请参见 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cea8dae01ecf33f5ab88d91d6afba8fa59b0a62" translate="yes" xml:space="preserve">
          <source>The opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; reference returned from this function is required as connection identifier when opening sessions over this connection, see &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过此连接打开会话时，需要从此函数返回的opaque &lt;code&gt;&lt;a href=&quot;#type-handle&quot;&gt;handle()&lt;/a&gt;&lt;/code&gt; 引用作为连接标识符，请参阅 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f687bf20820a4707deceb3ee3d246959a98c4556" translate="yes" xml:space="preserve">
          <source>The opaque part of the key. Does not need to be handled by the callback.</source>
          <target state="translated">密钥的不透明部分。不需要由回调处理。</target>
        </trans-unit>
        <trans-unit id="287e1e13116afdbb7c51463389d37f3a27188d42" translate="yes" xml:space="preserve">
          <source>The operands that are different must be at the beginning of the instruction. All operands in the last fragment must have the same operands in all variants of the specific instruction.</source>
          <target state="translated">不同的操作数必须在指令的开头。最后一个片段中的所有操作数在具体指令的所有变体中必须有相同的操作数。</target>
        </trans-unit>
        <trans-unit id="07aa6b76a1d620737ff1463895883152bf7bd915" translate="yes" xml:space="preserve">
          <source>The operating system has no concept of drives.</source>
          <target state="translated">操作系统没有驱动的概念。</target>
        </trans-unit>
        <trans-unit id="68b1724813e149be87ec79e4420f8e82cba651c0" translate="yes" xml:space="preserve">
          <source>The operating systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt; os:system_time()&lt;/code&gt;. This may or may not be an accurate view of POSIX time. This time may typically be adjusted both backwards and forwards without limitation. That is, &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; may be observed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 的操作系统视图。要检索它，请调用 &lt;code&gt; os:system_time()&lt;/code&gt; 。这可能不是POSIX时间的准确视图。通常可以无限制地向后和向前调整该时间。即，可以观察到 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d1f7c571653276add5945991e7d8dbaf8340b38" translate="yes" xml:space="preserve">
          <source>The operating systems view of &lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt;. To retrieve it, call &lt;code&gt;os:system_time()&lt;/code&gt;. This may or may not be an accurate view of POSIX time. This time may typically be adjusted both backwards and forwards without limitation. That is, &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; may be observed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#POSIX_Time&quot;&gt;POSIX time&lt;/a&gt;&lt;/code&gt; 的操作系统视图。要检索它，请调用 &lt;code&gt;os:system_time()&lt;/code&gt; 。这可能不是POSIX时间的准确视图。通常可以无限制地向后和向前调整该时间。即，可以观察到 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warps&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a8d66701c3dbfac0f49755065cecba5150d0351" translate="yes" xml:space="preserve">
          <source>The operation completed without errors.</source>
          <target state="translated">操作完成,没有错误。</target>
        </trans-unit>
        <trans-unit id="8b7dc04007a8243cf1e155a5507f9e9a7b4ed595" translate="yes" xml:space="preserve">
          <source>The operation was aborted, as the process needed to be garbage collected to determine the operation result, and the operation was requested by passing option &lt;code&gt;{allow_gc, false}&lt;/code&gt;.</source>
          <target state="translated">该操作被中止，因为需要对该进程进行垃圾回收以确定操作结果，并且通过传递选项 &lt;code&gt;{allow_gc, false}&lt;/code&gt; 请求该操作。</target>
        </trans-unit>
        <trans-unit id="028d2f9f2cf1ad6ba073b32e1d502dfedbbb24a1" translate="yes" xml:space="preserve">
          <source>The operator of a &lt;code&gt;Common Test&lt;/code&gt; system can receive event notifications continuously during a test run. For example, &lt;code&gt;Common Test&lt;/code&gt; reports when a test case starts and stops, the current count of successful, failed, and skipped cases, and so on. This information can be used for different purposes such as logging progress and results in another format than HTML, saving statistics to a database for report generation, and test system supervision.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 系统的操作员可以在测试运行期间连续接收事件通知。例如，&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 报告测试用例的开始和停止时间，成功案例，失败案例和跳过案例的当前计数，等等。该信息可用于不同目的，例如以不同于HTML的其他格式记录进度和结果，将统计信息保存到数据库以生成报告以及测试系统监督。</target>
        </trans-unit>
        <trans-unit id="8ac9cd2f3357019ca23e28a1a5c29f888acd7d48" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;add_module&lt;/code&gt; is &lt;code&gt;delete_module&lt;/code&gt;, which unloads a module:</source>
          <target state="translated">&lt;code&gt;add_module&lt;/code&gt; 的相反是 &lt;code&gt;delete_module&lt;/code&gt; ，它卸载模块：</target>
        </trans-unit>
        <trans-unit id="8201763988fd73d2d4e9e61c9df537349bc58481" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;use_stdio&lt;/code&gt;. It uses file descriptors 3 and 4 for communication with Erlang.</source>
          <target state="translated">的相对 &lt;code&gt;use_stdio&lt;/code&gt; 。它使用文件描述符3和4与Erlang进行通信。</target>
        </trans-unit>
        <trans-unit id="6947afa7b807cda54cd165aa32ce74a3d79f4c15" translate="yes" xml:space="preserve">
          <source>The optimization of the binary append operation requires that there is a &lt;strong&gt;single&lt;/strong&gt; ProcBin and a &lt;strong&gt;single reference&lt;/strong&gt; to the ProcBin for the binary. The reason is that the binary object can be moved (reallocated) during an append operation, and when that happens, the pointer in the ProcBin must be updated. If there would be more than one ProcBin pointing to the binary object, it would not be possible to find and update all of them.</source>
          <target state="translated">二进制追加操作的优化要求，有一个&lt;strong&gt;单一&lt;/strong&gt; ProcBin和一个&lt;strong&gt;单一的参考&lt;/strong&gt;到ProcBin用于二进制。原因是可以在追加操作期间移动（重新分配）二进制对象，并且在这种情况下，必须更新ProcBin中的指针。如果将有多个ProcBin指向二进制对象，则不可能找到并更新所有它们。</target>
        </trans-unit>
        <trans-unit id="455804f64d1c9833d014c23a12d14ea2494f3274" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-outdir Directory&lt;/code&gt; specifies the output directory for the generated files. Default is the current working directory.</source>
          <target state="translated">选项 &lt;code&gt;-outdir Directory&lt;/code&gt; 指定所生成文件的输出目录。默认值为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="c18f8390c7a1bd1bae0b40306cfcf6852925d8d1" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; defaults to directory &lt;code&gt;users ~/.ssh&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 默认为目录 &lt;code&gt;users ~/.ssh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a7dfbb8b5004581e731dee0d182116bbc44ffc2" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;agent_capabilities&lt;/code&gt;, if present, specifies that the AGENT-CAPABILITIES statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the agent-capabilitie will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="translated">选项 &lt;code&gt;agent_capabilities&lt;/code&gt; （如果存在）指定在编译的mib中应包含MIB的AGENT-CAPABILITIES语句（具有mib-entry记录）。代理功能的移动记录将在 &lt;code&gt;assocList&lt;/code&gt; 字段中包含此信息的 &lt;code&gt;reference&lt;/code&gt; 和 &lt;code&gt;modules&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="06424cbe694389a0379fd6422e76eb2e7b311463" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;db&lt;/code&gt; specifies which database should be used for the default instrumentation.</source>
          <target state="translated">选项 &lt;code&gt;db&lt;/code&gt; 指定应将哪个数据库用于默认检测。</target>
        </trans-unit>
        <trans-unit id="b1c38411f37d947a6f2316b11a66ae14df30f64e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;deprecated&lt;/code&gt; specifies if a deprecated definition should be kept or not. If the option is false the MIB compiler will ignore all deprecated definitions.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 的选项指定是否应保留不建议使用的定义。如果该选项为false，则MIB编译器将忽略所有不建议使用的定义。</target>
        </trans-unit>
        <trans-unit id="55335984c5b08e8d1673e107cca029d522769243" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;description&lt;/code&gt; specifies if the text of the DESCRIPTION field will be included or not.</source>
          <target state="translated">选项 &lt;code&gt;description&lt;/code&gt; 指定是否将包含DESCRIPTION字段的文本。</target>
        </trans-unit>
        <trans-unit id="09b9fb64f572f9490ecb854f2b8072cc568815e6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;group_check&lt;/code&gt; specifies whether the mib compiler should check the OBJECT-GROUP macro and the NOTIFICATION-GROUP macro for correctness or not.</source>
          <target state="translated">选项 &lt;code&gt;group_check&lt;/code&gt; 指定mib编译器是否应检查OBJECT-GROUP宏和NOTIFICATION-GROUP宏的正确性。</target>
        </trans-unit>
        <trans-unit id="ee1cb6b787011127b81f08d59e1c6d1d5e4d9685" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;i&lt;/code&gt; specifies the path to search for imported (compiled) MIB files. The directories should be strings with a trailing directory delimiter.</source>
          <target state="translated">选项 &lt;code&gt;i&lt;/code&gt; 指定搜索导入（编译）的MIB文件的路径。目录应该是带有尾随目录定界符的字符串。</target>
        </trans-unit>
        <trans-unit id="eae87d7de383250a9c21b21bec8bbf0784d992a8" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;il&lt;/code&gt; (include_lib) also specifies a list of directories to search for imported MIBs. It assumes that the first element in the directory name corresponds to an OTP application. The compiler will find the current installed version. For example, the value [&quot;snmp/mibs/&quot;] will be replaced by [&quot;snmp-3.1.1/mibs/&quot;] (or what the current version may be in the system). The current directory and the &lt;code&gt;&amp;lt;snmp-home&amp;gt;/priv/mibs/&lt;/code&gt; are always listed last in the include path.</source>
          <target state="translated">选项 &lt;code&gt;il&lt;/code&gt; （include_lib）还指定用于搜索导入的MIB的目录列表。假定目录名称中的第一个元素对应于OTP应用程序。编译器将找到当前安装的版本。例如，值[&amp;ldquo; snmp / mibs /&amp;rdquo;]将替换为[&amp;ldquo; snmp-3.1.1 / mibs /&amp;rdquo;]（或系统中当前的版本）。当前目录和 &lt;code&gt;&amp;lt;snmp-home&amp;gt;/priv/mibs/&lt;/code&gt; 始终在包含路径中最后列出。</target>
        </trans-unit>
        <trans-unit id="aecef6269c58a221d8b83cd35b4abe167bc9b4fb" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;imports&lt;/code&gt;, if present, specifies that the IMPORT statement of the MIB shall be included in the compiled mib.</source>
          <target state="translated">选项 &lt;code&gt;imports&lt;/code&gt; （如果存在）指定将MIB的IMPORT语句包含在已编译的mib中。</target>
        </trans-unit>
        <trans-unit id="854431466b1b09bfda8a21c141effba6fef54caf" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;indent&lt;/code&gt; controls the indention for formatted lines (defaults to 4 spaces).</source>
          <target state="translated">&lt;code&gt;indent&lt;/code&gt; 选项控制格式化行的缩进（默认为4个空格）。</target>
        </trans-unit>
        <trans-unit id="c2dc35988d55398d8e5330eb9f58ce44354b567d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;linewidth&lt;/code&gt; controls the maximum line width for formatted lines (defaults to 72 characters).</source>
          <target state="translated">选项 &lt;code&gt;linewidth&lt;/code&gt; 控制格式化行的最大行宽（默认为72个字符）。</target>
        </trans-unit>
        <trans-unit id="7d050cf3a9e6eaff748854538bc9531c00c71d49" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module&lt;/code&gt;, if present, specifies the name of a module which implements all instrumentation functions for the MIB.</source>
          <target state="translated">选项 &lt;code&gt;module&lt;/code&gt; （如果存在）指定实现MIB的所有检测功能的模块的名称。</target>
        </trans-unit>
        <trans-unit id="f2aabaa290b5cad088915be695ef4e5e2d192872" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_compliance&lt;/code&gt;, if present, specifies that the MODULE-COMPLIANCE statement of the MIB shall be included (with a mib-entry record) in the compiled mib. The mib-entry record of the module-compliance will contain &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; part(s) this info in the &lt;code&gt;assocList&lt;/code&gt; field).</source>
          <target state="translated">选项 &lt;code&gt;module_compliance&lt;/code&gt; （如果存在）指定将MIB的MODULE-COMPLIANCE语句包含在已编译的mib中（带有mib-entry记录）。模块符合性的mib-entry记录将在 &lt;code&gt;assocList&lt;/code&gt; 字段中包含此信息的 &lt;code&gt;reference&lt;/code&gt; 和 &lt;code&gt;module&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f4c88030e67c25f56859a203283edd3aad2cb537" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;module_identity&lt;/code&gt;, if present, specifies that the info part of the MODULE-IDENTITY statement of the MIB shall be included in the compiled mib.</source>
          <target state="translated">选项 &lt;code&gt;module_identity&lt;/code&gt; （如果存在）指定将MIB的MODULE-IDENTITY语句的info部分包含在已编译的mib中。</target>
        </trans-unit>
        <trans-unit id="b9f802c1128cac15a491e948fd2133dd4c271326" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;no_defs&lt;/code&gt;, if present, specifies that if a managed object does not have an instrumentation function, the default instrumentation function should NOT be used, instead this is reported as an error, and the compilation aborts.</source>
          <target state="translated">选项 &lt;code&gt;no_defs&lt;/code&gt; （如果存在）指定如果被管理对象不具有检测功能，则不应使用默认检测功能，而是将其报告为错误，并且编译中止。</target>
        </trans-unit>
        <trans-unit id="3534ebdcb42cec6bc4ed923a32d42f384e018c6f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;preferred_algorithms&lt;/code&gt; may be complicated to use for adding or removing single algorithms. First one has to list them with &lt;code&gt;ssh:default_algorithms()&lt;/code&gt; and then do changes in the lists.</source>
          <target state="translated">用于添加或删除单个算法的选项 &lt;code&gt;preferred_algorithms&lt;/code&gt; 可能很复杂。首先必须使用 &lt;code&gt;ssh:default_algorithms()&lt;/code&gt; 列出它们，然后在列表中进行更改。</target>
        </trans-unit>
        <trans-unit id="6f6493ec2c3856d0c27056672bbea1c4b30c3b8f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;quote_singleton_atom_types&lt;/code&gt; is used to add quotes to all singleton atom types.</source>
          <target state="translated">选项 &lt;code&gt;quote_singleton_atom_types&lt;/code&gt; 用于为所有单例原子类型添加引号。</target>
        </trans-unit>
        <trans-unit id="b0781dd6b89fb812468ff9fa696eedd3b05b73df" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;reference&lt;/code&gt; specifies if the text of the REFERENCE field, when found in a table definition, will be included or not.</source>
          <target state="translated">选项 &lt;code&gt;reference&lt;/code&gt; 指定在表定义中找到时是否包含REFERENCE字段的文本。</target>
        </trans-unit>
        <trans-unit id="9c2f0f1df982a9202e8988ea8ba0887c0ec765a3" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;relaxed_row_name_assign_check&lt;/code&gt;, if present, specifies that the row name assign check shall not be done strictly according to the SMI (which allows only the value 1). With this option, all values greater than zero is allowed (&amp;gt;= 1). This means that the error will be converted to a warning.</source>
          <target state="translated">选项 &lt;code&gt;relaxed_row_name_assign_check&lt;/code&gt; （如果存在）指定不应严格按照SMI（仅允许值1）进行行名分配检查。使用此选项，允许所有大于零的值（&amp;gt; = 1）。这意味着该错误将转换为警告。</target>
        </trans-unit>
        <trans-unit id="151eec6c2db1b331e575634845f94f69b16d7c18" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;user_dir&lt;/code&gt; defaults to directory &lt;code&gt;users ~/.ssh&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;user_dir&lt;/code&gt; 默认为目录 &lt;code&gt;users ~/.ssh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29d7dbac9950684e60e65c932b5345b19e0b54d6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;verbosity&lt;/code&gt; specifies the verbosity of the SNMP mib compiler. I.e. if warning, info, log, debug and trace messages shall be shown.</source>
          <target state="translated">选项 &lt;code&gt;verbosity&lt;/code&gt; 指定SNMP mib编译器的详细程度。即，如果应显示警告，信息，日志，调试和跟踪消息。</target>
        </trans-unit>
        <trans-unit id="5705298d46062a2bdcc353cd9d9485048e006df9" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings&lt;/code&gt; specifies whether warning messages should be shown.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; 选项指定是否应显示警告消息。</target>
        </trans-unit>
        <trans-unit id="e6ac8043daec14dfce4fd3a09fc4e68dffb195c6" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;warnings_as_errors&lt;/code&gt;, if present, specifies whether warnings should be treated as errors.</source>
          <target state="translated">选项 &lt;code&gt;warnings_as_errors&lt;/code&gt; （如果存在）指定是否将警告视为错误。</target>
        </trans-unit>
        <trans-unit id="222e8e711eaedda0de12d881bcddb354da9d562f" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;{inline_size,Size}&lt;/code&gt; controls how large functions that are allowed to be inlined. Default is &lt;code&gt;24&lt;/code&gt;, which keeps the size of the inlined code roughly the same as the un-inlined version (only relatively small functions are inlined).</source>
          <target state="translated">选项 &lt;code&gt;{inline_size,Size}&lt;/code&gt; 控制允许内联的函数数量。默认值为 &lt;code&gt;24&lt;/code&gt; ，它使内联代码的大小与非内联版本的大小大致相同（仅内联较小的函数）。</target>
        </trans-unit>
        <trans-unit id="7d5f42ecfc1068f199f3ebaf4be4351cea9cfd06" translate="yes" xml:space="preserve">
          <source>The option &lt;strong&gt;does not&lt;/strong&gt; affect how data is returned from the I/O functions or how it is sent in the I/O protocol, it only affects how the I/O device is to handle Unicode characters to the &quot;physical&quot; device.</source>
          <target state="translated">该选项&lt;strong&gt;不&lt;/strong&gt;影响从I / O函数返回数据的方式或以I / O协议发送数据的方式，它仅影响I / O设备将Unicode字符处理到&amp;ldquo;物理&amp;rdquo;设备的方式。</target>
        </trans-unit>
        <trans-unit id="338c829674166b013ae8d81f99bc61cb99452fea" translate="yes" xml:space="preserve">
          <source>The option also triggers port-killing (if driver option &lt;code&gt;kill_ports&lt;/code&gt; is used) although there are pending users, making it usable for forced driver replacement, but laying much responsibility on the driver &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;. The pending option is seldom used as one does not want other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; to have loaded the driver when code change is underway.</source>
          <target state="translated">该选项还会触发端口杀死（如果使用了驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; ），尽管有未决用户，这使其可用于强制更换驱动程序，但对驱动程序 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 负有很大责任。挂起选项很少使用，因为在进行代码更改时，不希望其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="d79d46839d24acf194b4d95443c1a4c376523203" translate="yes" xml:space="preserve">
          <source>The option can be given in three different forms as seen &lt;code&gt;&lt;a href=&quot;ssh#type-accept_hosts&quot;&gt;above&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">该选项可以以三种不同的形式给出， &lt;code&gt;&lt;a href=&quot;ssh#type-accept_hosts&quot;&gt;above&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2ca5efd3f45626d14f10b1048bf3a919d5d5db7" translate="yes" xml:space="preserve">
          <source>The option can be given in three different forms as seen above:</source>
          <target state="translated">如上图所示,该选项可以以三种不同的形式给出。</target>
        </trans-unit>
        <trans-unit id="d5c1f8228c64d69ef6b194e7e3a544bd5d6d3471" translate="yes" xml:space="preserve">
          <source>The option can be set by using flag &lt;code&gt;-cover_stop&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, by adding &lt;code&gt;{cover_stop,true|false}&lt;/code&gt; to argument &lt;code&gt;Opts&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, or by adding a &lt;code&gt;cover_stop&lt;/code&gt; term in the test specification (see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results).</source>
          <target state="translated">选项可以通过使用标志被设置 &lt;code&gt;-cover_stop&lt;/code&gt; 与 &lt;code&gt;ct_run&lt;/code&gt; ，加入 &lt;code&gt;{cover_stop,true|false}&lt;/code&gt; 到参数 &lt;code&gt;Opts&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ，或通过添加 &lt;code&gt;cover_stop&lt;/code&gt; 在测试规范术语（参见 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 在区间行驶测试和分析结果）。</target>
        </trans-unit>
        <trans-unit id="a831925265214b18bff284c9cb5f8da772ac0d22" translate="yes" xml:space="preserve">
          <source>The option cooperates with the daemon-option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; in the following way:</source>
          <target state="translated">该选项通过以下方式与daemon-option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 配合使用：</target>
        </trans-unit>
        <trans-unit id="46610d896c3ed60bac06af5aa9b492b0218d289f" translate="yes" xml:space="preserve">
          <source>The option is good for reducing the risk of &quot;slow DoS&quot; attacks.</source>
          <target state="translated">该方案有利于降低 &quot;慢速DoS &quot;攻击的风险。</target>
        </trans-unit>
        <trans-unit id="7b36472af701f82ed3aadc8a7a7a28419165841c" translate="yes" xml:space="preserve">
          <source>The option list can contain the following options:</source>
          <target state="translated">选项列表可以包含以下选项:</target>
        </trans-unit>
        <trans-unit id="fbaef9197380d100811d0eacc53dce62a553d255" translate="yes" xml:space="preserve">
          <source>The option list given in the &lt;code&gt;&lt;a href=&quot;ssh#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; option is available with the key &lt;code&gt;key_cb_private&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 选项中提供的选项列表可与 &lt;code&gt;key_cb_private&lt;/code&gt; 键一起使用。</target>
        </trans-unit>
        <trans-unit id="df3c954b5ba9c1474ae29416fce03f6aaa090802" translate="yes" xml:space="preserve">
          <source>The option takes a list with instructions to append, prepend or remove algorithms:</source>
          <target state="translated">该选项采用了一个带有附加、前缀或删除算法指令的列表。</target>
        </trans-unit>
        <trans-unit id="c2eb6213b7b87f0b7e6e4d25afe9e32cc806c629" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Category&lt;/code&gt; argument can be used to categorize the log printout. Categories can be used for two things as follows:</source>
          <target state="translated">可选的 &lt;code&gt;Category&lt;/code&gt; 参数可用于对日志打印输出进行分类。类别可用于两件事，如下所示：</target>
        </trans-unit>
        <trans-unit id="447f5a3f76e3e9563c9b86d4ea43d4333c4ebffe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Descr&lt;/code&gt; parameter is included &quot;as is&quot; in the &lt;code&gt;relup&lt;/code&gt; file, see &lt;code&gt;&lt;a href=&quot;relup&quot;&gt;relup(4)&lt;/a&gt;&lt;/code&gt;. Defaults to the empty list.</source>
          <target state="translated">可选的 &lt;code&gt;Descr&lt;/code&gt; 参数按原样包含在 &lt;code&gt;relup&lt;/code&gt; 文件中，请参见 &lt;code&gt;&lt;a href=&quot;relup&quot;&gt;relup(4)&lt;/a&gt;&lt;/code&gt; 。默认为空列表。</target>
        </trans-unit>
        <trans-unit id="5f923e9b577173731c7b96e064927ce55ee5384c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;Timeout&lt;/code&gt; parameter specifies a time-out in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;Timeout&lt;/code&gt; 参数指定超时（以毫秒为单位）。默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52335a394cf2ecea7217c7a04e3f8442f2097418" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;expect&lt;/code&gt; declaration can be placed anywhere before the last optional section with Erlang code. It is used for suppressing the warning about conflicts that is ordinarily given if the grammar is ambiguous. An example:</source>
          <target state="translated">可选的 &lt;code&gt;expect&lt;/code&gt; 声明可以放在带有Erlang代码的最后一个可选部分之前的任何位置。它用于抑制语法不明确时通常会发出的有关冲突的警告。一个例子：</target>
        </trans-unit>
        <trans-unit id="161604dc3e7d1bc8b928595e85930b898a263976" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; can be used to define a function that is called in the following cases:</source>
          <target state="translated">可选参数 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 可用于定义在以下情况下调用的函数：</target>
        </trans-unit>
        <trans-unit id="0de6e1bc58d56088e6eddee453ec6c1aeb739d3a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;Varbinds&lt;/code&gt; defines values for the objects in the notification. If no value is given for an object, the &lt;code&gt;Agent&lt;/code&gt; performs a get-operation to retrieve the value.</source>
          <target state="translated">可选参数 &lt;code&gt;Varbinds&lt;/code&gt; 定义通知中对象的值。如果没有为对象提供任何值，则 &lt;code&gt;Agent&lt;/code&gt; 执行获取操作以检索该值。</target>
        </trans-unit>
        <trans-unit id="d9e24b2c05b3f59535f6993ef411d13d031da358" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;'author'&lt;/code&gt; and &lt;code&gt;'version'&lt;/code&gt; are only used with &lt;code&gt;'windows'&lt;/code&gt; option mode.</source>
          <target state="translated">选项 &lt;code&gt;'author'&lt;/code&gt; 和 &lt;code&gt;'version'&lt;/code&gt; 仅与 &lt;code&gt;'windows'&lt;/code&gt; 选项模式一起使用。</target>
        </trans-unit>
        <trans-unit id="d6e6ee87f0886860f355c1e2932aa71133b1ec67" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;cpu_time&lt;/code&gt; or &lt;code&gt;{cpu_time, true}&lt;/code&gt; makes the timestamps in the trace be in CPU time instead of wallclock time which is the default. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="translated">选项 &lt;code&gt;cpu_time&lt;/code&gt; 或 &lt;code&gt;{cpu_time, true}&lt;/code&gt; 使跟踪中的时间戳以CPU时间而不是默认的wallclock时间为单位。仅在 &lt;code&gt;start&lt;/code&gt; 选项中允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="a575a8485a0e80fe603347e1de8782c8007d6e61" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; are mutually exclusive, and &lt;code&gt;global&lt;/code&gt; is the default (if no options are specified). The options &lt;code&gt;call_count&lt;/code&gt; and &lt;code&gt;meta&lt;/code&gt; perform a kind of local tracing, and cannot be combined with &lt;code&gt;global&lt;/code&gt;. A function can be globally or locally traced. If global tracing is specified for a set of functions, then local, meta, call time, and call count tracing for the matching set of local functions is disabled, and conversely.</source>
          <target state="translated">选项 &lt;code&gt;global&lt;/code&gt; 和 &lt;code&gt;local&lt;/code&gt; 是互斥的，并且 &lt;code&gt;global&lt;/code&gt; 是默认选项（如果未指定选项）。选项 &lt;code&gt;call_count&lt;/code&gt; 和 &lt;code&gt;meta&lt;/code&gt; 执行一种局部跟踪，不能与 &lt;code&gt;global&lt;/code&gt; 结合使用。可以全局或局部跟踪功能。如果为一组函数指定了全局跟踪，那么将禁用匹配的局部函数集的本地，元，调用时间和调用计数跟踪，反之亦然。</target>
        </trans-unit>
        <trans-unit id="3141c0a0db1129b4b7780cf8ea2631a4c0406c6d" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;sock_ctrl&lt;/code&gt;, &lt;code&gt;sock_data_act&lt;/code&gt; and &lt;code&gt;sock_data_pass&lt;/code&gt; passes options down to the underlying transport layer (tcp). The default value for &lt;code&gt;sock_ctrl&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;. Both &lt;code&gt;sock_data_act&lt;/code&gt; and &lt;code&gt;sock_data_pass&lt;/code&gt; uses the value of &lt;code&gt;sock_ctrl&lt;/code&gt; as default value.</source>
          <target state="translated">选项 &lt;code&gt;sock_ctrl&lt;/code&gt; ， &lt;code&gt;sock_data_act&lt;/code&gt; 和 &lt;code&gt;sock_data_pass&lt;/code&gt; 将选项向下传递到基础传输层（tcp）。作为默认值 &lt;code&gt;sock_ctrl&lt;/code&gt; 是 &lt;code&gt;[]&lt;/code&gt; 。无论 &lt;code&gt;sock_data_act&lt;/code&gt; 和 &lt;code&gt;sock_data_pass&lt;/code&gt; 使用的值 &lt;code&gt;sock_ctrl&lt;/code&gt; 为默认值。</target>
        </trans-unit>
        <trans-unit id="532c3466b01dbba024ee7d7263923dee4eb39f70" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;{verbose, true}&lt;/code&gt; adds some trace flags that &lt;code&gt;fprof&lt;/code&gt; does not need, but that may be interesting for general debugging purposes. This option is only allowed with the &lt;code&gt;start&lt;/code&gt; option.</source>
          <target state="translated">选项 &lt;code&gt;verbose&lt;/code&gt; 或 &lt;code&gt;{verbose, true}&lt;/code&gt; 添加了一些 &lt;code&gt;fprof&lt;/code&gt; 不需要的跟踪标志，但是对于常规调试目的可能是有趣的。仅在 &lt;code&gt;start&lt;/code&gt; 选项中允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="42859c21f2b79ff6b36fc89627196cf7c13e3b9e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;{nowarn_unused_function, FAs}&lt;/code&gt;, &lt;code&gt;{nowarn_bif_clash, FAs}&lt;/code&gt;, and &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; are only recognized when given in files. They are not affected by options &lt;code&gt;warn_unused_function&lt;/code&gt;, &lt;code&gt;warn_bif_clash&lt;/code&gt;, or &lt;code&gt;warn_deprecated_function&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;{nowarn_unused_function, FAs}&lt;/code&gt; ， &lt;code&gt;{nowarn_bif_clash, FAs}&lt;/code&gt; 和 &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; 仅在文件中给出时才被识别。它们不受选项 &lt;code&gt;warn_unused_function&lt;/code&gt; ， &lt;code&gt;warn_bif_clash&lt;/code&gt; 或 &lt;code&gt;warn_deprecated_function&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="52fb8838009488073df993b32117ab4a617e4e27" translate="yes" xml:space="preserve">
          <source>The options above can be used both in clients and in daemons (servers). They are further explained below.</source>
          <target state="translated">上述选项既可以在客户端使用,也可以在守护进程(服务器)中使用。下文将进一步解释这些选项。</target>
        </trans-unit>
        <trans-unit id="e9822c92221a3f35f766011a9109d3678a91584e" translate="yes" xml:space="preserve">
          <source>The options and values supported by the OTP I/O devices are as follows:</source>
          <target state="translated">OTP I/O设备支持的选项和数值如下。</target>
        </trans-unit>
        <trans-unit id="7a7c0fea91826b765b39d57698d804c40ec768d3" translate="yes" xml:space="preserve">
          <source>The options are &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt;. The first one replaces the default set, while the latter modifies the default set.</source>
          <target state="translated">选项为 &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 。第一个替换默认设置，而第二个修改默认设置。</target>
        </trans-unit>
        <trans-unit id="966a458ac5f5553b2b1772cc14d9f0802ad711ce" translate="yes" xml:space="preserve">
          <source>The options are &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;. The first one replaces the default set, while the latter modifies the default set.</source>
          <target state="translated">选项为 &lt;code&gt;preferred_algorithms&lt;/code&gt; 和 &lt;code&gt;modify_algorithms&lt;/code&gt; 。第一个替换默认设置，而后者修改默认设置。</target>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">这些选择是:</target>
        </trans-unit>
        <trans-unit id="0993030c5ac4d368f471285e301a74deb9b525f8" translate="yes" xml:space="preserve">
          <source>The options defaults to existing, write and keep.</source>
          <target state="translated">选项默认为现有、写入和保留。</target>
        </trans-unit>
        <trans-unit id="8a90ed84ac6c9da62366fd72993b92a3d6548993" translate="yes" xml:space="preserve">
          <source>The options for the tracee:</source>
          <target state="translated">溯源的选项。</target>
        </trans-unit>
        <trans-unit id="d0d619e9e8a7b4ef0ea604d389b298331dfe1155" translate="yes" xml:space="preserve">
          <source>The options in &lt;code&gt;OptionList&lt;/code&gt; modify the defaults as follows:</source>
          <target state="translated">&lt;code&gt;OptionList&lt;/code&gt; 中的选项将修改默认值，如下所示：</target>
        </trans-unit>
        <trans-unit id="3cdec8fc084975065672d9bc75d5f2d7a5819ddb" translate="yes" xml:space="preserve">
          <source>The options in the &lt;code&gt;{server, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:ssl_accept/3&lt;/code&gt;, and the options in the &lt;code&gt;{client, Opts}&lt;/code&gt; tuple are used when calling &lt;code&gt;ssl:connect/4&lt;/code&gt;.</source>
          <target state="translated">在选项 &lt;code&gt;{server, Opts}&lt;/code&gt; 元组调用当使用 &lt;code&gt;ssl:ssl_accept/3&lt;/code&gt; ，并在选项 &lt;code&gt;{client, Opts}&lt;/code&gt; 元组调用当使用 &lt;code&gt;ssl:connect/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af7cdef0d63b99479b72526c60ef273fa1e971f4" translate="yes" xml:space="preserve">
          <source>The options list is added to those of the configuration file. If an option is specified in both lists, the configuration file take precedence.</source>
          <target state="translated">选项列表会添加到配置文件的选项列表中。如果在两个列表中都指定了一个选项,则以配置文件为准。</target>
        </trans-unit>
        <trans-unit id="c8d09bff072ed3537255f4353e6843e0b594882d" translate="yes" xml:space="preserve">
          <source>The options list is added to those of the configuration file. If an option is specified in both lists, the configuration file takes precedence.</source>
          <target state="translated">选项列表会添加到配置文件的选项列表中。如果在两个列表中都指定了一个选项,则以配置文件为准。</target>
        </trans-unit>
        <trans-unit id="c7b32dbf5a7282fb93990ccd87cc73489c02dc49" translate="yes" xml:space="preserve">
          <source>The order in which a SetFun is applied to the elements of an unordered set is not specified, and can change in future versions of this module.</source>
          <target state="translated">SetFun应用于无序集合元素的顺序没有指定,在本模块的未来版本中可以改变。</target>
        </trans-unit>
        <trans-unit id="f36c81c4641ae489656e683b39af63a52c09b9a1" translate="yes" xml:space="preserve">
          <source>The order in which keys are declared in matching has no relevance.</source>
          <target state="translated">匹配中键的声明顺序没有相关性。</target>
        </trans-unit>
        <trans-unit id="ba864cd36b5d9fc0734824a2d89b5010877afe23" translate="yes" xml:space="preserve">
          <source>The order in which test cases in a group are executed is under normal circumstances the same as the order specified in the test case list in the group definition. With property &lt;code&gt;shuffle&lt;/code&gt; set, however, &lt;code&gt;Common Test&lt;/code&gt; instead executes the test cases in random order.</source>
          <target state="translated">在正常情况下，执行组中的测试用例的顺序与在组定义中的测试用例列表中指定的顺序相同。但是，设置属性 &lt;code&gt;shuffle&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 会以随机顺序执行测试用例。</target>
        </trans-unit>
        <trans-unit id="9181dd756bf0c244588172ca0c10840e8c09e01c" translate="yes" xml:space="preserve">
          <source>The order in which the expressions constructing the keys (and their associated values) are evaluated is not defined. The syntactic order of the key-value pairs in the construction is of no relevance, except in the recently mentioned case of two matching keys.</source>
          <target state="translated">构建键(及其相关值)的表达式的评估顺序没有规定。除了最近提到的两个匹配键的情况外,键值对在构造中的语法顺序并不相关。</target>
        </trans-unit>
        <trans-unit id="3b2e651aff4100a2544284cdd623666e00826d4f" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; is only valid for &lt;code&gt;ordered_set&lt;/code&gt; tables, they are synonyms for other tables. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; / &lt;code&gt;last&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; / &lt;code&gt;prev&lt;/code&gt; 的顺序仅对 &lt;code&gt;ordered_set&lt;/code&gt; 表有效，它们是其他表的同义词。当到达表的末尾时，将返回特殊键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f2ba6ee8246f16a08bc23339d4a331af938338" translate="yes" xml:space="preserve">
          <source>The order of AVPs in an encoded message is determined by the CCF of the message in question.</source>
          <target state="translated">编码信息中AVP的顺序是由有关信息的CCF决定的。</target>
        </trans-unit>
        <trans-unit id="fca0f7684c3b5a228fba4c8df60980c0fb7304b8" translate="yes" xml:space="preserve">
          <source>The order of the &lt;code&gt;InfoTuple&lt;/code&gt;s is undefined and all &lt;code&gt;InfoTuple&lt;/code&gt;s are not mandatory. The &lt;code&gt;InfoTuple&lt;/code&gt;s part of the result can be changed without prior notice.</source>
          <target state="translated">&lt;code&gt;InfoTuple&lt;/code&gt; 的顺序未定义，并且所有 &lt;code&gt;InfoTuple&lt;/code&gt; 都不是必需的。结果的 &lt;code&gt;InfoTuple&lt;/code&gt; 部分可以更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="a424f07125a5351756bef9206873c14f5a6353a0" translate="yes" xml:space="preserve">
          <source>The order of the identifier types implies the hierarchy of the CPU topology. The valid orders are as follows:</source>
          <target state="translated">标识符类型的顺序意味着CPU拓扑结构的层次性。有效的顺序如下。</target>
        </trans-unit>
        <trans-unit id="6ef0543efe4d20b5865e3801acad36673d50a7e1" translate="yes" xml:space="preserve">
          <source>The order of the instructions is important.</source>
          <target state="translated">指令的顺序很重要。</target>
        </trans-unit>
        <trans-unit id="40a9e5e0989674c7605430c6223ced2839090722" translate="yes" xml:space="preserve">
          <source>The order within an request is undefined and variables are not processed in a defined order. Do not assume that the first variable in the PDU will be processed before the second, even if the agent processes variables in this order. It cannot even be assumed that requests belonging to different sub-agents have any order.</source>
          <target state="translated">请求中的顺序是未定义的,变量没有按照定义的顺序处理。不要假设PDU中的第一个变量会在第二个变量之前被处理,即使代理按照这个顺序处理变量。甚至不能假设属于不同子代理的请求有任何顺序。</target>
        </trans-unit>
        <trans-unit id="5d9c8867ac57c93dfa1e9dd7ececb7cee20d1616" translate="yes" xml:space="preserve">
          <source>The ordinal for the current wrap log file in the range &lt;code&gt;1..MaxNoFiles&lt;/code&gt;, where &lt;code&gt;MaxNoFiles&lt;/code&gt; is specified by the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;size&lt;/code&gt; or set by &lt;code&gt;change_size/2&lt;/code&gt;.</source>
          <target state="translated">当前包装日志文件的序数，范围为 &lt;code&gt;1..MaxNoFiles&lt;/code&gt; ，其中 &lt;code&gt;MaxNoFiles&lt;/code&gt; 由 &lt;code&gt;open/1&lt;/code&gt; 选项的 &lt;code&gt;size&lt;/code&gt; 指定或由 &lt;code&gt;change_size/2&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="e6550278cb65a35db070f10d5936d5bb981ed919" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; record used in the failed &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">失败的 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*.&lt;/a&gt;&lt;/code&gt; 使用的原始 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="970df94b5a2d0508f33375517efeb60800ec3879" translate="yes" xml:space="preserve">
          <source>The original I/O protocol was simple and flexible. Demands for memory efficiency and execution time efficiency have triggered extensions to the protocol over the years, making the protocol larger and somewhat less easy to implement than the original. It can certainly be argued that the current protocol is too complex, but this section describes how it looks today, not how it should have looked.</source>
          <target state="translated">最初的I/O协议简单而灵活。多年来,对内存效率和执行时间效率的要求引发了对协议的扩展,使协议比原来的协议更大,更不容易实现。当然,可以说目前的协议太复杂了,但本节描述的是它今天的样子,而不是它应该有的样子。</target>
        </trans-unit>
        <trans-unit id="217325b6d5ed0f7981283510de9de1d9ec6f8859" translate="yes" xml:space="preserve">
          <source>The original approach is more or less to search for next free index or slot in the array. The search starts from the last slot allocated. If we reach the end of the array we increase a &quot;wrapped counter&quot; and then continue the search. The process identifier is constructed by writing the index to the least significant set of bits, and the &quot;wrapped counter&quot; to the most significant set of bits. The amount of bits in each set of bits is decided at boot time, so that maximum index will just fit into the least significant set of bits.</source>
          <target state="translated">最初的方法是或多或少地搜索数组中的下一个空闲索引或槽。搜索从最后一个分配的槽开始。如果到达数组的末端,我们就增加一个 &quot;封装计数器&quot;,然后继续搜索。进程标识符是通过将索引写到最不重要的一组比特,将 &quot;封装计数器 &quot;写到最重要的一组比特来构造的。每组比特的数量是在启动时决定的,所以最大的索引将刚好适合于最不重要的一组比特。</target>
        </trans-unit>
        <trans-unit id="0f3737702a282f6801504751b80a23982a8e7770" translate="yes" xml:space="preserve">
          <source>The original balance condition &lt;strong&gt;h(T) &amp;lt;= ceil(c * log(|T|))&lt;/strong&gt; has been changed to the similar (but not quite equivalent) condition &lt;strong&gt;2 ^ h(T) &amp;lt;= |T| ^ c&lt;/strong&gt;. This should also be OK.</source>
          <target state="translated">原始平衡条件&lt;strong&gt;h（T）&amp;lt;= ceil（c * log（| T |））&lt;/strong&gt;已更改为相似（但不完全等效）的条件&lt;strong&gt;2 ^ h（T）&amp;lt;= | T | ^ c&lt;/strong&gt;。这也应该可以。</target>
        </trans-unit>
        <trans-unit id="7c191efd6920f25c3ba576f5b703e200e55bf2d5" translate="yes" xml:space="preserve">
          <source>The original implementation is mostly done by Scott Lystiger Fritchie as an Open Source Contribution and it should be viewed as such even though the source for dynamic tracing as well as this module is included in the main distribution. However, the ability to use dynamic tracing of the virtual machine is a very valuable contribution which OTP has every intention to maintain as a tool for the developer.</source>
          <target state="translated">最初的实现主要是由Scott Lystiger Fritchie完成的,作为一个开源贡献,它应该被看作是一个开源贡献,尽管动态跟踪的源代码和这个模块都包含在主发行版中。然而,使用虚拟机动态跟踪的能力是一个非常有价值的贡献,OTP完全有意向将其作为开发者的工具来维护。</target>
        </trans-unit>
        <trans-unit id="1fb9c163b9ae8bc176015b798d7f0fe518b0cc1e" translate="yes" xml:space="preserve">
          <source>The original problem was to parse the grammar &lt;code&gt;(a | b) &amp;amp; (c | d)&lt;/code&gt;. The following code addresses this problem:</source>
          <target state="translated">最初的问题是解析语法 &lt;code&gt;(a | b) &amp;amp; (c | d)&lt;/code&gt; 。以下代码解决了这个问题：</target>
        </trans-unit>
        <trans-unit id="fd881abf9ded0ff52d6c0c5cc6411dc02ab57f19" translate="yes" xml:space="preserve">
          <source>The originating module for a log event is only detected if the key &lt;code&gt;mfa&lt;/code&gt; exists in the metadata, and is associated with &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;. When log macros are used, this association is automatically added to all log events. If an API function is called directly, without using a macro, the logging client must explicitly add this information if module levels shall have any effect.</source>
          <target state="translated">仅当密钥 &lt;code&gt;mfa&lt;/code&gt; 存在于元数据中并且与 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 关联时，才检测到日志事件的发起模块。使用日志宏时，此关联会自动添加到所有日志事件中。如果不使用宏就直接调用API函数，则日志记录客户端必须在模块级别有效的情况下显式添加此信息。</target>
        </trans-unit>
        <trans-unit id="9a90fb6c08256a161c6eb483a2634b3ee24142c2" translate="yes" xml:space="preserve">
          <source>The originating user will wait for a reply or a timeout (defined by the request_timer). When it receives the reply this will optionally be acknowledged (regulated by auto_ack), and forwarded to the user. If an interim pending reply is received, the long_request_timer will be used instead of the usual request_timer, in order to enable avoidance of spurious re-sends of the request.</source>
          <target state="translated">发起用户将等待回复或超时(由 request_timer 定义)。当它收到回复时,会有选择地确认(由auto_ack调节),并转发给用户。如果收到一个临时的等待回复,long_request_timer将被用来代替通常的request_timer,以避免虚假的重新发送请求。</target>
        </trans-unit>
        <trans-unit id="0e92f5e32fcae91a4c9f4be9a317837d1de0ba2b" translate="yes" xml:space="preserve">
          <source>The other POSIX classes are unchanged, and match only characters with code points less than 128.</source>
          <target state="translated">其他POSIX类没有变化,只匹配码点小于128的字符。</target>
        </trans-unit>
        <trans-unit id="a1b939845b7eda3d69e2e492e608d1e0b328d6c2" translate="yes" xml:space="preserve">
          <source>The other backtracking verbs are not treated specially if they appear in a positive assertion. In particular, (*THEN) skips to the next alternative in the innermost enclosing group that has alternations, regardless if this is within the assertion.</source>
          <target state="translated">其他回溯动词如果出现在正断句中,则不作特殊处理。特别是,(*THEN)会跳到最里面的包围组中有交替的下一个备选词,不管它是否在断言中。</target>
        </trans-unit>
        <trans-unit id="500a74c2c6e51cd76905327b832ede2fe0521759" translate="yes" xml:space="preserve">
          <source>The other callback functions of &lt;code&gt;ch3&lt;/code&gt; must also be modified and perhaps a new interface function must be added, but this is not shown here.</source>
          <target state="translated">&lt;code&gt;ch3&lt;/code&gt; 的其他回调函数也必须修改，也许必须添加一个新的接口函数，但是此处未显示。</target>
        </trans-unit>
        <trans-unit id="e1666602d3dd9e1b07910e384ad36de2d7fa0e9b" translate="yes" xml:space="preserve">
          <source>The other keys are ignored by &lt;code&gt;systools&lt;/code&gt;.</source>
          <target state="translated">其他键被 &lt;code&gt;systools&lt;/code&gt; 忽略。</target>
        </trans-unit>
        <trans-unit id="ff87693daa403b15e56f02488339c0b3e4fa0a09" translate="yes" xml:space="preserve">
          <source>The other time stamps look as follows:</source>
          <target state="translated">其他时间戳如下:</target>
        </trans-unit>
        <trans-unit id="321bdf06ff3ec9568b1af37c71c2a264a638b9ce" translate="yes" xml:space="preserve">
          <source>The other values come from this module's lower levels and are all fairly fatal internal errors:</source>
          <target state="translated">其他的数值来自于这个模块的低层,都是相当致命的内部错误。</target>
        </trans-unit>
        <trans-unit id="e0a7845bc3d760cb054d362d23116a08f3c015aa" translate="yes" xml:space="preserve">
          <source>The output captured by EUnit in the current test case, as a string.</source>
          <target state="translated">EUnit在当前测试用例中捕获的输出,作为一个字符串。</target>
        </trans-unit>
        <trans-unit id="d61abb80ef251301a72eea2a6b5eddae542b20ef" translate="yes" xml:space="preserve">
          <source>The output file &lt;code&gt;OutFile&lt;/code&gt; defaults to &lt;code&gt;Module.COVER.out&lt;/code&gt;, or &lt;code&gt;Module.COVER.html&lt;/code&gt; if the option &lt;code&gt;html&lt;/code&gt; was used.</source>
          <target state="translated">如果使用了 &lt;code&gt;html&lt;/code&gt; 选项，则输出文件 &lt;code&gt;OutFile&lt;/code&gt; 默认为 &lt;code&gt;Module.COVER.out&lt;/code&gt; 或 &lt;code&gt;Module.COVER.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58ca31dbd1427ec5eab0714fa958680db4f60d0e" translate="yes" xml:space="preserve">
          <source>The output file contains Erlang source code for a parser module with module name equal to the &lt;code&gt;Parserfile&lt;/code&gt; parameter. After compilation, the parser can be called as follows (the module name is assumed to be &lt;code&gt;myparser&lt;/code&gt;):</source>
          <target state="translated">输出文件包含解析器模块的Erlang源代码，其模块名称等于 &lt;code&gt;Parserfile&lt;/code&gt; 参数。编译后，可以按以下方式调用解析器（模块名称假定为 &lt;code&gt;myparser&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="950bb6bb3590d1b255219966cda8abbac6d08f2f" translate="yes" xml:space="preserve">
          <source>The output files in this case get their names from the configuration file. If the configuration file is named &lt;code&gt;SetOfFiles.set.asn&lt;/code&gt;, the names of the output files are &lt;code&gt;SetOfFiles.hrl, SetOfFiles.erl, and SetOfFiles.asn1db&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，输出文件将从配置文件中获取其名称。如果配置文件名为 &lt;code&gt;SetOfFiles.set.asn&lt;/code&gt; ，则输出文件的名称为 &lt;code&gt;SetOfFiles.hrl, SetOfFiles.erl, and SetOfFiles.asn1db&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bb85e310428587626e30c116127a2422cb890a6" translate="yes" xml:space="preserve">
          <source>The output format is the same for all log events.</source>
          <target state="translated">所有日志事件的输出格式都是一样的。</target>
        </trans-unit>
        <trans-unit id="5ed44c5ce1be01aac830a9b9d364b5bda8cb5f89" translate="yes" xml:space="preserve">
          <source>The output from Erlang Top is as follows:</source>
          <target state="translated">Erlang Top的输出如下。</target>
        </trans-unit>
        <trans-unit id="4375455178eca4e09ac1ea27af2822d564dd76b8" translate="yes" xml:space="preserve">
          <source>The output is a new file which is called &lt;code&gt;&amp;lt;mibname&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="translated">输出是一个名为 &lt;code&gt;&amp;lt;mibname&amp;gt;.bin&lt;/code&gt; 的新文件。</target>
        </trans-unit>
        <trans-unit id="cf16c507f23262a645872ad8bd5824124e5cfbee" translate="yes" xml:space="preserve">
          <source>The output is not to a file, but instead as a tuple &lt;code&gt;{FileName, binary()}&lt;/code&gt;. The binary is a full zip archive with header and can be extracted with, for example, &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输出不是输出到文件，而是输出为元组 &lt;code&gt;{FileName, binary()}&lt;/code&gt; 。二进制文件是带有标头的完整zip存档，可以使用例如 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 提取。</target>
        </trans-unit>
        <trans-unit id="a8d74c93a5b988198b9814a0f75a0ef9857da6e1" translate="yes" xml:space="preserve">
          <source>The output mechanisms are similar to the input. The &lt;code&gt;do_send&lt;/code&gt; routine is as follows:</source>
          <target state="translated">输出机制类似于输入。该 &lt;code&gt;do_send&lt;/code&gt; 程序如下：</target>
        </trans-unit>
        <trans-unit id="3eeb56a012bbd124b84f163ce270cf01c80c63bc" translate="yes" xml:space="preserve">
          <source>The output of the Erlang shell is discarded.</source>
          <target state="translated">Erlang shell的输出被丢弃。</target>
        </trans-unit>
        <trans-unit id="d9c10e1f5cf0633868a0d6acdff9b23bdac7f561" translate="yes" xml:space="preserve">
          <source>The output produced by this function is a directory structure with the following structure:</source>
          <target state="translated">该函数产生的输出是一个目录结构,结构如下。</target>
        </trans-unit>
        <trans-unit id="674403e3c388ef76a5e40cb3d72afaed1e950c87" translate="yes" xml:space="preserve">
          <source>The overall format of the term format is as follows:</source>
          <target state="translated">术语格式的总体格式如下:。</target>
        </trans-unit>
        <trans-unit id="38835811defd1f6c34454d9d8396ca9e3e5af5d1" translate="yes" xml:space="preserve">
          <source>The overall size of data generated by &lt;code&gt;ttb&lt;/code&gt; can be greater than the wrap specification suggests. If a traced node restarts and autoresume is enabled, the old wrap log is always stored and a new one is created.</source>
          <target state="translated">&lt;code&gt;ttb&lt;/code&gt; 生成的数据的总体大小可能大于包装规范建议的大小。如果被跟踪的节点重新启动并启用了自动恢复，则始终会存储旧的换行日志并创建一个新的换行日志。</target>
        </trans-unit>
        <trans-unit id="61cb6b8dd505955f977238c607e61cb7a82df0c8" translate="yes" xml:space="preserve">
          <source>The overall structure is shown in the following figure:</source>
          <target state="translated">整体结构如下图所示。</target>
        </trans-unit>
        <trans-unit id="9eeb1faeea0972c3ec895f2220d460dca9a19ab6" translate="yes" xml:space="preserve">
          <source>The overhead caused by the thread progress functionality is more or less fixed using the same amount of schedulers regardless of the number of uses of the functionality. Already today quite a lot of functionality use it, and we plan to use it even more. When rewriting old implementations of ERTS internal functionality to use the thread progress functionality, this implies removing communication in the old implementation. Otherwise it is simply no point rewriting the old implementation to use the thread progress functionality. Since the thread progress overhead is more or less fixed, the rewrite will cause a reduction of the total communication in the system.</source>
          <target state="translated">无论功能的使用次数如何,使用相同数量的调度器,线程进度功能所造成的开销多少是固定的。今天已经有相当多的功能使用了它,而且我们计划使用更多的功能。当重写ERTS内部功能的旧实现来使用线程进度功能时,这意味着要删除旧实现中的通信。否则,为了使用线程进度功能而重写旧的实现根本没有意义。由于线程进度开销多少是固定的,所以重写会导致系统中总通信量的减少。</target>
        </trans-unit>
        <trans-unit id="42d3d3de02c6a33e51e88647ce88261f5af1cf9c" translate="yes" xml:space="preserve">
          <source>The owner process can read and write to the table. Other processes can only read the table. This is the default setting for the access rights.</source>
          <target state="translated">所有者进程可以对该表进行读写。其他进程只能读取该表。这是访问权限的默认设置。</target>
        </trans-unit>
        <trans-unit id="331814c66623f97cb435ceb418f5ea7c97f6b53b" translate="yes" xml:space="preserve">
          <source>The padding sent is automatically verified</source>
          <target state="translated">发送的填充物会自动验证</target>
        </trans-unit>
        <trans-unit id="089e146f1ffd790b907f38b914bb227184826d25" translate="yes" xml:space="preserve">
          <source>The palindrome-matching patterns above work only if the subject string does not start with a palindrome that is shorter than the entire string. For example, although &quot;abcba&quot; is correctly matched, if the subject is &quot;ababa&quot;, PCRE finds palindrome &quot;aba&quot; at the start, and then fails at top level, as the end of the string does not follow. Once again, it cannot jump back into the recursion to try other alternatives, so the entire match fails.</source>
          <target state="translated">以上的词缀匹配模式只有在主题字符串的开头不比整个字符串短的词缀时才有效。例如,虽然 &quot;abcba &quot;被正确匹配,但如果主题是 &quot;ababa&quot;,PCRE会在开头找到词素 &quot;aba&quot;,然后在顶层失败,因为字符串的结尾没有跟上。再一次,它不能跳回递归中去尝试其他的选择,所以整个匹配失败。</target>
        </trans-unit>
        <trans-unit id="16b533f17b54668ffb1295b9bb8d4f9eb100b70f" translate="yes" xml:space="preserve">
          <source>The paragraphs are per default sorted in decreasing order of the ACC column for the marked function. The calling list and called list within one paragraph are also per default sorted in decreasing order of their ACC column.</source>
          <target state="translated">默认情况下,段落是按照被标记函数的ACC列的递减顺序排列的。段落中的调用列表和被调用列表也默认按ACC列的递减顺序排列。</target>
        </trans-unit>
        <trans-unit id="e5d4d2b62e1143e2dd17a07c3bb206ef9be5f7b2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Echo&lt;/code&gt; guides the client about need to hide the password.</source>
          <target state="translated">参数 &lt;code&gt;Echo&lt;/code&gt; 会指导客户端有关隐藏密码的需求。</target>
        </trans-unit>
        <trans-unit id="5cfbf68425808c36b1647fe7633ef469ae247239" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;Receiver&lt;/code&gt; specifies where information about delivery of Inform-Requests should be sent. The agent sends Inform-Requests and waits for acknowledgments from the managers. &lt;code&gt;Receiver&lt;/code&gt; can have three values:</source>
          <target state="translated">参数 &lt;code&gt;Receiver&lt;/code&gt; 指定应将有关Inform-Requests传递的信息发送到何处。代理发送Inform-Requests并等待管理者的确认。 &lt;code&gt;Receiver&lt;/code&gt; 可以具有三个值：</target>
        </trans-unit>
        <trans-unit id="152ff7f0c7b49c6faf35deb995a082e612f15821" translate="yes" xml:space="preserve">
          <source>The parameter is ignored on platforms that are known to not be POSIX compatible (Windows and SunOS).</source>
          <target state="translated">在已知不兼容POSIX的平台(Windows和SunOS)上,该参数被忽略。</target>
        </trans-unit>
        <trans-unit id="b93a8824964c3c68da73bbc8d10931f15f14a1ad" translate="yes" xml:space="preserve">
          <source>The parameter is ignored on platforms that are known to not be posix compatible (Windows and SunOS).</source>
          <target state="translated">在已知不兼容posix的平台(Windows和SunOS)上,该参数被忽略。</target>
        </trans-unit>
        <trans-unit id="e2e3af558ccfd68eba22bfa2a8b643ad678f8a28" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;accumulate&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt; can be changed during runtime with function &lt;code&gt;&lt;a href=&quot;etop#config-2&quot;&gt;etop:config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以在运行时使用功能 &lt;code&gt;&lt;a href=&quot;etop#config-2&quot;&gt;etop:config/2&lt;/a&gt;&lt;/code&gt; 更改参数 &lt;code&gt;lines&lt;/code&gt; ， &lt;code&gt;interval&lt;/code&gt; ， &lt;code&gt;accumulate&lt;/code&gt; 和 &lt;code&gt;sort&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8e6a51df5790dddef932d3398c6395529808020" translate="yes" xml:space="preserve">
          <source>The parameters are as described in &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, except the &lt;code&gt;Timeout&lt;/code&gt; value.</source>
          <target state="translated">除 &lt;code&gt;Timeout&lt;/code&gt; 值外，参数如 &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 中所述。</target>
        </trans-unit>
        <trans-unit id="5ce98213439a608e155e2aca750dfccce5c0b98e" translate="yes" xml:space="preserve">
          <source>The parameters of this function cannot be properly checked by the runtime system when executed by arbitrary threads. This can cause the function not to fail when it should.</source>
          <target state="translated">该函数的参数被任意线程执行时,运行时系统无法正确检查。这可能导致函数在应该失败的时候没有失败。</target>
        </trans-unit>
        <trans-unit id="5ec665272ce04d7ab2f0ef6b068d9c3325cbd4bf" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; are the same as to &lt;code&gt;&lt;a href=&quot;#report_event&quot;&gt;et_collector:report_event/6&lt;/a&gt;&lt;/code&gt; in the previous chapter. The big difference between the two is in the semantics of the two functions. The second actually reports an &lt;code&gt;Event&lt;/code&gt; to the &lt;code&gt;Collector&lt;/code&gt; while the first does nothing, it just returns the atom &lt;code&gt;hopefully_traced&lt;/code&gt;. In order to make the parameters to &lt;code&gt;et:trace_me/5&lt;/code&gt; turn up in the &lt;code&gt;Collector&lt;/code&gt;, tracing of that function must be activated and the &lt;code&gt;Collector&lt;/code&gt; must be registered as a &lt;code&gt;Tracer&lt;/code&gt; of the &lt;code&gt;Raw Trace Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;et:trace_me/5&lt;/code&gt; 的参数与上一章的 &lt;code&gt;&lt;a href=&quot;#report_event&quot;&gt;et_collector:report_event/6&lt;/a&gt;&lt;/code&gt; 相同。两者之间的最大区别在于这两个函数的语义。第二个实际上向 &lt;code&gt;Collector&lt;/code&gt; 报告一个 &lt;code&gt;Event&lt;/code&gt; ，而第一个不执行任何操作，它仅返回 &lt;code&gt;hopefully_traced&lt;/code&gt; 原子。为了使所述参数 &lt;code&gt;et:trace_me/5&lt;/code&gt; 转起来在 &lt;code&gt;Collector&lt;/code&gt; ，该函数的追踪必须被激活，并且 &lt;code&gt;Collector&lt;/code&gt; 必须被注册为 &lt;code&gt;Tracer&lt;/code&gt; 的的 &lt;code&gt;Raw Trace Data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6476df9bd7becd5f1615533b733c1dab82d38f7" translate="yes" xml:space="preserve">
          <source>The parent of the process, that is, the process that executed &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt;.</source>
          <target state="translated">进程的父级，即执行 &lt;code&gt;spawn&lt;/code&gt; 或 &lt;code&gt;spawn_link&lt;/code&gt; 的进程。</target>
        </trans-unit>
        <trans-unit id="0ee187ad5dff135b81bffe6ade6896261862f011" translate="yes" xml:space="preserve">
          <source>The parse result will be:</source>
          <target state="translated">解析结果将是:</target>
        </trans-unit>
        <trans-unit id="908e2b3e43d5891b77738e237f36e159be4612ea" translate="yes" xml:space="preserve">
          <source>The parse transform is implemented in the module &lt;code&gt;ms_transform&lt;/code&gt; and the source &lt;strong&gt;must&lt;/strong&gt; include the file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source will result in a runtime error, not a compile time ditto. The include file is easiest included by adding the line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="translated">解析转换在模块 &lt;code&gt;ms_transform&lt;/code&gt; 中实现，并且源&lt;strong&gt;必须&lt;/strong&gt;在STDLIB中包含文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，此伪函数才能起作用。未能在源代码中包含hrl文件将导致运行时错误，而不是编译时错误。通过添加 &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; 行，可以最轻松地包含include文件。到源文件。</target>
        </trans-unit>
        <trans-unit id="9a0fcc18541768fed9656f58cddeaa15df804db5" translate="yes" xml:space="preserve">
          <source>The parse transform is provided in the &lt;code&gt;ms_transform&lt;/code&gt; module and the source &lt;strong&gt;must&lt;/strong&gt; include file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in STDLIB for this pseudo function to work. Failing to include the hrl file in the source results in a runtime error, not a compile time error. The include file is easiest included by adding line &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; to the source file.</source>
          <target state="translated">&lt;code&gt;ms_transform&lt;/code&gt; 模块中提供了解析转换，并且源&lt;strong&gt;必须&lt;/strong&gt;在STDLIB中包含文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，此伪函数才能起作用。未能在源中包含hrl文件会导致运行时错误，而不是编译时错误。通过添加 &lt;code&gt;-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).&lt;/code&gt; 行，可以最轻松地包含include文件。到源文件。</target>
        </trans-unit>
        <trans-unit id="fa633312a20d20d1705e931b8f39b80fb7e1696b" translate="yes" xml:space="preserve">
          <source>The parser can be tested as follows:</source>
          <target state="translated">可以对解析器进行如下测试。</target>
        </trans-unit>
        <trans-unit id="d631ad0e789906de6a0dbe0f9ecc3c2c43edfa6d" translate="yes" xml:space="preserve">
          <source>The parsing failed.</source>
          <target state="translated">解析失败。</target>
        </trans-unit>
        <trans-unit id="c723b00d013bcc979e9e3335bbd7a9da3fabcff7" translate="yes" xml:space="preserve">
          <source>The parsing was successful.</source>
          <target state="translated">解析成功。</target>
        </trans-unit>
        <trans-unit id="a49afee373329c5d676f06380eda3a2c7220be60" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;AbsForm&lt;/code&gt; is the abstract form of the parsed form.</source>
          <target state="translated">解析成功。 &lt;code&gt;AbsForm&lt;/code&gt; 是已解析形式的抽象形式。</target>
        </trans-unit>
        <trans-unit id="eb6f7d761bbc4ec8ae3eb1becad08674a67adfed" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;ExprList&lt;/code&gt; is a list of the abstract forms of the parsed expressions.</source>
          <target state="translated">解析成功。 &lt;code&gt;ExprList&lt;/code&gt; 是已解析表达式的抽象形式的列表。</target>
        </trans-unit>
        <trans-unit id="92efbe38030d8e57be00bf5943de97bce61a93f6" translate="yes" xml:space="preserve">
          <source>The parsing was successful. &lt;code&gt;Term&lt;/code&gt; is the Erlang term corresponding to the token list.</source>
          <target state="translated">解析成功。 &lt;code&gt;Term&lt;/code&gt; 是与令牌列表相对应的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="dd9391eec0e6a1677450d11b0522f2da3f205730" translate="yes" xml:space="preserve">
          <source>The parts of &lt;code&gt;Pattern&lt;/code&gt; found in &lt;code&gt;Subject&lt;/code&gt; are not included in the result.</source>
          <target state="translated">结果中不包含在&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 中找到的 &lt;code&gt;Pattern&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="ccbbd44c0b22193a0ebfca2702bb353e9cc69190" translate="yes" xml:space="preserve">
          <source>The password of the key stored in an engine.</source>
          <target state="translated">储存在引擎中的钥匙的密码。</target>
        </trans-unit>
        <trans-unit id="9b76c5acf9e48a823e1ce8da1feab2e91ccd0b05" translate="yes" xml:space="preserve">
          <source>The patched applications are appended to the list of installed applications. Take a look at &lt;code&gt;&amp;lt;InstallDir&amp;gt;/releases/OTP-REL/installed_application_versions&lt;/code&gt;.</source>
          <target state="translated">已修补的应用程序将附加到已安装的应用程序列表中。看一下 &lt;code&gt;&amp;lt;InstallDir&amp;gt;/releases/OTP-REL/installed_application_versions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de8aec81a8619523440bf735eef84868583ed273" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist at the master node &lt;code&gt;Master&lt;/code&gt;.</source>
          <target state="translated">路径 &lt;code&gt;Path&lt;/code&gt; （文件或目录）在主节点 &lt;code&gt;Master&lt;/code&gt; 上不存在。</target>
        </trans-unit>
        <trans-unit id="9efed4ade7b3864058f4bc8126d22473cb9ba0df" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;Path&lt;/code&gt; (file or directory) does not exist.</source>
          <target state="translated">路径 &lt;code&gt;Path&lt;/code&gt; （文件或目录）不存在。</target>
        </trans-unit>
        <trans-unit id="00b2a07ab726e41d953579382af2a4c7a39f62f9" translate="yes" xml:space="preserve">
          <source>The path is not relative.</source>
          <target state="translated">路径不是相对的。</target>
        </trans-unit>
        <trans-unit id="302ff460ef043ede1fb15ed8b241c07bf3d0af3a" translate="yes" xml:space="preserve">
          <source>The path is relative to the top-level log directory if &lt;code&gt;ct:run:testspec(TestSpec)&lt;/code&gt; executes the test.</source>
          <target state="translated">如果 &lt;code&gt;ct:run:testspec(TestSpec)&lt;/code&gt; 执行测试，则该路径相对于顶级日志目录。</target>
        </trans-unit>
        <trans-unit id="ed296092ce0cab58b679cc1f44b7eff89a2c0d6a" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent configuration files.</source>
          <target state="translated">路径位置是用来存放持久性配置文件的。</target>
        </trans-unit>
        <trans-unit id="df84aee71581027a14aa1d0460434f6a1cd2bc48" translate="yes" xml:space="preserve">
          <source>The path location is intended for persistent data files.</source>
          <target state="translated">路径位置是为持久性数据文件准备的。</target>
        </trans-unit>
        <trans-unit id="1f41c20a183605aaa02c5a050804cb5f85891fc8" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient data files on a local machine.</source>
          <target state="translated">该路径位置是用于本地机器上的瞬时数据文件。</target>
        </trans-unit>
        <trans-unit id="24ac97a8853d3eb3c0e82e90ec7ff8a99f90d2b1" translate="yes" xml:space="preserve">
          <source>The path location is intended for transient log files on a local machine.</source>
          <target state="translated">路径位置是用来存放本地机器上的瞬时日志文件的。</target>
        </trans-unit>
        <trans-unit id="fabb1e75bc1356932aba105b5820e5c24d189a02" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on a specified volume, or it is a specific file on the current working volume.</source>
          <target state="translated">路径名是相对于指定卷上的当前工作目录而言的,或者是当前工作卷上的特定文件。</target>
        </trans-unit>
        <trans-unit id="329f4e1f9e1361ccb26d9048eedbf79a0fc09f6b" translate="yes" xml:space="preserve">
          <source>The path name is relative to the current working directory on the current volume.</source>
          <target state="translated">路径名是相对于当前卷的当前工作目录而言的。</target>
        </trans-unit>
        <trans-unit id="698e20309829f4ab61d3971bbd487b1bdda9857f" translate="yes" xml:space="preserve">
          <source>The path name refers to a specific file on a specific volume.</source>
          <target state="translated">路径名称指的是特定卷上的特定文件。</target>
        </trans-unit>
        <trans-unit id="c82c62dcbb94f72c91af63848dc5e39d27171439" translate="yes" xml:space="preserve">
          <source>The path to the directory where the distribution modules reside must be known at boot. This can be achieved either by specifying &lt;code&gt;-pa &amp;lt;path&amp;gt;&lt;/code&gt; on the command line or by building a boot script containing the applications used for your distribution protocol. (In the &lt;code&gt;uds_dist&lt;/code&gt; protocol, only the &lt;code&gt;uds_dist&lt;/code&gt; application needs to be added to the script.)</source>
          <target state="translated">引导时必须知道分发模块所在目录的路径。这可以通过在命令行上指定 &lt;code&gt;-pa &amp;lt;path&amp;gt;&lt;/code&gt; 或通过构建包含用于分发协议的应用程序的启动脚本来实现。（在 &lt;code&gt;uds_dist&lt;/code&gt; 协议中，只需将 &lt;code&gt;uds_dist&lt;/code&gt; 应用程序添加到脚本中。）</target>
        </trans-unit>
        <trans-unit id="2d1086799d2044989f999b93d98fb8bea62405c8" translate="yes" xml:space="preserve">
          <source>The path variable should now contain the windows paths to javac.exe and makensis.exe.</source>
          <target state="translated">现在路径变量应该包含javac.exe和makensis.exe的Windows路径。</target>
        </trans-unit>
        <trans-unit id="698dcce20dfe46d840644fbd320bb371ef1dcc60" translate="yes" xml:space="preserve">
          <source>The paths could easily be changed by options: &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过以下选项轻松更改路径： &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a49ddc6f258248253adba50688d33ca02aa202" translate="yes" xml:space="preserve">
          <source>The paths could easily be changed by options: &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过以下选项轻松更改路径： &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e863090f08be4587b861f731a6d55a6ce32f762" translate="yes" xml:space="preserve">
          <source>The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself.</source>
          <target state="translated">该模式被强制 &quot;锚定&quot;,也就是说,它被限制只在被搜索的字符串(&quot;主题字符串&quot;)的第一个匹配点进行匹配。这种效果也可以通过模式本身的适当构造来实现。</target>
        </trans-unit>
        <trans-unit id="56b998a50f666939e90060048d8bd7137cbf14f7" translate="yes" xml:space="preserve">
          <source>The pattern is here within parentheses so that the recursion refers to them instead of the whole pattern.</source>
          <target state="translated">这里的模式是在括号内,所以递归指的是它们而不是整个模式。</target>
        </trans-unit>
        <trans-unit id="0cc98b553afe0b60b841f7b9f1c109087f0da93e" translate="yes" xml:space="preserve">
          <source>The pattern provided to the functions must be a valid record, and the first element of the provided tuple must be the &lt;code&gt;record_name&lt;/code&gt; of the table. The special element &lt;code&gt;'_'&lt;/code&gt; matches any data structure in Erlang (also known as an Erlang term). The special elements &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; behave as Erlang variables, that is, they match anything, bind the first occurrence, and match the coming occurrences of that variable against the bound value.</source>
          <target state="translated">提供给函数的模式必须是有效记录，并且提供的元组的第一个元素必须是表的 &lt;code&gt;record_name&lt;/code&gt; 。特殊元素 &lt;code&gt;'_'&lt;/code&gt; 与Erlang中的任何数据结构（也称为Erlang术语）匹配。特殊元素 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 行为与Erlang变量相同，即它们匹配任何内容，绑定第一个匹配项，并将该变量的后续匹配项与绑定值匹配。</target>
        </trans-unit>
        <trans-unit id="24a80ef32aca4a8713f164a83e5fedea62a3ed43" translate="yes" xml:space="preserve">
          <source>The pattern(s) must be matched multiple times. If &lt;code&gt;N&lt;/code&gt; is specified, the pattern(s) are matched &lt;code&gt;N&lt;/code&gt; times, and the function returns &lt;code&gt;HaltReason = done&lt;/code&gt;. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="translated">模式必须多次匹配。如果指定了 &lt;code&gt;N&lt;/code&gt; ，则将模式匹配 &lt;code&gt;N&lt;/code&gt; 次，并且该函数返回 &lt;code&gt;HaltReason = done&lt;/code&gt; 。此选项可以被一个或多个 &lt;code&gt;HaltPatterns&lt;/code&gt; 中断。总是返回 &lt;code&gt;MatchList&lt;/code&gt; ，即 &lt;code&gt;Match&lt;/code&gt; 的列表，而不是一个 &lt;code&gt;Match&lt;/code&gt; 。还返回 &lt;code&gt;HaltReason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c0886b7cf654b6b834bf58578aecb88e02ed55d" translate="yes" xml:space="preserve">
          <source>The pattern(s) must be matched multiple times. If &lt;code&gt;N&lt;/code&gt; is speciified, the pattern(s) are matched &lt;code&gt;N&lt;/code&gt; times, and the function returns &lt;code&gt;HaltReason = done&lt;/code&gt;. This option can be interrupted by one or more &lt;code&gt;HaltPatterns&lt;/code&gt;. &lt;code&gt;MatchList&lt;/code&gt; is always returned, that is, a list of &lt;code&gt;Match&lt;/code&gt; instead of only one &lt;code&gt;Match&lt;/code&gt;. Also &lt;code&gt;HaltReason&lt;/code&gt; is returned.</source>
          <target state="translated">模式必须多次匹配。如果指定了 &lt;code&gt;N&lt;/code&gt; ，则将模式匹配 &lt;code&gt;N&lt;/code&gt; 次，并且该函数返回 &lt;code&gt;HaltReason = done&lt;/code&gt; 。一个或多个 &lt;code&gt;HaltPatterns&lt;/code&gt; 可以中断此选项。总是返回 &lt;code&gt;MatchList&lt;/code&gt; ，即 &lt;code&gt;Match&lt;/code&gt; 的列表，而不是一个 &lt;code&gt;Match&lt;/code&gt; 。还返回 &lt;code&gt;HaltReason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="268d1764864d982e7120f74e74c9fd6647497d91" translate="yes" xml:space="preserve">
          <source>The patterns in the clause head can be successfully matched against the given arguments.</source>
          <target state="translated">分句头中的模式可以与给定的参数成功匹配。</target>
        </trans-unit>
        <trans-unit id="8cf98c378247e817abc5f228e3f59d4dd5e3a6c9" translate="yes" xml:space="preserve">
          <source>The peer certificate is returned as a DER-encoded binary. The certificate can be decoded with &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt;</source>
          <target state="translated">对等证书以DER编码的二进制形式返回。可以使用 &lt;code&gt;public_key:pkix_decode_cert/2&lt;/code&gt; 对证书进行解码</target>
        </trans-unit>
        <trans-unit id="9c33a7248317e3e4d5645db402b82fdf9bfcfb31" translate="yes" xml:space="preserve">
          <source>The performance degradation for a system that is enabled for sequential tracing is negligible as long as no tracing is activated. When tracing is activated, there is an extra cost for each traced message, but all other messages are unaffected.</source>
          <target state="translated">对于启用了顺序跟踪的系统来说,只要不激活跟踪,其性能下降就可以忽略不计。当跟踪被激活时,每个被跟踪的报文都会有额外的成本,但所有其他报文不受影响。</target>
        </trans-unit>
        <trans-unit id="a8cbfc9b98e9849da11c2e28dbb992bbe4ea2486" translate="yes" xml:space="preserve">
          <source>The permissible options are the same as for &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, except that option&lt;code&gt;capture&lt;/code&gt; is not allowed. Instead a &lt;code&gt;{return, ReturnType}&lt;/code&gt; is present. The default return type is &lt;code&gt;iodata&lt;/code&gt;, constructed in a way to minimize copying. The &lt;code&gt;iodata&lt;/code&gt; result can be used directly in many I/O operations. If a flat &lt;code&gt;list()&lt;/code&gt; is desired, specify &lt;code&gt;{return, list}&lt;/code&gt;. If a binary is desired, specify &lt;code&gt;{return, binary}&lt;/code&gt;.</source>
          <target state="translated">允许的选项与 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 相同，只是不允许选项 &lt;code&gt;capture&lt;/code&gt; 。而是使用 &lt;code&gt;{return, ReturnType}&lt;/code&gt; 。默认返回类型是 &lt;code&gt;iodata&lt;/code&gt; ，以最小化复制的方式构造。该 &lt;code&gt;iodata&lt;/code&gt; 结果可以直接在许多I / O操作中使用。如果需要一个简单的 &lt;code&gt;list()&lt;/code&gt; ，请指定 &lt;code&gt;{return, list}&lt;/code&gt; 。如果需要二进制文件，请指定 &lt;code&gt;{return, binary}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6319938072e5f5bf04da6b368d9c42dc62f6e008" translate="yes" xml:space="preserve">
          <source>The pid</source>
          <target state="translated">pid</target>
        </trans-unit>
        <trans-unit id="3f16145e2d18587f6b89bcea6a5d1f5d05a57b75" translate="yes" xml:space="preserve">
          <source>The pid of the heir of the table, or &lt;code&gt;none&lt;/code&gt; if no heir is set.</source>
          <target state="translated">表的继承人，或的PID &lt;code&gt;none&lt;/code&gt; ，如果没有继承人设置。</target>
        </trans-unit>
        <trans-unit id="bad35c800b2a5b5e2bf66d0ff3f487490a14c90c" translate="yes" xml:space="preserve">
          <source>The pid of the owner of the table.</source>
          <target state="translated">桌主的pid。</target>
        </trans-unit>
        <trans-unit id="eb05b4cc61bcd44e5954e6a679ba99c62203c819" translate="yes" xml:space="preserve">
          <source>The pid of the receiving process. The pid is to refer to a process on the local node.</source>
          <target state="translated">接收进程的pid。pid是指本地节点上的进程。</target>
        </trans-unit>
        <trans-unit id="826db1b9e643364ce8e57b8ab6ccf5be81118acd" translate="yes" xml:space="preserve">
          <source>The point of sending data as a list header, is to facilitate matching on the data received.</source>
          <target state="translated">以列表头的形式发送数据的目的,是为了方便对接收到的数据进行匹配。</target>
        </trans-unit>
        <trans-unit id="a0dac0c856b6bd486d6d80e0c5f670c5e59ababc" translate="yes" xml:space="preserve">
          <source>The polling feature is controlled by the configuration values &lt;code&gt;poll_limit&lt;/code&gt; and &lt;code&gt;poll_interval&lt;/code&gt; and is by default disabled. This means that the function immediately returns all complete strings received and saves a remaining non-terminated string for a later &lt;code&gt;get_data&lt;/code&gt; call.</source>
          <target state="translated">轮询功能由配置值 &lt;code&gt;poll_limit&lt;/code&gt; 和 &lt;code&gt;poll_interval&lt;/code&gt; 控制，默认情况下处于禁用状态。这意味着该函数立即返回接收到的所有完整字符串，并将剩余的未终止字符串保存下来，供以后的 &lt;code&gt;get_data&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="d70c2213a0ee68939918fb6057ef93442450250d" translate="yes" xml:space="preserve">
          <source>The poly1305 mac wants an 32 bytes key and produces a 16 byte MAC by default.</source>
          <target state="translated">poly1305 mac想要一个32字节的密钥,默认产生一个16字节的MAC。</target>
        </trans-unit>
        <trans-unit id="a404af1f3c39c2d9104c462845e5717ca07b814f" translate="yes" xml:space="preserve">
          <source>The pool is implemented as a lock-free, circular, double linked, list. The list contains a sentinel which is used as the starting point when inserting to, or fetching from, the pool. Carriers in the pool are elements in this list.</source>
          <target state="translated">池是作为一个无锁的、循环的、双链接的列表来实现的。列表中包含一个哨兵,当向池中插入或从池中提取时,它被用作起点。池中的载体是这个列表中的元素。</target>
        </trans-unit>
        <trans-unit id="5d6f13f29266bcb18f4282624a4022662ca669ae" translate="yes" xml:space="preserve">
          <source>The pool of nodes</source>
          <target state="translated">节点库</target>
        </trans-unit>
        <trans-unit id="9f5b4ca13c9ab872bb6daaa4dfbebefbf017cc04" translate="yes" xml:space="preserve">
          <source>The port ID of the receiving port. The port ID is to refer to a port on the local node.</source>
          <target state="translated">接收端口的端口ID。该端口ID是指本地节点上的端口。</target>
        </trans-unit>
        <trans-unit id="0ddfe98846c7da18189a1df423baa1aaca1defcc" translate="yes" xml:space="preserve">
          <source>The port can only be used for input.</source>
          <target state="translated">该端口只能用于输入。</target>
        </trans-unit>
        <trans-unit id="2e788605ff88677668be04c2f0461ee176fc8414" translate="yes" xml:space="preserve">
          <source>The port can only be used for output.</source>
          <target state="translated">该端口只能用于输出。</target>
        </trans-unit>
        <trans-unit id="8e5668c5527d21298d324cca59ff3c8059f2e94f" translate="yes" xml:space="preserve">
          <source>The port controlling communication with the remote node.</source>
          <target state="translated">控制与远程节点通信的端口。</target>
        </trans-unit>
        <trans-unit id="d8add36b162d7f85fd7335d4a43fd4c5d3cb6a19" translate="yes" xml:space="preserve">
          <source>The port does &lt;strong&gt;not&lt;/strong&gt; reply with &lt;code&gt;{Port,connected}&lt;/code&gt;.</source>
          <target state="translated">端口并&lt;strong&gt;不会&lt;/strong&gt;与回复 &lt;code&gt;{Port,connected}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e2ddef440aa65eb46a9df15d1fd89471e5e732" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) creating the new port.</source>
          <target state="translated">创建新 port 的 port(驱动程序实例)的端口句柄。</target>
        </trans-unit>
        <trans-unit id="405194befe843be0a71985802205fb7d1880fe5a" translate="yes" xml:space="preserve">
          <source>The port handle of the port (driver instance) doing the acknowledgment.</source>
          <target state="translated">进行确认的端口(驱动程序实例)的端口句柄。</target>
        </trans-unit>
        <trans-unit id="95eb949bda5093de827dd6c5e24f46c8d5c5fb5e" translate="yes" xml:space="preserve">
          <source>The port identifier for the port that this structure corresponds to. It is needed for most &lt;code&gt;driver_XXX&lt;/code&gt; calls from the driver back to the emulator.</source>
          <target state="translated">此结构对应的端口的端口标识符。从驱动程序回到仿真器的大多数 &lt;code&gt;driver_XXX&lt;/code&gt; 调用都需要它。</target>
        </trans-unit>
        <trans-unit id="66cfb7457c3ee07be7aa92ceb66e42b6845d40bb" translate="yes" xml:space="preserve">
          <source>The port identifier of the port that is currently executed by the scheduler.</source>
          <target state="translated">当前被调度器执行的端口标识符。</target>
        </trans-unit>
        <trans-unit id="4d482aa64430d6219ae86b9b4af57ffcff9757f8" translate="yes" xml:space="preserve">
          <source>The port identifier.</source>
          <target state="translated">端口标识符。</target>
        </trans-unit>
        <trans-unit id="56b2c676adbaff1c1e1e0d421f4b603ad3e33a68" translate="yes" xml:space="preserve">
          <source>The port is created using the BIF &lt;code&gt;open_port/2&lt;/code&gt; with &lt;code&gt;{spawn,ExtPrg}&lt;/code&gt; as the first argument. The string &lt;code&gt;ExtPrg&lt;/code&gt; is the name of the external program, including any command line arguments. The second argument is a list of options, in this case only &lt;code&gt;{packet,2}&lt;/code&gt;. This option says that a 2 byte length indicator is to be used to simplify the communication between C and Erlang. The Erlang port automatically adds the length indicator, but this must be done explicitly in the external C program.</source>
          <target state="translated">使用BIF &lt;code&gt;open_port/2&lt;/code&gt; (以 &lt;code&gt;{spawn,ExtPrg}&lt;/code&gt; 作为第一个参数）创建端口。字符串 &lt;code&gt;ExtPrg&lt;/code&gt; 是外部程序的名称，包括任何命令行参数。第二个参数是选项列表，在这种情况下，仅是 &lt;code&gt;{packet,2}&lt;/code&gt; 。此选项表示将使用2字节长的指示器来简化C和Erlang之间的通信。Erlang端口会自动添加长度指示器，但这必须在外部C程序中明确完成。</target>
        </trans-unit>
        <trans-unit id="d515078a6d0f1b9f22ce1b5d7e5c099ff2874fa5" translate="yes" xml:space="preserve">
          <source>The port is not closed at the end of the file and does not produce an exit signal. Instead, it remains open and a &lt;code&gt;{Port, eof}&lt;/code&gt; message is sent to the process holding the port.</source>
          <target state="translated">该文件的末尾未关闭该端口，并且不会产生退出信号。而是保持打开状态，并向保存该端口的进程发送 &lt;code&gt;{Port, eof}&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="6a456a28936847225b9929c122d159c3ef3485f0" translate="yes" xml:space="preserve">
          <source>The port is then created using the BIF &lt;code&gt;open_port/2&lt;/code&gt;, with the tuple &lt;code&gt;{spawn, DriverName}&lt;/code&gt; as the first argument. The string &lt;code&gt;SharedLib&lt;/code&gt; is the name of the port driver. The second argument is a list of options, none in this case:</source>
          <target state="translated">然后使用BIF &lt;code&gt;open_port/2&lt;/code&gt; 创建端口，将元组 &lt;code&gt;{spawn, DriverName}&lt;/code&gt; 作为第一个参数。字符串 &lt;code&gt;SharedLib&lt;/code&gt; 是端口驱动程序的名称。第二个参数是选项列表，在这种情况下没有选项：</target>
        </trans-unit>
        <trans-unit id="b9fcfec977ea3c1e018c7d81f66fbf088c0f1d7b" translate="yes" xml:space="preserve">
          <source>The port message queue is set into a busy state when the amount of command data queued on the message queue reaches the &lt;code&gt;high&lt;/code&gt; limit. The port message queue is set into a not busy state when the amount of command data queued on the message queue falls below the &lt;code&gt;low&lt;/code&gt; limit. Command data is in this context data passed to the port using either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;. Notice that these limits only concerns command data that have not yet reached the port. The &lt;code&gt;&lt;a href=&quot;#set_busy_port&quot;&gt;busy port&lt;/a&gt;&lt;/code&gt; feature can be used for data that has reached the port.</source>
          <target state="translated">当命令数据的排队的消息队列中的量达到该端口的消息队列被设置成忙状态 &lt;code&gt;high&lt;/code&gt; 限。当在消息队列中排队的命令数据量低于 &lt;code&gt;low&lt;/code&gt; 限时，端口消息队列被设置为不忙状态。在这种情况下，命令数据就是使用任一 &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; 或 &lt;code&gt;port_command/[2,3]&lt;/code&gt; 。请注意，这些限制仅涉及尚未到达端口的命令数据。在 &lt;code&gt;&lt;a href=&quot;#set_busy_port&quot;&gt;busy port&lt;/a&gt;&lt;/code&gt; 功能，可用于已达到该端口的数据。</target>
        </trans-unit>
        <trans-unit id="5dbf981a049194a99596e0c4fa486d1d1e17175d" translate="yes" xml:space="preserve">
          <source>The port name of the new port. You usually want to use the same port name as the driver name (&lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt; driver_name&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新端口的端口名称。您通常需要使用相同的端口名称作为驱动程序名称（ &lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt; driver_name&lt;/a&gt;&lt;/code&gt; 基于场 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="20086dbd568a4d1794aae351e6d4783a1bb4f27a" translate="yes" xml:space="preserve">
          <source>The port name of the new port. You usually want to use the same port name as the driver name (&lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt;driver_name&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新端口的端口名称。您通常需要使用相同的端口名称作为驱动程序名称（ &lt;code&gt;&lt;a href=&quot;driver_entry#driver_name&quot;&gt;driver_name&lt;/a&gt;&lt;/code&gt; 基于场 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f0f47e8645d1b1ba4480dbc54c2d1360eb57b767" translate="yes" xml:space="preserve">
          <source>The port number on which the node accept connection requests.</source>
          <target state="translated">节点接受连接请求的端口号。</target>
        </trans-unit>
        <trans-unit id="14a2d34036c08fb128310c5494cd65660394733e" translate="yes" xml:space="preserve">
          <source>The port owner &lt;code&gt;Pid&lt;/code&gt; can communicate with the port &lt;code&gt;Port&lt;/code&gt; by sending and receiving messages. (In fact, any process can send the messages to the port, but the port owner must be identified in the message).</source>
          <target state="translated">端口所有者 &lt;code&gt;Pid&lt;/code&gt; 可以通过发送和接收消息来与端口 &lt;code&gt;Port&lt;/code&gt; 通信。（实际上，任何进程都可以将消息发送到端口，但是必须在消息中标识端口所有者）。</target>
        </trans-unit>
        <trans-unit id="587eaf52651123552b5f25d92f9633eb1946c4d6" translate="yes" xml:space="preserve">
          <source>The port table is very similar to the process table. The major difference, at least in concept, is that it is a mapping from port identifiers to port structures. It had a similar implementation, but with some differences. Instead of being an array of pointers it was an array of structures, and instead of being protected by two types of locks it was only protected by one global lock. This table also suffered from lock contention in various situations.</source>
          <target state="translated">端口表与进程表非常相似。主要的区别,至少在概念上是,它是一个从端口标识符到端口结构的映射。它有类似的实现,但也有一些不同。它不是一个指针数组,而是一个结构数组;它也不是受两种锁的保护,而是只受一个全局锁的保护。这个表在各种情况下也会受到锁争用的影响。</target>
        </trans-unit>
        <trans-unit id="53c673fa38fb63daad8279f5786d12a340c3879a" translate="yes" xml:space="preserve">
          <source>The port that the HTTP server listen to. If zero is specified as port, an arbitrary available port is picked and function &lt;code&gt;httpd:info/2&lt;/code&gt; can be used to determine which port was picked.</source>
          <target state="translated">HTTP服务器侦听的端口。如果将零指定为端口，则选择任意可用端口，并且可以使用函数 &lt;code&gt;httpd:info/2&lt;/code&gt; 来确定选择了哪个端口。</target>
        </trans-unit>
        <trans-unit id="303cb397a1becf617c4be6350ca5fd61cb80f620" translate="yes" xml:space="preserve">
          <source>The ports implemented by this driver operate in two major modes, named &lt;code&gt;command&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;. In &lt;code&gt;command&lt;/code&gt; mode, only passive reading and writing (like &lt;code&gt;gen_tcp:recv&lt;/code&gt;/&lt;code&gt;gen_tcp:send&lt;/code&gt;) can be done. The port is in this mode during the distribution handshake. When the connection is up, the port is switched to &lt;code&gt;data&lt;/code&gt; mode and all data is immediately read and passed further to the Erlang emulator. In &lt;code&gt;data&lt;/code&gt; mode, no data arriving to &lt;code&gt;uds_command&lt;/code&gt; is interpreted, only packaged and sent out on the socket. The &lt;code&gt;uds_control&lt;/code&gt; callback does the switching between those two modes.</source>
          <target state="translated">该驱动程序实现的端口以两种主要模式运行，分别称为 &lt;code&gt;command&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 。在 &lt;code&gt;command&lt;/code&gt; 模式下，只能进行被动读写（例如 &lt;code&gt;gen_tcp:recv&lt;/code&gt; / &lt;code&gt;gen_tcp:send&lt;/code&gt; ）。分发握手期间，端口处于此模式。连接建立后，端口将切换到 &lt;code&gt;data&lt;/code&gt; 模式，所有数据立即被读取并进一步传递给Erlang仿真器。在 &lt;code&gt;data&lt;/code&gt; 模式下，不解释到达 &lt;code&gt;uds_command&lt;/code&gt; 的数据，仅打包并将其发送到套接字。该 &lt;code&gt;uds_control&lt;/code&gt; 回调做这两种模式之间的切换。</target>
        </trans-unit>
        <trans-unit id="479cb4b39a01954743d9faba125677bc9ccf6bba" translate="yes" xml:space="preserve">
          <source>The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey Friedl originated the idea (and the name) in the first edition of his book. Mike McCloskey liked it, so implemented it when he built the Sun Java package, and PCRE copied it from there. It ultimately found its way into Perl at release 5.10.</source>
          <target state="translated">占有式量化器语法是对 Perl 5.8 语法的扩展。Jeffrey Friedl在他的书的第一版中提出了这个想法(和名字)。Mike McCloskey 喜欢它,所以在构建 Sun Java 软件包时实现了它,PCRE 也从那里复制了它。它最终在5.10版本的Perl中得到了应用。</target>
        </trans-unit>
        <trans-unit id="3636e381fdb27bd130356d04a1054555e03c668b" translate="yes" xml:space="preserve">
          <source>The possible commands are &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, and &lt;code&gt;unlink&lt;/code&gt;.</source>
          <target state="translated">可能的命令是 &lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;close&lt;/code&gt; ， &lt;code&gt;command&lt;/code&gt; ， &lt;code&gt;connect&lt;/code&gt; ， &lt;code&gt;control&lt;/code&gt; ， &lt;code&gt;flush&lt;/code&gt; ， &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;link&lt;/code&gt; ， &lt;code&gt;open&lt;/code&gt; 和 &lt;code&gt;unlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed31e825086e99a9550da0520a157f768b47fed9" translate="yes" xml:space="preserve">
          <source>The possible error reasons and the corresponding diagnostic strings returned by &lt;code&gt;formaterror/1&lt;/code&gt; are as follows:</source>
          <target state="translated">可能的错误原因以及 &lt;code&gt;formaterror/1&lt;/code&gt; 返回的相应诊断字符串如下：</target>
        </trans-unit>
        <trans-unit id="c76008544af718ead9afe49e6a29a494608280a0" translate="yes" xml:space="preserve">
          <source>The possible modifications are:</source>
          <target state="translated">可能的修改是:</target>
        </trans-unit>
        <trans-unit id="f67dca2d282eb65ee7030798081655de26212d8e" translate="yes" xml:space="preserve">
          <source>The possible monitor messages to expect are the same as when using option &lt;code&gt;unloaded&lt;/code&gt; to function &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可能期望的监控器消息与使用选项 &lt;code&gt;unloaded&lt;/code&gt; 到功能 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 时的消息相同。</target>
        </trans-unit>
        <trans-unit id="3402737cdfb2af426a71f1abc6fcfd8e890b8dfe" translate="yes" xml:space="preserve">
          <source>The possible path validation errors are given on form &lt;code&gt;{bad_cert, Reason}&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is:</source>
          <target state="translated">可能的路径验证错误在表格 &lt;code&gt;{bad_cert, Reason}&lt;/code&gt; 上给出，其中 &lt;code&gt;Reason&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="4a941da52cdacf4f18dab68834ca9a0b9b380d76" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;SeqTraceFlag&lt;/code&gt; are available in &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">对于可能的值 &lt;code&gt;SeqTraceFlag&lt;/code&gt; 在提供 &lt;code&gt;seq_trace&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8463b8102b0a232e391b76c31a7662065c9a35d8" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;code&gt;Reason&lt;/code&gt; returned when an error occurs are:</source>
          <target state="translated">发生错误时返回的 &lt;code&gt;Reason&lt;/code&gt; 可能值为：</target>
        </trans-unit>
        <trans-unit id="d9e7ad200abbd6c26753c3e135059d909819a0d3" translate="yes" xml:space="preserve">
          <source>The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of &lt;strong&gt;metacharacters&lt;/strong&gt;, which do not stand for themselves but instead are interpreted in some special way.</source>
          <target state="translated">正则表达式的功能来自在模式中包含替代和重复项的能力。这些通过使用&lt;strong&gt;元字符&lt;/strong&gt;在模式中进行编码，这些&lt;strong&gt;元字符&lt;/strong&gt;本身并不代表而是以某种特殊方式进行解释。</target>
        </trans-unit>
        <trans-unit id="b75dfccef8bf15d11af3ec419501f78711191fcb" translate="yes" xml:space="preserve">
          <source>The pre (post) functions for different tables are evaluated in unspecified order.</source>
          <target state="translated">不同表的前(后)函数的评估顺序不详。</target>
        </trans-unit>
        <trans-unit id="ef1f9e226e4b6cb5e965d6e8bd26fbd505355d6e" translate="yes" xml:space="preserve">
          <source>The precise effect of \cx on ASCII characters is as follows: if x is a lowercase letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A (A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes hex 7B (; is 3B). If the data item (byte or 16-bit value) following \c has a value &amp;gt; 127, a compile-time error occurs. This locks out non-ASCII characters in all modes.</source>
          <target state="translated">\ cx对ASCII字符的精确影响如下：如果x是小写字母，则将其转换为大写字母。然后，字符（十六进制40）的第6位反转。因此\ cA到\ cZ变成十六进制01到十六进制1A（A是41，Z是5A），但是\ c {变成十六进制3B（{是7B），并且\ c;变为十六进制7B（;为3B）。如果\ c之后的数据项（字节或16位值）的值&amp;gt; 127，则会发生编译时错误。这将在所有模式下锁定非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="b9ec8174f3c0fbb4a103d0721bac0a4593311c47" translate="yes" xml:space="preserve">
          <source>The precision field selects base, for example:</source>
          <target state="translated">例如,精度字段选择基。</target>
        </trans-unit>
        <trans-unit id="fe3ebba2ea20548fa4e1d8023343d98509aee9ee" translate="yes" xml:space="preserve">
          <source>The preferred way to do driver code replacement is to let &lt;strong&gt;one single process&lt;/strong&gt; keep track of the driver. When the process starts, the driver is loaded. When replacement is required, the driver is reloaded. Unload is probably never done, or done when the process exits. If more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has a driver loaded when code replacement is demanded, the replacement cannot occur until the last &quot;other&quot; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has unloaded the driver.</source>
          <target state="translated">进行驱动程序代码替换的首选方法是让&lt;strong&gt;一个进程&lt;/strong&gt;跟踪驱动程序。该过程开始时，将加载驱动程序。需要更换时，将重新加载驱动程序。卸载可能永远不会完成，或者在进程退出时完成。如果在要求替换代码时加载了多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 的驱动程序，则只有在最后一个&amp;ldquo;其他&amp;rdquo; &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 卸载了该驱动程序之后，才能进行替换。</target>
        </trans-unit>
        <trans-unit id="733bbb9127b2be9265fae567e547e0cecf362a58" translate="yes" xml:space="preserve">
          <source>The prefix can be a possibly deep list of characters or an atom. Example:</source>
          <target state="translated">前缀可以是一个可能很深的字符列表或一个原子。例子:&quot;前缀 &quot;可以是一个可能很深的字符列表或一个原子。</target>
        </trans-unit>
        <trans-unit id="15f6bbecf9747f4a64f4e7bbe9b753ee0ba59494" translate="yes" xml:space="preserve">
          <source>The prepare phase is designed to allow several &quot;loader&quot; processes to prepare separate modules in parallel while the finishing phase can only be done by one loader process at a time. A second loader process trying to enter finishing phase will be suspended until the first loader is done. This will only block the process, the scheduler is free to schedule other work while the second loader is waiting. (See &lt;code&gt;erts_try_seize_code_write_permission&lt;/code&gt; and &lt;code&gt;erts_release_code_write_permission&lt;/code&gt;).</source>
          <target state="translated">准备阶段旨在允许多个&amp;ldquo;加载器&amp;rdquo;过程并行准备单独的模块，而精加工阶段一次只能由一个加载器过程完成。尝试进入完成阶段的第二个加载程序进程将被暂停，直到第一个加载程序完成为止。这只会阻塞该进程，而调度程序可以在第二个加载程序正在等待时自由地调度其他工作。（请参阅 &lt;code&gt;erts_try_seize_code_write_permission&lt;/code&gt; 和 &lt;code&gt;erts_release_code_write_permission&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dba1348d69926c90183adbcb04fa0974199d7975" translate="yes" xml:space="preserve">
          <source>The pretty printer &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;erl_prettypr&lt;/a&gt;&lt;/code&gt; is implemented on top of the library module &lt;code&gt;&lt;a href=&quot;prettypr&quot;&gt;prettypr&lt;/a&gt;&lt;/code&gt;: this is a powerful and flexible generic pretty printing library, which is also distributed separately.</source>
          <target state="translated">漂亮打印机 &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;erl_prettypr&lt;/a&gt;&lt;/code&gt; 在库模块 &lt;code&gt;&lt;a href=&quot;prettypr&quot;&gt;prettypr&lt;/a&gt;&lt;/code&gt; 之上实现：这是一个功能强大且灵活的通用漂亮打印库，该库也单独分发。</target>
        </trans-unit>
        <trans-unit id="babda6f60c6c355195de3c2c14dddea91447f96f" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;&lt;a href=&quot;using_ssh#basic-example&quot;&gt;Basic example&lt;/a&gt;&lt;/code&gt; can be extended with encryption and decryption as follows:</source>
          <target state="translated">前面的 &lt;code&gt;&lt;a href=&quot;using_ssh#basic-example&quot;&gt;Basic example&lt;/a&gt;&lt;/code&gt; 可以通过加密和解密进行扩展，如下所示：</target>
        </trans-unit>
        <trans-unit id="55f286a009d576b38e8e85ec7239710e5fc14790" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;install/2&lt;/code&gt; procedure differs somewhat from that of the ordinary &lt;code&gt;Install&lt;/code&gt; shell script. In fact, &lt;code&gt;create/1&lt;/code&gt; makes the release package as complete as possible, and leave to the &lt;code&gt;install/2&lt;/code&gt; procedure to finish by only considering location-dependent files.</source>
          <target state="translated">先前的 &lt;code&gt;install/2&lt;/code&gt; 过程与普通的 &lt;code&gt;Install&lt;/code&gt; shell脚本略有不同。实际上， &lt;code&gt;create/1&lt;/code&gt; 使发行包尽可能完整，而仅考虑位置相关文件来完成 &lt;code&gt;install/2&lt;/code&gt; 过程。</target>
        </trans-unit>
        <trans-unit id="c20b14e27b69d7bc82eb15ea5626b90581876483" translate="yes" xml:space="preserve">
          <source>The previous example can be simplified by using the &lt;code&gt;&lt;a href=&quot;ei#ei_x_format_wo_ver&quot;&gt;ei_x_format_wo_ver&lt;/a&gt;&lt;/code&gt; function to create an Erlang term:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;ei#ei_x_format_wo_ver&quot;&gt;ei_x_format_wo_ver&lt;/a&gt;&lt;/code&gt; 函数创建Erlang术语可以简化前面的示例：</target>
        </trans-unit>
        <trans-unit id="3fa312f724214bcc1cd80a76985d7a69b991d85b" translate="yes" xml:space="preserve">
          <source>The previous example can be simplified by using the &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; module to create an Erlang term:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; 模块创建Erlang术语可以简化前面的示例：</target>
        </trans-unit>
        <trans-unit id="b46669f7567ee67b00ce88c3207ede01b10c7f03" translate="yes" xml:space="preserve">
          <source>The previous example of state time-outs only work if the state machine stays in the same state during the time-out time. And event time-outs only work if no disturbing unrelated events occur.</source>
          <target state="translated">前面举例的状态超时只有在超时时间内状态机保持在同一状态下才有效。而事件超时只有在没有干扰的无关事件发生的情况下才有效。</target>
        </trans-unit>
        <trans-unit id="b3459bae934771664d1dcbf0310cab83038c641d" translate="yes" xml:space="preserve">
          <source>The previous list comprehension expression contains a number of syntactical elements:</source>
          <target state="translated">前面的列表理解表达式包含了一些语法元素。</target>
        </trans-unit>
        <trans-unit id="84ec95b9934bf0009efc315d92c2afbbfc37fa92" translate="yes" xml:space="preserve">
          <source>The previous sections describe how to get started with &lt;code&gt;Mnesia&lt;/code&gt; and how to build a &lt;code&gt;Mnesia&lt;/code&gt; database. This section describes the more advanced features available when building a distributed, fault-tolerant &lt;code&gt;Mnesia&lt;/code&gt; database. The following topics are included:</source>
          <target state="translated">前面的部分描述了如何开始使用 &lt;code&gt;Mnesia&lt;/code&gt; 以及如何构建 &lt;code&gt;Mnesia&lt;/code&gt; 数据库。本节介绍在构建分布式容错 &lt;code&gt;Mnesia&lt;/code&gt; 数据库时可用的更高级功能。包括以下主题：</target>
        </trans-unit>
        <trans-unit id="bb3f030405dcf222bd64e25ad1c880d277340fe4" translate="yes" xml:space="preserve">
          <source>The previous write and read example can be extended with encryption and decryption as follows:</source>
          <target state="translated">前面的写和读的例子可以用加密和解密扩展如下。</target>
        </trans-unit>
        <trans-unit id="57796ceed90f470b2305125d019084fa629b2ede" translate="yes" xml:space="preserve">
          <source>The primary Logger configuration is a map with the following keys:</source>
          <target state="translated">主要的记录仪配置是一个具有以下键的地图。</target>
        </trans-unit>
        <trans-unit id="ff1cf20a564ba3e279a69440c710bf978e373ae2" translate="yes" xml:space="preserve">
          <source>The primary log level can be overridden by a log level configured per module. This is to, for instance, allow more verbose logging from a specific part of the system.</source>
          <target state="translated">主日志级别可以被每个模块配置的日志级别所覆盖。例如,允许从系统的特定部分进行更详细的日志记录。</target>
        </trans-unit>
        <trans-unit id="d1ae98d9ae06c45e41cf5ff9b762c21068711a9b" translate="yes" xml:space="preserve">
          <source>The primary use case for this option is to bind sockets into &lt;code&gt;&lt;a href=&quot;http://www.kernel.org/doc/Documentation/networking/vrf.txt&quot;&gt;Linux VRF instances&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此选项的主要用例是将套接字绑定到 &lt;code&gt;&lt;a href=&quot;http://www.kernel.org/doc/Documentation/networking/vrf.txt&quot;&gt;Linux VRF instances&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11e6f9bf4b0c0ac23f2c434d8c992babdb65c4e0" translate="yes" xml:space="preserve">
          <source>The primitive Erlang boot sequence was terminated, most probably because the boot script has errors or cannot be read. This is usually a configuration error; the system can have been started with a faulty &lt;code&gt;-boot&lt;/code&gt; parameter or with a boot script from the wrong OTP version.</source>
          <target state="translated">原始的Erlang引导顺序已终止，很可能是因为引导脚本有错误或无法读取。这通常是配置错误；该系统可已经开始与一个错误的 &lt;code&gt;-boot&lt;/code&gt; 参数或从错误的OTP版本引导脚本。</target>
        </trans-unit>
        <trans-unit id="0f4b4edb0f46f3c079a1f4a56d0fa6ad3463effc" translate="yes" xml:space="preserve">
          <source>The printout consists of one paragraph per called function. The function &lt;strong&gt;marked&lt;/strong&gt; with '%' is the one the paragraph concerns - &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. Above the marked function are the &lt;strong&gt;calling&lt;/strong&gt; functions - those that has called the marked, and below are those &lt;strong&gt;called&lt;/strong&gt; by the marked function.</source>
          <target state="translated">每个调用函数的打印输出包含一个段落。&lt;strong&gt;标&lt;/strong&gt;有'％' 的函数是该段落所关注的函数 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 。标记函数的上方是&lt;strong&gt;调用&lt;/strong&gt;函数-已调用标记的函数，而下方是标记函数所&lt;strong&gt;调用&lt;/strong&gt;的函数。</target>
        </trans-unit>
        <trans-unit id="cb0cc2d12f7673987ac78181af36308d13b093fb" translate="yes" xml:space="preserve">
          <source>The printout continues:</source>
          <target state="translated">继续打印输出。</target>
        </trans-unit>
        <trans-unit id="88eb7754fad0268a64d4c07aa796eac3d3d2ab89" translate="yes" xml:space="preserve">
          <source>The printout starts with:</source>
          <target state="translated">打印出来的内容是:</target>
        </trans-unit>
        <trans-unit id="45f91a7c53ea68084b88cb17f900ef0b40205e6b" translate="yes" xml:space="preserve">
          <source>The printout to parse is typically the result of a &lt;code&gt;select&lt;/code&gt; command in SQL. The returned &lt;code&gt;Table&lt;/code&gt; is a list of tuples, where each tuple is a row in the table.</source>
          <target state="translated">要解析的打印输出通常是SQL中 &lt;code&gt;select&lt;/code&gt; 命令的结果。返回的 &lt;code&gt;Table&lt;/code&gt; 是一个元组列表，其中每个元组都是表中的一行。</target>
        </trans-unit>
        <trans-unit id="324a8be8e8a88abcf82aab2f92ee5692197fd525" translate="yes" xml:space="preserve">
          <source>The priority of the Erlang emulator. Default to the Windows default priority.</source>
          <target state="translated">Erlang模拟器的优先级。默认为Windows默认的优先级。</target>
        </trans-unit>
        <trans-unit id="a81c5cddc2f625b15d9cc5fb1d0bba28c6b2f977" translate="yes" xml:space="preserve">
          <source>The private &quot;queue like&quot; task data structure could have been an ordinary queue if it wasn't for the busy port functionality. When the port has flagged itself as busy, &lt;code&gt;command&lt;/code&gt; signals are not allowed to be delivered and need to be blocked. Other signals sent from the same sender following a &lt;code&gt;command&lt;/code&gt; signal that has been blocked also have to be blocked; otherwise, we would violate the ordering guarantee. At the same time, other signals that have no dependencies to blocked &lt;code&gt;command&lt;/code&gt; signals are expected to be delivered.</source>
          <target state="translated">如果专用的&amp;ldquo;队列状&amp;rdquo;任务数据结构不用于繁忙的端口功能，则它可能是一个普通队列。当端口将自己标记为忙时，则不允许传递 &lt;code&gt;command&lt;/code&gt; 信号，并且需要将其阻塞。从同一发送方发出的其他信号，在 &lt;code&gt;command&lt;/code&gt; 信号被阻塞后也必须被阻塞；否则，我们将违反订购保证。同时，预期将传递与被阻止的 &lt;code&gt;command&lt;/code&gt; 信号没有依赖性的其他信号。</target>
        </trans-unit>
        <trans-unit id="9484243e544c5f1274424b246682b09a4351581e" translate="yes" xml:space="preserve">
          <source>The private internet extensions OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">私有互联网扩展OID名称原子及其对应的值类型如下。</target>
        </trans-unit>
        <trans-unit id="3578adaa26da6e601dfec21f2beb5043ca19f9a3" translate="yes" xml:space="preserve">
          <source>The private key contains the public key.</source>
          <target state="translated">私钥包含公钥。</target>
        </trans-unit>
        <trans-unit id="fb7c14f7ed96915fedd1cf72c76ce0b4318ac44c" translate="yes" xml:space="preserve">
          <source>The problem is the clause with the variable &lt;code&gt;Int&lt;/code&gt;. As a variable can match anything, including the atoms &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, which the following clauses also match, the compiler must generate suboptimal code that executes as follows:</source>
          <target state="translated">问题是带有变量 &lt;code&gt;Int&lt;/code&gt; 的子句。作为一个变量可匹配任何东西，包括原子 &lt;code&gt;four&lt;/code&gt; ， &lt;code&gt;five&lt;/code&gt; ，和 &lt;code&gt;six&lt;/code&gt; ，其中下列条款也匹配，执行如下编译器必须产生次优的代码：</target>
        </trans-unit>
        <trans-unit id="97101ea56c3365ae0f09e70bee55a9ade66266a3" translate="yes" xml:space="preserve">
          <source>The problem of &lt;strong id=&quot;topsort&quot;&gt;topological sorting&lt;/strong&gt; is to find a total ordering of S that is a superset of the partial ordering. A digraph G = (V, E) is equivalent to a relation E on V (we neglect that the version of directed graphs provided by the &lt;code&gt;digraph&lt;/code&gt; module allows multiple edges between vertices). If the digraph has no cycles of length two or more, the reflexive and transitive closure of E is a partial ordering.</source>
          <target state="translated">&lt;strong id=&quot;topsort&quot;&gt;拓扑排序&lt;/strong&gt;的问题是找到S的总排序，该总排序是部分排序的超集。有向图G =（V，E）等于V上的关系E（我们忽略了 &lt;code&gt;digraph&lt;/code&gt; 模块提供的有向图版本允许顶点之间有多个边）。如果有向图不具有长度为两个或两个以上的周期，则E的自反和传递闭合是部分有序的。</target>
        </trans-unit>
        <trans-unit id="29c89e72c0ad3efc7037e90c1657130508496db6" translate="yes" xml:space="preserve">
          <source>The procedure above is different from how it worked prior to 19.0. Before 19.0 there was no configuration option, the behaviour was always very similar to how the &lt;code&gt;on_heap&lt;/code&gt; option is in 19.0.</source>
          <target state="translated">上面的过程与19.0之前的工作方式不同。在19.0之前没有配置选项，其行为始终与19.0中的 &lt;code&gt;on_heap&lt;/code&gt; 选项非常相似。</target>
        </trans-unit>
        <trans-unit id="1b755521f9bfc80493df667fabf5dd2e6bf86649" translate="yes" xml:space="preserve">
          <source>The procedure described uses WSL as a build environment. You run the bash shell in WSL and use the gnu make/configure/autoconf etc to do the build. The emulator C-source code is, however, mostly compiled with Microsoft Visual C++&amp;trade;, producing a native Windows binary. This is the same procedure as we use to build the pre-built binaries. Why we use VC++ and not gcc is explained further in the FAQ section.</source>
          <target state="translated">所描述的过程将WSL用作构建环境。您在WSL中运行bash shell，并使用gnu make / configure / autoconf等进行构建。但是，仿真器C源代码大部分是使用Microsoft Visual C ++&amp;trade;编译的，从而生成本机Windows二进制文件。这与我们用来构建预构建的二进制文件的过程相同。在&amp;ldquo;常见问题&amp;rdquo;部分中进一步说明了为什么使用VC ++而不使用gcc的原因。</target>
        </trans-unit>
        <trans-unit id="6dc36bb1f0c67349dd2ad95f241625aa11fedd24" translate="yes" xml:space="preserve">
          <source>The procedure described uses either Cygwin, MSYS or MSYS2 as a build environment. You run the bash shell in Cygwin/MSYS/MSYS2 and use the gnu make/configure/autoconf etc to do the build. The emulator C-source code is, however, mostly compiled with Microsoft Visual C++&amp;trade;, producing a native Windows binary. This is the same procedure as we use to build the pre-built binaries. Why we use VC++ and not gcc is explained further in the FAQ section.</source>
          <target state="translated">所描述的过程使用Cygwin，MSYS或MSYS2作为构建环境。您在Cygwin / MSYS / MSYS2中运行bash shell，并使用gnu make / configure / autoconf等进行构建。但是，仿真器C源代码大部分是使用Microsoft Visual C ++&amp;trade;编译的，从而生成本机Windows二进制文件。这与用于构建预构建的二进制文件的过程相同。在&amp;ldquo;常见问题&amp;rdquo;部分中进一步说明了为什么使用VC ++而不使用gcc的原因。</target>
        </trans-unit>
        <trans-unit id="3defe5ccf8f073a7bfba94a853f4b3e04c4fd936" translate="yes" xml:space="preserve">
          <source>The procedure for installing an embedded system is the same as for an ordinary system (see Installation Guide), except for the following:</source>
          <target state="translated">安装嵌入式系统的程序与安装普通系统的程序相同(见安装指南),但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="3e1ec300b173f8914d2686b10b0da9ca7aa25ede" translate="yes" xml:space="preserve">
          <source>The process &quot;pong&quot; now does:</source>
          <target state="translated">过程 &quot;庞 &quot;现在做。</target>
        </trans-unit>
        <trans-unit id="db27ebbde3aba8040f9a717035d37465555bb852" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;0.Item.0&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">跟踪进程 &lt;code&gt;&amp;lt;0.Item.0&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23867be26ea372bdca1cdb7f994ce5aa95efde29" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">跟踪过程 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8981f50685978b00cd49a2baa1c8ac07d3e68007" translate="yes" xml:space="preserve">
          <source>The process &lt;code&gt;Pid&lt;/code&gt; must be alive, local, and not already the owner of the table. The calling process must be the table owner.</source>
          <target state="translated">进程 &lt;code&gt;Pid&lt;/code&gt; 必须是活动的，本地的，并且还不是表的所有者。调用过程必须是表所有者。</target>
        </trans-unit>
        <trans-unit id="b7ce97685440137bac537d3a5eb324dcf9c30fc8" translate="yes" xml:space="preserve">
          <source>The process ID of the Erlang process to become owner of the new port. This process will be linked to the new port. You usually want to use &lt;code&gt;driver_caller(port)&lt;/code&gt; as &lt;code&gt;owner_pid&lt;/code&gt;.</source>
          <target state="translated">成为新端口所有者的Erlang进程的进程ID。此过程将链接到新端口。您通常希望将 &lt;code&gt;driver_caller(port)&lt;/code&gt; 用作 &lt;code&gt;owner_pid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="069991f41691da930cb8b00055cd75415a3bfbb4" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;exit/1&lt;/code&gt;</source>
          <target state="translated">该过程称为 &lt;code&gt;exit/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2c0d20578ead716abbff96344be128bf1b9a3f" translate="yes" xml:space="preserve">
          <source>The process called &lt;code&gt;throw/1&lt;/code&gt;</source>
          <target state="translated">该过程称为 &lt;code&gt;throw/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="181d7e73097c8d6559d2b5b87438e37ef9de3355" translate="yes" xml:space="preserve">
          <source>The process executing the call does not belong to any application.</source>
          <target state="translated">执行该调用的进程不属于任何应用程序。</target>
        </trans-unit>
        <trans-unit id="58e264eaf990dce8d191d11d9ad4693c8554a8a7" translate="yes" xml:space="preserve">
          <source>The process flag &lt;code&gt;message_queue_data&lt;/code&gt;, of the receiver process, controls the message allocating strategy of the sender process in step 2 and also how the message data is treated by the garbage collector.</source>
          <target state="translated">接收方进程的进程标志 &lt;code&gt;message_queue_data&lt;/code&gt; 在步骤2中控制发送方进程的消息分配策略，以及垃圾收集器如何处理消息数据。</target>
        </trans-unit>
        <trans-unit id="8f1ecb9f48b736f7cd2db1444bab09f031bc5fcb" translate="yes" xml:space="preserve">
          <source>The process has terminated.</source>
          <target state="translated">该进程已经终止。</target>
        </trans-unit>
        <trans-unit id="1e60b1f056e03500b54fc847d023aec3ec8683ca" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; does not execute old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程不会执行 &lt;code&gt;Module&lt;/code&gt; 的旧代码。</target>
        </trans-unit>
        <trans-unit id="efbf96e7df8ac572e485b865c501336d859faf3c" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; executes old code for &lt;code&gt;Module&lt;/code&gt;. That is, the current call of the process executes old code for this module, or the process has references to old code for this module, or the process contains funs that references old code for this module.</source>
          <target state="translated">由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程执行 &lt;code&gt;Module&lt;/code&gt; 的旧代码。也就是说，该过程的当前调用执行了该模块的旧代码，或者该过程引用了该模块的旧代码，或者该过程包含了一些乐趣，这些乐趣引用了该模块的旧代码。</target>
        </trans-unit>
        <trans-unit id="8fe4451cfd96b4642a3cd1e82d934d848d394bb5" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Pid&lt;/code&gt; has been garbage collected.</source>
          <target state="translated">由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程已被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="2c11a4446151542c2c9c338884f572b30ec36ffc" translate="yes" xml:space="preserve">
          <source>The process identified by &lt;code&gt;Suspendee&lt;/code&gt; is suspended unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;. If &lt;code&gt;unless_suspending&lt;/code&gt; is combined with option &lt;code&gt;asynchronous&lt;/code&gt;, a suspend request is sent unless the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt; or if a suspend request already has been sent and is in transit. If the calling process already is suspending &lt;code&gt;Suspendee&lt;/code&gt;, or if combined with option &lt;code&gt;asynchronous&lt;/code&gt; and a send request already is in transit, &lt;code&gt;false&lt;/code&gt; is returned and the suspend count on &lt;code&gt;Suspendee&lt;/code&gt; remains unchanged.</source>
          <target state="translated">除非调用进程已经暂停 &lt;code&gt;Suspendee&lt;/code&gt; ,否则 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程。如果 &lt;code&gt;unless_suspending&lt;/code&gt; 与选项 &lt;code&gt;asynchronous&lt;/code&gt; 组合，则除非调用进程已经正在挂起 &lt;code&gt;Suspendee&lt;/code&gt; ,或者如果已经发送了挂起请求并且正在传输中，则发送挂起请求。如果调用过程已经在挂起 &lt;code&gt;Suspendee&lt;/code&gt; ，或者与选项 &lt;code&gt;asynchronous&lt;/code&gt; 组合并且发送请求已经在传输中，则返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;Suspendee&lt;/code&gt; 的挂起计数保持不变。</target>
        </trans-unit>
        <trans-unit id="cc6dbdee5963a4c4de105af29cdc7452461b900b" translate="yes" xml:space="preserve">
          <source>The process identifier for the process that owns the port.</source>
          <target state="translated">拥有此端口的进程的标识符。</target>
        </trans-unit>
        <trans-unit id="82a4df785e628bbb31440878eae2c3ce1aa2f090" translate="yes" xml:space="preserve">
          <source>The process identifier of the controlling process for a connection.</source>
          <target state="translated">连接的控制进程的进程标识符。</target>
        </trans-unit>
        <trans-unit id="c1019f88201ff8eebe4c4c8f11ee6ecb8f045c63" translate="yes" xml:space="preserve">
          <source>The process identifier of the process that is currently executed by the scheduler. If there is such a process, this entry is followed by the &lt;strong&gt;State&lt;/strong&gt;, &lt;strong&gt;Internal State&lt;/strong&gt;, &lt;strong&gt;Program Counter&lt;/strong&gt;, and &lt;strong&gt;CP&lt;/strong&gt; of that same process. The entries are described in section &lt;code&gt;&lt;a href=&quot;#processes&quot;&gt;Process Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调度程序当前正在执行的进程的进程标识符。如果存在这样的过程，则此条目后跟该过程的&lt;strong&gt;State&lt;/strong&gt;，&lt;strong&gt;Internal State&lt;/strong&gt;，&lt;strong&gt;Program Counter&lt;/strong&gt;和&lt;strong&gt;CP&lt;/strong&gt;。这些条目在&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#processes&quot;&gt;Process Information&lt;/a&gt;&lt;/code&gt; 部分中进行了描述。</target>
        </trans-unit>
        <trans-unit id="deb011da943a6720eb915f7c73d873d81a032acd" translate="yes" xml:space="preserve">
          <source>The process identifier.</source>
          <target state="translated">流程标识符。</target>
        </trans-unit>
        <trans-unit id="27fe3ed1814a1292249730be37daf32c06d0df69" translate="yes" xml:space="preserve">
          <source>The process information returned by this function may be used to locate and terminate remaining processes after tests have finished executing. The function would typically by called from Common Test Hook functions.</source>
          <target state="translated">该函数返回的进程信息可用于在测试完成执行后定位并终止剩余进程。该函数通常由普通测试钩子函数调用。</target>
        </trans-unit>
        <trans-unit id="e6bedca78a3506c8b135dc2b8bd0767845069ac2" translate="yes" xml:space="preserve">
          <source>The process is also set to trap exits, which enables detection of failure of the external program:</source>
          <target state="translated">流程也设置为陷阱退出,这样可以检测外部程序的失败。</target>
        </trans-unit>
        <trans-unit id="667f772f31f497429c78d5ea973176a8eb647545" translate="yes" xml:space="preserve">
          <source>The process is awaken when a message is sent to it, and control resumes in &lt;code&gt;Module:Function&lt;/code&gt; with the arguments specified by &lt;code&gt;Args&lt;/code&gt; with the call stack emptied, meaning that the process terminates when that function returns. Thus &lt;code&gt;erlang:hibernate/3&lt;/code&gt; never returns to its caller.</source>
          <target state="translated">当向其发送消息时，该过程被唤醒，并且控制在 &lt;code&gt;Module:Function&lt;/code&gt; 中恢复，并使用由 &lt;code&gt;Args&lt;/code&gt; 指定的参数并清空了调用堆栈，这意味着该函数返回时该过程终止。因此， &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 从不返回其调用者。</target>
        </trans-unit>
        <trans-unit id="8ba834279970a7606bdcc555a88858fe5cdb6aca" translate="yes" xml:space="preserve">
          <source>The process is running.</source>
          <target state="translated">进程正在运行。</target>
        </trans-unit>
        <trans-unit id="bfc91c3fc885823bbc69fd5edf12fc9288324645" translate="yes" xml:space="preserve">
          <source>The process is stopped at a breakpoint.</source>
          <target state="translated">进程在断点处停止。</target>
        </trans-unit>
        <trans-unit id="4e77677e6bacc9af8fae16fce0e3ff20590fece9" translate="yes" xml:space="preserve">
          <source>The process is suspended, either by the BIF &lt;code&gt;erlang:suspend_process/1&lt;/code&gt; or because it tries to write to a busy port.</source>
          <target state="translated">该进程被BIF &lt;code&gt;erlang:suspend_process/1&lt;/code&gt; 挂起，或者因为它试图写入繁忙的端口而被挂起。</target>
        </trans-unit>
        <trans-unit id="ec639777c6fbd39eddc16455128329cd62f77aa3" translate="yes" xml:space="preserve">
          <source>The process is to wait indefinitely for a matching message; this is the same as not using a timeout. This can be useful for timeout values that are calculated at runtime.</source>
          <target state="translated">这个过程是无限期地等待一个匹配的消息,这和不使用超时是一样的。这对于在运行时计算的超时值很有用。</target>
        </trans-unit>
        <trans-unit id="f83208c2a966f339873e15e8fdadbc8eaec4e600" translate="yes" xml:space="preserve">
          <source>The process is waiting in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">该过程在 &lt;code&gt;receive&lt;/code&gt; 语句中等待。</target>
        </trans-unit>
        <trans-unit id="490d1a02b4671d2f440059a33d6b5bf46ed39b4c" translate="yes" xml:space="preserve">
          <source>The process locks are sorted after its class like all other locks. It is convenient to look at specific processes and ports as classes. We can do this by swapping class and class identifiers with &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt;.</source>
          <target state="translated">像所有其他锁一样，进程锁在其类之后排序。将特定的进程和端口视为类很方便。我们可以通过用 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 交换类和类标识符来实现。</target>
        </trans-unit>
        <trans-unit id="ab71454c03a7a40960af21879aaea3b714e94712" translate="yes" xml:space="preserve">
          <source>The process of abstracting out the common features of a number of different programs is called &lt;strong&gt;procedural abstraction&lt;/strong&gt;. Procedural abstraction can be used to write several different functions that have a similar structure, but differ in some minor detail. This is done as follows:</source>
          <target state="translated">抽象出许多不同程序的共同特征的&lt;strong&gt;过程&lt;/strong&gt;称为&lt;strong&gt;过程抽象&lt;/strong&gt;。过程抽象可用于编写具有相似结构但在一些次要细节上有所不同的几个不同函数。这样做如下：</target>
        </trans-unit>
        <trans-unit id="ead71597be31bdb70e88141c28f9f2a4406c239b" translate="yes" xml:space="preserve">
          <source>The process of handling an HTTP request involves several steps, such as:</source>
          <target state="translated">处理一个HTTP请求的过程包括几个步骤,如:。</target>
        </trans-unit>
        <trans-unit id="73248bb9e604234911f321cbc273914ed901fdd0" translate="yes" xml:space="preserve">
          <source>The process or port that the trace belongs to.</source>
          <target state="translated">跟踪所属的进程或端口。</target>
        </trans-unit>
        <trans-unit id="f33ec46395f0f62c1d01a1ea2da5eba9a23d0892" translate="yes" xml:space="preserve">
          <source>The process or port with the corresponding registered name is traced. The process or port may be a remote process (on another Erlang node). The node must be added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">跟踪具有相应注册名称的进程或端口。该进程或端口可以是远程进程（在另一个Erlang节点上）。必须使用 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 函数添加该节点。</target>
        </trans-unit>
        <trans-unit id="797b5a91a8e60a806f3452dece6f7cd3883f0a36" translate="yes" xml:space="preserve">
          <source>The process performing the registration will be monitored. Which means that if that process should die, all agents registered by that user process will be unregistered. All outstanding requests will be canceled.</source>
          <target state="translated">执行注册的进程将被监控。这意味着,如果该进程死亡,该用户进程注册的所有代理将被取消注册。所有未完成的请求将被取消。</target>
        </trans-unit>
        <trans-unit id="1fb0435cbc590f55163deae437b8266e597b2e46" translate="yes" xml:space="preserve">
          <source>The process priority of the emulator. Can be one of the following:</source>
          <target state="translated">仿真器的进程优先级。可以是以下之一:</target>
        </trans-unit>
        <trans-unit id="0f83be6ed83e2d30516ef664a8ddb67e08a991ab" translate="yes" xml:space="preserve">
          <source>The process table has for a very long time just been an array of pointers to process structures. Since process identifiers internally in the runtime system are 28-bit integers it is quite easy to map a process identifier to index into the array. The 28-bits were divided into two sets. The least significant set of bits was used as index into the array. The most significant set of bits was only used to be able to distinguish between a number of identifiers with which map to the same index in the array. As long as process table sizes of a power of two was used we had 2^28 unique process identifiers.</source>
          <target state="translated">在很长一段时间里,进程表只是一个指向进程结构的指针数组。由于运行时系统内部的进程标识符是28位的整数,所以将进程标识符映射到数组中索引是非常容易的。这28位被分为两组。最不重要的一组比特被用作进入数组的索引。最重要的一组比特只用来能够区分与之映射到数组中同一索引的若干标识符。只要使用2的幂的进程表大小,我们就有2^28个唯一的进程标识符。</target>
        </trans-unit>
        <trans-unit id="d5bdc0a53696670a36f0ba8faa9498a2fd917238" translate="yes" xml:space="preserve">
          <source>The process table is a mapping from process identifiers to process structure pointers. The process structure contains miscellaneous information about a process, as for example pointers to its heap, message queue, etc. When the runtime system needs to operate on a process, it looks up the process structure in the process table using the process identifier. An example of this is when passing a message to a process.</source>
          <target state="translated">进程表是进程标识符到进程结构指针的映射。进程结构包含了一个进程的杂项信息,例如它的堆、消息队列的指针等。当运行时系统需要对某个进程进行操作时,就会使用进程标识符在进程表中查找进程结构。例如向进程传递消息时,就是一个例子。</target>
        </trans-unit>
        <trans-unit id="22bf8418ad2d5fe3ae2a5b957f779e0b7ae5b331" translate="yes" xml:space="preserve">
          <source>The process table was the major problem to address since processes are much more frequently used than ports. The first implementation only implemented this for processes, but since the port table is very similar and very similar problems occur on the port table, the process table implementation was later generalized so that it could also be used implementing the port table. For simplicity I will only talk about the process table in the following text, but the same will apply to the port table unless otherwise stated.</source>
          <target state="translated">进程表是要解决的主要问题,因为进程的使用频率远远高于端口。最早的实现只针对进程实现,但由于进程表与端口表非常相似,而且端口表也会出现非常类似的问题,所以后来对进程表的实现进行了概括,使其也可以用于实现端口表。为了简单起见,我在下面的文字中只谈进程表,但除非另有说明,否则同样适用于端口表。</target>
        </trans-unit>
        <trans-unit id="cafc31dad66786ba70eea63bab9cea65a367d6c5" translate="yes" xml:space="preserve">
          <source>The process that applied the function received an exit signal and terminated due to this signal. The process terminated with exit reason &lt;code&gt;ExitReason&lt;/code&gt;.</source>
          <target state="translated">应用该功能的进程收到退出信号，并由于该信号而终止。进程因退出原因 &lt;code&gt;ExitReason&lt;/code&gt; 而终止。</target>
        </trans-unit>
        <trans-unit id="cd66a4360cd6cbde0a0ee9091b32df8224b27834" translate="yes" xml:space="preserve">
          <source>The process then terminates with reason &lt;code&gt;Reason&lt;/code&gt; for &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;{Reason,Stack}&lt;/code&gt; for the others.</source>
          <target state="translated">然后，该过程终止， &lt;code&gt;Reason&lt;/code&gt; 为其他 &lt;code&gt;exit/1&lt;/code&gt; 原因Reason或 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1fd3ae34693cf45eb0f6d67aaf690952ebb7fe3" translate="yes" xml:space="preserve">
          <source>The process trace token is set to the trace token from the message.</source>
          <target state="translated">进程跟踪标记被设置为来自消息的跟踪标记。</target>
        </trans-unit>
        <trans-unit id="6c783222fca1057432e796e94441d99e31c4d2ed" translate="yes" xml:space="preserve">
          <source>The process was currently running. If the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; was called, this was the process calling it.</source>
          <target state="translated">该进程当前正在运行。如果调用了BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; ，则是调用它的过程。</target>
        </trans-unit>
        <trans-unit id="82a3bf215f40b6a47f89483c4acc26d02d7b3f1c" translate="yes" xml:space="preserve">
          <source>The process was on its way to exit.</source>
          <target state="translated">流程在退出的路上。</target>
        </trans-unit>
        <trans-unit id="f141b2b54a0e0f93bea0340098e765164fced9dd" translate="yes" xml:space="preserve">
          <source>The process was scheduled to run but is currently not running (&quot;in the run queue&quot;).</source>
          <target state="translated">进程被安排运行,但目前没有运行(&quot;在运行队列中&quot;)。</target>
        </trans-unit>
        <trans-unit id="2810522b49b7629b84a03c4f78227a04b09abe5b" translate="yes" xml:space="preserve">
          <source>The process was waiting for something (in &lt;code&gt;receive&lt;/code&gt;).</source>
          <target state="translated">进程正在等待某些东西（在 &lt;code&gt;receive&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="27d3cd0b8797a36f6ea5cee6f120e89b7d3af94f" translate="yes" xml:space="preserve">
          <source>The processes created by the service can, as opposed to normal services, be &quot;killed&quot; with the task manager. Killing an emulator that is started by a service triggers the &quot;OnFail&quot; action specified for that service, which can be a reboot.</source>
          <target state="translated">与普通服务不同,服务创建的进程可以通过任务管理器 &quot;杀死&quot;。杀死一个由服务启动的仿真器会触发为该服务指定的 &quot;OnFail &quot;动作,可以是重启。</target>
        </trans-unit>
        <trans-unit id="4d0fdc2fce3dc489670b9aaebda13b3b3434f1aa" translate="yes" xml:space="preserve">
          <source>The profiling result is delivered as a term containing a sorted list of entries, one per module. Each module entry contains a sorted list of functions. The sorting order in both cases is of decreasing call count.</source>
          <target state="translated">剖析结果以术语的形式提供,其中包含一个按顺序排列的条目列表,每个模块一个。每个模块条目包含一个排序的函数列表。两种情况下的排序顺序都是按调用次数递减。</target>
        </trans-unit>
        <trans-unit id="6855e78a7f0fc77588d6aebc869c8f249ff318eb" translate="yes" xml:space="preserve">
          <source>The program Igor merges the source code of one or more Erlang modules into a single module, which can then replace the original set of modules. Igor is also able to rename a set of (possibly interdependent) modules, without joining them into a single module.</source>
          <target state="translated">Igor程序将一个或多个Erlang模块的源代码合并成一个模块,然后它可以取代原来的模块集。Igor还能够重命名一组(可能是相互依赖的)模块,而不将它们合并成一个模块。</target>
        </trans-unit>
        <trans-unit id="88adc107fba544367fb42d05838fc7551d7ac3a2" translate="yes" xml:space="preserve">
          <source>The program at the other side of a port is often a C program. To help the C programmer, the Erl_Interface library has been developed</source>
          <target state="translated">在端口的另一边的程序往往是一个C程序。为了帮助C语言程序员,我们开发了Erl_Interface库。</target>
        </trans-unit>
        <trans-unit id="a8195bc3c2103b70768bbe121c78ace9e38d4b38" translate="yes" xml:space="preserve">
          <source>The program at the other side of a port is often a C program. To help the C programmer, the Erl_Interface library has been developed, including the following five parts:</source>
          <target state="translated">在端口的另一端的程序往往是C程序。为了帮助C程序员,我们开发了Erl_Interface库,包括以下五个部分。</target>
        </trans-unit>
        <trans-unit id="9cb003c21eb552de99312a5e6d1ef17c2df06991" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that the function given as argument is truly synchronous and that no work continues after the function has returned a value.</source>
          <target state="translated">程序员必须保证作为参数给出的函数是真正的同步的,在函数返回值后,不能继续工作。</target>
        </trans-unit>
        <trans-unit id="af6123cc63973cd3b8af9f6ef3dfae37dfc06eae" translate="yes" xml:space="preserve">
          <source>The proper way to solve this problem is to use &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; as input:</source>
          <target state="translated">解决此问题的正确方法是使用 &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 作为输入：</target>
        </trans-unit>
        <trans-unit id="8563f5a39583bb15e30f23bba9afb2129b0dea31" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;proplist_file&lt;/code&gt; and &lt;code&gt;file&lt;/code&gt; are mutually exclusive. Also newer properties may not be supported as Apache-like options, this is a legacy feature.</source>
          <target state="translated">属性 &lt;code&gt;proplist_file&lt;/code&gt; 和 &lt;code&gt;file&lt;/code&gt; 是互斥的。同样，较新的属性可能不支持类似Apache的选项，这是一项旧功能。</target>
        </trans-unit>
        <trans-unit id="ec3820a1952a9bf6dd6589dfc08be32bf37ba810" translate="yes" xml:space="preserve">
          <source>The properties for a group are always printed in the top of the HTML log for &lt;code&gt;init_per_group/2&lt;/code&gt;. The total execution time for a group is included at the bottom of the log for &lt;code&gt;end_per_group/2&lt;/code&gt;.</source>
          <target state="translated">组的属性始终打印在 &lt;code&gt;init_per_group/2&lt;/code&gt; 的HTML日志的顶部。组的总执行时间包含在 &lt;code&gt;end_per_group/2&lt;/code&gt; 的日志底部。</target>
        </trans-unit>
        <trans-unit id="c0658e68a98aef88d6e658150857250258c9aa19" translate="yes" xml:space="preserve">
          <source>The properties for directories are as follows:</source>
          <target state="translated">目录的属性如下:</target>
        </trans-unit>
        <trans-unit id="c21d4cead30e9277ec44f6f7b10414a0626222c2" translate="yes" xml:space="preserve">
          <source>The properties for the security directories are as follows:</source>
          <target state="translated">安全目录的属性如下:</target>
        </trans-unit>
        <trans-unit id="e1311e2c285781d781a81d4ea6d0fb15f0a88ba6" translate="yes" xml:space="preserve">
          <source>The properties of the sessions will be exactly the same, except that when using &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, you may start multiple sessions over the same SSH connection. Each session is implemented as an SSH channel.</source>
          <target state="translated">会话的属性将完全相同，除了使用 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 时，您可以通过同一SSH连接启动多个会话。每个会话都实现为SSH通道。</target>
        </trans-unit>
        <trans-unit id="2db0406d66f21d5b36229de1553b67aafe2dce31" translate="yes" xml:space="preserve">
          <source>The property names represented by &lt;strong&gt;xx&lt;/strong&gt; above are limited to the Unicode script names, the general category properties, &quot;Any&quot;, which matches any character (including newline), and some special PCRE properties (described in the next section). Other Perl properties, such as &quot;InMusicalSymbols&quot;, are currently not supported by PCRE. Notice that \P{Any} does not match any characters and always causes a match failure.</source>
          <target state="translated">上面由&lt;strong&gt;xx&lt;/strong&gt;表示的属性名称仅限于Unicode脚本名称，与任何字符（包括换行符）匹配的常规类别属性&amp;ldquo; Any&amp;rdquo;以及某些特殊的PCRE属性（在下一节中介绍）。PCRE当前不支持其他Perl属性，例如&amp;ldquo; InMusicalSymbols&amp;rdquo;。注意\ P {Any}不匹配任何字符，并且总是导致匹配失败。</target>
        </trans-unit>
        <trans-unit id="36d9328c63c68bf7ed7f85c4daa5e1a7efa42d4e" translate="yes" xml:space="preserve">
          <source>The property tests are assumed to be in a subdirectory named &lt;code&gt;property_test&lt;/code&gt;. All found Erlang files in that directory are compiled with one of the macros &lt;code&gt;'EQC'&lt;/code&gt;, &lt;code&gt;'PROPER'&lt;/code&gt; or &lt;code&gt;'TRIQ'&lt;/code&gt; set, depending on which tool that is first found. This could make parts of the Erlang property tests code to be included or excluded with the macro directives &lt;code&gt;-ifdef(Macro).&lt;/code&gt; or &lt;code&gt;-ifndef(Macro).&lt;/code&gt;.</source>
          <target state="translated">假定属性测试位于名为 &lt;code&gt;property_test&lt;/code&gt; 的子目录中。该目录中所有找到的Erlang文件都将根据设置的宏 &lt;code&gt;'EQC'&lt;/code&gt; ， &lt;code&gt;'PROPER'&lt;/code&gt; 或 &lt;code&gt;'TRIQ'&lt;/code&gt; 之一进行编译，具体取决于首先找到的工具。这可能会使宏指令 &lt;code&gt;-ifdef(Macro).&lt;/code&gt; 包含或排除Erlang属性测试代码的一部分。或 &lt;code&gt;-ifndef(Macro).&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b66b0619fa655f54cf968828bbc7d5585eb77d5" translate="yes" xml:space="preserve">
          <source>The property tests are assumed to be in subdirectory &lt;code&gt;property_test&lt;/code&gt;.</source>
          <target state="translated">假定属性测试位于子目录 &lt;code&gt;property_test&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cecd3acaa022724f92df164ddb141a901162aee3" translate="yes" xml:space="preserve">
          <source>The protection of the dumped table (that is, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, or &lt;code&gt;public&lt;/code&gt;). A table loaded from the file gets the same protection.</source>
          <target state="translated">转储表的保护（即 &lt;code&gt;private&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; 或 &lt;code&gt;public&lt;/code&gt; ）。从文件加载的表获得相同的保护。</target>
        </trans-unit>
        <trans-unit id="ea098b4d622a71447129857377ff429cb6e98cf7" translate="yes" xml:space="preserve">
          <source>The protection of the table.</source>
          <target state="translated">表的保护。</target>
        </trans-unit>
        <trans-unit id="2d49c5ef78ce098f6cf07e79b387a293a3f5f71d" translate="yes" xml:space="preserve">
          <source>The protocol (messages sent to and received from the server) is also hidden. This is good programming practice and allows one to change the protocol without changing the code using the interface functions.</source>
          <target state="translated">协议(向服务器发送和接收的消息)也是隐藏的。这是很好的编程实践,允许人们在不改变代码的情况下使用接口函数改变协议。</target>
        </trans-unit>
        <trans-unit id="af664d953b1ecbbc88733b368b7ab068bb4ba398" translate="yes" xml:space="preserve">
          <source>The protocol engine uses callback modules to handle various things:</source>
          <target state="translated">协议引擎使用回调模块来处理各种事情。</target>
        </trans-unit>
        <trans-unit id="45aaae8278825f7a88f5605ecd8a29c30678b26a" translate="yes" xml:space="preserve">
          <source>The protocol handling processes in &lt;code&gt;Common Test&lt;/code&gt;, implemented by &lt;code&gt;ct_telnet&lt;/code&gt;, &lt;code&gt;ct_ssh&lt;/code&gt;, &lt;code&gt;ct_ftp&lt;/code&gt;, and so on, do verbose printing to the test case logs. This can be switched off with flag &lt;code&gt;-silent_connections&lt;/code&gt;:</source>
          <target state="translated">由 &lt;code&gt;ct_telnet&lt;/code&gt; ， &lt;code&gt;ct_ssh&lt;/code&gt; ， &lt;code&gt;ct_ftp&lt;/code&gt; 等实现的 &lt;code&gt;Common Test&lt;/code&gt; 中的协议处理过程对测试用例日志进行了详细的打印。可以使用 &lt;code&gt;-silent_connections&lt;/code&gt; 标志将其关闭：</target>
        </trans-unit>
        <trans-unit id="7483add893bc17e440cace13830412bb71cc8e83" translate="yes" xml:space="preserve">
          <source>The protocol stack does also handle things like automatic sending of acknowledgements, pending transactions, re-send of messages, supervision of connections etc.</source>
          <target state="translated">协议栈也确实能处理诸如自动发送确认、待处理事务、重新发送消息、监督连接等。</target>
        </trans-unit>
        <trans-unit id="dd90b6a6ff5727727e4daa87f469034b2b5161f8" translate="yes" xml:space="preserve">
          <source>The protocol type &lt;code&gt;http&lt;/code&gt; is only to be used for the first line when an &lt;code&gt;HttpRequest&lt;/code&gt; or an &lt;code&gt;HttpResponse&lt;/code&gt; is expected. The following calls are to use &lt;code&gt;httph&lt;/code&gt; to get &lt;code&gt;HttpHeader&lt;/code&gt;s until &lt;code&gt;http_eoh&lt;/code&gt; is returned, which marks the end of the headers and the beginning of any following message body.</source>
          <target state="translated">协议类型 &lt;code&gt;http&lt;/code&gt; 仅在需要 &lt;code&gt;HttpRequest&lt;/code&gt; 或 &lt;code&gt;HttpResponse&lt;/code&gt; 时才用于第一行。以下呼叫被使用 &lt;code&gt;httph&lt;/code&gt; 来获得 &lt;code&gt;HttpHeader&lt;/code&gt; s，至 &lt;code&gt;http_eoh&lt;/code&gt; 返回，这标志着头的结束和任何后续消息正文的开头。</target>
        </trans-unit>
        <trans-unit id="535cbad2526a219432d1c3150baaa80223145620" translate="yes" xml:space="preserve">
          <source>The protocol-independent architectural model on the network level is the well-known client-server model for management operations. This model is based on the client-server principle, where the manager (client) sends a request from a manager to an agent (server) when it accesses management information. The agent sends a reply back to the manager. There are two main differences to the normal client-server model:</source>
          <target state="translated">网络层面上的协议无关的架构模型是著名的管理操作的客户机-服务器模型。该模型基于客户机-服务器原理,管理者(客户机)在访问管理信息时,向代理(服务器)发出请求。代理商向管理者发送回复。与普通的客户机-服务器模式主要有两点不同。</target>
        </trans-unit>
        <trans-unit id="6278f7403b5a1e09fafad3942a14a20681bc5378" translate="yes" xml:space="preserve">
          <source>The proxy process is overload protected in the same way as described in section &lt;code&gt;&lt;a href=&quot;#overload_protection&quot;&gt;Protecting the Handler from Overload&lt;/a&gt;&lt;/code&gt;, but with the following default values:</source>
          <target state="translated">代理进程以与 &lt;code&gt;&lt;a href=&quot;#overload_protection&quot;&gt;Protecting the Handler from Overload&lt;/a&gt;&lt;/code&gt; 相同的方式进行过载保护，但具有以下默认值：</target>
        </trans-unit>
        <trans-unit id="280da6da197f645773e4e0fc4bff4fdf5cea49ad" translate="yes" xml:space="preserve">
          <source>The proxy uses &lt;code&gt; erlang:send_nosuspend/2&lt;/code&gt; when sending log events to a remote node. If the message could not be sent without suspending the sender, it is dropped. This is to avoid blocking the proxy process.</source>
          <target state="translated">将日志事件发送到远程节点时，代理使用 &lt;code&gt; erlang:send_nosuspend/2&lt;/code&gt; 。如果在不暂停发件人的情况下无法发送该消息，则将其丢弃。这是为了避免阻止代理进程。</target>
        </trans-unit>
        <trans-unit id="4ddde5fc28851b248cf413f0d35e2cb62b0a5e5a" translate="yes" xml:space="preserve">
          <source>The public key algorithm &lt;code&gt;'ssh-dss&lt;/code&gt; is regarded as insecure due to its usage of SHA1 and its short key length, and is therfore deprecated. It is not available by default from OTP-23.</source>
          <target state="translated">由于使用了SHA1并且密钥长度短，因此公钥算法 &lt;code&gt;'ssh-dss&lt;/code&gt; 被认为是不安全的，因此已弃用。默认情况下，它在OTP-23中不可用。</target>
        </trans-unit>
        <trans-unit id="d4e700c0527b003a9b781ae4afc277dbb491d581" translate="yes" xml:space="preserve">
          <source>The public key algorithm &lt;code&gt;'ssh-rsa&lt;/code&gt; is regarded as insecure due to its usage of SHA1, and is therfore deprecated. It will not be available by default from OTP-24.</source>
          <target state="translated">由于使用了SHA1，因此公钥算法 &lt;code&gt;'ssh-rsa&lt;/code&gt; 被认为是不安全的，因此已弃用。默认情况下，它在OTP-24中将不可用。</target>
        </trans-unit>
        <trans-unit id="b945eead3d07f17de2dbf5269f341d725ae12921" translate="yes" xml:space="preserve">
          <source>The public key handling can be customized by implementing the following behaviours from &lt;code&gt;ssh&lt;/code&gt;:</source>
          <target state="translated">可以通过实现 &lt;code&gt;ssh&lt;/code&gt; 的以下行为来定制公钥处理：</target>
        </trans-unit>
        <trans-unit id="36b59dc532efc1e5c7b32fe689f2d2e6632ebccc" translate="yes" xml:space="preserve">
          <source>The public-key algorithm OID name atoms are as follows:</source>
          <target state="translated">公钥算法OID名称原子如下。</target>
        </trans-unit>
        <trans-unit id="365a0a47c3126baf7de92ed7dc7c83a388adb2b3" translate="yes" xml:space="preserve">
          <source>The purpose is that &lt;strong&gt;beam_makeops&lt;/strong&gt; can verify that an instruction that does a garbage collection and has an &lt;code&gt;d&lt;/code&gt; operand uses the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; macro.</source>
          <target state="translated">目的是&lt;strong&gt;beam_makeops&lt;/strong&gt;可以验证执行垃圾回收并具有 &lt;code&gt;d&lt;/code&gt; 操作数的指令是否使用 &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="9a15b14b311d626350885eb389b70b1402e8566a" translate="yes" xml:space="preserve">
          <source>The purpose is to have a mechanism for a human to accept an otherwise faulty Certificate. In for example a web browser, you could get a question like</source>
          <target state="translated">其目的是为了建立一个机制,让人接受一个有问题的证书。例如,在网络浏览器中,你可以得到一个问题,如</target>
        </trans-unit>
        <trans-unit id="2da4fdf22d3807497c8bad4c3fa2b75601232aeb" translate="yes" xml:space="preserve">
          <source>The purpose is to inform the &lt;code&gt;receiver&lt;/code&gt; of the result of the delivery (was the notification acknowledged or not) for each target.</source>
          <target state="translated">目的是通知 &lt;code&gt;receiver&lt;/code&gt; 每个目标的交付结果（通知是否得到确认）。</target>
        </trans-unit>
        <trans-unit id="d3ba6f0037561095ae27788eb1fae4aa354ad82a" translate="yes" xml:space="preserve">
          <source>The purpose of notification filters is to allow for modification and/or suppression of a notification.</source>
          <target state="translated">通知过滤器的目的是允许修改和/或抑制通知。</target>
        </trans-unit>
        <trans-unit id="6e9701b065192ac8404e84b8b9c52feac07c04bf" translate="yes" xml:space="preserve">
          <source>The purpose of the Erlang ODBC application is to provide the programmer with an ODBC interface that has a Erlang/OTP touch and feel. So that the programmer may concentrate on solving his/her actual problem instead of struggling with pointers and memory allocation which is not very relevant for Erlang. This user guide will give you some information about technical issues and provide some examples of how to use the Erlang ODBC interface.</source>
          <target state="translated">Erlang ODBC应用程序的目的是为程序员提供一个具有Erlang/OTP触感的ODBC接口。这样程序员就可以集中精力解决他/她的实际问题,而不是纠结于指针和内存分配,因为这与Erlang关系不大。这篇用户指南将为你提供一些关于技术问题的信息,并提供一些如何使用Erlang ODBC接口的例子。</target>
        </trans-unit>
        <trans-unit id="d3a6d9bf1c2c25a8cd3bddca112e22cfd0ab28d5" translate="yes" xml:space="preserve">
          <source>The purpose of the OTP_Mibs application is to provide an SNMP management information base for Erlang nodes.</source>
          <target state="translated">OTP_Mibs应用的目的是为Erlang节点提供一个SNMP管理信息库。</target>
        </trans-unit>
        <trans-unit id="c81f6d62e3a96b842b134455d747a0f68a121780" translate="yes" xml:space="preserve">
          <source>The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt; characters_to_binary/3&lt;/a&gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">该功能的目的主要是将Unicode字符的组合转换为列表表示形式的纯Unicode字符串，以进行进一步处理。为了将数据写入外部实体，可以使用反向函数 &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt; characters_to_binary/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83e927dfda3dd650e3137512b144dd84450aebd9" translate="yes" xml:space="preserve">
          <source>The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt;characters_to_binary/3&lt;/a&gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">该功能的目的主要是将Unicode字符的组合转换为列表表示形式的纯Unicode字符串，以进行进一步处理。为了将数据写入外部实体，可以使用反向函数 &lt;code&gt;&lt;a href=&quot;#characters_to_binary-3&quot;&gt;characters_to_binary/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ff9c9b9dec703339d3bdb8b0c4fd2008e1ebebd" translate="yes" xml:space="preserve">
          <source>The purpose of the network interface filter is to allow for filtering of messages (accept or reject) receive and send. This is done on two levels:</source>
          <target state="translated">网络接口过滤器的目的是允许过滤接收和发送的消息(接受或拒绝)。这是在两个层面上完成的。</target>
        </trans-unit>
        <trans-unit id="380d75fe3dc7c1d9bcb891cc0287c70808132793" translate="yes" xml:space="preserve">
          <source>The purpose of the transaction sender is to accumulate transactions for a more efficient message sending. The transactions that are accumulated are transaction request and transaction ack. For transaction ack's the benefit is quite large, since the transactions are small and it is possible to have ranges (which means that transaction acks for transactions 1, 2, 3 and 4 can be sent as a range 1-4 in one transaction ack, instead of four separate transactions).</source>
          <target state="translated">事务发送者的目的是为了积累事务,以便更高效地发送消息。积累的事务是事务请求和事务ACK。对于交易ACK的好处是相当大的,因为交易量小,而且可以有范围(也就是说,交易1、2、3、4的交易ACK可以作为1-4的范围在一个交易ACK中发送,而不是四个单独的交易)。</target>
        </trans-unit>
        <trans-unit id="285eddd7bec05e75e8a6d971be6aadc6efc04add" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to do a minimal decode of Megaco message. A successfull result is a &lt;code&gt;'MegacoMessage'&lt;/code&gt; in which only version and mid has been initiated. This function is used by the megaco_messenger module when the &lt;code&gt;decode_message/3&lt;/code&gt; function fails to figure out the mid (the actual sender) of the message.</source>
          <target state="translated">此功能的目的是对Megaco消息进行最少的解码。成功的结果是 &lt;code&gt;'MegacoMessage'&lt;/code&gt; ，其中仅启动了版本和中间版本。当 &lt;code&gt;decode_message/3&lt;/code&gt; 函数无法确定消息的中间（实际发送者）时，megaco_messenger模块将使用此函数。</target>
        </trans-unit>
        <trans-unit id="8c094a70f3fb457644d9fe5a09333364897998e8" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to generate the usm- related security data needed for usm processing in the agent. Specifically, updating the usmUserTable.</source>
          <target state="translated">这个函数的目的是生成代理中usm处理所需的usm相关安全数据。具体来说,就是更新usmUserTable。</target>
        </trans-unit>
        <trans-unit id="cb733abfc16c52599ffacd6192ef985dac677dcf" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to discuss the different hardening options available, as a guide to the reader. Configuration in general is described in the &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt; chapter.</source>
          <target state="translated">本指南的目的是讨论可用的不同强化选项，以作为读者的指南。常规 &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt; 中的配置&amp;rdquo;一章中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="e4997df3d063972a7e3b9575b1cf9377dc21bae3" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to simplify SNMP configuration for the test case writer. Many test cases can use default values for common operations and then no SNMP configuration files need to be supplied. When it is necessary to change particular configuration parameters, a subset of the relevant SNMP configuration files can be passed to &lt;code&gt;ct_snmp&lt;/code&gt; by &lt;code&gt;Common Test&lt;/code&gt; configuration files. For more specialized configuration parameters, a simple SNMP configuration file can be placed in the test suite data directory. To simplify the test suite, &lt;code&gt;Common Test&lt;/code&gt; keeps track of some of the SNMP manager information. This way the test suite does not have to handle as many input parameters as if it had to interface wthe OTP SNMP manager directly.</source>
          <target state="translated">该模块的目的是简化测试用例编写器的SNMP配置。许多测试用例可以将默认值用于常见操作，因此不需要提供SNMP配置文件。当需要改变特定的配置参数，相关的SNMP配置文件的一个子集可以传递给 &lt;code&gt;ct_snmp&lt;/code&gt; 通过 &lt;code&gt;Common Test&lt;/code&gt; 配置文件。对于更专业的配置参数，可以在测试套件数据目录中放置一个简单的SNMP配置文件。为了简化测试套件， &lt;code&gt;Common Test&lt;/code&gt; 会跟踪一些SNMP管理器信息。这样，测试套件不必处理必须直接与OTP SNMP管理器接口的输入参数。</target>
        </trans-unit>
        <trans-unit id="d919b258d0197ec8d853aab267758bf87f5d968e" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to increase performance by reducing the number of operating system calls. Thus, the &lt;code&gt;write/2&lt;/code&gt; calls must be for sizes significantly less than &lt;code&gt;Size&lt;/code&gt;, and not interspersed by too many other file operations.</source>
          <target state="translated">此选项的目的是通过减少操作系统调用的数量来提高性能。因此， &lt;code&gt;write/2&lt;/code&gt; 调用的大小必须大大小于 &lt;code&gt;Size&lt;/code&gt; ，并且不能被其他文件操作过多地散布。</target>
        </trans-unit>
        <trans-unit id="6764da434257370babfd601803893f5ca699a25d" translate="yes" xml:space="preserve">
          <source>The purpose of this section is to let the newcomer get started in quickly writing and executing some first simple tests with a &quot;learning by example&quot; approach. Most explanations are left for later sections. If you are not much into &quot;learning by example&quot; and prefer more technical details, go ahead and skip to the next section.</source>
          <target state="translated">本节的目的是让新手以 &quot;举一反三 &quot;的方式快速开始编写和执行一些最初的简单测试。大部分的解释都会留到后面的章节。如果你不太喜欢 &quot;举一反三&quot;,喜欢更多的技术细节,可以继续跳到下一节。</target>
        </trans-unit>
        <trans-unit id="5baba518ef35fe89fecc8d2eabb40055ac16675f" translate="yes" xml:space="preserve">
          <source>The purpose of this tutorial is to describe different interoperability mechanisms that can be used when integrating a program written in Erlang with a program written in another programming language, from the Erlang programmer's perspective.</source>
          <target state="translated">本教程的目的是从Erlang程序员的角度出发,介绍在将一个用Erlang编写的程序与另一种编程语言编写的程序集成时,可以使用的不同的互操作机制。</target>
        </trans-unit>
        <trans-unit id="ad7e63be85ec6284886f671e4aac3786bf5f89cd" translate="yes" xml:space="preserve">
          <source>The purpose of this user guide is to introduce you to the Erlang mode for Emacs and gives some relevant background information of the functions and features. See also &lt;code&gt;&lt;a href=&quot;erlang.el&quot;&gt;Erlang mode reference manual&lt;/a&gt;&lt;/code&gt; The purpose of the Erlang mode itself is to facilitate the developing process for the Erlang programmer.</source>
          <target state="translated">本用户指南的目的是向您介绍Emacs的Erlang模式，并提供一些有关功能和特性的背景信息。另请参见 &lt;code&gt;&lt;a href=&quot;erlang.el&quot;&gt;Erlang mode reference manual&lt;/a&gt;&lt;/code&gt; 。Erlang模式本身的目的是简化Erlang程序员的开发过程。</target>
        </trans-unit>
        <trans-unit id="2da86e2ca4dd48a3f84de358ea8343a9387be39e" translate="yes" xml:space="preserve">
          <source>The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present. This can be useful for subpatterns that are referenced as subroutines from elsewhere in the pattern (but see also section &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt; Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt;). Items other than subpatterns that have a {0} quantifier are omitted from the compiled pattern.</source>
          <target state="translated">允许使用量词{0}，从而使表达式的行为就像没有上一项和量词一样。这对于从模式中其他位置作为子例程引用的子模式很有用（但另请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt; Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt; 一节）。已编译模式中将省略具有{0}量词的子模式以外的项目。</target>
        </trans-unit>
        <trans-unit id="ea3039623e684f7c81037387c6d7f5eb72507985" translate="yes" xml:space="preserve">
          <source>The quantifier {0} is permitted, causing the expression to behave as if the previous item and the quantifier were not present. This can be useful for subpatterns that are referenced as subroutines from elsewhere in the pattern (but see also section &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt;Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt;). Items other than subpatterns that have a {0} quantifier are omitted from the compiled pattern.</source>
          <target state="translated">允许使用量词{0}，从而使表达式的行为就像没有上一项和量词一样。这对于从模式中其他位置作为子例程引用的子模式很有用（但另请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#defining_subpatterns&quot;&gt;Defining Subpatterns for Use by Reference Only&lt;/a&gt;&lt;/code&gt; 一节）。已编译模式中将省略具有{0}量词的子模式以外的项目。</target>
        </trans-unit>
        <trans-unit id="9ffdab0f26f651e47a43589852883c8b5ecab0d9" translate="yes" xml:space="preserve">
          <source>The query asks for the restriction of external calls except the unresolved calls to calls to functions that are externally used but neither exported nor built-in functions (the &lt;code&gt;||&lt;/code&gt; operator restricts the used functions while the &lt;code&gt;|&lt;/code&gt; operator restricts the calling functions). The &lt;code&gt;-&lt;/code&gt; operator returns the difference of two sets, and the &lt;code&gt;+&lt;/code&gt; operator to be used below returns the union of two sets.</source>
          <target state="translated">查询请求除了悬而未决的调用函数调用时，被外部使用，但既不出口也不内置功能（外部呼叫限制 &lt;code&gt;||&lt;/code&gt; 运营商限制使用的功能，而 &lt;code&gt;|&lt;/code&gt; 运营商限制了通话功能）。本 &lt;code&gt;-&lt;/code&gt; 运算符返回两个集合的差别，而 &lt;code&gt;+&lt;/code&gt; 运算符下面的回报可以使用两个集合的联合。</target>
        </trans-unit>
        <trans-unit id="f690a75130a74f61a6b149376be5c663bfe1f1d3" translate="yes" xml:space="preserve">
          <source>The queue can be manipulated from any threads if a port data lock is used. For more information, see &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;ErlDrvPDL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用端口数据锁，则可以从任何线程操纵队列。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;ErlDrvPDL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fca3c136aa3b7db81fe20cdb9588464345ea02d4" translate="yes" xml:space="preserve">
          <source>The ratio between the number of collisions and the number of tries (acquisitions) in percentage.</source>
          <target state="translated">碰撞次数与尝试(获取)次数之比,以百分比表示。</target>
        </trans-unit>
        <trans-unit id="4acf74b094574ab9f01234943d55b709616438b0" translate="yes" xml:space="preserve">
          <source>The raw data pointed to by &lt;code&gt;data&lt;/code&gt; is only mutable after a call to &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt; enif_alloc_binary&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt; enif_realloc_binary&lt;/a&gt;&lt;/code&gt;. All other functions that operate on a binary leave the data as read-only. A mutable binary must in the end either be freed with &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt; enif_release_binary&lt;/a&gt;&lt;/code&gt; or made read-only by transferring it to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. However, it does not have to occur in the same NIF call. Read-only binaries do not have to be released.</source>
          <target state="translated">原始数据指向 &lt;code&gt;data&lt;/code&gt; 是在通话结束后仅可变 &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt; enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt; enif_realloc_binary&lt;/a&gt;&lt;/code&gt; 。在二进制文件上运行的所有其他函数会将数据保留为只读状态。最后，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt; enif_release_binary&lt;/a&gt;&lt;/code&gt; 释放可变的二进制文件，或者使用enif_make_binary将可变的二进制文件转移到Erlang术语中以 &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt; 成为只读文件。但是，它不必在同一NIF调用中发生。只读二进制文件不必释放。</target>
        </trans-unit>
        <trans-unit id="44affb61a9f1b3e79f7f910ffd11f6983e2b7acd" translate="yes" xml:space="preserve">
          <source>The raw data pointed to by &lt;code&gt;data&lt;/code&gt; is only mutable after a call to &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt;enif_realloc_binary&lt;/a&gt;&lt;/code&gt;. All other functions that operate on a binary leave the data as read-only. A mutable binary must in the end either be freed with &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; or made read-only by transferring it to an Erlang term with &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt;. However, it does not have to occur in the same NIF call. Read-only binaries do not have to be released.</source>
          <target state="translated">原始数据指向 &lt;code&gt;data&lt;/code&gt; 是在通话结束后仅可变 &lt;code&gt;&lt;a href=&quot;#enif_alloc_binary&quot;&gt;enif_alloc_binary&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#enif_realloc_binary&quot;&gt;enif_realloc_binary&lt;/a&gt;&lt;/code&gt; 。在二进制文件上运行的所有其他函数会将数据保留为只读状态。最后，必须使用 &lt;code&gt;&lt;a href=&quot;#enif_release_binary&quot;&gt;enif_release_binary&lt;/a&gt;&lt;/code&gt; 释放可变的二进制文件，或者使用enif_make_binary将可变的二进制文件转移到Erlang术语中以 &lt;code&gt;&lt;a href=&quot;#enif_make_binary&quot;&gt;enif_make_binary&lt;/a&gt;&lt;/code&gt; 成为只读文件。但是，它不必在同一NIF调用中发生。只读二进制文件不必释放。</target>
        </trans-unit>
        <trans-unit id="e697470bc64df4548085b65b4119eaa00152f6fc" translate="yes" xml:space="preserve">
          <source>The raw memory information can be decoded by the Crashdump Viewer tool. You can then see the stack dump, the message queue (if any), and the dictionary (if any).</source>
          <target state="translated">原始的内存信息可以通过Crashdump Viewer工具进行解码,然后你可以看到堆栈转储、消息队列(如果有的话)和字典(如果有的话)。然后你可以看到堆栈转储,消息队列(如果有的话)和字典(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="94b9348a6665f910941aa4666d77803d6bab3e84" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;ErrorDescription&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">读取操作失败，参数 &lt;code&gt;ErrorDescription&lt;/code&gt; 给出了有关错误的提示。</target>
        </trans-unit>
        <trans-unit id="7bbc097f89bd9fc9542bcc569f782bd621e86844" translate="yes" xml:space="preserve">
          <source>The read operation failed and parameter &lt;code&gt;What&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">读取操作失败，参数&amp;ldquo; &lt;code&gt;What&lt;/code&gt; 给出有关错误的提示。</target>
        </trans-unit>
        <trans-unit id="fb6a39bb3dee1cf5c8904fe1074aac9c463a49da" translate="yes" xml:space="preserve">
          <source>The read was successful and &lt;code&gt;Terms&lt;/code&gt; is the list of successfully matched and read items.</source>
          <target state="translated">读取成功，&amp;ldquo; &lt;code&gt;Terms&lt;/code&gt; 是成功匹配和读取项目的列表。</target>
        </trans-unit>
        <trans-unit id="6f08a4c5b73c451cc9475ac59de38ea9ab782b24" translate="yes" xml:space="preserve">
          <source>The reader is referred to &lt;code&gt; the erl_interface users guide&lt;/code&gt; for information about how to create C nodes.</source>
          <target state="translated">读者可以参考 &lt;code&gt; the erl_interface users guide&lt;/code&gt; 以获取有关如何创建C节点的信息。</target>
        </trans-unit>
        <trans-unit id="dcfa32e23c0ed6b07d119f5cbe4a63799ba2a7c0" translate="yes" xml:space="preserve">
          <source>The reader of this section is assumed to be familiar with the following:</source>
          <target state="translated">假设本节读者熟悉以下内容:</target>
        </trans-unit>
        <trans-unit id="ba2a82a53accd93542c2130c8adecd6ee219c0ca" translate="yes" xml:space="preserve">
          <source>The reading failed and &lt;code&gt;FreadError&lt;/code&gt; gives a hint about the error.</source>
          <target state="translated">读取失败， &lt;code&gt;FreadError&lt;/code&gt; 提示有关错误。</target>
        </trans-unit>
        <trans-unit id="daa863f5699aef2a6313b5f617a1c72b21feead3" translate="yes" xml:space="preserve">
          <source>The real difference is instead in system characteristics, which is best shown with the mstone1 test.</source>
          <target state="translated">真正的区别反而是在系统特性上,这一点用mstone1测试最能体现。</target>
        </trans-unit>
        <trans-unit id="3736a506f2b70d1aaccee3608b548c52a06a0858" translate="yes" xml:space="preserve">
          <source>The reason for applying all &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; in level order, is to enable the user to add an algorithm that has been removed from the default set without code changes, only by adding an option in a config file. This can be used to interoperate with legacy systems that still uses algorithms no longer considered secure enough to be supported by default.</source>
          <target state="translated">按级别顺序应用所有 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 的原因是，使用户能够仅通过在配置文件中添加选项来添加已从默认集中删除的算法而无需更改代码。这可用于与仍使用算法的旧系统进行互操作，这些算法不再被认为具有足够的安全性，默认情况下不受支持。</target>
        </trans-unit>
        <trans-unit id="45e718b5cc8c016eeb0b83bab7279b93e9d7f448" translate="yes" xml:space="preserve">
          <source>The reason for having this limit is that if the cache is large, the GC can potentially take a long time, during which the agent is locked.</source>
          <target state="translated">有这个限制的原因是,如果缓存很大,GC有可能需要很长的时间,在这期间,代理被锁定。</target>
        </trans-unit>
        <trans-unit id="188404504e5ffcfc4e22d678f33dc7b1dabcdeee" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of a compiled match specification is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="translated">不对编译后的匹配规范进行外部表示的原因是性能问题。在未来的版本中,它可能会发生变化,而这个接口是为了向后兼容而保留的。</target>
        </trans-unit>
        <trans-unit id="d12e3451eede4d21837264efccb2d76d8bb6ff89" translate="yes" xml:space="preserve">
          <source>The reason for not having an external representation of compiled match specifications is performance. It can be subject to change in future releases, while this interface remains for backward compatibility.</source>
          <target state="translated">不对编译后的匹配规格进行外部表示的原因是性能问题。在未来的版本中可能会发生变化,而这个接口是为了向后兼容而保留的。</target>
        </trans-unit>
        <trans-unit id="62037923291a9bc215c53f9d64f569edf7ad5f37" translate="yes" xml:space="preserve">
          <source>The reason for the dump is shown in the beginning of the file as:</source>
          <target state="translated">转储的原因在文件的开头显示为:。</target>
        </trans-unit>
        <trans-unit id="2faab1fcd118d3b3332e3465dbb0be228ca6f80a" translate="yes" xml:space="preserve">
          <source>The reason for the latter is presumably interoperability: allowing arbitrary AVPs setting the M-bit in a command makes its interpretation implementation-dependent, since there's no guarantee that all implementations will understand the same set of arbitrary AVPs in the context of a given command. However, interpreting &lt;code&gt;AVP&lt;/code&gt; in a command grammar as any AVP, regardless of M-bit, renders 1.3.4 meaningless, since the receiver can simply ignore any AVP it thinks isn't relevant, regardless of the sender's intent.</source>
          <target state="translated">后者的原因大概是互操作性：允许在命令中设置M位的任意AVP使其解释依赖于实现，因为不能保证所有实现都将在给定命令的上下文中理解同一组任意AVP。然而，解释 &lt;code&gt;AVP&lt;/code&gt; 在命令语法任何AVP，无论M-位，呈现1.3.4意义的，因为接收器可以简单地忽略它认为是不相关的任何AVP，无论是发送者的意图。</target>
        </trans-unit>
        <trans-unit id="670dee16e7dda71243b144db55242f7df8863db8" translate="yes" xml:space="preserve">
          <source>The reason for this division of the interfaces into compile-time and runtime is that only runtime modules (&lt;code&gt;asn1rt*&lt;/code&gt;) need to be loaded in an embedded system.</source>
          <target state="translated">将接口划分为编译时和运行时的原因是，嵌入式系统中仅需要加载运行时模块（ &lt;code&gt;asn1rt*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aca13d817801ececaa8dfc48f08607f3b1cd91a9" translate="yes" xml:space="preserve">
          <source>The reason for this function is that continuation terms contain compiled match specifications and may therefore be invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent &lt;code&gt;select/1&lt;/code&gt; calls even though it has been stored on disk or on another node.</source>
          <target state="translated">使用此功能的原因是，连续术语包含已编译的匹配规范，因此如果转换为外部术语格式，则可能无效。假定原始匹配规范保持不变，则可以恢复该连续性，这意味着即使该连续性规范已存储在磁盘或其他节点上，也可以再次用于后续的 &lt;code&gt;select/1&lt;/code&gt; 调用中。</target>
        </trans-unit>
        <trans-unit id="78fc68d51d1cbc8283fa7ece8361aa9511ea81ac" translate="yes" xml:space="preserve">
          <source>The reason for this function is that continuation terms contain compiled match specifications and therefore are invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent &lt;code&gt;select/1&lt;/code&gt; calls even though it has been stored on disk or on another node.</source>
          <target state="translated">使用此功能的原因是，连续术语包含已编译的匹配规范，因此如果转换为外部术语格式，则它们将无效。假定原始匹配规范保持不变，则可以恢复该连续性，这意味着即使该连续性规范已存储在磁盘或另一个节点上，也可以再次用于后续的 &lt;code&gt;select/1&lt;/code&gt; 调用中。</target>
        </trans-unit>
        <trans-unit id="47b6fcd018fd712f3befd5bbeb2b9b0c016e80db" translate="yes" xml:space="preserve">
          <source>The reason for using two reference counters is that we need to know that the reference counter eventually will reach zero. If we only used one reference counter it would potentially be held above zero for ever by different unmanaged threads.</source>
          <target state="translated">使用两个参考计数器的原因是,我们需要知道参考计数器最终会达到零。如果我们只使用一个参考计数器,它就有可能被不同的非管理线程永远保持在零以上。</target>
        </trans-unit>
        <trans-unit id="7e66b56334bd4302b0b55eee5e555ae3f6f42859" translate="yes" xml:space="preserve">
          <source>The reason is that a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; contains a direct pointer to the binary data.</source>
          <target state="translated">原因是 &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; 包含指向二进制数据的直接指针。</target>
        </trans-unit>
        <trans-unit id="fa3e28310c9f5068c3bc594e80fb7f8131e7f277" translate="yes" xml:space="preserve">
          <source>The reason we get a deadlock in the first example is because when TAB is pressed to expand the function name, the group leader (which handles character input) calls &lt;code&gt;mymod:module_info()&lt;/code&gt;. This generates a trace message which, in turn, causes the tracer process to send an IO request to the group leader (by calling &lt;code&gt;io:format/2&lt;/code&gt;). We end up in a deadlock.</source>
          <target state="translated">在第一个示例中出现死锁的原因是，当按下TAB扩展功能名称时，组长（处理字符输入）调用 &lt;code&gt;mymod:module_info()&lt;/code&gt; 。这将生成一个跟踪消息，该跟踪消息继而导致跟踪程序向组长发送IO请求（通过调用 &lt;code&gt;io:format/2&lt;/code&gt; ）。我们最终陷入僵局。</target>
        </trans-unit>
        <trans-unit id="a6d7f5df781104c5964a98f48e369e9418cc7b6c" translate="yes" xml:space="preserve">
          <source>The reason why its possible to set a limit, is that if the cache is large, the GC can potentially take a long time, during which the agent is &quot;busy&quot;. &lt;strong&gt;But&lt;/strong&gt; on a heavily loaded system, we also risk not removing enough elements in the cache, instead causing it to grow over time. This is the reason the default value is &lt;code&gt;infinity&lt;/code&gt;, which will ensure that &lt;strong&gt;all&lt;/strong&gt; candidates are removed as soon as possible.</source>
          <target state="translated">之所以可以设置限制，是因为如果缓存很大，GC可能会花费很长时间，在此期间代理&amp;ldquo;忙&amp;rdquo;。&lt;strong&gt;但是&lt;/strong&gt;在负载很重的系统上，我们也冒着风险不要删除高速缓存中足够的元素，而是导致其随着时间增长而增加的风险。这就是默认值为 &lt;code&gt;infinity&lt;/code&gt; 的原因，它将确保尽快删除&lt;strong&gt;所有&lt;/strong&gt;候选对象。</target>
        </trans-unit>
        <trans-unit id="d334c8815a940e1117cd6bf97ab09bf24cf15d4d" translate="yes" xml:space="preserve">
          <source>The recognized allocators are listed in &lt;code&gt;erts_alloc(3)&lt;/code&gt;. Information about super carriers can be obtained from ERTS 8.0 with &lt;code&gt;{allocator, erts_mmap}&lt;/code&gt; or from ERTS 5.10.4; the returned list when calling with &lt;code&gt;{allocator, mseg_alloc}&lt;/code&gt; also includes an &lt;code&gt;{erts_mmap, _}&lt;/code&gt; tuple as one element in the list.</source>
          <target state="translated">公认的分配器在 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 中列出。可以从带有 &lt;code&gt;{allocator, erts_mmap}&lt;/code&gt; ERTS 8.0 或从ERTS 5.10.4 获得有关超级载波的信息。使用 &lt;code&gt;{allocator, mseg_alloc}&lt;/code&gt; 调用时返回的列表还包括一个 &lt;code&gt;{erts_mmap, _}&lt;/code&gt; 元组作为列表中的一个元素。</target>
        </trans-unit>
        <trans-unit id="1601ceca58dc5bb418d4d058642b8127306f81a6" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;file_info&lt;/code&gt; contains the following fields:</source>
          <target state="translated">记录 &lt;code&gt;file_info&lt;/code&gt; 包含以下字段：</target>
        </trans-unit>
        <trans-unit id="90fa624e6ef711e6538891034b680bc3cf375ce0" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;megaco_incr_timer&lt;/code&gt; contains the following fields:</source>
          <target state="translated">记录 &lt;code&gt;megaco_incr_timer&lt;/code&gt; 包含以下字段：</target>
        </trans-unit>
        <trans-unit id="fd91c53b0842e666e7eac373490635f53ee82f94" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;snmpa_notification_delivery_info&lt;/code&gt; contains the following fields:</source>
          <target state="translated">记录 &lt;code&gt;snmpa_notification_delivery_info&lt;/code&gt; 包含以下字段：</target>
        </trans-unit>
        <trans-unit id="5ef7e07ae45347add7e7787bb739a3aea7c0c97a" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;xmlAttribute&lt;/code&gt; holds the name and value of an attribute in the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. All attributes of an element is a list of xmlAttribute in the field &lt;code&gt;attributes&lt;/code&gt; of the xmlElement record.</source>
          <target state="translated">记录 &lt;code&gt;xmlAttribute&lt;/code&gt; 在名称和值字段中保存属性的 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 。元素的所有属性都是xmlElement记录的字段 &lt;code&gt;attributes&lt;/code&gt; 中的xmlAttribute列表。</target>
        </trans-unit>
        <trans-unit id="18b3b71ec5bfcc1ff63cbc72d59db895c56c0f72" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_comment&lt;/code&gt; only contains the archive comment for a zip archive.</source>
          <target state="translated">记录 &lt;code&gt;zip_comment&lt;/code&gt; 仅包含zip存档的存档注释。</target>
        </trans-unit>
        <trans-unit id="857d4f5792009846db2a99430f060ca57c895a3d" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;zip_file&lt;/code&gt; contains the following fields:</source>
          <target state="translated">记录 &lt;code&gt;zip_file&lt;/code&gt; 包含以下字段：</target>
        </trans-unit>
        <trans-unit id="72cb006aafe2a35c580dddc00f0e1af4643c65e2" translate="yes" xml:space="preserve">
          <source>The record &lt;code&gt;{boss, klacke, bjarne}&lt;/code&gt; can also be inserted. This record contains an implicit reference to another employee that does not yet exist in the database. &lt;code&gt;Mnesia&lt;/code&gt; does not enforce this.</source>
          <target state="translated">记录 &lt;code&gt;{boss, klacke, bjarne}&lt;/code&gt; 也可以插入。该记录包含对数据库中尚不存在的另一个雇员的隐式引用。 &lt;code&gt;Mnesia&lt;/code&gt; 不强制执行此操作。</target>
        </trans-unit>
        <trans-unit id="eeb48859b3ad695cfb58e1472606a8b95d102ac9" translate="yes" xml:space="preserve">
          <source>The record declarations for a module &lt;code&gt;M&lt;/code&gt; are placed in a separate &lt;code&gt;M.hrl&lt;/code&gt; file.</source>
          <target state="translated">模块 &lt;code&gt;M&lt;/code&gt; 的记录声明放置在单独的 &lt;code&gt;M.hrl&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="b8f84ddcf67fb899e512597e0ee97ecc7c382394" translate="yes" xml:space="preserve">
          <source>The record definition is found in xmerl.hrl.</source>
          <target state="translated">该记录的定义见xmerl.rl。</target>
        </trans-unit>
        <trans-unit id="4ce6599fcf9f158028050aea35d7c11542e58696" translate="yes" xml:space="preserve">
          <source>The record epxressions &lt;code&gt;Expr#Name.Field&lt;/code&gt; and &lt;code&gt;#Name.Field&lt;/code&gt;</source>
          <target state="translated">记录要素 &lt;code&gt;Expr#Name.Field&lt;/code&gt; 和 &lt;code&gt;#Name.Field&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="394047f2007a24d86e1cb879c7530c3931944dad" translate="yes" xml:space="preserve">
          <source>The record holding EEP-48 documentation for a module. You can use &lt;code&gt;code:get_doc/1&lt;/code&gt; to fetch this information from a module.</source>
          <target state="translated">记录包含EEP-48模块的文档。您可以使用 &lt;code&gt;code:get_doc/1&lt;/code&gt; 从模块中获取此信息。</target>
        </trans-unit>
        <trans-unit id="b708de2ffe05d9893e05e616dfbb164eb37b0f6f" translate="yes" xml:space="preserve">
          <source>The record initially returned by &lt;code&gt;megaco:connect/4,5&lt;/code&gt;. It identifies a &quot;virtual&quot; connection and may be reused after a reconnect (disconnect + connect).</source>
          <target state="translated">该记录最初由 &lt;code&gt;megaco:connect/4,5&lt;/code&gt; 返回。它标识&amp;ldquo;虚拟&amp;rdquo;连接，并且在重新连接（断开+连接）后可以重新使用。</target>
        </trans-unit>
        <trans-unit id="a7f4e92997b0d8825962c8c3544ff9c3495a9e48" translate="yes" xml:space="preserve">
          <source>The record is defined in the Kernel include file &lt;code&gt;&quot;inet.hrl&quot;&lt;/code&gt;.</source>
          <target state="translated">该记录在内核包含文件 &lt;code&gt;&quot;inet.hrl&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87950d43bd1bd589a1c9d9ae13c4a20a531dad00" translate="yes" xml:space="preserve">
          <source>The record must be defined in the shell to enable use of the record syntax in the examples:</source>
          <target state="translated">记录必须在shell中定义,以便在例子中使用记录语法。</target>
        </trans-unit>
        <trans-unit id="7dc35961a83e47be02049c0ff9dabcb3687ccf9d" translate="yes" xml:space="preserve">
          <source>The record representation of the Diameter header. Values in a &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;&lt;a href=&quot;#decode-2&quot;&gt;decode/2&lt;/a&gt;&lt;/code&gt; are as extracted from the incoming message. Values set in an &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; passed to &lt;code&gt;&lt;a href=&quot;#encode-2&quot;&gt;encode/2&lt;/a&gt;&lt;/code&gt; are preserved in the encoded binary(), with the exception of &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;cmd_code&lt;/code&gt; and &lt;code&gt;application_id&lt;/code&gt;, all of which are determined by the &lt;code&gt;&lt;a href=&quot;#dictionary&quot;&gt;dictionary()&lt;/a&gt;&lt;/code&gt; in question.</source>
          <target state="translated">Diameter标头的记录表示形式。 &lt;code&gt;&lt;a href=&quot;#decode-2&quot;&gt;decode/2&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 中的值是从传入消息中提取的。在传递给 &lt;code&gt;cmd_code&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#encode-2&quot;&gt;encode/2&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 中设置的值保留在已编码的binary（）中，但 &lt;code&gt;length&lt;/code&gt; ，cmd_code和 &lt;code&gt;application_id&lt;/code&gt; 除外，所有这些值均由相关的 &lt;code&gt;&lt;a href=&quot;#dictionary&quot;&gt;dictionary()&lt;/a&gt;&lt;/code&gt; 确定。</target>
        </trans-unit>
        <trans-unit id="b8a33924ef83addcd9ea6487ebe39442f7c5cc0d" translate="yes" xml:space="preserve">
          <source>The reference count of driver binary is normally to be decremented by calling &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt; driver_free_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，通过调用 &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt; driver_free_binary&lt;/a&gt;&lt;/code&gt; 来减少驱动程序二进制文件的引用计数。</target>
        </trans-unit>
        <trans-unit id="0f1ffbe66bd5cda775f3eecb9e76ac9a6773796b" translate="yes" xml:space="preserve">
          <source>The reference count of driver binary is normally to be decremented by calling &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，通过调用 &lt;code&gt;&lt;a href=&quot;#driver_free_binary&quot;&gt;driver_free_binary&lt;/a&gt;&lt;/code&gt; 来减少驱动程序二进制文件的引用计数。</target>
        </trans-unit>
        <trans-unit id="d02f19c19b420c90f199ab4d6f0e29073cf27683" translate="yes" xml:space="preserve">
          <source>The reference material is divided into the following sections:</source>
          <target state="translated">参考资料分为以下几部分。</target>
        </trans-unit>
        <trans-unit id="14b2330f91efad717120789b2f96d3d8f50d2e67" translate="yes" xml:space="preserve">
          <source>The reference objects &lt;strong&gt;sub binaries&lt;/strong&gt; and &lt;strong&gt;match contexts&lt;/strong&gt; can reference part of a refc binary or heap binary.</source>
          <target state="translated">引用对象&lt;strong&gt;子二进制文件&lt;/strong&gt;和&lt;strong&gt;匹配上下文&lt;/strong&gt;可以引用refc二进制文件或堆二进制文件的一部分。</target>
        </trans-unit>
        <trans-unit id="1f3eb9a07f806c6c71dfeae710e0da778e14bc05" translate="yes" xml:space="preserve">
          <source>The registered name of the port, if any.</source>
          <target state="translated">港口的注册名称(如果有的话);</target>
        </trans-unit>
        <trans-unit id="c9cf711a7294ba24b8c0e11fc28d22a091e59813" translate="yes" xml:space="preserve">
          <source>The registered name of the process, if any.</source>
          <target state="translated">流程的注册名称(如有);</target>
        </trans-unit>
        <trans-unit id="d5bafed5b0dd3a5d4eb9ad07383aa0c7c6a85578" translate="yes" xml:space="preserve">
          <source>The registered name, &lt;code&gt;RegName&lt;/code&gt;, can be any atom. The name can be ignored by the C code, or, for example, be used to distinguish between different types of messages. An example of Erlang code using short node names follows:</source>
          <target state="translated">注册名称 &lt;code&gt;RegName&lt;/code&gt; 可以是任何原子。该名称可以被C代码忽略，或者例如用于区分不同类型的消息。使用短节点名的Erlang代码示例如下：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
