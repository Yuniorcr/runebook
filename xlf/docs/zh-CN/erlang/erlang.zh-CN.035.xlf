<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="b98454e1dad347bf57900e7a0165181c58bc516a" translate="yes" xml:space="preserve">
          <source>There is always a process registered under the name of &lt;code&gt;user&lt;/code&gt;. This can be used for sending output to the user.</source>
          <target state="translated">总会有一个以 &lt;code&gt;user&lt;/code&gt; 名义注册的进程。这可用于将输出发送给用户。</target>
        </trans-unit>
        <trans-unit id="48f05fa36ef8d48104e41cb6957499643b973e55" translate="yes" xml:space="preserve">
          <source>There is an important command to list the actual algorithms and their ordering: &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有一个重要的命令可以列出实际算法及其顺序： &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83f929c7ba80aeba27f85a0a055bddbdc902825" translate="yes" xml:space="preserve">
          <source>There is an information function for the types above:</source>
          <target state="translated">以上类型有一个信息功能。</target>
        </trans-unit>
        <trans-unit id="9bbb406addbf195bc5bf6f601577bdb5f7463970" translate="yes" xml:space="preserve">
          <source>There is another non-standard property, Xuc, which matches any character that can be represented by a Universal Character Name in C++ and other programming languages. These are the characters $, @, ` (grave accent), and all characters with Unicode code points &amp;gt;= U+00A0, except for the surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are excluded. (Universal Character Names are of the form \uHHHH or \UHHHHHHHH, where H is a hexadecimal digit. Notice that the Xuc property does not match these sequences but the characters that they represent.)</source>
          <target state="translated">还有另一个非标准属性Xuc，它与可以用C ++和其他编程语言的通用字符名称表示的任何字符匹配。这些是字符$，@，`（重音符），以及所有带有Unicode代码点&amp;gt; = U + 00A0的字符，但从U + D800到U + DFFF的替代字符除外。请注意，排除了大多数基本（ASCII）字符。 （通用字符名称的格式为\ uHHHH或\ UHHHHHHHHH，其中H是十六进制数字。请注意，Xuc属性与这些序列不匹配，但与它们表示的字符匹配。）</target>
        </trans-unit>
        <trans-unit id="01441ce6d74363dda8f15648c06b7b0537c64a86" translate="yes" xml:space="preserve">
          <source>There is however a utility module, &lt;code&gt;dist_util&lt;/code&gt;, which does most of the hard work of handling handshakes, cookies, timers, and ticking. Using &lt;code&gt;dist_util&lt;/code&gt; makes implementing a distribution module much easier and that is done in the example application.</source>
          <target state="translated">但是，有一个实用程序模块 &lt;code&gt;dist_util&lt;/code&gt; ，它完成了处理握手，cookie，计时器和滴答的大部分艰苦的工作。使用 &lt;code&gt;dist_util&lt;/code&gt; 使实现分发模块更加容易，这在示例应用程序中完成。</target>
        </trans-unit>
        <trans-unit id="4ca5bc74ccdc1a7e5bdfd46cd1aa8fff1884417d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;rsh&lt;/code&gt; program on the computer.</source>
          <target state="translated">计算机上没有 &lt;code&gt;rsh&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="df2ff6a55b257f4164ad71e8f10123efe9394150" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;send&lt;/code&gt; call with a time-out option, use socket option &lt;code&gt;send_timeout&lt;/code&gt; if time-outs are desired. See section &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有带有超时选项的 &lt;code&gt;send&lt;/code&gt; 呼叫，如果需要超时，请使用套接字选项 &lt;code&gt;send_timeout&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="788a001e209f8fbfb495d59e087ae4ffbefebb3f" translate="yes" xml:space="preserve">
          <source>There is no Boolean data type in Erlang. Instead the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to denote Boolean values.</source>
          <target state="translated">Erlang中没有布尔数据类型。相反，原子 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 用于表示布尔值。</target>
        </trans-unit>
        <trans-unit id="37147d996eecd281a8ba511598164eac1e447d2f" translate="yes" xml:space="preserve">
          <source>There is no attempt to balance trees after deletions. As deletions do not increase the height of a tree, this should be OK.</source>
          <target state="translated">在删除后,没有尝试平衡树木。由于删除不会增加树的高度,所以应该是可以的。</target>
        </trans-unit>
        <trans-unit id="caf2aa5b2cbffe36cef8b0ea41ca0022fd85db8a" translate="yes" xml:space="preserve">
          <source>There is no connection to the node where the process is located.</source>
          <target state="translated">没有连接到进程所在的节点。</target>
        </trans-unit>
        <trans-unit id="5b7a1543335bb44ae5cf0c88c1eac25c65cd7e3b" translate="yes" xml:space="preserve">
          <source>There is no difference between rows in a table and &lt;code&gt;Mnesia&lt;/code&gt; records. Both concepts are the same and are used interchangeably throughout this User's Guide.</source>
          <target state="translated">表格中的行与 &lt;code&gt;Mnesia&lt;/code&gt; 记录之间没有区别。这两个概念相同，并且在本《用户指南》中可以互换使用。</target>
        </trans-unit>
        <trans-unit id="9a1861aef615622b38a7ac58736c71ae81c27ee3" translate="yes" xml:space="preserve">
          <source>There is no guarantee of consistency in the returned list. Tables created or deleted by other processes &quot;during&quot; the &lt;code&gt;ets:all()&lt;/code&gt; call either are or are not included in the list. Only tables created/deleted &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;ets:all()&lt;/code&gt; is called are guaranteed to be included/excluded.</source>
          <target state="translated">不能保证返回列表的一致性。在 &lt;code&gt;ets:all()&lt;/code&gt; 调用过程中由其他进程创建或删除的表不包含在列表中。只有在调用 &lt;code&gt;ets:all()&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;创建/删除的表才被保证包含/排除。</target>
        </trans-unit>
        <trans-unit id="23cb6eb28b6463357c5d086be78e4c28d974313b" translate="yes" xml:space="preserve">
          <source>There is no guarantee that this function will return the same encoded representation for the same term.</source>
          <target state="translated">不保证这个函数会对同一术语返回相同的编码表示。</target>
        </trans-unit>
        <trans-unit id="9a78fbe3d9cb96a901b01d191391ac77c129ae95" translate="yes" xml:space="preserve">
          <source>There is no local function handler.</source>
          <target state="translated">没有本地函数处理程序。</target>
        </trans-unit>
        <trans-unit id="33d688593567ec97b98492916d41c5719d414cf7" translate="yes" xml:space="preserve">
          <source>There is no non-local function handler.</source>
          <target state="translated">没有非本地函数处理程序。</target>
        </trans-unit>
        <trans-unit id="7e798f2b7954fbb8128c8deaa8091eb40c413ae4" translate="yes" xml:space="preserve">
          <source>There is no performance advantage of building (and using) a non-reentrant flex scanner over a reentrant flex scanner (if flex supports building such a scanner).</source>
          <target state="translated">与再入式柔性扫描仪相比,构建(和使用)非再入式柔性扫描仪没有性能优势(如果柔性扫描仪支持构建这样的扫描仪)。</target>
        </trans-unit>
        <trans-unit id="c626748bd3f9380817d9836ccd98f9458d1a0bc7" translate="yes" xml:space="preserve">
          <source>There is no space left on the device (if &lt;code&gt;write&lt;/code&gt; access was specified).</source>
          <target state="translated">设备上没有剩余空间（如果指定了 &lt;code&gt;write&lt;/code&gt; 访问权限）。</target>
        </trans-unit>
        <trans-unit id="2a40eb7111de1638bc04c597cd24719439c9fafa" translate="yes" xml:space="preserve">
          <source>There is not enough memory for the contents of the file.</source>
          <target state="translated">文件的内容没有足够的内存。</target>
        </trans-unit>
        <trans-unit id="68171e010dd69d363d2cc2e5daa9281d1e1ce0d2" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;start_ssl.boot&lt;/code&gt; file in the current directory.</source>
          <target state="translated">现在，当前目录中有一个 &lt;code&gt;start_ssl.boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="982e604305f35dec38eb296c4a9c3f70aede4f41" translate="yes" xml:space="preserve">
          <source>There is one exception to the rule that the tuple is copied. If the compiler clearly can see that destructively updating the tuple would give the same result as if the tuple was copied, the call to &lt;code&gt;setelement/3&lt;/code&gt; is replaced with a special destructive &lt;code&gt;setelement&lt;/code&gt; instruction. In the following code sequence, the first &lt;code&gt;setelement/3&lt;/code&gt; call copies the tuple and modifies the ninth element:</source>
          <target state="translated">元组被复制的规则有一个例外。如果编译器清楚地看到破坏性地更新元组将得到与复制元组相同的结果，则对 &lt;code&gt;setelement/3&lt;/code&gt; 的调用将替换为特殊的破坏性 &lt;code&gt;setelement&lt;/code&gt; 指令。在以下代码序列中，第一个 &lt;code&gt;setelement/3&lt;/code&gt; 调用复制该元组并修改第九个元素：</target>
        </trans-unit>
        <trans-unit id="961aa3429c05e4421a44dd6baffbd85ca75ea3dd" translate="yes" xml:space="preserve">
          <source>There is one exception. &lt;strong&gt;Any&lt;/strong&gt; tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; will, in this context, be considered belonging to this application, and may be processed by the agent.</source>
          <target state="translated">有一个例外。在这种情况下，包含原子 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 的&lt;strong&gt;任何&lt;/strong&gt;元组都将被视为属于此应用程序，并且可以由代理进行处理。</target>
        </trans-unit>
        <trans-unit id="fb83be6c2e955864087572066b00b5e6d77bfed6" translate="yes" xml:space="preserve">
          <source>There is seldom or never any need to use this BIF as other processes have a chance to run in another scheduler thread anyway. Using this BIF without a thorough grasp of how the scheduler works can cause performance degradation.</source>
          <target state="translated">很少或根本不需要使用这个BIF,因为其他进程有机会在另一个调度线程中运行。在没有彻底掌握调度器工作原理的情况下使用这个BIF会导致性能下降。</target>
        </trans-unit>
        <trans-unit id="672d0cbc29fa0c58939d66ddc95453e76a3b8e80" translate="yes" xml:space="preserve">
          <source>There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself.</source>
          <target state="translated">在shell中对读取和打印记录有一些支持。在编译过程中,记录表达式被翻译成元组表达式。在运行时,不知道元组是否代表记录,编译器使用的记录定义在运行时不可用。所以,为了尽可能地读取记录语法并将元组打印为记录,记录定义必须由shell自己维护。</target>
        </trans-unit>
        <trans-unit id="f75ce9844eb4486f4e4b30867918c3e4b3911386" translate="yes" xml:space="preserve">
          <source>There is support for this in xmerl by the &quot;simple-form&quot; format. You can put your data in a simple-form data structure and feed it into &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt;. Content may be a mixture of simple-form and xmerl records as xmlElement and xmlText.</source>
          <target state="translated">xmerl通过&amp;ldquo;简单形式&amp;rdquo;格式对此提供支持。您可以将数据放入简单形式的数据结构中，并将其输入 &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt; 中。内容可能是xmlElement和xmlText等简单形式和xmerl记录的混合。</target>
        </trans-unit>
        <trans-unit id="3edc744598fcc737ca378c211064f17614a02e99" translate="yes" xml:space="preserve">
          <source>There is usually not much difference between a body-recursive list function and tail-recursive function that reverses the list at the end. Therefore, concentrate on writing beautiful code and forget about the performance of your list functions. In the time-critical parts of your code (and only there), &lt;strong&gt;measure&lt;/strong&gt; before rewriting your code.</source>
          <target state="translated">主体递归列表函数和尾部递归函数（在末尾反向列表）之间通常没有太大区别。因此，请专注于编写漂亮的代码，而不必理会列表函数的性能。在代码的时间紧迫部分（并且仅在那儿），在重写代码之前先进行&lt;strong&gt;测量&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="175f3e4c19799f026ed2193325a08cc18afee059" translate="yes" xml:space="preserve">
          <source>There may be a tuple &lt;code&gt;{saved, N}&lt;/code&gt; in the return value, if the MatchSpec is other than []. The integer &lt;code&gt;N&lt;/code&gt; may then be used in subsequent calls to this function and will stand as an &quot;alias&quot; for the given expression. There are also a couple of built-in aliases for common expressions, see &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; below for details.</source>
          <target state="translated">如果MatchSpec不是[]，则返回值中可能有一个元组 &lt;code&gt;{saved, N}&lt;/code&gt; 。然后，整数 &lt;code&gt;N&lt;/code&gt; 可以在对该函数的后续调用中使用，并且将作为给定表达式的&amp;ldquo;别名&amp;rdquo;。通用表达式还有两个内置别名，有关详细信息，请参见下面的 &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="439af89f2aedc3e47e38162227f9dad598919f3e" translate="yes" xml:space="preserve">
          <source>There may be label characters before or/and after the wildcard. For example: &lt;code&gt;a*d.example.com&lt;/code&gt; matches &lt;code&gt;abcd.example.com&lt;/code&gt; and &lt;code&gt;ad.example.com&lt;/code&gt;, but not &lt;code&gt;ab.cd.example.com&lt;/code&gt;.</source>
          <target state="translated">通配符之前或之后可能有标签字符。例如： &lt;code&gt;a*d.example.com&lt;/code&gt; 与 &lt;code&gt;abcd.example.com&lt;/code&gt; 和 &lt;code&gt;ad.example.com&lt;/code&gt; 匹配，但与ab.cd.example.com不 &lt;code&gt;ab.cd.example.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2139ae87af2ed5426b73952d31a1c1937f8c40d6" translate="yes" xml:space="preserve">
          <source>There may only be one wildcard character and that is in the first label, for example: &lt;code&gt;*.example.com&lt;/code&gt;. This matches &lt;code&gt;foo.example.com&lt;/code&gt; but neither &lt;code&gt;example.com&lt;/code&gt; nor &lt;code&gt;foo.bar.example.com&lt;/code&gt;.</source>
          <target state="translated">可能只有一个通配符，并且在第一个标签中，例如： &lt;code&gt;*.example.com&lt;/code&gt; 。这与 &lt;code&gt;foo.example.com&lt;/code&gt; 匹配，但与 &lt;code&gt;example.com&lt;/code&gt; 或 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 都不匹配。</target>
        </trans-unit>
        <trans-unit id="86d38102deb0f5be31f5b5646bc1d23391a9239c" translate="yes" xml:space="preserve">
          <source>There must be no calls to another function in between the calls to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">在对 &lt;code&gt;setelement/3&lt;/code&gt; 的调用之间，不得存在对另一个函数的调用。</target>
        </trans-unit>
        <trans-unit id="4379219137f82ad3d5f85ec7793035a5647a5347" translate="yes" xml:space="preserve">
          <source>There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems:</source>
          <target state="translated">在实现现在未被记录的算法时存在一些问题,这就是为什么它们被废弃的原因。新的算法速度稍慢,但不存在这些问题。</target>
        </trans-unit>
        <trans-unit id="94edc56fd4c7a685211aeb70698042dc2126321d" translate="yes" xml:space="preserve">
          <source>Therefor in the tests, binary codecs are tested with four different encoding configs to determine exactly how the different options effect the performance: with transformation and without driver ([]), without transformation and without driver ([native]), with transformation and with driver ([driver]) and finally without transformation and with driver ([driver,native]).</source>
          <target state="translated">因此,在测试中,二进制编解码器用四种不同的编码配置进行测试,以确定不同的选项对性能的影响:有转换和无驱动([]),无转换和无驱动([native]),有转换和有驱动([driver]),最后无转换和有驱动([driver,native])。</target>
        </trans-unit>
        <trans-unit id="243f02477e6596c18fd3c62ae8ed5666e8ef7097" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;my_binary_to_list/1&lt;/code&gt; calls itself with the match context instead of with a sub binary. The instruction that initializes the matching operation basically does nothing when it sees that it was passed a match context instead of a binary.</source>
          <target state="translated">因此， &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 会使用match上下文而不是子二进制文件进行调用。初始化匹配操作的指令在看到已传递给匹配上下文而不是二进制文件时，基本上什么也不做。</target>
        </trans-unit>
        <trans-unit id="a8aae9f4ba098f331d48e185f24980e7223ed137" translate="yes" xml:space="preserve">
          <source>Therefore it is not enough to only recompile drivers written with version management for pre R15B types; the types must be changed in the driver suggesting other rewrites, especially regarding size variables. &lt;strong&gt;Investigate all warnings when recompiling.&lt;/strong&gt;</source>
          <target state="translated">因此，仅针对R15B之前的类型仅重新编译使用版本管理编写的驱动程序是不够的。必须在驱动程序中更改类型，建议进行其他重写，尤其是有关大小变量的重写。&lt;strong&gt;重新编译时，请检查所有警告。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8451cc048f68604a8e6f8398bb63201daf908b58" translate="yes" xml:space="preserve">
          <source>Therefore the following call:</source>
          <target state="translated">因此下面的电话。</target>
        </trans-unit>
        <trans-unit id="f4080dae433bd65ba4f78438abd73a9dcd511aa9" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;after_zero/1&lt;/code&gt; builds one match context and one sub binary (assuming it is passed a binary that contains a zero byte).</source>
          <target state="translated">因此， &lt;code&gt;after_zero/1&lt;/code&gt; 构建一个匹配上下文和一个子二进制文件（假定传递了一个包含零字节的二进制文件）。</target>
        </trans-unit>
        <trans-unit id="9e7c3bfd969d68d13350f73c07ad4f037893dc43" translate="yes" xml:space="preserve">
          <source>Therefore, certain operations on a binary mark it so that any future append operation will be forced to copy the binary. In most cases, the binary object will be shrunk at the same time to reclaim the extra space allocated for growing.</source>
          <target state="translated">因此,对二进制的某些操作会对其进行标记,这样未来的任何追加操作都会强制复制二进制。在大多数情况下,二进制对象将同时被收缩,以回收分配给增长的额外空间。</target>
        </trans-unit>
        <trans-unit id="92e119795a21e7955d1c30f27f5a24fcb874b645" translate="yes" xml:space="preserve">
          <source>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; can be used to to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</source>
          <target state="translated">因此，在连续运行的系统中，将任意输入字符串转换为原子可能很危险。如果只允许使用某些定义明确的原子作为输入，则 &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; 可以用于防范拒绝服务攻击。（例如，可以通过简单地在模块中使用所有原子并加载该模块来创建所有允许的原子。）</target>
        </trans-unit>
        <trans-unit id="0afb1e74cde0028071d12983306cbaa758aaee89" translate="yes" xml:space="preserve">
          <source>Therefore, if you want to send both a pre-existing binary and some extra data to a driver without copying the binary, you must call &lt;code&gt;port_control/3&lt;/code&gt; twice; once with the binary and once with the extra data. However, that will only work if there is only one process communicating with the port (because otherwise another process can call the driver in-between the calls).</source>
          <target state="translated">因此，如果您想将既有的二进制文件和一些额外的数据发送给驱动程序而不复制二进制文件，则必须调用 &lt;code&gt;port_control/3&lt;/code&gt; 两次；一次使用二进制文件，一次使用额外数据。但是，这仅在只有一个进程与端口进行通信时才起作用（因为否则，另一个进程可以在调用之间调用驱动程序）。</target>
        </trans-unit>
        <trans-unit id="e1058e576d020e27852d4dd63c7e76baf9cb4f3e" translate="yes" xml:space="preserve">
          <source>Therefore, setting this option to &lt;code&gt;true&lt;/code&gt; when creating a socket never fails, except possibly on a platform where you have customized the kernel to only allow &lt;code&gt;false&lt;/code&gt;, which can be doable (but awkward) on, for example, OpenBSD.</source>
          <target state="translated">因此，在创建套接字时将此选项设置为 &lt;code&gt;true&lt;/code&gt; 永远不会失败，除非可能是在您已将内核自定义为仅允许 &lt;code&gt;false&lt;/code&gt; 的平台上进行，但可以在OpenBSD上这样做（但尴尬）。</target>
        </trans-unit>
        <trans-unit id="fa03132e315d50b20abbcf96beb07d6fa4be6ede" translate="yes" xml:space="preserve">
          <source>Therefore, the following example is a valid Erlang instance of type 'Oid':</source>
          <target state="translated">因此,下面的例子是一个有效的'Oid'类型的Erlang实例。</target>
        </trans-unit>
        <trans-unit id="a00c80e549287bbb93dadd392554fafbbbc24b24" translate="yes" xml:space="preserve">
          <source>These Erlang variables are now bound to valid instances of ASN.1 defined types. This style of value can be passed directly to the encoder for transformation into a series of bytes.</source>
          <target state="translated">这些Erlang变量现在被绑定到ASN.1定义类型的有效实例上。这种风格的值可以直接传递给编码器,以便转化为一系列字节。</target>
        </trans-unit>
        <trans-unit id="0f0a03fdc3b62893e944bf31939f2cfaecae96b7" translate="yes" xml:space="preserve">
          <source>These MIBs are not loaded by default.</source>
          <target state="translated">这些MIB在默认情况下没有被加载。</target>
        </trans-unit>
        <trans-unit id="2ec64a39b7d4c54784cd2ad56d92c227d3e17b9a" translate="yes" xml:space="preserve">
          <source>These MIBs contain the &lt;code&gt;snmp-&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; groups from MIB-II which is defined in RFC1213 (STANDARD-MIB) or RFC1907 (SNMPv2-MIB). They are implemented in the &lt;code&gt;snmp_standard_mib&lt;/code&gt; module. The &lt;code&gt;snmp&lt;/code&gt; counters all reside in volatile memory and the &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; variables in persistent memory, using the SNMP built-in database (refer to the Reference Manual, section &lt;code&gt;snmp&lt;/code&gt;, module &lt;code&gt;snmpa_local_db&lt;/code&gt; for more details).</source>
          <target state="translated">这些MIB包含来自MIB-II 的 &lt;code&gt;snmp-&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; 组，这些组在RFC1213（STANDARD-MIB）或RFC1907（SNMPv2-MIB）中定义。它们在 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 模块中实现。该 &lt;code&gt;snmp&lt;/code&gt; 计数器都驻留在易失性存储器和 &lt;code&gt;system&lt;/code&gt; 以及 &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; 在永久存储器中的变量，使用SNMP内置数据库（请参阅参考手册，章节 &lt;code&gt;snmp&lt;/code&gt; ，模块 &lt;code&gt;snmpa_local_db&lt;/code&gt; 有详细介绍）。</target>
        </trans-unit>
        <trans-unit id="e67a93a99a7e370f0477c918676f4cf69ff8699a" translate="yes" xml:space="preserve">
          <source>These are a few  facts about the predefined variables (the set operators &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; (union) and &lt;code&gt;-&lt;/code&gt; (difference) as well as the cast operator &lt;code&gt;(&lt;/code&gt;Type&lt;code&gt;)&lt;/code&gt; are described below):</source>
          <target state="translated">以下是有关预定义变量的一些事实（集合运算符 &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; （联合）和 &lt;code&gt;-&lt;/code&gt; （差）以及强制转换运算符 &lt;code&gt;(&lt;/code&gt; 类型 &lt;code&gt;)&lt;/code&gt; 描述如下）：</target>
        </trans-unit>
        <trans-unit id="b41fa5eb73a7806528a8254a84f2a17ca0515977" translate="yes" xml:space="preserve">
          <source>These are deprecated because the annoying double meaning of the name servers/time-out argument, and because they have no decent place for a resolver options list.</source>
          <target state="translated">由于名称服务器/超时参数具有恼人的双重含义,而且它们在解析器选项列表中没有合适的位置,因此这些选项已被废弃。</target>
        </trans-unit>
        <trans-unit id="60cf421719fdc337d9a96b28085e43063192f175" translate="yes" xml:space="preserve">
          <source>These are only recognized by Erlang nodes, not by hidden nodes.</source>
          <target state="translated">这些只被Erlang节点识别,不被隐藏节点识别。</target>
        </trans-unit>
        <trans-unit id="3295d73ec7e802c1f14b2c332abe46ab60bbbcd5" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;originating&lt;/code&gt; in this agent.</source>
          <target state="translated">这些是影响 &lt;code&gt;originating&lt;/code&gt; 此代理的发现的选项。</target>
        </trans-unit>
        <trans-unit id="e5c03f74465d648a5862f1fc098e9296ee6d6bfb" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;terminating&lt;/code&gt; in this agent (i.e. initiated by a manager).</source>
          <target state="translated">这些是影响发现 &lt;code&gt;terminating&lt;/code&gt; 于此代理程序（即由管理者发起）的选项。</target>
        </trans-unit>
        <trans-unit id="b54f8e7581e4b11655c99aa67637a8c43ce11aa5" translate="yes" xml:space="preserve">
          <source>These are the tools you need in order to unpack and build Erlang/OTP.</source>
          <target state="translated">这些都是你在解压和构建Erlang/OTP时需要的工具。</target>
        </trans-unit>
        <trans-unit id="c2b3c62dddfeb24a018a3dfcfce0b24364d8a6b9" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt;, &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt;, and &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt;, respectively.</source>
          <target state="translated">它们分别表现为 &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt; ， &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt; 和 &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1e4b991ff6fe7d1f2495f5a84c72e419f949594" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; and &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt;, respectively.</source>
          <target state="translated">它们分别表现为 &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; 和 &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="187481b8c7b89208071bec932d3843dbbff8e5a2" translate="yes" xml:space="preserve">
          <source>These are two different SMP performance monitoring tool(s).</source>
          <target state="translated">这是两种不同的SMP性能监测工具。</target>
        </trans-unit>
        <trans-unit id="4a7d9dd0e596b5ce481a5779ed708189763b4369" translate="yes" xml:space="preserve">
          <source>These behaviors occur regardless if the subpattern is called recursively. The treatment of subroutines in Perl is different in some cases.</source>
          <target state="translated">无论子程序是否被递归调用,这些行为都会发生。在Perl中对子程序的处理在某些情况下是不同的。</target>
        </trans-unit>
        <trans-unit id="4ec49381162072262ed7e981970a8f6edfbd0ee9" translate="yes" xml:space="preserve">
          <source>These books are highly recommended as a start for learning Erlang.</source>
          <target state="translated">强烈推荐这些书作为学习Erlang的开始。</target>
        </trans-unit>
        <trans-unit id="f21525376606a80acbcf6dfcd0372134852c9de3" translate="yes" xml:space="preserve">
          <source>These callback functions are called from local and non-local evaluation function handlers, described in the &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; manual page. (Arguments in &lt;code&gt;ArgList&lt;/code&gt; are evaluated before the callback functions are called.)</source>
          <target state="translated">这些回调函数从本地和非本地评估函数处理程序调用，如 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; 手册页所述。（在调用回调函数之前先评估 &lt;code&gt;ArgList&lt;/code&gt; 中的参数。）</target>
        </trans-unit>
        <trans-unit id="0717b31aef17edf30fcfa1ecdd0c63f7b41ab7a8" translate="yes" xml:space="preserve">
          <source>These case switches only allow &lt;code&gt;?Q(...)&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; as clause patterns, and the guards may contain any expressions, not just Erlang guard expressions.</source>
          <target state="translated">这些大小写开关仅允许 &lt;code&gt;?Q(...)&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 作为子句模式，并且防护可能包含任何表达式，而不仅仅是Erlang防护表达式。</target>
        </trans-unit>
        <trans-unit id="b82509cdccdd98b3f35ff2498648839db3e7e6d5" translate="yes" xml:space="preserve">
          <source>These changes are essential not to crash the emulator or worse cause malfunction. Without them a driver can return garbage in the high 32 bits to the emulator, causing it to build a huge result from random bytes, either crashing on memory allocation or succeeding with a random result from the driver call.</source>
          <target state="translated">这些变化是必不可少的,不会使仿真器崩溃或更糟的是导致故障。如果没有它们,一个驱动程序可能会返回高32位的垃圾给仿真器,导致它从随机字节中建立一个巨大的结果,要么在内存分配时崩溃,要么成功地从驱动程序调用一个随机的结果。</target>
        </trans-unit>
        <trans-unit id="573248e1d06102f3107f0a34b228df99492a4b03" translate="yes" xml:space="preserve">
          <source>These choices depend a lot on your problem domain. If you don't have real time monitoring and ability to fix problems quickly, for example in an embedded system, you might want to accept at most one restart per minute before the supervisor should give up and escalate to the next level to try to clear the error automatically. On the other hand, if it is more important that you keep trying even at a high failure rate, you might want a sustained rate of as much as 1-2 restarts per second.</source>
          <target state="translated">这些选择在很大程度上取决于你的问题域。如果你没有实时监控和快速解决问题的能力,例如在嵌入式系统中,你可能希望在主管应该放弃并升级到下一级试图自动清除错误之前,每分钟最多接受一次重启。另一方面,如果更重要的是,即使在高故障率的情况下,你也要继续尝试,你可能希望有一个持续的速率,即每秒多达1-2次重启。</target>
        </trans-unit>
        <trans-unit id="7cc39d5ee560666c19b1d761a7fa1de1841363b5" translate="yes" xml:space="preserve">
          <source>These commands are only added for convenience, the normal way to manipulate the state of a service is through the control panels services applet.</source>
          <target state="translated">这些命令只是为了方便而添加的,正常情况下是通过控制面板服务小程序来操作服务的状态。</target>
        </trans-unit>
        <trans-unit id="f0bb49d0ba352c03c469accf5e7d24180534a7f3" translate="yes" xml:space="preserve">
          <source>These constructs makes it possible to define open types, that is, values of that type can be of any ASN.1 type. Also, relationships can be defined between different types and values, as classes can hold types, values, objects, object sets, and other classes in their fields. A class can be defined in ASN.1 as follows:</source>
          <target state="translated">这些构造使得定义开放类型成为可能,即该类型的值可以是任何ASN.1类型。同时,不同类型和值之间也可以定义关系,因为类可以在其字段中容纳类型、值、对象、对象集和其他类。在ASN.1中可以定义一个类,具体如下。</target>
        </trans-unit>
        <trans-unit id="befa22022ba0fc273ee1c740958946648b1b19ef" translate="yes" xml:space="preserve">
          <source>These data types are described in the documentation for the &lt;code&gt;SNMP&lt;/code&gt; application.</source>
          <target state="translated">这些数据类型在 &lt;code&gt;SNMP&lt;/code&gt; 应用程序的文档中描述。</target>
        </trans-unit>
        <trans-unit id="7607e5152380b649a4dfea1427608d47b7252b27" translate="yes" xml:space="preserve">
          <source>These declarations mean that &lt;code&gt;'='&lt;/code&gt; is defined as a &lt;code&gt;right associative binary&lt;/code&gt; operator with precedence 100, &lt;code&gt;'=='&lt;/code&gt; and &lt;code&gt;'=/='&lt;/code&gt; are operators with &lt;code&gt;no associativity&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt; are &lt;code&gt;left associative binary&lt;/code&gt; operators, where &lt;code&gt;'*'&lt;/code&gt; takes precedence over &lt;code&gt;'+'&lt;/code&gt; (the normal case), and &lt;code&gt;'-'&lt;/code&gt; is a &lt;code&gt;unary&lt;/code&gt; operator of higher precedence than &lt;code&gt;'*'&lt;/code&gt;. The fact that '==' has no associativity means that an expression like &lt;code&gt;a == b == c&lt;/code&gt; is considered a syntax error.</source>
          <target state="translated">这些声明意味着 &lt;code&gt;'='&lt;/code&gt; 被定义为优先级为100 的 &lt;code&gt;right associative binary&lt;/code&gt; 运算符， &lt;code&gt;'=='&lt;/code&gt; 和 &lt;code&gt;'=/='&lt;/code&gt; 是 &lt;code&gt;no associativity&lt;/code&gt; 运算符， &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;'*'&lt;/code&gt; 则是 &lt;code&gt;left associative binary&lt;/code&gt; 运算符，其中 &lt;code&gt;'*'&lt;/code&gt; 优先于 &lt;code&gt;'+'&lt;/code&gt; （在正常情况下），而 &lt;code&gt;'-'&lt;/code&gt; 是一 &lt;code&gt;unary&lt;/code&gt; 符，其优先级高于 &lt;code&gt;'*'&lt;/code&gt; 。 &amp;ldquo; ==&amp;rdquo;没有关联性的事实意味着像 &lt;code&gt;a == b == c&lt;/code&gt; 这样的表达式被视为语法错误。</target>
        </trans-unit>
        <trans-unit id="751552b3c6781f0e0e58af55485f1a42f3adbfcd" translate="yes" xml:space="preserve">
          <source>These function simply fetch the appropriate field from the &lt;code&gt;ec&lt;/code&gt; structure. Read the field directly will probably be safe for a long time, so these functions are not really needed.</source>
          <target state="translated">这些功能只是从 &lt;code&gt;ec&lt;/code&gt; 结构中获取适当的字段。直接阅读该字段可能很长一段时间都是安全的，因此实际上并不需要这些功能。</target>
        </trans-unit>
        <trans-unit id="04605460ad130e7237d6de8796f71c1d7f55abcb" translate="yes" xml:space="preserve">
          <source>These functions are all called in the same manner as &lt;code&gt;printf()&lt;/code&gt;, that is, with a string containing format specifiers followed by a list of corresponding arguments. All output from these functions is to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">所有这些函数都以与 &lt;code&gt;printf()&lt;/code&gt; 相同的方式调用，即，使用包含格式说明符的字符串，后跟相应的参数列表。这些函数的所有输出都将 &lt;code&gt;stderr&lt;/code&gt; 到stderr。</target>
        </trans-unit>
        <trans-unit id="52fc81f0ba111d2acbf6995d34d870aacab348cf" translate="yes" xml:space="preserve">
          <source>These functions are called for each object in an MIB when the MIB is unloaded or loaded, respectively.</source>
          <target state="translated">当MIB被卸载或加载时,分别对MIB中的每个对象调用这些函数。</target>
        </trans-unit>
        <trans-unit id="d9faf69dba0c1f70caf123cc3782e49dc958f249" translate="yes" xml:space="preserve">
          <source>These functions are described in detail in &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些功能在 &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt; 中详细介绍。</target>
        </trans-unit>
        <trans-unit id="fd7a6a1b98572c10143c1d93f4f329a609ec28fe" translate="yes" xml:space="preserve">
          <source>These functions are equivalent to the corresponding functions in module &lt;code&gt;dbg&lt;/code&gt;, but all calls are stored in the history. The history buffer makes it easy to create configuration files; the same trace environment can be set up many times, for example, to compare two test runs. It also reduces the amount of typing when using &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell.</source>
          <target state="translated">这些函数等效于 &lt;code&gt;dbg&lt;/code&gt; 模块中的相应函数，但是所有调用都存储在历史记录中。历史记录缓冲区使创建配置文件变得容易。可以多次设置相同的跟踪环境，例如，比较两个测试运行。当从Erlang shell中使用 &lt;code&gt;ttb&lt;/code&gt; 时，它还减少了键入量。</target>
        </trans-unit>
        <trans-unit id="158d67977a08a84d4924f2a647ba82873c18061b" translate="yes" xml:space="preserve">
          <source>These functions are explained in the following sections. See also &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt;, which describes the two functions used to activate and deactivate checkpoints.</source>
          <target state="translated">这些功能将在以下各节中说明。另请参阅 &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt; ，它描述了用于激活和停用检查点的两个功能。</target>
        </trans-unit>
        <trans-unit id="60e3f3ff3408849e7fd9edf60400f772dde55362" translate="yes" xml:space="preserve">
          <source>These functions are further described and exemplified in &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些功能将在 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt; 中进一步描述和举例说明。</target>
        </trans-unit>
        <trans-unit id="fa8057e2cae698872b37c80f8aa0f3fe06d7cf59" translate="yes" xml:space="preserve">
          <source>These functions are intended for interactive use in the Erlang shell only. The module prefix can be omitted.</source>
          <target state="translated">这些函数只用于在Erlang shell中的交互式使用,模块前缀可以省略。模块前缀可以省略。</target>
        </trans-unit>
        <trans-unit id="9545561ba594c4d5a35ac49f33ac5958ae1e125a" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging, and are not to be called from normal code. They are provided for convenience, allowing developers to avoid having to create their own custom state replacement functions.</source>
          <target state="translated">这些函数只是为了帮助调试,而不是从正常的代码中调用。提供这些函数是为了方便,让开发人员避免创建自己的自定义状态替换函数。</target>
        </trans-unit>
        <trans-unit id="b678d1c2ff800ccba92fa1081c74821cd431ce2f" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging. They are provided for convenience, allowing developers to avoid having to create their own state extraction functions and also avoid having to interactively extract the state from the return values of &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; while debugging.</source>
          <target state="translated">这些功能仅用于帮助调试。提供它们是为了方便，使开发人员可以不必创建自己的状态提取函数，也可以避免在调试时必须从 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; 的返回值中交互式提取状态。</target>
        </trans-unit>
        <trans-unit id="bb8d168e922a05dff4b0cd171803a7675b2fbf08" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35c1fc44955a642a5777cca455981c0556303f1d" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5de333f99c5ead1d8115c4087c9a72a0f601d546" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请使用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="2d9a4daca1ac6f764626bf603aa4c73a5aa770a0" translate="yes" xml:space="preserve">
          <source>These functions are much slower than the ordinary store and load functions of &lt;code&gt;Mnesia&lt;/code&gt;. However, this is mainly intended for minor experiments and initial prototyping. The major advantage of these functions is that they are easy to use.</source>
          <target state="translated">这些功能比 &lt;code&gt;Mnesia&lt;/code&gt; 的普通存储和加载功能要慢得多。但是，这主要用于较小的实验和初始原型制作。这些功能的主要优点是易于使用。</target>
        </trans-unit>
        <trans-unit id="cc96780ae3ae54fcc394e1c818c2355204d00877" translate="yes" xml:space="preserve">
          <source>These functions are not thread safe.</source>
          <target state="translated">这些功能不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="8afae98b4e16a8e03fc3cf30a7699eb78e0fa80a" translate="yes" xml:space="preserve">
          <source>These functions are performed in a transaction context involving mechanisms, such as locking, logging, replication, checkpoints, subscriptions, and commit protocols. However, the same function can also be evaluated in other activity contexts.</source>
          <target state="translated">这些函数是在涉及机制的事务上下文中执行的,如锁定、日志、复制、检查点、订阅和提交协议。然而,同样的函数也可以在其他活动上下文中进行评估。</target>
        </trans-unit>
        <trans-unit id="d43be56fdde5e5de270664b9730584c3eb30df12" translate="yes" xml:space="preserve">
          <source>These functions are primarily intended for simplified testing of &lt;code&gt;.appup&lt;/code&gt; files. They are not run within the context of the &lt;code&gt;release_handler&lt;/code&gt; process. They must therefore &lt;strong&gt;not&lt;/strong&gt; be used together with calls to &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;, as this causes the &lt;code&gt;release_handler&lt;/code&gt; to end up in an inconsistent state.</source>
          <target state="translated">这些功能主要用于简化 &lt;code&gt;.appup&lt;/code&gt; 文件的测试。它们不在 &lt;code&gt;release_handler&lt;/code&gt; 进程的上下文中运行。因此，&lt;strong&gt;不得&lt;/strong&gt;将它们与对 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 的调用一起使用，因为这会导致 &lt;code&gt;release_handler&lt;/code&gt; 最终处于不一致状态。</target>
        </trans-unit>
        <trans-unit id="bfdb7ec140eb86cb272ecdbb50138f14fef17e5c" translate="yes" xml:space="preserve">
          <source>These functions are to be used with trace flag &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;'receive'&lt;/code&gt; for setting and clearing trace patterns.</source>
          <target state="translated">这些功能将与跟踪标志 &lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 一起使用,以设置和清除跟踪模式。</target>
        </trans-unit>
        <trans-unit id="1f17b4d328843c30adfc4895bdc753282346f128" translate="yes" xml:space="preserve">
          <source>These functions can be called to retrieve information about the module.</source>
          <target state="translated">这些功能可以被调用来检索模块的信息。</target>
        </trans-unit>
        <trans-unit id="1311856f69e61fe882b7ae9bfc9de73ea32a8732" translate="yes" xml:space="preserve">
          <source>These functions can be used to find records in a table when it is impossible to write constraints for the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt;, or when you want to perform some action on certain records.</source>
          <target state="translated">当无法为函数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 编写约束时，或者要对某些记录执行某些操作时，可以使用这些函数在表中查找记录。</target>
        </trans-unit>
        <trans-unit id="0186f872732540e967fd668deb3a4c289a66df35" translate="yes" xml:space="preserve">
          <source>These functions create or delete a table index on a field defined by &lt;code&gt;AttributeName&lt;/code&gt;. To illustrate this, add an index to the table definition &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt;, which is the example table from the &lt;code&gt;Company&lt;/code&gt; database. The function that adds an index on element &lt;code&gt;salary&lt;/code&gt; can be expressed as &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt;.</source>
          <target state="translated">这些函数在 &lt;code&gt;AttributeName&lt;/code&gt; 定义的字段上创建或删除表索引。为了说明这一点，在表定义中添加一个索引 &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt; ，这是 &lt;code&gt;Company&lt;/code&gt; 数据库中的示例表。可以在元素 &lt;code&gt;salary&lt;/code&gt; 上添加索引的函数可以表示为 &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b321dfec9cbea3824adf71432c75a84bb7f39aaa" translate="yes" xml:space="preserve">
          <source>These functions iterate over the &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;Tab&lt;/code&gt; and apply the function &lt;code&gt;Fun&lt;/code&gt; to each record. &lt;code&gt;Fun&lt;/code&gt; takes two arguments, the first is a record from the table, and the second is the accumulator. &lt;code&gt;Fun&lt;/code&gt; returns a new accumulator.</source>
          <target state="translated">这些函数遍历 &lt;code&gt;Mnesia&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 然后将 &lt;code&gt;Fun&lt;/code&gt; 函数应用于每个记录。 &lt;code&gt;Fun&lt;/code&gt; 有两个参数，第一个是表中的记录，第二个是累加器。 &lt;code&gt;Fun&lt;/code&gt; 返回一个新的累加器。</target>
        </trans-unit>
        <trans-unit id="e2241c04aed6e2c04c16cc3d0bc2e51744dc9b5c" translate="yes" xml:space="preserve">
          <source>These functions match a &lt;code&gt;Pattern&lt;/code&gt; against all records in table &lt;code&gt;Tab&lt;/code&gt;. In a &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;Pattern&lt;/code&gt; is a part of &lt;code&gt;MatchSpecification&lt;/code&gt; described in the following. It is not necessarily performed as an exhaustive search of the entire table. By using indexes and bound values in the key of the pattern, the actual work done by the function can be condensed into a few hash lookups. Using &lt;code&gt;ordered_set&lt;/code&gt; tables can reduce the search space if the keys are partially bound.</source>
          <target state="translated">这些函数将 &lt;code&gt;Pattern&lt;/code&gt; 与表 &lt;code&gt;Tab&lt;/code&gt; 中的所有记录进行匹配。在 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; 调用中， &lt;code&gt;Pattern&lt;/code&gt; 是下面描述的 &lt;code&gt;MatchSpecification&lt;/code&gt; 的一部分。它不一定是对整个表的详尽搜索。通过在模式的键中使用索引和绑定值，该函数完成的实际工作可以简化为几个哈希查找。如果键是部分绑定的，则使用 &lt;code&gt;ordered_set&lt;/code&gt; 表可以减少搜索空间。</target>
        </trans-unit>
        <trans-unit id="4380dbd51df4c218d4fc67f122b3a31fa9dad5e7" translate="yes" xml:space="preserve">
          <source>These functions must return the current values of the associated variables.</source>
          <target state="translated">这些函数必须返回相关变量的当前值。</target>
        </trans-unit>
        <trans-unit id="d73e48f290f1971fad9fc4d6418f2f3ddc239932" translate="yes" xml:space="preserve">
          <source>These functions return a negative value indicating that an error occurred.</source>
          <target state="translated">这些函数返回一个负值,表示发生了错误。</target>
        </trans-unit>
        <trans-unit id="f2d4535f8dedc594af82a7502daf5f4472256bee" translate="yes" xml:space="preserve">
          <source>These functions return an open file descriptor on success, or a negative value indicating that an error occurred. In the latter case they set &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">这些函数在成功时返回打开的文件描述符，或者返回负值指示发生错误。在后一种情况下，他们将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为以下之一：</target>
        </trans-unit>
        <trans-unit id="33b0bf879f0be35d9275b8556a8bb8e4605058f4" translate="yes" xml:space="preserve">
          <source>These functions return the number of bytes written to buffer on success, otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">这些函数返回成功时写入缓冲区的字节数，否则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="492a4ea8131a6460ecb2bb728f7492324b79c821" translate="yes" xml:space="preserve">
          <source>These functions returns &lt;code&gt;noError&lt;/code&gt; if the assignment was successful, otherwise an error code.</source>
          <target state="translated">如果分配成功，这些函数将返回 &lt;code&gt;noError&lt;/code&gt; ，否则返回错误代码。</target>
        </trans-unit>
        <trans-unit id="a52d30d9d64255b930d9d116fb319458b1376b07" translate="yes" xml:space="preserve">
          <source>These functions sends a signal to the outer space and the caller hopes that someone is listening. In other words, they invoke &lt;code&gt;et:trace_me/4&lt;/code&gt; and &lt;code&gt;et:trace_me/5&lt;/code&gt; respectively.</source>
          <target state="translated">这些功能将信号发送到外层空间，并且呼叫者希望有人正在监听。换句话说，它们分别调用 &lt;code&gt;et:trace_me/4&lt;/code&gt; 和 &lt;code&gt;et:trace_me/5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c5096edbc3525bc8e760ed1084c3016bcbfb9a7" translate="yes" xml:space="preserve">
          <source>These have the same meanings as the normal returns but the characters in &lt;code&gt;PushBackList&lt;/code&gt; will be prepended to the input characters and scanned for the next token. Note that pushing back a newline will mean the line numbering will no longer be correct.</source>
          <target state="translated">这些具有与正常返回相同的含义，但 &lt;code&gt;PushBackList&lt;/code&gt; 中的字符将被放在输入字符之前，并扫描下一个标记。请注意，推回换行符将意味着行号将不再正确。</target>
        </trans-unit>
        <trans-unit id="28abed6097a4fa5f0db1c6ca4ce80910586cfeeb" translate="yes" xml:space="preserve">
          <source>These heuristics are also used by &lt;code&gt;io:format/2&lt;/code&gt;, &lt;code&gt;io_lib:format/2&lt;/code&gt;, and friends when modifier &lt;code&gt;t&lt;/code&gt; is used with &lt;code&gt;~p&lt;/code&gt; or &lt;code&gt;~P&lt;/code&gt;:</source>
          <target state="translated">这些启发式也使用 &lt;code&gt;io:format/2&lt;/code&gt; ， &lt;code&gt;io_lib:format/2&lt;/code&gt; ，和朋友当改性剂 &lt;code&gt;t&lt;/code&gt; 使用具有 &lt;code&gt;~p&lt;/code&gt; 或 &lt;code&gt;~P&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="216fd64a35c1d2baaf5b3f037d998a945eb81f1e" translate="yes" xml:space="preserve">
          <source>These host entries are searched after all added with &lt;code&gt;{file, hosts, File}&lt;/code&gt; above or &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; below when lookup option &lt;code&gt;file&lt;/code&gt; is used.</source>
          <target state="translated">当使用查找选项 &lt;code&gt;file&lt;/code&gt; 时 &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; 全部添加上面的 &lt;code&gt;{file, hosts, File}&lt;/code&gt; 或下面的{host，IP，Aliases}来搜索这些主机条目。</target>
        </trans-unit>
        <trans-unit id="07700975c4ec0500ef74d72b43eae1d34a325990" translate="yes" xml:space="preserve">
          <source>These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurances of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is &lt;code&gt;otp_win64_21.exe&lt;/code&gt;.</source>
          <target state="translated">这些说明适用于32位和64位Windows。请注意，即使您构建64位版本的Erlang，所涉及的大多数目录和文件仍被命名为win32。但是，出现了一些名称为win64的情况。例如，用于64位Windows版本的Erlang的安装文件是 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c394330d6ef054d071d8f890cc4c3711a8bdc95c" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to be used when it is considered an error that ports are open to a driver that no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has loaded. The ports that are still open when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;unload_driver/1&lt;/code&gt; or when the last process having the driver loaded dies, are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt;.</source>
          <target state="translated">当认为端口向没有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 加载的驱动程序打开错误时，应使用这些接口。当最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;unload_driver/1&lt;/code&gt; 或最后一个加载了驱动程序的进程死掉时，仍处于打开状态的端口由于 &lt;code&gt;driver_unloaded&lt;/code&gt; 原因而被杀死。</target>
        </trans-unit>
        <trans-unit id="976444f76eef13967574c5a3e92db1199465ca38" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c5c84c302204b5ad2412f8768bea313cd0255d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;agent_net_if_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7fa27f4823b4c40fb38224a9f2c44f5dc1ff3d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05b3a993da19e30da69e0542004935e23fe64b41" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;manager_net_if_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f52e46ef3067f96590cea6bfd8ffc4461c4cb9d7" translate="yes" xml:space="preserve">
          <source>These options are available when starting the name server. The name server is normally started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; (if not already available), but it can also be started at system startup.</source>
          <target state="translated">启动名称服务器时，这些选项可用。通常，名称服务器是通过命令 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 自动启动的（如果尚不可用），但是也可以在系统启动时启动。</target>
        </trans-unit>
        <trans-unit id="60feb775a5a2a0fc8f58b8ddfb26ab5e82088613" translate="yes" xml:space="preserve">
          <source>These options are described in &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些选项在 &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt; 中进行了描述。</target>
        </trans-unit>
        <trans-unit id="e6e76727821c709b0e581bace27e5e3b9ee3793f" translate="yes" xml:space="preserve">
          <source>These options are only for debugging and testing &lt;code&gt;epmd&lt;/code&gt; clients. They are not to be used in normal operation.</source>
          <target state="translated">这些选项仅用于调试和测试 &lt;code&gt;epmd&lt;/code&gt; 客户端。请勿在正常操作中使用它们。</target>
        </trans-unit>
        <trans-unit id="3184ea6ec742a62558f1e2dbf393dc6981719dd9" translate="yes" xml:space="preserve">
          <source>These options are preset by the &lt;code&gt;rename&lt;/code&gt; function and cannot be overridden by the user.</source>
          <target state="translated">这些选项由 &lt;code&gt;rename&lt;/code&gt; 功能预设，并且不能被用户覆盖。</target>
        </trans-unit>
        <trans-unit id="7d74113369f61132f3b23365e982841353df0d4a" translate="yes" xml:space="preserve">
          <source>These options make &lt;code&gt;epmd&lt;/code&gt; run as an interactive command, displaying the results of sending queries to an already running instance of &lt;code&gt;epmd&lt;/code&gt;. The &lt;code&gt;epmd&lt;/code&gt; contacted is always on the local node, but option &lt;code&gt;-port&lt;/code&gt; can be used to select between instances if several are running using different ports on the host.</source>
          <target state="translated">这些选项使 &lt;code&gt;epmd&lt;/code&gt; 作为交互式命令运行，显示将查询发送到已经运行的 &lt;code&gt;epmd&lt;/code&gt; 实例的结果。联系的 &lt;code&gt;epmd&lt;/code&gt; 始终在本地节点上，但是如果几个实例正在使用主机上的不同端口运行，则可以使用 &lt;code&gt;-port&lt;/code&gt; 选项在实例之间进行选择。</target>
        </trans-unit>
        <trans-unit id="e10be32239987c6f4a5a6c8dce5e7fc454e9dfca" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt;. For example, the following pattern changes the convention to CR:</source>
          <target state="translated">这些将覆盖默认值和指定为 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 的选项。例如，以下模式将约定更改为CR：</target>
        </trans-unit>
        <trans-unit id="76493b00ea7c71eb89b79e6053d97efaadb6e80f" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to the compiling function, but they can themselves be overridden by options specified to a matching function. Notice that these special settings, which are not Perl-compatible, are recognized only at the very start of a pattern, and that they must be in upper case. If more than one of them is present, the last one is used. They can be combined with a change of newline convention; for example, a pattern can start with:</source>
          <target state="translated">这些设置覆盖了默认值和指定给编译函数的选项,但是它们本身也可以被指定给匹配函数的选项所覆盖。请注意,这些特殊的设置并不兼容Perl,只有在模式的开头才会被识别,而且它们必须是大写的。如果它们中有一个以上的设置,则使用最后一个。它们可以与换行约定结合起来,例如,一个模式可以用以下开头。</target>
        </trans-unit>
        <trans-unit id="7c8826c9e11e1f3d846a339b100ceac99eba779d" translate="yes" xml:space="preserve">
          <source>These packet types only have effect on receiving. When sending a packet, it is the responsibility of the application to supply a correct header. On receiving, however, one message is sent to the controlling process for each complete packet received, and, similarly, each call to &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; returns one complete packet. The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">这些数据包类型仅对接收有效。发送数据包时，应用程序有责任提供正确的标头。但是，在接收时，对于接收到的每个完整数据包，将一条消息发送到控制过程，并且类似地，对 &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; 的每次调用都返回一个完整数据包。标头&lt;strong&gt;未&lt;/strong&gt;剥离。</target>
        </trans-unit>
        <trans-unit id="703061c1f2854688bcb586643b95905fd657c226" translate="yes" xml:space="preserve">
          <source>These parameters can be modified by the user with the following configuration term:</source>
          <target state="translated">这些参数可以由用户通过以下配置项进行修改。</target>
        </trans-unit>
        <trans-unit id="019f3eb722d3988d7298c6a669ca65df0fbbaa93" translate="yes" xml:space="preserve">
          <source>These questions are not always trivial to answer. Some benchmarks might be needed to back up your theory and to avoid making things slower if your theory is wrong. For details, see &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些问题并非总是微不足道的。如果您的理论是错误的，可能需要一些基准来支持您的理论并避免使事情变慢。有关详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="764b3f2b692c282ad0bd05c88a3b6913fb526534" translate="yes" xml:space="preserve">
          <source>These record definitions use the &quot;new&quot; spelling 'adaptation', not the deprecated 'adaption', regardless of which spelling the underlying C API uses.</source>
          <target state="translated">这些记录定义使用 &quot;新的 &quot;拼写 &quot;adaptation&quot;,而不是被废弃的 &quot;adapttion&quot;,无论底层C API使用哪种拼写。</target>
        </trans-unit>
        <trans-unit id="dc5ac270ae2ee1136906b421f96b332ee47c42ac" translate="yes" xml:space="preserve">
          <source>These relations are interpreted as follows: if we are in state &lt;code&gt;S&lt;/code&gt; and event &lt;code&gt;E&lt;/code&gt; occurs, we are to perform actions &lt;code&gt;A&lt;/code&gt; and make a transition to state &lt;code&gt;S'&lt;/code&gt;. Notice that &lt;code&gt;S'&lt;/code&gt; can be equal to &lt;code&gt;S&lt;/code&gt; and that &lt;code&gt;A&lt;/code&gt; can be empty.</source>
          <target state="translated">这些关系的解释如下：如果我们处于状态 &lt;code&gt;S&lt;/code&gt; 且发生事件 &lt;code&gt;E&lt;/code&gt; ，则我们将执行动作 &lt;code&gt;A&lt;/code&gt; 并转换为状态 &lt;code&gt;S'&lt;/code&gt; 。请注意， &lt;code&gt;S'&lt;/code&gt; 可以等于 &lt;code&gt;S&lt;/code&gt; ，而 &lt;code&gt;A&lt;/code&gt; 可以为空。</target>
        </trans-unit>
        <trans-unit id="663a0dde4969fddd76e6f124e908bc76a6818654" translate="yes" xml:space="preserve">
          <source>These services are controlled through the process &lt;code&gt;global_name_server&lt;/code&gt; that exists on every node. The global name server starts automatically when a node is started. With the term &lt;strong&gt;global&lt;/strong&gt; is meant over a system consisting of many Erlang nodes.</source>
          <target state="translated">这些服务通过每个节点上存在的进程 &lt;code&gt;global_name_server&lt;/code&gt; 进行控制。启动节点时，全局名称服务器将自动启动。术语&amp;ldquo; &lt;strong&gt;全局&amp;rdquo;&lt;/strong&gt;是指由许多Erlang节点组成的系统。</target>
        </trans-unit>
        <trans-unit id="18b3db7ac68ef66e01ea9e3110a4d7998bc037fb" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; when it is called with an &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过以下方式调用这些状态转换动作：从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; （使用 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt; 调用时），从 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 返回它们，或将其赋予 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f84a998101580824af52c1efde9742c062b4f3ac" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些状态转换动作可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或将它们赋予 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用。</target>
        </trans-unit>
        <trans-unit id="61a80d0c0fec3872bf24b97867cc3c3fed9d0143" translate="yes" xml:space="preserve">
          <source>These tests cannot (always) be done automatically when cross compiling. You usually do not need to set these variables.</source>
          <target state="translated">这些测试不能(总是)在交叉编译时自动完成。你通常不需要设置这些变量。</target>
        </trans-unit>
        <trans-unit id="2d05ecef6dec2328daa1fa8983fc44a7ac6b969f" translate="yes" xml:space="preserve">
          <source>These three BIFs do conversions that would be difficult (or impossible) to do in Erlang.</source>
          <target state="translated">这三个BIF可以完成在Erlang中很难(或不可能)完成的转换。</target>
        </trans-unit>
        <trans-unit id="9fc1faee4aad725a39321bd959c62d7b61fc838d" translate="yes" xml:space="preserve">
          <source>These three tables, &lt;code&gt;employees&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, and &lt;code&gt;projects&lt;/code&gt;, are made up of real records. The following database content is stored in the tables and is built on relationships. These tables are &lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, and &lt;code&gt;in_proj&lt;/code&gt;.</source>
          <target state="translated">这三个表 &lt;code&gt;employees&lt;/code&gt; ， &lt;code&gt;dept&lt;/code&gt; 和 &lt;code&gt;projects&lt;/code&gt; 由真实记录组成。以下数据库内容存储在表中，并且建立在关系上。这些表是 &lt;code&gt;manager&lt;/code&gt; ， &lt;code&gt;at_dep&lt;/code&gt; 和 &lt;code&gt;in_proj&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be4aeb784d73a7483bb30162082ef141d284732" translate="yes" xml:space="preserve">
          <source>These timeout actions sets timeout &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些超时操作设置超时 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1c1c65f29a414599f1da742468bf0977b89b3ea" translate="yes" xml:space="preserve">
          <source>These tuples are strictly monotonically ordered on the current runtime system instance according to creation time. It is important that the monotonic time is in the first element (the most significant element when comparing two-tuples). Using the monotonic time in the tuples, you can calculate time between events.</source>
          <target state="translated">这些元组在当前运行时系统实例上按照创建时间严格单调排序。重要的是,单调时间在第一个元素中(比较两个元组时最重要的元素)。使用元组中的单调时间,可以计算事件之间的时间。</target>
        </trans-unit>
        <trans-unit id="d52f80b222da3d294b0f671c73049263b3d9e584" translate="yes" xml:space="preserve">
          <source>These two functions are provided in the standard module &lt;code&gt;lists&lt;/code&gt;. &lt;code&gt;foreach&lt;/code&gt; takes a list and applies a fun to every element in the list. &lt;code&gt;map&lt;/code&gt; creates a new list by applying a fun to every element in a list. Going back to the shell, &lt;code&gt;map&lt;/code&gt; is used and a fun to add 3 to every element of a list:</source>
          <target state="translated">标准模块 &lt;code&gt;lists&lt;/code&gt; 中提供了这两个功能。 &lt;code&gt;foreach&lt;/code&gt; 获取一个列表，并对列表中的每个元素都添加了乐趣。 &lt;code&gt;map&lt;/code&gt; 通过将乐趣应用于列表中的每个元素来创建新列表。回到外壳，使用 &lt;code&gt;map&lt;/code&gt; 并为列表中的每个元素添加3的乐趣：</target>
        </trans-unit>
        <trans-unit id="4144563beb40dfa20763e7a44f564ed7df7e5fe8" translate="yes" xml:space="preserve">
          <source>These two functions have a similar structure. They both iterate over a list and do something to each element in the list. The &quot;something&quot; is passed on as an extra argument to the function that does this.</source>
          <target state="translated">这两个函数有类似的结构。它们都对一个列表进行迭代,并对列表中的每个元素做一些事情。这个 &quot;东西 &quot;是作为额外的参数传递给做这件事的函数的。</target>
        </trans-unit>
        <trans-unit id="6bf31d937cdb8656e463da3517deb67f3a158915" translate="yes" xml:space="preserve">
          <source>These two functions look up an executable program, with the specified name and a search path, in the same way as the underlying OS. &lt;code&gt;find_executable/1&lt;/code&gt; uses the current execution path (that is, the environment variable &lt;code&gt;PATH&lt;/code&gt; on Unix and Windows).</source>
          <target state="translated">这两个函数以与基础OS相同的方式查找具有指定名称和搜索路径的可执行程序。 &lt;code&gt;find_executable/1&lt;/code&gt; 使用当前的执行路径（即，Unix和Windows上的环境变量 &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e0d074a20ddd5e5f33562cc40bc5760ad507e2a6" translate="yes" xml:space="preserve">
          <source>These two pieces work in concert. Basically, the &lt;code&gt;Collector&lt;/code&gt; receives &lt;code&gt;Raw Trace Data&lt;/code&gt; and processes it into &lt;code&gt;Events&lt;/code&gt; in a &lt;code&gt;et&lt;/code&gt; specific format (defined in &lt;code&gt;et/include/et.hrl&lt;/code&gt;). The &lt;code&gt;Viewer&lt;/code&gt; interrogates the &lt;code&gt;Collector&lt;/code&gt; and displays an interactive representation of the data.</source>
          <target state="translated">这两个部分协同工作。基本上， &lt;code&gt;Collector&lt;/code&gt; 接收 &lt;code&gt;Raw Trace Data&lt;/code&gt; 并将其以 &lt;code&gt;et&lt;/code&gt; 特定格式（在 &lt;code&gt;et/include/et.hrl&lt;/code&gt; 中定义）处理为 &lt;code&gt;Events&lt;/code&gt; 。该 &lt;code&gt;Viewer&lt;/code&gt; 询问 &lt;code&gt;Collector&lt;/code&gt; 和显示数据的交互式表示。</target>
        </trans-unit>
        <trans-unit id="dda87b11f0a5cbea6a2795c81d6b6e5706e62c96" translate="yes" xml:space="preserve">
          <source>These two types are often not needed, as the socket automatically switches from &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;http_bin&lt;/code&gt; to &lt;code&gt;httph&lt;/code&gt;/&lt;code&gt;httph_bin&lt;/code&gt; internally after the first line is read. However, there can be occasions when they are useful, such as parsing trailers from chunked encoding.</source>
          <target state="translated">通常不需要这两种类型，因为在读取第一行之后， &lt;code&gt;httph_bin&lt;/code&gt; 内部自动从 &lt;code&gt;http&lt;/code&gt; / &lt;code&gt;http_bin&lt;/code&gt; 切换到 &lt;code&gt;httph&lt;/code&gt; / httph_bin。但是，有时可能有用，例如从分块编码中解析预告片。</target>
        </trans-unit>
        <trans-unit id="1c70e7bfedf23869960675efaf18a91ce706b0d2" translate="yes" xml:space="preserve">
          <source>These values can be used to determine order between events on the runtime system instance. That is, if both &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; and &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; are executed by different processes (or the same process) on the same runtime system instance and &lt;code&gt;X &amp;lt; Y&lt;/code&gt;, we know that &lt;code&gt;X&lt;/code&gt; was created before &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">这些值可用于确定运行时系统实例上事件之间的顺序。也就是说，如果 &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; 和 &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; 都由同一运行时系统实例上的不同进程（或同一进程）执行，并且 &lt;code&gt;X &amp;lt; Y&lt;/code&gt; ，我们知道即 &lt;code&gt;X&lt;/code&gt; 是之前创建 &lt;code&gt;Y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64037abeafa784d21870f15a8f477ebe7f35dde2" translate="yes" xml:space="preserve">
          <source>These variables currently have &lt;strong&gt;no&lt;/strong&gt; effect if you configure using the &lt;code&gt;configure&lt;/code&gt; script directly.</source>
          <target state="translated">这些变量目前有&lt;strong&gt;没有&lt;/strong&gt;影响，如果你是使用的 &lt;code&gt;configure&lt;/code&gt; 直接脚本。</target>
        </trans-unit>
        <trans-unit id="e4eeacbbfedd76f9009cc450f49274f9b8f50cf0" translate="yes" xml:space="preserve">
          <source>These verbs differ in exactly what kind of failure occurs when backtracking reaches them. The behavior described below is what occurs when the verb is not in a subroutine or an assertion. Subsequent sections cover these special cases.</source>
          <target state="translated">这些动词的不同之处在于当回溯到它们时,究竟会发生什么样的失败。下面描述的行为是当动词不在子程序或断言中时发生的行为。后面的章节会涉及这些特殊情况。</target>
        </trans-unit>
        <trans-unit id="bcb7ed1357b82ff56473fd5066848225a0c020e2" translate="yes" xml:space="preserve">
          <source>They can also be combined with the (*UTF8), (*UTF), or (*UCP) special sequences. Inside a character class, \R is treated as an unrecognized escape sequence, and so matches the letter &quot;R&quot; by default.</source>
          <target state="translated">它们也可以与(*UTF8)、(*UTF)或(*UCP)特殊序列组合。在一个字符类中,\R被视为未识别的转义序列,因此默认与字母 &quot;R &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="4f19fb9eb943279dbf1aab1f1a7e9449243b24c1" translate="yes" xml:space="preserve">
          <source>They can then be used in either of the following ways:</source>
          <target state="translated">然后,它们可以以下列任何一种方式使用:</target>
        </trans-unit>
        <trans-unit id="f10af1c6b334490e5b1459d0c8bfcff29264cd5a" translate="yes" xml:space="preserve">
          <source>Thin space</source>
          <target state="translated">狭窄的空间</target>
        </trans-unit>
        <trans-unit id="6196f53beeed99bac9dd3ff39c523037e81c3134" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. If you still need to use it, always &lt;code&gt;call os:type()&lt;/code&gt; first.</source>
          <target state="translated">使用此功能前请三思。如果仍然需要使用它，请始终先 &lt;code&gt;call os:type()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea8743046d2b98d1556841772481beb6c8b7be7" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. Use module &lt;code&gt;filename&lt;/code&gt; if you want to inspect or build filenames in a portable way. Avoid matching on atom &lt;code&gt;Osname&lt;/code&gt;.</source>
          <target state="translated">使用此功能前请三思。如果要以便携式方式检查或生成文件名，请使用模块 &lt;code&gt;filename&lt;/code&gt; 名。避免在原子 &lt;code&gt;Osname&lt;/code&gt; 上匹配。</target>
        </trans-unit>
        <trans-unit id="d592d2f7893043a1b846652e39ab1418e618bc4e" translate="yes" xml:space="preserve">
          <source>This (most common) scenario simply supports that each &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver loads it when needed and unloads it when no longer needed. The driver is always reference counted and as long as a process keeping the driver loaded is still alive, the driver is present in the system.</source>
          <target state="translated">此（最常见）方案仅支持驱动程序的每个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 在需要时加载它，并在不再需要时卸载它。该驱动程序始终按引用计数，只要保持加载该驱动程序的进程仍处于活动状态，该驱动程序就存在于系统中。</target>
        </trans-unit>
        <trans-unit id="cb6a47e588a181452c326fa39e3e06a8bbaf215e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;at_dep&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;at_dep&lt;/code&gt; 记录具有Erlang元组表示形式 &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb50969a4322693220f1622878a187ec8ef7865" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;employee&lt;/code&gt; record has the Erlang record/tuple representation &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;employee&lt;/code&gt; 记录具有Erlang记录/元组表示形式 &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6f78a7a573f4788a961abb21d13018ab8263739" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;in_proj&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;in_proj&lt;/code&gt; 记录具有Erlang元组表示形式 &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30eaf1b61fcff886440404502320b8087244781b" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how a simple manager can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">本&lt;strong&gt;实施示例&lt;/strong&gt;部分介绍了如何使用SNMP开发工具包实施简单的管理器。</target>
        </trans-unit>
        <trans-unit id="ffdeda27af47f2d41561b45e8678ebc080646b29" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how an MIB can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">本&lt;strong&gt;实施示例&lt;/strong&gt;部分介绍了如何使用SNMP开发工具包实施MIB。</target>
        </trans-unit>
        <trans-unit id="f8285515d6a8ffd60d079855281d19dbb335db5a" translate="yes" xml:space="preserve">
          <source>This BIF can be removed in a future version of the Beam machine without prior warning. It is unlikely to be implemented in other Erlang implementations.</source>
          <target state="translated">这个BIF可以在未来的Beam机器版本中被删除,而不会事先警告。它不太可能在其他Erlang实现中实现。</target>
        </trans-unit>
        <trans-unit id="d2c9f52ffa82790c5add5ce609c3b465fa6b5f87" translate="yes" xml:space="preserve">
          <source>This BIF is always to be used for hashing terms. It distributes small integers better than &lt;code&gt;phash/2&lt;/code&gt;, and it is faster for bignums and binaries.</source>
          <target state="translated">此BIF始终用于哈希术语。它比 &lt;code&gt;phash/2&lt;/code&gt; 更好地分配小整数，并且对于bignums和binaries分配更快。</target>
        </trans-unit>
        <trans-unit id="ca02fa554a6262c386a3db4a859b0b9b57b609dd" translate="yes" xml:space="preserve">
          <source>This BIF is documented for completeness. Usually &lt;code&gt;is_record/2&lt;/code&gt; is to be used.</source>
          <target state="translated">记录此BIF是为了完整性。通常使用 &lt;code&gt;is_record/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e919cc7df793008049931bcf01d09ffb06683260" translate="yes" xml:space="preserve">
          <source>This BIF is intended for &lt;strong&gt;debugging only&lt;/strong&gt;. For all other purposes, use &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此BIF仅用于&lt;strong&gt;调试&lt;/strong&gt;。对于所有其他目的，请使用 &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b16cda9185776fda7cf953473f68ed8eae22005c" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging and is not to be used in application programs.</source>
          <target state="translated">这个BIF是用来调试的,不能用在应用程序中。</target>
        </trans-unit>
        <trans-unit id="3a485a9d729fff78ad515ca89ab62a61dc168854" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging only.</source>
          <target state="translated">此BIF仅用于调试。</target>
        </trans-unit>
        <trans-unit id="33eab8a0dcb284396b1bdbf0824f52f98a707748" translate="yes" xml:space="preserve">
          <source>This BIF is intended for the code server (see &lt;code&gt;code(3)&lt;/code&gt;) and is not to be used elsewhere.</source>
          <target state="translated">此BIF用于代码服务器（请参阅 &lt;code&gt;code(3)&lt;/code&gt; ），并且不能在其他地方使用。</target>
        </trans-unit>
        <trans-unit id="bbc3f97203615ffb6be54801dfb7bad70393f210" translate="yes" xml:space="preserve">
          <source>This BIF is mainly intended for debugging, but it can sometimes be useful in library functions that need to verify, for example, the arity of a fun.</source>
          <target state="translated">这个BIF主要是为了调试,但有时在需要验证的库函数中也很有用,例如,一个fun的arity。</target>
        </trans-unit>
        <trans-unit id="ed42f39086e8ec9c7b1c29cd5a589cf6f72ca9ff" translate="yes" xml:space="preserve">
          <source>This BIF is useful for builders of cross-reference tools.</source>
          <target state="translated">这个BIF对交叉参考工具的构建者很有用。</target>
        </trans-unit>
        <trans-unit id="c6cc75865613bc58e0eb7ecb4f457c6d233e733d" translate="yes" xml:space="preserve">
          <source>This DNS client can resolve DNS records even if it is not used for normal name resolving in the node.</source>
          <target state="translated">该DNS客户端即使不用于节点的正常名称解析,也可以解析DNS记录。</target>
        </trans-unit>
        <trans-unit id="babe61c293ec427280b1edacc01c731077dee4c0" translate="yes" xml:space="preserve">
          <source>This Efficiency Guide cannot really teach you how to write efficient code. It can give you a few pointers about what to avoid and what to use, and some understanding of how certain language features are implemented. This guide does not include general tips about optimization that works in any language, such as moving common calculations out of loops.</source>
          <target state="translated">本效率指南不能真正教你如何编写高效的代码。它可以为你提供一些关于什么是应该避免的,什么是应该使用的指针,以及对某些语言特性如何实现的一些理解。本指南不包括在任何语言中都有效的关于优化的一般提示,例如将常用计算移出循环。</target>
        </trans-unit>
        <trans-unit id="ae1ff29eb10c59731ea6c65a3606a80e84b3335c" translate="yes" xml:space="preserve">
          <source>This Erlang/OTP application supplies a framework for building applications that needs to utilize the Megaco/H.248 protocol.</source>
          <target state="translated">这个Erlang/OTP应用程序为构建需要利用Megaco/H.248协议的应用程序提供了一个框架。</target>
        </trans-unit>
        <trans-unit id="b18f63f410f90b5069c9dc2f1ae77d811c62158c" translate="yes" xml:space="preserve">
          <source>This MIB is not loaded by default.</source>
          <target state="translated">该MIB默认不加载。</target>
        </trans-unit>
        <trans-unit id="a407b3d8ce92982dd769f80205472707dd33acd9" translate="yes" xml:space="preserve">
          <source>This MIB is now loaded into the agent, and a manager can ask questions. As an example of this, we start another Erlang system and the simple Erlang manager in the toolkit:</source>
          <target state="translated">现在这个MIB已经加载到代理中,经理可以提出问题。作为一个例子,我们启动另一个Erlang系统和工具箱中的简单Erlang管理器。</target>
        </trans-unit>
        <trans-unit id="8bee977533f2540fecf48c418b1e1c4b1c9441e8" translate="yes" xml:space="preserve">
          <source>This PCRE pattern solves the nested parentheses problem (assume that option &lt;code&gt;extended&lt;/code&gt; is set so that whitespace is ignored):</source>
          <target state="translated">此PCRE模式解决了嵌套括号问题（假定已设置 &lt;code&gt;extended&lt;/code&gt; 选项，以便忽略空格）：</target>
        </trans-unit>
        <trans-unit id="ba3b1c781a2b003455c5f276cc7adab4167d61a9" translate="yes" xml:space="preserve">
          <source>This Reference Manual describes the Mnesia API. This includes functions that define and manipulate Mnesia tables.</source>
          <target state="translated">本参考手册介绍了Mnesia API。这包括定义和操作Mnesia表的函数。</target>
        </trans-unit>
        <trans-unit id="5a1ea321f8ef4337012dd060505384a468b6d8b6" translate="yes" xml:space="preserve">
          <source>This Reference Manual uses a table of persons to illustrate various examples. The following record definition is assumed:</source>
          <target state="translated">本《参考手册》使用人员表来说明各种例子。假设记录定义如下:</target>
        </trans-unit>
        <trans-unit id="eba208a5a64a9fe2d23e89684b28919d090b1bf5" translate="yes" xml:space="preserve">
          <source>This User's Guide describes how to build Mnesia database applications, and how to integrate and use the Mnesia database management system with OTP. Programming constructs are described, and numerous programming examples are included to illustrate the use of Mnesia.</source>
          <target state="translated">本用户指南介绍了如何建立Mnesia数据库应用程序,以及如何将Mnesia数据库管理系统与OTP集成和使用。本指南描述了编程结构,并包括许多编程实例,以说明Mnesia的使用。</target>
        </trans-unit>
        <trans-unit id="d7c2e051140679b5fabfd3850166d5e44acd182d" translate="yes" xml:space="preserve">
          <source>This User's Guide is organized as follows:</source>
          <target state="translated">本用户指南的组织结构如下。</target>
        </trans-unit>
        <trans-unit id="6e07c970a29206fa6177bb430aa23651cee332f1" translate="yes" xml:space="preserve">
          <source>This access functions example shows how &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; can be implemented using &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; from outside the module:</source>
          <target state="translated">此访问函数示例演示如何从模块外部使用 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; 实现 &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e453611cc830c0fe9b4a7d78e62c5d3c550a27db" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">这将在整个表 &lt;code&gt;Tab&lt;/code&gt; 上获得 &lt;code&gt;LockKind&lt;/code&gt; 类型的锁。</target>
        </trans-unit>
        <trans-unit id="f91dd38ac67f0332e475b1b711e06f95a62ba56f" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the global resource &lt;code&gt;GlobalKey&lt;/code&gt;. The lock is acquired on all active nodes in the &lt;code&gt;Nodes&lt;/code&gt; list.</source>
          <target state="translated">该收购类型的锁 &lt;code&gt;LockKind&lt;/code&gt; 对全球资源 &lt;code&gt;GlobalKey&lt;/code&gt; 。将在&amp;ldquo; &lt;code&gt;Nodes&lt;/code&gt; 列表中的所有活动节点上获取锁定。</target>
        </trans-unit>
        <trans-unit id="52b66d36db3f8d918f682c24c470f8a1a0d1add9" translate="yes" xml:space="preserve">
          <source>This action does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead stores the specified &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; for insertion after all actions have been executed.</source>
          <target state="translated">此操作不设置任何 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，而是存储指定的 &lt;code&gt;EventType&lt;/code&gt; 和 &lt;code&gt;EventContent&lt;/code&gt; 以便在执行所有操作后插入。</target>
        </trans-unit>
        <trans-unit id="49d5b8cf3248f457c3e4fd7bf845d80256d7c600" translate="yes" xml:space="preserve">
          <source>This actually is a simulation of the process &lt;code&gt;Events&lt;/code&gt; caused by a &lt;code&gt;Mnesia&lt;/code&gt; transaction that writes a record in a local table:</source>
          <target state="translated">这实际上是对 &lt;code&gt;Mnesia&lt;/code&gt; 事务引起的流程 &lt;code&gt;Events&lt;/code&gt; 的模拟，该事务在本地表中写入一条记录：</target>
        </trans-unit>
        <trans-unit id="dbd8d5b06b09c15de60879a1a8a9947df8335726" translate="yes" xml:space="preserve">
          <source>This address family only works on Unix-like systems.</source>
          <target state="translated">这个地址族只适用于类Unix系统。</target>
        </trans-unit>
        <trans-unit id="63d593ef2ab6f3e8b14006b9f741f5c521ea7089" translate="yes" xml:space="preserve">
          <source>This affects the access logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">这会影响由 &lt;code&gt;mod_log&lt;/code&gt; 和 &lt;code&gt;mod_disk_log&lt;/code&gt; 编写的访问日志。</target>
        </trans-unit>
        <trans-unit id="2fd1765db5e4a1421a5a77cd061597e64ef02887" translate="yes" xml:space="preserve">
          <source>This affects the error logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">这会影响由 &lt;code&gt;mod_log&lt;/code&gt; 和 &lt;code&gt;mod_disk_log&lt;/code&gt; 写入的错误日志。</target>
        </trans-unit>
        <trans-unit id="bbd6bb60897f850ec49a0aac99503d287bd1842d" translate="yes" xml:space="preserve">
          <source>This allows info events to pass through to the default handler, and be printed to the terminal as well. If there are many info events, it can be useful to print these to a file instead.</source>
          <target state="translated">这允许信息事件传递到默认的处理程序,并打印到终端。如果有很多信息事件,可以将这些事件打印到文件中。</target>
        </trans-unit>
        <trans-unit id="23e19f7d8ad7331e73f9393236fe1782f10bda23" translate="yes" xml:space="preserve">
          <source>This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl's &lt;code&gt;/x&lt;/code&gt; option, and it can be changed within a pattern by a &lt;code&gt;(?x)&lt;/code&gt; option setting.</source>
          <target state="translated">这还会导致在字符类外部的未转义的＃与下一个换行符（包括）之间的字符被忽略。这等效于Perl的 &lt;code&gt;/x&lt;/code&gt; 选项，并且可以通过 &lt;code&gt;(?x)&lt;/code&gt; 选项设置在模式内进行更改。</target>
        </trans-unit>
        <trans-unit id="58f3cb66f380a5c19ef8ab400cfe6287edaa6dfa" translate="yes" xml:space="preserve">
          <source>This also means that if a user implement their own transport service then it has to maintain its own statistics.</source>
          <target state="translated">这也意味着,如果用户实现了自己的传输服务,那么就必须维护自己的统计数据。</target>
        </trans-unit>
        <trans-unit id="c7dd22038e1768c05bfb1a8b06817075c1c09560" translate="yes" xml:space="preserve">
          <source>This appendix describes the conversion of SNMPv2 to SNMPv1 error messages. The instrumentation functions should return v2 error messages.</source>
          <target state="translated">本附录描述了SNMPv2到SNMPv1错误信息的转换。仪表功能应返回v2错误信息。</target>
        </trans-unit>
        <trans-unit id="87860fce150658815e0dd8f84b7b2d2085183f77" translate="yes" xml:space="preserve">
          <source>This application covers all features of ASN.1 up to the 1997 edition of the specification. In the 2002 edition, new features were introduced. The following features of the 2002 edition are fully or partly supported:</source>
          <target state="translated">本应用程序涵盖1997年版规范之前ASN.1的所有功能。在2002年版中,引入了新的功能。完全或部分支持2002年版的下列特征:</target>
        </trans-unit>
        <trans-unit id="569634e92b8ce1ce008d5489ba01f7e7d69d8d45" translate="yes" xml:space="preserve">
          <source>This application has been deprecated and will be removed in a furture release.</source>
          <target state="translated">该应用已被废弃,将在后续版本中删除。</target>
        </trans-unit>
        <trans-unit id="dfc6af9c7770c0d0747ed2380e862e5393774125" translate="yes" xml:space="preserve">
          <source>This application provides an Erlang interface to communicate with relational SQL-databases. It is built on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to the database that you want to connect to.</source>
          <target state="translated">这个应用程序提供了一个Erlang接口来与关系型SQL数据库进行通信,它是建立在Microsofts ODBC接口之上的,因此需要你有一个连接到数据库的ODBC驱动。它建立在Microsofts ODBC接口之上,因此需要你有一个连接到数据库的ODBC驱动。</target>
        </trans-unit>
        <trans-unit id="33c8dd3d5797a890a9a711bb22cf2594354b0bee" translate="yes" xml:space="preserve">
          <source>This approach is always preferred over the other alternatives described below. This both from a performance perspective and a system characteristics perspective.</source>
          <target state="translated">这种方法总是优于下文所述的其他选择。无论是从性能的角度还是从系统特性的角度来看,都是如此。</target>
        </trans-unit>
        <trans-unit id="8068bc8d1c806d61b5dde8f35515f5de0ccd108c" translate="yes" xml:space="preserve">
          <source>This approach is probably easier for an Erlanger but if you need to use real XSLT stylesheets in order to &quot;comply to the standard&quot; there is an adapter available to the Sablotron XSLT package which is written i C++. See also the &lt;code&gt;Tutorial&lt;/code&gt;.</source>
          <target state="translated">对于Erlanger来说，这种方法可能更容易，但是如果您需要使用真实的XSLT样式表以&amp;ldquo;符合标准&amp;rdquo;，则可以使用用C ++编写的Sablotron XSLT软件包提供一个适配器。另请参见 &lt;code&gt;Tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f62d188dacb48bbbcc2b2321f9f579397d8bbfe1" translate="yes" xml:space="preserve">
          <source>This associates the name &lt;code&gt;a&lt;/code&gt; with the top-level &lt;code&gt;node&lt;/code&gt; entry. For this to work, the configuration file must at least contain:</source>
          <target state="translated">这会将名称 &lt;code&gt;a&lt;/code&gt; 与顶级 &lt;code&gt;node&lt;/code&gt; 条目相关联。为此，配置文件必须至少包含：</target>
        </trans-unit>
        <trans-unit id="3e34095000c0319f418ac3ee68cd3bf8ccd8bc10" translate="yes" xml:space="preserve">
          <source>This assumes that this is the first line of the input text, and that &lt;code&gt;'$end'&lt;/code&gt; is the distinguished &lt;code&gt;end_of_input&lt;/code&gt; symbol.</source>
          <target state="translated">假定这是输入文本的第一行，并且 &lt;code&gt;'$end'&lt;/code&gt; 是专有的 &lt;code&gt;end_of_input&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="821b03bacc21c4d7e259e58631986fc8983788a2" translate="yes" xml:space="preserve">
          <source>This attribute is to be specified first and is the only mandatory attribute.</source>
          <target state="translated">这个属性要先指定,而且是唯一的强制性属性。</target>
        </trans-unit>
        <trans-unit id="d5e89f840b948b0e856ea77d5bc34a2eb62f41fa" translate="yes" xml:space="preserve">
          <source>This attribute is used by tools, such as Yecc, to inform the compiler that the source program is generated by another tool. It also indicates the correspondence of source files to lines of the original user-written file, from which the source program is produced.</source>
          <target state="translated">这个属性被Yecc等工具用来通知编译器源程序是由其他工具生成的。它还表明源文件与用户编写的原始文件的行数的对应关系,源程序就是从该文件中产生的。</target>
        </trans-unit>
        <trans-unit id="e21a2982771a0d227b0a5afc10f4b081e89b3ac5" translate="yes" xml:space="preserve">
          <source>This attribute names a function that is to be run automatically when a module is loaded. For more information, see &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此属性命名一个在模块加载时自动运行的函数。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1862f101a5a9233b48a831149fc7167f1c97802b" translate="yes" xml:space="preserve">
          <source>This automatically starts the error logger event manager, and adds &lt;code&gt;error_logger&lt;/code&gt; as a handler to Logger, with the following configuration:</source>
          <target state="translated">这将自动启动错误记录器事件管理器，并使用以下配置将 &lt;code&gt;error_logger&lt;/code&gt; 作为处理程序添加到Logger中：</target>
        </trans-unit>
        <trans-unit id="b6abecdecbe55a6c353c6503f8fff17fe757dd78" translate="yes" xml:space="preserve">
          <source>This behavior appeared in Erlang/OTP 19.0. In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; was introduced. In OTP 20.0 the &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">此行为出现在Erlang / OTP 19.0中。在OTP 19.1中，对 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 的返回元组进行了向后不兼容的更改，并引入了强制性的回调函数 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 。在OTP 20.0中，添加了 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="785543b1d2c442c04e0906335bd46635b1eb96f6" translate="yes" xml:space="preserve">
          <source>This behavior can be controlled through command-line flag &lt;code&gt;-code_path_choice Choice&lt;/code&gt;. If the flag is set to &lt;code&gt;relaxed&lt;/code&gt;, the code server instead chooses a suitable directory depending on the actual file structure. If a regular application &lt;code&gt;ebin&lt;/code&gt; directory exists, it is chosen. Otherwise, the directory &lt;code&gt;ebin&lt;/code&gt; in the archive is chosen if it exists. If neither of them exists, the original directory is chosen.</source>
          <target state="translated">可以通过命令行标志 &lt;code&gt;-code_path_choice Choice&lt;/code&gt; 来控制此行为。如果该标志设置为 &lt;code&gt;relaxed&lt;/code&gt; ，则代码服务器将根据实际文件结构选择合适的目录。如果存在常规应用程序 &lt;code&gt;ebin&lt;/code&gt; 目录，则将其选中。否则，将选择存档中的目录 &lt;code&gt;ebin&lt;/code&gt; （如果存在）。如果它们都不存在，则选择原始目录。</target>
        </trans-unit>
        <trans-unit id="53636ccb870bbfa8ce6166a610a444015328245d" translate="yes" xml:space="preserve">
          <source>This behavior module implements the back end of the Erlang tracing system. The functions in this module are called whenever a trace probe is triggered. Both the &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;trace&lt;/code&gt; functions are called in the context of the entity that triggered the trace probe. This means that the overhead by having the tracing enabled is greatly effected by how much time is spent in these functions. So, do as little work as possible in these functions.</source>
          <target state="translated">该行为模块实现了Erlang跟踪系统的后端。每当触发跟踪探测时，就会调用此模块中的功能。在触发跟踪探针的实体的上下文中调用了已 &lt;code&gt;enabled&lt;/code&gt; 和 &lt;code&gt;trace&lt;/code&gt; 功能。这意味着启用跟踪功能的开销在这些功能中花费了多少时间而受到很大影响。因此，在这些功能中要做的工作尽可能少。</target>
        </trans-unit>
        <trans-unit id="70c20f09b1094d916dd54fcb5f009aa1d7c32e52" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块提供了一个监督者桥，该过程将未根据OTP设计原则设计的子系统连接到监督树。主管网桥位于主管与子系统之间。它的行为就像是其自己的主管的真正主管，但与子系统的真正主管具有不同的界面。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce3316c8111b9876ff9b5ef8da2949d18e1dd45d" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">此行为模块提供了一个主管，一个监督其他进程（称为子进程）的进程。子进程可以是另一个主管或工作进程。通常使用 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 行为之一来实现工作进程。使用此模块实现的主管具有一组标准的接口功能，并且包括用于跟踪和错误报告的功能。监督程序用于构建称为监督树的分层过程结构，这是构建容错应用程序的一种好方法。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d6df5b9b0f7a74dbafdab8bc790e47d7e7f9481" translate="yes" xml:space="preserve">
          <source>This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically.</source>
          <target state="translated">该行为模块提供事件处理功能。它由一个通用的事件管理器进程组成,该进程具有任意数量的事件处理程序,可以动态地添加和删除。</target>
        </trans-unit>
        <trans-unit id="abfb5bf41909c33228afc455141ff017bc6cbde2" translate="yes" xml:space="preserve">
          <source>This behavior module provides the server of a client-server relation. A generic server process (&lt;code&gt;gen_server&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section &lt;code&gt;gen_server Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块为服务器提供了客户端-服务器关系。使用此模块实现的通用服务器进程（ &lt;code&gt;gen_server&lt;/code&gt; ）具有一组标准的接口功能，并包括用于跟踪和错误报告的功能。它也适合OTP监管树。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;gen_server Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfe536c202221de15418e3b0398e40a018dac1a4" translate="yes" xml:space="preserve">
          <source>This binds variable &lt;code&gt;B&lt;/code&gt; to integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">这将变量 &lt;code&gt;B&lt;/code&gt; 绑定到整数 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43864d6a93dcab0bbcc900bd0174b5bbab1fdc75" translate="yes" xml:space="preserve">
          <source>This call is equivalent to &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt;:</source>
          <target state="translated">此调用等效于 &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0cb45c675dbc6c57c7e83453d414ea4d5859f32a" translate="yes" xml:space="preserve">
          <source>This callback format consumes much memory, as the whole response must be generated before it is sent to the user. This callback format is deprecated. For new development, use &lt;code&gt;Module:Function/3&lt;/code&gt;.</source>
          <target state="translated">这种回调格式会消耗大量内存，因为必须在将整个响应发送给用户之前生成整个响应。不建议使用此回调格式。对于新开发，请使用 &lt;code&gt;Module:Function/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c021922a0bcd25050486be93ca9a01fe228c8b3e" translate="yes" xml:space="preserve">
          <source>This callback function is mandatory.</source>
          <target state="translated">这个回调函数是必须的。</target>
        </trans-unit>
        <trans-unit id="19c59aed8326cb258e589ba8cff9c5c632aa9fd0" translate="yes" xml:space="preserve">
          <source>This callback function is optional.</source>
          <target state="translated">这个回调函数是可选的。</target>
        </trans-unit>
        <trans-unit id="38e550ff4f657cf80a8775b069566d9feb16c83b" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;. In it any side effects needed by the tracer are to be done. The tracepoint payload is located in the &lt;code&gt;TraceTerm&lt;/code&gt;. The content of the &lt;code&gt;TraceTerm&lt;/code&gt; depends on which &lt;code&gt;TraceTag&lt;/code&gt; is triggered. &lt;code&gt;TraceTerm&lt;/code&gt; corresponds to the fourth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。在此过程中，将完成示踪剂所需的任何副作用。跟踪点有效负载位于 &lt;code&gt;TraceTerm&lt;/code&gt; 中。 &lt;code&gt;TraceTerm&lt;/code&gt; 的内容取决于触发了哪个 &lt;code&gt;TraceTag&lt;/code&gt; 。 &lt;code&gt;TraceTerm&lt;/code&gt; 对应于 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 中描述的跟踪元组中的第四个元素。</target>
        </trans-unit>
        <trans-unit id="d37d000bba6ae99564128c8b7446cc5273b6a04e" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="15198a7c2fc8240482ba94b944bdfc0b14e586ba" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="2aa5dde256677cc6703eaf4ec5d19bc2b8283932" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="6dcc032a652781d3a4cff57f32134bdf4ec6b88d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="cfff3392a7d289ca0c61ca7155845689c03dcb44" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="c24bf92b0df20158eb77c36643c943e9fdb3807a" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="b6742c8972ca63b4eed6ff400182d4ad91035680" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="6f48d6f8f965dcfd900008bb64742372d353ae2d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="7d06f96f4aade9b952b7ce9c8005f3b70b23dcd8" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint is triggered. It allows the tracer to decide whether a trace is to be generated or not. This check is made as early as possible to limit the amount of overhead associated with tracing. If &lt;code&gt;trace&lt;/code&gt; is returned, the necessary trace data is created and the trace callback of the tracer is called. If &lt;code&gt;discard&lt;/code&gt; is returned, this trace call is discarded and no call to trace is done.</source>
          <target state="translated">每当触发跟踪点时，都会调用此回调。它允许跟踪程序决定是否要生成跟踪。尽早进行此检查，以限制与跟踪相关的开销。如果返回 &lt;code&gt;trace&lt;/code&gt; ，则将创建必要的跟踪数据，并调用跟踪器的跟踪回调。如果返回 &lt;code&gt;discard&lt;/code&gt; ，则此跟踪调用将被丢弃，并且不会完成对跟踪的调用。</target>
        </trans-unit>
        <trans-unit id="94e6048cf0014e861feb66ee170c873413ff3161" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="6fa7e2961f153a4436cefe4499cc280336994838" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当具有跟踪标志的跟踪点调用时，都会调用此回调 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; 被触发。</target>
        </trans-unit>
        <trans-unit id="69b3512c1f3ede51a7ecf30950dad7b0634b3377" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="04e6a249465c46d45e283c5f1f0285668b198409" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="af6001baab0a6ade22947ab13bfa31245cf0abe6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="0be59b7c2110146187e5c0eeaf4bc0878afe0cb6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="334c413e0dbeba2235f5db1ca4ea0969695570e1" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当具有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; 的跟踪点被调用时，都会调用此回调。运行被触发。</target>
        </trans-unit>
        <trans-unit id="7c04ab99901eac2f63941068c90d7843bba53367" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="945a522c510e59f03864e9eeb3d8a618307d8e56" translate="yes" xml:space="preserve">
          <source>This callback is optional, so a callback module does not need to export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation of this function that returns &lt;code&gt;{State,Data}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块不需要导出它。该 &lt;code&gt;gen_statem&lt;/code&gt; 模块提供此功能的默认实现，它返回 &lt;code&gt;{State,Data}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adab3ff296df418bda26c9ab38b8afebec6b2122" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the event handler will crash with an &lt;code&gt;undef&lt;/code&gt; error reason.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果未实现 &lt;code&gt;code_change/3&lt;/code&gt; 时，在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的发行版升级/降级，则事件处理程序将因 &lt;code&gt;undef&lt;/code&gt; 错误原因而崩溃。</target>
        </trans-unit>
        <trans-unit id="02bb4941fa7a9741c99ed42c9b52e91f322657b1" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/4&lt;/code&gt; is not implemented the process will crash with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果在未实现 &lt;code&gt;code_change/4&lt;/code&gt; 的情况下在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的发行版升级/降级，则该过程将因退出原因 &lt;code&gt;undef&lt;/code&gt; 而崩溃。</target>
        </trans-unit>
        <trans-unit id="09246fb26a04b28ca2f447f072f0daaf17b1ea05" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the process will crash with an &lt;code&gt;undef&lt;/code&gt; exit reason.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果未实施 &lt;code&gt;code_change/3&lt;/code&gt; 时在 &lt;code&gt;appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的版本升级/降级，则该过程将因 &lt;code&gt;undef&lt;/code&gt; 退出原因而崩溃。</target>
        </trans-unit>
        <trans-unit id="449de06640c440754deb50b818d7f03da9dfc15a" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_event&lt;/code&gt; 模块提供此功能的默认实现，大约意想不到的日志 &lt;code&gt;Info&lt;/code&gt; 的消息，删除它，然后返回 &lt;code&gt;{noreply, State}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="642a938f2c13878b19e630eed4ff743e43a98666" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_event&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="33b5eb4eda106379d214a532dea20df13c6ee4a7" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供此功能的默认实现，大约意想不到的日志 &lt;code&gt;Info&lt;/code&gt; 的消息，删除它，然后返回 &lt;code&gt;{noreply, State}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0950a9f920ccec0ce58fea7dd4cc52647d84000" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that returns the callback module state.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供这个函数，返回回调模块状态的默认实现。</target>
        </trans-unit>
        <trans-unit id="d3374de84ad48d0fa717caa3233068cba7f0a810" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="ed16700adf3de2342c41a38a47218a24b4797c88" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_statem&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="b14aaa8a71c534451d8b2fa83d586d1d7132b252" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need to export it only if they return &lt;code&gt;{continue,Continue}&lt;/code&gt; from another callback. If continue is used and the callback is not implemented, the process will exit with &lt;code&gt;undef&lt;/code&gt; error.</source>
          <target state="translated">此回调是可选的，因此仅当回调模块从另一个回调返回 &lt;code&gt;{continue,Continue}&lt;/code&gt; 时，才需要导出该回调。如果使用continue并且未实现回调，则该过程将退出，并显示 &lt;code&gt;undef&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="d62e7ff4624439456f6274f30841bc2cd438369b" translate="yes" xml:space="preserve">
          <source>This callback is optional, so event handler modules need not export it. If a handler does not export this function, the &lt;code&gt;gen_event&lt;/code&gt; module uses the handler state directly for the purposes described below.</source>
          <target state="translated">此回调是可选的，因此事件处理程序模块无需导出它。如果处理程序未导出此函数，则 &lt;code&gt;gen_event&lt;/code&gt; 模块将为以下所述目的直接使用处理程序状态。</target>
        </trans-unit>
        <trans-unit id="7e665adac2e338eb903db4caf99617c276a94da3" translate="yes" xml:space="preserve">
          <source>This callback may also return the port of the given node. In that case &lt;code&gt;port_please/3&lt;/code&gt; may be omitted.</source>
          <target state="translated">此回调也可能返回给定节点的端口。在这种情况下，可以省略 &lt;code&gt;port_please/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="220a2abc00984810bc967fbaf4c4a46c06726d6c" translate="yes" xml:space="preserve">
          <source>This can also be achieved in a more customized way by using parameter &lt;code&gt;export&lt;/code&gt; in the cover specification and analysing the result off line. However, the cross cover mechanism is a built-in solution that also provides logging.</source>
          <target state="translated">也可以通过使用封面规范中的参数 &lt;code&gt;export&lt;/code&gt; 并离线分析结果，以更加定制的方式来实现。但是，跨封面机制是一种内置解决方案，还提供了日志记录。</target>
        </trans-unit>
        <trans-unit id="d55911e226611b9c595d6a76da5448bc48c50a57" translate="yes" xml:space="preserve">
          <source>This can be defined as follows, but is faster:</source>
          <target state="translated">可定义如下,但速度更快。</target>
        </trans-unit>
        <trans-unit id="051b7b690babeaa0408d0d0c0e8d2f3f38cca0df" translate="yes" xml:space="preserve">
          <source>This can be done, for example, by focusing on one state at the time and for every state ensure that all events are handled. Alternatively, you can focus on one event at the time and ensure that it is handled in every state. You can also use a mix of these strategies.</source>
          <target state="translated">例如,可以通过同时关注一个状态,并为每个状态确保所有事件都被处理来实现。或者,你也可以每次只关注一个事件,并确保在每个状态下都能处理它。你也可以混合使用这些策略。</target>
        </trans-unit>
        <trans-unit id="d4598fb964d80c17b9042cf3810c56c1f2f70ecf" translate="yes" xml:space="preserve">
          <source>This can be the name of a binary log, a list of such logs, or the name of a directory containing one or more binary logs.</source>
          <target state="translated">这可以是一个二进制日志的名称,这样的日志的列表,或包含一个或多个二进制日志的目录的名称。</target>
        </trans-unit>
        <trans-unit id="0d49d5ccf3611383b79c9580f8c0026d786e3ee8" translate="yes" xml:space="preserve">
          <source>This can be used for various purposes, for example, writing a term to a file in an efficient way, or sending an Erlang term to some type of communications channel not supported by distributed Erlang.</source>
          <target state="translated">这可以用于各种目的,例如,以一种有效的方式将一个术语写入文件,或者将一个Erlang术语发送到分布式Erlang不支持的某种通信通道。</target>
        </trans-unit>
        <trans-unit id="a87fd0d612d477544f48342a46839027b50293f1" translate="yes" xml:space="preserve">
          <source>This can be used to detect problems with NIFs or drivers that take too long to execute. 1 ms is considered a good maximum time for a driver callback or a NIF. However, a time-sharing system is usually to consider everything &amp;lt; 100 ms as &quot;possible&quot; and fairly &quot;normal&quot;. However, longer schedule times can indicate swapping or a misbehaving NIF/driver. Misbehaving NIFs and drivers can cause bad resource utilization and bad overall system performance.</source>
          <target state="translated">这可用于检测NIF或驱动程序执行所需时间太长的问题。 1 ms被认为是驱动程序回调或NIF的最佳最长时间。但是，分时系统通常会将所有&amp;lt;100 ms的内容视为&amp;ldquo;可能&amp;rdquo;且相当&amp;ldquo;正常&amp;rdquo;。但是，较长的调度时间可能表示交换或NIF /驱动程序行为异常。 NIF和驱动程序的行为不当会导致资源利用率下降和整体系统性能下降。</target>
        </trans-unit>
        <trans-unit id="7c309ba8d110cc132caf3f434048be18fd8c888d" translate="yes" xml:space="preserve">
          <source>This can be useful to know, even if &lt;code&gt;systools&lt;/code&gt; is not used, since Erlang/OTP is packaged according to the OTP principles and thus comes with a specific directory structure. The code server (see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel) automatically uses code from the directory with the highest version number, if more than one version of an application is present.</source>
          <target state="translated">即使不使用 &lt;code&gt;systools&lt;/code&gt; ，这也很有用，因为Erlang / OTP是根据OTP原则打包的，因此带有特定的目录结构。如果存在一个应用程序的多个版本，则代码服务器（请参阅内核中的 &lt;code&gt;code(3)&lt;/code&gt; 手册页）自动使用目录中具有最高版本号的代码。</target>
        </trans-unit>
        <trans-unit id="c0a78708d83a11d18d7b6fde7a226d981a5c9a17" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to hold arbitrary terms: skip them and copy the binary term data to some buffer.</source>
          <target state="translated">当你想保存任意项时,这很有用:跳过它们,将二进制项数据复制到某个缓冲区。</target>
        </trans-unit>
        <trans-unit id="9dccf3f6d2f60b79a3b5bd80d61cef8142d3c9f1" translate="yes" xml:space="preserve">
          <source>This can occur even if a &lt;code&gt;reload&lt;/code&gt; option is specified, if &lt;code&gt;DriverOptionList&lt;/code&gt; differs from the current.</source>
          <target state="translated">即使 &lt;code&gt;DriverOptionList&lt;/code&gt; 与当前选项不同，即使指定了 &lt;code&gt;reload&lt;/code&gt; 选项，也会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="e696f35629ec0f432c29538e2e6c58a6cd4c896e" translate="yes" xml:space="preserve">
          <source>This can override the configuration parameters &lt;code&gt;nameserver&lt;/code&gt; and &lt;code&gt;search&lt;/code&gt; depending on the contents of the specified file. They can also change any time in the future reflecting the file contents.</source>
          <target state="translated">这可以覆盖配置参数 &lt;code&gt;nameserver&lt;/code&gt; 并根据指定文件的内容进行 &lt;code&gt;search&lt;/code&gt; 。它们还可以在将来的任何时间更改以反映文件内容。</target>
        </trans-unit>
        <trans-unit id="8dec9a62f192435d695441ed01fd661a8d8c315a" translate="yes" xml:space="preserve">
          <source>This causes &lt;code&gt;epmd&lt;/code&gt; to close the connection from the far end. Notice that if the name was in fact still in use by a node, the results of this operation are unpredictable. Also, doing this does not cause the local end of the connection to close, so resources can be consumed.</source>
          <target state="translated">这导致 &lt;code&gt;epmd&lt;/code&gt; 从远端关闭连接。请注意，如果该名称实际上仍被节点使用，则此操作的结果是不可预测的。同样，这样做不会导致连接的本地端关闭，因此可以消耗资源。</target>
        </trans-unit>
        <trans-unit id="b14b393bb418a216b0875dc8287af117dd7067bb" translate="yes" xml:space="preserve">
          <source>This causes a parse transform to substitute a fun for the QLC. The (compiled) fun is called when the query handle is evaluated.</source>
          <target state="translated">这将导致一个解析变换来代替QLC的fun。当查询句柄被评估时,这个(编译的)fun被调用。</target>
        </trans-unit>
        <trans-unit id="6b5f81b2ddca32cf291bc3217d330648ab91cbde" translate="yes" xml:space="preserve">
          <source>This causes a warning for an unused variable, &lt;code&gt;Elem&lt;/code&gt;, if the code is compiled with the flag &lt;code&gt;warn_unused_vars&lt;/code&gt; set. Instead, the code can be rewritten to:</source>
          <target state="translated">如果代码在设置了 &lt;code&gt;warn_unused_vars&lt;/code&gt; 标志的情况下编译，则会对未使用的变量 &lt;code&gt;Elem&lt;/code&gt; 发出警告。相反，可以将代码重写为：</target>
        </trans-unit>
        <trans-unit id="6cb1d2e7687337b9f0ef3870a3a41bbcb1151114" translate="yes" xml:space="preserve">
          <source>This causes outstanding megaco:call/3 requests to return. The callback functions UserMod:handle_reply/4 and UserMod:handle_trans_ack/4 are also invoked where it applies. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">这将导致未完成的megaco:call/3请求返回。回调函数 UserMod:handle_reply/4 和 UserMod:handle_trans_ack/4 也会在适用的地方被调用。关于回调参数的更多信息,请参见 megaco_user 模块。</target>
        </trans-unit>
        <trans-unit id="68c0a11988374396554e35c1339e4b4d296f9cbb" translate="yes" xml:space="preserve">
          <source>This causes the variable to be lifted (after parsing) to the next higher level in the syntax tree, replacing that entire subtree. In this case, the &lt;code&gt;'@_@Name'/0&lt;/code&gt; will be replaced with &lt;code&gt;'@@Name'&lt;/code&gt;, and the &lt;code&gt;/0&lt;/code&gt; part was just used as dummy notation and will be discarded.</source>
          <target state="translated">这导致变量在语法树中被提升（在解析之后）到更高的级别，从而替换了整个子树。在这种情况下， &lt;code&gt;'@_@Name'/0&lt;/code&gt; 将替换为 &lt;code&gt;'@@Name'&lt;/code&gt; ，并且 &lt;code&gt;/0&lt;/code&gt; 部分仅用作虚拟符号，并将被丢弃。</target>
        </trans-unit>
        <trans-unit id="84078e161475adc15a1fe15da8646e8557d4b551" translate="yes" xml:space="preserve">
          <source>This chapter briefly describes Erlang records derived from ASN.1 specifications used to handle public key infrastructure. The scope is to describe the data types of each component, not the semantics. For information on the semantics, refer to the relevant standards and RFCs linked in the sections below.</source>
          <target state="translated">本章简要介绍了源于ASN.1规范的Erlang记录,用于处理公钥基础设施。范围是描述每个组件的数据类型,而不是语义。关于语义的信息,请参考下面章节中链接的相关标准和RFC。</target>
        </trans-unit>
        <trans-unit id="b2f23bd1830ba030caede6017d114b23d96a8156" translate="yes" xml:space="preserve">
          <source>This chapter contains in extenso versions of the OpenSSL and SSLeay licenses.</source>
          <target state="translated">本章包含OpenSSL和SSLeay许可证的扩展版本。</target>
        </trans-unit>
        <trans-unit id="6b1d044a8e1dfdfc0b3ead8b82c9c3d5d936b5ef" translate="yes" xml:space="preserve">
          <source>This chapter describes FIPS mode support in the crypto application.</source>
          <target state="translated">本章介绍加密应用中的FIPS模式支持。</target>
        </trans-unit>
        <trans-unit id="ffd1f44c4ed57b40721b93cf5c0efd3d78d52a33" translate="yes" xml:space="preserve">
          <source>This chapter describes the support for loading encryption engines in the crypto application.</source>
          <target state="translated">本章介绍了对加密应用中加载加密引擎的支持。</target>
        </trans-unit>
        <trans-unit id="84e8d13b539f47c00293308a5f44715292e8675e" translate="yes" xml:space="preserve">
          <source>This chapter describes the support in the crypto application for using public and private keys stored in encryption engines.</source>
          <target state="translated">本章介绍了加密应用中对使用存储在加密引擎中的公钥和私钥的支持。</target>
        </trans-unit>
        <trans-unit id="66dda50ba5ba17ea40a6d362cc6e7f81e1f3b82a" translate="yes" xml:space="preserve">
          <source>This chapter is about creating such a system, which is called a &lt;strong&gt;target system&lt;/strong&gt;.</source>
          <target state="translated">本章是关于创建这样的系统的，该系统称为&lt;strong&gt;目标系统&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="303cc2fd7c07d62117308f568c6c7a69cd42b456" translate="yes" xml:space="preserve">
          <source>This checks that the pid &lt;code&gt;From&lt;/code&gt; is in the &lt;code&gt;User_List&lt;/code&gt;:</source>
          <target state="translated">这将检查pid &lt;code&gt;From&lt;/code&gt; 是否在 &lt;code&gt;User_List&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="cd754cddd9c96097f025a6b91734f43531e07dcf" translate="yes" xml:space="preserve">
          <source>This closes the Erlang/OTP shell.</source>
          <target state="translated">这将关闭Erlang/OTP shell。</target>
        </trans-unit>
        <trans-unit id="7d1fa1715e259b26d3b25f592aabf2747c705ee2" translate="yes" xml:space="preserve">
          <source>This code adds a set of people to the database. Running this code within one transaction ensures that either the whole family is added to the database, or the whole transaction terminates. For example, if the last child is badly formatted, or the executing process terminates because of an &lt;code&gt;'EXIT'&lt;/code&gt; signal while executing the family code, the transaction terminates. Thus, the situation where half a family is added can never occur.</source>
          <target state="translated">此代码将一组人员添加到数据库中。在一个事务中运行此代码可确保将整个族添加到数据库中，或者整个事务终止。例如，如果最后一个子文件的格式不正确，或者由于执行家族代码时由于 &lt;code&gt;'EXIT'&lt;/code&gt; 信号而导致执行过程终止，则事务终止。因此，永远不会出现增加一半家庭的情况。</target>
        </trans-unit>
        <trans-unit id="98b115ab987715d60781ca89e47fa4411fb40cb5" translate="yes" xml:space="preserve">
          <source>This code behaves differently from &quot;&lt;code&gt;--&lt;/code&gt;&quot; if the lists contain duplicate elements (one occurrence of an element in HugeList2 removes &lt;strong&gt;all&lt;/strong&gt; occurrences in HugeList1.)</source>
          <target state="translated">如果列表包含重复的元素，则此代码的行为与&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo; 不同（HugeList2中元素的一次出现会删除HugeList1中的&lt;strong&gt;所有&lt;/strong&gt;出现。）</target>
        </trans-unit>
        <trans-unit id="620f0e09a670821d9a2abe04fa98afa74a5ef2a9" translate="yes" xml:space="preserve">
          <source>This code is easier to write and to understand, and it also executes much faster.</source>
          <target state="translated">这种代码更容易写,也更容易理解,而且执行起来也更快。</target>
        </trans-unit>
        <trans-unit id="c2b34933ffae95b8a853f8ff645604fbd952d3ab" translate="yes" xml:space="preserve">
          <source>This code lock state machine can be implemented using &lt;code&gt;gen_statem&lt;/code&gt; with the following callback module:</source>
          <target state="translated">可以使用 &lt;code&gt;gen_statem&lt;/code&gt; 和以下回调模块来实现此代码锁定状态机：</target>
        </trans-unit>
        <trans-unit id="7b2443919e593a0d589592796a6acfa56ef58bd8" translate="yes" xml:space="preserve">
          <source>This code uses the function &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; instead of the function &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; The function &lt;code&gt;s_write/1&lt;/code&gt; sets a sticky lock instead of a normal lock. If the table is not replicated, sticky locks have no special effect. If the table is replicated, and a sticky lock is set on node &lt;code&gt;N1&lt;/code&gt;, this lock then sticks to node &lt;code&gt;N1&lt;/code&gt;. The next time you try to set a sticky lock on the same record at node &lt;code&gt;N1&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; detects that the lock is already set and do no network operation to acquire the lock.</source>
          <target state="translated">此代码使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; 而不是函数 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 。函数 &lt;code&gt;s_write/1&lt;/code&gt; 设置了粘滞锁而不是普通锁。如果不复制表，则粘滞锁没有特殊作用。如果复制了表，并且在节点 &lt;code&gt;N1&lt;/code&gt; 上设置了粘滞锁，则此锁将粘在节点 &lt;code&gt;N1&lt;/code&gt; 上。下次您尝试在节点 &lt;code&gt;N1&lt;/code&gt; 的同一记录上设置粘性锁定时， &lt;code&gt;Mnesia&lt;/code&gt; 会检测到该锁定已设置，并且不执行任何网络操作来获取该锁定。</target>
        </trans-unit>
        <trans-unit id="d473cae681409fa329e6bc7b44d312e6bb308a91" translate="yes" xml:space="preserve">
          <source>This command can only be used when contacting &lt;code&gt;epmd&lt;/code&gt; instances started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;.</source>
          <target state="translated">仅当联系以 &lt;code&gt;epmd&lt;/code&gt; 标志 &lt;code&gt;-relaxed_command_check&lt;/code&gt; epmd实例时，才可以使用此命令。</target>
        </trans-unit>
        <trans-unit id="a8da29ec7d90c1769855d7fc9ae5d438b9bb9d86" translate="yes" xml:space="preserve">
          <source>This command file is then set as heart command.</source>
          <target state="translated">这个命令文件就会被设置为心脏命令。</target>
        </trans-unit>
        <trans-unit id="52d8f2983dee948139d1e9e434673f9c52bda692" translate="yes" xml:space="preserve">
          <source>This command will create a file named &lt;code&gt;root.TAGS&lt;/code&gt; in the current directory. The file will contain references to all Erlang source files in the Erlang distribution.</source>
          <target state="translated">此命令将在当前目录中创建一个名为 &lt;code&gt;root.TAGS&lt;/code&gt; 的文件。该文件将包含对Erlang发行版中所有Erlang源文件的引用。</target>
        </trans-unit>
        <trans-unit id="aa2bc19b983020ccb9b326fcd4731f0bd1161c57" translate="yes" xml:space="preserve">
          <source>This composes a test set from the exported test functions of the named module, i.e., those functions with arity zero whose names end with &lt;code&gt;_test&lt;/code&gt; or &lt;code&gt;_test_&lt;/code&gt;. Basically, the &lt;code&gt;..._test()&lt;/code&gt; functions become simple tests, while the &lt;code&gt;..._test_()&lt;/code&gt; functions become generators.</source>
          <target state="translated">此构成从命名模块，即具有零元数名称以结束这些功能的导出的测试功能测试集 &lt;code&gt;_test&lt;/code&gt; 或 &lt;code&gt;_test_&lt;/code&gt; 。基本上， &lt;code&gt;..._test()&lt;/code&gt; 函数成为简单的测试，而 &lt;code&gt;..._test_()&lt;/code&gt; 函数成为生成器。</target>
        </trans-unit>
        <trans-unit id="63c3c21b3eef82be8246811ccf2f3c14d371f943" translate="yes" xml:space="preserve">
          <source>This concludes the example. It is fully runnable and you can read or write to the I/O server by using, for example, the &lt;code&gt;io&lt;/code&gt; module or even the &lt;code&gt;file&lt;/code&gt; module. It is as simple as that to implement a fully fledged I/O server in Erlang.</source>
          <target state="translated">到此结束示例。它是完全可运行的，您可以通过使用 &lt;code&gt;io&lt;/code&gt; 模块甚至 &lt;code&gt;file&lt;/code&gt; 模块来读取或写入I / O服务器。就像在Erlang中实现成熟的I / O服务器一样简单。</target>
        </trans-unit>
        <trans-unit id="33f0e49393f960fdbb1f12f5f92189e125a0ce06" translate="yes" xml:space="preserve">
          <source>This configuration function is called as the first function in the suite. It typically contains initializations that are common for all test cases in the suite, and that must only be done once. Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. Whatever is returned from this function is specified as &lt;code&gt;Config&lt;/code&gt; to all configuration functions and test cases in the suite.</source>
          <target state="translated">此配置功能称为套件中的第一个功能。它通常包含该套件中所有测试用例都通用的初始化，并且只能执行一次。参数 &lt;code&gt;Config&lt;/code&gt; 是可以修改的配置数据。从此函数返回的所有内容均指定为套件中所有配置函数和测试用例的 &lt;code&gt;Config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fc12196aaa3c7c817d997888a6e0c0d511e97b1" translate="yes" xml:space="preserve">
          <source>This configuration function is called before execution of a test case group. It typically contains initializations that are common for all test cases and subgroups in the group, and that must only be performed once. &lt;code&gt;GroupName&lt;/code&gt; is the name of the group, as specified in the group definition (see &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt;). Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. The return value of this function is given as &lt;code&gt;Config&lt;/code&gt; to all test cases and subgroups in the group.</source>
          <target state="translated">在执行测试用例组之前，将调用此配置功能。它通常包含该组中所有测试用例和子组都通用的初始化，并且只能执行一次。 &lt;code&gt;GroupName&lt;/code&gt; 是组的名称，如组定义中所指定（请参阅 &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; ）。参数 &lt;code&gt;Config&lt;/code&gt; 是可以修改的配置数据。该函数的返回值以 &lt;code&gt;Config&lt;/code&gt; 的形式提供给该组中的所有测试用例和子组。</target>
        </trans-unit>
        <trans-unit id="23368b3fe2d449c2692eb8e3e91bed68d4ab16da" translate="yes" xml:space="preserve">
          <source>This conforms to the format used by the scanner in the Erlang &lt;code&gt;io&lt;/code&gt; library module.</source>
          <target state="translated">这符合Erlang &lt;code&gt;io&lt;/code&gt; 库模块中扫描程序使用的格式。</target>
        </trans-unit>
        <trans-unit id="89e7ad5998bd8d56a5635438c81b21cdbc5fbf20" translate="yes" xml:space="preserve">
          <source>This construction does not consume any messages, only suspends execution in the process for &lt;code&gt;ExprT&lt;/code&gt; milliseconds. This can be used to implement simple timers.</source>
          <target state="translated">这种构造不会消耗任何消息，只会在进程中暂停执行 &lt;code&gt;ExprT&lt;/code&gt; 毫秒。这可以用来实现简单的计时器。</target>
        </trans-unit>
        <trans-unit id="ff79977655b81c53aa0929475789c463d4c65ccd" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="61b1bf1e5da0665206d28c63a8251c70f9437da9" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="3811bd05c74f86fcbc14a9c1b9034f65fa2fcd06" translate="yes" xml:space="preserve">
          <source>This could be accomplished with the option &lt;code&gt;fail_callback&lt;/code&gt; which will be called if the hostname verification fails:</source>
          <target state="translated">这可以通过选项 &lt;code&gt;fail_callback&lt;/code&gt; 来完成，如果主机名验证失败，则将调用该选项：</target>
        </trans-unit>
        <trans-unit id="51a1cc36e31cb197216b50eb9eb632d0459ddabc" translate="yes" xml:space="preserve">
          <source>This creates a boot script, both the readable version, &lt;code&gt;ch_rel-1.script&lt;/code&gt;, and the binary version, &lt;code&gt;ch_rel-1.boot&lt;/code&gt;, used by the runtime system.</source>
          <target state="translated">这将创建一个由运行时系统使用的引导脚本，即可读版本 &lt;code&gt;ch_rel-1.script&lt;/code&gt; 和二进制版本 &lt;code&gt;ch_rel-1.boot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f83e183c685a8bf96ad1d1d03b74d255f5c951a" translate="yes" xml:space="preserve">
          <source>This creates a test set from all the modules belonging to the specified application, by consulting the application's &lt;code&gt;.app&lt;/code&gt; file (see &lt;code&gt;{file, FileName}&lt;/code&gt;), or if no such file exists, by testing all object files in the application's &lt;code&gt;ebin&lt;/code&gt;-directory (see &lt;code&gt;{dir, Path}&lt;/code&gt;); if that does not exist, the &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; directory is used.</source>
          <target state="translated">这可以通过查询属于应用程序的 &lt;code&gt;.app&lt;/code&gt; 文件（请参阅 &lt;code&gt;{file, FileName}&lt;/code&gt; ）从属于指定应用程序的所有模块创建测试集，或者如果不存在此类文件，则可以通过测试应用程序的 &lt;code&gt;ebin&lt;/code&gt; -directory 中的所有目标文件来创建测试集（参见 &lt;code&gt;{dir, Path}&lt;/code&gt; ）; 如果不存在，则使用 &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="7dfbabbf55ded6bc40cb089b7e7b9db65720b207" translate="yes" xml:space="preserve">
          <source>This creates a tuple with the brand of the motorcycle and the output format. We use the brand name only for sorting purpose. We have to end the template function with the &quot;built in clause&quot; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt;</source>
          <target state="translated">这将创建一个具有摩托车品牌和输出格式的元组。我们仅将品牌名称用于分类目的。我们必须以&amp;ldquo;内建子句&amp;rdquo; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd1d3feb38283e93bdf7380a9a3f2767d2d85c6a" translate="yes" xml:space="preserve">
          <source>This creates an &lt;code&gt;(ETERM *)&lt;/code&gt; structure corresponding to the Erlang term &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt;</source>
          <target state="translated">这将创建一个与Erlang术语 &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt; 相对应的 &lt;code&gt;(ETERM *)&lt;/code&gt; 结构</target>
        </trans-unit>
        <trans-unit id="ae606f82f5ea62f5942a0adf3b9e512950c71e07" translate="yes" xml:space="preserve">
          <source>This creates an additional folder in &lt;code&gt;$ERL_TOP/release&lt;/code&gt; called &lt;code&gt;tests&lt;/code&gt;. Now, it's time to start the smoke test.</source>
          <target state="translated">这将在 &lt;code&gt;$ERL_TOP/release&lt;/code&gt; 创建一个名为 &lt;code&gt;tests&lt;/code&gt; 的附加文件夹。现在，该开始进行烟雾测试了。</target>
        </trans-unit>
        <trans-unit id="ef73a8deed0f6aa219ae36f5994c464c421d1dae" translate="yes" xml:space="preserve">
          <source>This creates an anonymous function of &lt;code&gt;N&lt;/code&gt; arguments and binds it to the variable &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">这产生的匿名功能 &lt;code&gt;N&lt;/code&gt; 参数和它结合到可变 &lt;code&gt;F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="524be8f1a981b01e7043d75c61d487bdaac91459" translate="yes" xml:space="preserve">
          <source>This creates:</source>
          <target state="translated">这就造成了:</target>
        </trans-unit>
        <trans-unit id="c46e82b8048ee48e1624490a06ae6b4a6e2f1c62" translate="yes" xml:space="preserve">
          <source>This daemon acts as a name server on all hosts involved in distributed Erlang computations. When an Erlang node starts, the node has a name and it obtains an address from the host OS kernel. The name and address are sent to the &lt;code&gt;epmd&lt;/code&gt; daemon running on the local host. In a TCP/IP environment, the address consists of the IP address and a port number. The node name is an atom on the form of &lt;code&gt;Name@Node&lt;/code&gt;. The job of the &lt;code&gt;epmd&lt;/code&gt; daemon is to keep track of which node name listens on which address. Hence, &lt;code&gt;epmd&lt;/code&gt; maps symbolic node names to machine addresses.</source>
          <target state="translated">该守护程序在涉及分布式Erlang计算的所有主机上充当名称服务器。当Erlang节点启动时，该节点将具有一个名称，并从主机OS内核获取地址。名称和地址将发送到在本地主机上运行的 &lt;code&gt;epmd&lt;/code&gt; 守护程序。在TCP / IP环境中，该地址由IP地址和端口号组成。节点名称是原子，形式为 &lt;code&gt;Name@Node&lt;/code&gt; 。 &lt;code&gt;epmd&lt;/code&gt; 守护程序的工作是跟踪哪个节点名称在哪个地址上侦听。因此， &lt;code&gt;epmd&lt;/code&gt; 将符号节点名称映射到机器地址。</target>
        </trans-unit>
        <trans-unit id="be132e0b64312cab1412b3c061af9dbcd07c2db2" translate="yes" xml:space="preserve">
          <source>This data can also be specified explicitly in the user configuration file. This file is to contain lines of configuration parameters (each terminated with a full stop). Some parameters add data to the configuration (such as host and nameserver), others overwrite any previous settings (such as domain and lookup). The user configuration file is always examined last in the configuration process, making it possible for the user to override any default values or previously made settings. Call &lt;code&gt;inet:get_rc()&lt;/code&gt; to view the state of the &lt;code&gt;inet&lt;/code&gt; configuration database.</source>
          <target state="translated">也可以在用户配置文件中显式指定此数据。该文件包含配置参数行（每行以句号终止）。一些参数将数据添加到配置中（例如主机和名称服务器），其他参数将覆盖之前的所有设置（例如域和查找）。在配置过程中，始终会最后检查用户配置文件，从而使用户可以覆盖任何默认值或先前进行的设置。调用 &lt;code&gt;inet:get_rc()&lt;/code&gt; 以查看 &lt;code&gt;inet&lt;/code&gt; 配置数据库的状态。</target>
        </trans-unit>
        <trans-unit id="48f25fc645975c60f249d68b5dd230f51d28d68c" translate="yes" xml:space="preserve">
          <source>This date and time identifier has the same format as the XML type &lt;code&gt;dateTime&lt;/code&gt; and is compliant with RFC 3339 Date and Time on the Internet Timestamps. The format is as follows:</source>
          <target state="translated">此日期和时间标识符与XML类型 &lt;code&gt;dateTime&lt;/code&gt; 的格式相同，并且符合RFC 3339 Internet时间戳上的&amp;ldquo;日期和时间&amp;rdquo;。格式如下：</target>
        </trans-unit>
        <trans-unit id="738523548a30e709bb5b81f10988c30ec76d3772" translate="yes" xml:space="preserve">
          <source>This defines a local function handler that is called with:</source>
          <target state="translated">这定义了一个本地函数处理程序,这个函数处理程序被调用。</target>
        </trans-unit>
        <trans-unit id="948cd7e2c415cc3a421a26b31393fafc514d648b" translate="yes" xml:space="preserve">
          <source>This defines a non-local function handler that is called with:</source>
          <target state="translated">这定义了一个非本地函数处理程序,该函数处理程序被调用。</target>
        </trans-unit>
        <trans-unit id="662f224ab983c6f766721b42aada149c79c7000c" translate="yes" xml:space="preserve">
          <source>This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes are stable since many years.</source>
          <target state="translated">这一说明远未完成。如果协议更新了,它将会被更新。然而,从Erlang节点到Erlang端口映射守护进程(EPMD)以及Erlang节点之间的协议自多年来都是稳定的。</target>
        </trans-unit>
        <trans-unit id="e8b60a37d6f9b5dab9afb438915682d979c1ca85" translate="yes" xml:space="preserve">
          <source>This diagnostic warns that the variable &lt;code&gt;X&lt;/code&gt; in the pattern is not the same as the variable &lt;code&gt;X&lt;/code&gt; that occurs in the function head.</source>
          <target state="translated">此诊断警告说，变量 &lt;code&gt;X&lt;/code&gt; 在图案是不一样的变量 &lt;code&gt;X&lt;/code&gt; 中发生的功能头。</target>
        </trans-unit>
        <trans-unit id="9c0a88d7e60d7e7f1439fe6fcfcc1a50b22440f9" translate="yes" xml:space="preserve">
          <source>This directory is the &lt;strong&gt;installation directory&lt;/strong&gt; of the embedded environment.</source>
          <target state="translated">该目录是嵌入式环境的&lt;strong&gt;安装目录&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7a3cf407193e52ba658ffaccdcac32c81fba9803" translate="yes" xml:space="preserve">
          <source>This disables the use of style sheets and JavaScripts (see &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这将禁用样式表和JavaScript的使用（请参阅 &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ecec3c07eff61196ca0de8babf79aab0e2d1d31" translate="yes" xml:space="preserve">
          <source>This document describes how to build and install Erlang/OTP-21. Erlang/OTP should be possible to build from source on any Unix/Linux system, including OS X. You are advised to read the whole document before attempting to build and install Erlang/OTP.</source>
          <target state="translated">本文档介绍了如何构建和安装Erlang/OTP-21。Erlang/OTP应该可以在任何Unix/Linux系统上从源码编译,包括OS X。</target>
        </trans-unit>
        <trans-unit id="154342527042516d1b93b9115b8c8965ef041d9a" translate="yes" xml:space="preserve">
          <source>This document describes how to cross compile Erlang/OTP-21. You are advised to read the whole document before attempting to cross compile Erlang/OTP. However, before reading this document, you should read the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document which describes building and installing Erlang/OTP in general. &lt;code&gt;$ERL_TOP&lt;/code&gt; is the top directory in the source tree.</source>
          <target state="translated">本文档介绍了如何交叉编译Erlang / OTP-21。建议您在尝试交叉编译Erlang / OTP之前先阅读整个文档。但是，在阅读本文档之前，您应该阅读 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 文档，该文档通常描述了如何构建和安装Erlang / OTP。 &lt;code&gt;$ERL_TOP&lt;/code&gt; 是源树中的顶级目录。</target>
        </trans-unit>
        <trans-unit id="71a24568f8a61fe472275bbbf1ab8d95f3724c6d" translate="yes" xml:space="preserve">
          <source>This document describes the process of patching an existing OTP installation with one or more Erlang/OTP applications of newer versions than already installed. The tool &lt;code&gt;otp_patch_apply&lt;/code&gt; is available for this specific purpose. It resides in the top directory of the Erlang/OTP source tree.</source>
          <target state="translated">本文档介绍了使用一个或多个比已安装的版本更高的Erlang / OTP应用程序修补现有OTP安装的过程。工具 &lt;code&gt;otp_patch_apply&lt;/code&gt; 可用于此特定目的。它位于Erlang / OTP源代码树的顶层目录中。</target>
        </trans-unit>
        <trans-unit id="a3d8a881ed785c2bbf80ae1ed7354f59f5918b23" translate="yes" xml:space="preserve">
          <source>This document does not give an introduction to XML. There are a lot of books available that describe XML from different views. At the &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; site you will find the &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; and other related specs. One site were you can find tutorials on XML and related specs is &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本文档未介绍XML。有很多书籍可以从不同的角度描述XML。在 &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; 网站上，您可以找到 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; 和其他相关规范。您可以在一个站点上找到 &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt; ,它是有关XML和相关规范的教程。</target>
        </trans-unit>
        <trans-unit id="143fad2c70e90531f505c4657ec791c944d5326a" translate="yes" xml:space="preserve">
          <source>This document focuses on the graphical parts of the tool. The concepts are explained in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt;.</source>
          <target state="translated">本文档重点介绍该工具的图形部分。有关概念，请参见模块 &lt;code&gt;reltool&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="d0a13f41d530fac43cd74427e80d4e61f60e1273" translate="yes" xml:space="preserve">
          <source>This does not reduce the overall time for the upgrade, but it allows checks and purge to be executed in the background before the real upgrade is started.</source>
          <target state="translated">这并没有减少升级的整体时间,但它允许在真正的升级开始之前在后台执行检查和清除。</target>
        </trans-unit>
        <trans-unit id="05624a0b5087d8c82b1545072e5dc7e9346c97f4" translate="yes" xml:space="preserve">
          <source>This driver is called like the others from Erlang. However, as we use &lt;code&gt;driver_output_term&lt;/code&gt;, there is no need to call &lt;code&gt;binary_to_term&lt;/code&gt;. The Erlang code is in the sample file &lt;code&gt;next_perm.erl&lt;/code&gt;.</source>
          <target state="translated">该驱动程序的名称与Erlang中的其他驱动程序相同。但是，由于我们使用 &lt;code&gt;driver_output_term&lt;/code&gt; ，因此无需调用 &lt;code&gt;binary_to_term&lt;/code&gt; 。Erlang代码在示例文件 &lt;code&gt;next_perm.erl&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0d94d056a098777bcb956ee04ca4b41885a25660" translate="yes" xml:space="preserve">
          <source>This driver uses the &lt;code&gt;writev&lt;/code&gt; system call to send data onto the socket. A combination of &lt;code&gt;writev&lt;/code&gt; and the driver output queues is very convenient. An &lt;code&gt;ErlIOVec&lt;/code&gt; structure contains a &lt;code&gt;SysIOVec&lt;/code&gt; (which is equivalent to the &lt;code&gt;struct iovec&lt;/code&gt; structure defined in &lt;code&gt;uio.h&lt;/code&gt;. The &lt;code&gt;ErlIOVec&lt;/code&gt; also contains an array of &lt;code&gt;ErlDrvBinary&lt;/code&gt; pointers, of the same length as the number of buffers in the I/O vector itself. One can use this to allocate the binaries for the queue &quot;manually&quot; in the driver, but here the binary array is filled with &lt;code&gt;NULL&lt;/code&gt; values (line 7). The runtime system then allocates its own buffers when &lt;code&gt;driver_enqv&lt;/code&gt; is called (line 37).</source>
          <target state="translated">该驱动程序使用 &lt;code&gt;writev&lt;/code&gt; 系统调用将数据发送到套接字。将 &lt;code&gt;writev&lt;/code&gt; 和驱动程序输出队列结合使用非常方便。一个 &lt;code&gt;ErlIOVec&lt;/code&gt; 结构包含一个 &lt;code&gt;SysIOVec&lt;/code&gt; （其等同于 &lt;code&gt;struct iovec&lt;/code&gt; 中定义的结构 &lt;code&gt;uio.h&lt;/code&gt; 该 &lt;code&gt;ErlIOVec&lt;/code&gt; 还包含的阵列 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 指针相同的长度，如缓冲剂的在I / O向量本身的数量。人们可以使用它为驱动程序中的队列&amp;ldquo;手动&amp;rdquo;分配二进制文件，但此处二进制数组中填充了 &lt;code&gt;NULL&lt;/code&gt; 值（第7行），然后运行系统在 &lt;code&gt;driver_enqv&lt;/code&gt; 时分配其自己的缓冲区 被称为（第37行）。</target>
        </trans-unit>
        <trans-unit id="08f20d866bfb101e15cb4fdb27b1335c719c4f1c" translate="yes" xml:space="preserve">
          <source>This driver was written before the runtime system had SMP support. The driver will still function in the runtime system with SMP support, but performance will suffer from lock contention on the driver lock used for the driver. This can be alleviated by reviewing and perhaps rewriting the code so that each instance of the driver safely can execute in parallel. When instances safely can execute in parallel, it is safe to enable instance-specific locking on the driver. This is done by passing &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; as a driver flag. This is left as an exercise for the reader.</source>
          <target state="translated">该驱动程序是在运行时系统具有SMP支持之前编写的。该驱动程序仍将在具有SMP支持的运行时系统中运行，但是性能会因用于该驱动程序的驱动程序锁上的锁争用而受损。这可以通过查看并重写代码来缓解，以便驱动程序的每个实例都可以安全地并行执行。当实例可以安全地并行执行时，可以在驱动程序上启用特定于实例的锁定。这是通过传递 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; 作为驱动程序标志来完成的。这留给读者练习。</target>
        </trans-unit>
        <trans-unit id="c64c900bac343dda7e6756119d5d4e6241d815d7" translate="yes" xml:space="preserve">
          <source>This effectively closes down the Erlang node. Therefore, use the erl scheme instead, until this security breach is fixed.</source>
          <target state="translated">这实际上关闭了Erlang节点。因此,在这个安全漏洞被修复之前,请使用 erl 方案代替。</target>
        </trans-unit>
        <trans-unit id="bc0795bd08428b2fedc177925549e5f08fa86748" translate="yes" xml:space="preserve">
          <source>This element has a total size of 4*8 = 32 bits, and it contains a signed integer in little-endian order.</source>
          <target state="translated">这个元素的总大小为4*8=32位,它包含了一个有符号的整数,按小安培顺序排列。</target>
        </trans-unit>
        <trans-unit id="60545e850b697ee47719a2ce1a4b108461f703aa" translate="yes" xml:space="preserve">
          <source>This enables references to the fields of the record by name. For example, if &lt;code&gt;P&lt;/code&gt; is a variable whose value is a &lt;code&gt;person&lt;/code&gt; record, the following code access the name and address fields of the records:</source>
          <target state="translated">这样可以按名称引用记录的字段。例如，如果 &lt;code&gt;P&lt;/code&gt; 是一个值是 &lt;code&gt;person&lt;/code&gt; 记录的变量，则以下代码访问记录的名称和地址字段：</target>
        </trans-unit>
        <trans-unit id="aa641702f4a74845596c27dedfc3c223048bd207" translate="yes" xml:space="preserve">
          <source>This encoding has many similarities to UTF-8, but the basic unit is a 16-bit number. This means that all characters occupy at least two bytes, and some high numbers four bytes. Some programs, libraries, and operating systems claiming to use UTF-16 only allow for characters that can be stored in one 16-bit entity, which is usually sufficient to handle living languages. As the basic unit is more than one byte, byte-order issues occur, which is why UTF-16 exists in both a big-endian and a little-endian variant.</source>
          <target state="translated">这种编码与UTF-8有许多相似之处,但基本单位是一个16位数字。这意味着所有的字符至少要占用两个字节,一些高数要占用四个字节。一些声称使用UTF-16的程序、库和操作系统只允许在一个16位实体中存储字符,这通常足以处理活语言。由于基本单位超过一个字节,就会出现字节顺序的问题,这就是为什么UTF-16存在大恩典和小恩典两种变体。</target>
        </trans-unit>
        <trans-unit id="57b04c69f42e5cd6d283dd11cf050111e35a9d54" translate="yes" xml:space="preserve">
          <source>This entry is normally not shown. It signifies that getting the rest of the information about this scheduler failed for some reason.</source>
          <target state="translated">这个条目通常不显示。它表示由于某种原因,获取该调度器的其他信息失败。</target>
        </trans-unit>
        <trans-unit id="1ee6d539dd946aea2f2282406d3b99f607f84e26" translate="yes" xml:space="preserve">
          <source>This entry is shown only if there is a current process. It is similar to &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that only the function frames are shown (that is, the stack variables are omitted). Also, only the top and bottom part of the stack are shown. If the stack is small (&amp;lt; 512 slots), the entire stack is shown. Otherwise the entry &lt;strong&gt;skipping ## slots&lt;/strong&gt; is shown, where &lt;code&gt;##&lt;/code&gt; is replaced by the number of slots that has been skipped.</source>
          <target state="translated">仅当存在当前进程时，才显示此条目。它与 &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 相似，除了仅显示功能框（即，忽略堆栈变量）。另外，仅显示堆栈的顶部和底部。如果堆栈很小（&amp;lt;512个插槽），则会显示整个堆栈。否则，将显示&lt;strong&gt;跳过##插槽&lt;/strong&gt;的条目，其中 &lt;code&gt;##&lt;/code&gt; 替换为已跳过的插槽数。</target>
        </trans-unit>
        <trans-unit id="f4c1826f8578bafadcea5382ece74a9e3ca2e0c8" translate="yes" xml:space="preserve">
          <source>This equals:</source>
          <target state="translated">这就等于:</target>
        </trans-unit>
        <trans-unit id="8ee9f6a74af74dded0ab21396013fd65cb0cdb5f" translate="yes" xml:space="preserve">
          <source>This error is very similar to &lt;code&gt;match_limit&lt;/code&gt;, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the &lt;code&gt;match_limit_recursion&lt;/code&gt; limit, which defaults to 10,000,000 as well. Notice that as long as the &lt;code&gt;match_limit&lt;/code&gt; and &lt;code&gt;match_limit_default&lt;/code&gt; values are kept at the default values, the &lt;code&gt;match_limit_recursion&lt;/code&gt; error cannot occur, as the &lt;code&gt;match_limit&lt;/code&gt; error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt;) or by specifying options to &lt;code&gt;run/3&lt;/code&gt;.</source>
          <target state="translated">此错误与 &lt;code&gt;match_limit&lt;/code&gt; 非常相似，但是当PCRE的内部匹配函数被&amp;ldquo;递归&amp;rdquo;调用的次数超过 &lt;code&gt;match_limit_recursion&lt;/code&gt; 限制的次数时，也会发生此错误，该限制也默认为10,000,000。请注意，只要 &lt;code&gt;match_limit&lt;/code&gt; 和 &lt;code&gt;match_limit_default&lt;/code&gt; 值被保持在默认值，则 &lt;code&gt;match_limit_recursion&lt;/code&gt; 不能发生错误，因为 &lt;code&gt;match_limit&lt;/code&gt; 之前（每次递归调用也是一个呼叫，但不能反过来）会出现误差。但是，可以通过直接在正则表达式字符串中设置限制（请参阅 &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt; 一节）或通过指定选项 &lt;code&gt;run/3&lt;/code&gt; 来更改两个限制。。</target>
        </trans-unit>
        <trans-unit id="b2c6321b6b0826055e2105517a81fb4bbe80e26b" translate="yes" xml:space="preserve">
          <source>This event gives initial test run information that can be interpreted as: &quot;This test run will execute &lt;code&gt;Tests&lt;/code&gt; separate tests, in total containing &lt;code&gt;Cases&lt;/code&gt; number of test cases, in &lt;code&gt;Suites&lt;/code&gt; number of suites&quot;. However, if a test case group with a repeat property exists in any test, the total number of test cases cannot be calculated (unknown).</source>
          <target state="translated">此事件提供的初始测试运行信息可以解释为：&amp;ldquo;此测试运行将执行 &lt;code&gt;Tests&lt;/code&gt; 单独的测试，总共包含 &lt;code&gt;Cases&lt;/code&gt; 数，以 &lt;code&gt;Suites&lt;/code&gt; 数为套件&amp;rdquo;。但是，如果在任何测试中都存在具有重复属性的测试用例组，则无法计算测试用例的总数（未知）。</target>
        </trans-unit>
        <trans-unit id="157a7ac786729b7a02e45935d66765ea641c0a63" translate="yes" xml:space="preserve">
          <source>This event indicates that &lt;code&gt;Common Test&lt;/code&gt; has finished initial preparations and begins executing test cases.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 已完成初始准备并开始执行测试用例。</target>
        </trans-unit>
        <trans-unit id="a311dceedd521d1962d136632b3e667b19bb56be" translate="yes" xml:space="preserve">
          <source>This event indicates that the last test case has been executed and &lt;code&gt;Common Test&lt;/code&gt; is shutting down.</source>
          <target state="translated">此事件表明最后一个测试用例已经执行，并且 &lt;code&gt;Common Test&lt;/code&gt; 正在关闭。</target>
        </trans-unit>
        <trans-unit id="e53e8156bb201879d980af4d7b34c6aceaecd401" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; has started successfully and is ready to receive I/O messages.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 的日志记录过程已成功启动，并准备接收I / O消息。</target>
        </trans-unit>
        <trans-unit id="76a023ae70d60675cb788ca95f5784d5e17403bb" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; was shut down at the end of the test run.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 的日志记录过程在测试运行结束时已关闭。</target>
        </trans-unit>
        <trans-unit id="1defde33c0ddbc9bf09303976e2df4c21eb56168" translate="yes" xml:space="preserve">
          <source>This event informs about the end of a test case or a configuration function (see event &lt;code&gt;tc_start&lt;/code&gt; for details on element &lt;code&gt;FuncOrGroup&lt;/code&gt;). With this event comes the final result of the function in question. It is possible to determine on the top level of &lt;code&gt;Result&lt;/code&gt; if the function was successful, skipped (by the user), or if it failed.</source>
          <target state="translated">这大约测试用例或配置功能的结束事件通知（见事件 &lt;code&gt;tc_start&lt;/code&gt; 的详细信息，元件 &lt;code&gt;FuncOrGroup&lt;/code&gt; ）。伴随此事件，是该功能的最终结果。可以在 &lt;code&gt;Result&lt;/code&gt; 的最高级别上确定该功能是否成功，被用户跳过（是否被用户）或是否失败。</target>
        </trans-unit>
        <trans-unit id="196853db3112d60fc49c52cb43e5304105859b69" translate="yes" xml:space="preserve">
          <source>This event informs about the start of a test case, or a group configuration function. The event is sent also for &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt;, but not for &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt;. If a group configuration function starts, the group name and execution properties are also specified.</source>
          <target state="translated">此事件通知有关测试用例或组配置功能的开始。也为 &lt;code&gt;init_per_suite&lt;/code&gt; 和 &lt;code&gt;end_per_suite&lt;/code&gt; 发送该事件，但不为 &lt;code&gt;init_per_testcase&lt;/code&gt; 和 &lt;code&gt;end_per_testcase&lt;/code&gt; 发送该事件。如果启动了组配置功能，则还将指定组名称和执行属性。</target>
        </trans-unit>
        <trans-unit id="55e3d00fdb284c9c490ae4f7d70ddb7a214409ea" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt;.</source>
          <target state="translated">此事件由 &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt; 生成。</target>
        </trans-unit>
        <trans-unit id="3c14d9a9fed395d121d6715f83a9e812993ef517" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt;.</source>
          <target state="translated">此事件由 &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c6d6cfcfdec46a1017f209d71402b88e99f222" translate="yes" xml:space="preserve">
          <source>This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt;. Both the handling of this event and sending it are taken care of by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为负责处理此事件以及将其发送。</target>
        </trans-unit>
        <trans-unit id="3bce9afff012f4ef208193d1a3f362891fa380a1" translate="yes" xml:space="preserve">
          <source>This event is sent at the start of each test case (and configuration function except &lt;code&gt;init/end_per_testcase&lt;/code&gt;) and carries information about the full name (that is, the file name including the absolute directory path) of the current test case log file.</source>
          <target state="translated">该事件在每个测试用例（以及除 &lt;code&gt;init/end_per_testcase&lt;/code&gt; 之外的配置函数）的开始处发送，并携带有关当前测试用例日志文件的全名（即，文件名，包括绝对目录路径）的信息。</target>
        </trans-unit>
        <trans-unit id="e4a38f01911d280761b98159e93b62180b939625" translate="yes" xml:space="preserve">
          <source>This event is sent for every test case or configuration function that &lt;code&gt;Common Test&lt;/code&gt; has skipped automatically because of either a failed &lt;code&gt;init_per_suite&lt;/code&gt; or &lt;code&gt;init_per_group&lt;/code&gt;, a failed &lt;code&gt;require&lt;/code&gt; in &lt;code&gt;suite/0&lt;/code&gt;, or a failed test case in a sequence. Notice that this event is never received as a result of a test case getting skipped because of &lt;code&gt;init_per_testcase&lt;/code&gt; failing, as that information is carried with event &lt;code&gt;tc_done&lt;/code&gt;. If a failed test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">此事件是为每一个测试用例或配置功能发送的 &lt;code&gt;Common Test&lt;/code&gt; 已经自动跳过，因为任一个失败 &lt;code&gt;init_per_suite&lt;/code&gt; 或 &lt;code&gt;init_per_group&lt;/code&gt; ，失败 &lt;code&gt;require&lt;/code&gt; 在 &lt;code&gt;suite/0&lt;/code&gt; ，或失败的测试用例的序列。请注意，由于 &lt;code&gt;init_per_testcase&lt;/code&gt; 失败而导致测试用例被跳过，因此永远不会收到此事件，因为该信息随事件 &lt;code&gt;tc_done&lt;/code&gt; 传递。如果失败的测试用例属于测试用例组，则第二个数据元素是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="85637c33d8358bfa807af40ed5b12cab4e94ad14" translate="yes" xml:space="preserve">
          <source>This event occurs when a transaction that caused a modification to the database is completed. It is useful for determining when a set of table events (see the next section), caused by a given activity, have been sent. Once this event is received, it is guaranteed that no further table events with the same &lt;code&gt;ActivityID&lt;/code&gt; will be received. Notice that this event can still be received even if no table events with a corresponding &lt;code&gt;ActivityID&lt;/code&gt; were received, depending on the tables to which the receiving process is subscribed.</source>
          <target state="translated">当引起数据库修改的事务完成时，将发生此事件。这对于确定何时发送由给定活动引起的一组表事件（请参阅下一节）非常有用。一旦接收到此事件，就可以保证不会 &lt;code&gt;ActivityID&lt;/code&gt; 收到具有相同ActivityID的表事件。请注意，即使没有接收到具有相应 &lt;code&gt;ActivityID&lt;/code&gt; 的表事件，也仍可以接收到此事件，具体取决于订阅了接收过程的表。</target>
        </trans-unit>
        <trans-unit id="f45e922ec57563cdea35247f1f7ed0e1f7d09af7" translate="yes" xml:space="preserve">
          <source>This event specifies that a test case was skipped by the user. It is only received if the skip is declared in a test specification. Otherwise, user skip information is received as a &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; result in event &lt;code&gt;tc_done&lt;/code&gt; for the test case. If a skipped test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">此事件指定用户跳过了一个测试用例。仅当在测试规范中声明跳过时才接收。否则，将在事件 &lt;code&gt;tc_done&lt;/code&gt; 的测试用例的 &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; 结果中接收用户跳过信息。如果跳过的测试用例属于测试用例组，则第二个数据元素是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="9a24b66f55b1608bf70f4eb21d0c378bcfcc90e0" translate="yes" xml:space="preserve">
          <source>This example back up the contents of the registry to the specified &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;&quot;mtab&quot;&lt;/code&gt;. Once a registry has been backed up to &lt;code&gt;Mnesia&lt;/code&gt; like this, more backups only affect objects that have been modified since the most recent backup, that is, objects that have been created, changed, or deleted. The backup operation is done as a single atomic transaction, so that either the entire backup is performed or none of it.</source>
          <target state="translated">本示例将注册表的内容备份到指定的 &lt;code&gt;Mnesia&lt;/code&gt; 表 &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 。将注册表这样备份到 &lt;code&gt;Mnesia&lt;/code&gt; 后，更多备份将仅影响自最近备份以来已修改的对象，即已创建，更改或删除的对象。备份操作是作为单个原子事务完成的，因此可以执行整个备份，也可以不执行任何备份。</target>
        </trans-unit>
        <trans-unit id="8e5008e4f2f2212bcc7d9051d31593661ec6ce4d" translate="yes" xml:space="preserve">
          <source>This example concerns the body of the fun. Assume that all employee numbers beginning with zero (&lt;code&gt;0&lt;/code&gt;) must be changed to begin with one (&lt;code&gt;1&lt;/code&gt;) instead, and that we want to create the list &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt;:</source>
          <target state="translated">此示例涉及乐趣的主体。假设必须将所有以零（ &lt;code&gt;0&lt;/code&gt; ）开头的员工编号改为以一（ &lt;code&gt;1&lt;/code&gt; ）开头，并且我们要创建列表 &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9cd78123d895f5c9e7c353280ff2f48b8ea86e8" translate="yes" xml:space="preserve">
          <source>This example concerns the use of raw options. Consider a Linux system where you want to set option &lt;code&gt;TCP_LINGER2&lt;/code&gt; on protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt; in the stack. You know that on this particular system it defaults to 60 (seconds), but you want to lower it to 30 for a particular socket. Option &lt;code&gt;TCP_LINGER2&lt;/code&gt; is not explicitly supported by &lt;code&gt;inet&lt;/code&gt;, but you know that the protocol level translates to number 6, the option number to number 8, and the value is to be specified as a 32-bit integer. You can use this code line to set the option for the socket named &lt;code&gt;Sock&lt;/code&gt;:</source>
          <target state="translated">本示例涉及原始选项的使用。考虑一个Linux系统，您要在堆栈中的协议级别 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 上设置选项 &lt;code&gt;TCP_LINGER2&lt;/code&gt; 。您知道在该特定系统上，它的默认值为60（秒），但是对于特定的套接字，您希望将其降低到30。选项 &lt;code&gt;TCP_LINGER2&lt;/code&gt; 不受 &lt;code&gt;inet&lt;/code&gt; 明确支持，但是您知道协议级别转换为数字6，选项编号转换为数字8，并且该值将指定为32位整数。您可以使用此代码行为名为 &lt;code&gt;Sock&lt;/code&gt; 的套接字设置选项：</target>
        </trans-unit>
        <trans-unit id="530266a6d25402966cea0cb8b232a85a4ff316d8" translate="yes" xml:space="preserve">
          <source>This example gives a rough idea of how the new primitives can be used and what kind of output it produces.</source>
          <target state="translated">这个示例大致介绍了如何使用新基元及其产生的输出。</target>
        </trans-unit>
        <trans-unit id="0ddfeb93d9d64b8470aa81333fa112e188816f26" translate="yes" xml:space="preserve">
          <source>This example has two functions:</source>
          <target state="translated">这个例子有两个功能。</target>
        </trans-unit>
        <trans-unit id="2408082cfd117d50361179146f7eb693e76f1486" translate="yes" xml:space="preserve">
          <source>This example illustrates the most used calls in match specifications for &lt;code&gt;dbg&lt;/code&gt;. The other, more esoteric, calls are listed and explained in &lt;code&gt;Match specifications in Erlang&lt;/code&gt; in ERTS User's Guide, as they are beyond the scope of this description.</source>
          <target state="translated">此示例说明了 &lt;code&gt;dbg&lt;/code&gt; 的匹配规范中最常用的调用。其他更深奥的呼叫在ERTS用户指南的 &lt;code&gt;Match specifications in Erlang&lt;/code&gt; 中的Match规范中列出并说明，因为它们不在本说明的范围之内。</target>
        </trans-unit>
        <trans-unit id="033dde8b7dbcadc4f83a911a11c711666e02a4d2" translate="yes" xml:space="preserve">
          <source>This example is, as can be seen, run in an environment where the terminal supports Unicode input and output.</source>
          <target state="translated">可以看出,这个例子是在终端支持Unicode输入和输出的环境下运行的。</target>
        </trans-unit>
        <trans-unit id="140c4136b4fe3317fa34f309b20873f708ff5543" translate="yes" xml:space="preserve">
          <source>This example only shows the message passing logic - no attempt has been made to provide a nice graphical user interface, although this can also be done in Erlang.</source>
          <target state="translated">这个例子只显示了消息传递的逻辑--没有试图提供一个漂亮的图形用户界面,尽管这在Erlang中也可以做到。</target>
        </trans-unit>
        <trans-unit id="d78541768b15176d63561103133f9d3936557387" translate="yes" xml:space="preserve">
          <source>This example requires no special knowledge of match specifications to understand. The head of the fun matches what you want to filter out and the body returns what you want returned. As long as the fun can be kept within the limits of the match specifications, there is no need to transfer all table data to the process for filtering as in the &lt;code&gt;ets:foldr/3&lt;/code&gt; example. It is easier to read than the &lt;code&gt;ets:foldr/3&lt;/code&gt; example, as the select call in itself discards anything that does not match, while the fun of the &lt;code&gt;ets:foldr/3&lt;/code&gt; call needs to handle both the elements matching and the ones not matching.</source>
          <target state="translated">此示例不需要了解匹配规范的特殊知识。乐趣的头部与您要过滤的内容相匹配，主体返回您想要的内容。只要可以将乐趣保持在匹配规范的范围内，就不需要像 &lt;code&gt;ets:foldr/3&lt;/code&gt; 示例中那样将所有表数据传输到用于过滤的过程中。比 &lt;code&gt;ets:foldr/3&lt;/code&gt; 示例更容易阅读，因为select调用本身会丢弃不匹配的任何内容，而 &lt;code&gt;ets:foldr/3&lt;/code&gt; 调用的乐趣则需要处理匹配的元素和不匹配的元素。</target>
        </trans-unit>
        <trans-unit id="742fc993326979930f137bea9115c77d5cbe9464" translate="yes" xml:space="preserve">
          <source>This example showed the use of &lt;code&gt;trunc&lt;/code&gt;. It is easier to use the Erlang operator &lt;code&gt;rem&lt;/code&gt; that gives the remainder after division, for example:</source>
          <target state="translated">这个例子展示了 &lt;code&gt;trunc&lt;/code&gt; 的用法。使用Erlang运算符 &lt;code&gt;rem&lt;/code&gt; 比较容易，该运算符给出除法后的余数，例如：</target>
        </trans-unit>
        <trans-unit id="576a654b801abd888323686420eb2be87d1e88d9" translate="yes" xml:space="preserve">
          <source>This example shows how to construct a key reference that is used in a sign operation. The actual key is stored in the engine that is loaded at prompt 1.</source>
          <target state="translated">这个例子展示了如何构造一个在符号操作中使用的键引用。实际的密钥存储在提示1加载的引擎中。</target>
        </trans-unit>
        <trans-unit id="8fc9c6e1c892b5ff940b330284e799595fb70aed" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database called &lt;code&gt;Company&lt;/code&gt; and the relationships shown in the following diagram:</source>
          <target state="translated">本示例说明如何创建一个名为 &lt;code&gt;Company&lt;/code&gt; 的数据库以及下图所示的关系：</target>
        </trans-unit>
        <trans-unit id="4ce8c4280e865227838d76a758d3b12d799a6916" translate="yes" xml:space="preserve">
          <source>This example shows that a function is generated by the compiler that returns a valid Erlang representation of the value, although the value is of a complex type.</source>
          <target state="translated">这个例子表明,编译器生成了一个函数,该函数返回一个有效的Erlang表示值,尽管该值是一个复杂类型。</target>
        </trans-unit>
        <trans-unit id="50ace829c34f91c2367e23e83ddbe5d2a03a399f" translate="yes" xml:space="preserve">
          <source>This example specifies the same tests as the original example. But now if started with a call to &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt;, test &lt;code&gt;t1&lt;/code&gt; is executed on node &lt;code&gt;ct_node@host_x&lt;/code&gt; (&lt;code&gt;node1&lt;/code&gt;), test &lt;code&gt;t2&lt;/code&gt; on &lt;code&gt;ct_node@host_y&lt;/code&gt; (&lt;code&gt;node2&lt;/code&gt;) and test &lt;code&gt;t3&lt;/code&gt; on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Configuration file &lt;code&gt;t1&lt;/code&gt; is only read on &lt;code&gt;node1&lt;/code&gt; and configuration file &lt;code&gt;t2&lt;/code&gt; only on &lt;code&gt;node2&lt;/code&gt;, while the configuration file &lt;code&gt;t3&lt;/code&gt; is read on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Both test nodes write log files to the same directory. (However, the &lt;code&gt;Common Test&lt;/code&gt; Master node uses a different log directory than the test nodes.)</source>
          <target state="translated">本示例指定与原始示例相同的测试。但现在如果开始调用 &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt; ，测试 &lt;code&gt;t1&lt;/code&gt; 在节点执行 &lt;code&gt;ct_node@host_x&lt;/code&gt; （ &lt;code&gt;node1&lt;/code&gt; ），测试 &lt;code&gt;t2&lt;/code&gt; 上 &lt;code&gt;ct_node@host_y&lt;/code&gt; （ &lt;code&gt;node2&lt;/code&gt; ）和测试 &lt;code&gt;t3&lt;/code&gt; 两个 &lt;code&gt;node1&lt;/code&gt; 和 &lt;code&gt;node2&lt;/code&gt; 。配置文件 &lt;code&gt;t1&lt;/code&gt; 是只读的 &lt;code&gt;node1&lt;/code&gt; ，并配置文件 &lt;code&gt;t2&lt;/code&gt; 只在 &lt;code&gt;node2&lt;/code&gt; ，而配置文件 &lt;code&gt;t3&lt;/code&gt; 读取两个 &lt;code&gt;node1&lt;/code&gt; 和 &lt;code&gt;node2&lt;/code&gt; 。两个测试节点将日志文件写入同一目录。（但是，&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 主&amp;rdquo;节点使用的日志目录与测试节点不同。）</target>
        </trans-unit>
        <trans-unit id="f919e3be6e1b9a58c077da63d3fa4b652b1b834d" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;gen_statem:call/2&lt;/code&gt;, which waits for a reply from the server. The reply is sent with a &lt;code&gt;{reply,From,Reply}&lt;/code&gt; tuple in an action list in the &lt;code&gt;{keep_state, ...}&lt;/code&gt; tuple that retains the current state. This return form is convenient when you want to stay in the current state but do not know or care about what it is.</source>
          <target state="translated">本示例使用 &lt;code&gt;gen_statem:call/2&lt;/code&gt; ，它等待服务器的答复。在 &lt;code&gt;{keep_state, ...}&lt;/code&gt; 元组的操作列表中 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 将使用{reply，From，Reply}元组发送回复，该元组保留当前状态。当您想保持当前状态但不知道或不关心它是什么时，此返回表单很方便。</target>
        </trans-unit>
        <trans-unit id="7e5afbec3d662e48a79fce4ee47d58154c988214" translate="yes" xml:space="preserve">
          <source>This example warrants some explanation:</source>
          <target state="translated">这个例子值得解释一下。</target>
        </trans-unit>
        <trans-unit id="b3dcc44bb471a63d75b0052d4b54fe647a04cb07" translate="yes" xml:space="preserve">
          <source>This example with the &lt;code&gt;file&lt;/code&gt; module operations is not necessary to use directly, as that is what function &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; in principle does.</source>
          <target state="translated">带有 &lt;code&gt;file&lt;/code&gt; 模块操作的该示例不必直接使用，因为原则上 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 是函数。</target>
        </trans-unit>
        <trans-unit id="9e9ac426961d89606271dd5da2f24c9429dfc0a7" translate="yes" xml:space="preserve">
          <source>This expression matches if the expression &lt;code&gt;Expr&lt;/code&gt; is of type map, otherwise it fails with an exception &lt;code&gt;badmatch&lt;/code&gt;.</source>
          <target state="translated">如果表达式 &lt;code&gt;Expr&lt;/code&gt; 的类型为map，则此表达式匹配，否则它将失败，并抛出 &lt;code&gt;badmatch&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="6184c20ff4fb14fe7267625d422557cd4d0fc7b2" translate="yes" xml:space="preserve">
          <source>This expression must be rewritten into the following, to be accepted by the compiler:</source>
          <target state="translated">这个表达式必须改写成以下内容,才能被编译器接受。</target>
        </trans-unit>
        <trans-unit id="87be2665458e0e8a04daa6def7ad816271a337f0" translate="yes" xml:space="preserve">
          <source>This feature also requires &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; to be enabled. When enabling this feature, multiple thread-specific instances are enabled if not already enabled, and the &lt;code&gt;aoffcbf&lt;/code&gt; strategy is enabled if the current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the &lt;code&gt;alloc_util&lt;/code&gt; framework, except &lt;code&gt;temp_alloc&lt;/code&gt; (which would be pointless).</source>
          <target state="translated">此功能还需要启用 &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; 。启用此功能时，如果尚未启用多个特定于线程的实例，则启用该功能；如果当前策略不支持废弃的载波，则启用 &lt;code&gt;aoffcbf&lt;/code&gt; 策略。可以在所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 框架的分配器上启用此功能，但 &lt;code&gt;temp_alloc&lt;/code&gt; 除外（这将毫无意义）。</target>
        </trans-unit>
        <trans-unit id="bab1aaa22d7c52e3e995a41f937d2e85596d7686" translate="yes" xml:space="preserve">
          <source>This feature has been introduced as a temporary workaround for long-executing native code, and native code that does not bump reductions properly in OTP. When these bugs have be fixed, this flag will be removed.</source>
          <target state="translated">此功能的引入是作为一种临时的变通方法,适用于长时间执行的原生代码,以及在OTP中不能正确进行撞库的原生代码。当这些错误被修复后,这个标志将被移除。</target>
        </trans-unit>
        <trans-unit id="f75f84efbe70a72e01ed3ffc4edbe4eb52121806" translate="yes" xml:space="preserve">
          <source>This feature is similar to a lookbehind assertion (described below). However, in this case, the part of the subject before the real match does not have to be of fixed length, as lookbehind assertions do. The use of \K does not interfere with the setting of captured substrings. For example, when the following pattern matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;:</source>
          <target state="translated">这个功能类似于lookbehind断言(如下所述)。然而,在这种情况下,真正匹配之前的主题部分不必像lookbehind断言那样是固定长度的。使用\K不会干扰捕获子串的设置。例如,当下面的模式匹配 &quot;foobar &quot;时,第一个子串仍然被设置为 &quot;foo&quot;。</target>
        </trans-unit>
        <trans-unit id="495e6e419f3ba6bc2ae861673f26fe3c4b80e6f5" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in a future release</source>
          <target state="translated">此功能是暂时的,将在未来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="bd4f30e27a6dd0784703ad9bdea45ca916a2edb1" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in future releases.</source>
          <target state="translated">这个功能是暂时的,在以后的版本中会被删除。</target>
        </trans-unit>
        <trans-unit id="77b5f46e3e133913367475d2045dfdc254bfa20f" translate="yes" xml:space="preserve">
          <source>This feature must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">必须使用源模块中的编译器选项或 &lt;code&gt;-compile()&lt;/code&gt; 属性显式启用此功能。</target>
        </trans-unit>
        <trans-unit id="aa96a44c28979dae84ca1a2a0e7d8160bebc38ef" translate="yes" xml:space="preserve">
          <source>This feature was added in Erlang 5.0/OTP R7.</source>
          <target state="translated">这个功能是在Erlang 5.0/OTP R7中加入的。</target>
        </trans-unit>
        <trans-unit id="1fc9bd5588c9ab451cbffd844cd0ccc06f39f29c" translate="yes" xml:space="preserve">
          <source>This field is either to be equal to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;. An old driver (not aware of the extended driver interface) is to set this field to &lt;code&gt;0&lt;/code&gt;. If this field is &lt;code&gt;0&lt;/code&gt;, all the following fields &lt;strong&gt;must&lt;/strong&gt; also be &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if it is a pointer field.</source>
          <target state="translated">该字段等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 。旧的驱动程序（不知道扩展的驱动程序接口）将将此字段设置为 &lt;code&gt;0&lt;/code&gt; 。如果此字段为 &lt;code&gt;0&lt;/code&gt; ，则以下所有字段也&lt;strong&gt;必须&lt;/strong&gt;为 &lt;code&gt;0&lt;/code&gt; ，如果它是指针字段则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0406d7a19c673109ce77b1bb24bda04bd2987652" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator modifies this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">该字段保留给仿真器内部使用。仿真器会修改此字段，因此不要将 &lt;code&gt;driver_entry&lt;/code&gt; 声明为 &lt;code&gt;const&lt;/code&gt; ，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="881f24225a8501e9d8e685397754715f57019f9b" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator will modify this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">该字段保留给仿真器内部使用。仿真器将修改此字段，因此不要将 &lt;code&gt;driver_entry&lt;/code&gt; 声明为 &lt;code&gt;const&lt;/code&gt; ，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="d71232de0ecbfffa5c29cf32c925bafa8bc48c5f" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">此字段是等于 &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; 如果场 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad9c786ae5049c8d53b5e5f11b7a559ebf7746cc" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">此字段是等于 &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; 如果场 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e98f5c415766c2c77bb045a0e8a36481a3244e3" translate="yes" xml:space="preserve">
          <source>This field is used to pass driver capability and other information to the runtime system. If field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;, it is to contain &lt;code&gt;0&lt;/code&gt; or driver flags (&lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt;) OR'ed bitwise. The following driver flags exist:</source>
          <target state="translated">此字段用于将驱动程序功能和其他信息传递给运行时系统。如果字段 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; ，则它将包含 &lt;code&gt;0&lt;/code&gt; 或驱动程序标志（ &lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt; ）或按位运算。存在以下驱动程序标志：</target>
        </trans-unit>
        <trans-unit id="53e33ba3e6e3853e3483bf977da426923d2e9210" translate="yes" xml:space="preserve">
          <source>This file can be &lt;code&gt;exported&lt;/code&gt; to a file structure by calling the &lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; function. This can be usefull if a measurement shall be done with an external tool. Exporting the messages creates a directory tree with the following structure:</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; 函数将该文件 &lt;code&gt;exported&lt;/code&gt; 为文件结构。如果必须使用外部工具进行测量，这将很有用。导出消息将创建具有以下结构的目录树：</target>
        </trans-unit>
        <trans-unit id="1b4a5fcbbcbba39461ee90e5035cbad9ed093754" translate="yes" xml:space="preserve">
          <source>This file does not need to be created manually, it can be generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. The relevant versions of the &lt;code&gt;.rel&lt;/code&gt; file, &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;.appup&lt;/code&gt; files are used as input. It is deducted which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the &lt;code&gt;.appup&lt;/code&gt; files and transformed into a single list of low-level instructions in the right order.</source>
          <target state="translated">该文件不需要手动创建，可以通过 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成。 &lt;code&gt;.rel&lt;/code&gt; 文件， &lt;code&gt;.app&lt;/code&gt; 文件和 &lt;code&gt;.appup&lt;/code&gt; 文件的相关版本用作输入。可以推断出要添加和删除的应用程序，以及必须升级和/或降级的应用程序。这些指令是从 &lt;code&gt;.appup&lt;/code&gt; 文件中提取的，并以正确的顺序转换为低级指令的单个列表。</target>
        </trans-unit>
        <trans-unit id="9fb48b81944131df296ecee7753475785f0204cf" translate="yes" xml:space="preserve">
          <source>This file is automatically generated by &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;, using a release resource file (&lt;code&gt;.rel&lt;/code&gt;), application resource files (&lt;code&gt;.app&lt;/code&gt;), and application upgrade files (&lt;code&gt;.appup&lt;/code&gt;) as input.</source>
          <target state="translated">该文件由 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 使用释放资源文件（ &lt;code&gt;.rel&lt;/code&gt; ），应用程序资源文件（ &lt;code&gt;.app&lt;/code&gt; ）和应用程序升级文件（ &lt;code&gt;.appup&lt;/code&gt; ）作为输入自动生成。</target>
        </trans-unit>
        <trans-unit id="3aeac0892cbf387cc4689f055a52de4d8bad4eb9" translate="yes" xml:space="preserve">
          <source>This file is included in &lt;code&gt;mess_server.erl&lt;/code&gt;:</source>
          <target state="translated">该文件包含在 &lt;code&gt;mess_server.erl&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="0a6831b7fc3cca45884bb8df55f7ae10d0fb0b2b" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating a release upgrade file &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">生成版本升级文件 &lt;code&gt;relup&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 中的功能使用此文件。</target>
        </trans-unit>
        <trans-unit id="efd4a3fe5e769769e91e2007d57ff8d294a747ea" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating start scripts (&lt;code&gt;.script&lt;/code&gt;, &lt;code&gt;.boot&lt;/code&gt;) and release upgrade files (&lt;code&gt;relup&lt;/code&gt;).</source>
          <target state="translated">生成启动脚本（ &lt;code&gt;.script&lt;/code&gt; ， &lt;code&gt;.boot&lt;/code&gt; ）和发行升级文件（ &lt;code&gt;relup&lt;/code&gt; ）时， &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 中的功能使用此文件。</target>
        </trans-unit>
        <trans-unit id="2d508ac4a54e356dd39279346e885dd774ae9ca6" translate="yes" xml:space="preserve">
          <source>This file must be compiled before it can be used. The ASN.1 compiler checks that the syntax is correct and that the text represents proper ASN.1 code before generating an abstract syntax tree. The code-generator then uses the abstract syntax tree to generate code.</source>
          <target state="translated">这个文件在使用前必须进行编译。ASN.1编译器在生成抽象语法树之前,会检查语法是否正确,文本是否代表正确的ASN.1代码。然后,代码生成器使用抽象语法树生成代码。</target>
        </trans-unit>
        <trans-unit id="868c84f12466baa660608254f7e7fa45a1ab087f" translate="yes" xml:space="preserve">
          <source>This filter matches all events originating from a process that has its group leader on a remote node.</source>
          <target state="translated">该过滤器匹配所有来自远程节点上有组长的进程的事件。</target>
        </trans-unit>
        <trans-unit id="41612185cf4eec8055aef32ce6a1e85ef2253041" translate="yes" xml:space="preserve">
          <source>This filter matches all progress reports from &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">该过滤器匹配 &lt;code&gt;supervisor&lt;/code&gt; 和 &lt;code&gt;application_controller&lt;/code&gt; 的所有进度报告。</target>
        </trans-unit>
        <trans-unit id="3139608738bfff344c3bbc9f537737137e32b777" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on a &lt;code&gt;domain&lt;/code&gt; field in &lt;code&gt;Metadata&lt;/code&gt;. This field is optional, and the purpose of using it is to group log events from, for example, a specific functional area. This allows filtering or other specialized treatment in a Logger handler.</source>
          <target state="translated">该筛选器提供了一种基于 &lt;code&gt;Metadata&lt;/code&gt; 中的 &lt;code&gt;domain&lt;/code&gt; 字段筛选日志事件的方法。该字段是可选的，使用该字段的目的是对来自特定功能区域的日志事件进行分组。这允许在Logger处理程序中进行过滤或其他特殊处理。</target>
        </trans-unit>
        <trans-unit id="d6c38d318267fc9b1e770c2f91391135ae4bc653" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on the log level. It matches log events by comparing the log level with a specified &lt;code&gt;MatchLevel&lt;/code&gt;</source>
          <target state="translated">该过滤器提供了一种基于日志级别过滤日志事件的方法。它通过将日志级别与指定的 &lt;code&gt;MatchLevel&lt;/code&gt; 进行比较来匹配日志事件</target>
        </trans-unit>
        <trans-unit id="d91f4f911f4f31e3b8fc52c8256e3280febf9a2b" translate="yes" xml:space="preserve">
          <source>This first command enables microstate accounting for 1000 milliseconds. See &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; for more details. The second command prints the statistics gathered during that time. First three general statistics are printed.</source>
          <target state="translated">第一条命令启用微状态计费，持续时间为1000毫秒。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 。第二条命令显示在此期间收集的统计信息。将打印前三个常规统计信息。</target>
        </trans-unit>
        <trans-unit id="1bcacf63cfd99cc81866dfa553a1b3c4711304ba" translate="yes" xml:space="preserve">
          <source>This flag affects how the filenames are to be interpreted. On operating systems with transparent file naming, this must be specified to allow for file naming in Unicode characters (and for correct interpretation of filenames containing characters &amp;gt; 255).</source>
          <target state="translated">此标志影响如何解释文件名。在具有透明文件命名的操作系统上，必须指定此项以允许以Unicode字符命名文件（并正确解释包含&amp;gt; 255个字符的文件名）。</target>
        </trans-unit>
        <trans-unit id="401ad721e8e42c6f1dc3f91e171c1c2bd9b985da" translate="yes" xml:space="preserve">
          <source>This flag affects what is interpreted as string data when doing heuristic string detection in the shell and in &lt;code&gt;io&lt;/code&gt;/ &lt;code&gt;io_lib:format&lt;/code&gt; with the &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; and &lt;code&gt;~tP&lt;/code&gt; formatting instructions, as described earlier.</source>
          <target state="translated">这个标志会影响壳做启发式检测字符串时什么被解释为字符串数据 &lt;code&gt;io&lt;/code&gt; / &lt;code&gt;io_lib:format&lt;/code&gt; 与 &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; 和 &lt;code&gt;~tP&lt;/code&gt; 格式化指令，如前面所述。</target>
        </trans-unit>
        <trans-unit id="b90bcd3825735414823381e680fcf705ea0d5299" translate="yes" xml:space="preserve">
          <source>This flag can be removed or changed at any time without prior notice.</source>
          <target state="translated">此旗帜可随时删除或更改,无需事先通知。</target>
        </trans-unit>
        <trans-unit id="a25b86654b752dec058dc76f9788b85101c1cf33" translate="yes" xml:space="preserve">
          <source>This flag determines how messages in the message queue are stored, as follows:</source>
          <target state="translated">该标志决定了消息队列中消息的存储方式,具体如下。</target>
        </trans-unit>
        <trans-unit id="af384f81db1d48b161cd5aace187074a44597516" translate="yes" xml:space="preserve">
          <source>This flag field is optional.</source>
          <target state="translated">这个标志字段是可选的。</target>
        </trans-unit>
        <trans-unit id="26248d39ec39b326e49e6de9a0200d4728253816" translate="yes" xml:space="preserve">
          <source>This flag has effect only when the emulator is linked with the GNU C library, and uses its &lt;code&gt;malloc&lt;/code&gt; implementation.</source>
          <target state="translated">仅当仿真器与GNU C库链接并使用其 &lt;code&gt;malloc&lt;/code&gt; 实现时，此标志才有效。</target>
        </trans-unit>
        <trans-unit id="f4f9950c6c7df7d55c31f657a13915f580c4acd7" translate="yes" xml:space="preserve">
          <source>This flag is particular useful when you want to elaborate with code loading from archives without editing the &lt;code&gt;boot script&lt;/code&gt;. For more information about interpretation of boot scripts, see &lt;code&gt;script(4)&lt;/code&gt;. The flag has also a similar effect on how the code server works; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">当您要详细说明从归档文件加载代码而不编辑 &lt;code&gt;boot script&lt;/code&gt; 时，此标志特别有用。有关启动脚本解释的更多信息，请参见 &lt;code&gt;script(4)&lt;/code&gt; 。该标志对代码服务器的工作方式也有类似的影响。参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dbde97932c8eaba9606eccfc93ef4a1443c2369" translate="yes" xml:space="preserve">
          <source>This flag sets the maximum heap size for the calling process. If &lt;code&gt;MaxHeapSize&lt;/code&gt; is an integer, the system default values for &lt;code&gt;kill&lt;/code&gt; and &lt;code&gt;error_logger&lt;/code&gt; are used.</source>
          <target state="translated">此标志设置调用进程的最大堆大小。如果 &lt;code&gt;MaxHeapSize&lt;/code&gt; 是整数，则使用 &lt;code&gt;kill&lt;/code&gt; 和 &lt;code&gt;error_logger&lt;/code&gt; 的系统默认值。</target>
        </trans-unit>
        <trans-unit id="f9f03daf9384ca8f19df9da9a248cad12c12009a" translate="yes" xml:space="preserve">
          <source>This following definition of a &lt;code&gt;person&lt;/code&gt; is used in several examples in this section. Three fields are included, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt;, and &lt;code&gt;address&lt;/code&gt;. The default values for &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;phone&lt;/code&gt; is &quot;&quot; and [], respectively. The default value for &lt;code&gt;address&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;, since no default value is supplied for this field:</source>
          <target state="translated">在部分中的以下示例中使用了以下对 &lt;code&gt;person&lt;/code&gt; 定义。包括三个字段， &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;phone&lt;/code&gt; 和 &lt;code&gt;address&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;phone&lt;/code&gt; 的默认值分别是&amp;ldquo;&amp;rdquo;和[]。 &lt;code&gt;address&lt;/code&gt; 的默认值是原子 &lt;code&gt;undefined&lt;/code&gt; ，因为此字段没有提供默认值：</target>
        </trans-unit>
        <trans-unit id="02f5811e131af42f984f54f852032dfcb1311211" translate="yes" xml:space="preserve">
          <source>This form can also be used in header files (.hrl) to declare type information for exported functions. Then these header files can be included in files that (implicitly or explicitly) import these functions.</source>
          <target state="translated">这种形式也可以在头文件(.hrl)中用于声明导出函数的类型信息。然后这些头文件可以包含在(隐式或显式)导入这些函数的文件中。</target>
        </trans-unit>
        <trans-unit id="2059c23a56cf58a2c4674e36d5fde6d6cdf2124b" translate="yes" xml:space="preserve">
          <source>This form is the one mostly used in the &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">这种形式是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; 部分中最常用的形式。</target>
        </trans-unit>
        <trans-unit id="966c16aa39dbb79b8cefa816f56010ae727285a2" translate="yes" xml:space="preserve">
          <source>This format can be used for printing any object and truncating the output so it fits a specified field:</source>
          <target state="translated">此格式可用于打印任何对象,并截断输出,使其适合指定的字段。</target>
        </trans-unit>
        <trans-unit id="96bf1314fc9e30514fade10f4ed25bb52dc94221" translate="yes" xml:space="preserve">
          <source>This formats the text like &lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; and outputs it like &lt;code&gt;debugMsg&lt;/code&gt;. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">这会像 &lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; 这样格式化文本，并像 &lt;code&gt;debugMsg&lt;/code&gt; 一样输出文本。结果总是 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1dba461392e21176e94cffd9044c02a52e238da" translate="yes" xml:space="preserve">
          <source>This fun can also be used to make delays in authentication tries for example by calling &lt;code&gt;timer:sleep/1&lt;/code&gt;.</source>
          <target state="translated">这种乐趣也可用于延迟身份验证尝试，例如通过调用 &lt;code&gt;timer:sleep/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="336ab36451349be053fe7e9e786bb4268ca4fe0b" translate="yes" xml:space="preserve">
          <source>This function (&lt;code&gt;mnesia:activity/4&lt;/code&gt;) differs in an important way from the functions &lt;code&gt;mnesia:transaction&lt;/code&gt;, &lt;code&gt;mnesia:sync_transaction&lt;/code&gt;, &lt;code&gt;mnesia:async_dirty&lt;/code&gt;, &lt;code&gt;mnesia:sync_dirty&lt;/code&gt;, and &lt;code&gt;mnesia:ets&lt;/code&gt;. Argument &lt;code&gt;AccessMod&lt;/code&gt; is the name of a callback module, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; behavior.</source>
          <target state="translated">此函数（ &lt;code&gt;mnesia:activity/4&lt;/code&gt; ）与函数 &lt;code&gt;mnesia:transaction&lt;/code&gt; ， &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; ， &lt;code&gt;mnesia:async_dirty&lt;/code&gt; ， &lt;code&gt;mnesia:sync_dirty&lt;/code&gt; 和 &lt;code&gt;mnesia:ets&lt;/code&gt; 有重要的不同。参数 &lt;code&gt;AccessMod&lt;/code&gt; 是回调模块的名称，该模块实现 &lt;code&gt;mnesia_access&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="a856a99360229d9e49c9035cef153bdfeb299a54" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;never&lt;/strong&gt; returns. It calls either of the following functions:</source>
          <target state="translated">该函数&lt;strong&gt;永不&lt;/strong&gt;返回。它调用以下功能之一：</target>
        </trans-unit>
        <trans-unit id="dfd2b9df4a36c64900ffcea705f4eb600cd796ec" translate="yes" xml:space="preserve">
          <source>This function adds a remote node (&lt;code&gt;Nodename&lt;/code&gt;) to the list of nodes where tracing is performed. It starts a tracer process on the remote node, which will send all trace messages to the tracer process on the local node (via the Erlang distribution). If no tracer process is running on the local node, the error reason &lt;code&gt;no_local_tracer&lt;/code&gt; is returned. The tracer process on the local node must be started with the &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">此功能将远程节点（ &lt;code&gt;Nodename&lt;/code&gt; ）添加到执行跟踪的节点列表中。它在远程节点上启动跟踪程序，该跟踪程序会将所有跟踪消息发送到本地节点上的跟踪程序（通过Erlang分发）。如果本地节点上没有跟踪程序运行，则返回错误原因 &lt;code&gt;no_local_tracer&lt;/code&gt; 。本地节点上的跟踪器进程必须使用 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; 功能启动。</target>
        </trans-unit>
        <trans-unit id="e377bf478ddc23f833b9b7a7f1af28105f09ad03" translate="yes" xml:space="preserve">
          <source>This function always creates a new binary, even if &lt;code&gt;N = 1&lt;/code&gt;. By using &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; on a binary referencing a larger binary, one can free up the larger binary for garbage collection.</source>
          <target state="translated">即使 &lt;code&gt;N = 1&lt;/code&gt; ，此函数也始终创建一个新的二进制文件。通过在引用较大二进制文件的二进制文件上使用 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; ，可以释放较大的二进制文件以进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="72153fe9aa2fe79a7632e3bef35203ef37b284e3" translate="yes" xml:space="preserve">
          <source>This function and the related &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; provide a uniform way to extend the set of &lt;code&gt;erl_parse&lt;/code&gt; node types. The associated data is any term, whose format may depend on the type tag.</source>
          <target state="translated">该函数以及相关的 &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; 提供了一种统一的方式来扩展 &lt;code&gt;erl_parse&lt;/code&gt; 节点类型集。关联数据是任何术语，其格式可能取决于类型标签。</target>
        </trans-unit>
        <trans-unit id="433b989897815cc9d57ace923542cbea3cc51b3e" translate="yes" xml:space="preserve">
          <source>This function associates a match specification with trace event &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;. By default all executed &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; events are traced if enabled for a process. A match specification can be used to filter traced events based on sender, receiver and/or message content.</source>
          <target state="translated">该函数将匹配规范与跟踪事件 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; 关联。默认情况下，如果为进程启用了所有执行的 &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 事件，则将对其进行跟踪。匹配规范可用于基于发送者，接收者和/或消息内容来过滤跟踪的事件。</target>
        </trans-unit>
        <trans-unit id="89635cf270dd169c3a41d472bf8e396339e0014e" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt;, but takes a third parameter, a list of options. The only option is &lt;code&gt;noconnect&lt;/code&gt;, which makes the function return &lt;code&gt;false&lt;/code&gt; if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option &lt;code&gt;noconnect&lt;/code&gt; makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</source>
          <target state="translated">该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt; ，但采用第三个参数，即选项列表。唯一的选择是 &lt;code&gt;noconnect&lt;/code&gt; ，如果本地节点当前无法访问远程节点，则该函数将返回 &lt;code&gt;false&lt;/code&gt; 。正常行为是尝试连接到节点，这可能会在短时间内使进程停止。使用选项 &lt;code&gt;noconnect&lt;/code&gt; 可以确保在发送到远程进程时不会有丝毫延迟。当与希望始终是连接部分的节点（即，用C或Java编写的节点）进行通信时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="83333525c2547e13927665951a088eb3ec49c561" translate="yes" xml:space="preserve">
          <source>This function broadcasts a message to a list of processes:</source>
          <target state="translated">该函数向进程列表广播消息。</target>
        </trans-unit>
        <trans-unit id="acaeb65b7a88cf8025f411bf5bf4220c48f96174" translate="yes" xml:space="preserve">
          <source>This function can also be used to add a replica of the table named &lt;code&gt;schema&lt;/code&gt;.</source>
          <target state="translated">此函数还可用于添加名为 &lt;code&gt;schema&lt;/code&gt; 的表的副本。</target>
        </trans-unit>
        <trans-unit id="e0129c56bbfa8049fef6fe88075e59972e7cc29c" translate="yes" xml:space="preserve">
          <source>This function can also be used to change the storage type of the table named &lt;code&gt;schema&lt;/code&gt;. The schema table can only have &lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt; as the storage type. If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, no other table can be disc-resident on that node.</source>
          <target state="translated">此函数还可用于更改名为 &lt;code&gt;schema&lt;/code&gt; 的表的存储类型。模式表只能将 &lt;code&gt;ram_copies&lt;/code&gt; 或 &lt;code&gt;disc_copies&lt;/code&gt; 作为存储类型。如果架构的存储类型为 &lt;code&gt;ram_copies&lt;/code&gt; ，则该表上不能再有其他表驻留在该磁盘上。</target>
        </trans-unit>
        <trans-unit id="298f0bbfcd306bc36a218e1e5c945f51e02abf73" translate="yes" xml:space="preserve">
          <source>This function can also be used to delete a replica of the table named &lt;code&gt;schema&lt;/code&gt;. The Mnesia node is then removed. Notice that Mnesia must be stopped on the node first.</source>
          <target state="translated">此函数还可用于删除名为 &lt;code&gt;schema&lt;/code&gt; 的表的副本。然后删除Mnesia节点。请注意，必须先在节点上停止Mnesia。</target>
        </trans-unit>
        <trans-unit id="81355cc6547701f3b5dbcf62012e8964f7fd6864" translate="yes" xml:space="preserve">
          <source>This function can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">进程可以调用此函数以从本地主机上的EPMD中注销指定的节点。但是，这通常是不允许的，除非EPMD以标志 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 启动，但通常不会。</target>
        </trans-unit>
        <trans-unit id="0b9254d1fc6a965191d944b7d91a6f039c16821e" translate="yes" xml:space="preserve">
          <source>This function can be called from any thread if a &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; associated with the &lt;code&gt;port&lt;/code&gt; is locked by the calling thread during the call.</source>
          <target state="translated">此功能可以从任何线程，如果一个被称为 &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; 与相关的 &lt;code&gt;port&lt;/code&gt; 是通过调用线程在通话过程中锁定。</target>
        </trans-unit>
        <trans-unit id="f6c82e6849bd9680e104431bbaa2e398b9142d98" translate="yes" xml:space="preserve">
          <source>This function can be called from the net_if process at start-up. The options list defines which versions to use.</source>
          <target state="translated">这个函数可以在启动时从net_if进程中调用。选项列表定义了要使用的版本。</target>
        </trans-unit>
        <trans-unit id="f2ad971b905f90b5afe4b3c7ffde91a0186892d8" translate="yes" xml:space="preserve">
          <source>This function can be called from the shell as follows:</source>
          <target state="translated">这个函数可以在shell中调用,如下所示。</target>
        </trans-unit>
        <trans-unit id="522d795e31428058f3384591f93786fc5c38e61f" translate="yes" xml:space="preserve">
          <source>This function can be called multiple times per tracepoint, so it is important that it is both fast and without side effects.</source>
          <target state="translated">这个函数每个tracecepoint可以调用多次,所以既要快又要无副作用。</target>
        </trans-unit>
        <trans-unit id="19493e2b3285e45af7ae976c2c5428e204167ea2" translate="yes" xml:space="preserve">
          <source>This function can be described as a &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; function that does not delete any elements, but only counts them.</source>
          <target state="translated">可以将此函数描述为 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 函数，该函数不删除任何元素，仅对其进行计数。</target>
        </trans-unit>
        <trans-unit id="ce984ece3bfa8ffe74ac15019b28eb788ccbbd1c" translate="yes" xml:space="preserve">
          <source>This function can be used as follows:</source>
          <target state="translated">该功能的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="85a27177a667f0e1465cbdbd2008515b2cc73a28" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_server&lt;/code&gt; process to explicitly send a reply to a client that called &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_server&lt;/code&gt; 进程可以使用此函数将答复显式发送给称为 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 的客户端。</target>
        </trans-unit>
        <trans-unit id="08f1b8ca49849c35cc0d4d177f183a0add904508" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_statem&lt;/code&gt; to explicitly send a reply to a process that waits in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; when the reply cannot be defined in the return value of a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_statem&lt;/code&gt; 可以使用此函数将答复显式发送到在 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 中等待的进程。</target>
        </trans-unit>
        <trans-unit id="8ea9dc0753a135b5574eec22abe8e746d04ba274" translate="yes" xml:space="preserve">
          <source>This function can be used by a channel to send a reply to a client that called &lt;code&gt;call/[2,3]&lt;/code&gt; when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时，通道可以使用此函数将答复发送给名为 &lt;code&gt;call/[2,3]&lt;/code&gt; 的客户端。</target>
        </trans-unit>
        <trans-unit id="db47f123c4d7737adc530bd1064733d21b41df5e" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. The crash report is sent using &lt;code&gt;logger(3)&lt;/code&gt;, and the event to be handled is of the format &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt;, where &lt;code&gt;GL&lt;/code&gt; is the group leader pid of process &lt;code&gt;Pid&lt;/code&gt; that sent the crash report.</source>
          <target state="translated">用户定义的旧版 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序可以使用此函数来格式化崩溃报告。使用 &lt;code&gt;logger(3)&lt;/code&gt; 发送崩溃报告，并且要处理的事件的格式为 &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt; ，其中 &lt;code&gt;GL&lt;/code&gt; 是发送崩溃报告的进程 &lt;code&gt;Pid&lt;/code&gt; 的组长pid。。</target>
        </trans-unit>
        <trans-unit id="9ee5cef59a670b3b68b71dece0a9f5e79fdb8155" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt;.</source>
          <target state="translated">用户定义的旧版 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序可以使用此函数来格式化崩溃报告。当Depth指定为正整数时，它在格式字符串中用于限制输出，如下所示： &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="617658033c030647cebceeeec015013360ae0d7a" translate="yes" xml:space="preserve">
          <source>This function can be used for sending &lt;code&gt;rpc&lt;/code&gt; requests that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">此功能可用于发送该模块中其他接口功能无法表达的 &lt;code&gt;rpc&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="42e7b32dc0277f5046892f45b1b0cb119299d8f7" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; to check if the status column of a table is modified.</source>
          <target state="translated">此函数可以在 &lt;code&gt;is_set_ok&lt;/code&gt; 的检测功能中使用， &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 为检查表的状态列是否被修改。</target>
        </trans-unit>
        <trans-unit id="fc3c92535fa29f8db696545ba3457c73577af82b" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve a given part of the table info.</source>
          <target state="translated">这个函数可以在仪表函数中用来检索表格信息的某一部分。</target>
        </trans-unit>
        <trans-unit id="7cdbbfa3213f416586603dfe437066c58b3bceec" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve the index types part of the table info.</source>
          <target state="translated">这个函数可以在仪表函数中用来检索表信息中的索引类型部分。</target>
        </trans-unit>
        <trans-unit id="f7be1756bfcf7a6c64caef1e2a4983a257ac163e" translate="yes" xml:space="preserve">
          <source>This function can be used to add an AGENT-CAPABILITY statement to the sysORTable in the agent. The table is defined in the SNMPv2-MIB.</source>
          <target state="translated">这个函数可以用来向代理中的sysORTable添加AGENT-CAPABILITY语句。该表在SNMPv2-MIB中定义。</target>
        </trans-unit>
        <trans-unit id="c7dac437f7278e03fe570daafa7cce023be74ce5" translate="yes" xml:space="preserve">
          <source>This function can be used to delete an AGENT-CAPABILITY statement to the sysORTable in the agent. This table is defined in the SNMPv2-MIB.</source>
          <target state="translated">这个函数可以用来删除代理中sysORTable的AGENT-CAPABILITY语句。该表在SNMPv2-MIB中定义。</target>
        </trans-unit>
        <trans-unit id="1102b37c65aef3cec918cc4b7670f14b8a81dbe0" translate="yes" xml:space="preserve">
          <source>This function can be used to load object code on remote Erlang nodes. Argument &lt;code&gt;Binary&lt;/code&gt; must contain object code for &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Filename&lt;/code&gt; is only used by the code server to keep a record of from which file the object code for &lt;code&gt;Module&lt;/code&gt; comes. Thus, &lt;code&gt;Filename&lt;/code&gt; is not opened and read by the code server.</source>
          <target state="translated">此功能可用于在远程Erlang节点上加载目标代码。参数 &lt;code&gt;Binary&lt;/code&gt; 必须包含 &lt;code&gt;Module&lt;/code&gt; 的目标代码。 &lt;code&gt;Filename&lt;/code&gt; 仅由代码服务器用来记录 &lt;code&gt;Module&lt;/code&gt; 的对象代码来自哪个文件。因此， &lt;code&gt;Filename&lt;/code&gt; 不会被代码服务器打开和读取。</target>
        </trans-unit>
        <trans-unit id="8a7a1c49364121587618310df79e658f758f578a" translate="yes" xml:space="preserve">
          <source>This function can be used to manually dump the database to file.</source>
          <target state="translated">这个功能可以用来手动将数据库转储到文件中。</target>
        </trans-unit>
        <trans-unit id="b39cd5560dc28e0d7d30d0cfa028ea7e687fcd3a" translate="yes" xml:space="preserve">
          <source>This function can be used to receive asynchronous notifications when OS-specific event objects become ready for either read or write operations.</source>
          <target state="translated">当操作系统特定的事件对象准备好进行读或写操作时,该函数可用于接收异步通知。</target>
        </trans-unit>
        <trans-unit id="4f3a58dc913baae062f654243c29c7f5eb0a4f46" translate="yes" xml:space="preserve">
          <source>This function can be used to restore an opaque continuation returned by &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; if the continuation has passed through external term format (been sent between nodes or stored on disk).</source>
          <target state="translated">如果连续性已通过外部术语格式传递（在节点之间发送或存储在磁盘上），则此功能可用于恢复由 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 返回的不透明连续性。</target>
        </trans-unit>
        <trans-unit id="fd7807ec473936d9df7098fd46d3b3b79853551d" translate="yes" xml:space="preserve">
          <source>This function can be useful when a node is started, and the names of the other network nodes are not initially known.</source>
          <target state="translated">当一个节点被启动,而其他网络节点的名称最初并不知道时,这个功能可以很有用。</target>
        </trans-unit>
        <trans-unit id="2f62afda090010612a0f62b821ddb83bdcfdcffb" translate="yes" xml:space="preserve">
          <source>This function can fail with one of the following error reasons:</source>
          <target state="translated">该函数可能因以下错误原因而失败。</target>
        </trans-unit>
        <trans-unit id="ba63a9a987b164fc62f29fa35526154bc8f7f106" translate="yes" xml:space="preserve">
          <source>This function can introduce some output latency (reading input without producing any output).</source>
          <target state="translated">这个函数可能会引入一些输出延迟(读取输入而不产生任何输出)。</target>
        </trans-unit>
        <trans-unit id="988314974f83c89323479c44bd0becefb3b2384f" translate="yes" xml:space="preserve">
          <source>This function can not change the result of the test case by returning skip or fail tuples, but it may insert items in &lt;code&gt;Config&lt;/code&gt; that can be read in &lt;code&gt;end_per_testcase/2&lt;/code&gt; or in &lt;code&gt;post_end_per_testcase/5&lt;/code&gt;.</source>
          <target state="translated">此函数无法通过返回跳过或失败元组来更改测试用例的结果，但是它可能会在 &lt;code&gt;Config&lt;/code&gt; 中插入可以在 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 或 &lt;code&gt;post_end_per_testcase/5&lt;/code&gt; 中读取的项目。</target>
        </trans-unit>
        <trans-unit id="6e10609e0797e589efd9411b6aba855461126929" translate="yes" xml:space="preserve">
          <source>This function can only be used from a NIF-calling thread, and with an environment corresponding to currently executing processes.</source>
          <target state="translated">该函数只能在NIF调用的线程中使用,且环境与当前执行的进程相对应。</target>
        </trans-unit>
        <trans-unit id="e042388a21a809a3fccbdc2d157a9abe40eeec97" translate="yes" xml:space="preserve">
          <source>This function can return multiple addresses for multihomed sockets, such as SCTP sockets. For other sockets it returns a one-element list.</source>
          <target state="translated">这个函数可以返回多套接字的多个地址,比如SCTP套接字。对于其他套接字,它返回一个单元素列表。</target>
        </trans-unit>
        <trans-unit id="11d63c52aba2de9f19866ae14e84baa28f340645" translate="yes" xml:space="preserve">
          <source>This function cannot be used on &lt;code&gt;local_content&lt;/code&gt; tables.</source>
          <target state="translated">此函数不能在 &lt;code&gt;local_content&lt;/code&gt; 表上使用。</target>
        </trans-unit>
        <trans-unit id="fe1d649e804662b3a5a46052ca328e2902ff015f" translate="yes" xml:space="preserve">
          <source>This function checks if a date is a valid.</source>
          <target state="translated">该函数检查日期是否有效。</target>
        </trans-unit>
        <trans-unit id="3517712921153c86ac3e375c1576c43c6781f969" translate="yes" xml:space="preserve">
          <source>This function checks that the</source>
          <target state="translated">该函数检查</target>
        </trans-unit>
        <trans-unit id="ddd56f29dbf260ed1f448685268e0f12bf606e89" translate="yes" xml:space="preserve">
          <source>This function checks whether microstate accounting is available or not.</source>
          <target state="translated">该功能可以检查是否有微观状态的核算。</target>
        </trans-unit>
        <trans-unit id="e7a6086739c9e28533ed8c3e368502ee3f910824" translate="yes" xml:space="preserve">
          <source>This function clears match specifications for the specified trace event (&lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;). It will revert back to the default behavior of tracing all triggered events.</source>
          <target state="translated">此函数清除指定跟踪事件（ &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; ）的匹配规范。它将恢复为跟踪所有触发事件的默认行为。</target>
        </trans-unit>
        <trans-unit id="6638616d01daa0310e5374bdd67d7c94f4479869" translate="yes" xml:space="preserve">
          <source>This function controls if user tags are to be spread to other processes with the next message. Spreading of user tags work like spreading of sequential trace tokens, so that a received user tag will be active in the process until the next message arrives (if that message does not also contain the user tag.</source>
          <target state="translated">这个函数控制用户标签是否要随着下一个消息扩散到其他进程。用户标签的传播工作就像传播顺序跟踪令牌一样,因此,收到的用户标签将在进程中处于活动状态,直到下一个消息到达(如果该消息不包含用户标签)。</target>
        </trans-unit>
        <trans-unit id="3f633655709ac9db491c14cd930f2f22fb70ea32" translate="yes" xml:space="preserve">
          <source>This function creates a trace port generating &lt;strong&gt;fun&lt;/strong&gt;. The &lt;strong&gt;fun&lt;/strong&gt; takes no arguments and returns a newly opened trace port. The return value from this function is suitable as a second parameter to tracer/2, i.e. &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt;.</source>
          <target state="translated">此函数创建一个跟踪端口，从而产生&lt;strong&gt;乐趣&lt;/strong&gt;。的&lt;strong&gt;乐趣&lt;/strong&gt;不带任何参数，并返回一个新开的跟踪端口。此函数的返回值适合作为tracer / 2的第二个参数，即 &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39c3cc91bfce26f7b990777dc0e4b36098e14e8" translate="yes" xml:space="preserve">
          <source>This function destructively update the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at position &lt;code&gt;Pos&lt;/code&gt;. The new counter value is returned. If no position is specified, the element directly following key (&lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt;) is updated.</source>
          <target state="translated">通过在表 &lt;code&gt;Pos&lt;/code&gt; 上的元素上增加 &lt;code&gt;Incr&lt;/code&gt; ，此功能可使用表 &lt;code&gt;Tab&lt;/code&gt; 中的键 &lt;code&gt;Key&lt;/code&gt; 破坏性地更新对象。返回新的计数器值。如果未指定位置，则更新键（ &lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt; ）之后的元素。</target>
        </trans-unit>
        <trans-unit id="ae92bc5423506c0c5495964ace9028451dd49af5" translate="yes" xml:space="preserve">
          <source>This function destructively updates the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt;. The element at position &lt;code&gt;Pos&lt;/code&gt; is given the value &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="translated">此功能使用表 &lt;code&gt;Tab&lt;/code&gt; 中的键 &lt;code&gt;Key&lt;/code&gt; 破坏性地更新对象。位置 &lt;code&gt;Pos&lt;/code&gt; 上的元素的值为 &lt;code&gt;Value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dbc5b017b8dfa31be93dfdf684be5e007a7e9bb" translate="yes" xml:space="preserve">
          <source>This function determines the set of modules to compile and the compile options to use, by first looking for the &lt;code&gt;emake&lt;/code&gt; make option, if not present reads the configuration from a file named &lt;code&gt;Emakefile&lt;/code&gt; (see below). If no such file is found, the set of modules to compile defaults to all modules in the current working directory.</source>
          <target state="translated">该功能通过首先查找 &lt;code&gt;emake&lt;/code&gt; make选项（如果不存在）从名为 &lt;code&gt;Emakefile&lt;/code&gt; 的文件中读取配置（请参见下文）来确定要编译的模块集和要使用的compile选项。如果找不到此类文件，则默认情况下，要编译的模块集为当前工作目录中的所有模块。</target>
        </trans-unit>
        <trans-unit id="64faa483024d3289527baea651fb01006a7adc8e" translate="yes" xml:space="preserve">
          <source>This function disables call tracing on the specified functions. The semantics of the parameter is the same as for the corresponding function specification in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;. Both local and global call trace is disabled.</source>
          <target state="translated">此功能禁用指定功能上的呼叫跟踪。参数的语义与 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 中的相应功能规范相同。本地和全局呼叫跟踪均被禁用。</target>
        </trans-unit>
        <trans-unit id="730e9eafa28a60b99c0ff8551559f6cf3f087431" translate="yes" xml:space="preserve">
          <source>This function does not address the problem of a deadlock. A deadlock can never occur as long as processes only lock one resource at a time. A deadlock can occur if some processes try to lock two or more resources. It is up to the application to detect and rectify a deadlock.</source>
          <target state="translated">这个函数并不能解决死锁的问题。只要进程一次只锁定一个资源,就不会发生死锁。如果一些进程试图锁定两个或更多的资源,就会发生死锁。由应用程序来检测和纠正死锁。</target>
        </trans-unit>
        <trans-unit id="35227fc1f3835cb57763b0f1a4bfacec807769bc" translate="yes" xml:space="preserve">
          <source>This function does not return. It handles the system message and then either calls the following if process execution is to continue:</source>
          <target state="translated">这个函数不返回。它处理系统消息,然后如果要继续执行进程,则调用以下函数。</target>
        </trans-unit>
        <trans-unit id="faacbdb3dacf5784f01df9011f0ba223b7d60c23" translate="yes" xml:space="preserve">
          <source>This function does the same as (and does call) the &lt;code&gt;hibernate/3&lt;/code&gt; BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</source>
          <target state="translated">此功能与 &lt;code&gt;hibernate/3&lt;/code&gt; BIF 相同（并且确实会进行调用），但可确保在进程唤醒时异常处理和日志记录按预期继续工作。</target>
        </trans-unit>
        <trans-unit id="36733f4f0e4a47c473ebe622e8727d51028dd793" translate="yes" xml:space="preserve">
          <source>This function enables call trace for one or more functions. All exported functions matching the &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; argument will be concerned, but the &lt;code&gt;match_spec()&lt;/code&gt; may further narrow down the set of function calls generating trace messages.</source>
          <target state="translated">此功能启用一个或多个功能的呼叫跟踪。将考虑所有与 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 参数匹配的导出函数，但是 &lt;code&gt;match_spec()&lt;/code&gt; 可以进一步缩小生成跟踪消息的函数调用的范围。</target>
        </trans-unit>
        <trans-unit id="368666e6ad2867a60cda73d9bf0c86e3149c145a" translate="yes" xml:space="preserve">
          <source>This function ensures that the results displayed by &lt;code&gt;analyze/0,1,2&lt;/code&gt; are printed both to the file &lt;code&gt;File&lt;/code&gt; and the screen.</source>
          <target state="translated">此功能确保将 &lt;code&gt;analyze/0,1,2&lt;/code&gt; 显示的结果打印到文件 &lt;code&gt;File&lt;/code&gt; 和屏幕上。</target>
        </trans-unit>
        <trans-unit id="1a7330bbeab182a749c3e5f5deba94d5a86ea474" translate="yes" xml:space="preserve">
          <source>This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. &lt;code&gt;Process&lt;/code&gt; can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process &lt;code&gt;Pid&lt;/code&gt; fetched through an &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; function call.</source>
          <target state="translated">此函数提取使用此模块中的spawn或start函数之一启动的进程的初始调用，并将其转换为更多有用的信息。 &lt;code&gt;Process&lt;/code&gt; 可以是pid，整数元组（可以从中创建pid），也可以是通过 &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; 函数调用获取的进程 &lt;code&gt;Pid&lt;/code&gt; 的进程信息。</target>
        </trans-unit>
        <trans-unit id="e682f273c8e96989f5d96e73eb77713bc1444f02" translate="yes" xml:space="preserve">
          <source>This function fails if the atom is too long for the buffer or if it cannot be represented with encoding &lt;code&gt;want&lt;/code&gt;.</source>
          <target state="translated">如果该原子对于缓冲区而言太长，或者无法用 &lt;code&gt;want&lt;/code&gt; 编码表示，则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="0da14902361aba9b7fcf3f2ac32b625e0ac51f73" translate="yes" xml:space="preserve">
          <source>This function first attempts to autoload &lt;code&gt;Module&lt;/code&gt;. If that is not possible, an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">此函数首先尝试自动加载 &lt;code&gt;Module&lt;/code&gt; 。如果这不可能，则会引发 &lt;code&gt;undef&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="2d26740fa881de95c3af6c29ab8da1324a33cbdf" translate="yes" xml:space="preserve">
          <source>This function first spawns a process &lt;code&gt;P&lt;/code&gt; which evaluates &lt;code&gt;Fun()&lt;/code&gt; or &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt;. Then, it starts profiling for &lt;code&gt;P&lt;/code&gt; and the processes in &lt;code&gt;Rootset&lt;/code&gt; (and any new processes spawned from them). Information about activity in any profiled process is stored in the Eprof database.</source>
          <target state="translated">此函数首先产生一个进程 &lt;code&gt;P&lt;/code&gt; ，该进程评估 &lt;code&gt;Fun()&lt;/code&gt; 或 &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt; 。然后，它开始对 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;Rootset&lt;/code&gt; 中的进程（以及由此产生的任何新进程）进行性能分析。有关任何概要分析过程中的活动的信息都存储在Eprof数据库中。</target>
        </trans-unit>
        <trans-unit id="a51eb8328b3ca7e73bd2ddec9c6cd1f1f6bce2fa" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.</source>
          <target state="translated">如果未为过程字典中的状态中指定的算法实现跳转功能，则此函数会生成一个 &lt;code&gt;not_implemented&lt;/code&gt; 错误异常。</target>
        </trans-unit>
        <trans-unit id="886d1bea974ef611ef862bdf736eeb1b8ee5deb0" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state.</source>
          <target state="translated">如果未为状态中指定的算法实现跳转功能，则此函数会生成 &lt;code&gt;not_implemented&lt;/code&gt; 错误异常。</target>
        </trans-unit>
        <trans-unit id="6058a385a21e4246b670869f65aa6fd981a5a8b7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations and by Mnesia during transactions.</source>
          <target state="translated">此功能在普通代码中的使用受到限制。 &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 模块使用它来执行 &lt;code&gt;dets:select()&lt;/code&gt; 操作，交易期间Mnesia 可以使用它。</target>
        </trans-unit>
        <trans-unit id="523fd33cf3afa46e759133c868d60920d18b1dc7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations.</source>
          <target state="translated">此功能在普通代码中的使用受到限制。 &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 模块使用它来执行 &lt;code&gt;dets:select()&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="d58459e2ceed77eb8305bceed246e818de9ca01c" translate="yes" xml:space="preserve">
          <source>This function implements case normalization, percent-encoding normalization, path segment normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP.</source>
          <target state="translated">该函数实现了HTTP(S)的大小写归一化、百分比编码归一化、路径段归一化和基于方案的归一化,基本支持FTP、SSH、SFTP和TFTP。</target>
        </trans-unit>
        <trans-unit id="c8514d81ff22e1ff67620750cdc3dfb27e9e6f77" translate="yes" xml:space="preserve">
          <source>This function initiates the DBMS locally.</source>
          <target state="translated">该函数在本地启动DBMS。</target>
        </trans-unit>
        <trans-unit id="fcbc273861fed1e51bf947867b1a084c27622209" translate="yes" xml:space="preserve">
          <source>This function investigates if support is available for either Quickcheck, PropEr, or Triq. The options &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; and &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; are set in the &lt;code&gt;Config&lt;/code&gt; returned.</source>
          <target state="translated">此功能将调查是否支持Quickcheck，PropEr或Triq。在返回的 &lt;code&gt;Config&lt;/code&gt; 中设置了 &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; 和 &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6a7d3a4b7f3328d175ce6a9a9eb8e20886f3bda3" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能是 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="423ca16d197ccc978bd5081d6b3eb1c403bc0744" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a516abdfc30d7c9e3685abf6e57bb1e1d0b658e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52d494db0c1567d04ee40812bdffbefd6c016473" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab94cedb464e4260389af7be6dfaf6ffb7bd2291" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="205cdd304fd7174c14274c85d2328b2a17ae0a9e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef02bd0b5153d37d1fa93514bd445ad29bc64930" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba5aba1911d9f1f71e6680b8d5f950e286eccad6" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0297c83560fb40b3e25160700b963d4d28d8cb3d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9483920738b267719838628a8df6eae176da3415" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29b69004da0d2e1742321c5e08d6472bd345f1bd" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1fca9e1ff35bcfc01c17bd46889f3070478dc5b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="206343ba93558e03d83b7d9b6041c45a9f4e4762" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdc288f4c8566ab96ad5a3c012d039a6f14b114d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be41039c1c345076e4346d099bd59b24ee69b28b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;[String1, String2]&lt;/code&gt; as &lt;code&gt;Data&lt;/code&gt; argument, and call &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; to flatten the output.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;[String1, String2]&lt;/code&gt; 作为 &lt;code&gt;Data&lt;/code&gt; 参数，并调用 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; 来展平输出。</target>
        </trans-unit>
        <trans-unit id="0fe0ff73852f97430972aade26b365aeb9d4dcca" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;not&lt;/strong&gt; to have any side effects, as it can be called multiple times by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">此功能&lt;strong&gt;不会&lt;/strong&gt;有任何副作用，因为 &lt;code&gt;Common Test&lt;/code&gt; 可以多次调用它。</target>
        </trans-unit>
        <trans-unit id="d1601bc7321a92135715173d0e057687db27b297" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;only&lt;/strong&gt; intended to be used from functions called by the Erl Scheme interface to deliver parts of the content to the user.</source>
          <target state="translated">此功能&lt;strong&gt;仅&lt;/strong&gt;旨在从Erl Scheme接口调用的功能中使用，以将部分内容交付给用户。</target>
        </trans-unit>
        <trans-unit id="aef47781d467db25a7963a68f242afbbc794ce0b" translate="yes" xml:space="preserve">
          <source>This function is a shortcut allowing to start a trace with one command. Each tuple in &lt;code&gt;Patterns&lt;/code&gt; is converted to a list, which in turn is passed to &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt;.</source>
          <target state="translated">此功能是一种快捷方式，允许使用一个命令启动跟踪。 &lt;code&gt;Patterns&lt;/code&gt; 中的每个元组都转换为一个列表，该列表又传递给 &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43d5979e9394159963538ec618354c0f2550802" translate="yes" xml:space="preserve">
          <source>This function is a utility to test a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; used in calls to &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;. The function both tests &lt;code&gt;MatchSpec&lt;/code&gt; for &quot;syntactic&quot; correctness and runs the match specification against object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">此函数是用于测试对 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; 的调用中使用的 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 的实用程序。该函数既测试 &lt;code&gt;MatchSpec&lt;/code&gt; 的&amp;ldquo;语法&amp;rdquo;正确性，又对对象 &lt;code&gt;Tuple&lt;/code&gt; 运行匹配规范。</target>
        </trans-unit>
        <trans-unit id="d988191fa0dabe515db4af812656eff83c34cb63" translate="yes" xml:space="preserve">
          <source>This function is always called before any other callback function. Use it to initiate any common state. It is to return a state for this CTH.</source>
          <target state="translated">这个函数总是在任何其他回调函数之前被调用。用它来启动任何普通状态。它是为了返回这个 CTH 的状态。</target>
        </trans-unit>
        <trans-unit id="b516bc2e9034c1590527ec443de2c6737bcd4f59" translate="yes" xml:space="preserve">
          <source>This function is asynchronous, and does not return any information. If an error occurs, &lt;code&gt;user_err/2&lt;/code&gt; of the error report module is called and the notification is discarded.</source>
          <target state="translated">该函数是异步的，并且不返回任何信息。如果发生错误，则会调用错误报告模块的 &lt;code&gt;user_err/2&lt;/code&gt; 并丢弃该通知。</target>
        </trans-unit>
        <trans-unit id="85c98f3d29d4a07045be121e9e487541dab759e4" translate="yes" xml:space="preserve">
          <source>This function is automatically run by program &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">该功能由程序 &lt;code&gt;ct_run&lt;/code&gt; 自动运行。</target>
        </trans-unit>
        <trans-unit id="3279d0d6b02338f13c8bc53782a187d1879ee456" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="9188edb1cc0ebdde86ffdb4193d6c9cead6cb834" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="5632d3f19a46e6a63364561ccdcd84c5cbd07239" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="ed2c8cbf6eea27fe25c9e2e37745c13758f418bf" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="eeb41891de5f47fa39556ecfa785a92f82d5ca45" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains extra checks to ensure that all the correct dependencies are started correctly.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用。它通常包含额外的检查，以确保正确启动所有正确的依赖项。</target>
        </trans-unit>
        <trans-unit id="ab712217cf24a26d75845255e5f1d384ed7df651" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="ac4e91297af25f1c85d719157b005b8f81db41e7" translate="yes" xml:space="preserve">
          <source>This function is called after each test case, and can be used to clean up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and the test case. Any return value (besides &lt;code&gt;{fail,Reason}&lt;/code&gt; and &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt;) is ignored. By returning &lt;code&gt;{fail,Reason}&lt;/code&gt;, &lt;code&gt;TestCase&lt;/code&gt; is marked as faulty (even though it was successful in the sense that it returned a value instead of terminating).</source>
          <target state="translated">在每个测试用例之后都会调用此函数，并且可以在 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 和测试用例之后使用此函数进行清理。任何返回值（除了 &lt;code&gt;{fail,Reason}&lt;/code&gt; 和 &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt; 之外）都将被忽略。通过返回 &lt;code&gt;{fail,Reason}&lt;/code&gt; ， &lt;code&gt;TestCase&lt;/code&gt; 被标记为错误的（即使从返回值而不是终止的意义上来说它是成功的）。</target>
        </trans-unit>
        <trans-unit id="648d9b19e4f1798cccb4aa970ca13730d675986d" translate="yes" xml:space="preserve">
          <source>This function is called after the execution of a test case group is finished. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;. A status value for a nested subgroup can be returned with &lt;code&gt;{return_group_result,Status}&lt;/code&gt;. The status can be retrieved in &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; for the group on the level above. The status is also used by &lt;code&gt;Common Test&lt;/code&gt; for deciding if execution of a group is to proceed if property &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;repeat_until_*&lt;/code&gt; is set.</source>
          <target state="translated">测试用例组的执行完成后，将调用此函数。它旨在用于 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 之后的清理。嵌套子组的状态值可以使用 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 返回。可以在上 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 检索该状态。如果设置了属性 &lt;code&gt;sequence&lt;/code&gt; 或 &lt;code&gt;repeat_until_*&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 也使用该状态来确定是否要继续执行组。</target>
        </trans-unit>
        <trans-unit id="897cf1fddb4813f2f697f362b138508da5c7dd0a" translate="yes" xml:space="preserve">
          <source>This function is called as the last test case in the suite. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能称为套件中的最后一个测试用例。它旨在用于 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 之后的清理。</target>
        </trans-unit>
        <trans-unit id="a0372e5f1383e52f209cab7781bd11e0c4ba8e71" translate="yes" xml:space="preserve">
          <source>This function is called at the end of a CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt; 的末尾调用此函数。</target>
        </trans-unit>
        <trans-unit id="f0807a57b644a344571e1467f9b13cb9f18d17f0" translate="yes" xml:space="preserve">
          <source>This function is called at the end of stage 1 of the discovery process. It should return either the atom &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">在发现过程的第1阶段结束时调用此功能。它应该返回原子 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt; 。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb32881cf0a426df77fb1522665bfe4e0e2538b1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之前调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="e874f35f84af17d413fa61bed6f2c2a545583190" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="5d541acf0f757f563f08bac98ff0a9411ac868f8" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="6d4fd2c714fc08ec0ac6579748777b65c3366a58" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="c4fada08cbaf8b15ce7f51c95c9fe3b326d58378" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains initialization/logging that must be done before &lt;code&gt;init_per_suite&lt;/code&gt; is called. If &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, &lt;code&gt;init_per_suite&lt;/code&gt; and all test cases of the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; printed in the overview log of the suite.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它通常包含初始化/记录，必须在 &lt;code&gt;init_per_suite&lt;/code&gt; 之前完成。如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 或 &lt;code&gt;{fail,Reason}&lt;/code&gt; ， &lt;code&gt;init_per_suite&lt;/code&gt; 跳过init_per_suite和套件的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="14766708da0b30b7e24b398d506799e96916c97e" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="3ec02031e2fa8bc763f23eebb36182a4725659b4" translate="yes" xml:space="preserve">
          <source>This function is called before each test case. Argument &lt;code&gt;TestCase&lt;/code&gt; is the test case name, and &lt;code&gt;Config&lt;/code&gt; (list of key-value tuples) is the configuration data that can be modified. The &lt;code&gt;NewConfig&lt;/code&gt; list returned from this function is given as &lt;code&gt;Config&lt;/code&gt; to the test case. If &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, the test case is marked as failed without being executed.</source>
          <target state="translated">在每个测试用例之前调用此函数。参数 &lt;code&gt;TestCase&lt;/code&gt; 是测试用例的名称，而 &lt;code&gt;Config&lt;/code&gt; （键值元组的列表）是可以修改的配置数据。从此函数返回的 &lt;code&gt;NewConfig&lt;/code&gt; 列表作为 &lt;code&gt;Config&lt;/code&gt; 给出给测试用例。如果返回 &lt;code&gt;{fail,Reason}&lt;/code&gt; ，则测试用例被标记为失败而未执行。</target>
        </trans-unit>
        <trans-unit id="7cef0bc6ae48b3bc1a5099f8d9c601b37d907e07" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_event&lt;/code&gt; process in the following situations:</source>
          <target state="translated">在以下情况下， &lt;code&gt;gen_event&lt;/code&gt; 进程将调用此函数：</target>
        </trans-unit>
        <trans-unit id="4e47279564d310806f28fccb0940fabd880414dd" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process in the following situations:</source>
          <target state="translated">在以下情况下， &lt;code&gt;gen_server&lt;/code&gt; 进程将调用此函数：</target>
        </trans-unit>
        <trans-unit id="a51ead4642d619f15354dcc0634fe8062618949d" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when a time-out occurs or when it receives any other message than a synchronous or asynchronous request (or a system message).</source>
          <target state="translated">当发生超时或当它接收到除同步或异步请求（或系统消息）以外的任何其他消息时，此函数由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。</target>
        </trans-unit>
        <trans-unit id="81f55aa9a3503931bbd4c62f78241c8bfccce378" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_server&lt;/code&gt; process terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 进程即将终止时，将调用此函数。与 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 相反，并进行所有必要的清理。返回时， &lt;code&gt;gen_server&lt;/code&gt; 进程以 &lt;code&gt;Reason&lt;/code&gt; 终止。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="854175a561611b0f58880036cbf8c4836509caea" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specifed in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see section &lt;code&gt;Release Handling Instructions&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">当要在发行版升级/降级期间更新其内部状态时，即在指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 中，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时，此函数由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Release Handling Instructions&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="6d4c34ae1c200b76e11bc231bee8bd2807964c89" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process whenever a previous callback returns &lt;code&gt;{continue, Continue}&lt;/code&gt;. &lt;code&gt;handle_continue/2&lt;/code&gt; is invoked immediately after the previous callback, which makes it useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">每当先前的回调返回 &lt;code&gt;{continue, Continue}&lt;/code&gt; 时，此函数就会由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。 &lt;code&gt;handle_continue/2&lt;/code&gt; 在上一个回调之后立即被调用，这对于在初始化后执行工作或在回调中将工作拆分为多个步骤，沿过程更新过程状态非常有用。</target>
        </trans-unit>
        <trans-unit id="7c755e5f75a4b9ab817fb2fc0f0f130048764892" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; process when any of the following apply:</source>
          <target state="translated">当以下任何情况适用时，此函数由 &lt;code&gt;gen_statem&lt;/code&gt; 进程调用：</target>
        </trans-unit>
        <trans-unit id="012052cb437447cd791b721593de5a645b47fd05" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_statem&lt;/code&gt; terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 即将终止时会调用此函数。与 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 相反，并进行所有必要的清理。返回时， &lt;code&gt;gen_statem&lt;/code&gt; 终止于 &lt;code&gt;Reason&lt;/code&gt; 。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="7ca2b78a5bbaa99a4fbd81da5ab6158558318d3b" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">这个功能是通过一个名为 &lt;code&gt;gen_statem&lt;/code&gt; 当它是一个发布升级/降级，即在更新其内部状态，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; ，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; ，是在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1029bd58312f364737a518c22f5aea571963829" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it needs to find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; of the callback module. The value is cached by &lt;code&gt;gen_statem&lt;/code&gt; for efficiency reasons, so this function is only called once after server start and after code change, but before the first &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in the current code version is called. More occasions may be added in future versions of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">当需要找出回调模块的 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 时，此函数由 &lt;code&gt;gen_statem&lt;/code&gt; 调用。由于效率原因，该值由 &lt;code&gt;gen_statem&lt;/code&gt; 缓存，因此该函数仅在服务器启动之后和代码更改之后被调用一次，但是在当前代码版本中的第一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 被调用之前。 &lt;code&gt;gen_statem&lt;/code&gt; 的未来版本中可能会添加更多场合。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46850b150e8f033a9f9fa7fa23905fcd27c1aa8d" translate="yes" xml:space="preserve">
          <source>This function is called by a channel process when it is about to terminate. Before this function is called, &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">即将终止时，此功能由通道进程调用。如果尚未早先调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; ，则在此函数被调用之前。此功能会进行任何必要的清理。返回时，通道过程终止，原因为 &lt;code&gt;Reason&lt;/code&gt; 。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="56c006741953e55f77a4441e9b362d11c170439b" translate="yes" xml:space="preserve">
          <source>This function is called by a client-side channel when it is to update its internal state during a release upgrade or downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is given in the &lt;code&gt;appup&lt;/code&gt; file. For more information, refer to Section 9.11.6 Release Handling Instructions in the &lt;code&gt;System Documentation&lt;/code&gt;.</source>
          <target state="translated">当要在版本升级或降级期间更新其内部状态（即，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; )（其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时，客户端通道调用此函数。}在 &lt;code&gt;appup&lt;/code&gt; 文件中给出。有关更多信息，请参阅 &lt;code&gt;System Documentation&lt;/code&gt; 中的9.11.6部分发布处理说明。</target>
        </trans-unit>
        <trans-unit id="98e32bc0ee74da52ca9a13438eac65dfb07d4d9a" translate="yes" xml:space="preserve">
          <source>This function is called by a process when it generates a system event. &lt;code&gt;FormFunc&lt;/code&gt; is a formatting function, called as &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; to print the events, which is necessary if tracing is activated. &lt;code&gt;Extra&lt;/code&gt; is any extra information that the process needs in the format function, for example, the process name.</source>
          <target state="translated">进程在生成系统事件时会调用此函数。 &lt;code&gt;FormFunc&lt;/code&gt; 是一种格式化函数，称为 &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; 用于打印事件，如果激活了跟踪，则这是必需的。 &lt;code&gt;Extra&lt;/code&gt; 是流程在格式功能中需要的任何其他信息，例如，流程名称。</target>
        </trans-unit>
        <trans-unit id="ed0e0eb61ef16ef99456d0c2364049ed3a1ebf47" translate="yes" xml:space="preserve">
          <source>This function is called by an application after a code replacement, if the configuration parameters have changed.</source>
          <target state="translated">如果配置参数发生变化,该函数会在代码替换后被应用程序调用。</target>
        </trans-unit>
        <trans-unit id="6621bfc9a122170668fcc8fc8225320a135fa869" translate="yes" xml:space="preserve">
          <source>This function is called by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior when the channel is terminated, see &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt;. Thus, channels implemented with the behavior are not to call this function explicitly.</source>
          <target state="translated">通道终止时，此函数由 &lt;code&gt;ssh_client_channel&lt;/code&gt; 行为调用，请参见 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt; 。因此，用该行为实现的通道不会显式调用此函数。</target>
        </trans-unit>
        <trans-unit id="dc9dece5047c3cb54dec0afd24b5a01788985144" translate="yes" xml:space="preserve">
          <source>This function is called by the runtime system if a call is made to &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; and &lt;code&gt;Module:Function/N&lt;/code&gt; is undefined. Notice that this function is evaluated inside the process making the original call.</source>
          <target state="translated">如果调用 &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; 并且未定义 &lt;code&gt;Module:Function/N&lt;/code&gt; ，则运行时系统将调用此函数。请注意，此函数是在进行原始调用的过程中评估的。</target>
        </trans-unit>
        <trans-unit id="932dde8834dd201f9618df3e2b729505b50863cc" translate="yes" xml:space="preserve">
          <source>This function is called by the supervisor bridge when it is about to terminate. It is to be the opposite of &lt;code&gt;Module:init/1&lt;/code&gt; and stop the subsystem and do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">即将终止时，主管桥会调用此功能。与 &lt;code&gt;Module:init/1&lt;/code&gt; 相反，并停止子系统并进行任何必要的清理。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="ea3c4634990a20391de600270693f41ff61a2a1d" translate="yes" xml:space="preserve">
          <source>This function is called for an installed event handler that is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;.appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">已安装的事件处理程序将调用此函数，该事件处理程序将在发行版升级/降级期间（即，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; ，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时更新其内部状态）。在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea3d7b3ef2cbf8699a32c34a5ebc6edac5d50d7" translate="yes" xml:space="preserve">
          <source>This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message).</source>
          <target state="translated">当事件管理器收到除事件或同步请求(或系统消息)以外的任何其他消息时,该函数被每个已安装的事件处理程序调用。</target>
        </trans-unit>
        <trans-unit id="ce473b5b5bef5c09e6ef1d61b1ed1c647a383af4" translate="yes" xml:space="preserve">
          <source>This function is called for each target in the &lt;code&gt;Targets&lt;/code&gt; argument of the &lt;code&gt;delivery_targets/3&lt;/code&gt; function, see above.</source>
          <target state="translated">请参见 &lt;code&gt;delivery_targets/3&lt;/code&gt; 函数的 &lt;code&gt;Targets&lt;/code&gt; 参数中的每个目标调用此函数。</target>
        </trans-unit>
        <trans-unit id="1d6462e692fd6e4e41ce5594f4b497bff94fb6d6" translate="yes" xml:space="preserve">
          <source>This function is called for every event sent by the parser. The error handling is done through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the application encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">这个函数对解析器发送的每个事件都会被调用。错误处理是通过异常来完成的。如果应用程序遇到致命错误,使用 throw/1 发送以下元组{Tag=atom(),Reason=string()}。Tag是一个原子,标识发送异常的功能实体,Reason是描述问题的字符串。</target>
        </trans-unit>
        <trans-unit id="93bdecc9d17882d1b467ebb3869ace1d974136a0" translate="yes" xml:space="preserve">
          <source>This function is called from the supervisor at system start-up.</source>
          <target state="translated">该功能在系统启动时由上位机调用。</target>
        </trans-unit>
        <trans-unit id="a217044c5be614a5f094b6a72163b7e4bdd7856f" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before &lt;code&gt;init_per_suite is run&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">仅当 &lt;code&gt;init_per_suite is run&lt;/code&gt; 之前添加了CTH时，才调用此函数。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9151faa7459c76d911ec31cbf5c69110f9a96417" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before or in &lt;code&gt;init_per_suite&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">仅当CTH在 &lt;code&gt;init_per_suite&lt;/code&gt; 之前或之中添加时，才调用此函数。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="5d413292a54f27c9406de8cff392ae42d2f42729" translate="yes" xml:space="preserve">
          <source>This function is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function is present and returns &lt;code&gt;noError&lt;/code&gt;.</source>
          <target state="translated">调用此函数以在设置请求处理的第二阶段执行设置。仅当存在相应的 &lt;code&gt;is_set_ok&lt;/code&gt; 函数并返回 &lt;code&gt;noError&lt;/code&gt; 时才调用它。</target>
        </trans-unit>
        <trans-unit id="19d4b60d6e3de5df91e369f01d6f092302794154" translate="yes" xml:space="preserve">
          <source>This function is called when a log event has passed through all primary filters, and all handler filters attached to the handler in question. The function call is executed on the client process, and it is up to the handler implementation if other processes are involved or not.</source>
          <target state="translated">当一个日志事件通过了所有的主过滤器,以及连接到相关处理程序的所有处理程序过滤器时,就会调用这个函数。该函数的调用是在客户端进程上执行的,是否涉及到其他进程由处理程序实现决定。</target>
        </trans-unit>
        <trans-unit id="c295250b137bf52da997b24c29441addd734d55e" translate="yes" xml:space="preserve">
          <source>This function is called when a message is received from an unknown agent.</source>
          <target state="translated">当收到来自未知代理的消息时,该函数被调用。</target>
        </trans-unit>
        <trans-unit id="5d70c9d97d9b9a958c936b8de051f3ed8d7ea9af" translate="yes" xml:space="preserve">
          <source>This function is called when a segment reply has been received if the &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; config option has been set to true.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; config选项设置为true，则在收到分段答复时将调用此函数。</target>
        </trans-unit>
        <trans-unit id="0a9e596fa34499a1e902a649a40ec5eaea84dc1d" translate="yes" xml:space="preserve">
          <source>This function is called when an application is about to be stopped, before shutting down the processes of the application.</source>
          <target state="translated">该函数在应用程序即将停止时,在关闭应用程序的进程之前被调用。</target>
        </trans-unit>
        <trans-unit id="e52a273e8b54ca8a87814403662bc4639ec75915" translate="yes" xml:space="preserve">
          <source>This function is called when the handshake has completed and the distribution channel is up. The distribution controller can begin dispatching traffic over the channel. This function is optional.</source>
          <target state="translated">当握手完成,分发通道启动时,该函数被调用。分销控制器可以开始通过通道调度流量。这个功能是可选的。</target>
        </trans-unit>
        <trans-unit id="78b766c6378e4e694c5a1f56cd06d012c7c1210f" translate="yes" xml:space="preserve">
          <source>This function is called when the manager needs to communicate an &quot;asynchronous&quot; error to the user: e.g. failure to send an asynchronous message (i.e. encoding error), a received message was discarded due to security error, the manager failed to generate a response message to a received inform-request, or when receiving an unexpected PDU from an agent (could be an expired async request).</source>
          <target state="translated">当管理器需要向用户传达一个 &quot;异步 &quot;错误时,就会调用这个函数:例如,未能发送异步消息(即编码错误),接收到的消息因安全错误而被丢弃,管理器未能对接收到的信息请求生成响应消息,或者当收到来自代理的意外PDU时(可能是过期的异步请求)。</target>
        </trans-unit>
        <trans-unit id="c1bd23363bb35671fd7a263f768278217cdab156" translate="yes" xml:space="preserve">
          <source>This function is called whenever Mnesia needs to determine which fragments that need to be searched for a &lt;code&gt;MatchSpec&lt;/code&gt;. It is typically called by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;.</source>
          <target state="translated">每当Mnesia需要确定需要为 &lt;code&gt;MatchSpec&lt;/code&gt; 搜索哪些片段时，都会调用此函数。通常由 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;match_object&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="01c69191566d604ec0e4348c19597985d6671a38" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) fails. It is called after the post function is called for the failed test case, that is:</source>
          <target state="translated">每当一个测试用例(或配置函数)失败时,这个函数就会被调用。它是在调用失败的测试用例的post函数之后被调用的,也就是说。</target>
        </trans-unit>
        <trans-unit id="d3efafaf0939c64a4ad9d5c14688207c28754d4e" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) is skipped. It is called after the post function is called for the skipped test case, that is:</source>
          <target state="translated">每当一个测试用例(或配置函数)被跳过时,这个函数就会被调用。它是在调用了跳过的测试用例的post函数之后被调用的,也就是说。</target>
        </trans-unit>
        <trans-unit id="c606577dcdb814f628921da1d374fa61eef9bcbd" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application has stopped. It is intended to be the opposite of &lt;code&gt;Module:start/2&lt;/code&gt; and is to do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">每当应用程序停止时，都会调用此函数。它打算与 &lt;code&gt;Module:start/2&lt;/code&gt; 相反，并进行任何必要的清理。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="5ee521594d1ddf2a7d2b5598240a35e803ba7648" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application is started using &lt;code&gt;start/1,2&lt;/code&gt;, and is to start the processes of the application. If the application is structured according to the OTP design principles as a supervision tree, this means starting the top supervisor of the tree.</source>
          <target state="translated">每当使用 &lt;code&gt;start/1,2&lt;/code&gt; 启动应用程序时，就会调用此函数，该函数将启动应用程序的进程。如果根据OTP设计原则将应用程序构建为监督树，则意味着启动该树的最高主管。</target>
        </trans-unit>
        <trans-unit id="5ce2ffe3ef06f25d257eea92fe03c94bd042a9ba" translate="yes" xml:space="preserve">
          <source>This function is called whenever the parser runs out of input data. If the function can't get hold of more input an empty list or binary (depends on start input in stream/2) is returned. Other types of errors is handled through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the continuation function encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">当解析器的输入数据用完时,就会调用这个函数。如果函数无法获得更多的输入,则返回一个空列表或二进制(取决于 stream/2 中的起始输入)。其他类型的错误是通过异常处理的。如果延续函数遇到致命错误,使用 throw/1 发送以下元组{Tag=atom(),Reason=string()}。Tag是一个原子,标识发送异常的功能实体,Reason是描述问题的字符串。</target>
        </trans-unit>
        <trans-unit id="112c32a0ac8f37302565069e1af7c3d11d8ddc14" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous, that is, when this function returns, the name is either registered on all nodes or none.</source>
          <target state="translated">这个函数是完全同步的,也就是说,当这个函数返回时,名字要么在所有节点上注册,要么没有。</target>
        </trans-unit>
        <trans-unit id="d629551f45aed938b0210e2c4a23a00e3421b297" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous.</source>
          <target state="translated">这个功能是完全同步的。</target>
        </trans-unit>
        <trans-unit id="f35d4e7d98bb703e34921dfd922b82cf2abffe2a" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release.</source>
          <target state="translated">该功能已被废弃,并将在未来的版本中被删除。</target>
        </trans-unit>
        <trans-unit id="7cf9e7b62dba47009024375097e3299049fe0a22" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57c472f59dd3d2f6ad17dc07c92e4c60fcf49729" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db4675d63f920313a1ea26e962187e1aa011dcdd" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ce49a62899e9f8f936f7b7c515c2cbbf4ad75dc" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a65b47bbbfbb54ad15ea7e9136f81e2f3a04ac4" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b52957272e25d9092e5e990877e3939651cbfce" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; on the uncompressed data instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。在未压缩的数据上使用 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f67f68973bfc4a8137b6bf187f50333109258a7" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb4d9b393f14dc50ae3c01015c208fd2e887250e" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cf4312fba04cc8c15fd9776029ba4bd244d245c" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">不建议使用此功能，因为 &lt;code&gt;error_logger&lt;/code&gt; 不再是登录Erlang / OTP的首选接口。在Erlang / OTP 21.0中添加了新的 &lt;code&gt;logging API&lt;/code&gt; ，但仍可以使用旧的 &lt;code&gt;error_logger&lt;/code&gt; 处理程序。新的Logger处理程序不需要使用此功能，因为格式化回调（ &lt;code&gt;report_cb&lt;/code&gt; ）作为元数据包括在日志事件中。</target>
        </trans-unit>
        <trans-unit id="797c275c3663aa3f1286ac6e8f576a1c8979a3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">不赞成使用此功能，因为 &lt;code&gt;error_logger&lt;/code&gt; 不再是登录Erlang / OTP的首选接口。在Erlang / OTP 21.0中添加了新的 &lt;code&gt;logging API&lt;/code&gt; ，但仍可以使用旧的 &lt;code&gt;error_logger&lt;/code&gt; 处理程序。新的Logger处理程序不需要使用此功能，因为格式化回调（ &lt;code&gt;report_cb&lt;/code&gt; ）作为元数据包含在log事件中。</target>
        </trans-unit>
        <trans-unit id="93275cd4e56a52fc18f140562459cc7469aef3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch &lt;strong&gt;to&lt;/strong&gt; daylight saving time, this function still returns a result.</source>
          <target state="translated">不推荐使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; ，因为它可以提供更正确和完整的结果。特别是对于不存在的时间段，由于在切换&lt;strong&gt;到&lt;/strong&gt;夏时制时会被跳过，因此此功能仍会返回结果。</target>
        </trans-unit>
        <trans-unit id="c812739c6fd83de52547a755970ceca008f0b790" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; instead for finding source files.</source>
          <target state="translated">不推荐使用此功能。使用 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 代替查找源文件。</target>
        </trans-unit>
        <trans-unit id="2f4e6b180074e2f9f3f128b4c971b69623e3ec1e" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but acts on the given node. A tracer is started on the node (&lt;code&gt;Nodename&lt;/code&gt;) and the node is added to the list of traced nodes.</source>
          <target state="translated">此函数等效于 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; ，但作用于给定节点。在节点（ &lt;code&gt;Nodename&lt;/code&gt; ）上启动一个跟踪器，并将该节点添加到被跟踪节点的列表中。</target>
        </trans-unit>
        <trans-unit id="c92d04be5c71ca9752e01679ace3dd192a2701dc" translate="yes" xml:space="preserve">
          <source>This function is evaluated if a call is made to &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; when the module defining the fun is not loaded. The function is evaluated inside the process making the original call.</source>
          <target state="translated">如果未加载定义 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 的模块时对Fun（Arg1，..，ArgN）的调用，则会评估此函数。该函数在进行原始调用的过程中进行评估。</target>
        </trans-unit>
        <trans-unit id="397de6af2f56ed299f26a66779fa39dc2d87c829" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging only.</source>
          <target state="translated">此功能仅用于调试。</target>
        </trans-unit>
        <trans-unit id="5e70db1a93c8f76d23e7c3d3fb2baea3f7a6af2b" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging purposes only.</source>
          <target state="translated">此功能仅用于调试目的。</target>
        </trans-unit>
        <trans-unit id="6f60000c240fa5a82e86efdce70cc54b8977641c" translate="yes" xml:space="preserve">
          <source>This function is intended for send operations to an unreliable remote node without ever blocking the sending (Erlang) process. If the connection to the remote node (usually not a real Erlang node, but a node written in C or Java) is overloaded, this function &lt;strong&gt;does not send the message&lt;/strong&gt; and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此功能旨在将操作发送到不可靠的远程节点，而不会阻止发送（Erlang）进程。如果到远程节点（通常不是真正的Erlang节点，而是用C或Java编写的节点）的连接过载，则此函数&lt;strong&gt;不会发送消息&lt;/strong&gt;并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81171218c09769a1d5b4af85d5937f41eeaa5f09" translate="yes" xml:space="preserve">
          <source>This function is intended to be called by a process belonging to an application, when the application is started, to determine the start type, which is &lt;code&gt;StartType&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">当启动应用程序时，应由属于该应用程序的进程调用此函数以确定启动类型，即 &lt;code&gt;StartType&lt;/code&gt; 或 &lt;code&gt;local&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e10f123bbee56ea9b87adef7c85f24ef9a0bea62" translate="yes" xml:space="preserve">
          <source>This function is intended to be called in the test cases in the test suite.</source>
          <target state="translated">这个函数是为了在测试套件的测试用例中调用。</target>
        </trans-unit>
        <trans-unit id="1b921fbf118e94cca94277c181ed0c5045bbfaba" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked at strategic places in user applications in order to enable simplified tracing. The functions are extremely light weight as they do nothing besides returning an atom. The functions are designed for being traced. The global tracing mechanism in &lt;code&gt;et_collector&lt;/code&gt; defaults to set its trace pattern to these functions.</source>
          <target state="translated">该功能旨在在用户应用程序中的关键位置调用，以实现简化的跟踪。这些函数非常轻巧，因为它们除了返回原子之外什么也不做。这些功能旨在进行跟踪。默认情况下， &lt;code&gt;et_collector&lt;/code&gt; 中的全局跟踪机制会将其跟踪模式设置为这些函数。</target>
        </trans-unit>
        <trans-unit id="36a555885bb62cc8fb0d04fa074ce553eafe397b" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">这个函数的作用是当一些传输模块收到收到的消息时调用。实际使用哪种传输方式,由用户自行选择。</target>
        </trans-unit>
        <trans-unit id="6d3f5fd62fd46c21ebd6dea29aa844aba60cb08c" translate="yes" xml:space="preserve">
          <source>This function is invoked as this module is added as a child of the &lt;code&gt;erl_distribution&lt;/code&gt; supervisor.</source>
          <target state="translated">在将此模块作为 &lt;code&gt;erl_distribution&lt;/code&gt; 监管程序的子级添加时，将调用此函数。</target>
        </trans-unit>
        <trans-unit id="1d32e0beab2a86c2649b5c5e66d99028d158f64c" translate="yes" xml:space="preserve">
          <source>This function is invoked if the originating pending limit has been exceeded. This usually means that a request has taken abnormally long time to complete.</source>
          <target state="translated">如果超过了发起的挂起限制,就会调用这个函数。这通常意味着一个请求需要异常长的时间才能完成。</target>
        </trans-unit>
        <trans-unit id="7fe0a088ee8a115443a4b7c28bd5e240eaea2ffd" translate="yes" xml:space="preserve">
          <source>This function is mandatory.</source>
          <target state="translated">这个功能是必须的。</target>
        </trans-unit>
        <trans-unit id="23ddde2c73699705374784b1a6630cfc5af08e7d" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string directly from a test case to the test case log file.</source>
          <target state="translated">这个函数的作用是将测试用例中的字符串直接打印到测试用例日志文件中。</target>
        </trans-unit>
        <trans-unit id="1c8ca547da965f042e95bb1424e4289fdf1c4a1b" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case to the console.</source>
          <target state="translated">该函数用于打印测试用例的字符串到控制台。</target>
        </trans-unit>
        <trans-unit id="200109fd126bab7ec37db1035c7afff40cc8667c" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case, both to the test case log file and to the console.</source>
          <target state="translated">这个函数用于打印测试用例中的字符串,既可以打印到测试用例日志文件,也可以打印到控制台。</target>
        </trans-unit>
        <trans-unit id="2dbc6b277a2853a0b6bf11d0b8a4589a39100a82" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for debugging only.</source>
          <target state="translated">此功能仅用于调试。</target>
        </trans-unit>
        <trans-unit id="353984c9a0fb4f2aea1206112d183a058e95d4a0" translate="yes" xml:space="preserve">
          <source>This function is mostly for debugging purposes, Normally &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;next&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; are to be used instead.</source>
          <target state="translated">此功能主要用于调试目的，通常使用 &lt;code&gt;first&lt;/code&gt; / &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;last&lt;/code&gt; / &lt;code&gt;prev&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="932f20a018c847fbfb4197a37b0d2d604f5eb9f7" translate="yes" xml:space="preserve">
          <source>This function is normally not called by the user. The user only needs to call if the channel process needs to be started with help of &lt;code&gt;proc_lib&lt;/code&gt; instead of calling &lt;code&gt;start/4&lt;/code&gt; or &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">用户通常不调用此函数。仅当需要在 &lt;code&gt;proc_lib&lt;/code&gt; 的帮助下启动通道进程而不是调用 &lt;code&gt;start/4&lt;/code&gt; 或 &lt;code&gt;start_link/4&lt;/code&gt; 时，用户才需要调用。</target>
        </trans-unit>
        <trans-unit id="42f571587b780a1e6f46d35b2d96fbee773dc95d" translate="yes" xml:space="preserve">
          <source>This function is not equivalent to &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;. While &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; starts a process tracer which redirects all trace information to a process tracer on the local node (i.e. the trace control node), &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; starts a tracer of any type which is independent of the tracer on the trace control node.</source>
          <target state="translated">此函数不等于 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 启动将所有跟踪信息重定向到本地节点（即，跟踪控制节点）上的进程跟踪器的进程跟踪器时， &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 启动与跟踪控制节点上的跟踪器无关的任何类型的跟踪器。</target>
        </trans-unit>
        <trans-unit id="bc4cccc5c4f2f3772a98e697fd645208ffc7bcd9" translate="yes" xml:space="preserve">
          <source>This function is obsolete. Use the conversion functions for gregorian days and seconds instead.</source>
          <target state="translated">这个功能已经过时了。请使用公历日和秒的转换函数。</target>
        </trans-unit>
        <trans-unit id="ce7c408302373e6adf8e0f46e04cfc34dc2748e9" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to have a same kind of interface as the &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">此功能仅用于测试目的。它应该具有与 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 函数相同的接口（带有 &lt;code&gt;EncodingMod&lt;/code&gt; 和 &lt;code&gt;EncodingConfig&lt;/code&gt; 参数）。它构成了一个完整的megaco消息尝试对其进行编码的最终尝试。返回值将是组成的megaco消息和编码结果的元组。</target>
        </trans-unit>
        <trans-unit id="f9e0331af836baa2d84d1f916d61996854b6352b" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to test the &lt;code&gt;actual_reply()&lt;/code&gt; return value of the callback functions &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">此功能仅用于测试目的。它应该测试回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; 函数（添加了 &lt;code&gt;EncodingMod&lt;/code&gt; 和 &lt;code&gt;EncodingConfig&lt;/code&gt; 参数）的actual_reply &lt;code&gt;actual_reply()&lt;/code&gt; 返回值。它构成了一个完整的megaco消息尝试对其进行编码的最终尝试。返回值将是组成的megaco消息和编码结果的元组。</target>
        </trans-unit>
        <trans-unit id="df58ae53df4ed25f773afed230f30889dcd5ca99" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used.</source>
          <target state="translated">该功能只有在使用支持SMP的仿真器时才是线程安全的。</target>
        </trans-unit>
        <trans-unit id="aef102baa9fb64ea372514334c60d7b3b9f264e9" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</source>
          <target state="translated">这个函数只有在使用支持SMP的仿真器时才是线程安全的。它只能在非SMP仿真器中由NIF调用线程使用。</target>
        </trans-unit>
        <trans-unit id="90c95c65aaea895304dfbed57d7ceb302b881182" translate="yes" xml:space="preserve">
          <source>This function is only to be used in rare circumstances where a process communicates with Erlang nodes that can disappear without any trace, causing the TCP buffers and the drivers queue to be over-full before the node is shut down (because of tick time-outs) by &lt;code&gt;net_kernel&lt;/code&gt;. The normal reaction to take when this occurs is some kind of premature shutdown of the other node.</source>
          <target state="translated">此功能仅在少数情况下使用，即进程与Erlang节点通信时，该节点可能消失而无任何踪迹，从而导致TCP缓冲区和驱动程序队列在该节点关闭之前变得过满（由于滴答超时） ）由 &lt;code&gt;net_kernel&lt;/code&gt; 。发生这种情况时，通常的反应是另一节点过早关闭。</target>
        </trans-unit>
        <trans-unit id="b91ea27388e04da4e23c43f3cd2a1b24a1b3f051" translate="yes" xml:space="preserve">
          <source>This function is only to be used on short lists, as a copy is created of the list, which is not released until after the NIF returns.</source>
          <target state="translated">这个函数只用于短列表,因为会创建一个列表副本,直到NIF返回后才会释放。</target>
        </trans-unit>
        <trans-unit id="1c2b27f3795376fc611944f7d7c38e8f0670e208" translate="yes" xml:space="preserve">
          <source>This function is optional.</source>
          <target state="translated">这个功能是可选的。</target>
        </trans-unit>
        <trans-unit id="c8eb9533643d424e90f80bd181b73132613e7c18" translate="yes" xml:space="preserve">
          <source>This function is optional. The return value is discarded.</source>
          <target state="translated">这个函数是可选的。返回值被丢弃。</target>
        </trans-unit>
        <trans-unit id="e2b3a473185dfec37318ffd01ffc565de71b54e4" translate="yes" xml:space="preserve">
          <source>This function is optional. Used when connection is up.</source>
          <target state="translated">此功能是可选的。在连接状态下使用。</target>
        </trans-unit>
        <trans-unit id="8c84159cb077e05ce5ab18f138db97ded3cd0f6a" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in load regulation scenarios.</source>
          <target state="translated">这个功能主要是在负荷调节的情况下有用。</target>
        </trans-unit>
        <trans-unit id="6d1c283b0d188ab1dc083d2737684fc3b5d9bcb5" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in testing/debugging scenarios.</source>
          <target state="translated">该功能主要用于测试/调试场景。</target>
        </trans-unit>
        <trans-unit id="11584ee6be5c439d09214f1f99df3af124d2da3b" translate="yes" xml:space="preserve">
          <source>This function is probably mainly useful when called from outside of Erlang, for example from a driver written in C.</source>
          <target state="translated">这个函数可能主要是在从Erlang以外的地方调用时有用,比如从C语言编写的驱动中调用。</target>
        </trans-unit>
        <trans-unit id="353504af3c988d4810cedc709216e313aaafe762" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; into a number of repeated NIF calls without the need to create threads.</source>
          <target state="translated">提供此功能是为了更好地支持协作调度，提高系统响应速度，并更容易防止由于NIF独占调度程序线程而导致的VM异常行为。它可以用于将 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; 划分为多个重复的NIF调用，而无需创建线程。</target>
        </trans-unit>
        <trans-unit id="5db90f14f3c432301e447b05ad0cb6592973631a" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and to make it easier to prevent misbehaviors of the VM because of a port monopolizing a scheduler thread. It can be used when dividing lengthy work into some repeated driver callback calls, without the need to use threads.</source>
          <target state="translated">提供这个功能的目的是为了更好的支持协同调度,提高系统响应速度,并且更容易防止因为某个端口垄断调度线程而导致虚拟机的错误行为。当把冗长的工作分成一些重复的驱动回调调用时,可以使用这个功能,而不需要使用线程。</target>
        </trans-unit>
        <trans-unit id="3bd60d1367a2a2c9bf42897b1642d4f588cea06f" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">在应用程序代码中很少需要此功能。Mnesia使用它来提供分布式 &lt;code&gt;select/3&lt;/code&gt; 和 &lt;code&gt;select/1&lt;/code&gt; 序列。普通应用程序将使用Mnesia或避免将延续文件转换为外部格式。</target>
        </trans-unit>
        <trans-unit id="5802ba7a3becc5d64b340383668b0fe991f19bfe" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by application Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">在应用程序代码中很少需要此功能。应用程序Mnesia使用它来提供分布式 &lt;code&gt;select/3&lt;/code&gt; 和 &lt;code&gt;select/1&lt;/code&gt; 序列。普通应用程序将使用Mnesia或避免将延续文件转换为外部格式。</target>
        </trans-unit>
        <trans-unit id="650535937ca4ee466c191b80e09fe3d66b3c7b8e" translate="yes" xml:space="preserve">
          <source>This function is retained for backward compatibility. Function &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; is usually more convenient.</source>
          <target state="translated">保留此功能是为了向后兼容。函数 &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; 通常更方便。</target>
        </trans-unit>
        <trans-unit id="6fd26f567334e9666b6ef2abb401ce9925581958" translate="yes" xml:space="preserve">
          <source>This function is retained for compatibility with code generated by the interface compiler and with code following examples in the same application.</source>
          <target state="translated">为了与接口编译器生成的代码以及在同一应用程序中跟随示例的代码兼容,保留了这个函数。</target>
        </trans-unit>
        <trans-unit id="04dbb81151f11a2a8e21a08672e2edd99a02d468" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;init:stop()&lt;/code&gt;, that is, it causes the node to stop in a controlled fashion.</source>
          <target state="translated">此函数是 &lt;code&gt;init:stop()&lt;/code&gt; 的简写形式，即，它导致节点以受控方式停止。</target>
        </trans-unit>
        <trans-unit id="4e31e42d4190f9153fc006e0f381fb267c91b114" translate="yes" xml:space="preserve">
          <source>This function is synchronous, which means that it will return when the discovery process has been completed or failed.</source>
          <target state="translated">这个函数是同步的,也就是说,当发现过程完成或失败时,它将返回。</target>
        </trans-unit>
        <trans-unit id="83e3218f152791a8b7bcc054591cf10cd806a3e6" translate="yes" xml:space="preserve">
          <source>This function is the only way for a driver to send data to &lt;strong&gt;other&lt;/strong&gt; processes than the port owner process. Parameter &lt;code&gt;receiver&lt;/code&gt; specifies the process to receive the data.</source>
          <target state="translated">该功能是驱动程序将数据发送到端口所有者进程以外的&lt;strong&gt;其他&lt;/strong&gt;进程的唯一方法。参数 &lt;code&gt;receiver&lt;/code&gt; 指定接收数据的过程。</target>
        </trans-unit>
        <trans-unit id="5d488a4d40159f9a0721dbdd5dad71579d3aee31" translate="yes" xml:space="preserve">
          <source>This function is thread-safe.</source>
          <target state="translated">这个功能是线程安全的。</target>
        </trans-unit>
        <trans-unit id="b9706d58a2352e8890b72cebf3416ed3ffff9ffe" translate="yes" xml:space="preserve">
          <source>This function is to be repeatedly called, while it returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;.</source>
          <target state="translated">该函数将被重复调用，同时返回 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe9a923027f6092daec4890f5b0a9af15bfddae" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;code&gt;erl_interface&lt;/code&gt; to create the Mnesia table if it does not already exist.</source>
          <target state="translated">&lt;code&gt;erl_interface&lt;/code&gt; 使用此函数创建Mnesia表（如果尚不存在）。</target>
        </trans-unit>
        <trans-unit id="e0ea944547ae0efb5c6ac097415a9890edb2fa66" translate="yes" xml:space="preserve">
          <source>This function is used by a process module to take care of system messages. The process receives a &lt;code&gt;{system, From, Msg}&lt;/code&gt; message and passes &lt;code&gt;Msg&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; to this function.</source>
          <target state="translated">处理模块使用此功能来处理系统消息。进程接收 &lt;code&gt;{system, From, Msg}&lt;/code&gt; 消息，并将 &lt;code&gt;Msg&lt;/code&gt; 和 &lt;code&gt;From&lt;/code&gt; 传递给此函数。</target>
        </trans-unit>
        <trans-unit id="e2a112b495b39abcd5586ec3664e29d01231ac87" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to accept a connection from a client process.</source>
          <target state="translated">这个函数被服务器进程用来接受来自客户端进程的连接。</target>
        </trans-unit>
        <trans-unit id="898bb0d30e504dc801429a9370b05b766f512338" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling this function, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">服务器进程使用此功能向本地名称服务器EPMD注册，从而允许其他进程使用注册的名称发送消息。在调用此函数之前，进程应在打开的套接字上调用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;listen()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70ccee3033b802a87c1b5086a81572b1cdf9f072" translate="yes" xml:space="preserve">
          <source>This function is used by drivers to provide the emulator with events to check for. This enables the emulator to call the driver when something has occurred asynchronously.</source>
          <target state="translated">这个函数被驱动程序用来为仿真器提供事件检查。这使得仿真器能够在异步事件发生时调用驱动程序。</target>
        </trans-unit>
        <trans-unit id="563d0e5f94af6836101c3632fc208eb6264d3ee8" translate="yes" xml:space="preserve">
          <source>This function is used by functions &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; to present process information.</source>
          <target state="translated">功能 &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; 使用此功能来显示过程信息。</target>
        </trans-unit>
        <trans-unit id="73986afc84809f75a6e12a693ebaed3b04b098c2" translate="yes" xml:space="preserve">
          <source>This function is used by the &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; function to prepare a document before being laid out as text.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; 函数使用此功能在将其布置为文本之前准备文档。</target>
        </trans-unit>
        <trans-unit id="af91dcbbafd0b245aac20abd673102bff806bdf0" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active TPKT connection.</source>
          <target state="translated">该功能用于关闭活动的 TPKT 连接。</target>
        </trans-unit>
        <trans-unit id="341959533bbd5fb6c13fba9bb6518b33337f67e1" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active UDP socket.</source>
          <target state="translated">该函数用于关闭一个活动的UDP套接字。</target>
        </trans-unit>
        <trans-unit id="c203b5dc275784f420edfae2f16a2aed1ae6aa56" translate="yes" xml:space="preserve">
          <source>This function is used for starting new TPKT listening socket for TCP/IP. The option list contains the socket definitions.</source>
          <target state="translated">该函数用于启动新的TCP/IP的TPKT监听套接字。选项列表包含套接字的定义。</target>
        </trans-unit>
        <trans-unit id="77b263a5f923ead126acb1e02db37792ff404de1" translate="yes" xml:space="preserve">
          <source>This function is used for starting the TCP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">该函数用于启动TCP/IP传输服务。使用exit(TransportRef,Reason)来停止传输服务。</target>
        </trans-unit>
        <trans-unit id="03f7bc8e389fa4c3de41f19125ec838b559c7fc6" translate="yes" xml:space="preserve">
          <source>This function is used for starting the UDP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">该函数用于启动UDP/IP传输服务。使用exit(TransportRef,Reason)可以停止传输服务。</target>
        </trans-unit>
        <trans-unit id="8eb43517a5b84f85e08e21015c8ab03e885b41f1" translate="yes" xml:space="preserve">
          <source>This function is used for stepping over one or more encoded terms in a buffer, to directly access later term.</source>
          <target state="translated">该函数用于跳过缓冲区中的一个或多个编码术语,直接访问后面的术语。</target>
        </trans-unit>
        <trans-unit id="9487b4eae0bc40d60b1b4e845725399492924f17" translate="yes" xml:space="preserve">
          <source>This function is used in conjunction with the monitor function.</source>
          <target state="translated">本功能与显示器功能配合使用。</target>
        </trans-unit>
        <trans-unit id="2f9f35e4a07c284d87e14bf146829705627cc610" translate="yes" xml:space="preserve">
          <source>This function is used to change the megaco trace level.</source>
          <target state="translated">该功能用于改变Megaco跟踪级别。</target>
        </trans-unit>
        <trans-unit id="9905970e8ef361713ff0dc6a231017daa7b1f422" translate="yes" xml:space="preserve">
          <source>This function is used to convert a socket_handle() to a inet_socket(). inet_socket() is a plain socket, see the inet module for more info.</source>
          <target state="translated">这个函数用于将socket_handle()转换为inet_socket()。 inet_socket()是一个普通的socket,更多信息请参见inet模块。</target>
        </trans-unit>
        <trans-unit id="872fb743adffaedcd340beb243b7412272596a11" translate="yes" xml:space="preserve">
          <source>This function is used to do a control operation on the active trace port driver on the given node (&lt;code&gt;Nodename&lt;/code&gt;). Which operations are allowed as well as their return values depend on which trace driver is used.</source>
          <target state="translated">此功能用于在给定节点（ &lt;code&gt;Nodename&lt;/code&gt; ）上的活动跟踪端口驱动程序上执行控制操作。允许哪些操作以及它们的返回值取决于所使用的跟踪驱动程序。</target>
        </trans-unit>
        <trans-unit id="322561e5d565d22195eae197df02cf59dd3cfda9" translate="yes" xml:space="preserve">
          <source>This function is used to flush the internal buffers held by a trace port driver. Currently only the file trace driver supports this operation. Returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">此功能用于刷新跟踪端口驱动程序所拥有的内部缓冲区。当前，只有文件跟踪驱动程序支持此操作。返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d09103efe5f0276f6c79d552dc6e48c891087e8e" translate="yes" xml:space="preserve">
          <source>This function is used to open a TPKT connection.</source>
          <target state="translated">该功能用于打开TPKT连接。</target>
        </trans-unit>
        <trans-unit id="757eb6e7834e636a4181b74283f0227f0e2ffefa" translate="yes" xml:space="preserve">
          <source>This function is used to open an UDP/IP socket.</source>
          <target state="translated">该功能用于打开一个UDP/IP套接字。</target>
        </trans-unit>
        <trans-unit id="810c1759ff4f2ee4359ad6e55e1e0716e8de8e16" translate="yes" xml:space="preserve">
          <source>This function is used to perform pattern matching similar to that done in Erlang. For matching rules and more examples, see section &lt;code&gt;Pattern Matching&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">该功能用于执行模式匹配，类似于在Erlang中进行的模式匹配。有关匹配规则和更多示例，请参见《 Erlang参考手册》中的&amp;ldquo; &lt;code&gt;Pattern Matching&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="8225c2b0b7a823b2c3db31843555cf08b0b1c58a" translate="yes" xml:space="preserve">
          <source>This function is used to reset (disable) trace for the given module(s).</source>
          <target state="translated">该函数用于重置(禁用)指定模块的跟踪。</target>
        </trans-unit>
        <trans-unit id="5e4eb0cb134962fb3cf2970562621b143268d3f7" translate="yes" xml:space="preserve">
          <source>This function is used to set up default trace on function(s) for the given module or modules. The scope of the trace will be all &lt;strong&gt;exported&lt;/strong&gt; functions (both the call info and the return value). Timestamp info will also be included.</source>
          <target state="translated">此功能用于为给定的一个或多个模块设置功能的默认跟踪。跟踪的范围将是所有&lt;strong&gt;导出的&lt;/strong&gt;函数（调用信息和返回值）。时间戳信息也将包括在内。</target>
        </trans-unit>
        <trans-unit id="cb8a8d71cb3f7af3283d816d0841f08d24b9568d" translate="yes" xml:space="preserve">
          <source>This function is used to set up trace on function(s) for the given module or modules.</source>
          <target state="translated">该函数用于为给定模块设置函数的跟踪。</target>
        </trans-unit>
        <trans-unit id="03c0831d3d5485f7597cd0b7a56cfb11e2d8d606" translate="yes" xml:space="preserve">
          <source>This function is used to start megaco tracing at a given &lt;code&gt;Level&lt;/code&gt; and direct result to the given &lt;code&gt;Destination&lt;/code&gt;.</source>
          <target state="translated">此函数用于在给定的 &lt;code&gt;Level&lt;/code&gt; 开始megaco跟踪，并将结果定向到给定的 &lt;code&gt;Destination&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5198a41fa4397f2b825350859ef9349761d440d3" translate="yes" xml:space="preserve">
          <source>This function is used to start the flex scanner. It locates the library and loads the linked in driver.</source>
          <target state="translated">该函数用于启动柔性扫描仪。它定位库并加载链接的驱动程序。</target>
        </trans-unit>
        <trans-unit id="9cbb65fd2f2f55ed5a8fdfcfbb54dede2d39cbef" translate="yes" xml:space="preserve">
          <source>This function is used to stop megaco tracing.</source>
          <target state="translated">该功能用于停止Megaco追踪。</target>
        </trans-unit>
        <trans-unit id="aa9a7f11a1203465f0dab2a3fff9289e46f67958" translate="yes" xml:space="preserve">
          <source>This function is used to stop the flex scanner. It also unloads the driver.</source>
          <target state="translated">该功能用于停止柔性扫描仪。它还可以卸载驱动程序。</target>
        </trans-unit>
        <trans-unit id="1834d21edb25fe321739aff4973157dc0f8ba281" translate="yes" xml:space="preserve">
          <source>This function is used when implementing an alternative distribution carrier using processes as distribution controllers. &lt;code&gt;DHandle&lt;/code&gt; is retrived via the callback &lt;code&gt;f_handshake_complete&lt;/code&gt;. More information can be found in the documentation of &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt;.</source>
          <target state="translated">当使用流程作为分发控制器来实现备用分发载体时，将使用此功能。 &lt;code&gt;DHandle&lt;/code&gt; 通过回调retrived &lt;code&gt;f_handshake_complete&lt;/code&gt; 。可在《 &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt; 的文档中找到更多信息。</target>
        </trans-unit>
        <trans-unit id="44824ba63eb3b307aabd6873ec5a1a332b6ba401" translate="yes" xml:space="preserve">
          <source>This function is used when segmentation has been configured. So, for this to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">配置了分段后，将使用此功能。因此，要使其正常工作，&lt;strong&gt;必须&lt;/strong&gt;完全支持此功能！</target>
        </trans-unit>
        <trans-unit id="12a35f0dbe51b5e3f1ecec001171f5281b1d71b2" translate="yes" xml:space="preserve">
          <source>This function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">此功能可用作开发和测试期间的快捷方式，但不得在生产系统中使用。有关如何为实时系统配置Logger的信息，请参见《内核用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 部分和 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="0e08d85e1b9bab386f133ff706c8c19be0cec717" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_server&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value, as well as how its status appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current status of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">对于这些情况，此功能对于更改 &lt;code&gt;gen_server&lt;/code&gt; 状态的形式和外观很有用。希望更改 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回值以及其状态如何出现在终止错误日志中的回调模块，将导出 &lt;code&gt;format_status/2&lt;/code&gt; 实例，该实例返回一个描述 &lt;code&gt;gen_server&lt;/code&gt; 进程当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="09f573635e783a4ad23c419f9139aab803708c3f" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_statem&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value and how its status appears in termination error logs exports an instance of &lt;code&gt;format_status/2&lt;/code&gt;, which returns a term describing the current status of the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">对于这些情况，此功能对于更改 &lt;code&gt;gen_statem&lt;/code&gt; 状态的形式和外观很有用。希望更改 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回值以及其状态如何在终止错误日志中显示的回调模块将导出 &lt;code&gt;format_status/2&lt;/code&gt; 的实例，该实例返回一个描述 &lt;code&gt;gen_statem&lt;/code&gt; 当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="b7792553fb70da23062b7be9ff4e7b99b4bb7f20" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the event handler state for these cases. An event handler callback module wishing to change the the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value as well as how its state appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current state of the event handler.</source>
          <target state="translated">对于这些情况，此功能对于更改事件处理程序状态的形式和外观很有用。希望更改 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回值以及其状态在终止错误日志中的显示方式的事件处理程序回调模块，导出 &lt;code&gt;format_status/2&lt;/code&gt; 的实例，该实例返回描述事件处理程序当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="610385401f6f02f433fd707df3e351fe5fa74f60" translate="yes" xml:space="preserve">
          <source>This function is useful if coverage data from different systems is to be merged.</source>
          <target state="translated">如果要合并来自不同系统的覆盖数据,该功能非常有用。</target>
        </trans-unit>
        <trans-unit id="98a04423b1194d9a1f5fa9b90393dfa8d11918f4" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_server&lt;/code&gt; process behavior provides.</source>
          <target state="translated">当需要比 &lt;code&gt;gen_server&lt;/code&gt; 进程行为提供的复杂的初始化过程时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="8e0b171472c534adf0757b7201fbb51bc8b8ffd0" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_statem&lt;/code&gt; behavior provides.</source>
          <target state="translated">当需要比 &lt;code&gt;gen_statem&lt;/code&gt; 行为提供的复杂的初始化过程时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="cea361e65fc7577a23ace8db8f6fec22077e2877" translate="yes" xml:space="preserve">
          <source>This function is usefull for flow control.</source>
          <target state="translated">该功能适用于流量控制。</target>
        </trans-unit>
        <trans-unit id="f46b30ae03aba38f2d6dbaebe599182eb938575a" translate="yes" xml:space="preserve">
          <source>This function may return an updated &lt;code&gt;NewExtraInfo&lt;/code&gt; that will be used in subsequent calls to the callback functions. Intended for future use.</source>
          <target state="translated">此函数可能返回更新的 &lt;code&gt;NewExtraInfo&lt;/code&gt; ，将在后续对回调函数的调用中使用。供将来使用。</target>
        </trans-unit>
        <trans-unit id="0ffae6b0af7395d12b556d9a92b8b8453169f33e" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数可能恰好返回 &lt;code&gt;0.0&lt;/code&gt; ，这对于某些应用程序可能是致命的。如果不希望这样，则可以使用 &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; 来获取时间间隔 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; ，或者使用 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca39a4b036275d0803e561bc49de6198f5110e47" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数可能恰好返回 &lt;code&gt;0.0&lt;/code&gt; ，这对于某些应用程序可能是致命的。如果不希望这样，可以使用 &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; 来获取时间间隔 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; ，或者改用 &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ce28b85ea3b55e10e44c23baa40c3964f84d6e" translate="yes" xml:space="preserve">
          <source>This function modifies the emulated environment used by &lt;code&gt;os:putenv/2&lt;/code&gt; and not the environment used by libc's &lt;code&gt;putenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;putenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">此函数修改 &lt;code&gt;os:putenv/2&lt;/code&gt; 所使用的仿真环境，而不是libc的 &lt;code&gt;putenv(3)&lt;/code&gt; 或类似环境所使用的环境。&lt;strong&gt;需要&lt;/strong&gt;同步的驱动程序将需要自己进行同步，但要记住，它们是有一定隔离的。 &lt;code&gt;putenv(3)&lt;/code&gt; 及其朋友&lt;strong&gt;不是线程安全的，&lt;/strong&gt;并且可能导致无关的代码行为异常或使模拟器崩溃。</target>
        </trans-unit>
        <trans-unit id="7d9bfad73b174be24fda46b6c6997bb2f07b83e7" translate="yes" xml:space="preserve">
          <source>This function must be called before any of the others in the &lt;code&gt;Erl_Interface&lt;/code&gt; library to initialize the library functions. The arguments must be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">在初始化 &lt;code&gt;Erl_Interface&lt;/code&gt; 库中的任何其他函数之前，必须先调用此函数。参数必须指定为 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd9a39191cb32abe8a7e5735ecc342ac8656f1e" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will never return.</source>
          <target state="translated">必须通过与 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 相同的进程来调用此函数，否则它将永远不会返回。</target>
        </trans-unit>
        <trans-unit id="19959c57c9d15d692c85ae027062ec2bc955b6f2" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will only return &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">必须通过与 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 相同的进程来调用此函数，否则它将仅返回 &lt;code&gt;timeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb3502ac60b18fe8cef093c946cf825538bc7b7" translate="yes" xml:space="preserve">
          <source>This function must be called immediately after &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt;, before any call of &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须在 &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 之后立即调用此函数，然后再调用 &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b75dd99eca2ff3b13955cd576db05e608645330" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case (not executing in a parallel group) has called function &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在测试用例（不在并行组中执行）调用函数 &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt; 之后，必须继续调用此函数。</target>
        </trans-unit>
        <trans-unit id="05df078881db876012ab67fef726a729b94ff9d8" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case has called &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt;. If the paused test case, &lt;code&gt;TestCase&lt;/code&gt;, executes in a parallel group, this function, rather than &lt;code&gt;continue/0&lt;/code&gt;, must be used to let the test case proceed.</source>
          <target state="translated">测试用例 &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; 之后，必须继续调用此函数。如果暂停的测试用例 &lt;code&gt;TestCase&lt;/code&gt; 在并行组中执行，则必须使用此函数而不是 &lt;code&gt;continue/0&lt;/code&gt; 来使测试用例继续进行。</target>
        </trans-unit>
        <trans-unit id="df6ca91336232bf4dc1b262219129b2c8bee458f" translate="yes" xml:space="preserve">
          <source>This function must be used by a process that has been started by a &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; function. It tells &lt;code&gt;Parent&lt;/code&gt; that the process has initialized itself, has started, or has failed to initialize itself.</source>
          <target state="translated">必须由 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; 函数启动的进程使用此函数。它告诉 &lt;code&gt;Parent&lt;/code&gt; 进程已初始化，启动或初始化失败。</target>
        </trans-unit>
        <trans-unit id="4eb57f4a5bbafdd8247f55548e5ee187fd56dc8b" translate="yes" xml:space="preserve">
          <source>This function needs to be called as a transaction. Assume that you wish to write a function that both calls the function &lt;code&gt;add_subscriber/1&lt;/code&gt; and is in itself protected by the context of a transaction. By calling &lt;code&gt;add_subscriber/1&lt;/code&gt; from within another transaction, a nested transaction is created.</source>
          <target state="translated">此功能需要作为事务调用。假设您希望编写一个既调用 &lt;code&gt;add_subscriber/1&lt;/code&gt; 函数又受事务上下文保护的函数。通过从另一个事务中调用 &lt;code&gt;add_subscriber/1&lt;/code&gt; ，将创建一个嵌套事务。</target>
        </trans-unit>
        <trans-unit id="bdb288dde170ca25e8a4e8d2927079c35992755a" translate="yes" xml:space="preserve">
          <source>This function only succeeds in platforms that provide this feature. When it succeeds, space is preallocated for the file but the file size might not be updated. This behaviour depends on the preallocation implementation. To guarantee that the file size is updated, truncate the file to the new size.</source>
          <target state="translated">此功能只有在提供此功能的平台上才会成功。当它成功时,文件的空间会被预分配,但文件大小可能不会被更新。这种行为取决于预分配的实现。为了保证文件大小得到更新,将文件截断为新的大小。</target>
        </trans-unit>
        <trans-unit id="b9d0851586e3645c6e0718dc09f5fec49d8fc898" translate="yes" xml:space="preserve">
          <source>This function performs the following transformation:</source>
          <target state="translated">该函数执行以下转换:</target>
        </trans-unit>
        <trans-unit id="681ee068d504344b07045ef0edae3fb7a6646520" translate="yes" xml:space="preserve">
          <source>This function prints all elements of a list onto a stream:</source>
          <target state="translated">该函数将列表中的所有元素打印到一个流中。</target>
        </trans-unit>
        <trans-unit id="abd07fdc0e97d4adf4e29f31e2cc86ba2b8eaea2" translate="yes" xml:space="preserve">
          <source>This function produces a list of information about the megaco application. Such as users and their config, connections and their config, statistics and so on.</source>
          <target state="translated">这个功能会产生一个关于megaco应用程序的信息列表,比如用户和他们的配置,连接和他们的配置,统计等等。比如用户和他们的配置,连接和他们的配置,统计数据等等。</target>
        </trans-unit>
        <trans-unit id="4aec40bb5deb9daace1e8128ff80ca5cbdbd3ab4" translate="yes" xml:space="preserve">
          <source>This function provides a low-level interface to the pretty printer, returning a flexible representation of possible layouts, independent of the paper width eventually to be used for formatting. This can be included as part of another document and/or further processed directly by the functions in the &lt;code&gt;prettypr&lt;/code&gt; module, or used in a hook function (see &lt;code&gt;format/2&lt;/code&gt; for details).</source>
          <target state="translated">此功能为漂亮的打印机提供了一个低级界面，返回了可能的布局的灵活表示形式，而与最终用于格式化的纸张宽度无关。这可以作为另一个文档的一部分包含和/或由 &lt;code&gt;prettypr&lt;/code&gt; 模块中的函数直接进行进一步处理，或在挂钩函数中使用（有关详细信息，请参阅 &lt;code&gt;format/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="292e6a8f5a93138af65b2381d7cdb5c0c6c34358" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. (The update is done atomically, that is, no process can access the ETS table in the middle of the operation.)</source>
          <target state="translated">这个函数提供了一种高效的方法来更新一个或多个计数器,而不需要麻烦地查找一个对象,通过增量元素来更新对象,并将得到的对象再次插入到表中。更新是以原子方式进行的,也就是说,没有任何进程可以在操作中间访问ETS表)。</target>
        </trans-unit>
        <trans-unit id="8b9e675f31114737aa33341ede5a5aba5db53e0d" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more elements within an object, without the trouble of having to look up, update, and write back the entire object.</source>
          <target state="translated">该函数提供了一种有效的方法来更新对象中的一个或多个元素,而不需要查找、更新和回写整个对象。</target>
        </trans-unit>
        <trans-unit id="c1b5d7fcc798e3adcd6205abd49a5e2a97894217" translate="yes" xml:space="preserve">
          <source>This function reads match specifications from a file (possibly) generated by the &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; function. It checks the syntax of all match specifications and verifies that they are correct. The error handling principle is &quot;all or nothing&quot;, i. e. if some of the match specifications are wrong, none of the specifications are added to the list of saved match specifications for the running system.</source>
          <target state="translated">该函数从 &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 函数生成的文件（可能）中读取匹配规范。它检查所有匹配规范的语法并验证它们是否正确。错误处理原则是&amp;ldquo;全部或全部&amp;rdquo;，即如果某些匹配规范错误，则不会将任何规范添加到正在运行的系统的已保存匹配规范列表中。</target>
        </trans-unit>
        <trans-unit id="4c87d8b732e8491a29379bc4f4e018b87a77b776" translate="yes" xml:space="preserve">
          <source>This function reads the emulated environment used by &lt;code&gt;os:getenv/1&lt;/code&gt; and not the environment used by libc's &lt;code&gt;getenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;getenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">此函数读取 &lt;code&gt;os:getenv/1&lt;/code&gt; 所使用的仿真环境，而不读取libc的 &lt;code&gt;getenv(3)&lt;/code&gt; 或类似环境所使用的环境。&lt;strong&gt;需要&lt;/strong&gt;同步的驱动程序将需要自己进行同步，但要记住，它们是有一定隔离的。 &lt;code&gt;getenv(3)&lt;/code&gt; 及其朋友&lt;strong&gt;不是线程安全的，&lt;/strong&gt;并且可能导致无关的代码行为异常或使模拟器崩溃。</target>
        </trans-unit>
        <trans-unit id="10a11b74ad5663559d5b504d02b42b896b8198c8" translate="yes" xml:space="preserve">
          <source>This function requires root privileges to succeed.</source>
          <target state="translated">该功能需要root权限才能成功。</target>
        </trans-unit>
        <trans-unit id="062c8ae0406bce16cb74fa7ee50a7f220f4495f9" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued through &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果服务器由于预期的原因终止，则此函数返回 &lt;code&gt;ok&lt;/code&gt; 。除了 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 之外的任何其他原因都会导致通过 &lt;code&gt;logger(3)&lt;/code&gt; 发出错误报告。默认的 &lt;code&gt;Reason&lt;/code&gt; 是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b619b8eb3b06a0c1f9ee95ad936ded887fe9b1f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{continue | finished, Output}&lt;/code&gt;, where Output is the data that was decompressed in this call. New input can be queued up on each call if desired, and the function will return &lt;code&gt;{finished, Output}&lt;/code&gt; once all queued data has been decompressed.</source>
          <target state="translated">此函数返回 &lt;code&gt;{continue | finished, Output}&lt;/code&gt; ，其中Output是在此调用中解压缩的数据。如果需要，可以在每个调用中将新的输入排队，并且一旦所有排队的数据都已解压缩，该函数将返回 &lt;code&gt;{finished, Output}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fe5f1399ea4e26d1526efcdd913ad89693dd38c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;, when there is more output available, and &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; is to be used to read it.</source>
          <target state="translated">当有更多可用输出时 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 此函数返回{more，Decompressed}，并且将使用 &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; 来读取它。</target>
        </trans-unit>
        <trans-unit id="57c7b411ef596e9d3dc2dccd3a829fab7afcf559" translate="yes" xml:space="preserve">
          <source>This function returns a non-zero value if the time-slice has been exhausted, and zero if the callback is allowed to continue execution. If a non-zero value is returned, the driver callback is to return as soon as possible in order for the port to be able to yield.</source>
          <target state="translated">如果时间片已经耗尽,这个函数返回一个非零值,如果回调被允许继续执行,则返回零值。如果返回一个非零的值,则驱动回调应尽快返回,以使 port 能够屈服。</target>
        </trans-unit>
        <trans-unit id="b34ef5ebb7e9ff07df93e070c922fe104914c7bc" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; of the named table identified by &lt;code&gt;TableName&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if no such table exists. The &lt;code&gt;tid()&lt;/code&gt; can be used in place of the table name in all operations, which is slightly faster since the name does not have to be resolved on each call.</source>
          <target state="translated">此函数返回由 &lt;code&gt;TableName&lt;/code&gt; 标识的命名表的 &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; ，如果不存在这样的表，则返回 &lt;code&gt;undefined&lt;/code&gt; 。该 &lt;code&gt;tid()&lt;/code&gt; 来代替表名的所有操作，这稍微快一些，因为该名称不必在每次调用待解决使用。</target>
        </trans-unit>
        <trans-unit id="50dd77bc2f5d6e06a832906b2c12c471d8aa9340" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;Adler&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;Adler1&lt;/code&gt;, &lt;code&gt;Adler2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">该函数返回 &lt;code&gt;Adler&lt;/code&gt; 的校验和 &lt;code&gt;[Data1,Data2]&lt;/code&gt; ，只需要 &lt;code&gt;Adler1&lt;/code&gt; ， &lt;code&gt;Adler2&lt;/code&gt; ，和 &lt;code&gt;Size2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="254134ddf194a5bc8b6a55dc528e9535675c6294" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;CRC&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;CRC1&lt;/code&gt;, &lt;code&gt;CRC2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">该函数返回 &lt;code&gt;CRC&lt;/code&gt; 的校验和 &lt;code&gt;[Data1,Data2]&lt;/code&gt; ，只需要 &lt;code&gt;CRC1&lt;/code&gt; ， &lt;code&gt;CRC2&lt;/code&gt; ，和 &lt;code&gt;Size2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfe8f7ec0382a52a177f156ebe5c3e11685e6528" translate="yes" xml:space="preserve">
          <source>This function returns the default encoding for Erlang source files (if no encoding comment is present) in the currently running release. In Erlang/OTP R16B, &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) was returned. As from Erlang/OTP 17.0, &lt;code&gt;utf8&lt;/code&gt; is returned.</source>
          <target state="translated">此函数返回当前正在运行的发行版中Erlang源文件的默认编码（如果不存在编码注释）。在Erlang / OTP R16B中，返回了 &lt;code&gt;latin1&lt;/code&gt; （按字节编码）。从Erlang / OTP 17.0开始，返回 &lt;code&gt;utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ac5e4c95ff19314b1e92b03b1fbc6ddb4df1f4" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process or, if no user tag is present, the last user tag sent to the process together with a message (in the same way as &lt;code&gt;sequential trace tokens&lt;/code&gt; are spread to other processes together with messages. For an explanation of how user tags can be spread together with messages, see &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt;. If no tag is found or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">此函数返回在当前进程中设置的用户标签，或者，如果不存在用户标签，则返回发送到该进程的最后一个用户标签以及一条消息（与 &lt;code&gt;sequential trace tokens&lt;/code&gt; 与消息一起散布到其他进程的方式相同）。有关如何将用户标记与消息一起传播的说明，请参见 &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt; 。如果找不到标记或动态跟踪不可用，则它将返回 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad3f3a41d62bdc7c42feabe41234fd9722d7cb98" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process. If no tag is set or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">该函数返回当前进程中设置的用户标签。如果未设置标签或动态跟踪不可用，则返回 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd79f4e47f62cf59b521bcb089167a8d5c5fd14f" translate="yes" xml:space="preserve">
          <source>This function returns the verbosity level for the specified logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to read the general verbosity level.</source>
          <target state="translated">此函数返回指定日志记录类别的详细级别。有关详细信息，请参见《 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 》。使用 &lt;code&gt;default&lt;/code&gt; 值读取常规详细程度。</target>
        </trans-unit>
        <trans-unit id="9213458608b1e7bf5d8b4e1a7eb828c4aad8ff78" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and a new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">此函数从字典返回值，而没有该值的新字典将返回该值。如果字典中不存在该键，则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf35b3402a76d292262e9d707c75231902c52bf" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">此函数从字典和新字典返回值，而没有该值。如果字典中不存在该键，则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4620a951555900d51d4b19f86794013a12f92c5b" translate="yes" xml:space="preserve">
          <source>This function runs the measurement on all the &lt;strong&gt;official&lt;/strong&gt; codecs; pretty, compact, ber, per and erlang.</source>
          <target state="translated">此功能在所有&lt;strong&gt;官方&lt;/strong&gt;编解码器上运行测量；漂亮，紧凑，误码率，per和erlang。</target>
        </trans-unit>
        <trans-unit id="4d644d2c0042513fa733b8a7d873cf8a04730f5c" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to add the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:init([])&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;add_handler&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the event handler.</source>
          <target state="translated">此函数向注册为 &lt;code&gt;error_man&lt;/code&gt; 的事件管理器发送一条消息，告诉它添加事件处理程序 &lt;code&gt;terminal_logger&lt;/code&gt; 。事件管理器调用回调函数 &lt;code&gt;terminal_logger:init([])&lt;/code&gt; ，其中参数 &lt;code&gt;[]&lt;/code&gt; 是 &lt;code&gt;add_handler&lt;/code&gt; 的第三个参数。预期 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是事件处理程序的内部状态。</target>
        </trans-unit>
        <trans-unit id="9488c1c7cd2d72dbd05ee8b3a4cf579cbfcc3089" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to delete the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;delete_handler&lt;/code&gt;. &lt;code&gt;terminate&lt;/code&gt; is to be the opposite of &lt;code&gt;init&lt;/code&gt; and do any necessary cleaning up. Its return value is ignored.</source>
          <target state="translated">此函数向注册为 &lt;code&gt;error_man&lt;/code&gt; 的事件管理器发送一条消息，告诉它删除事件处理程序 &lt;code&gt;terminal_logger&lt;/code&gt; 。事件管理器调用回调函数 &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt; ，其中参数 &lt;code&gt;[]&lt;/code&gt; 是 &lt;code&gt;delete_handler&lt;/code&gt; 的第三个参数。 &lt;code&gt;terminate&lt;/code&gt; 与 &lt;code&gt;init&lt;/code&gt; 相反，并进行必要的清理。它的返回值被忽略。</target>
        </trans-unit>
        <trans-unit id="01064956f3c5f10087dfedd98caeabdab20043f6" translate="yes" xml:space="preserve">
          <source>This function sets the user tag of the current process. The user tag is a binary(), but can be specified as any iodata(), which is automatically converted to a binary by this function.</source>
          <target state="translated">该函数设置当前进程的用户标签。用户标签是二进制(),但也可以指定为任何iodata(),该函数会自动将其转换为二进制。</target>
        </trans-unit>
        <trans-unit id="61313460b8aa3e37c5b58b57b47f109e6ec0573c" translate="yes" xml:space="preserve">
          <source>This function sets up a subscription for NETCONF event notifications of the specified stream type, matching the specified filter. The calling process receives notifications as messages of type &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数为指定流类型的NETCONF事件通知设置订阅，与指定的过滤器匹配。调用过程接收通知，作为 &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt; 类型为notify（）的消息。</target>
        </trans-unit>
        <trans-unit id="ae2f0db4a2d6577440241530db91576d86c351bc" translate="yes" xml:space="preserve">
          <source>This function should be used by custom Logger handlers to make configuration consistent no matter which handler the system uses. Normal usage is to add a call to &lt;code&gt;logger:add_handlers/1&lt;/code&gt; just after the processes that the handler needs are started, and pass the application's &lt;code&gt;logger&lt;/code&gt; configuration as the argument. For example:</source>
          <target state="translated">定制Logger处理程序应使用此功能，以使配置一致，无论系统使用哪个处理程序。通常的用法是在处理程序所需的进程启动后立即添加对 &lt;code&gt;logger:add_handlers/1&lt;/code&gt; 的调用，并将应用程序的 &lt;code&gt;logger&lt;/code&gt; 配置作为参数传递。例如：</target>
        </trans-unit>
        <trans-unit id="f301b3f0b8c0209d0cf4fd9f62efd0855d383514" translate="yes" xml:space="preserve">
          <source>This function should be used whenever the &lt;code&gt;ScopedPDU&lt;/code&gt; is encrypted.</source>
          <target state="translated">每当对 &lt;code&gt;ScopedPDU&lt;/code&gt; 进行加密时，都应使用此功能。</target>
        </trans-unit>
        <trans-unit id="6163aa7d8dcc271f09c1955760210bfef0a047d1" translate="yes" xml:space="preserve">
          <source>This function should only be used for micro-benchmarks; it sets &lt;code&gt;copy_save&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for the duration of the call, which can quickly lead to running out of memory.</source>
          <target state="translated">此功能应仅用于微基准测试；它将在整个调用过程 &lt;code&gt;copy_save&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，这会很快导致内存不足。</target>
        </trans-unit>
        <trans-unit id="378340ac7df7630dbeb8cb5d900d9bad24c77182" translate="yes" xml:space="preserve">
          <source>This function should, besides spawning the connection supervisor, also create a distribution controller. The distribution controller is either a process or a port which is responsible for dispatching traffic.</source>
          <target state="translated">这个函数除了生成连接监控器,还应该创建一个分发控制器。分布控制器可以是一个进程,也可以是一个端口,负责调度流量。</target>
        </trans-unit>
        <trans-unit id="d4d47d2b2af731fd5c9c26e6262581d877c04f00" translate="yes" xml:space="preserve">
          <source>This function shuts down a previously started trace client. The &lt;code&gt;Pid&lt;/code&gt; argument is the process id returned from the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">此功能关闭以前启动的跟踪客户端。所述 &lt;code&gt;Pid&lt;/code&gt; 参数是从返回进程id &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; 呼叫。</target>
        </trans-unit>
        <trans-unit id="1762fe9d329cecf345c08b9b7958cf3995f81b8e" translate="yes" xml:space="preserve">
          <source>This function spawns and links to a new process, an event manager.</source>
          <target state="translated">该函数生成并链接到一个新的进程,即事件管理器。</target>
        </trans-unit>
        <trans-unit id="550809e278a777ab2f212797a3d8588ff2bdddcd" translate="yes" xml:space="preserve">
          <source>This function starts a server on the local node that will be the recipient of all trace messages. All subsequent calls to &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; will result in messages sent to the newly started trace server.</source>
          <target state="translated">此功能在本地节点上启动服务器，该服务器将成为所有跟踪消息的收件人。对 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 的所有后续调用将导致消息发送到新启动的跟踪服务器。</target>
        </trans-unit>
        <trans-unit id="02bf735444f615dc9059203b498c83b1b1c490d8" translate="yes" xml:space="preserve">
          <source>This function starts a trace client that reads the output created by a trace port driver and handles it in mostly the same way as a tracer process created by the &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">此函数启动跟踪客户端，该客户端读取由跟踪端口驱动程序创建的输出，并以与 &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; 函数创建的跟踪进程几乎相同的方式处理该输出。</target>
        </trans-unit>
        <trans-unit id="71ed1ace1cba19901a1c4410fa55742720248a3e" translate="yes" xml:space="preserve">
          <source>This function starts a tracer server with additional parameters on the local node. The first parameter, the &lt;code&gt;Type&lt;/code&gt;, indicates if trace messages should be handled by a receiving process (&lt;code&gt;process&lt;/code&gt;), by a tracer port (&lt;code&gt;port&lt;/code&gt;) or by a tracer module (&lt;code&gt;module&lt;/code&gt;). For a description about tracer ports see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; and for a tracer modules see &lt;code&gt;erl_tracer&lt;/code&gt;.</source>
          <target state="translated">此功能使用本地节点上的其他参数启动跟踪服务器。第一个参数 &lt;code&gt;Type&lt;/code&gt; 指示是否应由接收进程（ &lt;code&gt;process&lt;/code&gt; ），跟踪器端口（ &lt;code&gt;port&lt;/code&gt; ）或跟踪器模块（ &lt;code&gt;module&lt;/code&gt; ）处理跟踪消息。有关跟踪器端口的描述，请参见 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ；对于跟踪器模块，请参见 &lt;code&gt;erl_tracer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b87e561423bace774990128b77e86ad6df9e413" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with all codec configs. &lt;code&gt;Factor&lt;/code&gt; (defaults to &lt;code&gt;1&lt;/code&gt;) processes are started for every supported codec config.</source>
          <target state="translated">此功能使用所有编解码器配置启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试。为每个受支持的编解码器配置启动 &lt;code&gt;Factor&lt;/code&gt; （默认为 &lt;code&gt;1&lt;/code&gt; ）过程。</target>
        </trans-unit>
        <trans-unit id="792ed4cb1314be5885f62ea62a3ebeadcd5147c2" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with codec configs not using any drivers (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; without &lt;code&gt;flex&lt;/code&gt;, &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; without &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; without &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此函数使用不使用任何驱动程序的编解码器配置启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试（即，没有 &lt;code&gt;flex&lt;/code&gt; ， &lt;code&gt;ber&lt;/code&gt; 和 &lt;code&gt;per&lt;/code&gt; ,没有 &lt;code&gt;driver&lt;/code&gt; 和 &lt;code&gt;erlang&lt;/code&gt; ,没有 &lt;code&gt;compressed&lt;/code&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;code&gt;compact&lt;/code&gt; ）。与运行标准测试时（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）启动的进程数量相同。每个进程对它们的消息进行编码和解码。 （对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="ad7b4c53c1b5220bc2673b30cb62ee3a8a2764a4" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the driver using codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;, and &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; with &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; with &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此功能启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试，只有使用的编解码器CONFIGS（即司机 &lt;code&gt;pretty&lt;/code&gt; 和 &lt;code&gt;compact&lt;/code&gt; 有 &lt;code&gt;flex&lt;/code&gt; ，和 &lt;code&gt;ber&lt;/code&gt; 和 &lt;code&gt;per&lt;/code&gt; 与 &lt;code&gt;driver&lt;/code&gt; 和 &lt;code&gt;erlang&lt;/code&gt; 与 &lt;code&gt;compressed&lt;/code&gt; ）。与运行标准测试时（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）启动的进程数量相同。每个进程对它们的消息进行编码和解码。 （对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="a169f04fb06754d3d77f607833509158a7205503" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the flex codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此函数仅使用flex编解码器配置（即，使用 &lt;code&gt;flex&lt;/code&gt; &lt;strong&gt;既&lt;/strong&gt; &lt;code&gt;pretty&lt;/code&gt; 又 &lt;code&gt;compact&lt;/code&gt; ）来启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试。与运行标准测试时启动的进程数量相同（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）。每个进程对它们的消息进行编码和解码。（对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="198cdb7eaaa9d51f54f530ef45039bacb833b143" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone2&lt;/strong&gt; performance test with all codec configs. Processes are created dynamically. Each process make &lt;strong&gt;one&lt;/strong&gt; run through their messages (decoding and encoding messages) and then exits. When one process exits, a new is created with the same codec config and set of messages.</source>
          <target state="translated">此功能使用所有编解码器配置启动&lt;strong&gt;mstone2&lt;/strong&gt;性能测试。进程是动态创建的。每个进程化妆&lt;strong&gt;一个&lt;/strong&gt;通过它们的消息（解码和编码的消息），然后退出运行。当一个进程退出时，将使用相同的编解码器配置和消息集创建一个新消息。</target>
        </trans-unit>
        <trans-unit id="3f645d23afcc815891f3acc3933eab5ba5bdfcf9" translate="yes" xml:space="preserve">
          <source>This function starts the evaluation of a digit map with megaco:eval_digit_map/1 and sends a sequence of events to it megaco:report_digit_event/2 in order to simplify testing of digit maps.</source>
          <target state="translated">这个函数从megaco:eval_digit_map/1开始对数字图进行评估,并向其发送事件序列megaco:report_digit_event/2,以简化数字图的测试。</target>
        </trans-unit>
        <trans-unit id="4a3fae66ed7c3cc4e51664a7096a153b2497b47c" translate="yes" xml:space="preserve">
          <source>This function starts the standalone &lt;code&gt;nteventlog&lt;/code&gt; process and, if &lt;code&gt;start_link/2&lt;/code&gt; is used, links to it.</source>
          <target state="translated">此函数启动独立的 &lt;code&gt;nteventlog&lt;/code&gt; 进程，如果使用了 &lt;code&gt;start_link/2&lt;/code&gt; ，则链接到该进程。</target>
        </trans-unit>
        <trans-unit id="51eab0810670dc8d97c68c1365bff9e556a60d4b" translate="yes" xml:space="preserve">
          <source>This function takes a list of 'ActionRequest' records and has three main options:</source>
          <target state="translated">该函数接收一个 &quot;ActionRequest &quot;记录列表,有三个主要选项。</target>
        </trans-unit>
        <trans-unit id="b830d311ae4ee73ecebdc71d2c40db38f6b5103e" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified managed agents, without checking if any of them exist. To change a registered managed agent, the agent must first be unregistered.</source>
          <target state="translated">该函数尝试注册指定的受管代理,而不检查它们是否存在。要改变已注册的管理代理,必须先解除代理的注册。</target>
        </trans-unit>
        <trans-unit id="97a729927e14b719ca944a21f7b5b57eca599bd8" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified users, without checking if any of them exist. To change a registered user, the user must first be unregistered.</source>
          <target state="translated">该函数尝试注册指定的用户,而不检查是否有用户存在。要改变一个已注册的用户,必须先解除该用户的注册。</target>
        </trans-unit>
        <trans-unit id="b10454e8f4725b8a0eb4da465ee57ecb2b75d61c" translate="yes" xml:space="preserve">
          <source>This function updates the configuration data from which the specified configuration variable was read, and returns the (possibly) new value of this variable.</source>
          <target state="translated">该函数更新从指定配置变量中读取的配置数据,并返回该变量的(可能)新值。</target>
        </trans-unit>
        <trans-unit id="ca81e8a0f9544f8a61bc496a4e260c146099af94" translate="yes" xml:space="preserve">
          <source>This function used to return &lt;code&gt;false&lt;/code&gt; for BIFs before Erlang/OTP 18.0.</source>
          <target state="translated">对于Erlang / OTP 18.0之前的BIF，此函数用于返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae9274ef2248b4bd36f346fff38a572567648823" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; just like &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数使用解析程序选项 &lt;code&gt;search&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="21fc2b9bb4c2e8f025026e93df306e88dd67e182" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; that is a list of domain names. If the name to resolve contains no dots, it is prepended to each domain name in the search list, and they are tried in order. If the name contains dots, it is first tried as an absolute name and if that fails, the search list is used. If the name has a trailing dot, it is supposed to be an absolute name and the search list is not used.</source>
          <target state="translated">此功能使用作为域名列表的解析器选项 &lt;code&gt;search&lt;/code&gt; 。如果要解析的名称不包含点，则将其放在搜索列表中的每个域名之前，并按顺序尝试。如果名称包含点，则首先尝试将其作为绝对名称，如果失败，则使用搜索列表。如果名称带有结尾点，则应将其视为绝对名称，并且不使用搜索列表。</target>
        </trans-unit>
        <trans-unit id="66f0f7dcf3e6aeb3b05425d374f015271bc5c8f8" translate="yes" xml:space="preserve">
          <source>This function uses the NIF library to determine if dynamic tracing is available. Usually calling &lt;code&gt;erlang:system_info/1&lt;/code&gt; is a better indicator of the availability of dynamic tracing.</source>
          <target state="translated">此函数使用NIF库来确定动态跟踪是否可用。通常，调用 &lt;code&gt;erlang:system_info/1&lt;/code&gt; 可以更好地指示动态跟踪的可用性。</target>
        </trans-unit>
        <trans-unit id="21d638edd5b52a38a30d020b01f40281508b0f05" translate="yes" xml:space="preserve">
          <source>This function uses the module &lt;code&gt;rand&lt;/code&gt; to generate new keys. The seed it uses may be initialized by calling &lt;code&gt;rand:seed/1&lt;/code&gt; or &lt;code&gt;rand:seed/2&lt;/code&gt; before this function is first called.</source>
          <target state="translated">此函数使用模块 &lt;code&gt;rand&lt;/code&gt; 生成新密钥。可以通过在第一次调用此函数之前调用 &lt;code&gt;rand:seed/1&lt;/code&gt; 或 &lt;code&gt;rand:seed/2&lt;/code&gt; 来初始化它使用的种子。</target>
        </trans-unit>
        <trans-unit id="971c66faa137257bfd2753c3d5426c0e180b495e" translate="yes" xml:space="preserve">
          <source>This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms.</source>
          <target state="translated">这个函数在Erlang/OTP R16中被引入,作为支持UTF-8原子的第一步的一部分。</target>
        </trans-unit>
        <trans-unit id="d681ac22ff0dcd99cf6793970b0001c494cacadb" translate="yes" xml:space="preserve">
          <source>This function was originally intenden for debugging purpose. It is not recommended to print very large terms with &lt;code&gt;%T&lt;/code&gt;. The function may change &lt;code&gt;errno&lt;/code&gt;, even if successful.</source>
          <target state="translated">此功能最初旨在调试。不建议使用 &lt;code&gt;%T&lt;/code&gt; 打印很大的术语。该函数可能会更改 &lt;code&gt;errno&lt;/code&gt; ，即使成功也是如此。</target>
        </trans-unit>
        <trans-unit id="ecc1aaa0050da285abdb43a70baab76906a3247e" translate="yes" xml:space="preserve">
          <source>This function will return the identity of test- and group leader processes that are still running at the time of this call. &lt;code&gt;TestProcs&lt;/code&gt; are processes in the system that have a Common Test IO process as group leader. &lt;code&gt;SharedGL&lt;/code&gt; is the central Common Test IO process, responsible for printing to log files for configuration functions and sequentially executing test cases. &lt;code&gt;OtherGLs&lt;/code&gt; are Common Test IO processes that print to log files for test cases in parallel test case groups.</source>
          <target state="translated">该函数将返回在此调用时仍在运行的测试领导者组和组领导者进程的标识。 &lt;code&gt;TestProcs&lt;/code&gt; 是系统中具有Common Test IO进程作为组长的进程。 &lt;code&gt;SharedGL&lt;/code&gt; 是中央通用测试IO流程，负责打印到配置功能的日志文件并按顺序执行测试用例。 &lt;code&gt;OtherGLs&lt;/code&gt; 是Common Test IO进程，可打印到并行测试用例组中的测试用例的日志文件。</target>
        </trans-unit>
        <trans-unit id="f14e5a0a13df62695dcaadc50e2282e18baef924" translate="yes" xml:space="preserve">
          <source>This function will save all match specifications saved during the session (during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;) and built-in match specifications in a text file with the name designated by &lt;code&gt;Name&lt;/code&gt;. The format of the file is textual, why it can be edited with an ordinary text editor, and then restored with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能会将会话期间（在调用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 期间）保存的所有匹配规范以及内置的匹配规范保存在文本文件中，该文本文件的名称由 &lt;code&gt;Name&lt;/code&gt; 指定。该文件的格式为文本格式，为什么可以使用常规文本编辑器进行编辑，然后使用 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 恢复该文件。</target>
        </trans-unit>
        <trans-unit id="fe5d78839a608e23473c4be1eb43fd59136f1578" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此函数作为 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 起作用，但仅禁用使用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 设置的跟踪（不使用 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 设置）。</target>
        </trans-unit>
        <trans-unit id="4f73b00efb28d22de61c21b36ad8a83ee49cefed" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此函数作为 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 起作用，但仅禁用使用 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 设置的跟踪（不使用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f3521fe756e0c4e17603d964e71f79b819ca2cc" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, but enables tracing for local calls (and local functions) as well as for global calls (and functions).</source>
          <target state="translated">此函数的工作方式为 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; ，但可以跟踪本地调用（和本地函数）以及全局调用（和函数）。</target>
        </trans-unit>
        <trans-unit id="649cc8a65ee1157009a2026f80b85a94281bddef" translate="yes" xml:space="preserve">
          <source>This function works exactly as &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt;, but allows you to write your own handler function. The handler function works mostly as the one described in &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but will also have to be prepared to handle trace messages of the form &lt;code&gt;{drop, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of dropped messages. This pseudo trace message will only occur if the ip trace driver is used.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 完全一样，但是允许您编写自己的处理函数。处理程序函数的工作原理与 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 中描述的函数相同，但还必须准备处理 &lt;code&gt;{drop, N}&lt;/code&gt; 形式的跟踪消息，其中 &lt;code&gt;N&lt;/code&gt; 是已删除消息的数量。仅当使用ip跟踪驱动程序时，才会出现此伪跟踪消息。</target>
        </trans-unit>
        <trans-unit id="e3613eb939658a1c4e7abb497a6aeaed611fdecc" translate="yes" xml:space="preserve">
          <source>This function works exactly the same way as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; except that it is asynchronous instead of synchronous. The spawned process will link with the caller when created. If an &lt;code&gt;Error&lt;/code&gt; occurs while doing the cover analysis the process will crash with the same error reason as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; would return.</source>
          <target state="translated">该函数的工作方式与 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 完全相同，不同之处在于它是异步的而不是同步的。创建后，生成的进程将与调用方链接。如果进行覆盖分析时发生 &lt;code&gt;Error&lt;/code&gt; ，则该过程将崩溃，并返回与 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 相同的错误原因。</target>
        </trans-unit>
        <trans-unit id="41248f0d6e585aea101cd90cc6b6f5d6fd5821da" translate="yes" xml:space="preserve">
          <source>This function, similar to &lt;code&gt;timer:sleep/1&lt;/code&gt; in STDLIB, suspends the test case for a specified time. However, this function also multiplies &lt;code&gt;Time&lt;/code&gt; with the &lt;code&gt;multiply_timetraps&lt;/code&gt; value (if set) and under certain circumstances also scales up the time automatically if &lt;code&gt;scale_timetraps&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">此功能类似于STDLIB中的 &lt;code&gt;timer:sleep/1&lt;/code&gt; ，可将测试用例暂停指定的时间。但是，此功能也倍增 &lt;code&gt;Time&lt;/code&gt; 与 &lt;code&gt;multiply_timetraps&lt;/code&gt; 值（如果设置），并在某些情况下还可扩展至如果自动时间 &lt;code&gt;scale_timetraps&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; （默认是 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="285cbe2f9f5c577e4d9b2e978e114e422218a0dd" translate="yes" xml:space="preserve">
          <source>This functionality can be used to avoid that one process overloads a database on another node.</source>
          <target state="translated">这个功能可以用来避免一个进程在另一个节点上过载数据库。</target>
        </trans-unit>
        <trans-unit id="2f663a6b926446bfebbbdc0b7d15882ae1bccc35" translate="yes" xml:space="preserve">
          <source>This functionality is only provided when using &lt;code&gt;BER&lt;/code&gt; (option &lt;code&gt;ber&lt;/code&gt;).</source>
          <target state="translated">仅在使用 &lt;code&gt;BER&lt;/code&gt; （选项 &lt;code&gt;ber&lt;/code&gt; ）时才提供此功能。</target>
        </trans-unit>
        <trans-unit id="03d45e2ad58e3bd143a9c7b2c50773493705e610" translate="yes" xml:space="preserve">
          <source>This functionality is used both when the transaction sender is used and for segmentation. So, for either of those to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">使用事务发送者时和分段时都使用此功能。因此，对于其中任何一个都必须工作，&lt;strong&gt;必须&lt;/strong&gt;完全支持此功能！</target>
        </trans-unit>
        <trans-unit id="018c73d63f139a3baee06c9daba146659fa3ed6c" translate="yes" xml:space="preserve">
          <source>This functionality is used when a client process communicates with a file i/o-server to spread the user tag to the I/O-server and then down to the efile_drv driver. By using &lt;code&gt;spread_tag/1&lt;/code&gt; and &lt;code&gt;restore_tag/1&lt;/code&gt;, one can enable or disable spreading of user tags to other processes and then restore the previous state of the user tag. The TagData returned from this call contains all previous information so the state (including any previously spread user tags) will be completely restored by a later call to &lt;code&gt;restore_tag/1&lt;/code&gt;.</source>
          <target state="translated">当客户端进程与文件I / O服务器通信以将用户标签传播到I / O服务器，然后传播到efile_drv驱动程序时，将使用此功能。通过使用 &lt;code&gt;spread_tag/1&lt;/code&gt; 和 &lt;code&gt;restore_tag/1&lt;/code&gt; ，可以启用或禁用将用户标签传播到其他进程，然后恢复用户标签的先前状态。从此调用返回的TagData包含所有先前的信息，因此状态（包括任何以前传播的用户标签）将在以后对 &lt;code&gt;restore_tag/1&lt;/code&gt; 的调用中完全恢复。</target>
        </trans-unit>
        <trans-unit id="1bfce0af83883f449ffeeed0bed57f3f0c60c686" translate="yes" xml:space="preserve">
          <source>This functionality works together with option &lt;code&gt;ber&lt;/code&gt;. It enables the specialized decodes, see Section &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能与 &lt;code&gt;ber&lt;/code&gt; 一起使用。它启用了特殊解码，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b7b1c65d65cff1e78b722d7d85e687fe5927d13" translate="yes" xml:space="preserve">
          <source>This functions differs from &lt;code&gt;token&lt;/code&gt; in that it will continue to scan tokens upto and including an &lt;code&gt;{end_token,Token}&lt;/code&gt; has been scanned (see next section). It will then return all the tokens. This is typically used for scanning grammars like Erlang where there is an explicit end token, &lt;code&gt;'.'&lt;/code&gt;. If no end token is found then the whole file will be scanned and returned. If an error occurs then all tokens upto and including the next end token will be skipped.</source>
          <target state="translated">此功能与 &lt;code&gt;token&lt;/code&gt; 不同之处在于，它将继续扫描令牌，直到包括已扫描的 &lt;code&gt;{end_token,Token}&lt;/code&gt; （请参阅下一节）。然后它将返回所有令牌。通常用于扫描像Erlang这样的语法，其中有一个明确的结束标记 &lt;code&gt;'.'&lt;/code&gt; 。如果未找到结束令牌，则将扫描并返回整个文件。如果发生错误，则将跳过所有令牌，包括下一个结束令牌。</target>
        </trans-unit>
        <trans-unit id="e988c48e237b3372b652c8e3639563f7969c8f32" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1aa52c0f139d5d8a6f71a168c88c9470f952129" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75829b451d464b595a1024dec90085ca0093abce" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请使用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="66d11c99d3b8bf1e2077d0f21b72e0ab032ea87c" translate="yes" xml:space="preserve">
          <source>This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again.</source>
          <target state="translated">这个函数提供了一种更新计数器的方法,不需要查找对象,通过递增元素更新对象,并将得到的对象再次插入表中。</target>
        </trans-unit>
        <trans-unit id="2b70ec5aa36c1075bf590864c6a36436ad975b12" translate="yes" xml:space="preserve">
          <source>This generates a &lt;code&gt;relup&lt;/code&gt; file with instructions for how to upgrade from version &quot;A&quot; (&quot;ch_rel-1&quot;) to version &quot;B&quot; (&quot;ch_rel-2&quot;) and how to downgrade from version &quot;B&quot; to version &quot;A&quot;.</source>
          <target state="translated">这将生成一个 &lt;code&gt;relup&lt;/code&gt; 文件，其中包含有关如何从版本&amp;ldquo; A&amp;rdquo;（&amp;ldquo; ch_rel-1&amp;rdquo;）升级到版本&amp;ldquo; B&amp;rdquo;（&amp;ldquo; ch_rel-2&amp;rdquo;）以及如何从版本&amp;ldquo; B&amp;rdquo;降级到版本&amp;ldquo; A&amp;rdquo;的说明。</target>
        </trans-unit>
        <trans-unit id="c116938db051375fe0e1532d328cb08b14b31015" translate="yes" xml:space="preserve">
          <source>This gives &lt;code&gt;D = 273&lt;/code&gt;, &lt;code&gt;E = 00&lt;/code&gt;, and F binds to a binary of size 1: &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt;.</source>
          <target state="translated">这样得到 &lt;code&gt;D = 273&lt;/code&gt; ， &lt;code&gt;E = 00&lt;/code&gt; ，并且F绑定到大小为1的二进制文件： &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b265622dae76f6ead2d5384e91874a0a56b738" translate="yes" xml:space="preserve">
          <source>This gives a binary of size 4. Here, a &lt;strong&gt;size expression&lt;/strong&gt; is used for the variable &lt;code&gt;C&lt;/code&gt; to specify a 16-bits segment of &lt;code&gt;Bin2&lt;/code&gt;.</source>
          <target state="translated">这给出了大小为4的二进制文件。这里，&lt;strong&gt;大小表达式&lt;/strong&gt;用于变量 &lt;code&gt;C&lt;/code&gt; 来指定 &lt;code&gt;Bin2&lt;/code&gt; 的16位段。</target>
        </trans-unit>
        <trans-unit id="9304ac5067de60ffef75db2d0f27153eea8fd249" translate="yes" xml:space="preserve">
          <source>This gives a set of binary logs, for example:</source>
          <target state="translated">例如,这给出了一组二进制日志。</target>
        </trans-unit>
        <trans-unit id="efb5947a696c40715e3fb71363beaeb5efc4f051" translate="yes" xml:space="preserve">
          <source>This gives an entry for &lt;code&gt;m1&lt;/code&gt; also in the cover log for test run &lt;code&gt;s2&lt;/code&gt;. The problem is that this only reflects the coverage by &lt;code&gt;s2&lt;/code&gt; tests, not the accumulated result over &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;. This is where the cross cover mechanism comes in handy.</source>
          <target state="translated">这在测试运行 &lt;code&gt;s2&lt;/code&gt; 的覆盖日志中也提供了 &lt;code&gt;m1&lt;/code&gt; 的条目。问题在于，这仅反映了 &lt;code&gt;s2&lt;/code&gt; 测试的覆盖率，而不反映 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 上的累积结果。这是横盖机制派上用场的地方。</target>
        </trans-unit>
        <trans-unit id="713b4a71335dbed07b61ab42f009c85295637765" translate="yes" xml:space="preserve">
          <source>This gives no result of length &amp;gt; 0 and we are at the last position, so the global search is complete.</source>
          <target state="translated">这不会给出length&amp;gt; 0的结果，并且我们位于最后一个位置，因此全局搜索已完成。</target>
        </trans-unit>
        <trans-unit id="e365e009b84d303f259288c46a5cf1337ae2825c" translate="yes" xml:space="preserve">
          <source>This gives the list of all elements in L1 that are not contained in L2.</source>
          <target state="translated">这给出了L1中不包含在L2中的所有元素的列表。</target>
        </trans-unit>
        <trans-unit id="79f96c1766aa59b316c1112142e724a0ac8f12f4" translate="yes" xml:space="preserve">
          <source>This gives the same result. &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; is in the guard part and therefore discards anything that does not have an &lt;code&gt;empyear&lt;/code&gt; (bound to &lt;code&gt;'$2'&lt;/code&gt; in the head) less than 2000, as the guard in the &lt;code&gt;foldr/3&lt;/code&gt; example.</source>
          <target state="translated">这给出了相同的结果。 &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; 位于后卫部分，因此丢弃没有 &lt;code&gt;empyear&lt;/code&gt; （在头部绑定到 &lt;code&gt;'$2'&lt;/code&gt; 年）的任何内容，作为 &lt;code&gt;foldr/3&lt;/code&gt; 中的后卫例。</target>
        </trans-unit>
        <trans-unit id="22d1dda5ab8530e1e0b433f6ea95f6b6b7eda6d3" translate="yes" xml:space="preserve">
          <source>This gives two binaries of size 3, with the following evaluations:</source>
          <target state="translated">这样就得到了两个大小为3的二进制,其评价如下。</target>
        </trans-unit>
        <trans-unit id="5bdfea051354f0bf5fa426336e15ae7b72111a2a" translate="yes" xml:space="preserve">
          <source>This grammar can be used to generate a parser which parses list expressions, such as &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; provided that your scanner tokenizes, for example, the input &lt;code&gt;(peter charles)&lt;/code&gt; as follows:</source>
          <target state="translated">此语法可用于生成解析器，用于解析列表表达式，例如 &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; 前提是您的扫描器将其标记为例如，输入 &lt;code&gt;(peter charles)&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="c5c33f8292424d5d8afd6fb208cfbfa703f594e5" translate="yes" xml:space="preserve">
          <source>This handler behaves much like &lt;code&gt;logger_std_h&lt;/code&gt;, except it uses &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; as its destination.</source>
          <target state="translated">该处理程序的行为与 &lt;code&gt;logger_std_h&lt;/code&gt; 相似，不同之处 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 它使用disk_log作为目的地。</target>
        </trans-unit>
        <trans-unit id="dcaca3a309669115a5d10a160b27e110b7d53cd4" translate="yes" xml:space="preserve">
          <source>This handler ignores events that do not originate from the &lt;code&gt;error_logger&lt;/code&gt; API, or from within OTP. This means that if your code uses the Logger API for logging, then your log events will be discarded by this handler.</source>
          <target state="translated">此处理程序将忽略不是源自 &lt;code&gt;error_logger&lt;/code&gt; API或OTP内部的事件。这意味着，如果您的代码使用Logger API进行日志记录，则此处理程序将丢弃您的日志事件。</target>
        </trans-unit>
        <trans-unit id="29807c3684400c3becd59e5edf9ba096157cab01" translate="yes" xml:space="preserve">
          <source>This handler is provided for backwards compatibility only. It is not started by default, but will be automatically started the first time an &lt;code&gt;error_logger&lt;/code&gt; event handler is added with &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供此处理程序仅是为了向后兼容。它默认情况下未启动，但是在第一次使用 &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; 添加 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序时将自动启动。</target>
        </trans-unit>
        <trans-unit id="87e5ec8533eb6addfe606eccdf0a8555b2e81bc0" translate="yes" xml:space="preserve">
          <source>This has the same effect as setting option &lt;code&gt;ucp&lt;/code&gt;: it causes sequences such as \d and \w to use Unicode properties to determine character types, instead of recognizing only characters with codes &amp;lt; 256 through a lookup table.</source>
          <target state="translated">这与设置选项 &lt;code&gt;ucp&lt;/code&gt; 具有相同的效果：它使诸如\ d和\ w之类的序列使用Unicode属性确定字符类型，而不是通过查找表仅识别代码&amp;lt;256的字符。</target>
        </trans-unit>
        <trans-unit id="0c156c0c2fc33946d9fbadad8702601855c80e09" translate="yes" xml:space="preserve">
          <source>This has the same effect as the above, &lt;strong&gt;if and only if&lt;/strong&gt; megaco has sent at least one pending message for this request (during the processing of the request). If no pending message has been sent, then immediate acknowledgement will &lt;strong&gt;not&lt;/strong&gt; be requested.</source>
          <target state="translated">&lt;strong&gt;当且仅当&lt;/strong&gt; megaco为该请求发送了至少一个挂起消息时（在处理请求期间），这具有与上述相同的效果。如果未发送任何待处理消息，则&lt;strong&gt;不会&lt;/strong&gt;请求立即确认。</target>
        </trans-unit>
        <trans-unit id="4ede3cfedbb971a104b9a8ef6799913490ca75be" translate="yes" xml:space="preserve">
          <source>This has the same effect as the following:</source>
          <target state="translated">这与下面的效果是一样的。</target>
        </trans-unit>
        <trans-unit id="e0d90b246b1198d103c86bc16c013de08162e8ce" translate="yes" xml:space="preserve">
          <source>This has the value &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, &lt;code&gt;{file,LogFileName}&lt;/code&gt;, or &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt;.</source>
          <target state="translated">其值为 &lt;code&gt;standard_io&lt;/code&gt; ， &lt;code&gt;standard_error&lt;/code&gt; ， &lt;code&gt;{file,LogFileName}&lt;/code&gt; 或 &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa9ae8726a4cc0244638ba67ad2025c382e5beef" translate="yes" xml:space="preserve">
          <source>This implementation-dependent function increments the reduction counter for the calling process. In the Beam emulator, the reduction counter is normally incremented by one for each function and BIF call. A context switch is forced when the counter reaches the maximum number of reductions for a process (2000 reductions in Erlang/OTP R12B).</source>
          <target state="translated">这个与实现相关的函数为调用过程递增还原计数器。在Beam仿真器中,通常每个函数和BIF调用的还原计数器都会递增一个。当计数器达到一个进程的最大还原数(在Erlang/OTP R12B中为2000个还原数)时,会强制进行上下文切换。</target>
        </trans-unit>
        <trans-unit id="a8d3c24a386f367f78241d2e4bac7b7d69305c8c" translate="yes" xml:space="preserve">
          <source>This implies that for an included application, the set of start phases must be a subset of the set of phases defined for the primary application. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">这意味着对于一个包含的应用程序，开始阶段集必须是为主要应用程序定义的一组阶段集的子集。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60cc03c618eaaba02c392d8b6d5e3541aa6478d4" translate="yes" xml:space="preserve">
          <source>This index is used to separate the implementation of the SNMP ordering from the actual implementation of the table. The SNMP ordering, that is implementation of GET NEXT, is implemented in this module.</source>
          <target state="translated">该索引用于将SNMP排序的实现与表的实际实现分开。SNMP排序,也就是GET NEXT的实现,在本模块中实现。</target>
        </trans-unit>
        <trans-unit id="4da9986920c604b316098093467baaddac2eb487" translate="yes" xml:space="preserve">
          <source>This indicates that the variable &lt;code&gt;File&lt;/code&gt;, which is defined inside the fun, collides with the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside the fun.</source>
          <target state="translated">这表明变量 &lt;code&gt;File&lt;/code&gt; ，它的乐趣中定义的，与可变碰撞 &lt;code&gt;File&lt;/code&gt; ，它的乐趣之外定义。</target>
        </trans-unit>
        <trans-unit id="cfea72aa373ef570cea99287f1170facd64d6eef" translate="yes" xml:space="preserve">
          <source>This inform the user which target addresses the notification was sent to.</source>
          <target state="translated">这将告知用户通知的目标地址是哪个。</target>
        </trans-unit>
        <trans-unit id="0d129bafd72948232df4b45a85096033eb4d3888" translate="yes" xml:space="preserve">
          <source>This information can be invalid for some implementations.</source>
          <target state="translated">这些信息对于某些实现来说可能是无效的。</target>
        </trans-unit>
        <trans-unit id="7aae2c9ba176a7a3f9d606f61a083bbbedd09c9d" translate="yes" xml:space="preserve">
          <source>This information can be produced by the functions &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; but this is a simple way to get it all at once.</source>
          <target state="translated">此信息可以由功能 &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; 生成,但这是一次一次性获取所有信息的简单方法。</target>
        </trans-unit>
        <trans-unit id="710dd978424ecc04fc2bf1003714cbd1fde00ea0" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="61fde3bec5255dca0919656dc9b966cbee0da75a" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="eaf22384b8506971667ec0cacf5790e4084dc39b" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="962a2ecfcacf4f2ae7569863ad3b0745fd8bd9b5" translate="yes" xml:space="preserve">
          <source>This information can be used to traverse the chain of function calls, using the &lt;strong&gt;Up&lt;/strong&gt; and &lt;strong&gt;Down&lt;/strong&gt; buttons in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 中的&amp;ldquo; &lt;strong&gt;向上&amp;rdquo;&lt;/strong&gt;和&amp;ldquo; &lt;strong&gt;向下&amp;rdquo;&lt;/strong&gt;按钮，可以使用此信息遍历函数调用链。</target>
        </trans-unit>
        <trans-unit id="9a325aae80341287a8eab869857564f9b28b86fd" translate="yes" xml:space="preserve">
          <source>This information is used by the release handler during upgrades and downgrades, see &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">版本处理程序在升级和降级期间将使用此信息，请参阅 &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="201452c6ed23592af55381e4e0078166857bb6b2" translate="yes" xml:space="preserve">
          <source>This information is useful when an external entity (for example, an IDE) provides additional code for a running node. If the code server is in interactive mode, it only has to add the path to the code. If the code server is in embedded mode, the code must be loaded with &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当外部实体（例如，IDE）为运行中的节点提供附加代码时，此信息很有用。如果代码服务器处于交互模式，则只需将路径添加到代码。如果代码服务器处于嵌入式模式，则必须使用 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 加载代码。</target>
        </trans-unit>
        <trans-unit id="5a8323563f351cf2bca8245a5765d1e7287f26f8" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address acknowledged the notification.</source>
          <target state="translated">这将通知用户,这个目标地址确认了该通知。</target>
        </trans-unit>
        <trans-unit id="1baf8ed33916a0e4003152e45bbc117558b69aff" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge notification.</source>
          <target state="translated">这将通知用户,这个目标地址没有确认通知。</target>
        </trans-unit>
        <trans-unit id="e9c0fbf4edafb48f201f8b1170f9bfbfe552c23a" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge the notification.</source>
          <target state="translated">这将告知用户,这个目标地址没有确认通知。</target>
        </trans-unit>
        <trans-unit id="083ac1279739f945b13a461e8bb4339d8dfde4a8" translate="yes" xml:space="preserve">
          <source>This informs the user which target addresses the notification was sent to.</source>
          <target state="translated">这将通知用户通知被发送到哪个目标地址。</target>
        </trans-unit>
        <trans-unit id="d7e452d2d7924302fbdea18276d798ae79408dc5" translate="yes" xml:space="preserve">
          <source>This instruction is not related to upgrades of ERTS or any of the core applications. It can be used by any application to force a restart of the emulator after all upgrade instructions are executed.</source>
          <target state="translated">该指令与ERTS或任何核心应用程序的升级无关。任何应用程序都可以使用它来强制在所有升级指令执行后重新启动模拟器。</target>
        </trans-unit>
        <trans-unit id="b27e8eb36b131c032f8c3fba207f37d792a31d2a" translate="yes" xml:space="preserve">
          <source>This instruction is similar to &lt;code&gt;restart_new_emulator&lt;/code&gt;, except it must be placed at the end of the &lt;code&gt;relup&lt;/code&gt; file. It is not related to an upgrade of the emulator or the core applications, but can be used by any application when a complete reboot of the system is required.</source>
          <target state="translated">该指令与 &lt;code&gt;restart_new_emulator&lt;/code&gt; 相似，不同的是它必须放在 &lt;code&gt;relup&lt;/code&gt; 文件的末尾。它与仿真器或核心应用程序的升级无关，但是当需要完全重新引导系统时，任何应用程序都可以使用它。</target>
        </trans-unit>
        <trans-unit id="4e2ff5aadab857bef7cc042cfddbfd7f94365d61" translate="yes" xml:space="preserve">
          <source>This instruction is used when changing to a new emulator version, or when any of the core applications Kernel, STDLIB, or SASL is upgraded. If a system reboot is needed for another reason, the &lt;code&gt;restart_emulator&lt;/code&gt; instruction is to be used instead.</source>
          <target state="translated">当更改为新的仿真器版本时，或者在升级任何核心应用程序内核，STDLIB或SASL时，都使用此指令。如果由于其他原因需要重新引导系统，则将使用 &lt;code&gt;restart_emulator&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="538ffcc030d6ff15bd0bfff773ddaca2d61087a9" translate="yes" xml:space="preserve">
          <source>This instruction is used when the application ERTS, Kernel, STDLIB, or SASL is upgraded. It shuts down the current emulator and starts a new one. All processes are terminated gracefully, and the new version of ERTS, Kernel, STDLIB, and SASL are used when the emulator restarts. Only one &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is allowed in the &lt;code&gt;relup&lt;/code&gt; file, and it must be placed first. &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures this when the &lt;code&gt;relup&lt;/code&gt; file is generated. The rest of the instructions in the &lt;code&gt;relup&lt;/code&gt; file is executed after the restart as a part of the boot script.</source>
          <target state="translated">升级应用程序ERTS，内核，STDLIB或SASL时使用此指令。它关闭当前的模拟器并启动一个新的模拟器。仿真器重新启动后，所有进程都会正常终止，并且将使用新版本的ERTS，内核，STDLIB和SASL。 &lt;code&gt;relup&lt;/code&gt; 文件中只允许使用一个 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令，并且必须将其放在第一位。 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 在生成 &lt;code&gt;relup&lt;/code&gt; 文件时确保这一点。 &lt;code&gt;relup&lt;/code&gt; 文件中的其余指令在重新启动后作为启动脚本的一部分执行。</target>
        </trans-unit>
        <trans-unit id="395215bf28142de440c81ef55b87f4169a80aec6" translate="yes" xml:space="preserve">
          <source>This instruction is written in the configuration file in the following format:</source>
          <target state="translated">该指令以如下格式写入配置文件。</target>
        </trans-unit>
        <trans-unit id="45862ec3de83aecdeb3f0430fc20ad3e86777590" translate="yes" xml:space="preserve">
          <source>This instruction requires that the system is started with heartbeat monitoring, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS and the &lt;code&gt;heart(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">此说明要求系统以心跳监视启动，请参阅ERTS中的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页和内核中的 &lt;code&gt;heart(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="eb9abbefd34b9022f0d676607ac6737850a70742" translate="yes" xml:space="preserve">
          <source>This instruction synchronizes the release installation with other nodes. Each &lt;code&gt;Node&lt;/code&gt; must evaluate this command with the same &lt;code&gt;Id&lt;/code&gt;. The local node waits for all other nodes to evaluate the instruction before execution continues. If a node goes down, it is considered to be an unrecoverable error, and the local node is restarted from the old release. There is no time-out for this instruction, which means that it can hang forever.</source>
          <target state="translated">该指令将发布安装与其他节点同步。每个 &lt;code&gt;Node&lt;/code&gt; 必须使用相同的 &lt;code&gt;Id&lt;/code&gt; 评估此命令。本地节点在执行继续之前等待所有其他节点评估指令。如果节点发生故障，则认为这是不可恢复的错误，并且本地节点将从旧版本重新启动。该指令没有超时，这意味着它可以永远挂起。</target>
        </trans-unit>
        <trans-unit id="72381508b412cca34ddf14083712fc31b9f93e31" translate="yes" xml:space="preserve">
          <source>This interface (or at least the name of the functions) is kept for backward compatibility. Using &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; in the option list gives the same effect regarding the port killing.</source>
          <target state="translated">保留此接口（或至少是函数名称）是为了向后兼容。使用 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; 选项列表中给出了关于港口杀灭效果相同。</target>
        </trans-unit>
        <trans-unit id="986a779296a267e9889a055a42330bfd68321abf" translate="yes" xml:space="preserve">
          <source>This internal event is used by the &lt;code&gt;Common Test&lt;/code&gt; Master process to synchronize particular file operations.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master进程使用此内部事件来同步特定的文件操作。</target>
        </trans-unit>
        <trans-unit id="c34c80ee3e756933a25868fd55ba9046da3c1c47" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; is finished compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">此内部事件表示 &lt;code&gt;Common Test&lt;/code&gt; 已完成目录 &lt;code&gt;Dir&lt;/code&gt; 中的模块编译。</target>
        </trans-unit>
        <trans-unit id="19fd863c53f0cce4ca256baeac321a61b8c0e924" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; starts compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">此内部事件表明 &lt;code&gt;Common Test&lt;/code&gt; 开始在目录 &lt;code&gt;Dir&lt;/code&gt; 中编译模块。</target>
        </trans-unit>
        <trans-unit id="918379111cbe178fe4429e0dda42e1bb45186e43" translate="yes" xml:space="preserve">
          <source>This internal name cannot be changed, it is fixed even if the service is renamed. &lt;code&gt;erlsrv&lt;/code&gt; generates a unique internal name when a service is created. It is recommended to keep to the default if release handling is to be used for the application.</source>
          <target state="translated">此内部名称无法更改，即使重命名服务也已固定。创建服务时， &lt;code&gt;erlsrv&lt;/code&gt; 会生成一个唯一的内部名称。如果要对应用程序使用发布处理，建议保持默认值。</target>
        </trans-unit>
        <trans-unit id="1c853aa37495f77100d3057f3fa259e2e5e59b2e" translate="yes" xml:space="preserve">
          <source>This is 86 % of the total run time, and as we saw before it is the close operation the absolutely biggest contributor. We find a comparison ratio a little bit up in the call stack:</source>
          <target state="translated">这占了总运行时间的86%,正如我们之前所看到的,这是接近操作的绝对最大贡献者。我们在调用堆栈中找到一个比较比例,在上面一点。</target>
        </trans-unit>
        <trans-unit id="e9ef9e4644f03eaf56584c4a5bfb4c37698548ad" translate="yes" xml:space="preserve">
          <source>This is a 4-component structure called &lt;code&gt;Pdu&lt;/code&gt;. By default, a &lt;code&gt;SEQUENCE&lt;/code&gt; is represented by a record in Erlang. It can also be represented as a map; see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt;. For each &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; in an ASN.1 module an Erlang record declaration is generated. For &lt;code&gt;Pdu&lt;/code&gt;, a record like the following is defined:</source>
          <target state="translated">这是一个称为 &lt;code&gt;Pdu&lt;/code&gt; 的4组件结构。默认情况下， &lt;code&gt;SEQUENCE&lt;/code&gt; 由Erlang中的记录表示。它也可以表示为地图。请参见 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 。对于ASN.1模块中的每个 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; ，都会生成一个Erlang记录声明。对于 &lt;code&gt;Pdu&lt;/code&gt; ，定义了以下记录：</target>
        </trans-unit>
        <trans-unit id="fccf5d389b6bb13934731f8a21547b98c0616cd1" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; time, but &lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; time. That is, consecutive calls to &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; can produce the same result.</source>
          <target state="translated">这是一个 &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; 时间，但&lt;strong&gt;没有&lt;/strong&gt;一个 &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 的时间。也就是说，连续调用 &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; 可以产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="3e773a13c08b29bd1b0b27e610e6a3ca5907aef0" translate="yes" xml:space="preserve">
          <source>This is a callback function intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">这是一个回调函数,目的是当一些传输模块收到收到的消息时调用。实际使用哪种传输方式由用户自行选择。</target>
        </trans-unit>
        <trans-unit id="6aaabdad85afb5297ef14e644ed60c642bdf1f64" translate="yes" xml:space="preserve">
          <source>This is a change from signed to unsigned. This can cause problems for, for example, loop termination conditions and error conditions if you only change the types all over the place.</source>
          <target state="translated">这是从有符号到无符号的变化。这可能会导致一些问题,例如,如果你只把类型改来改去,就会出现循环终止条件和错误条件。</target>
        </trans-unit>
        <trans-unit id="3196a6c5d44daf25b6d6681360eca21c5be5b270" translate="yes" xml:space="preserve">
          <source>This is a common error in test suites. It is assumed that the current directory is the same as the author used as current directory when the test case was developed. Many test cases even try to write scratch files to this directory. Instead &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt; are to be used to locate data and for writing scratch files.</source>
          <target state="translated">这是测试套件中的常见错误。假定当前目录与开发测试用例时用作当前目录的作者相同。许多测试用例甚至尝试将暂存文件写入此目录。而是使用 &lt;code&gt;data_dir&lt;/code&gt; 和 &lt;code&gt;priv_dir&lt;/code&gt; 来定位数据和写入暂存文件。</target>
        </trans-unit>
        <trans-unit id="360f48fae93411aaa84a534df910e9385d6dd358" translate="yes" xml:space="preserve">
          <source>This is a corrected version of the previous default algorithm, that now has been superseded by Xoroshiro116+ (&lt;code&gt;exrop&lt;/code&gt;). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &amp;lt; 15%) faster than &lt;code&gt;exrop&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是先前默认算法的更正版本，现已被Xoroshiro116 +（ &lt;code&gt;exrop&lt;/code&gt; ）取代。由于没有本地58位循环指令，因此该算法的执行速度比 &lt;code&gt;exrop&lt;/code&gt; 快（例如，&amp;lt;15％）。请参阅 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7aa23baa63f4887daf2bf3feb0b72e5a926fef" translate="yes" xml:space="preserve">
          <source>This is a dangerous feature that must be used with care. By unintentional mixing of directories, you can easily end up with an inconsistent database, if the same backup is installed on more than one directory.</source>
          <target state="translated">这是一个危险的功能,必须谨慎使用。通过无意中混合目录,如果在多个目录上安装了相同的备份,则很容易导致数据库不一致。</target>
        </trans-unit>
        <trans-unit id="00205e610ec0a95f3eebcf63dbbba8372b336cc5" translate="yes" xml:space="preserve">
          <source>This is a handler for Logger that offers circular (wrapped) logs by using &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt;. Multiple instances of this handler can be added to Logger, and each instance prints to its own disk log file, created with the name and settings specified in the handler configuration.</source>
          <target state="translated">这是Logger的处理程序，它通过使用 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 提供循环（包装）日志。可以将该处理程序的多个实例添加到Logger，并且每个实例均打印到其自己的磁盘日志文件，该文件使用在处理程序配置中指定的名称和设置创建。</target>
        </trans-unit>
        <trans-unit id="f1702c7d8fabc70bf82459bbec9093c02074634c" translate="yes" xml:space="preserve">
          <source>This is a large reference document. For casual use of this module, and for most real world applications, the descriptions of functions &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; are enough to getting started.</source>
          <target state="translated">这是一个很大的参考文件。对于该模块的随意使用以及在大多数实际应用中，函数 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; 的描述足以入门。</target>
        </trans-unit>
        <trans-unit id="bfe64ae08d8239e916a24e614514fb557dd71251" translate="yes" xml:space="preserve">
          <source>This is a normal Erlang/OTP application descriptor, as found in an &lt;code&gt;.app&lt;/code&gt; file. The resulting test set consists of the modules listed in the &lt;code&gt;modules&lt;/code&gt; entry in &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">这是一个普通的Erlang / OTP应用程序描述符，可以在 &lt;code&gt;.app&lt;/code&gt; 文件中找到。生成的测试集由 &lt;code&gt;Info&lt;/code&gt; 的 &lt;code&gt;modules&lt;/code&gt; 条目中列出的模块组成。</target>
        </trans-unit>
        <trans-unit id="cc0886c68b7d31b43eac50f2f501f0e29c21db91" translate="yes" xml:space="preserve">
          <source>This is a normal, healthy, return value if the call was just placed to inform the emulator that you have no further use of the driver. It is the most common return value in the most common &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; described in the introduction.</source>
          <target state="translated">如果只是为了告知仿真器您不再使用驱动程序而进行了调用，则这是一个正常的，健康的返回值。在引言中介绍的最常见的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; 它是最常见的返回值。</target>
        </trans-unit>
        <trans-unit id="a74b91a12c8bd155dd6272fb26f51914a5b6669f" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan one token from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan a token or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;token()&lt;/code&gt; with more characters to try an scan the token. This is continued until a token has been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">这是一个重入呼叫，尝试从 &lt;code&gt;Chars&lt;/code&gt; 扫描一个令牌。如果 &lt;code&gt;Chars&lt;/code&gt; 中有足够的字符可以扫描令牌或检测到错误，则将返回 &lt;code&gt;{done,...}&lt;/code&gt; 。否则 &lt;code&gt;{cont,Cont}&lt;/code&gt; 将返回{cont，Cont}，其中在下一次对 &lt;code&gt;token()&lt;/code&gt; 的调用中使用 &lt;code&gt;Cont&lt;/code&gt; 时,将使用更多字符尝试扫描令牌。继续进行直到扫描了令牌为止。 &lt;code&gt;Cont&lt;/code&gt; 最初是 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd5f47604323fa85263c477df2f49651a6e3df8c" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan tokens from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan tokens or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;tokens()&lt;/code&gt; with more characters to try an scan the tokens. This is continued until all tokens have been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">这是重入呼叫，以尝试从 &lt;code&gt;Chars&lt;/code&gt; 扫描令牌。如果 &lt;code&gt;Chars&lt;/code&gt; 中有足够的字符来扫描令牌或检测到错误，则将返回 &lt;code&gt;{done,...}&lt;/code&gt; 。否则 &lt;code&gt;{cont,Cont}&lt;/code&gt; 将返回{cont，Cont}，其中在下一次对 &lt;code&gt;tokens()&lt;/code&gt; 的调用中使用 &lt;code&gt;Cont&lt;/code&gt; 时，使用更多字符尝试扫描令牌。继续进行直到所有令牌都被扫描为止。 &lt;code&gt;Cont&lt;/code&gt; 最初是 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed7d83881b92d8f8849b160af3bcd9a10b096707" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;report_errors&lt;/code&gt; 和 &lt;code&gt;report_warnings&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="274dc8f24a407d0b1cda6dac95a4fedcd1f99a11" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;return_errors&lt;/code&gt; 和 &lt;code&gt;return_warnings&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="b415593166c4a9ddd5fa9eb4f27a156aba749468" translate="yes" xml:space="preserve">
          <source>This is a simple example of starting the TFTP server and reading the content of a sample file using the TFTP client.</source>
          <target state="translated">这是一个启动TFTP服务器并使用TFTP客户端读取样本文件内容的简单例子。</target>
        </trans-unit>
        <trans-unit id="808da979a84710e3348d8f0999feea04935b391f" translate="yes" xml:space="preserve">
          <source>This is a slight modification of the ping pong program where both processes are spawned from the same &lt;code&gt;start/1&lt;/code&gt; function, and the &quot;ping&quot; process can be spawned on a separate node. Notice the use of the &lt;code&gt;link&lt;/code&gt; BIF. &quot;Ping&quot; calls &lt;code&gt;exit(ping)&lt;/code&gt; when it finishes and this causes an exit signal to be sent to &quot;pong&quot;, which also terminates.</source>
          <target state="translated">这是对乒乓程序的略微修改，其中两个进程都从相同的 &lt;code&gt;start/1&lt;/code&gt; 函数生成，并且&amp;ldquo; ping&amp;rdquo;进程可以在单独的节点上生成。注意 &lt;code&gt;link&lt;/code&gt; BIF 的使用。&amp;ldquo; Ping&amp;rdquo; 完成时会调用 &lt;code&gt;exit(ping)&lt;/code&gt; ，这会导致将退出信号发送到&amp;ldquo; pong&amp;rdquo;，后者也会终止。</target>
        </trans-unit>
        <trans-unit id="73a9a1cddaa9852a0011d5e8ce12699ed0d05497" translate="yes" xml:space="preserve">
          <source>This is a so-called Erlang I/O ErrorInfo structure; see the &lt;code&gt;io(3)&lt;/code&gt; module for details.</source>
          <target state="translated">这就是所谓的Erlang I / O ErrorInfo结构。有关详细信息，请参见 &lt;code&gt;io(3)&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="e343f368517e25b67cf5e58932e33d7c4ed349a4" translate="yes" xml:space="preserve">
          <source>This is a standard macro (that is, defined by the system, not by the user). &lt;code&gt;?MODULE&lt;/code&gt; is always replaced by the name of the current module (that is, the &lt;code&gt;-module&lt;/code&gt; definition near the start of the file). There are more advanced ways of using macros with, for example, parameters (*manual*).</source>
          <target state="translated">这是一个标准宏（即由系统而不是由用户定义）。 &lt;code&gt;?MODULE&lt;/code&gt; 始终替换为当前模块的名称（即，文件开头附近的 &lt;code&gt;-module&lt;/code&gt; 定义）。有使用参数等宏的更高级方法，例如，参数（* manual *）。</target>
        </trans-unit>
        <trans-unit id="69b7150a1e2635ac10627a958161be921d3a386e" translate="yes" xml:space="preserve">
          <source>This is a statistics event with current count of successful, skipped, and failed test cases so far. This event is sent after the end of each test case, immediately following event &lt;code&gt;tc_done&lt;/code&gt;.</source>
          <target state="translated">这是一个统计事件，到目前为止，当前有成功，跳过和失败的测试用例计数。在每个测试用例结束后，紧随事件 &lt;code&gt;tc_done&lt;/code&gt; 之后发送此事件。</target>
        </trans-unit>
        <trans-unit id="398909e587f906e89bc126a8eb8fdfd6b8204296" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated &lt;code&gt;select/2&lt;/code&gt; calls.</source>
          <target state="translated">这是一个有用的调试和测试工具，尤其是在编写复杂的 &lt;code&gt;select/2&lt;/code&gt; 调用时。</target>
        </trans-unit>
        <trans-unit id="ef77778e97bbcd3de76e5cb922449c0969559f39" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated match specifications.</source>
          <target state="translated">这是一个有用的调试和测试工具,特别是在编写复杂的匹配规格时。</target>
        </trans-unit>
        <trans-unit id="cc0b0332cdc379fcfaab7b7f81af77dfd65580d0" translate="yes" xml:space="preserve">
          <source>This is a useful way to test a generated boot script locally.</source>
          <target state="translated">这是一个测试本地生成的启动脚本的有用方法。</target>
        </trans-unit>
        <trans-unit id="8c1d072ab39ba63d2cf9e54937425fb41a6e24e0" translate="yes" xml:space="preserve">
          <source>This is a utility function used to inspect, for instance, memory usage, in a simple way.</source>
          <target state="translated">这是一个用于检查内存使用情况的实用函数,例如,以简单的方式。</target>
        </trans-unit>
        <trans-unit id="1e82946d829123c6910c06194e9e7cebf010cb22" translate="yes" xml:space="preserve">
          <source>This is a utility function, that can be useful when e.g. debugging instrumentation functions.</source>
          <target state="translated">这是一个实用函数,在调试仪器功能时很有用。</target>
        </trans-unit>
        <trans-unit id="638f44b006e9ddc55b07c2ecf8dd004cd4e662bc" translate="yes" xml:space="preserve">
          <source>This is a utility function; see &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; for further details.</source>
          <target state="translated">这是一个实用程序功能；有关更多详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4ecf4af35ccbc508f0f2a3b4017f2147f96a8d" translate="yes" xml:space="preserve">
          <source>This is accomplished as follows:</source>
          <target state="translated">具体做法如下:</target>
        </trans-unit>
        <trans-unit id="1661232769f6d1b51ba5b2ab390488adc40b1764" translate="yes" xml:space="preserve">
          <source>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt;. Information about thread primitives is provided below.</source>
          <target state="translated">这是通过将工作分配给NIF库管理的另一个线程，从NIF返回并等待结果来完成的。线程可以使用 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 将结果发送回Erlang进程。下面提供了有关线程基元的信息。</target>
        </trans-unit>
        <trans-unit id="a3a5884eaf41dfb2c20bb095d899f4bb1aee0421" translate="yes" xml:space="preserve">
          <source>This is all that has to be done! Now the manager can read, add, and modify rows. Also, you can use the ordinary Mnesia API to access the table from your programs. The only explicit action is to create the Mnesia table, an action the user has to perform in order to create the required table schemas.</source>
          <target state="translated">这就是所有要做的事情! 现在经理可以读取、添加和修改行。同时,你可以使用普通的Mnesia API从你的程序中访问表。唯一显式的操作是创建Mnesia表,用户必须执行这个操作才能创建所需的表模式。</target>
        </trans-unit>
        <trans-unit id="2b23a1bbf224deed4021f7affe8851472e761554" translate="yes" xml:space="preserve">
          <source>This is allowed in ASN.1 and the ASN.1-to-Erlang compiler supports this recursive type. A value for this type is assigned in Erlang as follows:</source>
          <target state="translated">这在ASN.1中是允许的,ASN.1-to-Erlang编译器支持这个递归类型。这个类型的值在Erlang中分配如下。</target>
        </trans-unit>
        <trans-unit id="b9c60488fe7be932bfbb686280514f6095ca5c3b" translate="yes" xml:space="preserve">
          <source>This is also handled automatically by the megaco application. First of all, segmentation is only attempted if so configured, see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; option. Secondly, megaco relies on the ability of the used codec to encode action replies, which is the smallest component the megaco application handles when segmenting. Thirdly, the reply will be segmented only if the sum of the size of the action replies (plus an arbitrary message header size) are greater then the specified max message size (see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; option). Finally, if segmentation is decided, then each action reply will make up its own (segment) message.</source>
          <target state="translated">megaco应用程序也会自动处理此问题。首先，仅在进行了分段配置后才尝试分段，请参见 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; 选项。其次，megaco依赖于所使用的编解码器对动作回复进行编码的能力，这是megaco应用程序进行分段时处理的最小组件。第三，仅当动作答复的大小之和（加上任意的消息头大小）大于指定的最大消息大小（请参见 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; 选项）时，才对答复进行分段。最后，如果确定了分段，则每个操作答复将组成其自己的（分段）消息。</target>
        </trans-unit>
        <trans-unit id="c22b40b578529e2c84690ed6b337febcebea2978" translate="yes" xml:space="preserve">
          <source>This is also the case for functions &lt;code&gt;red/2&lt;/code&gt;, &lt;code&gt;blue/2&lt;/code&gt;, and &lt;code&gt;green/2&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;red/2&lt;/code&gt; ， &lt;code&gt;blue/2&lt;/code&gt; 和 &lt;code&gt;green/2&lt;/code&gt; 也是这种情况。</target>
        </trans-unit>
        <trans-unit id="66cae3829517c0c1511c6c613a5e64f898384f8a" translate="yes" xml:space="preserve">
          <source>This is an abstract representation of syntax tree node attributes; see the function &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是语法树节点属性的抽象表示。参见功能 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2128cfc6cbe9e874c7e25ecf50f44f2ff9c59c9d" translate="yes" xml:space="preserve">
          <source>This is an enhancement of &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. It gives the possibility to:</source>
          <target state="translated">这是对 &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 的增强。它使可能性：</target>
        </trans-unit>
        <trans-unit id="bb4355c46a241b6ccaa141fa3ca19310a4e18377" translate="yes" xml:space="preserve">
          <source>This is an example of an &quot;atomic group&quot;, details are provided below.</source>
          <target state="translated">这是一个 &quot;原子组 &quot;的例子,详情见下文。</target>
        </trans-unit>
        <trans-unit id="7cdd0e3d179b7cbbf8f37996643142fe64dc77b4" translate="yes" xml:space="preserve">
          <source>This is an intentionally rough guide to the relative costs of different calls. It is based on benchmark figures run on Solaris/Sparc:</source>
          <target state="translated">这是对不同呼叫的相对成本的一个有意的粗略指导。它是根据在Solaris/Sparc上运行的基准数字得出的。</target>
        </trans-unit>
        <trans-unit id="f4c4ab4d5f5e4f366b3c529f50a5c1512948dcaf" translate="yes" xml:space="preserve">
          <source>This is an interface module for the Reltool application.</source>
          <target state="translated">这是一个Reltool应用的接口模块。</target>
        </trans-unit>
        <trans-unit id="03e3358ac9f51a5518985ca7ba361683826cf828" translate="yes" xml:space="preserve">
          <source>This is an opaque data type that identifies a monitor.</source>
          <target state="translated">这是一种不透明的数据类型,用于标识显示器。</target>
        </trans-unit>
        <trans-unit id="26ef7d5997459d409e40c1dbe84146420ac9b4f9" translate="yes" xml:space="preserve">
          <source>This is any extra info the user wants to have supplied when the functions in the callback module is called.</source>
          <target state="translated">这是当回调模块中的函数被调用时,用户希望提供的任何额外信息。</target>
        </trans-unit>
        <trans-unit id="08a7da6db995a217d09a30c00205bf365c46e13e" translate="yes" xml:space="preserve">
          <source>This is as of Erlang/OTP 17.0 the default. It forces any floats in the term to be encoded in a more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to a textual representation). As from Erlang/OTP R11B-4, &lt;code&gt;binary_to_term/1&lt;/code&gt; can decode this representation.</source>
          <target state="translated">这是默认的Erlang / OTP 17.0版本。它将强制以更节省空间和更精确的方式（即采用64位IEEE格式，而不是转换为文本表示形式）对术语中的所有浮点进行编码。从Erlang / OTP R11B-4起， &lt;code&gt;binary_to_term/1&lt;/code&gt; 可以解码此表示形式。</target>
        </trans-unit>
        <trans-unit id="113749aad29dc1cdbedc3b815e734a581ecdd057" translate="yes" xml:space="preserve">
          <source>This is bad luck, the process was garbage collecting when the crash dump was written. The rest of the information for this process is limited.</source>
          <target state="translated">这下可倒霉了,写崩溃转储的时候,这个进程正在收集垃圾。这个过程的其他信息是有限的。</target>
        </trans-unit>
        <trans-unit id="2b06c013992850341fe5a82bf55411c7f74bcdc5" translate="yes" xml:space="preserve">
          <source>This is because record definitions are only available at compile time, not at runtime. For details on records in the shell, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">这是因为记录定义仅在编译时可用，而在运行时不可用。有关shell中记录的详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="8afd6050f97c61cdb32e6c96ba6b457c161482c6" translate="yes" xml:space="preserve">
          <source>This is called &lt;strong&gt;synchronized code replacement&lt;/strong&gt; and for this the following instructions are used:</source>
          <target state="translated">这称为&lt;strong&gt;同步代码替换&lt;/strong&gt;，为此使用以下说明：</target>
        </trans-unit>
        <trans-unit id="646259e147d9a776464db65bc4bea0ac6f13d14c" translate="yes" xml:space="preserve">
          <source>This is done by adding or deleting the &lt;code&gt;error_logger_file_h&lt;/code&gt; event handler, and thus indirectly adding &lt;code&gt;error_logger&lt;/code&gt; as a Logger handler.</source>
          <target state="translated">通过添加或删除 &lt;code&gt;error_logger_file_h&lt;/code&gt; 事件处理程序，然后间接将 &lt;code&gt;error_logger&lt;/code&gt; 添加为Logger处理程序来完成此操作。</target>
        </trans-unit>
        <trans-unit id="681acf8836c69537b79e14e48dcac39812f986dc" translate="yes" xml:space="preserve">
          <source>This is done by manipulating the Logger configuration. The function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">这可以通过操作Logger配置来完成。该功能在开发和测试期间可用作快捷方式，但不得在生产系统中使用。有关如何为实时系统配置Logger的信息，请参见《内核用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 部分和 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="180abcd23e113c6f5993e0e4b65009873a53afdd" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, &lt;code&gt;Return&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. &lt;code&gt;Config&lt;/code&gt; in this case is the same &lt;code&gt;Config&lt;/code&gt; as the testcase is called with. &lt;code&gt;Return&lt;/code&gt; is the value returned by the testcase. If the testcase fails by crashing, &lt;code&gt;Return&lt;/code&gt; is &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt;.</source>
          <target state="translated">这在称为 &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt; 的CTH函数中完成。这些函数采用 &lt;code&gt;SuiteName&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; （组或测试用例名称，如果适用）， &lt;code&gt;Config&lt;/code&gt; ， &lt;code&gt;Return&lt;/code&gt; 和 &lt;code&gt;CTHState&lt;/code&gt; 作为参数。 &lt;code&gt;Config&lt;/code&gt; 在这种情况下，相同 &lt;code&gt;Config&lt;/code&gt; 的测试用例被调用。 &lt;code&gt;Return&lt;/code&gt; 是测试用例返回的值。如果测试用例因崩溃而失败，则 &lt;code&gt;Return&lt;/code&gt; 为 &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ab57d9407d3cc2fec5c4c069b356365d21838b" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;.</source>
          <target state="translated">这在称为 &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt; 的CTH函数中完成。这些函数采用 &lt;code&gt;SuiteName&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; （组或测试用例的名称，如果适用）， &lt;code&gt;Config&lt;/code&gt; 和 &lt;code&gt;CTHState&lt;/code&gt; 作为参数。CTH函数的返回值始终是套件/组/测试的结果与更新的 &lt;code&gt;CTHState&lt;/code&gt; 的组合。</target>
        </trans-unit>
        <trans-unit id="bfd349ddda4246be97d235609d023e3a44aa81a6" translate="yes" xml:space="preserve">
          <source>This is done until the end of the list is reached, that is, the list is empty:</source>
          <target state="translated">直到到达列表的末端,即列表为空。</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">这相当于</target>
        </trans-unit>
        <trans-unit id="d11de2ea50c52f849f3bde4848fccd123f17645d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">这等效于 &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="5c2e34b39e7cb8fbbca41e01630396e57161f9bd" translate="yes" xml:space="preserve">
          <source>This is equivalent to a call to:</source>
          <target state="translated">这相当于呼吁:</target>
        </trans-unit>
        <trans-unit id="b89997f1aaabac9326c311cc6347ce9ddb0e3b91" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt;:</source>
          <target state="translated">这等效于调用 &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b99c8c34be448e6bbcfec89b94bf9160fbaeb4a" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt;:</source>
          <target state="translated">这等效于调用 &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="97a7c564e0e141ccb4b750a31aa63ab870cbb904" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following specification:</source>
          <target state="translated">这相当于下面的规范。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="4b93967cb769ce4a169bcbd657ff004f71b25464" translate="yes" xml:space="preserve">
          <source>This is expanded to:</source>
          <target state="translated">这扩大到:</target>
        </trans-unit>
        <trans-unit id="732ce2a7a4465b34c1eb7162718b1da76d4ed1e9" translate="yes" xml:space="preserve">
          <source>This is experimental code that can be changed or removed anytime without any warning.</source>
          <target state="translated">这是实验性的代码,可以随时更改或删除,没有任何警告。</target>
        </trans-unit>
        <trans-unit id="1093a321a621a1d24d25a283757e5229ec776381" translate="yes" xml:space="preserve">
          <source>This is followed by a call to &lt;code&gt;open/4&lt;/code&gt; before any read/write access is performed. &lt;code&gt;AcceptedOptions&lt;/code&gt; is sent to the server, which replies with the options that it accepts. These are then forwarded to &lt;code&gt;open/4&lt;/code&gt; as &lt;code&gt;SuggestedOptions&lt;/code&gt;.</source>
          <target state="translated">在执行任何读/写访问之前，随后调用 &lt;code&gt;open/4&lt;/code&gt; 。 &lt;code&gt;AcceptedOptions&lt;/code&gt; 被发送到服务器，服务器以其接受的选项进行回复。然后将它们作为 &lt;code&gt;SuggestedOptions&lt;/code&gt; 转发到 &lt;code&gt;open/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef43207effbfa0c4bc3102645253272383b860ee" translate="yes" xml:space="preserve">
          <source>This is handled automatically by the megaco application. There is however one thing that need to be configured by the user, the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">这是由megaco应用程序自动处理的。但是，用户需要配置一件事情， &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="29f190ed43ce30d7d9b9d196be4fa299d1c36697" translate="yes" xml:space="preserve">
          <source>This is if it is used in the context of the match operator as in the example.</source>
          <target state="translated">如果它是在匹配操作符的上下文中使用的,如本例。</target>
        </trans-unit>
        <trans-unit id="7b6a3bc9957c826c254223da8d53ebcc53f4e171" translate="yes" xml:space="preserve">
          <source>This is illustrated in the following table:</source>
          <target state="translated">下表说明了这一点。</target>
        </trans-unit>
        <trans-unit id="3a9346a5e9e0ffd489af06c1ad2635ffc6b9ae2c" translate="yes" xml:space="preserve">
          <source>This is implementattion depended. That is, it depends on the module. For each module a specific set of options are valid. For the module provided with the app, these options are supported:</source>
          <target state="translated">这是实现上的依赖。也就是说,它取决于模块。对于每个模块,都有一组特定的选项是有效的。对于应用程序提供的模块,这些选项都是支持的。</target>
        </trans-unit>
        <trans-unit id="114d08a8e002db6d0c9182141940ed632dd9d634" translate="yes" xml:space="preserve">
          <source>This is in effect a progress report.</source>
          <target state="translated">这实际上是一份进度报告。</target>
        </trans-unit>
        <trans-unit id="a159e1612a81f8d86b525155c551f0929580069d" translate="yes" xml:space="preserve">
          <source>This is no longer the case. If you require &lt;code&gt;'undefined'&lt;/code&gt; in your record field type, you must explicitly add it to the typespec, as in the 2nd example.</source>
          <target state="translated">这已不再是这种情况。如果在记录字段类型中需要 &lt;code&gt;'undefined'&lt;/code&gt; ，则必须像第二个示例一样将其显式添加到typespec中。</target>
        </trans-unit>
        <trans-unit id="33403ecb7959eebc92f2663aeded4a8c6c3bee94" translate="yes" xml:space="preserve">
          <source>This is normally a wise decision, but it can be disastrous if the nodes have been disconnected because of a communication failure, as the &lt;code&gt;Mnesia&lt;/code&gt; normal table load mechanism does not cope with communication failures.</source>
          <target state="translated">这通常是明智的决定，但是如果节点由于通信故障而断开连接，则可能会造成灾难性的后果，因为 &lt;code&gt;Mnesia&lt;/code&gt; 普通表加载机制无法应对通信故障。</target>
        </trans-unit>
        <trans-unit id="868d49c485867e5bfe4e2b7dfc7ac02d90106823" translate="yes" xml:space="preserve">
          <source>This is normally the default &lt;code&gt;malloc&lt;/code&gt; implementation used on the specific OS.</source>
          <target state="translated">通常，这是特定OS上使用的默认 &lt;code&gt;malloc&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="9dde21bfce3c688dc390548f3494e7bf552bd9fc" translate="yes" xml:space="preserve">
          <source>This is not a full-fledged resolver, only a DNS client that relies on asking trusted recursive name servers.</source>
          <target state="translated">这不是一个成熟的解析器,只是一个依靠询问可信递归名称服务器的DNS客户端。</target>
        </trans-unit>
        <trans-unit id="836326e8e7b02322f5679431a9ac0cf2a7bdaf26" translate="yes" xml:space="preserve">
          <source>This is not a proper Unicode representation, but the representation used for characters before the Unicode standard. It can still be used to represent character code points in the Unicode standard with numbers &amp;lt; 256, which exactly corresponds to the ISO Latin-1 character set. In Erlang, this is commonly denoted &lt;code&gt;latin1&lt;/code&gt; encoding, which is slightly misleading as ISO Latin-1 is a character code range, not an encoding.</source>
          <target state="translated">这不是正确的Unicode表示形式，而是用于Unicode标准之前的字符的表示形式。在Unicode标准中，它仍然可以用来表示数字&amp;lt;256的字符代码点，该数字完全对应于ISO Latin-1字符集。在Erlang中，通常将其表示为 &lt;code&gt;latin1&lt;/code&gt; 编码，由于ISO Latin-1是字符代码范围而不是编码，因此会稍有误导。</target>
        </trans-unit>
        <trans-unit id="2c58e7e1b5e3d20a4fa526ed7b8e2cfc77c34073" translate="yes" xml:space="preserve">
          <source>This is not entirely safe, as it is vulnerable against takeover attacks, but it is a tradeoff between fair safety and performance.</source>
          <target state="translated">这并不是完全安全的,因为它容易受到接管攻击,但这是公平安全和性能之间的权衡。</target>
        </trans-unit>
        <trans-unit id="43d40b61a5fa7c9dc787ea193a5ed313e523277b" translate="yes" xml:space="preserve">
          <source>This is not important if you do not postpone events. But if you later decide to start postponing some events, then the design flaw of not having separate states when they should be, might become a hard to find bug.</source>
          <target state="translated">如果你不推迟事件,这并不重要。但如果你后来决定开始推迟一些事件,那么该有的时候没有单独的状态的设计缺陷,可能会成为一个很难发现的bug。</target>
        </trans-unit>
        <trans-unit id="65f78e9c138cff8dcc48b10d2119a79c6c5f383e" translate="yes" xml:space="preserve">
          <source>This is not the wanted result. To achieve the desired effect, &lt;code&gt;select&lt;/code&gt; must be written as follows:</source>
          <target state="translated">这不是想要的结果。为了达到理想的效果， &lt;code&gt;select&lt;/code&gt; 必须编写如下：</target>
        </trans-unit>
        <trans-unit id="b7f69a6080f0d1385f2abcc049f00ad9be5341c1" translate="yes" xml:space="preserve">
          <source>This is perhaps the most central module in the entirety of the &lt;code&gt;et&lt;/code&gt; suite. The &lt;code&gt;Collector&lt;/code&gt; needs &quot;filters&quot; to convert the &lt;code&gt;Raw Trace Data&lt;/code&gt; into &quot;events&quot; that it can display. The &lt;code&gt;et_selector&lt;/code&gt; module provides the default &lt;code&gt;Filter&lt;/code&gt; and some API calls to manage the &lt;code&gt;Trace Pattern&lt;/code&gt;. The &lt;code&gt;Selector&lt;/code&gt; provides various functions that achieve the following:</source>
          <target state="translated">这也许是整个 &lt;code&gt;et&lt;/code&gt; 套件中最核心的模块。该 &lt;code&gt;Collector&lt;/code&gt; 需要&amp;ldquo;过滤器&amp;rdquo;的转换 &lt;code&gt;Raw Trace Data&lt;/code&gt; 为&amp;ldquo;事件&amp;rdquo;，它可以显示。该 &lt;code&gt;et_selector&lt;/code&gt; 模块提供的默认 &lt;code&gt;Filter&lt;/code&gt; 以及一些API调用来管理 &lt;code&gt;Trace Pattern&lt;/code&gt; 。该 &lt;code&gt;Selector&lt;/code&gt; 提供了实现以下多种功能：</target>
        </trans-unit>
        <trans-unit id="bd78b41da72f8f6a1b1b335bee4881061346e4af" translate="yes" xml:space="preserve">
          <source>This is possibly a little clearer.</source>
          <target state="translated">这一点可能比较清楚。</target>
        </trans-unit>
        <trans-unit id="7063cc576e9b11f727c2ae0cabc7e8bc7b76b64e" translate="yes" xml:space="preserve">
          <source>This is primarily a way to show the effects of using the reentrant flex scanner instead of the non-reentrant.</source>
          <target state="translated">这主要是为了展示使用再入式柔性扫描仪而非再入式的效果。</target>
        </trans-unit>
        <trans-unit id="7f43cbca3b6fcf016e7da8036914af019823f1d9" translate="yes" xml:space="preserve">
          <source>This is read as follows: The list of X such that X is taken from the list &lt;code&gt;[1,2,a,...]&lt;/code&gt; and X is greater than 3.</source>
          <target state="translated">内容如下：X的列表，使得X从列表 &lt;code&gt;[1,2,a,...]&lt;/code&gt; 中获取,并且X大于3。</target>
        </trans-unit>
        <trans-unit id="e5bbd1957b21e024367be0eb839936ca962e71f8" translate="yes" xml:space="preserve">
          <source>This is received by the client, which in turn does &lt;code&gt;exit(normal)&lt;/code&gt; and terminates. If &lt;code&gt;keysearch&lt;/code&gt; returns &lt;code&gt;{value,{From,Name}}&lt;/code&gt; it is certain that the user is logged on and that his name (peter) is in variable &lt;code&gt;Name&lt;/code&gt;.</source>
          <target state="translated">这是由客户端接收的，客户端依次 &lt;code&gt;exit(normal)&lt;/code&gt; 并终止。如果 &lt;code&gt;keysearch&lt;/code&gt; 返回 &lt;code&gt;{value,{From,Name}}&lt;/code&gt; ，则可以确定用户已登录并且其名称（字符）在变量 &lt;code&gt;Name&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="81a8f87d1727d52beaa427ce4936112ae848bc0b" translate="yes" xml:space="preserve">
          <source>This is received by the client.</source>
          <target state="translated">这是由客户收到的。</target>
        </trans-unit>
        <trans-unit id="6c40d6a299f26d7b05469a35afc3ecd07bd6f779" translate="yes" xml:space="preserve">
          <source>This is simply an erlang compatible text-file with the following structure: &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt;.</source>
          <target state="translated">这只是一个与erlang兼容的文本文件，其结构如下： &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44863f1a9281f46194959277b2c84306dd047f31" translate="yes" xml:space="preserve">
          <source>This is slightly faster for probably the most common case that the input lists are not empty or very short. (Another advantage is that Dialyzer can deduce a better type for the &lt;code&gt;Xs&lt;/code&gt; variable.)</source>
          <target state="translated">对于可能最常见的输入列表不为空或非常短的情况，这会稍微快一些。（另一个优点是Dialyzer可以为 &lt;code&gt;Xs&lt;/code&gt; 变量推断出更好的类型。）</target>
        </trans-unit>
        <trans-unit id="709cd27ea3760e45f8fdbf83a2674e3dd14b99e2" translate="yes" xml:space="preserve">
          <source>This is slightly more efficient because here you do not build a list element only to copy it directly. (Or it would be more efficient if the compiler did not automatically rewrite &lt;code&gt;[H]++Acc&lt;/code&gt; to &lt;code&gt;[H|Acc]&lt;/code&gt;.)</source>
          <target state="translated">这会稍微提高效率，因为在这里您不构建列表元素只是为了直接复制它。（或者，如果编译器不自动将 &lt;code&gt;[H]++Acc&lt;/code&gt; 重写为 &lt;code&gt;[H|Acc]&lt;/code&gt; 效率会更高）。</target>
        </trans-unit>
        <trans-unit id="4f59ec1eb2875e58bffaa8ecb426dbb6d7dc8700" translate="yes" xml:space="preserve">
          <source>This is sometimes the only way to run distributed Erlang if the Domain Name System (DNS) is not running. No communication can exist between nodes running with flag &lt;code&gt;-sname&lt;/code&gt; and those running with flag &lt;code&gt;-name&lt;/code&gt;, as node names must be unique in distributed Erlang systems.</source>
          <target state="translated">如果域名系统（DNS）未运行，则有时这是运行分布式Erlang的唯一方法。使用标志 &lt;code&gt;-sname&lt;/code&gt; 运行的节点与使用标志 &lt;code&gt;-name&lt;/code&gt; 运行的节点之间不能存在通信，因为节点名称在分布式Erlang系统中必须唯一。</target>
        </trans-unit>
        <trans-unit id="570f8642744ae6cd3a9675f1aad4ee8419ad33a1" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the equivalent, but harder to read:</source>
          <target state="translated">这是等价的句法糖,但比较难读。</target>
        </trans-unit>
        <trans-unit id="9e186bc5c4bbfebc187d81afa7fc46f64f868bc5" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the following:</source>
          <target state="translated">这是下面的句法糖。</target>
        </trans-unit>
        <trans-unit id="bb54970de95599c4474802466e4b9431c5e1008a" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;SSL/TLS&lt;/code&gt; connectin configuration option.</source>
          <target state="translated">这是 &lt;code&gt;SSL/TLS&lt;/code&gt; 连接配置选项。</target>
        </trans-unit>
        <trans-unit id="aac881df38163ed7b3cad0912165225c572fc928" translate="yes" xml:space="preserve">
          <source>This is the default handler used by OTP. Multiple instances can be started, and each instance will write log events to a given destination, terminal or file.</source>
          <target state="translated">这是OTP使用的默认处理程序。可以启动多个实例,每个实例都会将日志事件写入指定的目标、终端或文件。</target>
        </trans-unit>
        <trans-unit id="c4d57523639a2e8a475bc6496773bdbfcedee6d9" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for tables.</source>
          <target state="translated">这是表格的默认仪表功能。</target>
        </trans-unit>
        <trans-unit id="8a590bd244aa7fba225f4a56cad227855876f150" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for variables.</source>
          <target state="translated">这是变量的默认工具功能。</target>
        </trans-unit>
        <trans-unit id="0ea769a678284ef3199b2e2888a8634fc4803cb9" translate="yes" xml:space="preserve">
          <source>This is the default. It means the &lt;code&gt;Time&lt;/code&gt; value is interpreted as a time in milliseconds &lt;strong&gt;relative&lt;/strong&gt; current &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是默认值。这意味着 &lt;code&gt;Time&lt;/code&gt; 值被解释为以毫秒为单位的&lt;strong&gt;相对&lt;/strong&gt;当前 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31b3e5ab542a5f0debc59c85dd91647f80797616" translate="yes" xml:space="preserve">
          <source>This is the disk log type, &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;halt&lt;/code&gt;. The option corresponds to the &lt;code&gt;type&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是磁盘日志类型， &lt;code&gt;wrap&lt;/code&gt; 或 &lt;code&gt;halt&lt;/code&gt; 。该选项对应于 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 数据类型中的 &lt;code&gt;type&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="79cf40aec82f5e3c6c095b9a7f24df20c5c7f299" translate="yes" xml:space="preserve">
          <source>This is the fastest way of calling a driver and get a response. It makes no context switch in the Erlang emulator and requires no message passing. It is suitable for calling C function to get faster execution, when Erlang is too slow.</source>
          <target state="translated">这是调用驱动程序并获得响应的最快方式。它在Erlang仿真器中不做上下文切换,也不需要传递消息。当Erlang太慢的时候,它适合于调用C函数来获得更快的执行速度。</target>
        </trans-unit>
        <trans-unit id="f997eb6e8d88cc346ac8a25ffea65575e19dddfd" translate="yes" xml:space="preserve">
          <source>This is the first function called when a notification delivery is in progress. It informs the &lt;code&gt;receiver&lt;/code&gt; which targets will get the notification. The result of the delivery will be provided via successive calls to &lt;code&gt;delivery_info/4&lt;/code&gt; function, see below.</source>
          <target state="translated">这是在进行通知传递时调用的第一个函数。它通知 &lt;code&gt;receiver&lt;/code&gt; 哪些目标将获得通知。传递的结果将通过连续调用 &lt;code&gt;delivery_info/4&lt;/code&gt; 函数来提供，请参见下文。</target>
        </trans-unit>
        <trans-unit id="ba21277d355183275053e3909ab979314fa50468" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. It is sent just before the &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; function returns successfully. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">这是频道收到的第一条消息。它是在 &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 函数成功返回之前发送的。如果服务器希望在不首先从客户端接收消息的情况下向客户端发送消息，则此功能特别有用。如果该消息对您的特定情况没有用，请立即返回 &lt;code&gt;{ok, State}&lt;/code&gt; 忽略它。</target>
        </trans-unit>
        <trans-unit id="ff43ffc2013d60b90dbeef0ec3d72ae3abfda509" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">这是频道收到的第一条消息。如果服务器希望在不首先从客户端接收消息的情况下向客户端发送消息，则此功能特别有用。如果该消息对您的特定情况没有用，请立即返回 &lt;code&gt;{ok, State}&lt;/code&gt; 忽略它。</target>
        </trans-unit>
        <trans-unit id="f4993527ae602c81dada40230c7e4b229f40c09c" translate="yes" xml:space="preserve">
          <source>This is the full name of the disk log file. The option corresponds to the &lt;code&gt;name&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是磁盘日志文件的全名。该选项对应于 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 数据类型中的 &lt;code&gt;name&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5982af784f6f1a00b591611686e14f6193a9f84c" translate="yes" xml:space="preserve">
          <source>This is the interface module for the &lt;code&gt;SSH&lt;/code&gt; application. The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. See &lt;code&gt;ssh(6)&lt;/code&gt; for details of supported RFCs, versions, algorithms and unicode handling.</source>
          <target state="translated">这是 &lt;code&gt;SSH&lt;/code&gt; 应用程序的接口模块。安全外壳（SSH）协议是用于通过不安全网络进行安全远程登录和其他安全网络服务的协议。有关受支持的RFC，版本，算法和unicode处理的详细信息，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f80630a3cb0a4f72ab077d535fc76e765cca2dca" translate="yes" xml:space="preserve">
          <source>This is the low-level function to unload (or decrement reference counts of) a driver. It can be used to force port killing, in much the same way as the driver option &lt;code&gt;kill_ports&lt;/code&gt; implicitly does. Also, it can trigger a monitor either because other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still have the driver loaded or because open ports use the driver.</source>
          <target state="translated">这是卸载（或减少参考计数）驱动程序的底层函数。它可以用来强制端口杀死，其方式与驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 隐式执行的方式几乎相同。另外，它可能会触发监视器，原因是其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 仍在加载驱动程序，或者是因为开放端口使用了该驱动程序。</target>
        </trans-unit>
        <trans-unit id="eacd6f28e2e16d27200f6b33be43d951190f1539" translate="yes" xml:space="preserve">
          <source>This is the magic macro to initialize a NIF library. It is to be evaluated in global file scope.</source>
          <target state="translated">这是初始化NIF库的神奇宏。它将在全局文件范围内执行。</target>
        </trans-unit>
        <trans-unit id="a9ed06a82672ebce7c45ad63610c5550104e76dd" translate="yes" xml:space="preserve">
          <source>This is the main option and it controls the configuration of Reltool. It can either be a &lt;code&gt;sys&lt;/code&gt; tuple or a name of a &lt;code&gt;file&lt;/code&gt; containing a sys tuple.</source>
          <target state="translated">这是主要选项，它控制Reltool的配置。它可以是 &lt;code&gt;sys&lt;/code&gt; 元组，也可以是包含sys元组的 &lt;code&gt;file&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="3c9044a0169d5c61331b09923e7b20b8bc8aa7f2" translate="yes" xml:space="preserve">
          <source>This is the maximum allowed queue length. If the message queue grows larger than this, the handler process is terminated.</source>
          <target state="translated">这是允许的最大队列长度。如果消息队列的长度大于这个长度,处理程序进程就会终止。</target>
        </trans-unit>
        <trans-unit id="b9f45ed64c3e0c4da54fbe1eb312ba76516ad0e2" translate="yes" xml:space="preserve">
          <source>This is the maximum memory size that the handler process is allowed to use. If the handler grows larger than this, the process is terminated.</source>
          <target state="translated">这是处理程序进程允许使用的最大内存大小。如果处理程序的大小大于这个值,则该进程将被终止。</target>
        </trans-unit>
        <trans-unit id="16038a3786bdd4dedf260d26283b919a880bb676" translate="yes" xml:space="preserve">
          <source>This is the maximum number of bytes that is written to a log file before disk_log proceeds with the next file in order, or generates an error in case of a full halt log. The option corresponds to the &lt;code&gt;MaxNoBytes&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是disk_log按顺序处理下一个文件之前写入日志文件的最大字节数，或者在完全停止日志的情况下生成错误。的选项对应于 &lt;code&gt;MaxNoBytes&lt;/code&gt; 在元件 &lt;code&gt;size&lt;/code&gt; 在属性 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="459f135a3a42608f2bd3388de6fc151cb8110783" translate="yes" xml:space="preserve">
          <source>This is the maximum number of events to handle within a &lt;code&gt;burst_limit_window_time&lt;/code&gt; time frame. After the limit is reached, successive events are dropped until the end of the time frame.</source>
          <target state="translated">这是在 &lt;code&gt;burst_limit_window_time&lt;/code&gt; 时间范围内要处理的最大事件数。达到限制后，将丢弃连续的事件，直到时间范围结束为止。</target>
        </trans-unit>
        <trans-unit id="f9d007efced8ad7291f6b7473c324b69730b4bdb" translate="yes" xml:space="preserve">
          <source>This is the maximum number of files that disk_log uses for its circular logging. The option corresponds to the &lt;code&gt;MaxNoFiles&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是disk_log用于其循环日志记录的最大文件数。的选项对应于 &lt;code&gt;MaxNoFiles&lt;/code&gt; 在元件 &lt;code&gt;size&lt;/code&gt; 在属性 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="88ddfe714e0b66558fbe57136603410b11130d4d" translate="yes" xml:space="preserve">
          <source>This is the new encoding of internal funs: &lt;code&gt;fun F/A&lt;/code&gt; and &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt;.</source>
          <target state="translated">这是内部 &lt;code&gt;fun F/A&lt;/code&gt; 的新编码：fun F / A和 &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="837460bd7445a65a68a00b613c75a7744d0ed82a" translate="yes" xml:space="preserve">
          <source>This is the printout header of one process. The printout contains only this one process since we did &lt;code&gt;fprof:apply/3&lt;/code&gt; which traces only the current process. Therefore the CNT and OWN columns perfectly matches the totals above. The ACC column is undefined since summing the ACC times of all calls in the process makes no sense - you would get something like the ACC value from totals above multiplied by the average depth of the call stack, or something.</source>
          <target state="translated">这是一个进程的打印头。由于我们执行了 &lt;code&gt;fprof:apply/3&lt;/code&gt; ，因此仅打印当前进程，因此打印输出仅包含此进程。因此，CNT和OWN列与上面的总数完全匹配。ACC列是未定义的，因为将过程中所有调用的ACC时间相加是没有意义的-您将从上面的总数中得到ACC值，再乘以调用堆栈的平均深度之类的值。</target>
        </trans-unit>
        <trans-unit id="ee530acee221ac3457f1090f43fd370b8436c96d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant formatted reader. The continuation of the first call to the functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">这是可重入格式的阅读器。对函数的第一次调用的继续必须为 &lt;code&gt;[]&lt;/code&gt; 。有关可重入输入方案如何工作的完整说明，请参见Armstrong，Virding，Williams：&amp;ldquo; Erlang中的并行编程&amp;rdquo;，第13章。</target>
        </trans-unit>
        <trans-unit id="ecd4a7ad5696bedde8f5f313930da44fe12f224d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant scanner, which scans characters until either a &lt;strong&gt;dot&lt;/strong&gt; ('.' followed by a white space) or &lt;code&gt;eof&lt;/code&gt; is reached. It returns:</source>
          <target state="translated">这是可重入的扫描器，它扫描字符直到到达&lt;strong&gt;点&lt;/strong&gt;（&amp;ldquo;。&amp;rdquo;后跟空白）或 &lt;code&gt;eof&lt;/code&gt; 。它返回：</target>
        </trans-unit>
        <trans-unit id="6ad3ae21f4d6378b9390fab772b58bcf9e24057d" translate="yes" xml:space="preserve">
          <source>This is the return type from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; and selects &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; and whether to do &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, or not.</source>
          <target state="translated">这是来自 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 的返回类型，它选择 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; 以及是否进行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e8ab784b5603c6b44491c28cae41829d1e3589" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sol&lt;/code&gt;, but only for the first call to &lt;code&gt;link/1&lt;/code&gt; by the traced process.</source>
          <target state="translated">这与 &lt;code&gt;sol&lt;/code&gt; 相同，但仅适用于被跟踪进程首次调用 &lt;code&gt;link/1&lt;/code&gt; 的情况。</target>
        </trans-unit>
        <trans-unit id="5d44ec075c5224429b7e914e2c0f01b386f3e0fd" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sos&lt;/code&gt;, but only for the first process spawned by the traced process.</source>
          <target state="translated">这与 &lt;code&gt;sos&lt;/code&gt; 相同，但仅适用于被跟踪进程产生的第一个进程。</target>
        </trans-unit>
        <trans-unit id="5c9a7f10551e6fef6526100ea65361d85f3b3c5e" translate="yes" xml:space="preserve">
          <source>This is the same as calling &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与调用 &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="ae7c485681a5d5be425044d9a2ecba3267612e5e" translate="yes" xml:space="preserve">
          <source>This is the same as doing, e.g.:</source>
          <target state="translated">这与做,如。</target>
        </trans-unit>
        <trans-unit id="d70feac208b0fafbbf1031f0ed7f8654773e27d3" translate="yes" xml:space="preserve">
          <source>This is the same as:</source>
          <target state="translated">这与。</target>
        </trans-unit>
        <trans-unit id="3b5a14eeead1c5ce60108308f333bdf8d18e6154" translate="yes" xml:space="preserve">
          <source>This is the short story though, for the experienced and impatient:</source>
          <target state="translated">这虽然是短篇小说,适合有经验的人和没有耐心的人。</target>
        </trans-unit>
        <trans-unit id="5cabfd28d4ff30cee5147e828bd4dda97a0b5763" translate="yes" xml:space="preserve">
          <source>This is the standard handler for Logger. Multiple instances of this handler can be added to Logger, and each instance prints logs to &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, or to file.</source>
          <target state="translated">这是Logger的标准处理程序。可以将此处理程序的多个实例添加到Logger，每个实例将日志打印到 &lt;code&gt;standard_io&lt;/code&gt; ， &lt;code&gt;standard_error&lt;/code&gt; 或文件中。</target>
        </trans-unit>
        <trans-unit id="7d0bc914b2bcbf775df160b6a080adcaa1ab6b48" translate="yes" xml:space="preserve">
          <source>This is the start of a hiearchy of opaque data structures that can be examined with access functions in &lt;code&gt;inet_dns&lt;/code&gt;, which return lists of &lt;code&gt;{Field,Value}&lt;/code&gt; tuples. The arity 2 functions only return the value for a specified field.</source>
          <target state="translated">这是不透明的数据结构的一个hiearchy它可以与访问功能被检查的开始 &lt;code&gt;inet_dns&lt;/code&gt; ，其返回的列表 &lt;code&gt;{Field,Value}&lt;/code&gt; 元组。Arity 2函数仅返回指定字段的值。</target>
        </trans-unit>
        <trans-unit id="d98c71268352e941036bfc46f7ac63a11dac3adf" translate="yes" xml:space="preserve">
          <source>This is the sum of the runtime for all threads in the Erlang runtime system and can therefore be greater than the wall clock time.</source>
          <target state="translated">这是Erlang运行时系统中所有线程的运行时间之和,因此可以大于墙时钟时间。</target>
        </trans-unit>
        <trans-unit id="f65cd2322c237b869a90671095b9d99fc32d6542" translate="yes" xml:space="preserve">
          <source>This is the top supervisor for the agent part of the SNMP application. There is always one supervisor at each node with an SNMP agent (master agent or sub-agent).</source>
          <target state="translated">这是SNMP应用的代理部分的最高监督者。在每个有SNMP代理(主代理或子代理)的节点上总是有一个监督者。</target>
        </trans-unit>
        <trans-unit id="1c91fd8459d792120c638965b077037f75eb8c7b" translate="yes" xml:space="preserve">
          <source>This is the type definition for the supervisor flags:</source>
          <target state="translated">这是主管标志的类型定义。</target>
        </trans-unit>
        <trans-unit id="9847ce6094bdf607fe5e13ee0e480c77d4dbdfd9" translate="yes" xml:space="preserve">
          <source>This is to be added to the &lt;code&gt;start&lt;/code&gt; script.</source>
          <target state="translated">这将被添加到 &lt;code&gt;start&lt;/code&gt; 脚本中。</target>
        </trans-unit>
        <trans-unit id="9cc5dbd4b0a6027790eeb7362903f65abf0802cc" translate="yes" xml:space="preserve">
          <source>This is to provide options that changes its general behavior and &quot;sticks&quot; to the driver throughout its lifespan.</source>
          <target state="translated">这是为了提供改变其一般行为的选项,并在驱动器的整个生命周期内 &quot;坚持&quot;。</target>
        </trans-unit>
        <trans-unit id="63ab71f3a67c414cba27c6d8e2befb9085535d6d" translate="yes" xml:space="preserve">
          <source>This is transformed into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这被转换为对 &lt;code&gt;my_table&lt;/code&gt; 的一次调用：</target>
        </trans-unit>
        <trans-unit id="fad7abe2a96807b6a5b8ac7472f217897f8a19e9" translate="yes" xml:space="preserve">
          <source>This is used for &lt;strong&gt;three-way-handshake&lt;/strong&gt;.</source>
          <target state="translated">这用于&lt;strong&gt;三向握手&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="72036e52d82b37ea2fc4d48dfb5499c608ebb71d" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to non-local function &lt;code&gt;FuncSpec&lt;/code&gt; (&lt;code&gt;{Module,Func}&lt;/code&gt; or a fun) with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed. The return value &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; can be used to let the shell evaluate some other function than the one specified by &lt;code&gt;FuncSpec&lt;/code&gt; and &lt;code&gt;ArgList&lt;/code&gt;.</source>
          <target state="translated">这用于确定是否允许使用参数 &lt;code&gt;ArgList&lt;/code&gt; 调用非本地函数 &lt;code&gt;FuncSpec&lt;/code&gt; （ &lt;code&gt;{Module,Func}&lt;/code&gt; 或fun）。返回值 &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; 可用于让shell评估除 &lt;code&gt;FuncSpec&lt;/code&gt; 和 &lt;code&gt;ArgList&lt;/code&gt; 指定的函数以外的其他函数。</target>
        </trans-unit>
        <trans-unit id="d65885f8646585ffb41393b4d943ab7b9e09ca48" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to the local function &lt;code&gt;Func&lt;/code&gt; with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed.</source>
          <target state="translated">这用于确定是否允许使用参数 &lt;code&gt;ArgList&lt;/code&gt; 调用本地函数 &lt;code&gt;Func&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4567b676fadac5a76d27950b200211f3a0074958" translate="yes" xml:space="preserve">
          <source>This just tests that the function &lt;code&gt;lists:reverse(List)&lt;/code&gt; does not crash when &lt;code&gt;List&lt;/code&gt; is &lt;code&gt;[1,2,3]&lt;/code&gt;. It is not a great test, but many people write simple functions like this one to test the basic functionality of their code, and those tests can be used directly by EUnit, without changes, as long as their function names match.</source>
          <target state="translated">这只是测试 &lt;code&gt;List&lt;/code&gt; = &lt;code&gt;[1,2,3]&lt;/code&gt; 时函数 &lt;code&gt;lists:reverse(List)&lt;/code&gt; 是否不会崩溃。这不是一个很好的测试，但是许多人都编写了像这样的简单函数来测试其代码的基本功能，只要这些函数名称匹配，这些测试就可以直接由EUnit使用，而无需更改。</target>
        </trans-unit>
        <trans-unit id="fe9522c485cb7d376d5642accb7a321aad5a05ed" translate="yes" xml:space="preserve">
          <source>This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</source>
          <target state="translated">这种小括号一旦匹配,就会 &quot;锁死 &quot;它所包含的那部分模式,再往模式中的失败就无法回溯到它。不过,回溯过去到之前的项目,则可以正常工作。</target>
        </trans-unit>
        <trans-unit id="82013b529d675da98d4511e184ab7425bf09102f" translate="yes" xml:space="preserve">
          <source>This list is actually two - one for each direction server-to-client and client-to-server. Therefore it is possible but rare to have different algorithms in the two directions in one connection.</source>
          <target state="translated">这个列表实际上是两个--服务器到客户端和客户端到服务器两个方向各一个。因此,在一个连接中的两个方向上采用不同的算法是可能的,但很少见。</target>
        </trans-unit>
        <trans-unit id="cc0444143c5a31fc19d9928f133e7fc40ea61901" translate="yes" xml:space="preserve">
          <source>This list is also divided into two for the both directions</source>
          <target state="translated">此榜也分两路为两路</target>
        </trans-unit>
        <trans-unit id="4f65aaceb7dbec6b1fb6792cf70ed6c05f03495f" translate="yes" xml:space="preserve">
          <source>This list is subject to change at any time, as is the category any given lock may belong to.</source>
          <target state="translated">此列表随时可能发生变化,任何给定的锁可能属于的类别也是如此。</target>
        </trans-unit>
        <trans-unit id="8667cb466629d5430d9bcf4d289713494e360097" translate="yes" xml:space="preserve">
          <source>This macro can also be used for conditional compilation, but is more typically used to disable testing: If &lt;code&gt;NOTEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included, and &lt;code&gt;TEST&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; defined, then the code will be compiled with EUnit disabled. See also &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这个宏也可用于条件编译，但更通常用于禁用测试：如果 &lt;code&gt;NOTEST&lt;/code&gt; 定义&lt;strong&gt;之前&lt;/strong&gt;的EUnit头文件包含，并且 &lt;code&gt;TEST&lt;/code&gt; 是&lt;strong&gt;没有&lt;/strong&gt;定义的，那么代码将与EUnit禁用编译。另请参阅 &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5114889d9a6e68c62a0a1992ed05dd66a4ea6679" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is &lt;strong&gt;disabled&lt;/strong&gt; at compile time. (Compare the &lt;code&gt;TEST&lt;/code&gt; macro.)</source>
          <target state="translated">每当在编译时&lt;strong&gt;禁用&lt;/strong&gt; EUnit时，都会始终定义此宏（为 &lt;code&gt;true&lt;/code&gt; ，除非用户先前将其定义为具有另一个值）。（比较 &lt;code&gt;TEST&lt;/code&gt; 宏。）&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ace903cd27c28d656c86413693b1c2b7cebb1c45" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is enabled at compile time. This can be used to place testing code within conditional compilation; see also the macros &lt;code&gt;NOTEST&lt;/code&gt; and &lt;code&gt;EUNIT&lt;/code&gt;.</source>
          <target state="translated">每当在编译时启用EUnit时，都会始终定义此宏（为 &lt;code&gt;true&lt;/code&gt; ，除非用户先前将其定义为具有另一个值）。这可用于将测试代码放入条件编译中。另请参见宏 &lt;code&gt;NOTEST&lt;/code&gt; 和 &lt;code&gt;EUNIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0e6792b17f6782871d2727d10c5675a63bdafd" translate="yes" xml:space="preserve">
          <source>This macro is always defined to &lt;code&gt;true&lt;/code&gt; whenever EUnit is enabled at compile time. This is typically used to place testing code within conditional compilation, as in:</source>
          <target state="translated">每当在编译时启用EUnit时，此宏始终定义为 &lt;code&gt;true&lt;/code&gt; 。这通常用于将测试代码放入条件编译中，如下所示：</target>
        </trans-unit>
        <trans-unit id="f9a17853871676c0efbbea7592f31b8e2c70ba24" translate="yes" xml:space="preserve">
          <source>This macro is useful in the setup and cleanup sections of fixtures, e.g., for creating and deleting files or perform similar operating system specific tasks, to make sure that the test system is informed of any failures.</source>
          <target state="translated">这个宏在固定装置的设置和清理部分很有用,例如,用于创建和删除文件或执行类似的操作系统特定任务,以确保测试系统被告知任何故障。</target>
        </trans-unit>
        <trans-unit id="3e065ddbb311347232c6065a89455d54a53e02c6" translate="yes" xml:space="preserve">
          <source>This makes it possible to extend the protocol with optional requests and for the clients to be somewhat backward compatible.</source>
          <target state="translated">这使得协议可以通过可选的请求进行扩展,并且客户机可以在一定程度上向后兼容。</target>
        </trans-unit>
        <trans-unit id="f4d660f58a84c58c9d56e335532b3deb651bfa98" translate="yes" xml:space="preserve">
          <source>This makes the &lt;code&gt;gen_statem&lt;/code&gt; call callback function &lt;code&gt;terminate/3&lt;/code&gt; just like for a supervised server and waits for the process to terminate.</source>
          <target state="translated">这使得 &lt;code&gt;gen_statem&lt;/code&gt; 调用回调函数的 &lt;code&gt;terminate/3&lt;/code&gt; 就像受监管的服务器一样，并等待进程终止。</target>
        </trans-unit>
        <trans-unit id="d7f81c6c5bf6cf515d1e9f111e538332017866ee" translate="yes" xml:space="preserve">
          <source>This makes the fragment independent of the parentheses in the larger pattern.</source>
          <target state="translated">这使得该片段独立于大图案中的括号。</target>
        </trans-unit>
        <trans-unit id="49587f7146156380abd9cd71341e113bb523de56" translate="yes" xml:space="preserve">
          <source>This manual describes the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册将 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 应用程序描述为Erlang / Open Telecom Platform开发环境的组成部分。假定读者熟悉Erlang开发环境，这在单独的用户指南中进行了描述。</target>
        </trans-unit>
        <trans-unit id="f54f98ecb63f059bc0f3f16893d00b0178de2ead" translate="yes" xml:space="preserve">
          <source>This manual describes the Megaco application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了Megaco应用程序,它是Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的用户指南中描述。</target>
        </trans-unit>
        <trans-unit id="3565b9c0bcf6e9edf6874ed477820b3f0f6afff4" translate="yes" xml:space="preserve">
          <source>This manual describes the Reltool application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了Reltool应用,它是Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的《用户指南》中描述。</target>
        </trans-unit>
        <trans-unit id="15184424397c18e9f422c74e5e74ac83b7f03ff2" translate="yes" xml:space="preserve">
          <source>This manual describes the SNMP development tool, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了SNMP开发工具,作为Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的《用户指南》中介绍。</target>
        </trans-unit>
        <trans-unit id="193220694d15266d7cc69378ef8f2e63c4cd4f53" translate="yes" xml:space="preserve">
          <source>This match specification can be specified as the last argument to &lt;code&gt;tp&lt;/code&gt; or &lt;code&gt;tpl&lt;/code&gt;. The activated &lt;code&gt;Item&lt;/code&gt; then becomes a &lt;strong&gt;trigger&lt;/strong&gt; for sequential tracing. This means that if the item is called on a process with trace flag &lt;code&gt;call&lt;/code&gt; set, the process is &quot;contaminated&quot; with token &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">可以将此匹配规范指定为 &lt;code&gt;tp&lt;/code&gt; 或 &lt;code&gt;tpl&lt;/code&gt; 的最后一个参数。然后，激活的 &lt;code&gt;Item&lt;/code&gt; 将成为顺序跟踪的&lt;strong&gt;触发器&lt;/strong&gt;。这意味着，如果在设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; 的进程上调用该项目，则该进程被令牌 &lt;code&gt;seq_trace&lt;/code&gt; &amp;ldquo;污染&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b5770f3057dc3732a2c219c409191a4bcf36e051" translate="yes" xml:space="preserve">
          <source>This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of dynamic anchor, or &quot;I've started, so I must finish&quot;. The name of the most recently passed (*MARK) in the path is passed back when (*COMMIT) forces a match failure.</source>
          <target state="translated">这符合 &quot;xxaab&quot;,但不符合 &quot;aacaab&quot;。它可以被认为是一种动态锚,或者说 &quot;我已经开始了,所以我必须完成&quot;。当(*COMMIT)强制匹配失败时,路径中最近传递的(*MARK)的名称会被传回来。</target>
        </trans-unit>
        <trans-unit id="5a54f8d6fa87944f3859d8aacba8377d13f4ab03" translate="yes" xml:space="preserve">
          <source>This matches all characters that have the Unicode P (punctuation) property, plus those characters whose code points are less than 128 that have the S (Symbol) property.</source>
          <target state="translated">这将匹配所有具有Unicode P(标点符号)属性的字符,加上码点小于128的具有S(符号)属性的字符。</target>
        </trans-unit>
        <trans-unit id="4060f37dc8e959716bd75592eaf33dbbe9422b23" translate="yes" xml:space="preserve">
          <source>This matches characters that have glyphs that mark the page when printed. In Unicode property terms, it matches all characters with the L, M, N, P, S, or Cf properties, except for:</source>
          <target state="translated">它匹配那些在打印时有字形标记的字符。在Unicode属性中,它匹配所有具有L、M、N、P、S或Cf属性的字符,除了。</target>
        </trans-unit>
        <trans-unit id="80aa7005a5a9b662614697fc0718ba90f2d5eb3f" translate="yes" xml:space="preserve">
          <source>This matches the same characters as [:graph:] plus space characters that are not controls, that is, characters with the Zs property.</source>
          <target state="translated">这与[:graph:]加上非控制的空格字符,也就是带有Zs属性的字符相同。</target>
        </trans-unit>
        <trans-unit id="596241cc1fad7ba2b8c15f7e59f64a7ddc1befdd" translate="yes" xml:space="preserve">
          <source>This means that if there is more than one way to locate a group (and its test cases) in a path, the result of the group search operation is a number of tests, all of which are to be performed. &lt;code&gt;Common Test&lt;/code&gt; interprets a group specification that consists of a single name as follows:</source>
          <target state="translated">这意味着，如果在路径中找到一个组（及其测试用例）的方法不止一种，则组搜索操作的结果将是许多测试，所有这些测试都将执行。 &lt;code&gt;Common Test&lt;/code&gt; 解释由单个名称组成的组规范，如下所示：</target>
        </trans-unit>
        <trans-unit id="22a98636e075cad89494908c0027932db4587e6e" translate="yes" xml:space="preserve">
          <source>This means that no bit higher than 31 can be set.</source>
          <target state="translated">这意味着不能设置高于31的位。</target>
        </trans-unit>
        <trans-unit id="df996ca43fed811b9266d44d0025a342f366a979" translate="yes" xml:space="preserve">
          <source>This means that parameter values set in the other system configuration files and values set using &lt;code&gt;application:set_env/3&lt;/code&gt; are disregarded.</source>
          <target state="translated">这意味着将忽略其他系统配置文件中设置的参数值和使用 &lt;code&gt;application:set_env/3&lt;/code&gt; 设置的值。</target>
        </trans-unit>
        <trans-unit id="8f13bbc91d440e811da4676f3e7ca92ea54d9f50" translate="yes" xml:space="preserve">
          <source>This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM.</source>
          <target state="translated">这意味着,如果使用此选项降低限制,失控的正则表达式匹配可以更快地失败。默认值10,000,000被编译到Erlang虚拟机中。</target>
        </trans-unit>
        <trans-unit id="932d8129dcaf5494e901e2360eca271fe2d0ad88" translate="yes" xml:space="preserve">
          <source>This means that specifying another &lt;code&gt;.config&lt;/code&gt; file, or more &lt;code&gt;.config&lt;/code&gt; files, leads to inconsistent update of application configurations. There is, however, a syntax for &lt;code&gt;sys.config&lt;/code&gt; that allows pointing out other &lt;code&gt;.config&lt;/code&gt; files:</source>
          <target state="translated">这意味着指定另一个 &lt;code&gt;.config&lt;/code&gt; 文件或多个 &lt;code&gt;.config&lt;/code&gt; 文件会导致应用程序配置的更新不一致。但是， &lt;code&gt;sys.config&lt;/code&gt; 的语法允许指出其他 &lt;code&gt;.config&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="2200dc5ecc3e0975342e26ce8ac3610348c991da" translate="yes" xml:space="preserve">
          <source>This means that the application is preferably to be started at &lt;code&gt;cp1@cave&lt;/code&gt;. If &lt;code&gt;cp1@cave&lt;/code&gt; is down, the application is to be started at &lt;code&gt;cp2@cave&lt;/code&gt; or &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">这意味着该应用程序最好从 &lt;code&gt;cp1@cave&lt;/code&gt; 启动。如果 &lt;code&gt;cp1@cave&lt;/code&gt; 关闭，则应从 &lt;code&gt;cp2@cave&lt;/code&gt; 或 &lt;code&gt;cp3@cave&lt;/code&gt; 启动应用程序。</target>
        </trans-unit>
        <trans-unit id="106bb3bedaf49597cebe6d920a66bd4eef59b102" translate="yes" xml:space="preserve">
          <source>This means that the context (an opaque type) returned from streaming crypto functions (&lt;code&gt;hash_(init|update|final)&lt;/code&gt;, &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; and &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt;) is different and incompatible with regular builds when compiling crypto with FIPS support.</source>
          <target state="translated">这意味着从流式加密函数（ &lt;code&gt;hash_(init|update|final)&lt;/code&gt; ， &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; 和 &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt; ）返回的上下文（不透明类型）是不同的并且与常规构建不兼容。使用FIPS支持编译加密时。</target>
        </trans-unit>
        <trans-unit id="36077c72e710c444ae2797c20c5e8799b4acfa03" translate="yes" xml:space="preserve">
          <source>This means that the match specification is always a list of one or more tuples (of arity 3). The first element of the tuple is to be a pattern as described in &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The second element of the tuple is to be a list of 0 or more guard tests (described below). The third element of the tuple is to be a list containing a description of the value to return. In almost all normal cases, the list contains exactly one term that fully describes the value to return for each object.</source>
          <target state="translated">这意味着匹配规范始终是一个或多个元组（arity 3）的列表。元组的第一个元素将是 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 中描述的模式。元组的第二个元素将是0个或更多防护测试的列表（如下所述）。元组的第三个元素是一个列表，其中包含要返回的值的描述。在几乎所有正常情况下，列表仅包含一个术语，完整描述了每个对象要返回的值。</target>
        </trans-unit>
        <trans-unit id="f7aa9f1a915ce26bfe5ca3abc7eefe46479cfe4b" translate="yes" xml:space="preserve">
          <source>This means that when running, an included application is in fact part of the primary application, and a process in an included application considers itself belonging to the primary application.</source>
          <target state="translated">这意味着,当运行时,被包含的应用程序实际上是主应用程序的一部分,被包含的应用程序中的进程认为自己属于主应用程序。</target>
        </trans-unit>
        <trans-unit id="8c76b8edc5c31749772c3e7c79034a31599a007d" translate="yes" xml:space="preserve">
          <source>This mechanism causes the new versions of the emulator and core applications to run with the old version of other applications during startup. Thus, take extra care to avoid incompatibility. Incompatible changes in the core applications can in some situations be necessary. If possible, such changes are preceded by deprecation over two major releases before the actual change. To ensure the application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">这种机制会导致仿真器和核心应用程序的新版本在启动时与其他应用程序的旧版本一起运行。因此,要特别注意避免不兼容。在某些情况下,核心应用程序中不兼容的更改是必要的。如果可能的话,在实际更改之前,会先进行两个主要版本的废弃处理。为了确保应用程序不会因为不兼容的更改而崩溃,请务必尽快删除对废弃函数的任何调用。</target>
        </trans-unit>
        <trans-unit id="e3157f67a5eef33bc0f27dfb7ed55e0358006331" translate="yes" xml:space="preserve">
          <source>This message appears if &lt;code&gt;{ok, pending_driver}&lt;/code&gt; was returned from &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; for the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and then &lt;code&gt;{ok, already_loaded}&lt;/code&gt; is returned from a call to &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此消息出现如果 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 从返回 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 最后 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 驱动的，然后 &lt;code&gt;{ok, already_loaded}&lt;/code&gt; 是从一个调用返回 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7443815abce9a78b8f12e9b4a8006f7ab0678558" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway but the loading for some reason failed. The &lt;code&gt;Failure&lt;/code&gt; term is one of the errors that can be returned from &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;. The error term can be passed to &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; for translation into human readable form. Notice that the translation must be done in the same running Erlang virtual machine as the error was detected in.</source>
          <target state="translated">如果正在进行重新加载，但由于某种原因加载失败，则会出现此消息。该 &lt;code&gt;Failure&lt;/code&gt; 项是可以从返回的错误之一 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。错误项可以传递给 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 以便翻译成人类可读的形式。请注意，转换必须在检测到错误的同一运行的Erlang虚拟机中完成。</target>
        </trans-unit>
        <trans-unit id="1fd84b520be9e9ea3d84c401734e82ebe7eac97d" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway, but the requesting &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; cancelled it by dying or calling &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;unload/1&lt;/code&gt;/&lt;code&gt;unload_driver/1&lt;/code&gt;) again before it was reloaded.</source>
          <target state="translated">如果正在进行重新加载，此消息将到达，但是请求 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 通过在重新加载之前死掉或 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 调用try_unload / 2（或 &lt;code&gt;unload/1&lt;/code&gt; / &lt;code&gt;unload_driver/1&lt;/code&gt; ）来取消了该消息。</target>
        </trans-unit>
        <trans-unit id="d6bd04f8e274c08cef04fc4e45d10c02182267ab" translate="yes" xml:space="preserve">
          <source>This message is only sent to a transport process over whose &lt;code&gt;Inband-Security-Id&lt;/code&gt; configuration has indicated support for TLS.</source>
          <target state="translated">该消息仅发送到其 &lt;code&gt;Inband-Security-Id&lt;/code&gt; 配置指示支持TLS 的传输过程。</target>
        </trans-unit>
        <trans-unit id="c9fe7d956f6a48c7301aa47c203d863f991af167" translate="yes" xml:space="preserve">
          <source>This message is sent either immediately if the driver is already loaded and no reloading is pending, or when reloading is executed if reloading is pending.</source>
          <target state="translated">如果驱动程序已经加载,且没有等待重装,则立即发送该消息;如果重装等待,则在执行重装时发送。</target>
        </trans-unit>
        <trans-unit id="b59c3f75f12fd3dcb8bfccc7fe935cad829ca36a" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent if it for some reason decided to discard the pdu.</source>
          <target state="translated">如果主代理由于某种原因决定放弃pdu,则该消息由主代理发送。</target>
        </trans-unit>
        <trans-unit id="829114beb9c3f31023ae657dbb8e8d0e25c1f282" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a request is to be sent. The only request an agent can send is Inform-Request. The net if process needs to remember the request id and the Pid, and when a response is received for the request id, send it to Pid, using a &lt;code&gt;snmp_response_received&lt;/code&gt; message.</source>
          <target state="translated">当要发送请求时，此消息是从主代理发送的。代理可以发送的唯一请求是Inform-Request。净if进程需要记住请求ID和Pid，并在收到请求ID的响应时，使用 &lt;code&gt;snmp_response_received&lt;/code&gt; 消息将其发送到Pid 。</target>
        </trans-unit>
        <trans-unit id="e5f157b9c3b08af7fd2a99ceb91dfce727fcf26b" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a trap is to be sent.</source>
          <target state="translated">当要发送陷阱时,该消息由主代理发送。</target>
        </trans-unit>
        <trans-unit id="d441c31108c7576d3cbad8491a4c4b23596427f8" translate="yes" xml:space="preserve">
          <source>This message is sent if reloading was expected, but the (old) driver made itself permanent before reloading. It is also sent if the driver was permanent or statically linked-in when trying to create the monitor.</source>
          <target state="translated">如果预计要重新加载,但(旧的)驱动程序在重新加载之前就已经永久化了,则会发送此消息。如果在尝试创建监视器时,驱动程序是永久的或静态链接的,也会发送此消息。</target>
        </trans-unit>
        <trans-unit id="2a9a7c62be17cb4236568289a04568a0ca14d646" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but the driver made itself permanent before unloading. It is also sent if trying to monitor a permanent or statically linked-in driver.</source>
          <target state="translated">如果预计要卸载,但驱动程序在卸载前将自己变成了永久的,则会发送此消息。如果试图监控一个永久或静态链接的驱动程序,也会发送该消息。</target>
        </trans-unit>
        <trans-unit id="55cf023d178c69ab93cb5f5b6795668204cbf186" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but while the driver was waiting for all ports to get closed, a new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver appeared, and the unloading was cancelled.</source>
          <target state="translated">如果预期要卸载，则发送此消息，但是在驱动程序等待所有端口关闭时，出现了该驱动程序的新 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，并且取消了卸载。</target>
        </trans-unit>
        <trans-unit id="f4e7b699a7ae096287dd7808194507f6d50b3e91" translate="yes" xml:space="preserve">
          <source>This message is sent to the Net if process from a master agent as a response to a previously received request.</source>
          <target state="translated">该消息由主代理发送到Net if进程,作为对先前收到的请求的响应。</target>
        </trans-unit>
        <trans-unit id="9a28b745a2e2cc7649e2af78230f7339cfe78c45" translate="yes" xml:space="preserve">
          <source>This message is used by the release handler to find which processes that execute a certain module. The process can later be suspended and ordered to perform a code change for one of its modules.</source>
          <target state="translated">这个消息被释放处理程序用来查找执行某个模块的进程。随后可以暂停该进程,并命令该进程对其某个模块进行代码修改。</target>
        </trans-unit>
        <trans-unit id="afd8dba6b75e3f001a723a1efc9d9ff4abf7b225" translate="yes" xml:space="preserve">
          <source>This message requests that the server starts execution of the given command. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该消息请求服务器开始执行给定命令。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="e505234f686d8ab1a451d96190a8bff8adf1ec9a" translate="yes" xml:space="preserve">
          <source>This message requests that the user default shell is started at the other end. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此消息要求在另一端启动用户默认外壳程序。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="1fc986c5547b793c1d6d354a196fdaa59d4a31d9" translate="yes" xml:space="preserve">
          <source>This mode can also be activated with flag &lt;code&gt;silent&lt;/code&gt; to &lt;code&gt;erlang:trace/3&lt;/code&gt;.</source>
          <target state="translated">这种模式也可以与标志激活 &lt;code&gt;silent&lt;/code&gt; 到 &lt;code&gt;erlang:trace/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a11330d6901fd7311c10340dd7bf642645e942b" translate="yes" xml:space="preserve">
          <source>This mode fits well when you have a regular state diagram, like the ones in this chapter, which describes all events and actions belonging to a state visually around that state, and each state has its unique name.</source>
          <target state="translated">当你有一个常规的状态图时,这种模式很适合,就像本章中的状态图一样,围绕着这个状态,直观地描述属于一个状态的所有事件和动作,而且每个状态都有其唯一的名称。</target>
        </trans-unit>
        <trans-unit id="bb204752ab758821e61472ec417419d5f3d9971e" translate="yes" xml:space="preserve">
          <source>This mode is more or less a backward compatibility mode as from its introduction.</source>
          <target state="translated">从介绍来看,这种模式多少是一种后向兼容模式。</target>
        </trans-unit>
        <trans-unit id="172f14b940b1b2c6900b1372fa3316ca07a87e44" translate="yes" xml:space="preserve">
          <source>This mode works equally well when you want to focus on one event at the time or on one state at the time, but function &lt;code&gt;Module:handle_event/4&lt;/code&gt; quickly grows too large to handle without branching to helper functions.</source>
          <target state="translated">当您希望同时关注一个事件或某个时间处于一种状态时，此模式同样适用，但是功能 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 很快变得太大而无法分支到辅助函数。</target>
        </trans-unit>
        <trans-unit id="5fdef418c42eba77018e8e42460b63d278950bac" translate="yes" xml:space="preserve">
          <source>This model has only three different tables, and the employee records contain references to other records. The record has the following references:</source>
          <target state="translated">这个模型只有三个不同的表,雇员记录包含对其他记录的引用。该记录有以下引用:</target>
        </trans-unit>
        <trans-unit id="b3ce72021e00b147c9199fb77c9a3762a844a3df" translate="yes" xml:space="preserve">
          <source>This module also provides facilities for displaying status information about interpreted processes and break points.</source>
          <target state="translated">该模块还提供了显示解释过程和断点的状态信息的功能。</target>
        </trans-unit>
        <trans-unit id="817190ceec75c6fa4d3197e4a1b86534327d94e7" translate="yes" xml:space="preserve">
          <source>This module also supports the following annotations, which are used by various modules:</source>
          <target state="translated">本模块还支持以下注解,这些注解被各种模块使用。</target>
        </trans-unit>
        <trans-unit id="c1519372f968a7c83f80d29c6d04dbd62347e6bd" translate="yes" xml:space="preserve">
          <source>This module archives and extract files to and from a tar file. This module supports reading most common tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions to the USTAR format (sparse files most notably). It produces tar archives in USTAR format, unless the files being archived require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As such, &lt;code&gt;erl_tar&lt;/code&gt; supports tar archives produced by most all modern tar utilities, and produces tarballs which should be similarly portable.</source>
          <target state="translated">此模块将文件归档并解压缩到tar文件中。该模块支持读取最常见的tar格式，即v7，STAR，USTAR和PAX，以及一些GNU tar对USTAR格式的扩展（最稀疏的文件）。它会以USTAR格式生成tar存档，除非由于USTAR的限制（例如unicode元数据，文件名长度等）而使要存档的文件需要PAX格式。这样， &lt;code&gt;erl_tar&lt;/code&gt; 支持大多数现代tar实用程序生成的tar存档，并生成应具有类似可移植性的tarball。</target>
        </trans-unit>
        <trans-unit id="c93dc94853da5f65dd0f19dd1ea05a3d6a2b52f1" translate="yes" xml:space="preserve">
          <source>This module archives and extracts files to and from a zip archive. The zip format is specified by the &quot;ZIP Appnote.txt&quot; file, available on the PKWARE web site &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块将文件归档并从zip归档中提取文件。压缩格式由PKWARE网站 &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt; 上的&amp;ldquo; ZIP Appnote.txt&amp;rdquo;文件指定。</target>
        </trans-unit>
        <trans-unit id="5ebed77e7881e24d9d50b032e03940e9bdf36b09" translate="yes" xml:space="preserve">
          <source>This module can also be found in the &lt;code&gt;examples&lt;/code&gt; directory of the SASL application.</source>
          <target state="translated">该模块也可以在SASL应用程序的 &lt;code&gt;examples&lt;/code&gt; 目录中找到。</target>
        </trans-unit>
        <trans-unit id="1aca0b6e822b7c6d0a2dee5904564049e299817d" translate="yes" xml:space="preserve">
          <source>This module can also be viewed as a behaviour for an application implemented according to the OTP design principles as a supervision tree. The definition of how to start and stop the tree is to be located in an &lt;strong&gt;application callback module&lt;/strong&gt;, exporting a predefined set of functions.</source>
          <target state="translated">该模块也可以看作是根据OTP设计原则实现的应用程序的行为，它是监督树。如何启动和停止树的定义位于&lt;strong&gt;应用程序回调模块中&lt;/strong&gt;，并导出一组预定义的函数。</target>
        </trans-unit>
        <trans-unit id="46fe9ebbf441b09ed18ab05af78ee6b86682c8d6" translate="yes" xml:space="preserve">
          <source>This module can be used as follows:</source>
          <target state="translated">该模块可用于以下方面:</target>
        </trans-unit>
        <trans-unit id="686c65b4a65c34ff9cf138f3076e44dd59452f8f" translate="yes" xml:space="preserve">
          <source>This module can be used to run a set of Erlang nodes as a pool of computational processors. It is organized as a master and a set of slave nodes and includes the following features:</source>
          <target state="translated">这个模块可以用来运行一组Erlang节点作为计算处理器池。它被组织成一个主节点和一组从节点,包括以下功能。</target>
        </trans-unit>
        <trans-unit id="af82f371bff5810258c512bac2aa2370e799470c" translate="yes" xml:space="preserve">
          <source>This module communicates with the EPMD daemon, see &lt;code&gt;epmd&lt;/code&gt;. To implement your own epmd module please see &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt;</source>
          <target state="translated">该模块与EPMD守护程序通信，请参阅 &lt;code&gt;epmd&lt;/code&gt; 。要实现自己的epmd模块，请参阅《 &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b4ce3dec0f26e77853815afd7b3cb63b31d970f" translate="yes" xml:space="preserve">
          <source>This module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">当且仅当两个元素的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将其视为不同的元素。</target>
        </trans-unit>
        <trans-unit id="0be9d79105e371fa97debd95b84b58219b4279ea" translate="yes" xml:space="preserve">
          <source>This module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">当且仅当两个键的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将其视为不同的键。</target>
        </trans-unit>
        <trans-unit id="f7838291047ac4d60e0139ec156a7e643ad4faaa" translate="yes" xml:space="preserve">
          <source>This module consists of the following services:</source>
          <target state="translated">本模块由以下服务组成:</target>
        </trans-unit>
        <trans-unit id="ff598a317fac529d717bd1f848d0ec9eaa2f5e61" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting between different character representations. It converts between ISO Latin-1 characters and Unicode characters, but it can also convert between different Unicode encodings (like UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">这个模块包含了在不同字符表示之间进行转换的功能。它可以在ISO Latin-1字符和Unicode字符之间进行转换,也可以在不同的Unicode编码之间进行转换(如UTF-8、UTF-16和UTF-32)。</target>
        </trans-unit>
        <trans-unit id="b5b9240d86d995a89ac9eb37eda08d6f1ac2c51e" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; can be used for flattening deep lists.</source>
          <target state="translated">该模块包含用于在字符串（字符列表）之间进行转换的函数。它们用于实现 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 模块中的功能。无法保证从某些函数返回的字符列表是平坦的，它们可以是深列表。功能 &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; 可用于平整深层列表。</target>
        </trans-unit>
        <trans-unit id="837f779fb53a71d0c4ae19998076438feb1919ac" translate="yes" xml:space="preserve">
          <source>This module contains functions for encoding Erlang terms into a sequence of bytes, and for decoding Erlang terms from a sequence of bytes.</source>
          <target state="translated">这个模块包含了将Erlang术语编码成字节序列,以及将Erlang术语从字节序列中解码的函数。</target>
        </trans-unit>
        <trans-unit id="de911f7e348fe07047fba5ab0f536e33890e3df9" translate="yes" xml:space="preserve">
          <source>This module contains functions for inserting comments, described by position, indentation and text, as attachments on an abstract syntax tree, at the correct places.</source>
          <target state="translated">这个模块包含了用于插入注释的功能,这些注释由位置、缩进和文本描述,作为抽象语法树上的附件,放在正确的位置。</target>
        </trans-unit>
        <trans-unit id="59032641754c334d2119d69e35fd6099ad62842c" translate="yes" xml:space="preserve">
          <source>This module contains functions for list processing.</source>
          <target state="translated">该模块包含列表处理的功能。</target>
        </trans-unit>
        <trans-unit id="81e43c82257cd393c01258396233b38bac085577" translate="yes" xml:space="preserve">
          <source>This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang.</source>
          <target state="translated">这个模块包含了用于操作面向字节的二进制文件的函数。虽然大部分函数可以使用位元语法来提供,但这个库中的函数是高度优化的,预计会比纯Erlang编写的函数执行得更快或消耗更少的内存,或者两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="50ccc7ec1143773aaedcc8657aa657008607be3a" translate="yes" xml:space="preserve">
          <source>This module contains functions for maps processing.</source>
          <target state="translated">该模块包含地图处理的功能。</target>
        </trans-unit>
        <trans-unit id="50f0b83fe2516bf67a941d2bd6474f61aeee90ee" translate="yes" xml:space="preserve">
          <source>This module contains functions for parsing and handling URIs (&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;) and form-urlencoded query strings (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此模块包含用于解析和处理URI（ &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; ）和表单编码的查询字符串（ &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; ）的函数。</target>
        </trans-unit>
        <trans-unit id="ca7843662571b136297297d4631b70479e539fd0" translate="yes" xml:space="preserve">
          <source>This module contains functions for sending system messages used by programs, and messages used for debugging purposes.</source>
          <target state="translated">该模块包含了发送程序使用的系统消息和用于调试的消息的功能。</target>
        </trans-unit>
        <trans-unit id="49fe7206d616c14253dcbc198d4a64077934564a" translate="yes" xml:space="preserve">
          <source>This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge.</source>
          <target state="translated">这个模块包含对文件中的术语进行排序,合并已经排序的文件,以及检查文件的排序性的功能。从文件序列中读取包含二进制术语的块,在内存中进行内部排序并写入临时文件,合并后产生一个排序文件作为输出。合并是作为一种优化提供的;当文件已经排序时,它的速度更快,但它总是工作在排序而不是合并上。</target>
        </trans-unit>
        <trans-unit id="5326d602d1276804a6e5daef142fc199cc00ce06" translate="yes" xml:space="preserve">
          <source>This module contains functions for tokenizing (scanning) characters into Erlang tokens.</source>
          <target state="translated">该模块包含将字符标记化(扫描)为Erlang标记的功能。</target>
        </trans-unit>
        <trans-unit id="994f1f991d1dfea12bae127e267a7c21607503f3" translate="yes" xml:space="preserve">
          <source>This module contains functions to generate boot scripts (&lt;code&gt;.boot&lt;/code&gt;, &lt;code&gt;.script&lt;/code&gt;), a release upgrade file (&lt;code&gt;relup&lt;/code&gt;), and release packages.</source>
          <target state="translated">该模块包含用于生成引导脚本（ &lt;code&gt;.boot&lt;/code&gt; ， &lt;code&gt;.script&lt;/code&gt; ），发行升级文件（ &lt;code&gt;relup&lt;/code&gt; ）和发行包的函数。</target>
        </trans-unit>
        <trans-unit id="cfb41f0bba62101238346d92d97629a2935e3299" translate="yes" xml:space="preserve">
          <source>This module contains interface functions for the SSL/TLS/DTLS protocol. For detailed information about the supported standards see &lt;code&gt;ssl(6)&lt;/code&gt;.</source>
          <target state="translated">该模块包含SSL / TLS / DTLS协议的接口功能。有关支持的标准的详细信息，请参见 &lt;code&gt;ssl(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb4c286324503fe5462bf11f1a2d003718ad9829" translate="yes" xml:space="preserve">
          <source>This module contains regular expression matching functions for strings and binaries.</source>
          <target state="translated">这个模块包含了字符串和二进制文件的正则表达式匹配函数。</target>
        </trans-unit>
        <trans-unit id="ef53274b9322e757bb4063af4f3183c6e84d40a8" translate="yes" xml:space="preserve">
          <source>This module contains services similar to Remote Procedure Calls. It also contains broadcast facilities and parallel evaluators. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</source>
          <target state="translated">该模块包含类似于远程过程调用的服务。它还包含广播设施和并行评估器。远程过程调用是一种在远程节点上调用一个函数并收集答案的方法,它用于收集远程节点上的信息,或者在远程节点上运行一个具有特定副作用的函数。它用于收集远程节点上的信息,或者在远程节点上运行一个具有特定副作用的函数。</target>
        </trans-unit>
        <trans-unit id="d58b9a536ce590d194f2de76046ad6eb75d92d75" translate="yes" xml:space="preserve">
          <source>This module contains some error printing routines taken from &quot;Advanced Programming in the UNIX Environment&quot; by W. Richard Stevens.</source>
          <target state="translated">这个模块包含了一些错误打印例程,这些例程来自于W.Richard Stevens的《UNIX环境下的高级编程》。</target>
        </trans-unit>
        <trans-unit id="d4648e09f07ca512b563c45755d232665770d52a" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the Erlang &lt;strong&gt;code server&lt;/strong&gt;, which deals with the loading of compiled code into a running Erlang runtime system.</source>
          <target state="translated">该模块包含Erlang &lt;strong&gt;代码服务器&lt;/strong&gt;的接口，该&lt;strong&gt;服务器&lt;/strong&gt;负责将已编译的代码加载到正在运行的Erlang运行时系统中。</target>
        </trans-unit>
        <trans-unit id="f512252f459f62899c4ec02d14e4f592e80d6fd9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the TPKT (TCP/IP) version transport protocol for Megaco/H.248.</source>
          <target state="translated">该模块包含了Megaco/H.248的TPKT(TCP/IP)版本传输协议的公共接口。</target>
        </trans-unit>
        <trans-unit id="e64245c6a67eefbaeb52b73410ca5898d27decb3" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the UDP/IP version transport protocol for Megaco/H.248.</source>
          <target state="translated">该模块包含Megaco/H.248的UDP/IP版本传输协议的公共接口。</target>
        </trans-unit>
        <trans-unit id="b0c49b48d28a03a73e07c75bceac59af417062b9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the flex scanner linked in driver. The flex scanner performs the scanning phase of text message decoding.</source>
          <target state="translated">该模块包含了与驱动中链接的flex扫描仪的公共接口。flex扫描仪执行文本信息解码的扫描阶段。</target>
        </trans-unit>
        <trans-unit id="028411a6308d39aee0db1a739a433763a7fa1e96" translate="yes" xml:space="preserve">
          <source>This module contains two routines: one general function for creating Erlang terms and one for pattern matching Erlang terms.</source>
          <target state="translated">这个模块包含两个例程:一个是用于创建Erlang术语的通用函数,一个是用于模式匹配Erlang术语的函数。</target>
        </trans-unit>
        <trans-unit id="43a0c1ee918b2bf11b8612b0b536425a9de08920" translate="yes" xml:space="preserve">
          <source>This module contains utilities on a higher level than the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">该模块包含比 &lt;code&gt;file&lt;/code&gt; 模块更高级别的实用程序。</target>
        </trans-unit>
        <trans-unit id="75ca3e4fb9bfa2cb08015503e443bec03d7d012f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for easier measurement and calculation of scheduler utilization, otherwise obtained from calling the more primitive &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt;.</source>
          <target state="translated">此模块包含实用程序函数，这些函数可以更方便地测量和计算调度程序利用率，否则可以通过调用更原始的 &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8466a816803c9602c9c5da297825fe2d8738a12f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for working with the abstract data type defined in the module &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块包含实用程序函数，用于处理模块 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 中定义的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="6db7bd57b934dc58f231a5b9efdb7c6ce8fb29e8" translate="yes" xml:space="preserve">
          <source>This module contains various network utility functions.</source>
          <target state="translated">该模块包含各种网络实用功能。</target>
        </trans-unit>
        <trans-unit id="0d60840cdb8394c4bebe2baf925c2e4db6023faa" translate="yes" xml:space="preserve">
          <source>This module controls that the conditions in the requests are fulfilled. For example, a request can specify that the answer only is of interest if the content is unchanged since the last retrieval. If the content is changed, the range request is to be converted to a request for the whole file instead.</source>
          <target state="translated">这个模块可以控制请求中的条件是否得到满足。例如,一个请求可以指定只有当内容自上次检索以来没有变化时,才对答案感兴趣。如果内容发生了变化,则要将范围请求转换为对整个文件的请求。</target>
        </trans-unit>
        <trans-unit id="fe422acfcd694c2630daf21b44a7f9f2a2d5de80" translate="yes" xml:space="preserve">
          <source>This module deals with the composition and decomposition of &lt;strong&gt;syntactic&lt;/strong&gt; entities (as opposed to semantic ones); its purpose is to hide all direct references to the data structures used to represent these entities. With few exceptions, the functions in this module perform no semantic interpretation of their inputs, and in general, the user is assumed to pass type-correct arguments - if this is not done, the effects are not defined.</source>
          <target state="translated">该模块处理&lt;strong&gt;语法&lt;/strong&gt;实体（与语义实体相对）的组成和分解；其目的是隐藏对用于表示这些实体的数据结构的所有直接引用。除少数例外，此模块中的功能不对其输入进行语义解释，通常，假定用户传递类型正确的参数-如果不这样做，则效果未定义。</target>
        </trans-unit>
        <trans-unit id="cfa2f96a0a3bfeb4a366115418ce75043dff5047" translate="yes" xml:space="preserve">
          <source>This module defines Erlang BIFs, guard tests, and operators. This module is only of interest to programmers who manipulate Erlang code.</source>
          <target state="translated">这个模块定义了Erlang BIF、防护测试和操作符。这个模块只对操作Erlang代码的程序员感兴趣。</target>
        </trans-unit>
        <trans-unit id="b03bc08e3947730353e9a2f08b1653a85fdf21af" translate="yes" xml:space="preserve">
          <source>This module defines a callback behavior for user-defined hash functions of fragmented tables.</source>
          <target state="translated">该模块为用户定义的碎片表的哈希函数定义了一个回调行为。</target>
        </trans-unit>
        <trans-unit id="76441fb4ee13017766943030861f4ce7688ed9bd" translate="yes" xml:space="preserve">
          <source>This module defines an abstract data type for representing Erlang source code as syntax trees, in a way that is backwards compatible with the data structures created by the Erlang standard library parser module &lt;code&gt;erl_parse&lt;/code&gt; (often referred to as &quot;parse trees&quot;, which is a bit of a misnomer). This means that all &lt;code&gt;erl_parse&lt;/code&gt; trees are valid abstract syntax trees, but the reverse is not true: abstract syntax trees can in general not be used as input to functions expecting an &lt;code&gt;erl_parse&lt;/code&gt; tree. However, as long as an abstract syntax tree represents a correct Erlang program, the function &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; should be able to transform it to the corresponding &lt;code&gt;erl_parse&lt;/code&gt; representation.</source>
          <target state="translated">该模块定义了一种抽象数据类型，用于将Erlang源代码表示为语法树，其方式与Erlang标准库解析器模块 &lt;code&gt;erl_parse&lt;/code&gt; （通常称为&amp;ldquo; parse tree&amp;rdquo;）创建的数据结构向后兼容。用词不当）。这意味着所有 &lt;code&gt;erl_parse&lt;/code&gt; 树都是有效的抽象语法树，但事实并非如此：抽象语法树通常不能用作期望 &lt;code&gt;erl_parse&lt;/code&gt; 树的函数的输入。但是，只要抽象语法树表示正确的Erlang程序，函数 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 应该能够将其转换为相应的 &lt;code&gt;erl_parse&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="e69c1a93aecab552763a38625c306d9fb09103f6" translate="yes" xml:space="preserve">
          <source>This module defines the Erlang Server Interface (ESI) API. It is a more efficient way of writing Erlang scripts for your &lt;code&gt;Inets&lt;/code&gt; web server than writing them as common CGI scripts.</source>
          <target state="translated">该模块定义Erlang服务器接口（ESI）API。与将它们编写为常见的CGI脚本相比，这是一种为 &lt;code&gt;Inets&lt;/code&gt; Web服务器编写Erlang脚本的更有效的方法。</target>
        </trans-unit>
        <trans-unit id="392313e4002a7778328cfb59fce4c77f8c1952d5" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib storage.</source>
          <target state="translated">该模块定义了SNMP代理mib存储的行为。</target>
        </trans-unit>
        <trans-unit id="7eff1b562e4fe0566ee0da7f6a9daaa2439e2f8b" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib-server data module. A &lt;code&gt;snmpa_mib_data&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义SNMP代理mib-server数据模块的行为。一个 &lt;code&gt;snmpa_mib_data&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="b0d76e366c3f9dcdfb5f12def1540b4e052163ce" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent discovery handler. A &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义代理发现处理程序的行为。一个 &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="e43530aefc8fe67ce3e1a2b7e5683063982513d3" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent error reporting. A &lt;code&gt;snmpa_error_report&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理错误报告的行为。一个 &lt;code&gt;snmpa_error_report&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="d81fb92749352083b3ab6bc64e61e21bf25c9749" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface filter. A &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理程序网络接口过滤器的行为。一个 &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="5412a13932b854a89270a84f2ceaaa33588e1121" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface. A &lt;code&gt;snmpa_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义代理网络接口的行为。一个 &lt;code&gt;snmpa_network_interface&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="3c921e60f1fd55471b897ea29e000de7226f0bb1" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent notification filters. A &lt;code&gt;snmpa_notification_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理通知过滤器的行为。一个 &lt;code&gt;snmpa_notification_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="8c813e504362483e091dd45b65c32a63841d6a1d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface filter. A &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义管理器网络接口过滤器的行为。一个 &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="1efae6ac4d1c40501e88954337a2c493e68e0103" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface. A &lt;code&gt;snmpm_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义管理器网络接口的行为。一个 &lt;code&gt;snmpm_network_interface&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="70cf854e5d6063f7072b44e1cece8ac9b81a70b7" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager user. A &lt;code&gt;snmpm_user&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义管理员用户的行为。一个 &lt;code&gt;snmpm_user&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="468ccfe9ae0121bf6da5c3aaba9a0e4a3f14050d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the notification delivery information receiver.</source>
          <target state="translated">该模块定义了通知传递信息接收者的行为。</target>
        </trans-unit>
        <trans-unit id="118517391ac279d58d25f1693b404c970b02d3e5" translate="yes" xml:space="preserve">
          <source>This module defines the callback behaviour of Megaco users. A megaco_user compliant callback module must export the following functions:</source>
          <target state="translated">这个模块定义了Megaco用户的回调行为。一个符合megaco_user标准的回调模块必须输出以下函数。</target>
        </trans-unit>
        <trans-unit id="4c8aaa7d34274a9f4bb7dc956dc47a8e7e1445eb" translate="yes" xml:space="preserve">
          <source>This module defines what happens when certain types of errors occur.</source>
          <target state="translated">该模块定义了当某些类型的错误发生时的情况。</target>
        </trans-unit>
        <trans-unit id="5ffa259dadc9ae103670240a5de8cb07d4a0a997" translate="yes" xml:space="preserve">
          <source>This module does not support &quot;raw&quot; filenames (that is, files whose names do not comply with the expected encoding). Such files are ignored by the functions in this module.</source>
          <target state="translated">本模块不支持 &quot;原始 &quot;文件名(即文件名不符合预期的编码)。本模块的功能会忽略这些文件。</target>
        </trans-unit>
        <trans-unit id="d6653760221ddc3d83e211cede6e8be096bb7928" translate="yes" xml:space="preserve">
          <source>This module enables C-programs to communicate with Erlang nodes, using the Erlang distribution over TCP/IP.</source>
          <target state="translated">该模块使C程序能够与Erlang节点通信,使用Erlang发行版通过TCP/IP进行通信。</target>
        </trans-unit>
        <trans-unit id="263e76116a98bb1fd881761f209bf1ba1fce107d" translate="yes" xml:space="preserve">
          <source>This module enables users to enter the short form of some commonly used commands.</source>
          <target state="translated">该模块使用户可以输入一些常用命令的简写。</target>
        </trans-unit>
        <trans-unit id="3343ff3168dd5f14d02286d39c2ac78ec614ecd9" translate="yes" xml:space="preserve">
          <source>This module expands records in a module.</source>
          <target state="translated">本模块可扩展模块中的记录。</target>
        </trans-unit>
        <trans-unit id="a3732061720e8ab1db0a300e706fb90768269889" translate="yes" xml:space="preserve">
          <source>This module exports functions for running &lt;code&gt;Common Test&lt;/code&gt; nodes on multiple hosts in parallel.</source>
          <target state="translated">此模块导出用于在多个主机上并行运行 &lt;code&gt;Common Test&lt;/code&gt; 节点的功能。</target>
        </trans-unit>
        <trans-unit id="0503901901ce52a8d8d522c2fc6e6ad11e2ed29f" translate="yes" xml:space="preserve">
          <source>This module exports functions used by the &lt;code&gt;Common Test&lt;/code&gt; Master to start and stop &quot;slave&quot; nodes. It is the default callback module for the &lt;code&gt;{init, node_start}&lt;/code&gt; term in the Test Specification.</source>
          <target state="translated">此模块导出 &lt;code&gt;Common Test&lt;/code&gt; 主设备用来启动和停止&amp;ldquo;从&amp;rdquo;节点的功能。它是测试规范中 &lt;code&gt;{init, node_start}&lt;/code&gt; 术语的默认回调模块。</target>
        </trans-unit>
        <trans-unit id="5c1c8fa2fdb9c360a27bfb55873d503a480bf994" translate="yes" xml:space="preserve">
          <source>This module exports help functions for parsing of test specifications.</source>
          <target state="translated">该模块输出帮助函数,用于解析测试规范。</target>
        </trans-unit>
        <trans-unit id="a7e44b5175c847fa8191a306063c634fed83971d" translate="yes" xml:space="preserve">
          <source>This module exports help functions for performing code coverage analysis.</source>
          <target state="translated">该模块输出帮助函数,用于执行代码覆盖率分析。</target>
        </trans-unit>
        <trans-unit id="eb5bfcc59cc41439eaa702f52ecbd01d0b73eb7d" translate="yes" xml:space="preserve">
          <source>This module generates an HTML directory listing (Apache-style) if a client sends a request for a directory instead of a file. This module must be removed from the Modules config directive if directory listings is unwanted.</source>
          <target state="translated">如果客户端发送一个目录而不是文件的请求,这个模块会生成一个HTML目录列表(Apache风格)。如果不需要目录列表,必须从模块配置指令中删除该模块。</target>
        </trans-unit>
        <trans-unit id="ebf8cc7dad040f1beca78868efd260f249334a6e" translate="yes" xml:space="preserve">
          <source>This module handles invoking of CGI scripts.</source>
          <target state="translated">该模块处理CGI脚本的调用。</target>
        </trans-unit>
        <trans-unit id="474f6eb9d78d082e8b16b40b4a1c3de1a0cc963c" translate="yes" xml:space="preserve">
          <source>This module has been deprecated and will be removed in a furture release.</source>
          <target state="translated">该模块已被废止,将在后续版本中删除。</target>
        </trans-unit>
        <trans-unit id="20277e2186104d73a70c009c74886d168752fafa" translate="yes" xml:space="preserve">
          <source>This module has been reworked in Erlang/OTP 20 to handle &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; and operate on grapheme clusters. The &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release.</source>
          <target state="translated">此模块已在Erlang / OTP 20中进行了重新处理，以处理 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 并在字素簇上运行。只能在Latin-1列表上作为输入使用的 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; 仍然可用，但不应使用，在以后的版本中将不推荐使用。</target>
        </trans-unit>
        <trans-unit id="e92193f0e2766adbb07bff2f6dfb2e47b5b38666" translate="yes" xml:space="preserve">
          <source>This module has three sets of interface functions: the &quot;Original API&quot;, the &quot;Extended API&quot;, and the &quot;Okasaki API&quot;.</source>
          <target state="translated">该模块有三组接口函数:&quot;原始API&quot;、&quot;扩展API &quot;和 &quot;冈崎API&quot;。</target>
        </trans-unit>
        <trans-unit id="e94b28ea5c396cd8b2c46ddc4551b34a14bfd479" translate="yes" xml:space="preserve">
          <source>This module implements a client for file transfer according to a subset of the File Transfer Protocol (FTP), see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此模块根据文件传输协议（FTP）的子集实现用于文件传输的客户端，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b25912bf3af7bf1193b3fff50e47205181300228" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec measurement tool.</source>
          <target state="translated">该模块实现了一个简单的megaco编解码器测量工具。</target>
        </trans-unit>
        <trans-unit id="871eeb782d63d6630dd6a5d492a7b58d86850778" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了一个简单的基于megaco编解码器的性能工具。</target>
        </trans-unit>
        <trans-unit id="f9179ddef6a9ee16329a9f709abd6d55eba87a03" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco message transformation utility.</source>
          <target state="translated">该模块实现了一个简单的megaco消息转换工具。</target>
        </trans-unit>
        <trans-unit id="509079930c0c0a8b4797c4ad9534704e9e78b720" translate="yes" xml:space="preserve">
          <source>This module implements a text based interface to the &lt;code&gt;trace/3&lt;/code&gt; and the &lt;code&gt;trace_pattern/2&lt;/code&gt; BIFs. It makes it possible to trace functions, processes, ports and messages.</source>
          <target state="translated">该模块为 &lt;code&gt;trace/3&lt;/code&gt; 和 &lt;code&gt;trace_pattern/2&lt;/code&gt; BIF实现了基于文本的接口。它使跟踪功能，过程，端口和消息成为可能。</target>
        </trans-unit>
        <trans-unit id="c2d643bd7191e32f2c51494e11bf58ee73f4a435" translate="yes" xml:space="preserve">
          <source>This module implements an SSH FTP (SFTP) client. SFTP is a secure, encrypted file transfer service available for SSH.</source>
          <target state="translated">该模块实现了一个SSH FTP(SFTP)客户端。SFTP是一种安全的、加密的、适用于SSH的文件传输服务。</target>
        </trans-unit>
        <trans-unit id="03ef132a9564d822dda1f23634bee22efb87c0be" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over SCTP using &lt;code&gt;gen_sctp(3)&lt;/code&gt;. It can be specified as the value of a transport_module option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块使用 &lt;code&gt;gen_sctp(3)&lt;/code&gt; 在SCTP上实现直径传输。可以将其指定为 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 的transport_module选项的值，并实现在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 中记录的行为。</target>
        </trans-unit>
        <trans-unit id="88cb8b49f73b329262758743b81d712fdab5c653" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over TCP using &lt;code&gt;gen_tcp(3)&lt;/code&gt;. It can be specified as the value of a &lt;code&gt;transport_module&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. TLS security is supported, either as an upgrade following capabilities exchange or at connection establishment.</source>
          <target state="translated">该模块使用 &lt;code&gt;gen_tcp(3)&lt;/code&gt; 在TCP上实现直径传输。可以将其指定为 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;transport_module&lt;/code&gt; 选项的值，并实现在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 中记录的行为。支持TLS安全性，可以作为功能交换后的升级或建立连接时使用。</target>
        </trans-unit>
        <trans-unit id="9266c44a4ba8cd9ee1a5c81b4c58c87a30706c84" translate="yes" xml:space="preserve">
          <source>This module implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments are added. It is well suited for scalable hash tables.</source>
          <target state="translated">这个模块实现了动态哈希,这是一种当新的碎片加入时,会很好地增长的哈希。它非常适合于可扩展的哈希表。</target>
        </trans-unit>
        <trans-unit id="237af1ed7b14daa8c6a596b37b3d9e9e2855eee1" translate="yes" xml:space="preserve">
          <source>This module implements interfaces to dynamic tracing, should such be compiled into the virtual machine. For a standard and/or commercial build, no dynamic tracing is available, in which case none of the functions in this module is usable or give any effect.</source>
          <target state="translated">该模块实现了动态跟踪的接口,如果将其编译到虚拟机中的话。对于标准的和/或商业的构建,没有动态跟踪,在这种情况下,本模块中的任何功能都不能使用或产生任何效果。</target>
        </trans-unit>
        <trans-unit id="5567e19229f23540f47010e8b1ddd342e185fa20" translate="yes" xml:space="preserve">
          <source>This module implements process groups. Each message can be sent to one, some, or all group members.</source>
          <target state="translated">该模块实现了流程组。每条消息可以发送给一个、部分或所有组成员。</target>
        </trans-unit>
        <trans-unit id="81520061930d4cb81104030ae03956c22721f688" translate="yes" xml:space="preserve">
          <source>This module implements some convenience functions for analyzing microstate accounting data. For details about how to use the basic api and what the different states represent see &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt;.</source>
          <target state="translated">该模块实现了一些方便的功能，用于分析微状态会计数据。有关如何使用基本api以及不同状态表示什么的详细信息，请参见 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d15b1e9aa28423920ee271c9eb3d3a739153bbd9" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone1&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了&lt;strong&gt;mstone1&lt;/strong&gt;工具，这是一个简单的基于&lt;strong&gt;megaco&lt;/strong&gt;编解码器的性能工具。</target>
        </trans-unit>
        <trans-unit id="251e35996e11df5d3eaaaf86f280ba3afa349ebe" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone2&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了&lt;strong&gt;mstone2&lt;/strong&gt;工具，这是一个简单的基于&lt;strong&gt;megaco&lt;/strong&gt;编解码器的性能工具。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
